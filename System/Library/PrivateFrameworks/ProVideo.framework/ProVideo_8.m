uint64_t Gettype4_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  __int128 v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int8x16_t *v71;
  int v72;
  uint64_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v72 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v14, *((int8x16_t *)a2 + 76)), 3);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((_OWORD *)a2 + 1);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = vaddq_f32(v16, v19);
      v21 = *((int8x16_t *)a2 + 19);
      v22 = *((float32x4_t *)a2 + 20);
      v23 = vaddq_f32(v17, v19);
      v24 = *((float32x4_t *)a2 + 5);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v24);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v23), (int8x16_t)v24);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v22, v23)));
      v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v22, v20))), v28);
      v31 = *((float32x4_t *)a2 + 23);
      v32 = *((float32x4_t *)a2 + 24);
      v33 = vsubq_f32(v29, v28);
      v34 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v31));
      v35 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v26, v31));
      v36 = vaddq_f32(v30, v34);
      v37 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v32, v34), v25));
      v38 = vsubq_f32(vsubq_f32(v26, v24), vmulq_f32(vmulq_f32(v32, v35), v26));
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v43 = *((float32x4_t *)a2 + 27);
      v44 = *((float32x4_t *)a2 + 28);
      v45 = vmulq_n_f32(vaddq_f32(vaddq_f32(v33, v35), vmulq_f32(v38, vaddq_f32(vaddq_f32(v43, vmulq_f32(v38, v44)), vmulq_f32(vmulq_f32(v38, v38), v42)))), COERCE_FLOAT(*(_OWORD *)a2));
      v46 = *((float32x4_t *)a2 + 29);
      v47 = *((float32x4_t *)a2 + 30);
      v48 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v36, vmulq_f32(v37, vaddq_f32(vaddq_f32(v43, vmulq_f32(v37, v44)), vmulq_f32(vmulq_f32(v37, v37), v41)))), COERCE_FLOAT(*(_OWORD *)a2)), v46);
      v49 = vmaxq_f32(v45, v46);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v51, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v51, v49)));
      v54 = vsubq_f32(v48, v52);
      v55 = vsubq_f32(v49, v53);
      v56 = *((float32x4_t *)a2 + 31);
      v57 = *((float32x4_t *)a2 + 32);
      v58 = vmulq_f32(v55, vaddq_f32(v57, vmulq_f32(v55, vaddq_f32(v47, vmulq_f32(v56, v55)))));
      v59 = vaddq_f32(v24, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, vaddq_f32(v47, vmulq_f32(v56, v54))))));
      v60 = vcvtq_s32_f32(v53);
      v61 = *((int32x4_t *)a2 + 33);
      v62 = vmulq_f32(v59, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v52)), 0x17uLL));
      v63 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v64 = vmulq_laneq_f32(vmulq_f32(vaddq_f32(v24, v58), (float32x4_t)vshlq_n_s32(vaddq_s32(v61, v60), 0x17uLL)), *(float32x4_t *)a2, 3);
      v65 = (int8x16_t)vmulq_n_f32(v16, *(float *)&v18);
      v66 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 1);
      v67 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v66));
      v68 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v66)), (int8x16_t)vmulq_n_f32(v17, *(float *)&v18), (int8x16_t)vaddq_f32(v63, v64));
      v69 = *((int8x16_t *)a2 + 15);
      v70 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v71 = (int8x16_t *)(v6 + v11);
      v71[-1] = vbslq_s8(v69, (int8x16_t)v13, (int8x16_t)vaddq_f32(v70, (float32x4_t)vbslq_s8(v69, (int8x16_t)v13, vbslq_s8(v67, v65, (int8x16_t)vaddq_f32(v63, vmulq_laneq_f32(v62, *(float32x4_t *)a2, 3))))));
      *v71 = vbslq_s8(v69, (int8x16_t)v12, (int8x16_t)vaddq_f32(v70, (float32x4_t)vbslq_s8(v69, (int8x16_t)v12, v68)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v72 = -v10;
    if (v72 >= v5)
      goto LABEL_3;
LABEL_10:
    v73 = 16 * v72;
    v74 = *(float32x4_t *)(v7 + v73);
    v75 = *((float32x4_t *)a2 + 75);
    v76 = vminq_f32(vmaxq_f32(v74, v75), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v75, *((int8x16_t *)a2 + 76)), 3));
    v77 = vaddq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1));
    v78 = *((float32x4_t *)a2 + 5);
    v79 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v77), (int8x16_t)v78);
    v80 = (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v79, *((float32x4_t *)a2 + 23)));
    v81 = vsubq_f32(vsubq_f32(v79, v78), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v80), v79));
    v82 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v77, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v77))), *((float32x4_t *)a2 + 22)), v80), vmulq_f32(v81, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v81, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v81)))))), COERCE_FLOAT(*(_OWORD *)a2)),
            *((float32x4_t *)a2 + 29));
    v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
    v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v83, v82)));
    v85 = vsubq_f32(v82, v84);
    *(int8x16_t *)(v6 + v73) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v74, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v74, vbslq_s8((int8x16_t)vcgtq_f32(v75, vsubq_f32(v76, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v76, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32(
                                                                            (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v78, vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(
                                                                                                 *((int32x4_t *)a2 + 33),
                                                                                                 vcvtq_s32_f32(v84)),
                                                                                               0x17uLL)),
                                                                              *(float32x4_t *)a2,
                                                                              3))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  __int128 v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  float32x4_t v84;
  int8x16_t *v85;
  int v86;
  uint64_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v86 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 16);
      v13 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v14, *((int8x16_t *)a2 + 76)), 3);
      v16 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v18 = *((_OWORD *)a2 + 1);
      v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
      v20 = *((float32x4_t *)a2 + 5);
      v21 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v14)), v14);
      v22 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v20, (int8x16_t)vaddq_f32(v16, v19));
      v23 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v20, (int8x16_t)vaddq_f32(v17, v19));
      v24 = *((int8x16_t *)a2 + 19);
      v25 = *((float32x4_t *)a2 + 20);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v22), (int8x16_t)v20);
      v27 = *((int8x16_t *)a2 + 21);
      v28 = *((float32x4_t *)a2 + 22);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v23), (int8x16_t)v20);
      v30 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v25, v23)));
      v31 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v25, v22))), v28);
      v32 = *((float32x4_t *)a2 + 23);
      v33 = *((float32x4_t *)a2 + 24);
      v34 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v26, v32));
      v35 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v29, v32));
      v36 = vaddq_f32(v31, v34);
      v37 = vmulq_f32(v33, v34);
      v38 = vmulq_f32(vmulq_f32(v33, v35), v29);
      v39 = vaddq_f32(vsubq_f32(v30, v28), v35);
      v40 = vsubq_f32(vsubq_f32(v26, v20), vmulq_f32(v37, v26));
      v41 = vsubq_f32(vsubq_f32(v29, v20), v38);
      v42 = *((float32x4_t *)a2 + 37);
      v43 = *((float32x4_t *)a2 + 38);
      v44 = vmulq_f32(v40, v40);
      v45 = *((float32x4_t *)a2 + 39);
      v46 = *((float32x4_t *)a2 + 40);
      v47 = vaddq_f32(v42, vmulq_f32(v43, v40));
      v48 = vaddq_f32(v45, vmulq_f32(v46, v40));
      v49 = vaddq_f32(v45, vmulq_f32(v46, v41));
      v50 = *((float32x4_t *)a2 + 41);
      v51 = *((float32x4_t *)a2 + 42);
      v52 = vaddq_f32(v42, vmulq_f32(v43, v41));
      v53 = vaddq_f32(v50, vmulq_f32(v51, v40));
      v54 = vaddq_f32(v50, vmulq_f32(v51, v41));
      v55 = vmulq_f32(v41, v41);
      v56 = vmulq_f32(v40, vaddq_f32(v53, vmulq_f32(v44, vaddq_f32(v47, vmulq_f32(v44, v48)))));
      v57 = *((float32x4_t *)a2 + 43);
      v58 = *((float32x4_t *)a2 + 44);
      v59 = vmulq_n_f32(vaddq_f32(v39, vmulq_f32(v41, vaddq_f32(v57, vmulq_f32(v41, vaddq_f32(v54, vmulq_f32(v55, vaddq_f32(v52, vmulq_f32(v55, v49)))))))), COERCE_FLOAT(*(_OWORD *)a2));
      v60 = *((float32x4_t *)a2 + 29);
      v61 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v36, vmulq_f32(v40, vaddq_f32(v57, v56))), COERCE_FLOAT(*(_OWORD *)a2)), v60);
      v62 = vmaxq_f32(v59, v60);
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v64, v62)));
      v67 = vsubq_f32(v61, v65);
      v68 = vsubq_f32(v62, v66);
      v69 = *((float32x4_t *)a2 + 45);
      v70 = *((float32x4_t *)a2 + 46);
      v71 = vaddq_f32(v58, vmulq_f32(v69, v67));
      v72 = vaddq_f32(v58, vmulq_f32(v69, v68));
      v73 = *((float32x4_t *)a2 + 47);
      v74 = *((float32x4_t *)a2 + 48);
      v75 = *((int32x4_t *)a2 + 33);
      v76 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v67, vaddq_f32(v74, vmulq_f32(v67, vaddq_f32(vaddq_f32(v70, vmulq_f32(v67, v73)), vmulq_f32(vmulq_f32(v67, v67), v71)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v75, vcvtq_s32_f32(v65)), 0x17uLL));
      v77 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2);
      v78 = vmulq_laneq_f32(vmulq_f32(vaddq_f32(v20, vmulq_f32(v68, vaddq_f32(v74, vmulq_f32(v68, vaddq_f32(vaddq_f32(v70, vmulq_f32(v73, v68)), vmulq_f32(vmulq_f32(v68, v68), v72)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v75, vcvtq_s32_f32(v66)), 0x17uLL)), *(float32x4_t *)a2, 3);
      v79 = (int8x16_t)vmulq_n_f32(v16, *(float *)&v18);
      v80 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 1);
      v81 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v80));
      v82 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v80)), (int8x16_t)vmulq_n_f32(v17, *(float *)&v18), (int8x16_t)vaddq_f32(v77, v78));
      v83 = *((int8x16_t *)a2 + 15);
      v84 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0);
      v85 = (int8x16_t *)(v6 + v11);
      v85[-1] = vbslq_s8(v83, (int8x16_t)v12, (int8x16_t)vaddq_f32(v84, (float32x4_t)vbslq_s8(v83, (int8x16_t)v12, vbslq_s8(v81, v79, (int8x16_t)vaddq_f32(v77, vmulq_laneq_f32(v76, *(float32x4_t *)a2, 3))))));
      *v85 = vbslq_s8(v83, (int8x16_t)v13, (int8x16_t)vaddq_f32(v84, (float32x4_t)vbslq_s8(v83, (int8x16_t)v13, v82)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v86 = -v10;
    if (v86 >= v5)
      goto LABEL_3;
LABEL_10:
    v87 = 16 * v86;
    v88 = *(float32x4_t *)(v7 + v87);
    v89 = *((float32x4_t *)a2 + 75);
    v90 = vminq_f32(vmaxq_f32(v88, v89), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v89, *((int8x16_t *)a2 + 76)), 3));
    v91 = *((float32x4_t *)a2 + 5);
    v92 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v89)), v89), (int8x16_t)v91, (int8x16_t)vaddq_f32(v90, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
    v93 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v92), (int8x16_t)v91);
    v94 = (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v93, *((float32x4_t *)a2 + 23)));
    v95 = vsubq_f32(vsubq_f32(v93, v91), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v94), v93));
    v96 = vmulq_f32(v95, v95);
    v97 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v92, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v92))), *((float32x4_t *)a2 + 22)), v94), vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v95)),
                        vmulq_f32(v96, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v95)), vmulq_f32(v96, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v95)))))))))), COERCE_FLOAT(*(_OWORD *)a2)), *((float32x4_t *)a2 + 29));
    v98 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
    v99 = vsubq_f32(v98, (float32x4_t)vandq_s8((int8x16_t)v91, (int8x16_t)vcgtq_f32(v98, v97)));
    v100 = vsubq_f32(v97, v99);
    *(int8x16_t *)(v6 + v87) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v88, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v88, vbslq_s8((int8x16_t)vcgtq_f32(v89, vsubq_f32(v90, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v90, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32(
                                                                            (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32(vmulq_f32(vaddq_f32(v91, vmulq_f32(v100, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v100, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v100)), vmulq_f32(
                                                                                            vmulq_f32(v100, v100),
                                                                                            vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v100)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v99)), 0x17uLL)), *(float32x4_t *)a2, 3))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Gettype4_float_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = 16 * *((int *)a1 + 22);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v10 = 0;
      do
      {
        v11 = *(float32x4_t *)(v5 + v10);
        v12 = *((float32x4_t *)a2 + 75);
        v13 = vminq_f32(vmaxq_f32(v11, v12), (float32x4_t)vdupq_laneq_s32((int32x4_t)vbicq_s8((int8x16_t)v12, *((int8x16_t *)a2 + 76)), 3));
        v14 = *((float32x4_t *)a2 + 5);
        v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0), v12)), v12), (int8x16_t)v14, (int8x16_t)vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1)));
        v16 = *((int8x16_t *)a2 + 52);
        v17 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v15);
        v18 = (int8x16_t)vmulq_f32(v15, vaddq_f32(v14, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 49), v17)));
        v19 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), v18), (int8x16_t)v14);
        v20 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v15, *((float32x4_t *)a2 + 21))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v15, *((float32x4_t *)a2 + 50)), *((int8x16_t *)a2 + 51)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vceqq_f32(v15, *((float32x4_t *)a2 + 50)))), (float32x4_t)vandq_s8(v16, v17))), *((float32x4_t *)a2 + 22)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)));
        v21 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v19, *((float32x4_t *)a2 + 23)));
        v22 = vaddq_f32(v20, v21);
        v23 = vsubq_f32(vsubq_f32(v19, v14), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v21), v19));
        v24 = vmulq_f32(v23, v23);
        v25 = vmulq_n_f32(vaddq_f32(v22, vmulq_f32(v23, vaddq_f32(*((float32x4_t *)a2 + 61), vmulq_f32(v23, vaddq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 59), vmulq_f32(*((float32x4_t *)a2 + 60), v23)), vmulq_f32(v24, vaddq_f32(*((float32x4_t *)a2 + 57), vmulq_f32(*((float32x4_t *)a2 + 58), v23)))), vmulq_f32(vmulq_f32(v24, v24), vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 55), vmulq_f32(*((float32x4_t *)a2 + 56), v23)), vmulq_f32(
                                v24,
                                vaddq_f32(*((float32x4_t *)a2 + 53), vmulq_f32(*((float32x4_t *)a2 + 54), v23)))))))))),
                COERCE_FLOAT(*(_OWORD *)a2));
        v26 = vminq_f32(vmaxq_f32(v25, *((float32x4_t *)a2 + 62)), *((float32x4_t *)a2 + 63));
        v27 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
        v28 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v27, v26)));
        v29 = vsubq_f32(v26, v28);
        v30 = vmulq_f32(v29, v29);
        v31 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 70), v28);
        *(int8x16_t *)(v7 + v10) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 32), 0), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v12, vsubq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 16), 1))), (int8x16_t)vmulq_n_f32(v13, COERCE_FLOAT(*((_OWORD *)a2 + 1))), (int8x16_t)vaddq_f32(
                                                                                (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 2), vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25))), v12), (int8x16_t)vmulq_f32(vaddq_f32(v14, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 71), v31)), vmulq_f32(vaddq_f32(v14, vmulq_f32(v29, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 68), vmulq_f32(v29, *((float32x4_t *)a2 + 69))), vmulq_f32(v30, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 66), vmulq_f32(*((float32x4_t *)a2 + 67), v29)), vmulq_f32(v30, vaddq_f32(*((float32x4_t *)a2 + 64), vmulq_f32(*((float32x4_t *)a2 + 65), v29)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(vaddq_f32(v28, (float32x4_t)vandq_s8(v16, v31)))), 0x17uLL))), (int8x16_t)v25), *(float32x4_t *)a2, 3))))));
        v10 += 16;
      }
      while (v9 != v10);
      ++v4;
      v5 += v6;
      v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t Getrec709_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t *v32;
  float32x4_t v33;
  float32x4_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  float32x4_t v40;
  float32x4_t v41;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v35 = 0;
        v36 = 16 * v8;
        v37 = 16 * v7;
        v38 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v39 = 0;
          do
          {
            v40 = v5[v39 / 0x10];
            v41 = vminq_f32(vmaxq_f32(v40, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v6[v39 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v40, (int8x16_t)vmulq_f32(v41, vminq_f32(vrsqrteq_f32(v41), *((float32x4_t *)a2 + 73))));
            v39 += 16;
          }
          while (v38 != v39);
          ++v35;
          v5 = (float32x4_t *)((char *)v5 + v36);
          v6 = (int8x16_t *)((char *)v6 + v37);
        }
        while (v35 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((float32x4_t *)a2 + 73);
          v31 = *((int8x16_t *)a2 + 15);
          v32 = &v6[v17];
          v32[-2] = vbslq_s8(v31, (int8x16_t)v20, (int8x16_t)vmulq_f32(v26, vminq_f32(vrsqrteq_f32(v26), v30)));
          v32[-1] = vbslq_s8(v31, (int8x16_t)v21, (int8x16_t)vmulq_f32(v27, vminq_f32(vrsqrteq_f32(v27), v30)));
          v14 += 4;
          *v32 = vbslq_s8(v31, (int8x16_t)v22, (int8x16_t)vmulq_f32(v28, vminq_f32(vrsqrteq_f32(v28), v30)));
          v32[1] = vbslq_s8(v31, (int8x16_t)v23, (int8x16_t)vmulq_f32(v29, vminq_f32(vrsqrteq_f32(v29), v30)));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v33 = *v18++;
            v34 = vminq_f32(vmaxq_f32(v33, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v33, (int8x16_t)vmulq_f32(v34, vminq_f32(vrsqrteq_f32(v34), *((float32x4_t *)a2 + 73))));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getrec709_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  uint64_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v76) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v18));
      v22 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v19));
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v20));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v24), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v22, v25), v27));
      v31 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v23, v26)));
      v32 = vaddq_f32(v28, v24);
      v33 = vaddq_f32(v28, v25);
      v34 = vaddq_f32(v28, v26);
      v35 = *((float32x4_t *)a2 + 9);
      v36 = *((float32x4_t *)a2 + 10);
      v37 = vsubq_f32(v32, vmulq_f32(v29, v35));
      v38 = *((float32x4_t *)a2 + 77);
      v39 = vmulq_f32(v38, v37);
      v40 = vmulq_f32(v38, vsubq_f32(v33, vmulq_f32(v30, v35)));
      v41 = vmulq_f32(v38, vsubq_f32(v34, vmulq_f32(v31, v35)));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = *((float32x4_t *)a2 + 11);
      v49 = *((float32x4_t *)a2 + 12);
      v50 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v39, v45))), v49);
      v51 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v40, v46))), v49);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v41, v47))), v49);
      v53 = vaddq_f32(vaddq_f32(v36, v47), vmulq_f32(v52, v52));
      v54 = vmaxq_f32(vaddq_f32(vaddq_f32(v36, v45), vmulq_f32(v50, v50)), v14);
      v55 = vmaxq_f32(vaddq_f32(vaddq_f32(v36, v46), vmulq_f32(v51, v51)), v14);
      v56 = *((float32x4_t *)a2 + 13);
      v57 = *((float32x4_t *)a2 + 14);
      v58 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v54, v56), v57));
      v59 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v55, v56), v57));
      v60 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v53, v14), v56), v57));
      v61 = *((float32x4_t *)a2 + 78);
      v62 = *((float32x4_t *)a2 + 79);
      v63 = (int8x16_t)vaddq_f32(v61, vmulq_f32(v62, v58));
      v64 = (int8x16_t)vaddq_f32(v61, vmulq_f32(v62, v59));
      v65 = vmulq_f32(v62, v60);
      v66 = *((float32x4_t *)a2 + 80);
      v67 = (int8x16_t)vmulq_f32(v18, v66);
      v68 = (int8x16_t)vaddq_f32(v61, v65);
      v69 = (int8x16_t)vmulq_f32(v19, v66);
      v70 = *((float32x4_t *)a2 + 81);
      v71 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v70));
      v72 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v70));
      v73 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v20, v70)), (int8x16_t)vmulq_f32(v20, v66), v68);
      v74 = *((int8x16_t *)a2 + 15);
      v75 = (int8x16_t *)(v6 + v10);
      *v75 = vbslq_s8(v74, (int8x16_t)v12, vbslq_s8(v71, v67, v63));
      v75[1] = vbslq_s8(v74, (int8x16_t)v13, vbslq_s8(v72, v69, v64));
      v75[2] = vbslq_s8(v74, (int8x16_t)v15, v73);
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v76) = -v11;
    if ((int)v76 >= v5)
      goto LABEL_3;
LABEL_10:
    v76 = v76;
    do
    {
      v77 = *(float32x4_t *)(v7 + 16 * v76);
      v78 = *((float32x4_t *)a2 + 75);
      v79 = *((float32x4_t *)a2 + 5);
      v80 = vminq_f32(vmaxq_f32(v77, v78), v79);
      v81 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)v80));
      v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
      v83 = vmulq_f32(*((float32x4_t *)a2 + 77), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v82), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v81, v82))), *((float32x4_t *)a2 + 9))));
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v85 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v84, v83)));
      v86 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v83, v85))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v76++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v77, vbslq_s8((int8x16_t)vcgtq_f32(v78, vsubq_f32(v80, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v80, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v85), vmulq_f32(v86, v86)), v78),
                                                                              *((float32x4_t *)a2 + 13)),
                                                                            *((float32x4_t *)a2 + 14)))))));
    }
    while (v76 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  int8x16_t v85;
  float32x4_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t *v90;
  int v91;
  uint64_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v91 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = *((float32x4_t *)a2 + 77);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v19 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v17, v14)), v14);
      v20 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, (int8x16_t)v16);
      v21 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, (int8x16_t)v18);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v26 = *((int8x16_t *)a2 + 21);
      v27 = *((float32x4_t *)a2 + 22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v20)));
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v21)));
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v30));
      v34 = vaddq_f32(vsubq_f32(v28, v27), v32);
      v35 = vmulq_f32(v31, v32);
      v36 = vmulq_f32(vmulq_f32(v31, v33), v25);
      v37 = vaddq_f32(vsubq_f32(v29, v27), v33);
      v38 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(v35, v24));
      v39 = vsubq_f32(vsubq_f32(v25, v15), v36);
      v40 = vmulq_f32(v38, v38);
      v41 = vmulq_f32(v39, v39);
      v42 = *((float32x4_t *)a2 + 37);
      v43 = *((float32x4_t *)a2 + 38);
      v44 = *((float32x4_t *)a2 + 39);
      v45 = *((float32x4_t *)a2 + 40);
      v46 = vaddq_f32(v42, vmulq_f32(v43, v38));
      v47 = vaddq_f32(v44, vmulq_f32(v45, v38));
      v48 = vaddq_f32(v44, vmulq_f32(v45, v39));
      v49 = vaddq_f32(v42, vmulq_f32(v43, v39));
      v50 = *((float32x4_t *)a2 + 41);
      v51 = *((float32x4_t *)a2 + 42);
      v52 = vaddq_f32(vaddq_f32(v50, vmulq_f32(v51, v39)), vmulq_f32(v41, vaddq_f32(v49, vmulq_f32(v41, v48))));
      v53 = vmulq_f32(v38, vaddq_f32(vaddq_f32(v50, vmulq_f32(v51, v38)), vmulq_f32(v40, vaddq_f32(v46, vmulq_f32(v40, v47)))));
      v54 = *((float32x4_t *)a2 + 43);
      v55 = *((float32x4_t *)a2 + 44);
      v56 = vmulq_f32(v17, vaddq_f32(v34, vmulq_f32(v38, vaddq_f32(v54, v53))));
      v57 = vmulq_f32(v17, vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v54, vmulq_f32(v39, v52)))));
      v58 = *((float32x4_t *)a2 + 29);
      v59 = vmaxq_f32(v56, v58);
      v60 = vmaxq_f32(v57, v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 45);
      v68 = *((float32x4_t *)a2 + 46);
      v69 = vaddq_f32(v55, vmulq_f32(v67, v65));
      v70 = vaddq_f32(v55, vmulq_f32(v67, v66));
      v71 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v73 = vaddq_f32(v15, vmulq_f32(v65, vaddq_f32(v72, vmulq_f32(v65, vaddq_f32(vaddq_f32(v68, vmulq_f32(v65, v71)), vmulq_f32(vmulq_f32(v65, v65), v69))))));
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v72, vmulq_f32(v66, vaddq_f32(vaddq_f32(v68, vmulq_f32(v71, v66)), vmulq_f32(vmulq_f32(v66, v66), v70))))));
      v76 = (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v63)), 0x17uLL);
      v77 = (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v64)), 0x17uLL);
      v78 = vmulq_f32(v73, v76);
      v79 = *((float32x4_t *)a2 + 78);
      v80 = *((float32x4_t *)a2 + 79);
      v81 = (int8x16_t)vaddq_f32(v79, vmulq_f32(v80, v78));
      v82 = vmulq_f32(v80, vmulq_f32(v75, v77));
      v83 = *((float32x4_t *)a2 + 80);
      v84 = (int8x16_t)vmulq_f32(v16, v83);
      v85 = (int8x16_t)vaddq_f32(v79, v82);
      v86 = *((float32x4_t *)a2 + 81);
      v87 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v86));
      v88 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v86)), (int8x16_t)vmulq_f32(v18, v83), v85);
      v89 = *((int8x16_t *)a2 + 15);
      v90 = (int8x16_t *)(v6 + v11);
      v90[-1] = vbslq_s8(v89, (int8x16_t)v13, vbslq_s8(v87, v84, v81));
      *v90 = vbslq_s8(v89, (int8x16_t)v12, v88);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v91 = -v10;
    if (v91 >= v5)
      goto LABEL_3;
LABEL_10:
    v92 = 16 * v91;
    v93 = *(float32x4_t *)(v7 + v92);
    v94 = *((float32x4_t *)a2 + 75);
    v95 = *((float32x4_t *)a2 + 5);
    v96 = vminq_f32(vmaxq_f32(v93, v94), v95);
    v97 = *((float32x4_t *)a2 + 77);
    v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vceqq_f32(v97, v94)), v94), (int8x16_t)v95, (int8x16_t)v96);
    v99 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v98), (int8x16_t)v95);
    v100 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v99, *((float32x4_t *)a2 + 23)));
    v101 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v98))), *((float32x4_t *)a2 + 22)), v100);
    v102 = vsubq_f32(vsubq_f32(v99, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v100), v99));
    v103 = vmulq_f32(v102, v102);
    v104 = vmaxq_f32(vmulq_f32(v97, vaddq_f32(v101, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v102, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v102)), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v102)), vmulq_f32(v103, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v102))))))))))),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    *(int8x16_t *)(v6 + v92) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v93, vbslq_s8((int8x16_t)vcgtq_f32(v94, vsubq_f32(v96, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v96, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v95, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v107, vaddq_f32(
                                                              vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v107)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  int v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v76 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((int8x16_t *)a2 + 19);
      v19 = *((float32x4_t *)a2 + 20);
      v20 = (float32x4_t)vorrq_s8(vandq_s8(v18, (int8x16_t)v16), (int8x16_t)v15);
      v21 = (float32x4_t)vorrq_s8(vandq_s8(v18, (int8x16_t)v17), (int8x16_t)v15);
      v22 = (int8x16_t)vcgtq_f32(v19, v16);
      v23 = *((int8x16_t *)a2 + 21);
      v24 = *((float32x4_t *)a2 + 22);
      v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v19, v17)));
      v26 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v23, v22)), v24);
      v27 = *((float32x4_t *)a2 + 23);
      v28 = *((float32x4_t *)a2 + 24);
      v29 = vsubq_f32(v25, v24);
      v30 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v27));
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v21, v27));
      v32 = vsubq_f32(vsubq_f32(v20, v15), vmulq_f32(vmulq_f32(v28, v30), v20));
      v33 = vsubq_f32(vsubq_f32(v21, v15), vmulq_f32(vmulq_f32(v28, v31), v21));
      v34 = *((float32x4_t *)a2 + 25);
      v35 = *((float32x4_t *)a2 + 26);
      v36 = vaddq_f32(v34, vmulq_f32(v35, v32));
      v37 = vaddq_f32(v34, vmulq_f32(v35, v33));
      v38 = *((float32x4_t *)a2 + 27);
      v39 = *((float32x4_t *)a2 + 28);
      v40 = vaddq_f32(vaddq_f32(v29, v31), vmulq_f32(v33, vaddq_f32(vaddq_f32(v38, vmulq_f32(v33, v39)), vmulq_f32(vmulq_f32(v33, v33), v37))));
      v41 = *((float32x4_t *)a2 + 77);
      v42 = vmulq_f32(v41, vaddq_f32(vaddq_f32(v26, v30), vmulq_f32(v32, vaddq_f32(vaddq_f32(v38, vmulq_f32(v32, v39)), vmulq_f32(vmulq_f32(v32, v32), v36)))));
      v43 = vmulq_f32(v41, v40);
      v44 = *((float32x4_t *)a2 + 29);
      v45 = *((float32x4_t *)a2 + 30);
      v46 = vmaxq_f32(v42, v44);
      v47 = vmaxq_f32(v43, v44);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v46, v50);
      v53 = *((float32x4_t *)a2 + 31);
      v54 = *((float32x4_t *)a2 + 32);
      v55 = vsubq_f32(v47, v51);
      v56 = vmulq_f32(v55, vaddq_f32(v54, vmulq_f32(v55, vaddq_f32(v45, vmulq_f32(v53, v55)))));
      v57 = vaddq_f32(v15, vmulq_f32(v52, vaddq_f32(v54, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v53, v52))))));
      v58 = vcvtq_s32_f32(v51);
      v59 = *((int32x4_t *)a2 + 33);
      v60 = vaddq_f32(v15, v56);
      v61 = (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL);
      v62 = (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL);
      v63 = vmulq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 78);
      v65 = *((float32x4_t *)a2 + 79);
      v66 = (int8x16_t)vaddq_f32(v64, vmulq_f32(v65, v63));
      v67 = vmulq_f32(v65, vmulq_f32(v60, v62));
      v68 = *((float32x4_t *)a2 + 80);
      v69 = (int8x16_t)vmulq_f32(v16, v68);
      v70 = (int8x16_t)vaddq_f32(v64, v67);
      v71 = *((float32x4_t *)a2 + 81);
      v72 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v71));
      v73 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v71)), (int8x16_t)vmulq_f32(v17, v68), v70);
      v74 = *((int8x16_t *)a2 + 15);
      v75 = (int8x16_t *)(v6 + v11);
      v75[-1] = vbslq_s8(v74, (int8x16_t)v13, vbslq_s8(v72, v69, v66));
      *v75 = vbslq_s8(v74, (int8x16_t)v12, v73);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v76 = -v10;
    if (v76 >= v5)
      goto LABEL_3;
LABEL_10:
    v77 = 16 * v76;
    v78 = *(float32x4_t *)(v7 + v77);
    v79 = *((float32x4_t *)a2 + 75);
    v80 = *((float32x4_t *)a2 + 5);
    v81 = vminq_f32(vmaxq_f32(v78, v79), v80);
    v82 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v81), (int8x16_t)v80);
    v83 = (float32x4_t)vandq_s8((int8x16_t)v80, (int8x16_t)vcgtq_f32(v82, *((float32x4_t *)a2 + 23)));
    v84 = vsubq_f32(vsubq_f32(v82, v80), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v83), v82));
    v85 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v81, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v81))), *((float32x4_t *)a2 + 22)), v83), vmulq_f32(v84, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v84, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v84))))))),
            *((float32x4_t *)a2 + 29));
    v86 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
    v87 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v80, (int8x16_t)vcgtq_f32(v86, v85)));
    v88 = vsubq_f32(v85, v87);
    *(int8x16_t *)(v6 + v77) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v78, vbslq_s8((int8x16_t)vcgtq_f32(v79, vsubq_f32(v81, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v81, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v80, vmulq_f32(v88, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v88, vaddq_f32(
                                                              *((float32x4_t *)a2 + 30),
                                                              vmulq_f32(*((float32x4_t *)a2 + 31), v88)))))),
                                                    (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v87)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t *v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = (int8x16_t)vcgtq_f32(v18, v17);
      v21 = *((int8x16_t *)a2 + 83);
      v22 = *((float32x4_t *)a2 + 5);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v21, (int8x16_t)v22));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v20, v21, (int8x16_t)v22));
      v25 = *((float32x4_t *)a2 + 84);
      v26 = vminq_f32(v23, v25);
      v27 = vminq_f32(v24, v25);
      v28 = *((int8x16_t *)a2 + 19);
      v29 = *((float32x4_t *)a2 + 20);
      v30 = (float32x4_t)vorrq_s8(vandq_s8(v28, (int8x16_t)v26), (int8x16_t)v22);
      v31 = *((int8x16_t *)a2 + 21);
      v32 = *((float32x4_t *)a2 + 22);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v28, (int8x16_t)v27), (int8x16_t)v22);
      v34 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v29, v27)));
      v35 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v29, v26))), v32);
      v36 = *((float32x4_t *)a2 + 23);
      v37 = *((float32x4_t *)a2 + 24);
      v38 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v30, v36));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v33, v36));
      v40 = vaddq_f32(v35, v38);
      v41 = vmulq_f32(v37, v38);
      v42 = vmulq_f32(vmulq_f32(v37, v39), v33);
      v43 = vaddq_f32(vsubq_f32(v34, v32), v39);
      v44 = vsubq_f32(vsubq_f32(v30, v22), vmulq_f32(v41, v30));
      v45 = vsubq_f32(vsubq_f32(v33, v22), v42);
      v46 = *((float32x4_t *)a2 + 25);
      v47 = *((float32x4_t *)a2 + 26);
      v48 = vaddq_f32(v46, vmulq_f32(v47, v44));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v45));
      v51 = *((float32x4_t *)a2 + 27);
      v50 = *((float32x4_t *)a2 + 28);
      v52 = vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v51, vmulq_f32(v45, v50)), vmulq_f32(vmulq_f32(v45, v45), v49))));
      v53 = *((float32x4_t *)a2 + 77);
      v54 = vmulq_f32(v53, vaddq_f32(v40, vmulq_f32(v44, vaddq_f32(vaddq_f32(v51, vmulq_f32(v44, v50)), vmulq_f32(vmulq_f32(v44, v44), v48)))));
      v55 = vmulq_f32(v53, v52);
      v56 = *((float32x4_t *)a2 + 29);
      v57 = *((float32x4_t *)a2 + 30);
      v58 = vmaxq_f32(v54, v56);
      v59 = vmaxq_f32(v55, v56);
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v58, v62);
      v65 = vsubq_f32(v59, v63);
      v66 = *((float32x4_t *)a2 + 31);
      v67 = *((float32x4_t *)a2 + 32);
      v68 = vmulq_f32(v65, vaddq_f32(v67, vmulq_f32(v65, vaddq_f32(v57, vmulq_f32(v66, v65)))));
      v69 = vaddq_f32(v22, vmulq_f32(v64, vaddq_f32(v67, vmulq_f32(v64, vaddq_f32(v57, vmulq_f32(v66, v64))))));
      v70 = vcvtq_s32_f32(v63);
      v71 = *((int32x4_t *)a2 + 33);
      v72 = vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v71, vcvtq_s32_f32(v62)), 0x17uLL));
      v73 = vmulq_f32(vaddq_f32(v22, v68), (float32x4_t)vshlq_n_s32(vaddq_s32(v71, v70), 0x17uLL));
      v74 = *((float32x4_t *)a2 + 78);
      v75 = *((float32x4_t *)a2 + 79);
      v76 = vmulq_f32(v75, v73);
      v77 = (int8x16_t)vaddq_f32(v74, vmulq_f32(v75, v72));
      v78 = *((float32x4_t *)a2 + 80);
      v79 = *((float32x4_t *)a2 + 81);
      v80 = (int8x16_t *)(v6 + v11);
      v80[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v79)), (int8x16_t)vmulq_f32(v23, v78), v77), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v22)));
      *v80 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v79)), (int8x16_t)vmulq_f32(v24, v78), (int8x16_t)vaddq_f32(v74, v76)), (float32x4_t)vbslq_s8(v20, (int8x16_t)v14, (int8x16_t)v22)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((float32x4_t *)a2 + 82);
    v85 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, (int8x16_t)vmaxq_f32(v83, v84));
    v86 = *((float32x4_t *)a2 + 75);
    v87 = (int8x16_t)vcgtq_f32(v86, v85);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vmulq_f32(v85, (float32x4_t)vbslq_s8(v87, *((int8x16_t *)a2 + 83), (int8x16_t)v88));
    v90 = vminq_f32(v89, *((float32x4_t *)a2 + 84));
    v91 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v90), (int8x16_t)v88);
    v92 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v91, *((float32x4_t *)a2 + 23)));
    v93 = vsubq_f32(vsubq_f32(v91, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v92), v91));
    v94 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v90))), *((float32x4_t *)a2 + 22)), v92), vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v93, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v93, v93), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v93))))))),
            *((float32x4_t *)a2 + 29));
    v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
    v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v95, v94)));
    v97 = vsubq_f32(v94, v96);
    *(int8x16_t *)(v6 + v82) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v89, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v88, vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 32),
                                                                                    vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v97)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v96)), 0x17uLL))))), (float32x4_t)vbslq_s8(v87, (int8x16_t)v84, (int8x16_t)v88)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec709_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t *v87;
  int v88;
  uint64_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v88 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = *((int8x16_t *)a2 + 83);
      v21 = *((float32x4_t *)a2 + 5);
      v22 = (int8x16_t)vcgtq_f32(v18, v17);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v20, (int8x16_t)v21));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v22, v20, (int8x16_t)v21));
      v25 = *((float32x4_t *)a2 + 84);
      v26 = (int8x16_t)vminq_f32(v23, v25);
      v27 = (int8x16_t)vminq_f32(v24, v25);
      v28 = *((float32x4_t *)a2 + 77);
      v29 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v28, v18)), v18);
      v30 = (float32x4_t)vbslq_s8(v29, (int8x16_t)v21, v26);
      v31 = (float32x4_t)vbslq_s8(v29, (int8x16_t)v21, v27);
      v32 = *((int8x16_t *)a2 + 19);
      v33 = *((float32x4_t *)a2 + 20);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v21);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v31), (int8x16_t)v21);
      v36 = *((int8x16_t *)a2 + 21);
      v37 = *((float32x4_t *)a2 + 22);
      v38 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v33, v31)));
      v39 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v33, v30))), v37);
      v40 = *((float32x4_t *)a2 + 23);
      v41 = *((float32x4_t *)a2 + 24);
      v42 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v34, v40));
      v43 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v35, v40));
      v44 = vaddq_f32(v39, v42);
      v45 = vaddq_f32(vsubq_f32(v38, v37), v43);
      v46 = vsubq_f32(vsubq_f32(v34, v21), vmulq_f32(vmulq_f32(v41, v42), v34));
      v47 = vsubq_f32(vsubq_f32(v35, v21), vmulq_f32(vmulq_f32(v41, v43), v35));
      v48 = vmulq_f32(v46, v46);
      v49 = vmulq_f32(v47, v47);
      v50 = *((float32x4_t *)a2 + 37);
      v51 = *((float32x4_t *)a2 + 38);
      v52 = vaddq_f32(v50, vmulq_f32(v51, v46));
      v53 = *((float32x4_t *)a2 + 39);
      v54 = *((float32x4_t *)a2 + 40);
      v55 = vaddq_f32(v50, vmulq_f32(v51, v47));
      v56 = vaddq_f32(v53, vmulq_f32(v54, v46));
      v57 = vaddq_f32(v53, vmulq_f32(v54, v47));
      v58 = *((float32x4_t *)a2 + 41);
      v59 = *((float32x4_t *)a2 + 42);
      v60 = vaddq_f32(vaddq_f32(v58, vmulq_f32(v59, v47)), vmulq_f32(v49, vaddq_f32(v55, vmulq_f32(v49, v57))));
      v61 = vmulq_f32(v46, vaddq_f32(vaddq_f32(v58, vmulq_f32(v59, v46)), vmulq_f32(v48, vaddq_f32(v52, vmulq_f32(v48, v56)))));
      v62 = *((float32x4_t *)a2 + 43);
      v63 = *((float32x4_t *)a2 + 44);
      v64 = vaddq_f32(v45, vmulq_f32(v47, vaddq_f32(v62, vmulq_f32(v47, v60))));
      v65 = *((float32x4_t *)a2 + 29);
      v66 = vmaxq_f32(vmulq_f32(v28, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(v62, v61)))), v65);
      v67 = vmaxq_f32(vmulq_f32(v28, v64), v65);
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v68, v66)));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v66, v70);
      v73 = vsubq_f32(v67, v71);
      v74 = *((float32x4_t *)a2 + 45);
      v75 = *((float32x4_t *)a2 + 46);
      v76 = *((float32x4_t *)a2 + 47);
      v77 = *((float32x4_t *)a2 + 48);
      v78 = *((int32x4_t *)a2 + 33);
      v79 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v72, vaddq_f32(v77, vmulq_f32(v72, vaddq_f32(vaddq_f32(v75, vmulq_f32(v72, v76)), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(v63, vmulq_f32(v74, v72)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v70)), 0x17uLL));
      v80 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v73, vaddq_f32(v77, vmulq_f32(v73, vaddq_f32(vaddq_f32(v75, vmulq_f32(v76, v73)), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(v63, vmulq_f32(v74, v73)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v71)), 0x17uLL));
      v81 = *((float32x4_t *)a2 + 78);
      v82 = *((float32x4_t *)a2 + 79);
      v83 = vmulq_f32(v82, v80);
      v84 = (int8x16_t)vaddq_f32(v81, vmulq_f32(v82, v79));
      v85 = *((float32x4_t *)a2 + 80);
      v86 = *((float32x4_t *)a2 + 81);
      v87 = (int8x16_t *)(v6 + v11);
      v87[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v86)), (int8x16_t)vmulq_f32(v23, v85), v84), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v21)));
      *v87 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v86)), (int8x16_t)vmulq_f32(v24, v85), (int8x16_t)vaddq_f32(v81, v83)), (float32x4_t)vbslq_s8(v22, (int8x16_t)v14, (int8x16_t)v21)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v88 = -v10;
    if (v88 >= v5)
      goto LABEL_3;
LABEL_10:
    v89 = 16 * v88;
    v90 = *(float32x4_t *)(v7 + v89);
    v91 = *((float32x4_t *)a2 + 82);
    v92 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v90, (int8x16_t)vmaxq_f32(v90, v91));
    v93 = *((float32x4_t *)a2 + 75);
    v94 = (int8x16_t)vcgtq_f32(v93, v92);
    v95 = *((float32x4_t *)a2 + 5);
    v96 = vmulq_f32(v92, (float32x4_t)vbslq_s8(v94, *((int8x16_t *)a2 + 83), (int8x16_t)v95));
    v97 = *((float32x4_t *)a2 + 77);
    v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vceqq_f32(v97, v93)), v93), (int8x16_t)v95, (int8x16_t)vminq_f32(v96, *((float32x4_t *)a2 + 84)));
    v99 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v98), (int8x16_t)v95);
    v100 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v99, *((float32x4_t *)a2 + 23)));
    v101 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v98))), *((float32x4_t *)a2 + 22)), v100);
    v102 = vsubq_f32(vsubq_f32(v99, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v100), v99));
    v103 = vmulq_f32(v102, v102);
    v104 = vmaxq_f32(vmulq_f32(v97, vaddq_f32(v101, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v102, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v102)), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v102)), vmulq_f32(v103, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v102))))))))))),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    *(int8x16_t *)(v6 + v89) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v90, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v93, vsubq_f32(v96, *((float32x4_t *)a2 + 81))), (int8x16_t)vmulq_f32(v96, *((float32x4_t *)a2 + 80)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 78), vmulq_f32(*((float32x4_t *)a2 + 79), vmulq_f32(vaddq_f32(v95, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 48),
                                                                                    vmulq_f32(v107, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v107)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL))))),
                                              (float32x4_t)vbslq_s8(v94, (int8x16_t)v91, (int8x16_t)v95)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  float32x4_t v39;
  float32x4_t v40;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v34 = 0;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v39 = v5[v38 / 0x10];
            v40 = vminq_f32(vmaxq_f32(v39, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v6[v38 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v39, (int8x16_t)vmulq_f32(v40, v40));
            v38 += 16;
          }
          while (v37 != v38);
          ++v34;
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (int8x16_t *)((char *)v6 + v36);
        }
        while (v34 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((int8x16_t *)a2 + 15);
          v31 = &v6[v17];
          v31[-2] = vbslq_s8(v30, (int8x16_t)v20, (int8x16_t)vmulq_f32(v26, v26));
          v31[-1] = vbslq_s8(v30, (int8x16_t)v21, (int8x16_t)vmulq_f32(v27, v27));
          v14 += 4;
          *v31 = vbslq_s8(v30, (int8x16_t)v22, (int8x16_t)vmulq_f32(v28, v28));
          v31[1] = vbslq_s8(v30, (int8x16_t)v23, (int8x16_t)vmulq_f32(v29, v29));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v32 = *v18++;
            v33 = vminq_f32(vmaxq_f32(v32, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v32, (int8x16_t)vmulq_f32(v33, v33));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_rec709_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t *v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v75) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v21 = *((float32x4_t *)a2 + 85);
      v22 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v21)));
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v21)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v20, v21)));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = *((float32x4_t *)a2 + 7);
      v29 = *((float32x4_t *)a2 + 8);
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v22, v25), v28));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v23, v26), v28));
      v32 = vaddq_f32(v29, v25);
      v33 = vrsqrteq_f32(vaddq_f32(v28, vsubq_f32(v24, v27)));
      v34 = vaddq_f32(v29, v26);
      v35 = vaddq_f32(v29, v27);
      v36 = *((float32x4_t *)a2 + 9);
      v37 = *((float32x4_t *)a2 + 10);
      v38 = vsubq_f32(v32, vmulq_f32(v30, v36));
      v39 = vsubq_f32(v34, vmulq_f32(v31, v36));
      v40 = *((float32x4_t *)a2 + 86);
      v41 = vmulq_f32(v40, v38);
      v42 = vmulq_f32(v40, v39);
      v43 = vmulq_f32(v40, vsubq_f32(v35, vmulq_f32(v33, v36)));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v45, v42)));
      v49 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v46, v43)));
      v50 = *((float32x4_t *)a2 + 11);
      v51 = *((float32x4_t *)a2 + 12);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v41, v47))), v51);
      v53 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v42, v48))), v51);
      v54 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v43, v49))), v51);
      v55 = vaddq_f32(vaddq_f32(v37, v49), vmulq_f32(v54, v54));
      v56 = vmaxq_f32(vaddq_f32(vaddq_f32(v37, v47), vmulq_f32(v52, v52)), v14);
      v57 = vmaxq_f32(vaddq_f32(vaddq_f32(v37, v48), vmulq_f32(v53, v53)), v14);
      v58 = *((float32x4_t *)a2 + 13);
      v59 = *((float32x4_t *)a2 + 14);
      v60 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v56, v58), v59));
      v61 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v57, v58), v59));
      v62 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v55, v14), v58), v59));
      v63 = *((float32x4_t *)a2 + 87);
      v64 = *((float32x4_t *)a2 + 88);
      v65 = (int8x16_t)vmulq_f32(v18, v64);
      v66 = (int8x16_t)vmulq_f32(v19, v64);
      v67 = (int8x16_t)vmulq_f32(v20, v64);
      v68 = *((float32x4_t *)a2 + 89);
      v69 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v68));
      v70 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v68));
      v71 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v20, v68));
      v72 = vbslq_s8(v69, v65, (int8x16_t)vmulq_f32(v63, v60));
      v73 = *((int8x16_t *)a2 + 15);
      v74 = (int8x16_t *)(v6 + v10);
      *v74 = vbslq_s8(v73, (int8x16_t)v12, v72);
      v74[1] = vbslq_s8(v73, (int8x16_t)v13, vbslq_s8(v70, v66, (int8x16_t)vmulq_f32(v63, v61)));
      v74[2] = vbslq_s8(v73, (int8x16_t)v15, vbslq_s8(v71, v67, (int8x16_t)vmulq_f32(v63, v62)));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v75) = -v11;
    if ((int)v75 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = v75;
    do
    {
      v76 = *(float32x4_t *)(v7 + 16 * v75);
      v77 = *((float32x4_t *)a2 + 75);
      v78 = *((float32x4_t *)a2 + 5);
      v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
      v80 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v79, *((float32x4_t *)a2 + 85))));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v82 = vmulq_f32(*((float32x4_t *)a2 + 86), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v81), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v80, v81))), *((float32x4_t *)a2 + 9))));
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v83, v82)));
      v85 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v82, v84))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v75++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v79, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v84), vmulq_f32(v85, v85)), v77), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))))));
    }
    while (v75 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 85);
      v19 = (int8x16_t)vaddq_f32(v16, v18);
      v20 = (int8x16_t)vaddq_f32(v17, v18);
      v21 = *((float32x4_t *)a2 + 86);
      v22 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v21, v14)), v14);
      v23 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v19);
      v24 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v20);
      v25 = *((int8x16_t *)a2 + 19);
      v26 = *((float32x4_t *)a2 + 20);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v23), (int8x16_t)v15);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v24), (int8x16_t)v15);
      v29 = *((int8x16_t *)a2 + 21);
      v30 = *((float32x4_t *)a2 + 22);
      v31 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v24)));
      v32 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v23))), v30);
      v33 = *((float32x4_t *)a2 + 23);
      v34 = *((float32x4_t *)a2 + 24);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v33));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v33));
      v37 = vaddq_f32(v32, v35);
      v38 = vaddq_f32(vsubq_f32(v31, v30), v36);
      v39 = vsubq_f32(vsubq_f32(v27, v15), vmulq_f32(vmulq_f32(v34, v35), v27));
      v40 = vsubq_f32(vsubq_f32(v28, v15), vmulq_f32(vmulq_f32(v34, v36), v28));
      v41 = vmulq_f32(v39, v39);
      v42 = vmulq_f32(v40, v40);
      v43 = *((float32x4_t *)a2 + 37);
      v44 = *((float32x4_t *)a2 + 38);
      v45 = vaddq_f32(v43, vmulq_f32(v44, v39));
      v46 = *((float32x4_t *)a2 + 39);
      v47 = *((float32x4_t *)a2 + 40);
      v48 = vaddq_f32(v43, vmulq_f32(v44, v40));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v39));
      v50 = vaddq_f32(v46, vmulq_f32(v47, v40));
      v51 = *((float32x4_t *)a2 + 41);
      v52 = *((float32x4_t *)a2 + 42);
      v53 = vaddq_f32(vaddq_f32(v51, vmulq_f32(v52, v40)), vmulq_f32(v42, vaddq_f32(v48, vmulq_f32(v42, v50))));
      v54 = vmulq_f32(v39, vaddq_f32(vaddq_f32(v51, vmulq_f32(v52, v39)), vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, v49)))));
      v55 = *((float32x4_t *)a2 + 43);
      v56 = *((float32x4_t *)a2 + 44);
      v57 = vaddq_f32(v38, vmulq_f32(v40, vaddq_f32(v55, vmulq_f32(v40, v53))));
      v58 = *((float32x4_t *)a2 + 29);
      v59 = vmaxq_f32(vmulq_f32(v21, vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v55, v54)))), v58);
      v60 = vmaxq_f32(vmulq_f32(v21, v57), v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 45);
      v68 = *((float32x4_t *)a2 + 46);
      v69 = *((float32x4_t *)a2 + 47);
      v70 = *((float32x4_t *)a2 + 48);
      v71 = vaddq_f32(v15, vmulq_f32(v65, vaddq_f32(v70, vmulq_f32(v65, vaddq_f32(vaddq_f32(v68, vmulq_f32(v65, v69)), vmulq_f32(vmulq_f32(v65, v65), vaddq_f32(v56, vmulq_f32(v67, v65))))))));
      v72 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v70, vmulq_f32(v66, vaddq_f32(vaddq_f32(v68, vmulq_f32(v69, v66)), vmulq_f32(vmulq_f32(v66, v66), vaddq_f32(v56, vmulq_f32(v67, v66))))))));
      v73 = *((int32x4_t *)a2 + 33);
      v74 = vmulq_f32(v71, (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v63)), 0x17uLL));
      v75 = vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v64)), 0x17uLL));
      v76 = *((float32x4_t *)a2 + 87);
      v77 = *((float32x4_t *)a2 + 88);
      v78 = (int8x16_t)vmulq_f32(v16, v77);
      v79 = *((float32x4_t *)a2 + 89);
      v80 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v79));
      v81 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v79)), (int8x16_t)vmulq_f32(v17, v77), (int8x16_t)vmulq_f32(v76, v75));
      v82 = *((int8x16_t *)a2 + 15);
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v82, (int8x16_t)v13, vbslq_s8(v80, v78, (int8x16_t)vmulq_f32(v76, v74)));
      *v83 = vbslq_s8(v82, (int8x16_t)v12, v81);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((float32x4_t *)a2 + 75);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
    v90 = *((float32x4_t *)a2 + 86);
    v91 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vceqq_f32(v90, v87)), v87), (int8x16_t)v88, (int8x16_t)vaddq_f32(v89, *((float32x4_t *)a2 + 85)));
    v92 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v91), (int8x16_t)v88);
    v93 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v92, *((float32x4_t *)a2 + 23)));
    v94 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v91, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v91))), *((float32x4_t *)a2 + 22)), v93);
    v95 = vsubq_f32(vsubq_f32(v92, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v93), v92));
    v96 = vmulq_f32(v95, v95);
    v97 = vmaxq_f32(vmulq_f32(v90, vaddq_f32(v94, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v95)), vmulq_f32(v96, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v95)), vmulq_f32(v96, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v95))))))))))),
            *((float32x4_t *)a2 + 29));
    v98 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
    v99 = vsubq_f32(v98, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v98, v97)));
    v100 = vsubq_f32(v97, v99);
    *(int8x16_t *)(v6 + v85) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v88, vmulq_f32(v100, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v100, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46),
                                                              vmulq_f32(*((float32x4_t *)a2 + 47), v100)),
                                                            vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v100)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v99)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t *v73;
  int v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v74 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 85);
      v19 = vaddq_f32(v16, v18);
      v20 = vaddq_f32(v17, v18);
      v21 = *((int8x16_t *)a2 + 19);
      v22 = *((float32x4_t *)a2 + 20);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v19), (int8x16_t)v15);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v15);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v20)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v19))), v25);
      v29 = *((float32x4_t *)a2 + 23);
      v30 = *((float32x4_t *)a2 + 24);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vmulq_f32(v30, v31);
      v35 = vmulq_f32(vmulq_f32(v30, v32), v26);
      v36 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v37 = vsubq_f32(vsubq_f32(v23, v15), vmulq_f32(v34, v23));
      v38 = vsubq_f32(vsubq_f32(v26, v15), v35);
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v44 = *((float32x4_t *)a2 + 27);
      v43 = *((float32x4_t *)a2 + 28);
      v45 = vaddq_f32(v36, vmulq_f32(v38, vaddq_f32(vaddq_f32(v44, vmulq_f32(v38, v43)), vmulq_f32(vmulq_f32(v38, v38), v42))));
      v46 = *((float32x4_t *)a2 + 86);
      v47 = vmulq_f32(v46, vaddq_f32(v33, vmulq_f32(v37, vaddq_f32(vaddq_f32(v44, vmulq_f32(v37, v43)), vmulq_f32(vmulq_f32(v37, v37), v41)))));
      v48 = vmulq_f32(v46, v45);
      v49 = *((float32x4_t *)a2 + 29);
      v50 = *((float32x4_t *)a2 + 30);
      v51 = vmaxq_f32(v47, v49);
      v52 = vmaxq_f32(v48, v49);
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v54, v52)));
      v57 = vsubq_f32(v51, v55);
      v58 = vsubq_f32(v52, v56);
      v59 = *((float32x4_t *)a2 + 31);
      v60 = *((float32x4_t *)a2 + 32);
      v61 = vaddq_f32(v15, vmulq_f32(v57, vaddq_f32(v60, vmulq_f32(v57, vaddq_f32(v50, vmulq_f32(v59, v57))))));
      v62 = vaddq_f32(v15, vmulq_f32(v58, vaddq_f32(v60, vmulq_f32(v58, vaddq_f32(v50, vmulq_f32(v59, v58))))));
      v63 = *((int32x4_t *)a2 + 33);
      v64 = vmulq_f32(v61, (float32x4_t)vshlq_n_s32(vaddq_s32(v63, vcvtq_s32_f32(v55)), 0x17uLL));
      v65 = vmulq_f32(v62, (float32x4_t)vshlq_n_s32(vaddq_s32(v63, vcvtq_s32_f32(v56)), 0x17uLL));
      v66 = *((float32x4_t *)a2 + 87);
      v67 = *((float32x4_t *)a2 + 88);
      v68 = (int8x16_t)vmulq_f32(v16, v67);
      v69 = *((float32x4_t *)a2 + 89);
      v70 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v69));
      v71 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v69)), (int8x16_t)vmulq_f32(v17, v67), (int8x16_t)vmulq_f32(v66, v65));
      v72 = *((int8x16_t *)a2 + 15);
      v73 = (int8x16_t *)(v6 + v11);
      v73[-1] = vbslq_s8(v72, (int8x16_t)v13, vbslq_s8(v70, v68, (int8x16_t)vmulq_f32(v66, v64)));
      *v73 = vbslq_s8(v72, (int8x16_t)v12, v71);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v74 = -v10;
    if (v74 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = 16 * v74;
    v76 = *(float32x4_t *)(v7 + v75);
    v77 = *((float32x4_t *)a2 + 75);
    v78 = *((float32x4_t *)a2 + 5);
    v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
    v80 = vaddq_f32(v79, *((float32x4_t *)a2 + 85));
    v81 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v80), (int8x16_t)v78);
    v82 = (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v81, *((float32x4_t *)a2 + 23)));
    v83 = vsubq_f32(vsubq_f32(v81, v78), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v82), v81));
    v84 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v80, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v80))), *((float32x4_t *)a2 + 22)), v82), vmulq_f32(v83, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v83, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v83, v83), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v83))))))),
            *((float32x4_t *)a2 + 29));
    v85 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
    v86 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v85, v84)));
    v87 = vsubq_f32(v84, v86);
    *(int8x16_t *)(v6 + v75) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v79, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v78, vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v87)))))),
                                                  (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v86)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t *v76;
  int v77;
  uint64_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v77 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = (int8x16_t)vcgtq_f32(v18, v17);
      v21 = *((int8x16_t *)a2 + 83);
      v22 = *((float32x4_t *)a2 + 5);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v21, (int8x16_t)v22));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v20, v21, (int8x16_t)v22));
      v25 = *((float32x4_t *)a2 + 90);
      v26 = *((float32x4_t *)a2 + 85);
      v27 = vaddq_f32(vminq_f32(v23, v25), v26);
      v28 = vaddq_f32(vminq_f32(v24, v25), v26);
      v29 = *((int8x16_t *)a2 + 19);
      v30 = *((float32x4_t *)a2 + 20);
      v31 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v27), (int8x16_t)v22);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v28), (int8x16_t)v22);
      v33 = *((int8x16_t *)a2 + 21);
      v34 = *((float32x4_t *)a2 + 22);
      v35 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v30, v28)));
      v36 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v30, v27))), v34);
      v37 = *((float32x4_t *)a2 + 23);
      v38 = *((float32x4_t *)a2 + 24);
      v39 = vsubq_f32(v35, v34);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v31, v37));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v32, v37));
      v42 = vaddq_f32(v36, v40);
      v43 = vsubq_f32(vsubq_f32(v31, v22), vmulq_f32(vmulq_f32(v38, v40), v31));
      v44 = vsubq_f32(vsubq_f32(v32, v22), vmulq_f32(vmulq_f32(v38, v41), v32));
      v45 = *((float32x4_t *)a2 + 25);
      v46 = *((float32x4_t *)a2 + 26);
      v47 = vaddq_f32(v45, vmulq_f32(v46, v43));
      v48 = vaddq_f32(v45, vmulq_f32(v46, v44));
      v49 = *((float32x4_t *)a2 + 27);
      v50 = *((float32x4_t *)a2 + 28);
      v51 = vaddq_f32(vaddq_f32(v39, v41), vmulq_f32(v44, vaddq_f32(vaddq_f32(v49, vmulq_f32(v44, v50)), vmulq_f32(vmulq_f32(v44, v44), v48))));
      v52 = *((float32x4_t *)a2 + 86);
      v53 = vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(vaddq_f32(v49, vmulq_f32(v43, v50)), vmulq_f32(vmulq_f32(v43, v43), v47)))));
      v54 = vmulq_f32(v52, v51);
      v55 = *((float32x4_t *)a2 + 29);
      v56 = *((float32x4_t *)a2 + 30);
      v57 = vmaxq_f32(v53, v55);
      v58 = vmaxq_f32(v54, v55);
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 31);
      v65 = *((float32x4_t *)a2 + 32);
      v66 = vsubq_f32(v58, v62);
      v67 = vmulq_f32(v66, vaddq_f32(v65, vmulq_f32(v66, vaddq_f32(v56, vmulq_f32(v64, v66)))));
      v68 = vaddq_f32(v22, vmulq_f32(v63, vaddq_f32(v65, vmulq_f32(v63, vaddq_f32(v56, vmulq_f32(v64, v63))))));
      v69 = vcvtq_s32_f32(v62);
      v70 = *((int32x4_t *)a2 + 33);
      v71 = vmulq_f32(v68, (float32x4_t)vshlq_n_s32(vaddq_s32(v70, vcvtq_s32_f32(v61)), 0x17uLL));
      v72 = vmulq_f32(vaddq_f32(v22, v67), (float32x4_t)vshlq_n_s32(vaddq_s32(v70, v69), 0x17uLL));
      v73 = *((float32x4_t *)a2 + 87);
      v74 = *((float32x4_t *)a2 + 88);
      v75 = *((float32x4_t *)a2 + 89);
      v76 = (int8x16_t *)(v6 + v11);
      v76[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v75)), (int8x16_t)vmulq_f32(v23, v74), (int8x16_t)vmulq_f32(v73, v71)), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v22)));
      *v76 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v75)), (int8x16_t)vmulq_f32(v24, v74), (int8x16_t)vmulq_f32(v73, v72)), (float32x4_t)vbslq_s8(v20, (int8x16_t)v14, (int8x16_t)v22)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v77 = -v10;
    if (v77 >= v5)
      goto LABEL_3;
LABEL_10:
    v78 = 16 * v77;
    v79 = *(float32x4_t *)(v7 + v78);
    v80 = *((float32x4_t *)a2 + 82);
    v81 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v79, (int8x16_t)vmaxq_f32(v79, v80));
    v82 = *((float32x4_t *)a2 + 75);
    v83 = (int8x16_t)vcgtq_f32(v82, v81);
    v84 = *((float32x4_t *)a2 + 5);
    v85 = vmulq_f32(v81, (float32x4_t)vbslq_s8(v83, *((int8x16_t *)a2 + 83), (int8x16_t)v84));
    v86 = vaddq_f32(vminq_f32(v85, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 85));
    v87 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v86), (int8x16_t)v84);
    v88 = (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v87, *((float32x4_t *)a2 + 23)));
    v89 = vsubq_f32(vsubq_f32(v87, v84), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v88), v87));
    v90 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v86, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v86))), *((float32x4_t *)a2 + 22)), v88), vmulq_f32(v89, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v89, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v89, v89), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v89))))))),
            *((float32x4_t *)a2 + 29));
    v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
    v92 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v91, v90)));
    v93 = vsubq_f32(v90, v92);
    *(int8x16_t *)(v6 + v78) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v79, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, vsubq_f32(v85, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v85, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v84, vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v93,
                                                                                    vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v93)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v92)), 0x17uLL)))), (float32x4_t)vbslq_s8(v83, (int8x16_t)v80, (int8x16_t)v84)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec709_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t *v91;
  int v92;
  uint64_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v92 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = *((int8x16_t *)a2 + 83);
      v21 = *((float32x4_t *)a2 + 5);
      v22 = (int8x16_t)vcgtq_f32(v18, v17);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v20, (int8x16_t)v21));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v22, v20, (int8x16_t)v21));
      v25 = *((float32x4_t *)a2 + 90);
      v26 = vminq_f32(v24, v25);
      v27 = *((float32x4_t *)a2 + 85);
      v28 = (int8x16_t)vaddq_f32(vminq_f32(v23, v25), v27);
      v29 = *((float32x4_t *)a2 + 86);
      v30 = (int8x16_t)vaddq_f32(v26, v27);
      v31 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v29, v18)), v18);
      v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v21, v28);
      v33 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v21, v30);
      v34 = *((int8x16_t *)a2 + 19);
      v35 = *((float32x4_t *)a2 + 20);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v32), (int8x16_t)v21);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v33), (int8x16_t)v21);
      v38 = *((int8x16_t *)a2 + 21);
      v39 = *((float32x4_t *)a2 + 22);
      v40 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v32)));
      v41 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v33)));
      v42 = *((float32x4_t *)a2 + 23);
      v43 = *((float32x4_t *)a2 + 24);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v36, v42));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v37, v42));
      v46 = vaddq_f32(vsubq_f32(v40, v39), v44);
      v47 = vmulq_f32(v43, v44);
      v48 = vmulq_f32(vmulq_f32(v43, v45), v37);
      v49 = vaddq_f32(vsubq_f32(v41, v39), v45);
      v50 = vsubq_f32(vsubq_f32(v36, v21), vmulq_f32(v47, v36));
      v51 = vsubq_f32(vsubq_f32(v37, v21), v48);
      v52 = vmulq_f32(v50, v50);
      v53 = vmulq_f32(v51, v51);
      v54 = *((float32x4_t *)a2 + 37);
      v55 = *((float32x4_t *)a2 + 38);
      v56 = *((float32x4_t *)a2 + 39);
      v57 = *((float32x4_t *)a2 + 40);
      v58 = vaddq_f32(v54, vmulq_f32(v55, v50));
      v59 = vaddq_f32(v56, vmulq_f32(v57, v50));
      v60 = vaddq_f32(v56, vmulq_f32(v57, v51));
      v61 = vaddq_f32(v54, vmulq_f32(v55, v51));
      v62 = *((float32x4_t *)a2 + 41);
      v63 = *((float32x4_t *)a2 + 42);
      v64 = vaddq_f32(vaddq_f32(v62, vmulq_f32(v63, v51)), vmulq_f32(v53, vaddq_f32(v61, vmulq_f32(v53, v60))));
      v65 = vmulq_f32(v50, vaddq_f32(vaddq_f32(v62, vmulq_f32(v63, v50)), vmulq_f32(v52, vaddq_f32(v58, vmulq_f32(v52, v59)))));
      v66 = *((float32x4_t *)a2 + 43);
      v67 = *((float32x4_t *)a2 + 44);
      v68 = vmulq_f32(v29, vaddq_f32(v46, vmulq_f32(v50, vaddq_f32(v66, v65))));
      v69 = vmulq_f32(v29, vaddq_f32(v49, vmulq_f32(v51, vaddq_f32(v66, vmulq_f32(v51, v64)))));
      v70 = *((float32x4_t *)a2 + 29);
      v71 = vmaxq_f32(v68, v70);
      v72 = vmaxq_f32(v69, v70);
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
      v74 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
      v75 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v73, v71)));
      v76 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v74, v72)));
      v77 = vsubq_f32(v71, v75);
      v78 = vsubq_f32(v72, v76);
      v79 = *((float32x4_t *)a2 + 45);
      v80 = *((float32x4_t *)a2 + 46);
      v81 = vaddq_f32(v67, vmulq_f32(v79, v77));
      v82 = vaddq_f32(v67, vmulq_f32(v79, v78));
      v83 = *((float32x4_t *)a2 + 47);
      v84 = *((float32x4_t *)a2 + 48);
      v85 = *((int32x4_t *)a2 + 33);
      v86 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v77, vaddq_f32(v84, vmulq_f32(v77, vaddq_f32(vaddq_f32(v80, vmulq_f32(v77, v83)), vmulq_f32(vmulq_f32(v77, v77), v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v75)), 0x17uLL));
      v87 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v78, vaddq_f32(v84, vmulq_f32(v78, vaddq_f32(vaddq_f32(v80, vmulq_f32(v83, v78)), vmulq_f32(vmulq_f32(v78, v78), v82)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v76)), 0x17uLL));
      v88 = *((float32x4_t *)a2 + 87);
      v89 = *((float32x4_t *)a2 + 88);
      v90 = *((float32x4_t *)a2 + 89);
      v91 = (int8x16_t *)(v6 + v11);
      v91[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v90)), (int8x16_t)vmulq_f32(v23, v89), (int8x16_t)vmulq_f32(v88, v86)), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v21)));
      *v91 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v90)), (int8x16_t)vmulq_f32(v24, v89), (int8x16_t)vmulq_f32(v88, v87)), (float32x4_t)vbslq_s8(v22, (int8x16_t)v14, (int8x16_t)v21)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v92 = -v10;
    if (v92 >= v5)
      goto LABEL_3;
LABEL_10:
    v93 = 16 * v92;
    v94 = *(float32x4_t *)(v7 + v93);
    v95 = *((float32x4_t *)a2 + 82);
    v96 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v94, (int8x16_t)vmaxq_f32(v94, v95));
    v97 = *((float32x4_t *)a2 + 75);
    v98 = (int8x16_t)vcgtq_f32(v97, v96);
    v99 = *((float32x4_t *)a2 + 5);
    v100 = vmulq_f32(v96, (float32x4_t)vbslq_s8(v98, *((int8x16_t *)a2 + 83), (int8x16_t)v99));
    v101 = *((float32x4_t *)a2 + 86);
    v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vceqq_f32(v101, v97)), v97), (int8x16_t)v99, (int8x16_t)vaddq_f32(vminq_f32(v100, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 85)));
    v103 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v102), (int8x16_t)v99);
    v104 = (float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vcgtq_f32(v103, *((float32x4_t *)a2 + 23)));
    v105 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v102, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v102))), *((float32x4_t *)a2 + 22)), v104);
    v106 = vsubq_f32(vsubq_f32(v103, v99), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v104), v103));
    v107 = vmulq_f32(v106, v106);
    v108 = vmaxq_f32(vmulq_f32(v101, vaddq_f32(v105, vmulq_f32(v106, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v106, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v106)), vmulq_f32(v107, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v106)), vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v106))))))))))),
             *((float32x4_t *)a2 + 29));
    v109 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
    v110 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vcgtq_f32(v109, v108)));
    v111 = vsubq_f32(v108, v110);
    *(int8x16_t *)(v6 + v93) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v94, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v97, vsubq_f32(v100, *((float32x4_t *)a2 + 89))), (int8x16_t)vmulq_f32(v100, *((float32x4_t *)a2 + 88)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(vaddq_f32(v99, vmulq_f32(v111, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v111,
                                                                                    vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v111)), vmulq_f32(vmulq_f32(v111, v111), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v111)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v110)), 0x17uLL)))), (float32x4_t)vbslq_s8(v98, (int8x16_t)v95, (int8x16_t)v99)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t *v32;
  float32x4_t v33;
  float32x4_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  float32x4_t v40;
  float32x4_t v41;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v35 = 0;
        v36 = 16 * v8;
        v37 = 16 * v7;
        v38 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v39 = 0;
          do
          {
            v40 = v5[v39 / 0x10];
            v41 = vminq_f32(vmaxq_f32(v40, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v6[v39 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v40, (int8x16_t)vmulq_f32(v41, vminq_f32(vrsqrteq_f32(v41), *((float32x4_t *)a2 + 73))));
            v39 += 16;
          }
          while (v38 != v39);
          ++v35;
          v5 = (float32x4_t *)((char *)v5 + v36);
          v6 = (int8x16_t *)((char *)v6 + v37);
        }
        while (v35 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((float32x4_t *)a2 + 73);
          v31 = *((int8x16_t *)a2 + 15);
          v32 = &v6[v17];
          v32[-2] = vbslq_s8(v31, (int8x16_t)v20, (int8x16_t)vmulq_f32(v26, vminq_f32(vrsqrteq_f32(v26), v30)));
          v32[-1] = vbslq_s8(v31, (int8x16_t)v21, (int8x16_t)vmulq_f32(v27, vminq_f32(vrsqrteq_f32(v27), v30)));
          v14 += 4;
          *v32 = vbslq_s8(v31, (int8x16_t)v22, (int8x16_t)vmulq_f32(v28, vminq_f32(vrsqrteq_f32(v28), v30)));
          v32[1] = vbslq_s8(v31, (int8x16_t)v23, (int8x16_t)vmulq_f32(v29, vminq_f32(vrsqrteq_f32(v29), v30)));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v33 = *v18++;
            v34 = vminq_f32(vmaxq_f32(v33, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v33, (int8x16_t)vmulq_f32(v34, vminq_f32(vrsqrteq_f32(v34), *((float32x4_t *)a2 + 73))));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getrec601_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  uint64_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v76) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v18));
      v22 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v19));
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v20));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v24), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v22, v25), v27));
      v31 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v23, v26)));
      v32 = vaddq_f32(v28, v24);
      v33 = vaddq_f32(v28, v25);
      v34 = vaddq_f32(v28, v26);
      v35 = *((float32x4_t *)a2 + 9);
      v36 = *((float32x4_t *)a2 + 10);
      v37 = vsubq_f32(v32, vmulq_f32(v29, v35));
      v38 = *((float32x4_t *)a2 + 77);
      v39 = vmulq_f32(v38, v37);
      v40 = vmulq_f32(v38, vsubq_f32(v33, vmulq_f32(v30, v35)));
      v41 = vmulq_f32(v38, vsubq_f32(v34, vmulq_f32(v31, v35)));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = *((float32x4_t *)a2 + 11);
      v49 = *((float32x4_t *)a2 + 12);
      v50 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v39, v45))), v49);
      v51 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v40, v46))), v49);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v41, v47))), v49);
      v53 = vaddq_f32(vaddq_f32(v36, v47), vmulq_f32(v52, v52));
      v54 = vmaxq_f32(vaddq_f32(vaddq_f32(v36, v45), vmulq_f32(v50, v50)), v14);
      v55 = vmaxq_f32(vaddq_f32(vaddq_f32(v36, v46), vmulq_f32(v51, v51)), v14);
      v56 = *((float32x4_t *)a2 + 13);
      v57 = *((float32x4_t *)a2 + 14);
      v58 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v54, v56), v57));
      v59 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v55, v56), v57));
      v60 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v53, v14), v56), v57));
      v61 = *((float32x4_t *)a2 + 91);
      v62 = *((float32x4_t *)a2 + 92);
      v63 = (int8x16_t)vaddq_f32(v61, vmulq_f32(v62, v58));
      v64 = (int8x16_t)vaddq_f32(v61, vmulq_f32(v62, v59));
      v65 = vmulq_f32(v62, v60);
      v66 = *((float32x4_t *)a2 + 93);
      v67 = (int8x16_t)vmulq_f32(v18, v66);
      v68 = (int8x16_t)vaddq_f32(v61, v65);
      v69 = (int8x16_t)vmulq_f32(v19, v66);
      v70 = *((float32x4_t *)a2 + 94);
      v71 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v70));
      v72 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v70));
      v73 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v20, v70)), (int8x16_t)vmulq_f32(v20, v66), v68);
      v74 = *((int8x16_t *)a2 + 15);
      v75 = (int8x16_t *)(v6 + v10);
      *v75 = vbslq_s8(v74, (int8x16_t)v12, vbslq_s8(v71, v67, v63));
      v75[1] = vbslq_s8(v74, (int8x16_t)v13, vbslq_s8(v72, v69, v64));
      v75[2] = vbslq_s8(v74, (int8x16_t)v15, v73);
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v76) = -v11;
    if ((int)v76 >= v5)
      goto LABEL_3;
LABEL_10:
    v76 = v76;
    do
    {
      v77 = *(float32x4_t *)(v7 + 16 * v76);
      v78 = *((float32x4_t *)a2 + 75);
      v79 = *((float32x4_t *)a2 + 5);
      v80 = vminq_f32(vmaxq_f32(v77, v78), v79);
      v81 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)v80));
      v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
      v83 = vmulq_f32(*((float32x4_t *)a2 + 77), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v82), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v81, v82))), *((float32x4_t *)a2 + 9))));
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v85 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v84, v83)));
      v86 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v83, v85))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v76++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v77, vbslq_s8((int8x16_t)vcgtq_f32(v78, vsubq_f32(v80, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v80, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v85), vmulq_f32(v86, v86)), v78),
                                                                              *((float32x4_t *)a2 + 13)),
                                                                            *((float32x4_t *)a2 + 14)))))));
    }
    while (v76 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  int8x16_t v85;
  float32x4_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t *v90;
  int v91;
  uint64_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v91 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = *((float32x4_t *)a2 + 77);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v19 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v17, v14)), v14);
      v20 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, (int8x16_t)v16);
      v21 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, (int8x16_t)v18);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v26 = *((int8x16_t *)a2 + 21);
      v27 = *((float32x4_t *)a2 + 22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v20)));
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v21)));
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v30));
      v34 = vaddq_f32(vsubq_f32(v28, v27), v32);
      v35 = vmulq_f32(v31, v32);
      v36 = vmulq_f32(vmulq_f32(v31, v33), v25);
      v37 = vaddq_f32(vsubq_f32(v29, v27), v33);
      v38 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(v35, v24));
      v39 = vsubq_f32(vsubq_f32(v25, v15), v36);
      v40 = vmulq_f32(v38, v38);
      v41 = vmulq_f32(v39, v39);
      v42 = *((float32x4_t *)a2 + 37);
      v43 = *((float32x4_t *)a2 + 38);
      v44 = *((float32x4_t *)a2 + 39);
      v45 = *((float32x4_t *)a2 + 40);
      v46 = vaddq_f32(v42, vmulq_f32(v43, v38));
      v47 = vaddq_f32(v44, vmulq_f32(v45, v38));
      v48 = vaddq_f32(v44, vmulq_f32(v45, v39));
      v49 = vaddq_f32(v42, vmulq_f32(v43, v39));
      v50 = *((float32x4_t *)a2 + 41);
      v51 = *((float32x4_t *)a2 + 42);
      v52 = vaddq_f32(vaddq_f32(v50, vmulq_f32(v51, v39)), vmulq_f32(v41, vaddq_f32(v49, vmulq_f32(v41, v48))));
      v53 = vmulq_f32(v38, vaddq_f32(vaddq_f32(v50, vmulq_f32(v51, v38)), vmulq_f32(v40, vaddq_f32(v46, vmulq_f32(v40, v47)))));
      v54 = *((float32x4_t *)a2 + 43);
      v55 = *((float32x4_t *)a2 + 44);
      v56 = vmulq_f32(v17, vaddq_f32(v34, vmulq_f32(v38, vaddq_f32(v54, v53))));
      v57 = vmulq_f32(v17, vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v54, vmulq_f32(v39, v52)))));
      v58 = *((float32x4_t *)a2 + 29);
      v59 = vmaxq_f32(v56, v58);
      v60 = vmaxq_f32(v57, v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 45);
      v68 = *((float32x4_t *)a2 + 46);
      v69 = vaddq_f32(v55, vmulq_f32(v67, v65));
      v70 = vaddq_f32(v55, vmulq_f32(v67, v66));
      v71 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v73 = vaddq_f32(v15, vmulq_f32(v65, vaddq_f32(v72, vmulq_f32(v65, vaddq_f32(vaddq_f32(v68, vmulq_f32(v65, v71)), vmulq_f32(vmulq_f32(v65, v65), v69))))));
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v72, vmulq_f32(v66, vaddq_f32(vaddq_f32(v68, vmulq_f32(v71, v66)), vmulq_f32(vmulq_f32(v66, v66), v70))))));
      v76 = (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v63)), 0x17uLL);
      v77 = (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v64)), 0x17uLL);
      v78 = vmulq_f32(v73, v76);
      v79 = *((float32x4_t *)a2 + 91);
      v80 = *((float32x4_t *)a2 + 92);
      v81 = (int8x16_t)vaddq_f32(v79, vmulq_f32(v80, v78));
      v82 = vmulq_f32(v80, vmulq_f32(v75, v77));
      v83 = *((float32x4_t *)a2 + 93);
      v84 = (int8x16_t)vmulq_f32(v16, v83);
      v85 = (int8x16_t)vaddq_f32(v79, v82);
      v86 = *((float32x4_t *)a2 + 94);
      v87 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v86));
      v88 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v86)), (int8x16_t)vmulq_f32(v18, v83), v85);
      v89 = *((int8x16_t *)a2 + 15);
      v90 = (int8x16_t *)(v6 + v11);
      v90[-1] = vbslq_s8(v89, (int8x16_t)v13, vbslq_s8(v87, v84, v81));
      *v90 = vbslq_s8(v89, (int8x16_t)v12, v88);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v91 = -v10;
    if (v91 >= v5)
      goto LABEL_3;
LABEL_10:
    v92 = 16 * v91;
    v93 = *(float32x4_t *)(v7 + v92);
    v94 = *((float32x4_t *)a2 + 75);
    v95 = *((float32x4_t *)a2 + 5);
    v96 = vminq_f32(vmaxq_f32(v93, v94), v95);
    v97 = *((float32x4_t *)a2 + 77);
    v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vceqq_f32(v97, v94)), v94), (int8x16_t)v95, (int8x16_t)v96);
    v99 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v98), (int8x16_t)v95);
    v100 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v99, *((float32x4_t *)a2 + 23)));
    v101 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v98))), *((float32x4_t *)a2 + 22)), v100);
    v102 = vsubq_f32(vsubq_f32(v99, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v100), v99));
    v103 = vmulq_f32(v102, v102);
    v104 = vmaxq_f32(vmulq_f32(v97, vaddq_f32(v101, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v102, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v102)), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v102)), vmulq_f32(v103, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v102))))))))))),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    *(int8x16_t *)(v6 + v92) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v93, vbslq_s8((int8x16_t)vcgtq_f32(v94, vsubq_f32(v96, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v96, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v95, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v107, vaddq_f32(
                                                              vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v107)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  int v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v76 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((int8x16_t *)a2 + 19);
      v19 = *((float32x4_t *)a2 + 20);
      v20 = (float32x4_t)vorrq_s8(vandq_s8(v18, (int8x16_t)v16), (int8x16_t)v15);
      v21 = (float32x4_t)vorrq_s8(vandq_s8(v18, (int8x16_t)v17), (int8x16_t)v15);
      v22 = (int8x16_t)vcgtq_f32(v19, v16);
      v23 = *((int8x16_t *)a2 + 21);
      v24 = *((float32x4_t *)a2 + 22);
      v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v19, v17)));
      v26 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v23, v22)), v24);
      v27 = *((float32x4_t *)a2 + 23);
      v28 = *((float32x4_t *)a2 + 24);
      v29 = vsubq_f32(v25, v24);
      v30 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v27));
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v21, v27));
      v32 = vsubq_f32(vsubq_f32(v20, v15), vmulq_f32(vmulq_f32(v28, v30), v20));
      v33 = vsubq_f32(vsubq_f32(v21, v15), vmulq_f32(vmulq_f32(v28, v31), v21));
      v34 = *((float32x4_t *)a2 + 25);
      v35 = *((float32x4_t *)a2 + 26);
      v36 = vaddq_f32(v34, vmulq_f32(v35, v32));
      v37 = vaddq_f32(v34, vmulq_f32(v35, v33));
      v38 = *((float32x4_t *)a2 + 27);
      v39 = *((float32x4_t *)a2 + 28);
      v40 = vaddq_f32(vaddq_f32(v29, v31), vmulq_f32(v33, vaddq_f32(vaddq_f32(v38, vmulq_f32(v33, v39)), vmulq_f32(vmulq_f32(v33, v33), v37))));
      v41 = *((float32x4_t *)a2 + 77);
      v42 = vmulq_f32(v41, vaddq_f32(vaddq_f32(v26, v30), vmulq_f32(v32, vaddq_f32(vaddq_f32(v38, vmulq_f32(v32, v39)), vmulq_f32(vmulq_f32(v32, v32), v36)))));
      v43 = vmulq_f32(v41, v40);
      v44 = *((float32x4_t *)a2 + 29);
      v45 = *((float32x4_t *)a2 + 30);
      v46 = vmaxq_f32(v42, v44);
      v47 = vmaxq_f32(v43, v44);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v46, v50);
      v53 = *((float32x4_t *)a2 + 31);
      v54 = *((float32x4_t *)a2 + 32);
      v55 = vsubq_f32(v47, v51);
      v56 = vmulq_f32(v55, vaddq_f32(v54, vmulq_f32(v55, vaddq_f32(v45, vmulq_f32(v53, v55)))));
      v57 = vaddq_f32(v15, vmulq_f32(v52, vaddq_f32(v54, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v53, v52))))));
      v58 = vcvtq_s32_f32(v51);
      v59 = *((int32x4_t *)a2 + 33);
      v60 = vaddq_f32(v15, v56);
      v61 = (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL);
      v62 = (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL);
      v63 = vmulq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 91);
      v65 = *((float32x4_t *)a2 + 92);
      v66 = (int8x16_t)vaddq_f32(v64, vmulq_f32(v65, v63));
      v67 = vmulq_f32(v65, vmulq_f32(v60, v62));
      v68 = *((float32x4_t *)a2 + 93);
      v69 = (int8x16_t)vmulq_f32(v16, v68);
      v70 = (int8x16_t)vaddq_f32(v64, v67);
      v71 = *((float32x4_t *)a2 + 94);
      v72 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v71));
      v73 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v71)), (int8x16_t)vmulq_f32(v17, v68), v70);
      v74 = *((int8x16_t *)a2 + 15);
      v75 = (int8x16_t *)(v6 + v11);
      v75[-1] = vbslq_s8(v74, (int8x16_t)v13, vbslq_s8(v72, v69, v66));
      *v75 = vbslq_s8(v74, (int8x16_t)v12, v73);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v76 = -v10;
    if (v76 >= v5)
      goto LABEL_3;
LABEL_10:
    v77 = 16 * v76;
    v78 = *(float32x4_t *)(v7 + v77);
    v79 = *((float32x4_t *)a2 + 75);
    v80 = *((float32x4_t *)a2 + 5);
    v81 = vminq_f32(vmaxq_f32(v78, v79), v80);
    v82 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v81), (int8x16_t)v80);
    v83 = (float32x4_t)vandq_s8((int8x16_t)v80, (int8x16_t)vcgtq_f32(v82, *((float32x4_t *)a2 + 23)));
    v84 = vsubq_f32(vsubq_f32(v82, v80), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v83), v82));
    v85 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v81, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v81))), *((float32x4_t *)a2 + 22)), v83), vmulq_f32(v84, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v84, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v84))))))),
            *((float32x4_t *)a2 + 29));
    v86 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
    v87 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v80, (int8x16_t)vcgtq_f32(v86, v85)));
    v88 = vsubq_f32(v85, v87);
    *(int8x16_t *)(v6 + v77) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v78, vbslq_s8((int8x16_t)vcgtq_f32(v79, vsubq_f32(v81, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v81, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v80, vmulq_f32(v88, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v88, vaddq_f32(
                                                              *((float32x4_t *)a2 + 30),
                                                              vmulq_f32(*((float32x4_t *)a2 + 31), v88)))))),
                                                    (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v87)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t *v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = (int8x16_t)vcgtq_f32(v18, v17);
      v21 = *((int8x16_t *)a2 + 83);
      v22 = *((float32x4_t *)a2 + 5);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v21, (int8x16_t)v22));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v20, v21, (int8x16_t)v22));
      v25 = *((float32x4_t *)a2 + 84);
      v26 = vminq_f32(v23, v25);
      v27 = vminq_f32(v24, v25);
      v28 = *((int8x16_t *)a2 + 19);
      v29 = *((float32x4_t *)a2 + 20);
      v30 = (float32x4_t)vorrq_s8(vandq_s8(v28, (int8x16_t)v26), (int8x16_t)v22);
      v31 = *((int8x16_t *)a2 + 21);
      v32 = *((float32x4_t *)a2 + 22);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v28, (int8x16_t)v27), (int8x16_t)v22);
      v34 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v29, v27)));
      v35 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v29, v26))), v32);
      v36 = *((float32x4_t *)a2 + 23);
      v37 = *((float32x4_t *)a2 + 24);
      v38 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v30, v36));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v33, v36));
      v40 = vaddq_f32(v35, v38);
      v41 = vmulq_f32(v37, v38);
      v42 = vmulq_f32(vmulq_f32(v37, v39), v33);
      v43 = vaddq_f32(vsubq_f32(v34, v32), v39);
      v44 = vsubq_f32(vsubq_f32(v30, v22), vmulq_f32(v41, v30));
      v45 = vsubq_f32(vsubq_f32(v33, v22), v42);
      v46 = *((float32x4_t *)a2 + 25);
      v47 = *((float32x4_t *)a2 + 26);
      v48 = vaddq_f32(v46, vmulq_f32(v47, v44));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v45));
      v51 = *((float32x4_t *)a2 + 27);
      v50 = *((float32x4_t *)a2 + 28);
      v52 = vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v51, vmulq_f32(v45, v50)), vmulq_f32(vmulq_f32(v45, v45), v49))));
      v53 = *((float32x4_t *)a2 + 77);
      v54 = vmulq_f32(v53, vaddq_f32(v40, vmulq_f32(v44, vaddq_f32(vaddq_f32(v51, vmulq_f32(v44, v50)), vmulq_f32(vmulq_f32(v44, v44), v48)))));
      v55 = vmulq_f32(v53, v52);
      v56 = *((float32x4_t *)a2 + 29);
      v57 = *((float32x4_t *)a2 + 30);
      v58 = vmaxq_f32(v54, v56);
      v59 = vmaxq_f32(v55, v56);
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v58, v62);
      v65 = vsubq_f32(v59, v63);
      v66 = *((float32x4_t *)a2 + 31);
      v67 = *((float32x4_t *)a2 + 32);
      v68 = vmulq_f32(v65, vaddq_f32(v67, vmulq_f32(v65, vaddq_f32(v57, vmulq_f32(v66, v65)))));
      v69 = vaddq_f32(v22, vmulq_f32(v64, vaddq_f32(v67, vmulq_f32(v64, vaddq_f32(v57, vmulq_f32(v66, v64))))));
      v70 = vcvtq_s32_f32(v63);
      v71 = *((int32x4_t *)a2 + 33);
      v72 = vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v71, vcvtq_s32_f32(v62)), 0x17uLL));
      v73 = vmulq_f32(vaddq_f32(v22, v68), (float32x4_t)vshlq_n_s32(vaddq_s32(v71, v70), 0x17uLL));
      v74 = *((float32x4_t *)a2 + 91);
      v75 = *((float32x4_t *)a2 + 92);
      v76 = vmulq_f32(v75, v73);
      v77 = (int8x16_t)vaddq_f32(v74, vmulq_f32(v75, v72));
      v78 = *((float32x4_t *)a2 + 93);
      v79 = *((float32x4_t *)a2 + 94);
      v80 = (int8x16_t *)(v6 + v11);
      v80[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v79)), (int8x16_t)vmulq_f32(v23, v78), v77), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v22)));
      *v80 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v79)), (int8x16_t)vmulq_f32(v24, v78), (int8x16_t)vaddq_f32(v74, v76)), (float32x4_t)vbslq_s8(v20, (int8x16_t)v14, (int8x16_t)v22)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((float32x4_t *)a2 + 82);
    v85 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, (int8x16_t)vmaxq_f32(v83, v84));
    v86 = *((float32x4_t *)a2 + 75);
    v87 = (int8x16_t)vcgtq_f32(v86, v85);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vmulq_f32(v85, (float32x4_t)vbslq_s8(v87, *((int8x16_t *)a2 + 83), (int8x16_t)v88));
    v90 = vminq_f32(v89, *((float32x4_t *)a2 + 84));
    v91 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v90), (int8x16_t)v88);
    v92 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v91, *((float32x4_t *)a2 + 23)));
    v93 = vsubq_f32(vsubq_f32(v91, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v92), v91));
    v94 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 77), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v90))), *((float32x4_t *)a2 + 22)), v92), vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v93, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v93, v93), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v93))))))),
            *((float32x4_t *)a2 + 29));
    v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
    v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v95, v94)));
    v97 = vsubq_f32(v94, v96);
    *(int8x16_t *)(v6 + v82) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v89, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v88, vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 32),
                                                                                    vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v97)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v96)), 0x17uLL))))), (float32x4_t)vbslq_s8(v87, (int8x16_t)v84, (int8x16_t)v88)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getrec601_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t *v87;
  int v88;
  uint64_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v88 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = *((int8x16_t *)a2 + 83);
      v21 = *((float32x4_t *)a2 + 5);
      v22 = (int8x16_t)vcgtq_f32(v18, v17);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v20, (int8x16_t)v21));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v22, v20, (int8x16_t)v21));
      v25 = *((float32x4_t *)a2 + 84);
      v26 = (int8x16_t)vminq_f32(v23, v25);
      v27 = (int8x16_t)vminq_f32(v24, v25);
      v28 = *((float32x4_t *)a2 + 77);
      v29 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v28, v18)), v18);
      v30 = (float32x4_t)vbslq_s8(v29, (int8x16_t)v21, v26);
      v31 = (float32x4_t)vbslq_s8(v29, (int8x16_t)v21, v27);
      v32 = *((int8x16_t *)a2 + 19);
      v33 = *((float32x4_t *)a2 + 20);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v21);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v31), (int8x16_t)v21);
      v36 = *((int8x16_t *)a2 + 21);
      v37 = *((float32x4_t *)a2 + 22);
      v38 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v33, v31)));
      v39 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v33, v30))), v37);
      v40 = *((float32x4_t *)a2 + 23);
      v41 = *((float32x4_t *)a2 + 24);
      v42 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v34, v40));
      v43 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v35, v40));
      v44 = vaddq_f32(v39, v42);
      v45 = vaddq_f32(vsubq_f32(v38, v37), v43);
      v46 = vsubq_f32(vsubq_f32(v34, v21), vmulq_f32(vmulq_f32(v41, v42), v34));
      v47 = vsubq_f32(vsubq_f32(v35, v21), vmulq_f32(vmulq_f32(v41, v43), v35));
      v48 = vmulq_f32(v46, v46);
      v49 = vmulq_f32(v47, v47);
      v50 = *((float32x4_t *)a2 + 37);
      v51 = *((float32x4_t *)a2 + 38);
      v52 = vaddq_f32(v50, vmulq_f32(v51, v46));
      v53 = *((float32x4_t *)a2 + 39);
      v54 = *((float32x4_t *)a2 + 40);
      v55 = vaddq_f32(v50, vmulq_f32(v51, v47));
      v56 = vaddq_f32(v53, vmulq_f32(v54, v46));
      v57 = vaddq_f32(v53, vmulq_f32(v54, v47));
      v58 = *((float32x4_t *)a2 + 41);
      v59 = *((float32x4_t *)a2 + 42);
      v60 = vaddq_f32(vaddq_f32(v58, vmulq_f32(v59, v47)), vmulq_f32(v49, vaddq_f32(v55, vmulq_f32(v49, v57))));
      v61 = vmulq_f32(v46, vaddq_f32(vaddq_f32(v58, vmulq_f32(v59, v46)), vmulq_f32(v48, vaddq_f32(v52, vmulq_f32(v48, v56)))));
      v62 = *((float32x4_t *)a2 + 43);
      v63 = *((float32x4_t *)a2 + 44);
      v64 = vaddq_f32(v45, vmulq_f32(v47, vaddq_f32(v62, vmulq_f32(v47, v60))));
      v65 = *((float32x4_t *)a2 + 29);
      v66 = vmaxq_f32(vmulq_f32(v28, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(v62, v61)))), v65);
      v67 = vmaxq_f32(vmulq_f32(v28, v64), v65);
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v68, v66)));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v66, v70);
      v73 = vsubq_f32(v67, v71);
      v74 = *((float32x4_t *)a2 + 45);
      v75 = *((float32x4_t *)a2 + 46);
      v76 = *((float32x4_t *)a2 + 47);
      v77 = *((float32x4_t *)a2 + 48);
      v78 = *((int32x4_t *)a2 + 33);
      v79 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v72, vaddq_f32(v77, vmulq_f32(v72, vaddq_f32(vaddq_f32(v75, vmulq_f32(v72, v76)), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(v63, vmulq_f32(v74, v72)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v70)), 0x17uLL));
      v80 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v73, vaddq_f32(v77, vmulq_f32(v73, vaddq_f32(vaddq_f32(v75, vmulq_f32(v76, v73)), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(v63, vmulq_f32(v74, v73)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v71)), 0x17uLL));
      v81 = *((float32x4_t *)a2 + 91);
      v82 = *((float32x4_t *)a2 + 92);
      v83 = vmulq_f32(v82, v80);
      v84 = (int8x16_t)vaddq_f32(v81, vmulq_f32(v82, v79));
      v85 = *((float32x4_t *)a2 + 93);
      v86 = *((float32x4_t *)a2 + 94);
      v87 = (int8x16_t *)(v6 + v11);
      v87[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v86)), (int8x16_t)vmulq_f32(v23, v85), v84), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v21)));
      *v87 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v86)), (int8x16_t)vmulq_f32(v24, v85), (int8x16_t)vaddq_f32(v81, v83)), (float32x4_t)vbslq_s8(v22, (int8x16_t)v14, (int8x16_t)v21)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v88 = -v10;
    if (v88 >= v5)
      goto LABEL_3;
LABEL_10:
    v89 = 16 * v88;
    v90 = *(float32x4_t *)(v7 + v89);
    v91 = *((float32x4_t *)a2 + 82);
    v92 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v90, (int8x16_t)vmaxq_f32(v90, v91));
    v93 = *((float32x4_t *)a2 + 75);
    v94 = (int8x16_t)vcgtq_f32(v93, v92);
    v95 = *((float32x4_t *)a2 + 5);
    v96 = vmulq_f32(v92, (float32x4_t)vbslq_s8(v94, *((int8x16_t *)a2 + 83), (int8x16_t)v95));
    v97 = *((float32x4_t *)a2 + 77);
    v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vceqq_f32(v97, v93)), v93), (int8x16_t)v95, (int8x16_t)vminq_f32(v96, *((float32x4_t *)a2 + 84)));
    v99 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v98), (int8x16_t)v95);
    v100 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v99, *((float32x4_t *)a2 + 23)));
    v101 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v98))), *((float32x4_t *)a2 + 22)), v100);
    v102 = vsubq_f32(vsubq_f32(v99, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v100), v99));
    v103 = vmulq_f32(v102, v102);
    v104 = vmaxq_f32(vmulq_f32(v97, vaddq_f32(v101, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v102, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v102)), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v102)), vmulq_f32(v103, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v102))))))))))),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    *(int8x16_t *)(v6 + v89) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v90, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v93, vsubq_f32(v96, *((float32x4_t *)a2 + 94))), (int8x16_t)vmulq_f32(v96, *((float32x4_t *)a2 + 93)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 91), vmulq_f32(*((float32x4_t *)a2 + 92), vmulq_f32(vaddq_f32(v95, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 48),
                                                                                    vmulq_f32(v107, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v107)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL))))),
                                              (float32x4_t)vbslq_s8(v94, (int8x16_t)v91, (int8x16_t)v95)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  float32x4_t v39;
  float32x4_t v40;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v34 = 0;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v39 = v5[v38 / 0x10];
            v40 = vminq_f32(vmaxq_f32(v39, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v6[v38 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v39, (int8x16_t)vmulq_f32(v40, v40));
            v38 += 16;
          }
          while (v37 != v38);
          ++v34;
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (int8x16_t *)((char *)v6 + v36);
        }
        while (v34 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((int8x16_t *)a2 + 15);
          v31 = &v6[v17];
          v31[-2] = vbslq_s8(v30, (int8x16_t)v20, (int8x16_t)vmulq_f32(v26, v26));
          v31[-1] = vbslq_s8(v30, (int8x16_t)v21, (int8x16_t)vmulq_f32(v27, v27));
          v14 += 4;
          *v31 = vbslq_s8(v30, (int8x16_t)v22, (int8x16_t)vmulq_f32(v28, v28));
          v31[1] = vbslq_s8(v30, (int8x16_t)v23, (int8x16_t)vmulq_f32(v29, v29));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v32 = *v18++;
            v33 = vminq_f32(vmaxq_f32(v32, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v32, (int8x16_t)vmulq_f32(v33, v33));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_rec601_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t *v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v75) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v21 = *((float32x4_t *)a2 + 95);
      v22 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v21)));
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v21)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v20, v21)));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = *((float32x4_t *)a2 + 7);
      v29 = *((float32x4_t *)a2 + 8);
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v22, v25), v28));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v23, v26), v28));
      v32 = vaddq_f32(v29, v25);
      v33 = vrsqrteq_f32(vaddq_f32(v28, vsubq_f32(v24, v27)));
      v34 = vaddq_f32(v29, v26);
      v35 = vaddq_f32(v29, v27);
      v36 = *((float32x4_t *)a2 + 9);
      v37 = *((float32x4_t *)a2 + 10);
      v38 = vsubq_f32(v32, vmulq_f32(v30, v36));
      v39 = vsubq_f32(v34, vmulq_f32(v31, v36));
      v40 = *((float32x4_t *)a2 + 86);
      v41 = vmulq_f32(v40, v38);
      v42 = vmulq_f32(v40, v39);
      v43 = vmulq_f32(v40, vsubq_f32(v35, vmulq_f32(v33, v36)));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v45, v42)));
      v49 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v46, v43)));
      v50 = *((float32x4_t *)a2 + 11);
      v51 = *((float32x4_t *)a2 + 12);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v41, v47))), v51);
      v53 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v42, v48))), v51);
      v54 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v43, v49))), v51);
      v55 = vaddq_f32(vaddq_f32(v37, v49), vmulq_f32(v54, v54));
      v56 = vmaxq_f32(vaddq_f32(vaddq_f32(v37, v47), vmulq_f32(v52, v52)), v14);
      v57 = vmaxq_f32(vaddq_f32(vaddq_f32(v37, v48), vmulq_f32(v53, v53)), v14);
      v58 = *((float32x4_t *)a2 + 13);
      v59 = *((float32x4_t *)a2 + 14);
      v60 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v56, v58), v59));
      v61 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v57, v58), v59));
      v62 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v55, v14), v58), v59));
      v63 = *((float32x4_t *)a2 + 96);
      v64 = *((float32x4_t *)a2 + 97);
      v65 = (int8x16_t)vmulq_f32(v18, v64);
      v66 = (int8x16_t)vmulq_f32(v19, v64);
      v67 = (int8x16_t)vmulq_f32(v20, v64);
      v68 = *((float32x4_t *)a2 + 98);
      v69 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v68));
      v70 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v68));
      v71 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v20, v68));
      v72 = vbslq_s8(v69, v65, (int8x16_t)vmulq_f32(v63, v60));
      v73 = *((int8x16_t *)a2 + 15);
      v74 = (int8x16_t *)(v6 + v10);
      *v74 = vbslq_s8(v73, (int8x16_t)v12, v72);
      v74[1] = vbslq_s8(v73, (int8x16_t)v13, vbslq_s8(v70, v66, (int8x16_t)vmulq_f32(v63, v61)));
      v74[2] = vbslq_s8(v73, (int8x16_t)v15, vbslq_s8(v71, v67, (int8x16_t)vmulq_f32(v63, v62)));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v75) = -v11;
    if ((int)v75 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = v75;
    do
    {
      v76 = *(float32x4_t *)(v7 + 16 * v75);
      v77 = *((float32x4_t *)a2 + 75);
      v78 = *((float32x4_t *)a2 + 5);
      v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
      v80 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v79, *((float32x4_t *)a2 + 95))));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v82 = vmulq_f32(*((float32x4_t *)a2 + 86), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v81), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v80, v81))), *((float32x4_t *)a2 + 9))));
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v83, v82)));
      v85 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v82, v84))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v75++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v79, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v84), vmulq_f32(v85, v85)), v77), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))))));
    }
    while (v75 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 95);
      v19 = (int8x16_t)vaddq_f32(v16, v18);
      v20 = (int8x16_t)vaddq_f32(v17, v18);
      v21 = *((float32x4_t *)a2 + 86);
      v22 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v21, v14)), v14);
      v23 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v19);
      v24 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v20);
      v25 = *((int8x16_t *)a2 + 19);
      v26 = *((float32x4_t *)a2 + 20);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v23), (int8x16_t)v15);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v24), (int8x16_t)v15);
      v29 = *((int8x16_t *)a2 + 21);
      v30 = *((float32x4_t *)a2 + 22);
      v31 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v24)));
      v32 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v23))), v30);
      v33 = *((float32x4_t *)a2 + 23);
      v34 = *((float32x4_t *)a2 + 24);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v33));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v33));
      v37 = vaddq_f32(v32, v35);
      v38 = vaddq_f32(vsubq_f32(v31, v30), v36);
      v39 = vsubq_f32(vsubq_f32(v27, v15), vmulq_f32(vmulq_f32(v34, v35), v27));
      v40 = vsubq_f32(vsubq_f32(v28, v15), vmulq_f32(vmulq_f32(v34, v36), v28));
      v41 = vmulq_f32(v39, v39);
      v42 = vmulq_f32(v40, v40);
      v43 = *((float32x4_t *)a2 + 37);
      v44 = *((float32x4_t *)a2 + 38);
      v45 = vaddq_f32(v43, vmulq_f32(v44, v39));
      v46 = *((float32x4_t *)a2 + 39);
      v47 = *((float32x4_t *)a2 + 40);
      v48 = vaddq_f32(v43, vmulq_f32(v44, v40));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v39));
      v50 = vaddq_f32(v46, vmulq_f32(v47, v40));
      v51 = *((float32x4_t *)a2 + 41);
      v52 = *((float32x4_t *)a2 + 42);
      v53 = vaddq_f32(vaddq_f32(v51, vmulq_f32(v52, v40)), vmulq_f32(v42, vaddq_f32(v48, vmulq_f32(v42, v50))));
      v54 = vmulq_f32(v39, vaddq_f32(vaddq_f32(v51, vmulq_f32(v52, v39)), vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, v49)))));
      v55 = *((float32x4_t *)a2 + 43);
      v56 = *((float32x4_t *)a2 + 44);
      v57 = vaddq_f32(v38, vmulq_f32(v40, vaddq_f32(v55, vmulq_f32(v40, v53))));
      v58 = *((float32x4_t *)a2 + 29);
      v59 = vmaxq_f32(vmulq_f32(v21, vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v55, v54)))), v58);
      v60 = vmaxq_f32(vmulq_f32(v21, v57), v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 45);
      v68 = *((float32x4_t *)a2 + 46);
      v69 = *((float32x4_t *)a2 + 47);
      v70 = *((float32x4_t *)a2 + 48);
      v71 = vaddq_f32(v15, vmulq_f32(v65, vaddq_f32(v70, vmulq_f32(v65, vaddq_f32(vaddq_f32(v68, vmulq_f32(v65, v69)), vmulq_f32(vmulq_f32(v65, v65), vaddq_f32(v56, vmulq_f32(v67, v65))))))));
      v72 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v70, vmulq_f32(v66, vaddq_f32(vaddq_f32(v68, vmulq_f32(v69, v66)), vmulq_f32(vmulq_f32(v66, v66), vaddq_f32(v56, vmulq_f32(v67, v66))))))));
      v73 = *((int32x4_t *)a2 + 33);
      v74 = vmulq_f32(v71, (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v63)), 0x17uLL));
      v75 = vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v64)), 0x17uLL));
      v76 = *((float32x4_t *)a2 + 96);
      v77 = *((float32x4_t *)a2 + 97);
      v78 = (int8x16_t)vmulq_f32(v16, v77);
      v79 = *((float32x4_t *)a2 + 98);
      v80 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v79));
      v81 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v79)), (int8x16_t)vmulq_f32(v17, v77), (int8x16_t)vmulq_f32(v76, v75));
      v82 = *((int8x16_t *)a2 + 15);
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v82, (int8x16_t)v13, vbslq_s8(v80, v78, (int8x16_t)vmulq_f32(v76, v74)));
      *v83 = vbslq_s8(v82, (int8x16_t)v12, v81);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((float32x4_t *)a2 + 75);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
    v90 = *((float32x4_t *)a2 + 86);
    v91 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vceqq_f32(v90, v87)), v87), (int8x16_t)v88, (int8x16_t)vaddq_f32(v89, *((float32x4_t *)a2 + 95)));
    v92 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v91), (int8x16_t)v88);
    v93 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v92, *((float32x4_t *)a2 + 23)));
    v94 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v91, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v91))), *((float32x4_t *)a2 + 22)), v93);
    v95 = vsubq_f32(vsubq_f32(v92, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v93), v92));
    v96 = vmulq_f32(v95, v95);
    v97 = vmaxq_f32(vmulq_f32(v90, vaddq_f32(v94, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v95)), vmulq_f32(v96, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v95)), vmulq_f32(v96, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v95))))))))))),
            *((float32x4_t *)a2 + 29));
    v98 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
    v99 = vsubq_f32(v98, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v98, v97)));
    v100 = vsubq_f32(v97, v99);
    *(int8x16_t *)(v6 + v85) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v88, vmulq_f32(v100, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v100, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46),
                                                              vmulq_f32(*((float32x4_t *)a2 + 47), v100)),
                                                            vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v100)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v99)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t *v73;
  int v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v74 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 95);
      v19 = vaddq_f32(v16, v18);
      v20 = vaddq_f32(v17, v18);
      v21 = *((int8x16_t *)a2 + 19);
      v22 = *((float32x4_t *)a2 + 20);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v19), (int8x16_t)v15);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v15);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v20)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v19))), v25);
      v29 = *((float32x4_t *)a2 + 23);
      v30 = *((float32x4_t *)a2 + 24);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vmulq_f32(v30, v31);
      v35 = vmulq_f32(vmulq_f32(v30, v32), v26);
      v36 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v37 = vsubq_f32(vsubq_f32(v23, v15), vmulq_f32(v34, v23));
      v38 = vsubq_f32(vsubq_f32(v26, v15), v35);
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v44 = *((float32x4_t *)a2 + 27);
      v43 = *((float32x4_t *)a2 + 28);
      v45 = vaddq_f32(v36, vmulq_f32(v38, vaddq_f32(vaddq_f32(v44, vmulq_f32(v38, v43)), vmulq_f32(vmulq_f32(v38, v38), v42))));
      v46 = *((float32x4_t *)a2 + 86);
      v47 = vmulq_f32(v46, vaddq_f32(v33, vmulq_f32(v37, vaddq_f32(vaddq_f32(v44, vmulq_f32(v37, v43)), vmulq_f32(vmulq_f32(v37, v37), v41)))));
      v48 = vmulq_f32(v46, v45);
      v49 = *((float32x4_t *)a2 + 29);
      v50 = *((float32x4_t *)a2 + 30);
      v51 = vmaxq_f32(v47, v49);
      v52 = vmaxq_f32(v48, v49);
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v54, v52)));
      v57 = vsubq_f32(v51, v55);
      v58 = vsubq_f32(v52, v56);
      v59 = *((float32x4_t *)a2 + 31);
      v60 = *((float32x4_t *)a2 + 32);
      v61 = vaddq_f32(v15, vmulq_f32(v57, vaddq_f32(v60, vmulq_f32(v57, vaddq_f32(v50, vmulq_f32(v59, v57))))));
      v62 = vaddq_f32(v15, vmulq_f32(v58, vaddq_f32(v60, vmulq_f32(v58, vaddq_f32(v50, vmulq_f32(v59, v58))))));
      v63 = *((int32x4_t *)a2 + 33);
      v64 = vmulq_f32(v61, (float32x4_t)vshlq_n_s32(vaddq_s32(v63, vcvtq_s32_f32(v55)), 0x17uLL));
      v65 = vmulq_f32(v62, (float32x4_t)vshlq_n_s32(vaddq_s32(v63, vcvtq_s32_f32(v56)), 0x17uLL));
      v66 = *((float32x4_t *)a2 + 96);
      v67 = *((float32x4_t *)a2 + 97);
      v68 = (int8x16_t)vmulq_f32(v16, v67);
      v69 = *((float32x4_t *)a2 + 98);
      v70 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v69));
      v71 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v69)), (int8x16_t)vmulq_f32(v17, v67), (int8x16_t)vmulq_f32(v66, v65));
      v72 = *((int8x16_t *)a2 + 15);
      v73 = (int8x16_t *)(v6 + v11);
      v73[-1] = vbslq_s8(v72, (int8x16_t)v13, vbslq_s8(v70, v68, (int8x16_t)vmulq_f32(v66, v64)));
      *v73 = vbslq_s8(v72, (int8x16_t)v12, v71);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v74 = -v10;
    if (v74 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = 16 * v74;
    v76 = *(float32x4_t *)(v7 + v75);
    v77 = *((float32x4_t *)a2 + 75);
    v78 = *((float32x4_t *)a2 + 5);
    v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
    v80 = vaddq_f32(v79, *((float32x4_t *)a2 + 95));
    v81 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v80), (int8x16_t)v78);
    v82 = (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v81, *((float32x4_t *)a2 + 23)));
    v83 = vsubq_f32(vsubq_f32(v81, v78), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v82), v81));
    v84 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v80, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v80))), *((float32x4_t *)a2 + 22)), v82), vmulq_f32(v83, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v83, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v83, v83), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v83))))))),
            *((float32x4_t *)a2 + 29));
    v85 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
    v86 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v85, v84)));
    v87 = vsubq_f32(v84, v86);
    *(int8x16_t *)(v6 + v75) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v79, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v78, vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v87)))))),
                                                  (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v86)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t *v76;
  int v77;
  uint64_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v77 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = (int8x16_t)vcgtq_f32(v18, v17);
      v21 = *((int8x16_t *)a2 + 83);
      v22 = *((float32x4_t *)a2 + 5);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v21, (int8x16_t)v22));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v20, v21, (int8x16_t)v22));
      v25 = *((float32x4_t *)a2 + 90);
      v26 = *((float32x4_t *)a2 + 95);
      v27 = vaddq_f32(vminq_f32(v23, v25), v26);
      v28 = vaddq_f32(vminq_f32(v24, v25), v26);
      v29 = *((int8x16_t *)a2 + 19);
      v30 = *((float32x4_t *)a2 + 20);
      v31 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v27), (int8x16_t)v22);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v28), (int8x16_t)v22);
      v33 = *((int8x16_t *)a2 + 21);
      v34 = *((float32x4_t *)a2 + 22);
      v35 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v30, v28)));
      v36 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v30, v27))), v34);
      v37 = *((float32x4_t *)a2 + 23);
      v38 = *((float32x4_t *)a2 + 24);
      v39 = vsubq_f32(v35, v34);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v31, v37));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v32, v37));
      v42 = vaddq_f32(v36, v40);
      v43 = vsubq_f32(vsubq_f32(v31, v22), vmulq_f32(vmulq_f32(v38, v40), v31));
      v44 = vsubq_f32(vsubq_f32(v32, v22), vmulq_f32(vmulq_f32(v38, v41), v32));
      v45 = *((float32x4_t *)a2 + 25);
      v46 = *((float32x4_t *)a2 + 26);
      v47 = vaddq_f32(v45, vmulq_f32(v46, v43));
      v48 = vaddq_f32(v45, vmulq_f32(v46, v44));
      v49 = *((float32x4_t *)a2 + 27);
      v50 = *((float32x4_t *)a2 + 28);
      v51 = vaddq_f32(vaddq_f32(v39, v41), vmulq_f32(v44, vaddq_f32(vaddq_f32(v49, vmulq_f32(v44, v50)), vmulq_f32(vmulq_f32(v44, v44), v48))));
      v52 = *((float32x4_t *)a2 + 86);
      v53 = vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(vaddq_f32(v49, vmulq_f32(v43, v50)), vmulq_f32(vmulq_f32(v43, v43), v47)))));
      v54 = vmulq_f32(v52, v51);
      v55 = *((float32x4_t *)a2 + 29);
      v56 = *((float32x4_t *)a2 + 30);
      v57 = vmaxq_f32(v53, v55);
      v58 = vmaxq_f32(v54, v55);
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 31);
      v65 = *((float32x4_t *)a2 + 32);
      v66 = vsubq_f32(v58, v62);
      v67 = vmulq_f32(v66, vaddq_f32(v65, vmulq_f32(v66, vaddq_f32(v56, vmulq_f32(v64, v66)))));
      v68 = vaddq_f32(v22, vmulq_f32(v63, vaddq_f32(v65, vmulq_f32(v63, vaddq_f32(v56, vmulq_f32(v64, v63))))));
      v69 = vcvtq_s32_f32(v62);
      v70 = *((int32x4_t *)a2 + 33);
      v71 = vmulq_f32(v68, (float32x4_t)vshlq_n_s32(vaddq_s32(v70, vcvtq_s32_f32(v61)), 0x17uLL));
      v72 = vmulq_f32(vaddq_f32(v22, v67), (float32x4_t)vshlq_n_s32(vaddq_s32(v70, v69), 0x17uLL));
      v73 = *((float32x4_t *)a2 + 96);
      v74 = *((float32x4_t *)a2 + 97);
      v75 = *((float32x4_t *)a2 + 98);
      v76 = (int8x16_t *)(v6 + v11);
      v76[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v75)), (int8x16_t)vmulq_f32(v23, v74), (int8x16_t)vmulq_f32(v73, v71)), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v22)));
      *v76 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v75)), (int8x16_t)vmulq_f32(v24, v74), (int8x16_t)vmulq_f32(v73, v72)), (float32x4_t)vbslq_s8(v20, (int8x16_t)v14, (int8x16_t)v22)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v77 = -v10;
    if (v77 >= v5)
      goto LABEL_3;
LABEL_10:
    v78 = 16 * v77;
    v79 = *(float32x4_t *)(v7 + v78);
    v80 = *((float32x4_t *)a2 + 82);
    v81 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v79, (int8x16_t)vmaxq_f32(v79, v80));
    v82 = *((float32x4_t *)a2 + 75);
    v83 = (int8x16_t)vcgtq_f32(v82, v81);
    v84 = *((float32x4_t *)a2 + 5);
    v85 = vmulq_f32(v81, (float32x4_t)vbslq_s8(v83, *((int8x16_t *)a2 + 83), (int8x16_t)v84));
    v86 = vaddq_f32(vminq_f32(v85, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 95));
    v87 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v86), (int8x16_t)v84);
    v88 = (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v87, *((float32x4_t *)a2 + 23)));
    v89 = vsubq_f32(vsubq_f32(v87, v84), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v88), v87));
    v90 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 86), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v86, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v86))), *((float32x4_t *)a2 + 22)), v88), vmulq_f32(v89, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v89, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v89, v89), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v89))))))),
            *((float32x4_t *)a2 + 29));
    v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
    v92 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v91, v90)));
    v93 = vsubq_f32(v90, v92);
    *(int8x16_t *)(v6 + v78) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v79, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, vsubq_f32(v85, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v85, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v84, vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v93,
                                                                                    vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v93)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v92)), 0x17uLL)))), (float32x4_t)vbslq_s8(v83, (int8x16_t)v80, (int8x16_t)v84)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_rec601_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t *v91;
  int v92;
  uint64_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v92 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v14));
      v18 = *((float32x4_t *)a2 + 75);
      v19 = (int8x16_t)vcgtq_f32(v18, v16);
      v20 = *((int8x16_t *)a2 + 83);
      v21 = *((float32x4_t *)a2 + 5);
      v22 = (int8x16_t)vcgtq_f32(v18, v17);
      v23 = vmulq_f32(v16, (float32x4_t)vbslq_s8(v19, v20, (int8x16_t)v21));
      v24 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v22, v20, (int8x16_t)v21));
      v25 = *((float32x4_t *)a2 + 90);
      v26 = vminq_f32(v24, v25);
      v27 = *((float32x4_t *)a2 + 95);
      v28 = (int8x16_t)vaddq_f32(vminq_f32(v23, v25), v27);
      v29 = *((float32x4_t *)a2 + 86);
      v30 = (int8x16_t)vaddq_f32(v26, v27);
      v31 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v29, v18)), v18);
      v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v21, v28);
      v33 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v21, v30);
      v34 = *((int8x16_t *)a2 + 19);
      v35 = *((float32x4_t *)a2 + 20);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v32), (int8x16_t)v21);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v33), (int8x16_t)v21);
      v38 = *((int8x16_t *)a2 + 21);
      v39 = *((float32x4_t *)a2 + 22);
      v40 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v32)));
      v41 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v33)));
      v42 = *((float32x4_t *)a2 + 23);
      v43 = *((float32x4_t *)a2 + 24);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v36, v42));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v37, v42));
      v46 = vaddq_f32(vsubq_f32(v40, v39), v44);
      v47 = vmulq_f32(v43, v44);
      v48 = vmulq_f32(vmulq_f32(v43, v45), v37);
      v49 = vaddq_f32(vsubq_f32(v41, v39), v45);
      v50 = vsubq_f32(vsubq_f32(v36, v21), vmulq_f32(v47, v36));
      v51 = vsubq_f32(vsubq_f32(v37, v21), v48);
      v52 = vmulq_f32(v50, v50);
      v53 = vmulq_f32(v51, v51);
      v54 = *((float32x4_t *)a2 + 37);
      v55 = *((float32x4_t *)a2 + 38);
      v56 = *((float32x4_t *)a2 + 39);
      v57 = *((float32x4_t *)a2 + 40);
      v58 = vaddq_f32(v54, vmulq_f32(v55, v50));
      v59 = vaddq_f32(v56, vmulq_f32(v57, v50));
      v60 = vaddq_f32(v56, vmulq_f32(v57, v51));
      v61 = vaddq_f32(v54, vmulq_f32(v55, v51));
      v62 = *((float32x4_t *)a2 + 41);
      v63 = *((float32x4_t *)a2 + 42);
      v64 = vaddq_f32(vaddq_f32(v62, vmulq_f32(v63, v51)), vmulq_f32(v53, vaddq_f32(v61, vmulq_f32(v53, v60))));
      v65 = vmulq_f32(v50, vaddq_f32(vaddq_f32(v62, vmulq_f32(v63, v50)), vmulq_f32(v52, vaddq_f32(v58, vmulq_f32(v52, v59)))));
      v66 = *((float32x4_t *)a2 + 43);
      v67 = *((float32x4_t *)a2 + 44);
      v68 = vmulq_f32(v29, vaddq_f32(v46, vmulq_f32(v50, vaddq_f32(v66, v65))));
      v69 = vmulq_f32(v29, vaddq_f32(v49, vmulq_f32(v51, vaddq_f32(v66, vmulq_f32(v51, v64)))));
      v70 = *((float32x4_t *)a2 + 29);
      v71 = vmaxq_f32(v68, v70);
      v72 = vmaxq_f32(v69, v70);
      v73 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
      v74 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
      v75 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v73, v71)));
      v76 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v74, v72)));
      v77 = vsubq_f32(v71, v75);
      v78 = vsubq_f32(v72, v76);
      v79 = *((float32x4_t *)a2 + 45);
      v80 = *((float32x4_t *)a2 + 46);
      v81 = vaddq_f32(v67, vmulq_f32(v79, v77));
      v82 = vaddq_f32(v67, vmulq_f32(v79, v78));
      v83 = *((float32x4_t *)a2 + 47);
      v84 = *((float32x4_t *)a2 + 48);
      v85 = *((int32x4_t *)a2 + 33);
      v86 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v77, vaddq_f32(v84, vmulq_f32(v77, vaddq_f32(vaddq_f32(v80, vmulq_f32(v77, v83)), vmulq_f32(vmulq_f32(v77, v77), v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v75)), 0x17uLL));
      v87 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v78, vaddq_f32(v84, vmulq_f32(v78, vaddq_f32(vaddq_f32(v80, vmulq_f32(v83, v78)), vmulq_f32(vmulq_f32(v78, v78), v82)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v76)), 0x17uLL));
      v88 = *((float32x4_t *)a2 + 96);
      v89 = *((float32x4_t *)a2 + 97);
      v90 = *((float32x4_t *)a2 + 98);
      v91 = (int8x16_t *)(v6 + v11);
      v91[-1] = vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v23, v90)), (int8x16_t)vmulq_f32(v23, v89), (int8x16_t)vmulq_f32(v88, v86)), (float32x4_t)vbslq_s8(v19, (int8x16_t)v14, (int8x16_t)v21)));
      *v91 = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, vsubq_f32(v24, v90)), (int8x16_t)vmulq_f32(v24, v89), (int8x16_t)vmulq_f32(v88, v87)), (float32x4_t)vbslq_s8(v22, (int8x16_t)v14, (int8x16_t)v21)));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v92 = -v10;
    if (v92 >= v5)
      goto LABEL_3;
LABEL_10:
    v93 = 16 * v92;
    v94 = *(float32x4_t *)(v7 + v93);
    v95 = *((float32x4_t *)a2 + 82);
    v96 = (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v94, (int8x16_t)vmaxq_f32(v94, v95));
    v97 = *((float32x4_t *)a2 + 75);
    v98 = (int8x16_t)vcgtq_f32(v97, v96);
    v99 = *((float32x4_t *)a2 + 5);
    v100 = vmulq_f32(v96, (float32x4_t)vbslq_s8(v98, *((int8x16_t *)a2 + 83), (int8x16_t)v99));
    v101 = *((float32x4_t *)a2 + 86);
    v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vceqq_f32(v101, v97)), v97), (int8x16_t)v99, (int8x16_t)vaddq_f32(vminq_f32(v100, *((float32x4_t *)a2 + 90)), *((float32x4_t *)a2 + 95)));
    v103 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v102), (int8x16_t)v99);
    v104 = (float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vcgtq_f32(v103, *((float32x4_t *)a2 + 23)));
    v105 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v102, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v102))), *((float32x4_t *)a2 + 22)), v104);
    v106 = vsubq_f32(vsubq_f32(v103, v99), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v104), v103));
    v107 = vmulq_f32(v106, v106);
    v108 = vmaxq_f32(vmulq_f32(v101, vaddq_f32(v105, vmulq_f32(v106, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v106, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v106)), vmulq_f32(v107, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v106)), vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v106))))))))))),
             *((float32x4_t *)a2 + 29));
    v109 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
    v110 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vcgtq_f32(v109, v108)));
    v111 = vsubq_f32(v108, v110);
    *(int8x16_t *)(v6 + v93) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v94, (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v97, vsubq_f32(v100, *((float32x4_t *)a2 + 98))), (int8x16_t)vmulq_f32(v100, *((float32x4_t *)a2 + 97)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 96), vmulq_f32(vaddq_f32(v99, vmulq_f32(v111, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v111,
                                                                                    vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v111)), vmulq_f32(vmulq_f32(v111, v111), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v111)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v110)), 0x17uLL)))), (float32x4_t)vbslq_s8(v98, (int8x16_t)v95, (int8x16_t)v99)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t *v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v46 = 0;
        v47 = 16 * v8;
        v48 = 16 * v7;
        v49 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v50 = 0;
          do
          {
            v51 = v5[v50 / 0x10];
            v52 = vminq_f32(vmaxq_f32(v51, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v53 = vmulq_f32(v52, *((float32x4_t *)a2 + 99));
            v54 = vaddq_f32(v53, vmulq_f32(v52, vsubq_f32(v52, v53)));
            v6[v50 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v51, (int8x16_t)vmulq_f32(vminq_f32(vrsqrteq_f32(v54), *((float32x4_t *)a2 + 73)), v54));
            v50 += 16;
          }
          while (v49 != v50);
          ++v46;
          v5 = (float32x4_t *)((char *)v5 + v47);
          v6 = (int8x16_t *)((char *)v6 + v48);
        }
        while (v46 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v5[v17 - 2];
          v20 = v5[v17 - 1];
          v21 = v5[v17];
          v22 = v5[v17 + 1];
          v23 = *((float32x4_t *)a2 + 75);
          v24 = *((float32x4_t *)a2 + 5);
          v25 = vminq_f32(vmaxq_f32(v19, v23), v24);
          v26 = vminq_f32(vmaxq_f32(v20, v23), v24);
          v27 = vminq_f32(vmaxq_f32(v21, v23), v24);
          v28 = vminq_f32(vmaxq_f32(v22, v23), v24);
          v29 = *((float32x4_t *)a2 + 99);
          v30 = vmulq_f32(v25, v29);
          v31 = vmulq_f32(v26, v29);
          v32 = vmulq_f32(v27, v29);
          v33 = vmulq_f32(v28, v29);
          v34 = v15;
          v35 = vaddq_f32(v30, vmulq_f32(v25, vsubq_f32(v25, v30)));
          v36 = vaddq_f32(v31, vmulq_f32(v26, vsubq_f32(v26, v31)));
          v37 = vaddq_f32(v32, vmulq_f32(v27, vsubq_f32(v27, v32)));
          v38 = vaddq_f32(v33, vmulq_f32(v28, vsubq_f32(v28, v33)));
          v39 = *((float32x4_t *)a2 + 73);
          v40 = *((int8x16_t *)a2 + 15);
          v41 = &v6[v17];
          v14 += 4;
          v41[-2] = vbslq_s8(v40, (int8x16_t)v19, (int8x16_t)vmulq_f32(v35, vminq_f32(vrsqrteq_f32(v35), v39)));
          v41[-1] = vbslq_s8(v40, (int8x16_t)v20, (int8x16_t)vmulq_f32(v36, vminq_f32(vrsqrteq_f32(v36), v39)));
          *v41 = vbslq_s8(v40, (int8x16_t)v21, (int8x16_t)vmulq_f32(v37, vminq_f32(vrsqrteq_f32(v37), v39)));
          v41[1] = vbslq_s8(v40, (int8x16_t)v22, (int8x16_t)vmulq_f32(v38, vminq_f32(vrsqrteq_f32(v38), v39)));
          v17 += 4;
          v16 += 4;
          v15 = v34 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v42 = *v18++;
            v43 = vminq_f32(vmaxq_f32(v42, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v44 = vmulq_f32(v43, *((float32x4_t *)a2 + 99));
            v45 = vaddq_f32(v44, vmulq_f32(v43, vsubq_f32(v43, v44)));
            *v34++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v42, (int8x16_t)vmulq_f32(vminq_f32(vrsqrteq_f32(v45), *((float32x4_t *)a2 + 73)), v45));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getsrgb_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  uint64_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v76) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v21 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v18));
      v22 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v19));
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)v20));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v24), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v22, v25), v27));
      v31 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v23, v26)));
      v32 = vaddq_f32(v28, v24);
      v33 = vaddq_f32(v28, v25);
      v34 = vaddq_f32(v28, v26);
      v35 = *((float32x4_t *)a2 + 9);
      v36 = *((float32x4_t *)a2 + 10);
      v37 = vsubq_f32(v32, vmulq_f32(v29, v35));
      v38 = *((float32x4_t *)a2 + 100);
      v39 = vmulq_f32(v38, v37);
      v40 = vmulq_f32(v38, vsubq_f32(v33, vmulq_f32(v30, v35)));
      v41 = vmulq_f32(v38, vsubq_f32(v34, vmulq_f32(v31, v35)));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v42, v39)));
      v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v43, v40)));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = *((float32x4_t *)a2 + 11);
      v49 = *((float32x4_t *)a2 + 12);
      v50 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v39, v45))), v49);
      v51 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v40, v46))), v49);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v48, vsubq_f32(v41, v47))), v49);
      v53 = vaddq_f32(vaddq_f32(v36, v47), vmulq_f32(v52, v52));
      v54 = vmaxq_f32(vaddq_f32(vaddq_f32(v36, v45), vmulq_f32(v50, v50)), v14);
      v55 = vmaxq_f32(vaddq_f32(vaddq_f32(v36, v46), vmulq_f32(v51, v51)), v14);
      v56 = *((float32x4_t *)a2 + 13);
      v57 = *((float32x4_t *)a2 + 14);
      v58 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v54, v56), v57));
      v59 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v55, v56), v57));
      v60 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v53, v14), v56), v57));
      v61 = *((float32x4_t *)a2 + 101);
      v62 = *((float32x4_t *)a2 + 102);
      v63 = (int8x16_t)vaddq_f32(v61, vmulq_f32(v62, v58));
      v64 = (int8x16_t)vaddq_f32(v61, vmulq_f32(v62, v59));
      v65 = vmulq_f32(v62, v60);
      v66 = *((float32x4_t *)a2 + 103);
      v67 = (int8x16_t)vmulq_f32(v18, v66);
      v68 = (int8x16_t)vaddq_f32(v61, v65);
      v69 = (int8x16_t)vmulq_f32(v19, v66);
      v70 = *((float32x4_t *)a2 + 104);
      v71 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v70));
      v72 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v70));
      v73 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v20, v70)), (int8x16_t)vmulq_f32(v20, v66), v68);
      v74 = *((int8x16_t *)a2 + 15);
      v75 = (int8x16_t *)(v6 + v10);
      *v75 = vbslq_s8(v74, (int8x16_t)v12, vbslq_s8(v71, v67, v63));
      v75[1] = vbslq_s8(v74, (int8x16_t)v13, vbslq_s8(v72, v69, v64));
      v75[2] = vbslq_s8(v74, (int8x16_t)v15, v73);
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v76) = -v11;
    if ((int)v76 >= v5)
      goto LABEL_3;
LABEL_10:
    v76 = v76;
    do
    {
      v77 = *(float32x4_t *)(v7 + 16 * v76);
      v78 = *((float32x4_t *)a2 + 75);
      v79 = *((float32x4_t *)a2 + 5);
      v80 = vminq_f32(vmaxq_f32(v77, v78), v79);
      v81 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)v80));
      v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
      v83 = vmulq_f32(*((float32x4_t *)a2 + 100), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v82), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v81, v82))), *((float32x4_t *)a2 + 9))));
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v85 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v84, v83)));
      v86 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v83, v85))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v76++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v77, vbslq_s8((int8x16_t)vcgtq_f32(v78, vsubq_f32(v80, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v80, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v85), vmulq_f32(v86, v86)), v78),
                                                                              *((float32x4_t *)a2 + 13)),
                                                                            *((float32x4_t *)a2 + 14)))))));
    }
    while (v76 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  int8x16_t v85;
  float32x4_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t *v90;
  int v91;
  uint64_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v91 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = *((float32x4_t *)a2 + 100);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v19 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v17, v14)), v14);
      v20 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, (int8x16_t)v16);
      v21 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, (int8x16_t)v18);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v26 = *((int8x16_t *)a2 + 21);
      v27 = *((float32x4_t *)a2 + 22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v20)));
      v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v23, v21)));
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v25, v30));
      v34 = vaddq_f32(vsubq_f32(v28, v27), v32);
      v35 = vmulq_f32(v31, v32);
      v36 = vmulq_f32(vmulq_f32(v31, v33), v25);
      v37 = vaddq_f32(vsubq_f32(v29, v27), v33);
      v38 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(v35, v24));
      v39 = vsubq_f32(vsubq_f32(v25, v15), v36);
      v40 = vmulq_f32(v38, v38);
      v41 = vmulq_f32(v39, v39);
      v42 = *((float32x4_t *)a2 + 37);
      v43 = *((float32x4_t *)a2 + 38);
      v44 = *((float32x4_t *)a2 + 39);
      v45 = *((float32x4_t *)a2 + 40);
      v46 = vaddq_f32(v42, vmulq_f32(v43, v38));
      v47 = vaddq_f32(v44, vmulq_f32(v45, v38));
      v48 = vaddq_f32(v44, vmulq_f32(v45, v39));
      v49 = vaddq_f32(v42, vmulq_f32(v43, v39));
      v50 = *((float32x4_t *)a2 + 41);
      v51 = *((float32x4_t *)a2 + 42);
      v52 = vaddq_f32(vaddq_f32(v50, vmulq_f32(v51, v39)), vmulq_f32(v41, vaddq_f32(v49, vmulq_f32(v41, v48))));
      v53 = vmulq_f32(v38, vaddq_f32(vaddq_f32(v50, vmulq_f32(v51, v38)), vmulq_f32(v40, vaddq_f32(v46, vmulq_f32(v40, v47)))));
      v54 = *((float32x4_t *)a2 + 43);
      v55 = *((float32x4_t *)a2 + 44);
      v56 = vmulq_f32(v17, vaddq_f32(v34, vmulq_f32(v38, vaddq_f32(v54, v53))));
      v57 = vmulq_f32(v17, vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v54, vmulq_f32(v39, v52)))));
      v58 = *((float32x4_t *)a2 + 29);
      v59 = vmaxq_f32(v56, v58);
      v60 = vmaxq_f32(v57, v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 45);
      v68 = *((float32x4_t *)a2 + 46);
      v69 = vaddq_f32(v55, vmulq_f32(v67, v65));
      v70 = vaddq_f32(v55, vmulq_f32(v67, v66));
      v71 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v73 = vaddq_f32(v15, vmulq_f32(v65, vaddq_f32(v72, vmulq_f32(v65, vaddq_f32(vaddq_f32(v68, vmulq_f32(v65, v71)), vmulq_f32(vmulq_f32(v65, v65), v69))))));
      v74 = *((int32x4_t *)a2 + 33);
      v75 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v72, vmulq_f32(v66, vaddq_f32(vaddq_f32(v68, vmulq_f32(v71, v66)), vmulq_f32(vmulq_f32(v66, v66), v70))))));
      v76 = (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v63)), 0x17uLL);
      v77 = (float32x4_t)vshlq_n_s32(vaddq_s32(v74, vcvtq_s32_f32(v64)), 0x17uLL);
      v78 = vmulq_f32(v73, v76);
      v79 = *((float32x4_t *)a2 + 101);
      v80 = *((float32x4_t *)a2 + 102);
      v81 = (int8x16_t)vaddq_f32(v79, vmulq_f32(v80, v78));
      v82 = vmulq_f32(v80, vmulq_f32(v75, v77));
      v83 = *((float32x4_t *)a2 + 103);
      v84 = (int8x16_t)vmulq_f32(v16, v83);
      v85 = (int8x16_t)vaddq_f32(v79, v82);
      v86 = *((float32x4_t *)a2 + 104);
      v87 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v86));
      v88 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v86)), (int8x16_t)vmulq_f32(v18, v83), v85);
      v89 = *((int8x16_t *)a2 + 15);
      v90 = (int8x16_t *)(v6 + v11);
      v90[-1] = vbslq_s8(v89, (int8x16_t)v13, vbslq_s8(v87, v84, v81));
      *v90 = vbslq_s8(v89, (int8x16_t)v12, v88);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v91 = -v10;
    if (v91 >= v5)
      goto LABEL_3;
LABEL_10:
    v92 = 16 * v91;
    v93 = *(float32x4_t *)(v7 + v92);
    v94 = *((float32x4_t *)a2 + 75);
    v95 = *((float32x4_t *)a2 + 5);
    v96 = vminq_f32(vmaxq_f32(v93, v94), v95);
    v97 = *((float32x4_t *)a2 + 100);
    v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vceqq_f32(v97, v94)), v94), (int8x16_t)v95, (int8x16_t)v96);
    v99 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v98), (int8x16_t)v95);
    v100 = (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v99, *((float32x4_t *)a2 + 23)));
    v101 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v98))), *((float32x4_t *)a2 + 22)), v100);
    v102 = vsubq_f32(vsubq_f32(v99, v95), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v100), v99));
    v103 = vmulq_f32(v102, v102);
    v104 = vmaxq_f32(vmulq_f32(v97, vaddq_f32(v101, vmulq_f32(v102, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v102, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v102)), vmulq_f32(v103, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v102)), vmulq_f32(v103, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v102))))))))))),
             *((float32x4_t *)a2 + 29));
    v105 = vcvtq_f32_s32(vcvtq_s32_f32(v104));
    v106 = vsubq_f32(v105, (float32x4_t)vandq_s8((int8x16_t)v95, (int8x16_t)vcgtq_f32(v105, v104)));
    v107 = vsubq_f32(v104, v106);
    *(int8x16_t *)(v6 + v92) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v93, vbslq_s8((int8x16_t)vcgtq_f32(v94, vsubq_f32(v96, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v96, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v95, vmulq_f32(v107, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v107, vaddq_f32(
                                                              vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v107)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v106)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  int v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v76 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((int8x16_t *)a2 + 19);
      v19 = *((float32x4_t *)a2 + 20);
      v20 = (float32x4_t)vorrq_s8(vandq_s8(v18, (int8x16_t)v16), (int8x16_t)v15);
      v21 = (float32x4_t)vorrq_s8(vandq_s8(v18, (int8x16_t)v17), (int8x16_t)v15);
      v22 = (int8x16_t)vcgtq_f32(v19, v16);
      v23 = *((int8x16_t *)a2 + 21);
      v24 = *((float32x4_t *)a2 + 22);
      v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v19, v17)));
      v26 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v23, v22)), v24);
      v27 = *((float32x4_t *)a2 + 23);
      v28 = *((float32x4_t *)a2 + 24);
      v29 = vsubq_f32(v25, v24);
      v30 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v27));
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v21, v27));
      v32 = vsubq_f32(vsubq_f32(v20, v15), vmulq_f32(vmulq_f32(v28, v30), v20));
      v33 = vsubq_f32(vsubq_f32(v21, v15), vmulq_f32(vmulq_f32(v28, v31), v21));
      v34 = *((float32x4_t *)a2 + 25);
      v35 = *((float32x4_t *)a2 + 26);
      v36 = vaddq_f32(v34, vmulq_f32(v35, v32));
      v37 = vaddq_f32(v34, vmulq_f32(v35, v33));
      v38 = *((float32x4_t *)a2 + 27);
      v39 = *((float32x4_t *)a2 + 28);
      v40 = vaddq_f32(vaddq_f32(v29, v31), vmulq_f32(v33, vaddq_f32(vaddq_f32(v38, vmulq_f32(v33, v39)), vmulq_f32(vmulq_f32(v33, v33), v37))));
      v41 = *((float32x4_t *)a2 + 100);
      v42 = vmulq_f32(v41, vaddq_f32(vaddq_f32(v26, v30), vmulq_f32(v32, vaddq_f32(vaddq_f32(v38, vmulq_f32(v32, v39)), vmulq_f32(vmulq_f32(v32, v32), v36)))));
      v43 = vmulq_f32(v41, v40);
      v44 = *((float32x4_t *)a2 + 29);
      v45 = *((float32x4_t *)a2 + 30);
      v46 = vmaxq_f32(v42, v44);
      v47 = vmaxq_f32(v43, v44);
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v46, v50);
      v53 = *((float32x4_t *)a2 + 31);
      v54 = *((float32x4_t *)a2 + 32);
      v55 = vsubq_f32(v47, v51);
      v56 = vmulq_f32(v55, vaddq_f32(v54, vmulq_f32(v55, vaddq_f32(v45, vmulq_f32(v53, v55)))));
      v57 = vaddq_f32(v15, vmulq_f32(v52, vaddq_f32(v54, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v53, v52))))));
      v58 = vcvtq_s32_f32(v51);
      v59 = *((int32x4_t *)a2 + 33);
      v60 = vaddq_f32(v15, v56);
      v61 = (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL);
      v62 = (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL);
      v63 = vmulq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 101);
      v65 = *((float32x4_t *)a2 + 102);
      v66 = (int8x16_t)vaddq_f32(v64, vmulq_f32(v65, v63));
      v67 = vmulq_f32(v65, vmulq_f32(v60, v62));
      v68 = *((float32x4_t *)a2 + 103);
      v69 = (int8x16_t)vmulq_f32(v16, v68);
      v70 = (int8x16_t)vaddq_f32(v64, v67);
      v71 = *((float32x4_t *)a2 + 104);
      v72 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v71));
      v73 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v71)), (int8x16_t)vmulq_f32(v17, v68), v70);
      v74 = *((int8x16_t *)a2 + 15);
      v75 = (int8x16_t *)(v6 + v11);
      v75[-1] = vbslq_s8(v74, (int8x16_t)v13, vbslq_s8(v72, v69, v66));
      *v75 = vbslq_s8(v74, (int8x16_t)v12, v73);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v76 = -v10;
    if (v76 >= v5)
      goto LABEL_3;
LABEL_10:
    v77 = 16 * v76;
    v78 = *(float32x4_t *)(v7 + v77);
    v79 = *((float32x4_t *)a2 + 75);
    v80 = *((float32x4_t *)a2 + 5);
    v81 = vminq_f32(vmaxq_f32(v78, v79), v80);
    v82 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v81), (int8x16_t)v80);
    v83 = (float32x4_t)vandq_s8((int8x16_t)v80, (int8x16_t)vcgtq_f32(v82, *((float32x4_t *)a2 + 23)));
    v84 = vsubq_f32(vsubq_f32(v82, v80), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v83), v82));
    v85 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 100), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v81, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v81))), *((float32x4_t *)a2 + 22)), v83), vmulq_f32(v84, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v84, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v84))))))),
            *((float32x4_t *)a2 + 29));
    v86 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
    v87 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v80, (int8x16_t)vcgtq_f32(v86, v85)));
    v88 = vsubq_f32(v85, v87);
    *(int8x16_t *)(v6 + v77) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v78, vbslq_s8((int8x16_t)vcgtq_f32(v79, vsubq_f32(v81, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v81, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v80, vmulq_f32(v88, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v88, vaddq_f32(
                                                              *((float32x4_t *)a2 + 30),
                                                              vmulq_f32(*((float32x4_t *)a2 + 31), v88)))))),
                                                    (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v87)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t *v81;
  int v82;
  uint64_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v82 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 105);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v18 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, v16);
      v19 = *((float32x4_t *)a2 + 75);
      v20 = *((float32x4_t *)a2 + 5);
      v22 = *((int32x4_t *)a2 + 33);
      v21 = *((int8x16_t *)a2 + 34);
      v23 = vmulq_f32(v17, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v19, v17), v21, (int8x16_t)v20));
      v24 = vmulq_f32(v18, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v19, v18), v21, (int8x16_t)v20));
      v25 = *((float32x4_t *)a2 + 106);
      v26 = vminq_f32(v23, v25);
      v27 = vminq_f32(v24, v25);
      v28 = *((int8x16_t *)a2 + 19);
      v29 = *((float32x4_t *)a2 + 20);
      v30 = (float32x4_t)vorrq_s8(vandq_s8(v28, (int8x16_t)v26), (int8x16_t)v20);
      v31 = *((int8x16_t *)a2 + 21);
      v32 = *((float32x4_t *)a2 + 22);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v28, (int8x16_t)v27), (int8x16_t)v20);
      v34 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v29, v27)));
      v35 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v29, v26))), v32);
      v36 = *((float32x4_t *)a2 + 23);
      v37 = *((float32x4_t *)a2 + 24);
      v38 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v30, v36));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v33, v36));
      v40 = vaddq_f32(v35, v38);
      v41 = vmulq_f32(v37, v38);
      v42 = vmulq_f32(vmulq_f32(v37, v39), v33);
      v43 = vaddq_f32(vsubq_f32(v34, v32), v39);
      v44 = vsubq_f32(vsubq_f32(v30, v20), vmulq_f32(v41, v30));
      v45 = vsubq_f32(vsubq_f32(v33, v20), v42);
      v46 = *((float32x4_t *)a2 + 25);
      v47 = *((float32x4_t *)a2 + 26);
      v48 = *((float32x4_t *)a2 + 27);
      v49 = *((float32x4_t *)a2 + 28);
      v50 = vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v48, vmulq_f32(v45, v49)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v46, vmulq_f32(v47, v45))))));
      v51 = *((float32x4_t *)a2 + 100);
      v52 = vmulq_f32(v51, vaddq_f32(v40, vmulq_f32(v44, vaddq_f32(vaddq_f32(v48, vmulq_f32(v44, v49)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v46, vmulq_f32(v47, v44)))))));
      v53 = vmulq_f32(v51, v50);
      v54 = *((float32x4_t *)a2 + 29);
      v55 = *((float32x4_t *)a2 + 30);
      v56 = vmaxq_f32(v52, v54);
      v57 = vmaxq_f32(v53, v54);
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v58, v56)));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v56, v60);
      v63 = vsubq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 31);
      v65 = *((float32x4_t *)a2 + 32);
      v66 = vaddq_f32(v20, vmulq_f32(v62, vaddq_f32(v65, vmulq_f32(v62, vaddq_f32(v55, vmulq_f32(v64, v62))))));
      v67 = vaddq_f32(v20, vmulq_f32(v63, vaddq_f32(v65, vmulq_f32(v63, vaddq_f32(v55, vmulq_f32(v64, v63))))));
      v68 = vmulq_f32(v66, (float32x4_t)vshlq_n_s32(vaddq_s32(v22, vcvtq_s32_f32(v60)), 0x17uLL));
      v69 = vmulq_f32(v67, (float32x4_t)vshlq_n_s32(vaddq_s32(v22, vcvtq_s32_f32(v61)), 0x17uLL));
      v70 = *((float32x4_t *)a2 + 101);
      v71 = *((float32x4_t *)a2 + 102);
      v72 = vmulq_f32(v71, v68);
      v73 = vmulq_f32(v71, v69);
      v74 = *((float32x4_t *)a2 + 103);
      v75 = (int8x16_t)vmulq_f32(v23, v74);
      v76 = (int8x16_t)vmulq_f32(v24, v74);
      v77 = *((float32x4_t *)a2 + 104);
      v78 = (int8x16_t)vcgtq_f32(v19, vsubq_f32(v23, v77));
      v79 = (int8x16_t)vcgtq_f32(v19, vsubq_f32(v24, v77));
      v80 = *((int8x16_t *)a2 + 36);
      v81 = (int8x16_t *)(v6 + v11);
      v81[-1] = vbslq_s8(v15, (int8x16_t)v13, veorq_s8(vandq_s8(v80, (int8x16_t)v17), vbslq_s8(v78, v75, (int8x16_t)vaddq_f32(v70, v72))));
      *v81 = vbslq_s8(v15, (int8x16_t)v12, veorq_s8(vandq_s8(v80, (int8x16_t)v18), vbslq_s8(v79, v76, (int8x16_t)vaddq_f32(v70, v73))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v82 = -v10;
    if (v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v83 = 16 * v82;
    v84 = *(float32x4_t *)(v7 + v83);
    v85 = *((int8x16_t *)a2 + 15);
    v86 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v84, (int8x16_t)vmaxq_f32(v84, *((float32x4_t *)a2 + 105)));
    v87 = *((float32x4_t *)a2 + 75);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vmulq_f32(v86, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v87, v86), *((int8x16_t *)a2 + 34), (int8x16_t)v88));
    v90 = vminq_f32(v89, *((float32x4_t *)a2 + 106));
    v91 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v90), (int8x16_t)v88);
    v92 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v91, *((float32x4_t *)a2 + 23)));
    v93 = vsubq_f32(vsubq_f32(v91, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v92), v91));
    v94 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 100), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v90))), *((float32x4_t *)a2 + 22)), v92), vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v93, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v93, v93), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v93))))))),
            *((float32x4_t *)a2 + 29));
    v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
    v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v95, v94)));
    v97 = vsubq_f32(v94, v96);
    *(int8x16_t *)(v6 + v83) = vbslq_s8(v85, (int8x16_t)v84, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v86), vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v88, vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(
                                                              v97,
                                                              vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v97)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v96)), 0x17uLL)))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getsrgb_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int8x16_t *v92;
  int v93;
  uint64_t v94;
  float32x4_t v95;
  int8x16_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v93 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 105);
      v15 = (int8x16_t)vmaxq_f32(v13, v14);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = *((int8x16_t *)a2 + 15);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v13, v15);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *((float32x4_t *)a2 + 75);
      v21 = *((float32x4_t *)a2 + 5);
      v23 = *((int32x4_t *)a2 + 33);
      v22 = *((int8x16_t *)a2 + 34);
      v24 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v19), v22, (int8x16_t)v21);
      v25 = vmulq_f32(v18, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v18), v22, (int8x16_t)v21));
      v26 = vmulq_f32(v19, v24);
      v27 = *((float32x4_t *)a2 + 106);
      v28 = *((float32x4_t *)a2 + 100);
      v29 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v28, v20)), v20);
      v30 = (float32x4_t)vbslq_s8(v29, (int8x16_t)v21, (int8x16_t)vminq_f32(v25, v27));
      v31 = (float32x4_t)vbslq_s8(v29, (int8x16_t)v21, (int8x16_t)vminq_f32(v26, v27));
      v32 = *((int8x16_t *)a2 + 19);
      v33 = *((float32x4_t *)a2 + 20);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v21);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v31), (int8x16_t)v21);
      v36 = *((int8x16_t *)a2 + 21);
      v37 = *((float32x4_t *)a2 + 22);
      v38 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v33, v31)));
      v39 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v33, v30))), v37);
      v40 = *((float32x4_t *)a2 + 23);
      v41 = *((float32x4_t *)a2 + 24);
      v42 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v34, v40));
      v43 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v35, v40));
      v44 = vaddq_f32(v39, v42);
      v45 = vaddq_f32(vsubq_f32(v38, v37), v43);
      v46 = vsubq_f32(vsubq_f32(v34, v21), vmulq_f32(vmulq_f32(v41, v42), v34));
      v47 = vsubq_f32(vsubq_f32(v35, v21), vmulq_f32(vmulq_f32(v41, v43), v35));
      v48 = *((float32x4_t *)a2 + 38);
      v49 = *((float32x4_t *)a2 + 39);
      v51 = *((int8x16_t *)a2 + 36);
      v50 = *((float32x4_t *)a2 + 37);
      v52 = vaddq_f32(v50, vmulq_f32(v48, v46));
      v53 = *((float32x4_t *)a2 + 40);
      v54 = *((float32x4_t *)a2 + 41);
      v55 = vaddq_f32(v49, vmulq_f32(v53, v46));
      v56 = vaddq_f32(v49, vmulq_f32(v53, v47));
      v57 = *((float32x4_t *)a2 + 42);
      v58 = *((float32x4_t *)a2 + 43);
      v59 = vaddq_f32(v50, vmulq_f32(v48, v47));
      v60 = vaddq_f32(v54, vmulq_f32(v57, v46));
      v61 = vaddq_f32(v54, vmulq_f32(v57, v47));
      v62 = vmulq_f32(v46, v46);
      v63 = vaddq_f32(v52, vmulq_f32(v62, v55));
      v64 = vmulq_f32(v47, v47);
      v65 = vaddq_f32(v45, vmulq_f32(v47, vaddq_f32(v58, vmulq_f32(v47, vaddq_f32(v61, vmulq_f32(v64, vaddq_f32(v59, vmulq_f32(v64, v56))))))));
      v66 = *((float32x4_t *)a2 + 29);
      v67 = vmaxq_f32(vmulq_f32(v28, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(v58, vmulq_f32(v46, vaddq_f32(v60, vmulq_f32(v62, v63))))))), v66);
      v68 = vmaxq_f32(vmulq_f32(v28, v65), v66);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v67, v71);
      v74 = vsubq_f32(v68, v72);
      v75 = *((float32x4_t *)a2 + 44);
      v76 = *((float32x4_t *)a2 + 45);
      v77 = vaddq_f32(v75, vmulq_f32(v76, v73));
      v78 = *((float32x4_t *)a2 + 46);
      v79 = *((float32x4_t *)a2 + 47);
      v80 = vaddq_f32(v75, vmulq_f32(v76, v74));
      v81 = *((float32x4_t *)a2 + 48);
      v82 = vaddq_f32(v21, vmulq_f32(v73, vaddq_f32(v81, vmulq_f32(v73, vaddq_f32(vaddq_f32(v78, vmulq_f32(v73, v79)), vmulq_f32(vmulq_f32(v73, v73), v77))))));
      v83 = vaddq_f32(v21, vmulq_f32(v74, vaddq_f32(v81, vmulq_f32(v74, vaddq_f32(vaddq_f32(v78, vmulq_f32(v79, v74)), vmulq_f32(vmulq_f32(v74, v74), v80))))));
      v84 = vmulq_f32(v82, (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v71)), 0x17uLL));
      v85 = vmulq_f32(v83, (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v72)), 0x17uLL));
      v86 = *((float32x4_t *)a2 + 101);
      v87 = *((float32x4_t *)a2 + 102);
      v88 = vmulq_f32(v87, v85);
      v89 = (int8x16_t)vaddq_f32(v86, vmulq_f32(v87, v84));
      v90 = *((float32x4_t *)a2 + 103);
      v91 = *((float32x4_t *)a2 + 104);
      v92 = (int8x16_t *)(v6 + v11);
      v92[-1] = vbslq_s8(v17, (int8x16_t)v13, veorq_s8(vandq_s8(v51, (int8x16_t)v18), vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v25, v91)), (int8x16_t)vmulq_f32(v25, v90), v89)));
      *v92 = vbslq_s8(v17, (int8x16_t)v12, veorq_s8(vandq_s8(v51, (int8x16_t)v19), vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v26, v91)), (int8x16_t)vmulq_f32(v26, v90), (int8x16_t)vaddq_f32(v86, v88))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v93 = -v10;
    if (v93 >= v5)
      goto LABEL_3;
LABEL_10:
    v94 = 16 * v93;
    v95 = *(float32x4_t *)(v7 + v94);
    v96 = *((int8x16_t *)a2 + 15);
    v97 = (float32x4_t)vbslq_s8(v96, (int8x16_t)v95, (int8x16_t)vmaxq_f32(v95, *((float32x4_t *)a2 + 105)));
    v98 = *((float32x4_t *)a2 + 75);
    v99 = *((float32x4_t *)a2 + 5);
    v100 = vmulq_f32(v97, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v98, v97), *((int8x16_t *)a2 + 34), (int8x16_t)v99));
    v101 = *((float32x4_t *)a2 + 100);
    v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vceqq_f32(v101, v98)), v98), (int8x16_t)v99, (int8x16_t)vminq_f32(v100, *((float32x4_t *)a2 + 106)));
    v103 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v102), (int8x16_t)v99);
    v104 = (float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vcgtq_f32(v103, *((float32x4_t *)a2 + 23)));
    v105 = vsubq_f32(vsubq_f32(v103, v99), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v104), v103));
    v106 = vmulq_f32(v105, v105);
    v107 = vmaxq_f32(vmulq_f32(v101, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v102, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v102))), *((float32x4_t *)a2 + 22)), v104), vmulq_f32(v105, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v105, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v105)),
                         vmulq_f32(v106, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v105)), vmulq_f32(v106, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v105))))))))))), *((float32x4_t *)a2 + 29));
    v108 = vcvtq_f32_s32(vcvtq_s32_f32(v107));
    v109 = vsubq_f32(v108, (float32x4_t)vandq_s8((int8x16_t)v99, (int8x16_t)vcgtq_f32(v108, v107)));
    v110 = vsubq_f32(v107, v109);
    *(int8x16_t *)(v6 + v94) = vbslq_s8(v96, (int8x16_t)v95, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v97), vbslq_s8((int8x16_t)vcgtq_f32(v98, vsubq_f32(v100, *((float32x4_t *)a2 + 104))), (int8x16_t)vmulq_f32(v100, *((float32x4_t *)a2 + 103)), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 101), vmulq_f32(*((float32x4_t *)a2 + 102), vmulq_f32(vaddq_f32(v99, vmulq_f32(v110, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(
                                                              v110,
                                                              vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v110)), vmulq_f32(vmulq_f32(v110, v110), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v110)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v109)), 0x17uLL)))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  int8x16_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v45 = 0;
        v46 = 16 * v8;
        v47 = 16 * v7;
        v48 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v49 = 0;
          do
          {
            v50 = v5[v49 / 0x10];
            v51 = vminq_f32(vmaxq_f32(v50, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v52 = vmulq_f32(v51, *((float32x4_t *)a2 + 107));
            v53 = vaddq_f32(v52, vmulq_f32(v51, vsubq_f32(v51, v52)));
            v6[v49 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v50, (int8x16_t)vmulq_f32(v53, v53));
            v49 += 16;
          }
          while (v48 != v49);
          ++v45;
          v5 = (float32x4_t *)((char *)v5 + v46);
          v6 = (int8x16_t *)((char *)v6 + v47);
        }
        while (v45 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((float32x4_t *)a2 + 107);
          v31 = vmulq_f32(v26, v30);
          v32 = vmulq_f32(v27, v30);
          v33 = vmulq_f32(v28, v30);
          v34 = vmulq_f32(v29, v30);
          v35 = vaddq_f32(v31, vmulq_f32(v26, vsubq_f32(v26, v31)));
          v36 = vaddq_f32(v32, vmulq_f32(v27, vsubq_f32(v27, v32)));
          v37 = vaddq_f32(v33, vmulq_f32(v28, vsubq_f32(v28, v33)));
          v38 = vaddq_f32(v34, vmulq_f32(v29, vsubq_f32(v29, v34)));
          v39 = *((int8x16_t *)a2 + 15);
          v40 = &v6[v17];
          v40[-2] = vbslq_s8(v39, (int8x16_t)v20, (int8x16_t)vmulq_f32(v35, v35));
          v40[-1] = vbslq_s8(v39, (int8x16_t)v21, (int8x16_t)vmulq_f32(v36, v36));
          v14 += 4;
          *v40 = vbslq_s8(v39, (int8x16_t)v22, (int8x16_t)vmulq_f32(v37, v37));
          v40[1] = vbslq_s8(v39, (int8x16_t)v23, (int8x16_t)vmulq_f32(v38, v38));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v41 = *v18++;
            v42 = vminq_f32(vmaxq_f32(v41, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v43 = vmulq_f32(v42, *((float32x4_t *)a2 + 107));
            v44 = vaddq_f32(v43, vmulq_f32(v42, vsubq_f32(v42, v43)));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v41, (int8x16_t)vmulq_f32(v44, v44));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_srgb_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t *v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 3)
    {
      LODWORD(v75) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v6 += v8;
      v7 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x4_t *)(v7 + v10);
      v13 = *(float32x4_t *)(v7 + v10 + 16);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *(float32x4_t *)(v7 + v10 + 32);
      v16 = *((float32x4_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vminq_f32(vmaxq_f32(v12, v14), v16);
      v19 = vminq_f32(vmaxq_f32(v13, v14), v16);
      v20 = vminq_f32(vmaxq_f32(v15, v14), v16);
      v21 = *((float32x4_t *)a2 + 108);
      v22 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v18, v21)));
      v23 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v19, v21)));
      v24 = vmulq_f32(v17, vcvtq_f32_s32((int32x4_t)vaddq_f32(v20, v21)));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      v27 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      v28 = *((float32x4_t *)a2 + 7);
      v29 = *((float32x4_t *)a2 + 8);
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v22, v25), v28));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v23, v26), v28));
      v32 = vaddq_f32(v29, v25);
      v33 = vrsqrteq_f32(vaddq_f32(v28, vsubq_f32(v24, v27)));
      v34 = vaddq_f32(v29, v26);
      v35 = vaddq_f32(v29, v27);
      v36 = *((float32x4_t *)a2 + 9);
      v37 = *((float32x4_t *)a2 + 10);
      v38 = vsubq_f32(v32, vmulq_f32(v30, v36));
      v39 = vsubq_f32(v34, vmulq_f32(v31, v36));
      v40 = *((float32x4_t *)a2 + 109);
      v41 = vmulq_f32(v40, v38);
      v42 = vmulq_f32(v40, v39);
      v43 = vmulq_f32(v40, vsubq_f32(v35, vmulq_f32(v33, v36)));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v44, v41)));
      v48 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v45, v42)));
      v49 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v46, v43)));
      v50 = *((float32x4_t *)a2 + 11);
      v51 = *((float32x4_t *)a2 + 12);
      v52 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v41, v47))), v51);
      v53 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v42, v48))), v51);
      v54 = vmulq_f32(vrecpeq_f32(vsubq_f32(v50, vsubq_f32(v43, v49))), v51);
      v55 = vaddq_f32(vaddq_f32(v37, v49), vmulq_f32(v54, v54));
      v56 = vmaxq_f32(vaddq_f32(vaddq_f32(v37, v47), vmulq_f32(v52, v52)), v14);
      v57 = vmaxq_f32(vaddq_f32(vaddq_f32(v37, v48), vmulq_f32(v53, v53)), v14);
      v58 = *((float32x4_t *)a2 + 13);
      v59 = *((float32x4_t *)a2 + 14);
      v60 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v56, v58), v59));
      v61 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(v57, v58), v59));
      v62 = (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(v55, v14), v58), v59));
      v63 = *((float32x4_t *)a2 + 110);
      v64 = *((float32x4_t *)a2 + 111);
      v65 = (int8x16_t)vmulq_f32(v18, v64);
      v66 = (int8x16_t)vmulq_f32(v19, v64);
      v67 = (int8x16_t)vmulq_f32(v20, v64);
      v68 = *((float32x4_t *)a2 + 112);
      v69 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v18, v68));
      v70 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v19, v68));
      v71 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v20, v68));
      v72 = vbslq_s8(v69, v65, (int8x16_t)vmulq_f32(v63, v60));
      v73 = *((int8x16_t *)a2 + 15);
      v74 = (int8x16_t *)(v6 + v10);
      *v74 = vbslq_s8(v73, (int8x16_t)v12, v72);
      v74[1] = vbslq_s8(v73, (int8x16_t)v13, vbslq_s8(v70, v66, (int8x16_t)vmulq_f32(v63, v61)));
      v74[2] = vbslq_s8(v73, (int8x16_t)v15, vbslq_s8(v71, v67, (int8x16_t)vmulq_f32(v63, v62)));
      v11 -= 3;
      v10 += 48;
    }
    while (v5 + v11 > 2);
    LODWORD(v75) = -v11;
    if ((int)v75 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = v75;
    do
    {
      v76 = *(float32x4_t *)(v7 + 16 * v75);
      v77 = *((float32x4_t *)a2 + 75);
      v78 = *((float32x4_t *)a2 + 5);
      v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
      v80 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vaddq_f32(v79, *((float32x4_t *)a2 + 108))));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v82 = vmulq_f32(*((float32x4_t *)a2 + 109), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v81), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v80, v81))), *((float32x4_t *)a2 + 9))));
      v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v83, v82)));
      v85 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v82, v84))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v75++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v79, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), (float32x4_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v84), vmulq_f32(v85, v85)), v77), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))))));
    }
    while (v75 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t *v83;
  int v84;
  uint64_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v84 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 108);
      v19 = (int8x16_t)vaddq_f32(v16, v18);
      v20 = (int8x16_t)vaddq_f32(v17, v18);
      v21 = *((float32x4_t *)a2 + 109);
      v22 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v21, v14)), v14);
      v23 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v19);
      v24 = (float32x4_t)vbslq_s8(v22, (int8x16_t)v15, v20);
      v25 = *((int8x16_t *)a2 + 19);
      v26 = *((float32x4_t *)a2 + 20);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v23), (int8x16_t)v15);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v24), (int8x16_t)v15);
      v29 = *((int8x16_t *)a2 + 21);
      v30 = *((float32x4_t *)a2 + 22);
      v31 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v24)));
      v32 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v23))), v30);
      v33 = *((float32x4_t *)a2 + 23);
      v34 = *((float32x4_t *)a2 + 24);
      v35 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v33));
      v36 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v28, v33));
      v37 = vaddq_f32(v32, v35);
      v38 = vaddq_f32(vsubq_f32(v31, v30), v36);
      v39 = vsubq_f32(vsubq_f32(v27, v15), vmulq_f32(vmulq_f32(v34, v35), v27));
      v40 = vsubq_f32(vsubq_f32(v28, v15), vmulq_f32(vmulq_f32(v34, v36), v28));
      v41 = vmulq_f32(v39, v39);
      v42 = vmulq_f32(v40, v40);
      v43 = *((float32x4_t *)a2 + 37);
      v44 = *((float32x4_t *)a2 + 38);
      v45 = vaddq_f32(v43, vmulq_f32(v44, v39));
      v46 = *((float32x4_t *)a2 + 39);
      v47 = *((float32x4_t *)a2 + 40);
      v48 = vaddq_f32(v43, vmulq_f32(v44, v40));
      v49 = vaddq_f32(v46, vmulq_f32(v47, v39));
      v50 = vaddq_f32(v46, vmulq_f32(v47, v40));
      v51 = *((float32x4_t *)a2 + 41);
      v52 = *((float32x4_t *)a2 + 42);
      v53 = vaddq_f32(vaddq_f32(v51, vmulq_f32(v52, v40)), vmulq_f32(v42, vaddq_f32(v48, vmulq_f32(v42, v50))));
      v54 = vmulq_f32(v39, vaddq_f32(vaddq_f32(v51, vmulq_f32(v52, v39)), vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, v49)))));
      v55 = *((float32x4_t *)a2 + 43);
      v56 = *((float32x4_t *)a2 + 44);
      v57 = vaddq_f32(v38, vmulq_f32(v40, vaddq_f32(v55, vmulq_f32(v40, v53))));
      v58 = *((float32x4_t *)a2 + 29);
      v59 = vmaxq_f32(vmulq_f32(v21, vaddq_f32(v37, vmulq_f32(v39, vaddq_f32(v55, v54)))), v58);
      v60 = vmaxq_f32(vmulq_f32(v21, v57), v58);
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v59, v63);
      v66 = vsubq_f32(v60, v64);
      v67 = *((float32x4_t *)a2 + 45);
      v68 = *((float32x4_t *)a2 + 46);
      v69 = *((float32x4_t *)a2 + 47);
      v70 = *((float32x4_t *)a2 + 48);
      v71 = vaddq_f32(v15, vmulq_f32(v65, vaddq_f32(v70, vmulq_f32(v65, vaddq_f32(vaddq_f32(v68, vmulq_f32(v65, v69)), vmulq_f32(vmulq_f32(v65, v65), vaddq_f32(v56, vmulq_f32(v67, v65))))))));
      v72 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v70, vmulq_f32(v66, vaddq_f32(vaddq_f32(v68, vmulq_f32(v69, v66)), vmulq_f32(vmulq_f32(v66, v66), vaddq_f32(v56, vmulq_f32(v67, v66))))))));
      v73 = *((int32x4_t *)a2 + 33);
      v74 = vmulq_f32(v71, (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v63)), 0x17uLL));
      v75 = vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(v73, vcvtq_s32_f32(v64)), 0x17uLL));
      v76 = *((float32x4_t *)a2 + 110);
      v77 = *((float32x4_t *)a2 + 111);
      v78 = (int8x16_t)vmulq_f32(v16, v77);
      v79 = *((float32x4_t *)a2 + 112);
      v80 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v79));
      v81 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v79)), (int8x16_t)vmulq_f32(v17, v77), (int8x16_t)vmulq_f32(v76, v75));
      v82 = *((int8x16_t *)a2 + 15);
      v83 = (int8x16_t *)(v6 + v11);
      v83[-1] = vbslq_s8(v82, (int8x16_t)v13, vbslq_s8(v80, v78, (int8x16_t)vmulq_f32(v76, v74)));
      *v83 = vbslq_s8(v82, (int8x16_t)v12, v81);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v84 = -v10;
    if (v84 >= v5)
      goto LABEL_3;
LABEL_10:
    v85 = 16 * v84;
    v86 = *(float32x4_t *)(v7 + v85);
    v87 = *((float32x4_t *)a2 + 75);
    v88 = *((float32x4_t *)a2 + 5);
    v89 = vminq_f32(vmaxq_f32(v86, v87), v88);
    v90 = *((float32x4_t *)a2 + 109);
    v91 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vceqq_f32(v90, v87)), v87), (int8x16_t)v88, (int8x16_t)vaddq_f32(v89, *((float32x4_t *)a2 + 108)));
    v92 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v91), (int8x16_t)v88);
    v93 = (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v92, *((float32x4_t *)a2 + 23)));
    v94 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v91, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v91))), *((float32x4_t *)a2 + 22)), v93);
    v95 = vsubq_f32(vsubq_f32(v92, v88), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v93), v92));
    v96 = vmulq_f32(v95, v95);
    v97 = vmaxq_f32(vmulq_f32(v90, vaddq_f32(v94, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v95)), vmulq_f32(v96, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v95)), vmulq_f32(v96, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v95))))))))))),
            *((float32x4_t *)a2 + 29));
    v98 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
    v99 = vsubq_f32(v98, (float32x4_t)vandq_s8((int8x16_t)v88, (int8x16_t)vcgtq_f32(v98, v97)));
    v100 = vsubq_f32(v97, v99);
    *(int8x16_t *)(v6 + v85) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32(v87, vsubq_f32(v89, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v89, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v88, vmulq_f32(v100, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v100, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46),
                                                              vmulq_f32(*((float32x4_t *)a2 + 47), v100)),
                                                            vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v100)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v99)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t *v73;
  int v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v74 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 108);
      v19 = vaddq_f32(v16, v18);
      v20 = vaddq_f32(v17, v18);
      v21 = *((int8x16_t *)a2 + 19);
      v22 = *((float32x4_t *)a2 + 20);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v19), (int8x16_t)v15);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v15);
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v20)));
      v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v19))), v25);
      v29 = *((float32x4_t *)a2 + 23);
      v30 = *((float32x4_t *)a2 + 24);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v29));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v26, v29));
      v33 = vaddq_f32(v28, v31);
      v34 = vmulq_f32(v30, v31);
      v35 = vmulq_f32(vmulq_f32(v30, v32), v26);
      v36 = vaddq_f32(vsubq_f32(v27, v25), v32);
      v37 = vsubq_f32(vsubq_f32(v23, v15), vmulq_f32(v34, v23));
      v38 = vsubq_f32(vsubq_f32(v26, v15), v35);
      v39 = *((float32x4_t *)a2 + 25);
      v40 = *((float32x4_t *)a2 + 26);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v44 = *((float32x4_t *)a2 + 27);
      v43 = *((float32x4_t *)a2 + 28);
      v45 = vaddq_f32(v36, vmulq_f32(v38, vaddq_f32(vaddq_f32(v44, vmulq_f32(v38, v43)), vmulq_f32(vmulq_f32(v38, v38), v42))));
      v46 = *((float32x4_t *)a2 + 109);
      v47 = vmulq_f32(v46, vaddq_f32(v33, vmulq_f32(v37, vaddq_f32(vaddq_f32(v44, vmulq_f32(v37, v43)), vmulq_f32(vmulq_f32(v37, v37), v41)))));
      v48 = vmulq_f32(v46, v45);
      v49 = *((float32x4_t *)a2 + 29);
      v50 = *((float32x4_t *)a2 + 30);
      v51 = vmaxq_f32(v47, v49);
      v52 = vmaxq_f32(v48, v49);
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v54, v52)));
      v57 = vsubq_f32(v51, v55);
      v58 = vsubq_f32(v52, v56);
      v59 = *((float32x4_t *)a2 + 31);
      v60 = *((float32x4_t *)a2 + 32);
      v61 = vaddq_f32(v15, vmulq_f32(v57, vaddq_f32(v60, vmulq_f32(v57, vaddq_f32(v50, vmulq_f32(v59, v57))))));
      v62 = vaddq_f32(v15, vmulq_f32(v58, vaddq_f32(v60, vmulq_f32(v58, vaddq_f32(v50, vmulq_f32(v59, v58))))));
      v63 = *((int32x4_t *)a2 + 33);
      v64 = vmulq_f32(v61, (float32x4_t)vshlq_n_s32(vaddq_s32(v63, vcvtq_s32_f32(v55)), 0x17uLL));
      v65 = vmulq_f32(v62, (float32x4_t)vshlq_n_s32(vaddq_s32(v63, vcvtq_s32_f32(v56)), 0x17uLL));
      v66 = *((float32x4_t *)a2 + 110);
      v67 = *((float32x4_t *)a2 + 111);
      v68 = (int8x16_t)vmulq_f32(v16, v67);
      v69 = *((float32x4_t *)a2 + 112);
      v70 = (int8x16_t)vcgtq_f32(v14, vsubq_f32(v16, v69));
      v71 = vbslq_s8((int8x16_t)vcgtq_f32(v14, vsubq_f32(v17, v69)), (int8x16_t)vmulq_f32(v17, v67), (int8x16_t)vmulq_f32(v66, v65));
      v72 = *((int8x16_t *)a2 + 15);
      v73 = (int8x16_t *)(v6 + v11);
      v73[-1] = vbslq_s8(v72, (int8x16_t)v13, vbslq_s8(v70, v68, (int8x16_t)vmulq_f32(v66, v64)));
      *v73 = vbslq_s8(v72, (int8x16_t)v12, v71);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v74 = -v10;
    if (v74 >= v5)
      goto LABEL_3;
LABEL_10:
    v75 = 16 * v74;
    v76 = *(float32x4_t *)(v7 + v75);
    v77 = *((float32x4_t *)a2 + 75);
    v78 = *((float32x4_t *)a2 + 5);
    v79 = vminq_f32(vmaxq_f32(v76, v77), v78);
    v80 = vaddq_f32(v79, *((float32x4_t *)a2 + 108));
    v81 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v80), (int8x16_t)v78);
    v82 = (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v81, *((float32x4_t *)a2 + 23)));
    v83 = vsubq_f32(vsubq_f32(v81, v78), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v82), v81));
    v84 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 109), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v80, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v80))), *((float32x4_t *)a2 + 22)), v82), vmulq_f32(v83, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v83, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v83, v83), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v83))))))),
            *((float32x4_t *)a2 + 29));
    v85 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
    v86 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v85, v84)));
    v87 = vsubq_f32(v84, v86);
    *(int8x16_t *)(v6 + v75) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32(v77, vsubq_f32(v79, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v79, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v78, vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v87)))))),
                                                  (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v86)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  int8x16_t v75;
  float32x4_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t *v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 113);
      v15 = *((int8x16_t *)a2 + 15);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v13, (int8x16_t)vmaxq_f32(v13, v14));
      v18 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, v16);
      v19 = *((float32x4_t *)a2 + 75);
      v20 = *((float32x4_t *)a2 + 5);
      v22 = *((int32x4_t *)a2 + 33);
      v21 = *((int8x16_t *)a2 + 34);
      v23 = vmulq_f32(v17, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v19, v17), v21, (int8x16_t)v20));
      v24 = vmulq_f32(v18, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v19, v18), v21, (int8x16_t)v20));
      v25 = *((float32x4_t *)a2 + 114);
      v26 = *((float32x4_t *)a2 + 108);
      v27 = vaddq_f32(vminq_f32(v23, v25), v26);
      v28 = vaddq_f32(vminq_f32(v24, v25), v26);
      v29 = *((int8x16_t *)a2 + 19);
      v30 = *((float32x4_t *)a2 + 20);
      v31 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v27), (int8x16_t)v20);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v28), (int8x16_t)v20);
      v33 = *((int8x16_t *)a2 + 21);
      v34 = *((float32x4_t *)a2 + 22);
      v35 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v30, v28)));
      v36 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v30, v27))), v34);
      v37 = *((float32x4_t *)a2 + 23);
      v38 = *((float32x4_t *)a2 + 24);
      v39 = vsubq_f32(v35, v34);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v31, v37));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v32, v37));
      v42 = vaddq_f32(v36, v40);
      v43 = vsubq_f32(vsubq_f32(v31, v20), vmulq_f32(vmulq_f32(v38, v40), v31));
      v44 = vsubq_f32(vsubq_f32(v32, v20), vmulq_f32(vmulq_f32(v38, v41), v32));
      v45 = *((float32x4_t *)a2 + 25);
      v46 = *((float32x4_t *)a2 + 26);
      v47 = vaddq_f32(v45, vmulq_f32(v46, v43));
      v48 = vaddq_f32(v45, vmulq_f32(v46, v44));
      v49 = *((float32x4_t *)a2 + 27);
      v50 = *((float32x4_t *)a2 + 28);
      v51 = vaddq_f32(vaddq_f32(v39, v41), vmulq_f32(v44, vaddq_f32(vaddq_f32(v49, vmulq_f32(v44, v50)), vmulq_f32(vmulq_f32(v44, v44), v48))));
      v52 = *((float32x4_t *)a2 + 109);
      v53 = vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(vaddq_f32(v49, vmulq_f32(v43, v50)), vmulq_f32(vmulq_f32(v43, v43), v47)))));
      v54 = vmulq_f32(v52, v51);
      v55 = *((float32x4_t *)a2 + 29);
      v56 = *((float32x4_t *)a2 + 30);
      v57 = vmaxq_f32(v53, v55);
      v58 = vmaxq_f32(v54, v55);
      v59 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v59, v57)));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v57, v61);
      v64 = *((float32x4_t *)a2 + 31);
      v65 = *((float32x4_t *)a2 + 32);
      v66 = vsubq_f32(v58, v62);
      v67 = vaddq_f32(v20, vmulq_f32(v63, vaddq_f32(v65, vmulq_f32(v63, vaddq_f32(v56, vmulq_f32(v64, v63))))));
      v68 = vaddq_f32(v20, vmulq_f32(v66, vaddq_f32(v65, vmulq_f32(v66, vaddq_f32(v56, vmulq_f32(v64, v66))))));
      v69 = (float32x4_t)vshlq_n_s32(vaddq_s32(v22, vcvtq_s32_f32(v62)), 0x17uLL);
      v70 = vmulq_f32(v67, (float32x4_t)vshlq_n_s32(vaddq_s32(v22, vcvtq_s32_f32(v61)), 0x17uLL));
      v71 = vmulq_f32(v68, v69);
      v72 = *((float32x4_t *)a2 + 110);
      v73 = *((float32x4_t *)a2 + 111);
      v74 = (int8x16_t)vmulq_f32(v23, v73);
      v75 = (int8x16_t)vmulq_f32(v24, v73);
      v76 = *((float32x4_t *)a2 + 112);
      v77 = (int8x16_t)vcgtq_f32(v19, vsubq_f32(v23, v76));
      v78 = (int8x16_t)vcgtq_f32(v19, vsubq_f32(v24, v76));
      v79 = *((int8x16_t *)a2 + 36);
      v80 = (int8x16_t *)(v6 + v11);
      v80[-1] = vbslq_s8(v15, (int8x16_t)v13, veorq_s8(vandq_s8(v79, (int8x16_t)v17), vbslq_s8(v77, v74, (int8x16_t)vmulq_f32(v72, v70))));
      *v80 = vbslq_s8(v15, (int8x16_t)v12, veorq_s8(vandq_s8(v79, (int8x16_t)v18), vbslq_s8(v78, v75, (int8x16_t)vmulq_f32(v72, v71))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((int8x16_t *)a2 + 15);
    v85 = (float32x4_t)vbslq_s8(v84, (int8x16_t)v83, (int8x16_t)vmaxq_f32(v83, *((float32x4_t *)a2 + 113)));
    v86 = *((float32x4_t *)a2 + 75);
    v87 = *((float32x4_t *)a2 + 5);
    v88 = vmulq_f32(v85, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v86, v85), *((int8x16_t *)a2 + 34), (int8x16_t)v87));
    v89 = vaddq_f32(vminq_f32(v88, *((float32x4_t *)a2 + 114)), *((float32x4_t *)a2 + 108));
    v90 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v89), (int8x16_t)v87);
    v91 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v90, *((float32x4_t *)a2 + 23)));
    v92 = vsubq_f32(vsubq_f32(v90, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v91), v90));
    v93 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 109), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v89, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v89))), *((float32x4_t *)a2 + 22)), v91), vmulq_f32(v92, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v92, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v92, v92), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v92))))))),
            *((float32x4_t *)a2 + 29));
    v94 = vcvtq_f32_s32(vcvtq_s32_f32(v93));
    v95 = vsubq_f32(v94, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v94, v93)));
    v96 = vsubq_f32(v93, v95);
    *(int8x16_t *)(v6 + v82) = vbslq_s8(v84, (int8x16_t)v83, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v85), vbslq_s8((int8x16_t)vcgtq_f32(v86, vsubq_f32(v88, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v88, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v87, vmulq_f32(v96, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v96, vaddq_f32(
                                                              *((float32x4_t *)a2 + 30),
                                                              vmulq_f32(*((float32x4_t *)a2 + 31), v96)))))),
                                                    (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v95)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_srgb_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t *v91;
  int v92;
  uint64_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v92 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 113);
      v15 = (int8x16_t)vmaxq_f32(v13, v14);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = *((int8x16_t *)a2 + 15);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v13, v15);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *((float32x4_t *)a2 + 75);
      v21 = *((float32x4_t *)a2 + 5);
      v23 = *((int32x4_t *)a2 + 33);
      v22 = *((int8x16_t *)a2 + 34);
      v24 = vmulq_f32(v18, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v18), v22, (int8x16_t)v21));
      v25 = vmulq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v19), v22, (int8x16_t)v21));
      v26 = *((float32x4_t *)a2 + 114);
      v27 = *((float32x4_t *)a2 + 108);
      v28 = (int8x16_t)vaddq_f32(vminq_f32(v24, v26), v27);
      v29 = *((float32x4_t *)a2 + 109);
      v30 = (int8x16_t)vaddq_f32(vminq_f32(v25, v26), v27);
      v31 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v29, v20)), v20);
      v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v21, v28);
      v33 = (float32x4_t)vbslq_s8(v31, (int8x16_t)v21, v30);
      v34 = *((int8x16_t *)a2 + 19);
      v35 = *((float32x4_t *)a2 + 20);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v32), (int8x16_t)v21);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)v33), (int8x16_t)v21);
      v38 = *((int8x16_t *)a2 + 21);
      v39 = *((float32x4_t *)a2 + 22);
      v40 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v32)));
      v41 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v38, (int8x16_t)vcgtq_f32(v35, v33)));
      v42 = *((float32x4_t *)a2 + 23);
      v43 = *((float32x4_t *)a2 + 24);
      v44 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v36, v42));
      v45 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v37, v42));
      v46 = vsubq_f32(v41, v39);
      v47 = vaddq_f32(vsubq_f32(v40, v39), v44);
      v48 = vsubq_f32(vsubq_f32(v36, v21), vmulq_f32(vmulq_f32(v43, v44), v36));
      v49 = vsubq_f32(vsubq_f32(v37, v21), vmulq_f32(vmulq_f32(v43, v45), v37));
      v50 = *((float32x4_t *)a2 + 38);
      v51 = *((float32x4_t *)a2 + 39);
      v52 = vmulq_f32(v48, v48);
      v54 = *((int8x16_t *)a2 + 36);
      v53 = *((float32x4_t *)a2 + 37);
      v55 = *((float32x4_t *)a2 + 40);
      v56 = *((float32x4_t *)a2 + 41);
      v57 = vaddq_f32(v53, vmulq_f32(v50, v48));
      v58 = vaddq_f32(v51, vmulq_f32(v55, v48));
      v59 = vaddq_f32(v51, vmulq_f32(v55, v49));
      v60 = vaddq_f32(v53, vmulq_f32(v50, v49));
      v61 = *((float32x4_t *)a2 + 42);
      v62 = *((float32x4_t *)a2 + 43);
      v63 = vaddq_f32(v56, vmulq_f32(v61, v48));
      v64 = vaddq_f32(v56, vmulq_f32(v61, v49));
      v65 = vmulq_f32(v49, v49);
      v66 = vmulq_f32(v29, vaddq_f32(vaddq_f32(v46, v45), vmulq_f32(v49, vaddq_f32(v62, vmulq_f32(v49, vaddq_f32(v64, vmulq_f32(v65, vaddq_f32(v60, vmulq_f32(v65, v59)))))))));
      v67 = *((float32x4_t *)a2 + 29);
      v68 = vmaxq_f32(vmulq_f32(v29, vaddq_f32(v47, vmulq_f32(v48, vaddq_f32(v62, vmulq_f32(v48, vaddq_f32(v63, vmulq_f32(v52, vaddq_f32(v57, vmulq_f32(v52, v58))))))))), v67);
      v69 = vmaxq_f32(v66, v67);
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vcvtq_f32_s32(vcvtq_s32_f32(v69));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v71, v69)));
      v74 = vsubq_f32(v68, v72);
      v75 = vsubq_f32(v69, v73);
      v76 = *((float32x4_t *)a2 + 44);
      v77 = *((float32x4_t *)a2 + 45);
      v78 = vaddq_f32(v76, vmulq_f32(v77, v74));
      v79 = vaddq_f32(v76, vmulq_f32(v77, v75));
      v80 = *((float32x4_t *)a2 + 46);
      v81 = *((float32x4_t *)a2 + 47);
      v82 = vaddq_f32(vaddq_f32(v80, vmulq_f32(v81, v75)), vmulq_f32(vmulq_f32(v75, v75), v79));
      v83 = *((float32x4_t *)a2 + 48);
      v84 = vaddq_f32(v21, vmulq_f32(v74, vaddq_f32(v83, vmulq_f32(v74, vaddq_f32(vaddq_f32(v80, vmulq_f32(v74, v81)), vmulq_f32(vmulq_f32(v74, v74), v78))))));
      v85 = vaddq_s32(v23, vcvtq_s32_f32(v72));
      v86 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v75, vaddq_f32(v83, vmulq_f32(v75, v82)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v73)), 0x17uLL));
      v87 = *((float32x4_t *)a2 + 110);
      v88 = (int8x16_t)vmulq_f32(v87, vmulq_f32(v84, (float32x4_t)vshlq_n_s32(v85, 0x17uLL)));
      v89 = *((float32x4_t *)a2 + 111);
      v90 = *((float32x4_t *)a2 + 112);
      v91 = (int8x16_t *)(v6 + v11);
      v91[-1] = vbslq_s8(v17, (int8x16_t)v13, veorq_s8(vandq_s8(v54, (int8x16_t)v18), vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v24, v90)), (int8x16_t)vmulq_f32(v24, v89), v88)));
      *v91 = vbslq_s8(v17, (int8x16_t)v12, veorq_s8(vandq_s8(v54, (int8x16_t)v19), vbslq_s8((int8x16_t)vcgtq_f32(v20, vsubq_f32(v25, v90)), (int8x16_t)vmulq_f32(v25, v89), (int8x16_t)vmulq_f32(v87, v86))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v92 = -v10;
    if (v92 >= v5)
      goto LABEL_3;
LABEL_10:
    v93 = 16 * v92;
    v94 = *(float32x4_t *)(v7 + v93);
    v95 = *((int8x16_t *)a2 + 15);
    v96 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v94, (int8x16_t)vmaxq_f32(v94, *((float32x4_t *)a2 + 113)));
    v97 = *((float32x4_t *)a2 + 75);
    v98 = *((float32x4_t *)a2 + 5);
    v99 = vmulq_f32(v96, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v97, v96), *((int8x16_t *)a2 + 34), (int8x16_t)v98));
    v100 = *((float32x4_t *)a2 + 109);
    v101 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vceqq_f32(v100, v97)), v97), (int8x16_t)v98, (int8x16_t)vaddq_f32(vminq_f32(v99, *((float32x4_t *)a2 + 114)), *((float32x4_t *)a2 + 108)));
    v102 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v101), (int8x16_t)v98);
    v103 = (float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vcgtq_f32(v102, *((float32x4_t *)a2 + 23)));
    v104 = vsubq_f32(vsubq_f32(v102, v98), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v103), v102));
    v105 = vmulq_f32(v104, v104);
    v106 = vmaxq_f32(vmulq_f32(v100, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v101, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v101))), *((float32x4_t *)a2 + 22)), v103), vmulq_f32(v104, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v104, vaddq_f32(
                         vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v104)),
                         vmulq_f32(v105, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v104)), vmulq_f32(v105, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v104))))))))))), *((float32x4_t *)a2 + 29));
    v107 = vcvtq_f32_s32(vcvtq_s32_f32(v106));
    v108 = vsubq_f32(v107, (float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vcgtq_f32(v107, v106)));
    v109 = vsubq_f32(v106, v108);
    *(int8x16_t *)(v6 + v93) = vbslq_s8(v95, (int8x16_t)v94, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v96), vbslq_s8((int8x16_t)vcgtq_f32(v97, vsubq_f32(v99, *((float32x4_t *)a2 + 112))), (int8x16_t)vmulq_f32(v99, *((float32x4_t *)a2 + 111)), (int8x16_t)vmulq_f32(*((float32x4_t *)a2 + 110), vmulq_f32(vaddq_f32(v98, vmulq_f32(v109, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v109, vaddq_f32(
                                                              vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v109)), vmulq_f32(vmulq_f32(v109, v109), vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v109)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v108)), 0x17uLL))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t *v32;
  float32x4_t v33;
  float32x4_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  float32x4_t v40;
  float32x4_t v41;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v35 = 0;
        v36 = 16 * v8;
        v37 = 16 * v7;
        v38 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v39 = 0;
          do
          {
            v40 = v5[v39 / 0x10];
            v41 = vminq_f32(vmaxq_f32(v40, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v6[v39 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v40, (int8x16_t)vmulq_f32(v41, vminq_f32(vrsqrteq_f32(v41), *((float32x4_t *)a2 + 73))));
            v39 += 16;
          }
          while (v38 != v39);
          ++v35;
          v5 = (float32x4_t *)((char *)v5 + v36);
          v6 = (int8x16_t *)((char *)v6 + v37);
        }
        while (v35 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((float32x4_t *)a2 + 73);
          v31 = *((int8x16_t *)a2 + 15);
          v32 = &v6[v17];
          v32[-2] = vbslq_s8(v31, (int8x16_t)v20, (int8x16_t)vmulq_f32(v26, vminq_f32(vrsqrteq_f32(v26), v30)));
          v32[-1] = vbslq_s8(v31, (int8x16_t)v21, (int8x16_t)vmulq_f32(v27, vminq_f32(vrsqrteq_f32(v27), v30)));
          v14 += 4;
          *v32 = vbslq_s8(v31, (int8x16_t)v22, (int8x16_t)vmulq_f32(v28, vminq_f32(vrsqrteq_f32(v28), v30)));
          v32[1] = vbslq_s8(v31, (int8x16_t)v23, (int8x16_t)vmulq_f32(v29, vminq_f32(vrsqrteq_f32(v29), v30)));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v33 = *v18++;
            v34 = vminq_f32(vmaxq_f32(v33, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v33, (int8x16_t)vmulq_f32(v34, vminq_f32(vrsqrteq_f32(v34), *((float32x4_t *)a2 + 73))));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getquicktime_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t *v72;
  uint64_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v73) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v16 = *((float32x4_t *)a2 + 75);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v19 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v12, v16), v17)));
      v20 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v13, v16), v17)));
      v21 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v14, v16), v17)));
      v22 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v15, v16), v17)));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v19, v23), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v20, v24), v27));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v25), v27));
      v32 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v22, v26)));
      v33 = vaddq_f32(v28, v23);
      v34 = vaddq_f32(v28, v24);
      v35 = vaddq_f32(v28, v25);
      v36 = vaddq_f32(v28, v26);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vsubq_f32(v33, vmulq_f32(v29, v37));
      v40 = *((float32x4_t *)a2 + 115);
      v41 = vmulq_f32(v40, v39);
      v42 = vmulq_f32(v40, vsubq_f32(v34, vmulq_f32(v30, v37)));
      v43 = vmulq_f32(v40, vsubq_f32(v35, vmulq_f32(v31, v37)));
      v44 = vmulq_f32(v40, vsubq_f32(v36, vmulq_f32(v32, v37)));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v49 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v45, v41)));
      v50 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v46, v42)));
      v51 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v47, v43)));
      v52 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v48, v44)));
      v53 = *((float32x4_t *)a2 + 11);
      v54 = *((float32x4_t *)a2 + 12);
      v55 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v41, v49))), v54);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v42, v50))), v54);
      v57 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v43, v51))), v54);
      v58 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v44, v52))), v54);
      v59 = vmaxq_f32(vaddq_f32(vaddq_f32(v49, v38), vmulq_f32(v55, v55)), v16);
      v60 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v50), vmulq_f32(v56, v56)), v16);
      v61 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v51), vmulq_f32(v57, v57)), v16);
      v62 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v52), vmulq_f32(v58, v58)), v16);
      v63 = *((float32x4_t *)a2 + 13);
      v64 = *((float32x4_t *)a2 + 14);
      v65 = vminq_f32(v60, v63);
      v66 = vminq_f32(v61, v63);
      v67 = vminq_f32(v62, v63);
      v68 = vmulq_f32(vminq_f32(v59, v63), v64);
      v69 = vmulq_f32(v65, v64);
      v70 = (int8x16_t)vcvtq_s32_f32(vmulq_f32(v66, v64));
      v71 = *((int8x16_t *)a2 + 15);
      v72 = (int8x16_t *)(v6 + v11);
      v72[-2] = vbslq_s8(v71, (int8x16_t)v12, (int8x16_t)vcvtq_s32_f32(v68));
      v72[-1] = vbslq_s8(v71, (int8x16_t)v13, (int8x16_t)vcvtq_s32_f32(v69));
      *v72 = vbslq_s8(v71, (int8x16_t)v14, v70);
      v72[1] = vbslq_s8(v71, (int8x16_t)v15, (int8x16_t)vcvtq_s32_f32(vmulq_f32(v67, v64)));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v73) = -v10;
    if ((int)v73 >= v5)
      goto LABEL_3;
LABEL_10:
    v73 = v73;
    do
    {
      v74 = *(float32x4_t *)(v7 + 16 * v73);
      v75 = *((float32x4_t *)a2 + 75);
      v76 = *((float32x4_t *)a2 + 5);
      v77 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v74, v75), v76)));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v79 = vmulq_f32(*((float32x4_t *)a2 + 115), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v78), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v77, v78))), *((float32x4_t *)a2 + 9))));
      v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
      v81 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v80, v79)));
      v82 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v79, v81))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v73++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v74, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v81), vmulq_f32(v82, v82)), v75), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
    }
    while (v73 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  int32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t *v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = (int8x16_t)vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = (int8x16_t)vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 115);
      v19 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v18, v14)), v14);
      v20 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, v16);
      v21 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, v17);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = *((int8x16_t *)a2 + 21);
      v26 = *((float32x4_t *)a2 + 22);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v21)));
      v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v20))), v26);
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = vsubq_f32(v28, v26);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v30));
      v35 = vaddq_f32(v29, v33);
      v36 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(vmulq_f32(v31, v33), v24));
      v37 = vsubq_f32(vsubq_f32(v27, v15), vmulq_f32(vmulq_f32(v31, v34), v27));
      v38 = vmulq_f32(v36, v36);
      v39 = *((float32x4_t *)a2 + 37);
      v40 = *((float32x4_t *)a2 + 38);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v36));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v43 = *((float32x4_t *)a2 + 39);
      v44 = *((float32x4_t *)a2 + 40);
      v45 = vaddq_f32(v43, vmulq_f32(v44, v36));
      v46 = vaddq_f32(v43, vmulq_f32(v44, v37));
      v47 = *((float32x4_t *)a2 + 41);
      v48 = *((float32x4_t *)a2 + 42);
      v49 = vaddq_f32(v47, vmulq_f32(v48, v36));
      v50 = vaddq_f32(v47, vmulq_f32(v48, v37));
      v51 = vmulq_f32(v37, v37);
      v52 = vaddq_f32(v50, vmulq_f32(v51, vaddq_f32(v42, vmulq_f32(v51, v46))));
      v53 = vmulq_f32(v36, vaddq_f32(v49, vmulq_f32(v38, vaddq_f32(v41, vmulq_f32(v38, v45)))));
      v54 = *((float32x4_t *)a2 + 43);
      v55 = *((float32x4_t *)a2 + 44);
      v56 = vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v37, vaddq_f32(v54, vmulq_f32(v37, v52))));
      v57 = vmulq_f32(v18, vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(v54, v53))));
      v58 = vmulq_f32(v18, v56);
      v59 = *((float32x4_t *)a2 + 29);
      v60 = vmaxq_f32(v57, v59);
      v61 = vmaxq_f32(v58, v59);
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v60, v64);
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 45);
      v69 = *((float32x4_t *)a2 + 46);
      v70 = vaddq_f32(v55, vmulq_f32(v68, v66));
      v71 = vaddq_f32(v55, vmulq_f32(v68, v67));
      v73 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v74 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v72, vmulq_f32(v66, vaddq_f32(vaddq_f32(v69, vmulq_f32(v66, v73)), vmulq_f32(vmulq_f32(v66, v66), v70))))));
      v75 = vaddq_f32(v15, vmulq_f32(v67, vaddq_f32(v72, vmulq_f32(v67, vaddq_f32(vaddq_f32(v69, vmulq_f32(v73, v67)), vmulq_f32(vmulq_f32(v67, v67), v71))))));
      v76 = vcvtq_s32_f32(v65);
      v77 = *((int32x4_t *)a2 + 33);
      v78 = (int8x16_t)vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v77, v76), 0x17uLL));
      v79 = *((int8x16_t *)a2 + 15);
      v80 = (int8x16_t *)(v6 + v11);
      v80[-1] = vbslq_s8(v79, (int8x16_t)v13, (int8x16_t)vmulq_f32(v74, (float32x4_t)vshlq_n_s32(vaddq_s32(v77, vcvtq_s32_f32(v64)), 0x17uLL)));
      *v80 = vbslq_s8(v79, (int8x16_t)v12, v78);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((float32x4_t *)a2 + 5);
    v85 = *((float32x4_t *)a2 + 115);
    v86 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vceqq_f32(v85, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v84, (int8x16_t)vminq_f32(vmaxq_f32(v83, *((float32x4_t *)a2 + 75)), v84));
    v87 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v86), (int8x16_t)v84);
    v88 = (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v87, *((float32x4_t *)a2 + 23)));
    v89 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v86, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v86))), *((float32x4_t *)a2 + 22)), v88);
    v90 = vsubq_f32(vsubq_f32(v87, v84), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v88), v87));
    v91 = vmulq_f32(v90, v90);
    v92 = vmaxq_f32(vmulq_f32(v85, vaddq_f32(v89, vmulq_f32(v90, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v90, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v90)), vmulq_f32(v91, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v90)), vmulq_f32(v91, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v90))))))))))),
            *((float32x4_t *)a2 + 29));
    v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
    v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v93, v92)));
    v95 = vsubq_f32(v92, v94);
    *(int8x16_t *)(v6 + v82) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, (int8x16_t)vmulq_f32(vaddq_f32(v84, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v95)), vmulq_f32(vmulq_f32(v95, v95), vaddq_f32(*((float32x4_t *)a2 + 44),
                                                            vmulq_f32(*((float32x4_t *)a2 + 45), v95)))))))),
                                              (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v94)), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t *v61;
  int v62;
  uint64_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v62 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = vmaxq_f32(v13, v14);
      v16 = vmaxq_f32(v12, v14);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = vminq_f32(v15, v17);
      v19 = vminq_f32(v16, v17);
      v20 = *((int8x16_t *)a2 + 19);
      v21 = *((float32x4_t *)a2 + 20);
      v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v17);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v17);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18)));
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v19)));
      v28 = *((float32x4_t *)a2 + 23);
      v29 = *((float32x4_t *)a2 + 24);
      v30 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v22, v28));
      v31 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v23, v28));
      v32 = vaddq_f32(vsubq_f32(v26, v25), v30);
      v33 = vsubq_f32(vsubq_f32(v22, v17), vmulq_f32(vmulq_f32(v29, v30), v22));
      v34 = vsubq_f32(vsubq_f32(v23, v17), vmulq_f32(vmulq_f32(v29, v31), v23));
      v35 = *((float32x4_t *)a2 + 25);
      v36 = *((float32x4_t *)a2 + 26);
      v37 = *((float32x4_t *)a2 + 27);
      v38 = *((float32x4_t *)a2 + 28);
      v39 = vaddq_f32(vaddq_f32(vsubq_f32(v27, v25), v31), vmulq_f32(v34, vaddq_f32(vaddq_f32(v37, vmulq_f32(v34, v38)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v35, vmulq_f32(v36, v34))))));
      v40 = *((float32x4_t *)a2 + 115);
      v41 = vmulq_f32(v40, vaddq_f32(v32, vmulq_f32(v33, vaddq_f32(vaddq_f32(v37, vmulq_f32(v33, v38)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v35, vmulq_f32(v36, v33)))))));
      v42 = vmulq_f32(v40, v39);
      v44 = *((float32x4_t *)a2 + 29);
      v43 = *((float32x4_t *)a2 + 30);
      v45 = vmaxq_f32(v41, v44);
      v46 = vmaxq_f32(v42, v44);
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v45, v49);
      v52 = vsubq_f32(v46, v50);
      v53 = *((float32x4_t *)a2 + 31);
      v54 = *((float32x4_t *)a2 + 32);
      v55 = vmulq_f32(v52, vaddq_f32(v54, vmulq_f32(v52, vaddq_f32(v43, vmulq_f32(v53, v52)))));
      v56 = vaddq_f32(v17, vmulq_f32(v51, vaddq_f32(v54, vmulq_f32(v51, vaddq_f32(v43, vmulq_f32(v53, v51))))));
      v57 = vcvtq_s32_f32(v49);
      v58 = *((int32x4_t *)a2 + 33);
      v59 = (int8x16_t)vmulq_f32(vaddq_f32(v17, v55), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v50)), 0x17uLL));
      v60 = *((int8x16_t *)a2 + 15);
      v61 = (int8x16_t *)(v6 + v11);
      v61[-1] = vbslq_s8(v60, (int8x16_t)v13, (int8x16_t)vmulq_f32(v56, (float32x4_t)vshlq_n_s32(vaddq_s32(v58, v57), 0x17uLL)));
      *v61 = vbslq_s8(v60, (int8x16_t)v12, v59);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v62 = -v10;
    if (v62 >= v5)
      goto LABEL_3;
LABEL_10:
    v63 = 16 * v62;
    v64 = *(float32x4_t *)(v7 + v63);
    v65 = *((float32x4_t *)a2 + 5);
    v66 = vminq_f32(vmaxq_f32(v64, *((float32x4_t *)a2 + 75)), v65);
    v67 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v66), (int8x16_t)v65);
    v68 = (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v67, *((float32x4_t *)a2 + 23)));
    v69 = vsubq_f32(vsubq_f32(v67, v65), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v68), v67));
    v70 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 115), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v66))), *((float32x4_t *)a2 + 22)), v68), vmulq_f32(v69, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v69, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v69))))))),
            *((float32x4_t *)a2 + 29));
    v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
    v72 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v71, v70)));
    v73 = vsubq_f32(v70, v72);
    *(int8x16_t *)(v6 + v63) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v64, (int8x16_t)vmulq_f32(vaddq_f32(v65, vmulq_f32(v73, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v73, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v73)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v72)), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t *v71;
  int v72;
  uint64_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v72 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = (int8x16_t)vmaxq_f32(v13, v14);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = *((int8x16_t *)a2 + 15);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v13, v15);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *((float32x4_t *)a2 + 75);
      v21 = (int8x16_t)vcgtq_f32(v20, v18);
      v22 = (int8x16_t)vcgtq_f32(v20, v19);
      v23 = *((float32x4_t *)a2 + 5);
      v25 = *((int32x4_t *)a2 + 33);
      v24 = *((int8x16_t *)a2 + 34);
      v26 = vmulq_f32(v18, (float32x4_t)vbslq_s8(v21, v24, (int8x16_t)v23));
      v27 = vmulq_f32(v19, (float32x4_t)vbslq_s8(v22, v24, (int8x16_t)v23));
      v28 = *((float32x4_t *)a2 + 84);
      v29 = vminq_f32(v26, v28);
      v30 = vminq_f32(v27, v28);
      v31 = *((int8x16_t *)a2 + 19);
      v32 = *((float32x4_t *)a2 + 20);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)v29), (int8x16_t)v23);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)v30), (int8x16_t)v23);
      v35 = *((int8x16_t *)a2 + 21);
      v36 = *((float32x4_t *)a2 + 22);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v32, v30)));
      v38 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v32, v29))), v36);
      v39 = *((float32x4_t *)a2 + 23);
      v40 = *((float32x4_t *)a2 + 24);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v33, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v34, v39));
      v43 = vaddq_f32(v38, v41);
      v44 = vaddq_f32(vsubq_f32(v37, v36), v42);
      v45 = vsubq_f32(vsubq_f32(v33, v23), vmulq_f32(vmulq_f32(v40, v41), v33));
      v46 = vsubq_f32(vsubq_f32(v34, v23), vmulq_f32(vmulq_f32(v40, v42), v34));
      v47 = *((float32x4_t *)a2 + 25);
      v48 = *((float32x4_t *)a2 + 26);
      v49 = vaddq_f32(v47, vmulq_f32(v48, v45));
      v50 = vaddq_f32(v47, vmulq_f32(v48, v46));
      v51 = *((float32x4_t *)a2 + 27);
      v52 = *((float32x4_t *)a2 + 28);
      v53 = *((float32x4_t *)a2 + 115);
      v54 = vmulq_f32(v53, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v51, vmulq_f32(v45, v52)), vmulq_f32(vmulq_f32(v45, v45), v49)))));
      v55 = vmulq_f32(v53, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(vaddq_f32(v51, vmulq_f32(v46, v52)), vmulq_f32(vmulq_f32(v46, v46), v50)))));
      v56 = *((float32x4_t *)a2 + 29);
      v57 = *((float32x4_t *)a2 + 30);
      v58 = vmaxq_f32(v54, v56);
      v59 = vmaxq_f32(v55, v56);
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v58, v62);
      v65 = vsubq_f32(v59, v63);
      v66 = *((float32x4_t *)a2 + 31);
      v67 = *((float32x4_t *)a2 + 32);
      v68 = vaddq_f32(v23, vmulq_f32(v64, vaddq_f32(v67, vmulq_f32(v64, vaddq_f32(v57, vmulq_f32(v66, v64))))));
      v69 = vaddq_f32(v23, vmulq_f32(v65, vaddq_f32(v67, vmulq_f32(v65, vaddq_f32(v57, vmulq_f32(v66, v65))))));
      v70 = *((int8x16_t *)a2 + 36);
      v71 = (int8x16_t *)(v6 + v11);
      v71[-1] = vbslq_s8(v17, (int8x16_t)v13, veorq_s8(vandq_s8(v70, (int8x16_t)v18), (int8x16_t)vmulq_f32(v68, (float32x4_t)vshlq_n_s32(vaddq_s32(v25, vcvtq_s32_f32(v62)), 0x17uLL))));
      *v71 = vbslq_s8(v17, (int8x16_t)v12, veorq_s8(vandq_s8(v70, (int8x16_t)v19), (int8x16_t)vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v25, vcvtq_s32_f32(v63)), 0x17uLL))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v72 = -v10;
    if (v72 >= v5)
      goto LABEL_3;
LABEL_10:
    v73 = 16 * v72;
    v74 = *(float32x4_t *)(v7 + v73);
    v75 = *((int8x16_t *)a2 + 15);
    v76 = (float32x4_t)vbslq_s8(v75, (int8x16_t)v74, (int8x16_t)vmaxq_f32(v74, *((float32x4_t *)a2 + 82)));
    v77 = *((float32x4_t *)a2 + 5);
    v78 = vminq_f32(vmulq_f32(v76, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v76), *((int8x16_t *)a2 + 34), (int8x16_t)v77)), *((float32x4_t *)a2 + 84));
    v79 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v78), (int8x16_t)v77);
    v80 = (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v79, *((float32x4_t *)a2 + 23)));
    v81 = vsubq_f32(vsubq_f32(v79, v77), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v80), v79));
    v82 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 115), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v78, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v78))), *((float32x4_t *)a2 + 22)), v80), vmulq_f32(v81, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v81, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v81))))))),
            *((float32x4_t *)a2 + 29));
    v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
    v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v83, v82)));
    v85 = vsubq_f32(v82, v84);
    *(int8x16_t *)(v6 + v73) = vbslq_s8(v75, (int8x16_t)v74, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v76), (int8x16_t)vmulq_f32(vaddq_f32(v77, vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v84)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getquicktime_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t *v81;
  int v82;
  uint64_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v82 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = (int8x16_t)vmaxq_f32(v13, v14);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = *((int8x16_t *)a2 + 15);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v13, v15);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *((float32x4_t *)a2 + 75);
      v21 = *((float32x4_t *)a2 + 5);
      v23 = *((int32x4_t *)a2 + 33);
      v22 = *((int8x16_t *)a2 + 34);
      v24 = vmulq_f32(v18, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v18), v22, (int8x16_t)v21));
      v25 = vmulq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v19), v22, (int8x16_t)v21));
      v26 = *((float32x4_t *)a2 + 84);
      v27 = *((float32x4_t *)a2 + 115);
      v28 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v27, v20)), v20);
      v29 = (float32x4_t)vbslq_s8(v28, (int8x16_t)v21, (int8x16_t)vminq_f32(v24, v26));
      v30 = (float32x4_t)vbslq_s8(v28, (int8x16_t)v21, (int8x16_t)vminq_f32(v25, v26));
      v32 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v29), (int8x16_t)v21);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v21);
      v35 = *((int8x16_t *)a2 + 21);
      v36 = *((float32x4_t *)a2 + 22);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v31, v30)));
      v38 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v31, v29))), v36);
      v39 = *((float32x4_t *)a2 + 23);
      v40 = *((float32x4_t *)a2 + 24);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v33, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v34, v39));
      v43 = vaddq_f32(v38, v41);
      v44 = vaddq_f32(vsubq_f32(v37, v36), v42);
      v45 = vsubq_f32(vsubq_f32(v33, v21), vmulq_f32(vmulq_f32(v40, v41), v33));
      v46 = vsubq_f32(vsubq_f32(v34, v21), vmulq_f32(vmulq_f32(v40, v42), v34));
      v47 = vmulq_f32(v45, v45);
      v48 = *((float32x4_t *)a2 + 38);
      v49 = *((float32x4_t *)a2 + 39);
      v51 = *((int8x16_t *)a2 + 36);
      v50 = *((float32x4_t *)a2 + 37);
      v52 = vaddq_f32(v50, vmulq_f32(v48, v45));
      v53 = vaddq_f32(v50, vmulq_f32(v48, v46));
      v54 = *((float32x4_t *)a2 + 40);
      v55 = *((float32x4_t *)a2 + 41);
      v56 = vaddq_f32(v49, vmulq_f32(v54, v45));
      v57 = vaddq_f32(v49, vmulq_f32(v54, v46));
      v58 = *((float32x4_t *)a2 + 42);
      v59 = *((float32x4_t *)a2 + 43);
      v60 = vaddq_f32(v55, vmulq_f32(v58, v45));
      v61 = vaddq_f32(v55, vmulq_f32(v58, v46));
      v62 = vmulq_f32(v46, v46);
      v63 = vmulq_f32(v27, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(v59, vmulq_f32(v46, vaddq_f32(v61, vmulq_f32(v62, vaddq_f32(v53, vmulq_f32(v62, v57)))))))));
      v64 = *((float32x4_t *)a2 + 29);
      v65 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(v59, vmulq_f32(v45, vaddq_f32(v60, vmulq_f32(v47, vaddq_f32(v52, vmulq_f32(v47, v56))))))))), v64);
      v66 = vmaxq_f32(v63, v64);
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v69 = vsubq_f32(v67, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v67, v65)));
      v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v68, v66)));
      v71 = vsubq_f32(v65, v69);
      v72 = vsubq_f32(v66, v70);
      v73 = *((float32x4_t *)a2 + 44);
      v74 = *((float32x4_t *)a2 + 45);
      v75 = vaddq_f32(v73, vmulq_f32(v74, v71));
      v76 = vaddq_f32(v73, vmulq_f32(v74, v72));
      v77 = *((float32x4_t *)a2 + 46);
      v78 = *((float32x4_t *)a2 + 47);
      v79 = vaddq_f32(vaddq_f32(v77, vmulq_f32(v78, v72)), vmulq_f32(vmulq_f32(v72, v72), v76));
      v80 = *((float32x4_t *)a2 + 48);
      v81 = (int8x16_t *)(v6 + v11);
      v81[-1] = vbslq_s8(v17, (int8x16_t)v13, veorq_s8(vandq_s8(v51, (int8x16_t)v18), (int8x16_t)vmulq_f32(vaddq_f32(v21, vmulq_f32(v71, vaddq_f32(v80, vmulq_f32(v71, vaddq_f32(vaddq_f32(v77, vmulq_f32(v71, v78)), vmulq_f32(vmulq_f32(v71, v71), v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v69)), 0x17uLL))));
      *v81 = vbslq_s8(v17, (int8x16_t)v12, veorq_s8(vandq_s8(v51, (int8x16_t)v19), (int8x16_t)vmulq_f32(vaddq_f32(v21, vmulq_f32(v72, vaddq_f32(v80, vmulq_f32(v72, v79)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v70)), 0x17uLL))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v82 = -v10;
    if (v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v83 = 16 * v82;
    v84 = *(float32x4_t *)(v7 + v83);
    v85 = *((int8x16_t *)a2 + 15);
    v86 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v84, (int8x16_t)vmaxq_f32(v84, *((float32x4_t *)a2 + 82)));
    v87 = *((float32x4_t *)a2 + 5);
    v88 = *((float32x4_t *)a2 + 115);
    v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vceqq_f32(v88, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v87, (int8x16_t)vminq_f32(vmulq_f32(v86, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v86), *((int8x16_t *)a2 + 34), (int8x16_t)v87)), *((float32x4_t *)a2 + 84)));
    v90 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v89), (int8x16_t)v87);
    v91 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v90, *((float32x4_t *)a2 + 23)));
    v92 = vsubq_f32(vsubq_f32(v90, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v91), v90));
    v93 = vmulq_f32(v92, v92);
    v94 = vmaxq_f32(vmulq_f32(v88, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v89, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v89))), *((float32x4_t *)a2 + 22)), v91), vmulq_f32(v92, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v92, vaddq_f32(
                        vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v92)),
                        vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v92)), vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v92))))))))))), *((float32x4_t *)a2 + 29));
    v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
    v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v95, v94)));
    v97 = vsubq_f32(v94, v96);
    *(int8x16_t *)(v6 + v83) = vbslq_s8(v85, (int8x16_t)v84, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v86), (int8x16_t)vmulq_f32(vaddq_f32(v87, vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v97, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v97)), vmulq_f32(vmulq_f32(v97, v97),
                                                            vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v97)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v96)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_fast_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  float32x4_t v39;
  float32x4_t v40;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v34 = 0;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v39 = v5[v38 / 0x10];
            v40 = vminq_f32(vmaxq_f32(v39, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            v6[v38 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v39, (int8x16_t)vmulq_f32(v40, v40));
            v38 += 16;
          }
          while (v37 != v38);
          ++v34;
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (int8x16_t *)((char *)v6 + v36);
        }
        while (v34 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = v5 + 4;
      v13 = v6 + 4;
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 2;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = v5[v17 - 2];
          v21 = v5[v17 - 1];
          v22 = v5[v17];
          v23 = v5[v17 + 1];
          v24 = *((float32x4_t *)a2 + 75);
          v25 = *((float32x4_t *)a2 + 5);
          v26 = vminq_f32(vmaxq_f32(v20, v24), v25);
          v27 = vminq_f32(vmaxq_f32(v21, v24), v25);
          v28 = vminq_f32(vmaxq_f32(v22, v24), v25);
          v29 = vminq_f32(vmaxq_f32(v23, v24), v25);
          v30 = *((int8x16_t *)a2 + 15);
          v31 = &v6[v17];
          v31[-2] = vbslq_s8(v30, (int8x16_t)v20, (int8x16_t)vmulq_f32(v26, v26));
          v31[-1] = vbslq_s8(v30, (int8x16_t)v21, (int8x16_t)vmulq_f32(v27, v27));
          v14 += 4;
          *v31 = vbslq_s8(v30, (int8x16_t)v22, (int8x16_t)vmulq_f32(v28, v28));
          v31[1] = vbslq_s8(v30, (int8x16_t)v23, (int8x16_t)vmulq_f32(v29, v29));
          v17 += 4;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v32 = *v18++;
            v33 = vminq_f32(vmaxq_f32(v32, *((float32x4_t *)a2 + 75)), *((float32x4_t *)a2 + 5));
            *v19++ = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v32, (int8x16_t)vmulq_f32(v33, v33));
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 = (int8x16_t *)((char *)v6 + v10);
        v5 = (float32x4_t *)((char *)v5 + v11);
        v12 = (float32x4_t *)((char *)v12 + v11);
        v13 = (int8x16_t *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

uint64_t Getinv_quicktime_fixed_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t *v72;
  uint64_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 6);
    while (v5 < 4)
    {
      LODWORD(v73) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = *(float32x4_t *)(v7 + v11 - 32);
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v14 = *(float32x4_t *)(v7 + v11);
      v15 = *(float32x4_t *)(v7 + v11 + 16);
      v16 = *((float32x4_t *)a2 + 75);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v19 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v12, v16), v17)));
      v20 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v13, v16), v17)));
      v21 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v14, v16), v17)));
      v22 = vmulq_f32(v18, vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v15, v16), v17)));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v25 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v26 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      v27 = *((float32x4_t *)a2 + 7);
      v28 = *((float32x4_t *)a2 + 8);
      v29 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v19, v23), v27));
      v30 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v20, v24), v27));
      v31 = vrsqrteq_f32(vaddq_f32(vsubq_f32(v21, v25), v27));
      v32 = vrsqrteq_f32(vaddq_f32(v27, vsubq_f32(v22, v26)));
      v33 = vaddq_f32(v28, v23);
      v34 = vaddq_f32(v28, v24);
      v35 = vaddq_f32(v28, v25);
      v36 = vaddq_f32(v28, v26);
      v37 = *((float32x4_t *)a2 + 9);
      v38 = *((float32x4_t *)a2 + 10);
      v39 = vsubq_f32(v33, vmulq_f32(v29, v37));
      v40 = *((float32x4_t *)a2 + 116);
      v41 = vmulq_f32(v40, v39);
      v42 = vmulq_f32(v40, vsubq_f32(v34, vmulq_f32(v30, v37)));
      v43 = vmulq_f32(v40, vsubq_f32(v35, vmulq_f32(v31, v37)));
      v44 = vmulq_f32(v40, vsubq_f32(v36, vmulq_f32(v32, v37)));
      v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v49 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v45, v41)));
      v50 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v46, v42)));
      v51 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v47, v43)));
      v52 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v48, v44)));
      v53 = *((float32x4_t *)a2 + 11);
      v54 = *((float32x4_t *)a2 + 12);
      v55 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v41, v49))), v54);
      v56 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v42, v50))), v54);
      v57 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v43, v51))), v54);
      v58 = vmulq_f32(vrecpeq_f32(vsubq_f32(v53, vsubq_f32(v44, v52))), v54);
      v59 = vmaxq_f32(vaddq_f32(vaddq_f32(v49, v38), vmulq_f32(v55, v55)), v16);
      v60 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v50), vmulq_f32(v56, v56)), v16);
      v61 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v51), vmulq_f32(v57, v57)), v16);
      v62 = vmaxq_f32(vaddq_f32(vaddq_f32(v38, v52), vmulq_f32(v58, v58)), v16);
      v63 = *((float32x4_t *)a2 + 13);
      v64 = *((float32x4_t *)a2 + 14);
      v65 = vminq_f32(v60, v63);
      v66 = vminq_f32(v61, v63);
      v67 = vminq_f32(v62, v63);
      v68 = vmulq_f32(vminq_f32(v59, v63), v64);
      v69 = vmulq_f32(v65, v64);
      v70 = (int8x16_t)vcvtq_s32_f32(vmulq_f32(v66, v64));
      v71 = *((int8x16_t *)a2 + 15);
      v72 = (int8x16_t *)(v6 + v11);
      v72[-2] = vbslq_s8(v71, (int8x16_t)v12, (int8x16_t)vcvtq_s32_f32(v68));
      v72[-1] = vbslq_s8(v71, (int8x16_t)v13, (int8x16_t)vcvtq_s32_f32(v69));
      *v72 = vbslq_s8(v71, (int8x16_t)v14, v70);
      v72[1] = vbslq_s8(v71, (int8x16_t)v15, (int8x16_t)vcvtq_s32_f32(vmulq_f32(v67, v64)));
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v73) = -v10;
    if ((int)v73 >= v5)
      goto LABEL_3;
LABEL_10:
    v73 = v73;
    do
    {
      v74 = *(float32x4_t *)(v7 + 16 * v73);
      v75 = *((float32x4_t *)a2 + 75);
      v76 = *((float32x4_t *)a2 + 5);
      v77 = vmulq_f32(*((float32x4_t *)a2 + 6), vcvtq_f32_s32((int32x4_t)vminq_f32(vmaxq_f32(v74, v75), v76)));
      v78 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v79 = vmulq_f32(*((float32x4_t *)a2 + 116), vsubq_f32(vaddq_f32(*((float32x4_t *)a2 + 8), v78), vmulq_f32(vrsqrteq_f32(vaddq_f32(*((float32x4_t *)a2 + 7), vsubq_f32(v77, v78))), *((float32x4_t *)a2 + 9))));
      v80 = vcvtq_f32_s32(vcvtq_s32_f32(v79));
      v81 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v80, v79)));
      v82 = vmulq_f32(vrecpeq_f32(vsubq_f32(*((float32x4_t *)a2 + 11), vsubq_f32(v79, v81))), *((float32x4_t *)a2 + 12));
      *(int8x16_t *)(v6 + 16 * v73++) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v74, (int8x16_t)vcvtq_s32_f32(vmulq_f32(vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 10), v81), vmulq_f32(v82, v82)), v75), *((float32x4_t *)a2 + 13)), *((float32x4_t *)a2 + 14))));
    }
    while (v73 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_nice_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  int32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t *v80;
  int v81;
  uint64_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v81 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = *((float32x4_t *)a2 + 5);
      v16 = (int8x16_t)vminq_f32(vmaxq_f32(v13, v14), v15);
      v17 = (int8x16_t)vminq_f32(vmaxq_f32(v12, v14), v15);
      v18 = *((float32x4_t *)a2 + 116);
      v19 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32(v18, v14)), v14);
      v20 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, v16);
      v21 = (float32x4_t)vbslq_s8(v19, (int8x16_t)v15, v17);
      v22 = *((int8x16_t *)a2 + 19);
      v23 = *((float32x4_t *)a2 + 20);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v20), (int8x16_t)v15);
      v25 = *((int8x16_t *)a2 + 21);
      v26 = *((float32x4_t *)a2 + 22);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v21), (int8x16_t)v15);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v21)));
      v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v20))), v26);
      v30 = *((float32x4_t *)a2 + 23);
      v31 = *((float32x4_t *)a2 + 24);
      v32 = vsubq_f32(v28, v26);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v24, v30));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v27, v30));
      v35 = vaddq_f32(v29, v33);
      v36 = vsubq_f32(vsubq_f32(v24, v15), vmulq_f32(vmulq_f32(v31, v33), v24));
      v37 = vsubq_f32(vsubq_f32(v27, v15), vmulq_f32(vmulq_f32(v31, v34), v27));
      v38 = vmulq_f32(v36, v36);
      v39 = *((float32x4_t *)a2 + 37);
      v40 = *((float32x4_t *)a2 + 38);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v36));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v43 = *((float32x4_t *)a2 + 39);
      v44 = *((float32x4_t *)a2 + 40);
      v45 = vaddq_f32(v43, vmulq_f32(v44, v36));
      v46 = vaddq_f32(v43, vmulq_f32(v44, v37));
      v47 = *((float32x4_t *)a2 + 41);
      v48 = *((float32x4_t *)a2 + 42);
      v49 = vaddq_f32(v47, vmulq_f32(v48, v36));
      v50 = vaddq_f32(v47, vmulq_f32(v48, v37));
      v51 = vmulq_f32(v37, v37);
      v52 = vaddq_f32(v50, vmulq_f32(v51, vaddq_f32(v42, vmulq_f32(v51, v46))));
      v53 = vmulq_f32(v36, vaddq_f32(v49, vmulq_f32(v38, vaddq_f32(v41, vmulq_f32(v38, v45)))));
      v54 = *((float32x4_t *)a2 + 43);
      v55 = *((float32x4_t *)a2 + 44);
      v56 = vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v37, vaddq_f32(v54, vmulq_f32(v37, v52))));
      v57 = vmulq_f32(v18, vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(v54, v53))));
      v58 = vmulq_f32(v18, v56);
      v59 = *((float32x4_t *)a2 + 29);
      v60 = vmaxq_f32(v57, v59);
      v61 = vmaxq_f32(v58, v59);
      v62 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v62, v60)));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = vsubq_f32(v60, v64);
      v67 = vsubq_f32(v61, v65);
      v68 = *((float32x4_t *)a2 + 45);
      v69 = *((float32x4_t *)a2 + 46);
      v70 = vaddq_f32(v55, vmulq_f32(v68, v66));
      v71 = vaddq_f32(v55, vmulq_f32(v68, v67));
      v73 = *((float32x4_t *)a2 + 47);
      v72 = *((float32x4_t *)a2 + 48);
      v74 = vaddq_f32(v15, vmulq_f32(v66, vaddq_f32(v72, vmulq_f32(v66, vaddq_f32(vaddq_f32(v69, vmulq_f32(v66, v73)), vmulq_f32(vmulq_f32(v66, v66), v70))))));
      v75 = vaddq_f32(v15, vmulq_f32(v67, vaddq_f32(v72, vmulq_f32(v67, vaddq_f32(vaddq_f32(v69, vmulq_f32(v73, v67)), vmulq_f32(vmulq_f32(v67, v67), v71))))));
      v76 = vcvtq_s32_f32(v65);
      v77 = *((int32x4_t *)a2 + 33);
      v78 = (int8x16_t)vmulq_f32(v75, (float32x4_t)vshlq_n_s32(vaddq_s32(v77, v76), 0x17uLL));
      v79 = *((int8x16_t *)a2 + 15);
      v80 = (int8x16_t *)(v6 + v11);
      v80[-1] = vbslq_s8(v79, (int8x16_t)v13, (int8x16_t)vmulq_f32(v74, (float32x4_t)vshlq_n_s32(vaddq_s32(v77, vcvtq_s32_f32(v64)), 0x17uLL)));
      *v80 = vbslq_s8(v79, (int8x16_t)v12, v78);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v81 = -v10;
    if (v81 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = 16 * v81;
    v83 = *(float32x4_t *)(v7 + v82);
    v84 = *((float32x4_t *)a2 + 5);
    v85 = *((float32x4_t *)a2 + 116);
    v86 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vceqq_f32(v85, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v84, (int8x16_t)vminq_f32(vmaxq_f32(v83, *((float32x4_t *)a2 + 75)), v84));
    v87 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v86), (int8x16_t)v84);
    v88 = (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v87, *((float32x4_t *)a2 + 23)));
    v89 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v86, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v86))), *((float32x4_t *)a2 + 22)), v88);
    v90 = vsubq_f32(vsubq_f32(v87, v84), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v88), v87));
    v91 = vmulq_f32(v90, v90);
    v92 = vmaxq_f32(vmulq_f32(v85, vaddq_f32(v89, vmulq_f32(v90, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v90, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v90)), vmulq_f32(v91, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v90)), vmulq_f32(v91, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v90))))))))))),
            *((float32x4_t *)a2 + 29));
    v93 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
    v94 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v84, (int8x16_t)vcgtq_f32(v93, v92)));
    v95 = vsubq_f32(v92, v94);
    *(int8x16_t *)(v6 + v82) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v83, (int8x16_t)vmulq_f32(vaddq_f32(v84, vmulq_f32(v95, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v95, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v95)), vmulq_f32(vmulq_f32(v95, v95), vaddq_f32(*((float32x4_t *)a2 + 44),
                                                            vmulq_f32(*((float32x4_t *)a2 + 45), v95)))))))),
                                              (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v94)), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_half_sat_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t *v61;
  int v62;
  uint64_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v62 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 75);
      v15 = vmaxq_f32(v13, v14);
      v16 = vmaxq_f32(v12, v14);
      v17 = *((float32x4_t *)a2 + 5);
      v18 = vminq_f32(v15, v17);
      v19 = vminq_f32(v16, v17);
      v20 = *((int8x16_t *)a2 + 19);
      v21 = *((float32x4_t *)a2 + 20);
      v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v17);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v17);
      v24 = *((int8x16_t *)a2 + 21);
      v25 = *((float32x4_t *)a2 + 22);
      v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18)));
      v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v19)));
      v28 = *((float32x4_t *)a2 + 23);
      v29 = *((float32x4_t *)a2 + 24);
      v30 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v22, v28));
      v31 = (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v23, v28));
      v32 = vaddq_f32(vsubq_f32(v26, v25), v30);
      v33 = vsubq_f32(vsubq_f32(v22, v17), vmulq_f32(vmulq_f32(v29, v30), v22));
      v34 = vsubq_f32(vsubq_f32(v23, v17), vmulq_f32(vmulq_f32(v29, v31), v23));
      v35 = *((float32x4_t *)a2 + 25);
      v36 = *((float32x4_t *)a2 + 26);
      v37 = *((float32x4_t *)a2 + 27);
      v38 = *((float32x4_t *)a2 + 28);
      v39 = vaddq_f32(vaddq_f32(vsubq_f32(v27, v25), v31), vmulq_f32(v34, vaddq_f32(vaddq_f32(v37, vmulq_f32(v34, v38)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v35, vmulq_f32(v36, v34))))));
      v40 = *((float32x4_t *)a2 + 116);
      v41 = vmulq_f32(v40, vaddq_f32(v32, vmulq_f32(v33, vaddq_f32(vaddq_f32(v37, vmulq_f32(v33, v38)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v35, vmulq_f32(v36, v33)))))));
      v42 = vmulq_f32(v40, v39);
      v44 = *((float32x4_t *)a2 + 29);
      v43 = *((float32x4_t *)a2 + 30);
      v45 = vmaxq_f32(v41, v44);
      v46 = vmaxq_f32(v42, v44);
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v48, v46)));
      v51 = vsubq_f32(v45, v49);
      v52 = vsubq_f32(v46, v50);
      v53 = *((float32x4_t *)a2 + 31);
      v54 = *((float32x4_t *)a2 + 32);
      v55 = vmulq_f32(v52, vaddq_f32(v54, vmulq_f32(v52, vaddq_f32(v43, vmulq_f32(v53, v52)))));
      v56 = vaddq_f32(v17, vmulq_f32(v51, vaddq_f32(v54, vmulq_f32(v51, vaddq_f32(v43, vmulq_f32(v53, v51))))));
      v57 = vcvtq_s32_f32(v49);
      v58 = *((int32x4_t *)a2 + 33);
      v59 = (int8x16_t)vmulq_f32(vaddq_f32(v17, v55), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v50)), 0x17uLL));
      v60 = *((int8x16_t *)a2 + 15);
      v61 = (int8x16_t *)(v6 + v11);
      v61[-1] = vbslq_s8(v60, (int8x16_t)v13, (int8x16_t)vmulq_f32(v56, (float32x4_t)vshlq_n_s32(vaddq_s32(v58, v57), 0x17uLL)));
      *v61 = vbslq_s8(v60, (int8x16_t)v12, v59);
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v62 = -v10;
    if (v62 >= v5)
      goto LABEL_3;
LABEL_10:
    v63 = 16 * v62;
    v64 = *(float32x4_t *)(v7 + v63);
    v65 = *((float32x4_t *)a2 + 5);
    v66 = vminq_f32(vmaxq_f32(v64, *((float32x4_t *)a2 + 75)), v65);
    v67 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v66), (int8x16_t)v65);
    v68 = (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v67, *((float32x4_t *)a2 + 23)));
    v69 = vsubq_f32(vsubq_f32(v67, v65), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v68), v67));
    v70 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 116), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v66))), *((float32x4_t *)a2 + 22)), v68), vmulq_f32(v69, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v69, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v69))))))),
            *((float32x4_t *)a2 + 29));
    v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
    v72 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v71, v70)));
    v73 = vsubq_f32(v70, v72);
    *(int8x16_t *)(v6 + v63) = vbslq_s8(*((int8x16_t *)a2 + 15), (int8x16_t)v64, (int8x16_t)vmulq_f32(vaddq_f32(v65, vmulq_f32(v73, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v73, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v73)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v72)), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_half_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t *v71;
  int v72;
  uint64_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v72 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = (int8x16_t)vmaxq_f32(v13, v14);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = *((int8x16_t *)a2 + 15);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v13, v15);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *((float32x4_t *)a2 + 75);
      v21 = (int8x16_t)vcgtq_f32(v20, v18);
      v22 = (int8x16_t)vcgtq_f32(v20, v19);
      v23 = *((float32x4_t *)a2 + 5);
      v25 = *((int32x4_t *)a2 + 33);
      v24 = *((int8x16_t *)a2 + 34);
      v26 = vmulq_f32(v18, (float32x4_t)vbslq_s8(v21, v24, (int8x16_t)v23));
      v27 = vmulq_f32(v19, (float32x4_t)vbslq_s8(v22, v24, (int8x16_t)v23));
      v28 = *((float32x4_t *)a2 + 90);
      v29 = vminq_f32(v26, v28);
      v30 = vminq_f32(v27, v28);
      v31 = *((int8x16_t *)a2 + 19);
      v32 = *((float32x4_t *)a2 + 20);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)v29), (int8x16_t)v23);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)v30), (int8x16_t)v23);
      v35 = *((int8x16_t *)a2 + 21);
      v36 = *((float32x4_t *)a2 + 22);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v32, v30)));
      v38 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v32, v29))), v36);
      v39 = *((float32x4_t *)a2 + 23);
      v40 = *((float32x4_t *)a2 + 24);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v33, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v34, v39));
      v43 = vaddq_f32(v38, v41);
      v44 = vaddq_f32(vsubq_f32(v37, v36), v42);
      v45 = vsubq_f32(vsubq_f32(v33, v23), vmulq_f32(vmulq_f32(v40, v41), v33));
      v46 = vsubq_f32(vsubq_f32(v34, v23), vmulq_f32(vmulq_f32(v40, v42), v34));
      v47 = *((float32x4_t *)a2 + 25);
      v48 = *((float32x4_t *)a2 + 26);
      v49 = vaddq_f32(v47, vmulq_f32(v48, v45));
      v50 = vaddq_f32(v47, vmulq_f32(v48, v46));
      v51 = *((float32x4_t *)a2 + 27);
      v52 = *((float32x4_t *)a2 + 28);
      v53 = *((float32x4_t *)a2 + 116);
      v54 = vmulq_f32(v53, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v51, vmulq_f32(v45, v52)), vmulq_f32(vmulq_f32(v45, v45), v49)))));
      v55 = vmulq_f32(v53, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(vaddq_f32(v51, vmulq_f32(v46, v52)), vmulq_f32(vmulq_f32(v46, v46), v50)))));
      v56 = *((float32x4_t *)a2 + 29);
      v57 = *((float32x4_t *)a2 + 30);
      v58 = vmaxq_f32(v54, v56);
      v59 = vmaxq_f32(v55, v56);
      v60 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v61 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v62 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v60, v58)));
      v63 = vsubq_f32(v61, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v61, v59)));
      v64 = vsubq_f32(v58, v62);
      v65 = vsubq_f32(v59, v63);
      v66 = *((float32x4_t *)a2 + 31);
      v67 = *((float32x4_t *)a2 + 32);
      v68 = vaddq_f32(v23, vmulq_f32(v64, vaddq_f32(v67, vmulq_f32(v64, vaddq_f32(v57, vmulq_f32(v66, v64))))));
      v69 = vaddq_f32(v23, vmulq_f32(v65, vaddq_f32(v67, vmulq_f32(v65, vaddq_f32(v57, vmulq_f32(v66, v65))))));
      v70 = *((int8x16_t *)a2 + 36);
      v71 = (int8x16_t *)(v6 + v11);
      v71[-1] = vbslq_s8(v17, (int8x16_t)v13, veorq_s8(vandq_s8(v70, (int8x16_t)v18), (int8x16_t)vmulq_f32(v68, (float32x4_t)vshlq_n_s32(vaddq_s32(v25, vcvtq_s32_f32(v62)), 0x17uLL))));
      *v71 = vbslq_s8(v17, (int8x16_t)v12, veorq_s8(vandq_s8(v70, (int8x16_t)v19), (int8x16_t)vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v25, vcvtq_s32_f32(v63)), 0x17uLL))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v72 = -v10;
    if (v72 >= v5)
      goto LABEL_3;
LABEL_10:
    v73 = 16 * v72;
    v74 = *(float32x4_t *)(v7 + v73);
    v75 = *((int8x16_t *)a2 + 15);
    v76 = (float32x4_t)vbslq_s8(v75, (int8x16_t)v74, (int8x16_t)vmaxq_f32(v74, *((float32x4_t *)a2 + 82)));
    v77 = *((float32x4_t *)a2 + 5);
    v78 = vminq_f32(vmulq_f32(v76, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v76), *((int8x16_t *)a2 + 34), (int8x16_t)v77)), *((float32x4_t *)a2 + 90));
    v79 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v78), (int8x16_t)v77);
    v80 = (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v79, *((float32x4_t *)a2 + 23)));
    v81 = vsubq_f32(vsubq_f32(v79, v77), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v80), v79));
    v82 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 116), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v78, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v78))), *((float32x4_t *)a2 + 22)), v80), vmulq_f32(v81, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 27), vmulq_f32(v81, *((float32x4_t *)a2 + 28))), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(*((float32x4_t *)a2 + 25), vmulq_f32(*((float32x4_t *)a2 + 26), v81))))))),
            *((float32x4_t *)a2 + 29));
    v83 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
    v84 = vsubq_f32(v83, (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v83, v82)));
    v85 = vsubq_f32(v82, v84);
    *(int8x16_t *)(v6 + v73) = vbslq_s8(v75, (int8x16_t)v74, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v76), (int8x16_t)vmulq_f32(vaddq_f32(v77, vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 32), vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 30), vmulq_f32(*((float32x4_t *)a2 + 31), v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v84)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t Getinv_quicktime_nice_unpremultTile(HGTile *a1, HGToneCurve::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t *v81;
  int v82;
  uint64_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = 16 * *((int *)a1 + 6);
    v9 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v82 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 += v9;
      v6 += v8;
      if (++v4 == v3)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v7 + v11 - 16);
      v12 = *(float32x4_t *)(v7 + v11);
      v14 = *((float32x4_t *)a2 + 82);
      v15 = (int8x16_t)vmaxq_f32(v13, v14);
      v16 = (int8x16_t)vmaxq_f32(v12, v14);
      v17 = *((int8x16_t *)a2 + 15);
      v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v13, v15);
      v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      v20 = *((float32x4_t *)a2 + 75);
      v21 = *((float32x4_t *)a2 + 5);
      v23 = *((int32x4_t *)a2 + 33);
      v22 = *((int8x16_t *)a2 + 34);
      v24 = vmulq_f32(v18, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v18), v22, (int8x16_t)v21));
      v25 = vmulq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v20, v19), v22, (int8x16_t)v21));
      v26 = *((float32x4_t *)a2 + 90);
      v27 = *((float32x4_t *)a2 + 116);
      v28 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v27, v20)), v20);
      v29 = (float32x4_t)vbslq_s8(v28, (int8x16_t)v21, (int8x16_t)vminq_f32(v24, v26));
      v30 = (float32x4_t)vbslq_s8(v28, (int8x16_t)v21, (int8x16_t)vminq_f32(v25, v26));
      v32 = *((int8x16_t *)a2 + 19);
      v31 = *((float32x4_t *)a2 + 20);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v29), (int8x16_t)v21);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v21);
      v35 = *((int8x16_t *)a2 + 21);
      v36 = *((float32x4_t *)a2 + 22);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v31, v30)));
      v38 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v31, v29))), v36);
      v39 = *((float32x4_t *)a2 + 23);
      v40 = *((float32x4_t *)a2 + 24);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v33, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v34, v39));
      v43 = vaddq_f32(v38, v41);
      v44 = vaddq_f32(vsubq_f32(v37, v36), v42);
      v45 = vsubq_f32(vsubq_f32(v33, v21), vmulq_f32(vmulq_f32(v40, v41), v33));
      v46 = vsubq_f32(vsubq_f32(v34, v21), vmulq_f32(vmulq_f32(v40, v42), v34));
      v47 = vmulq_f32(v45, v45);
      v48 = *((float32x4_t *)a2 + 38);
      v49 = *((float32x4_t *)a2 + 39);
      v51 = *((int8x16_t *)a2 + 36);
      v50 = *((float32x4_t *)a2 + 37);
      v52 = vaddq_f32(v50, vmulq_f32(v48, v45));
      v53 = vaddq_f32(v50, vmulq_f32(v48, v46));
      v54 = *((float32x4_t *)a2 + 40);
      v55 = *((float32x4_t *)a2 + 41);
      v56 = vaddq_f32(v49, vmulq_f32(v54, v45));
      v57 = vaddq_f32(v49, vmulq_f32(v54, v46));
      v58 = *((float32x4_t *)a2 + 42);
      v59 = *((float32x4_t *)a2 + 43);
      v60 = vaddq_f32(v55, vmulq_f32(v58, v45));
      v61 = vaddq_f32(v55, vmulq_f32(v58, v46));
      v62 = vmulq_f32(v46, v46);
      v63 = vmulq_f32(v27, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(v59, vmulq_f32(v46, vaddq_f32(v61, vmulq_f32(v62, vaddq_f32(v53, vmulq_f32(v62, v57)))))))));
      v64 = *((float32x4_t *)a2 + 29);
      v65 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(v59, vmulq_f32(v45, vaddq_f32(v60, vmulq_f32(v47, vaddq_f32(v52, vmulq_f32(v47, v56))))))))), v64);
      v66 = vmaxq_f32(v63, v64);
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v69 = vsubq_f32(v67, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v67, v65)));
      v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v68, v66)));
      v71 = vsubq_f32(v65, v69);
      v72 = vsubq_f32(v66, v70);
      v73 = *((float32x4_t *)a2 + 44);
      v74 = *((float32x4_t *)a2 + 45);
      v75 = vaddq_f32(v73, vmulq_f32(v74, v71));
      v76 = vaddq_f32(v73, vmulq_f32(v74, v72));
      v77 = *((float32x4_t *)a2 + 46);
      v78 = *((float32x4_t *)a2 + 47);
      v79 = vaddq_f32(vaddq_f32(v77, vmulq_f32(v78, v72)), vmulq_f32(vmulq_f32(v72, v72), v76));
      v80 = *((float32x4_t *)a2 + 48);
      v81 = (int8x16_t *)(v6 + v11);
      v81[-1] = vbslq_s8(v17, (int8x16_t)v13, veorq_s8(vandq_s8(v51, (int8x16_t)v18), (int8x16_t)vmulq_f32(vaddq_f32(v21, vmulq_f32(v71, vaddq_f32(v80, vmulq_f32(v71, vaddq_f32(vaddq_f32(v77, vmulq_f32(v71, v78)), vmulq_f32(vmulq_f32(v71, v71), v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v69)), 0x17uLL))));
      *v81 = vbslq_s8(v17, (int8x16_t)v12, veorq_s8(vandq_s8(v51, (int8x16_t)v19), (int8x16_t)vmulq_f32(vaddq_f32(v21, vmulq_f32(v72, vaddq_f32(v80, vmulq_f32(v72, v79)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v23, vcvtq_s32_f32(v70)), 0x17uLL))));
      v10 -= 2;
      v11 += 32;
    }
    while (v5 + v10 > 1);
    v82 = -v10;
    if (v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v83 = 16 * v82;
    v84 = *(float32x4_t *)(v7 + v83);
    v85 = *((int8x16_t *)a2 + 15);
    v86 = (float32x4_t)vbslq_s8(v85, (int8x16_t)v84, (int8x16_t)vmaxq_f32(v84, *((float32x4_t *)a2 + 82)));
    v87 = *((float32x4_t *)a2 + 5);
    v88 = *((float32x4_t *)a2 + 116);
    v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vceqq_f32(v88, *((float32x4_t *)a2 + 75))), *((float32x4_t *)a2 + 75)), (int8x16_t)v87, (int8x16_t)vminq_f32(vmulq_f32(v86, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 75), v86), *((int8x16_t *)a2 + 34), (int8x16_t)v87)), *((float32x4_t *)a2 + 90)));
    v90 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 19), (int8x16_t)v89), (int8x16_t)v87);
    v91 = (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v90, *((float32x4_t *)a2 + 23)));
    v92 = vsubq_f32(vsubq_f32(v90, v87), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 24), v91), v90));
    v93 = vmulq_f32(v92, v92);
    v94 = vmaxq_f32(vmulq_f32(v88, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v89, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 21), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 20), v89))), *((float32x4_t *)a2 + 22)), v91), vmulq_f32(v92, vaddq_f32(*((float32x4_t *)a2 + 43), vmulq_f32(v92, vaddq_f32(
                        vaddq_f32(*((float32x4_t *)a2 + 41), vmulq_f32(*((float32x4_t *)a2 + 42), v92)),
                        vmulq_f32(v93, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 37), vmulq_f32(*((float32x4_t *)a2 + 38), v92)), vmulq_f32(v93, vaddq_f32(*((float32x4_t *)a2 + 39), vmulq_f32(*((float32x4_t *)a2 + 40), v92))))))))))), *((float32x4_t *)a2 + 29));
    v95 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
    v96 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v87, (int8x16_t)vcgtq_f32(v95, v94)));
    v97 = vsubq_f32(v94, v96);
    *(int8x16_t *)(v6 + v83) = vbslq_s8(v85, (int8x16_t)v84, veorq_s8(vandq_s8(*((int8x16_t *)a2 + 36), (int8x16_t)v86), (int8x16_t)vmulq_f32(vaddq_f32(v87, vmulq_f32(v97, vaddq_f32(*((float32x4_t *)a2 + 48), vmulq_f32(v97, vaddq_f32(vaddq_f32(*((float32x4_t *)a2 + 46), vmulq_f32(*((float32x4_t *)a2 + 47), v97)), vmulq_f32(vmulq_f32(v97, v97),
                                                            vaddq_f32(*((float32x4_t *)a2 + 44), vmulq_f32(*((float32x4_t *)a2 + 45), v97)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)a2 + 33), vcvtq_s32_f32(v96)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

void HGHWBlendFlipped::AllocateStates(HGHWBlendFlipped *this, HGRenderer *a2)
{
  unint64_t v4;
  HGHWBlendFlipped::State ***v5;
  uint64_t v6;
  HGHWBlendFlipped::State *v7;
  unint64_t v8;
  HGHWBlendFlipped::State **v9;
  HGHWBlendFlipped::State **v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _BYTE *v16;
  HGHWBlendFlipped::State **v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  HGHWBlendFlipped::State **v21;
  _OWORD *v22;
  HGHWBlendFlipped::State **v23;
  uint64_t v24;
  __int128 v25;
  HGHWBlendFlipped::State *v26;

  if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
  {
    v4 = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 5);
    if (v4 <= (uint64_t)(*((_QWORD *)this + 57) - *((_QWORD *)this + 56)) >> 3)
      return;
    goto LABEL_5;
  }
  v4 = 1;
  if (!((uint64_t)(*((_QWORD *)this + 57) - *((_QWORD *)this + 56)) >> 3))
  {
LABEL_5:
    v5 = (HGHWBlendFlipped::State ***)((char *)this + 448);
    while (1)
    {
      v7 = (HGHWBlendFlipped::State *)operator new();
      HGHWBlendFlipped::State::State(v7);
      v9 = (HGHWBlendFlipped::State **)*((_QWORD *)this + 57);
      v8 = *((_QWORD *)this + 58);
      if ((unint64_t)v9 >= v8)
        break;
      *v9 = v7;
      v6 = (uint64_t)(v9 + 1);
LABEL_7:
      *((_QWORD *)this + 57) = v6;
      if (v4 <= (v6 - *((_QWORD *)this + 56)) >> 3)
        return;
    }
    v10 = *v5;
    v11 = (char *)v9 - (char *)*v5;
    v12 = v11 >> 3;
    v13 = (v11 >> 3) + 1;
    if (v13 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v14 = v8 - (_QWORD)v10;
    if (v14 >> 2 > v13)
      v13 = v14 >> 2;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
    {
      if (v15 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v16 = operator new(8 * v15);
      v17 = (HGHWBlendFlipped::State **)&v16[8 * v12];
      *v17 = v7;
      v6 = (uint64_t)(v17 + 1);
      if (v9 == v10)
        goto LABEL_27;
    }
    else
    {
      v16 = 0;
      v17 = (HGHWBlendFlipped::State **)(8 * v12);
      *(_QWORD *)(8 * v12) = v7;
      v6 = 8 * v12 + 8;
      if (v9 == v10)
      {
LABEL_27:
        *((_QWORD *)this + 56) = v17;
        *((_QWORD *)this + 57) = v6;
        *((_QWORD *)this + 58) = &v16[8 * v15];
        if (v9)
          operator delete(v9);
        goto LABEL_7;
      }
    }
    v18 = (char *)(v9 - 1) - (char *)v10;
    if (v18 < 0x58)
      goto LABEL_34;
    if ((unint64_t)((char *)v9 - &v16[v11]) < 0x20)
      goto LABEL_34;
    v19 = (v18 >> 3) + 1;
    v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    v21 = &v9[v20 / 0xFFFFFFFFFFFFFFF8];
    v17 = (HGHWBlendFlipped::State **)((char *)v17 - v20);
    v22 = &v16[8 * v12 - 16];
    v23 = v9 - 2;
    v24 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v25 = *(_OWORD *)v23;
      *(v22 - 1) = *((_OWORD *)v23 - 1);
      *v22 = v25;
      v22 -= 2;
      v23 -= 4;
      v24 -= 4;
    }
    while (v24);
    v9 = v21;
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_34:
      do
      {
        v26 = *--v9;
        *--v17 = v26;
      }
      while (v9 != v10);
    }
    v9 = *v5;
    goto LABEL_27;
  }
}

void sub_1B2B6506C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1000C40811E05F4);
  _Unwind_Resume(a1);
}

uint64_t HGHWBlendFlipped::DeleteStates(uint64_t this)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(this + 456) - *(_QWORD *)(this + 448);
  if ((int)(v1 >> 3) >= 1)
  {
    v2 = this;
    v3 = (v1 >> 3) + 1;
    do
    {
      this = *(_QWORD *)(*(_QWORD *)(v2 + 448) + 8 * (v3 - 2));
      if (this)
        this = MEMORY[0x1B5E29170](this, 0x1000C40811E05F4);
      --v3;
    }
    while (v3 > 1);
  }
  return this;
}

uint64_t HGHWBlendFlipped::Bind(HGHWBlendFlipped *this, HGHandler *a2)
{
  unsigned int v4;

  if (*((_QWORD *)this + 56) != *((_QWORD *)this + 57))
  {
    (*(void (**)(HGHWBlendFlipped *, _QWORD))(*(_QWORD *)this + 616))(this, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, **((_QWORD **)this + 56), 1);
    v4 = *((_DWORD *)this + 106);
    if (v4 - 9 <= 0x20 && HGHWBlendFlipped::GetGammaBlendMode(this, v4, *((float *)this + 105)) == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, **((_QWORD **)this + 56) + 16, 1);
      if (*((_DWORD *)this + 106) != 26)
        (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, **((_QWORD **)this + 56) + 32, 1);
    }
  }
  return 0;
}

float HGHWBlendFlipped::UpdateLocalParameters(HGHWBlendFlipped *this, int a2, float result)
{
  uint64_t v3;
  const float *v4;
  float32x4_t v5;
  float v6;
  uint64_t v7;
  __int128 v13;

  v3 = *((_QWORD *)this + 56);
  if ((int)((unint64_t)(*((_QWORD *)this + 57) - v3) >> 3) > a2)
  {
    if ((*((_DWORD *)this + 106) & 0xFFFFFFFE) == 0x24 && !*((_BYTE *)this + 481))
    {
      v6 = *((float *)this + 104);
      v5.f32[0] = v6 * *((float *)this + 124);
      v5.f32[1] = v6 * *((float *)this + 125);
      v5.f32[2] = v6 * *((float *)this + 126);
      v5.f32[3] = v6;
    }
    else
    {
      v4 = (const float *)((char *)this + 416);
      v5 = vld1q_dup_f32(v4);
    }
    v7 = 8 * a2;
    *(float32x4_t *)*(_QWORD *)(v3 + v7) = v5;
    __asm { FMOV            V1.4S, #1.0 }
    HIDWORD(v13) = HIDWORD(_Q1);
    *(float *)&v13 = 1.0 / *((float *)this + 105);
    *((float *)&v13 + 1) = *(float *)&v13;
    *((float *)&v13 + 2) = *(float *)&v13;
    *(_OWORD *)(*(_QWORD *)(*((_QWORD *)this + 56) + v7) + 16) = v13;
    result = *((float *)this + 105);
    *(float *)&_Q1 = result;
    *((float *)&_Q1 + 1) = result;
    *((float *)&_Q1 + 2) = result;
    *(_OWORD *)(*(_QWORD *)(*((_QWORD *)this + 56) + v7) + 32) = _Q1;
  }
  return result;
}

uint64_t HGHWBlendFlipped::RenderTile(float32x2_t *this, HGTile *a2, unsigned int a3, float *a4)
{
  uint64_t v4;
  float32x2_t v5;
  __int128 v8;
  uint64_t (*v10)(HGTile *, _QWORD, float32x2_t *);

  v4 = *(int *)(*((_QWORD *)a2 + 42) + 160);
  v5 = this[56];
  if ((int)v4 >= (int)((*(_QWORD *)&this[57] - *(_QWORD *)&v5) >> 3))
    return 0;
  if ((a3 & 0xFFFFFFFE) == 0x24 && !this[60].i8[1])
  {
    *(float32x2_t *)&v8 = vmul_f32(*(float32x2_t *)a4, this[62]);
    *((float *)&v8 + 2) = this[63].f32[0] * a4[2];
  }
  else
  {
    *(_QWORD *)&v8 = *(_QWORD *)a4;
    *((float *)&v8 + 2) = a4[2];
  }
  *((float *)&v8 + 3) = a4[3];
  *(_OWORD *)*(_QWORD *)(*(_QWORD *)&v5 + 8 * v4) = v8;
  *(_OWORD *)(*(_QWORD *)(*(_QWORD *)&this[56] + 8 * v4) + 16) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(*(_QWORD *)(*(_QWORD *)&this[56] + 8 * v4) + 32) = *((_OWORD *)a4 + 2);
  if (!*((_QWORD *)a2 + 10) || !*((_QWORD *)a2 + 12) || a3 - 9 > 0x20)
    return HGLegacyBlend::RenderTile((HGLegacyBlend *)this, a2, a3, a4);
  v10 = (uint64_t (*)(HGTile *, _QWORD, float32x2_t *))*(&s_func_glblend_table
                                                                 + 3 * a3
                                                                 + (int)HGHWBlendFlipped::GetGammaBlendMode((HGHWBlendFlipped *)this, a3, a4[8])- 27);
  return v10(a2, *(_QWORD *)(*(_QWORD *)&this[56] + 8 * v4), this);
}

uint64_t HGHWBlendFlipped::GetProgram(HGHWBlendFlipped *this, HGRenderer *a2)
{
  unsigned int v3;
  uint64_t (*v4)(HGRenderer *);

  v3 = *((_DWORD *)this + 106);
  if (v3 - 9 > 0x20)
    return HGLegacyBlend::GetProgram(this, a2);
  v4 = *(&s_arb_glblend_table[3 * v3 - 27] + (int)HGHWBlendFlipped::GetGammaBlendMode(this, v3, *((float *)this + 105)));
  return v4(a2);
}

uint64_t HGHWBlendFlipped::InitProgramDescriptor(HGHWBlendFlipped *this, HGProgramDescriptor *a2)
{
  unsigned int v3;
  uint64_t (*v4)(HGProgramDescriptor *);

  v3 = *((_DWORD *)this + 106);
  if (v3 - 9 > 0x20)
    return HGLegacyBlend::InitProgramDescriptor((HGNode *)this, a2);
  v4 = *(&s_programdesc_glblend_table[3 * v3 - 27]
       + (int)HGHWBlendFlipped::GetGammaBlendMode(this, v3, *((float *)this + 105)));
  return v4(a2);
}

const char *HGHWBlendFlipped::GetOpacityProgram(HGHWBlendFlipped *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000236\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=5499c239:9891868e:bd9ea6d3:bd30d467\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000228\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=6eae314a:ee581af3:fdfce447:74b07bd6\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001f6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=78149511:5c47b7fc:9d3dfb0a:c601ba4b\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *HGHWBlendFlipped::GetMetalOpacityProgram(HGHWBlendFlipped *this, HGRenderer *a2)
{
  uint64_t v3;
  unsigned int Target;
  const char *v5;

  v3 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 32);
  (*(void (**)(HGRenderer *, uint64_t, uint64_t))(*(_QWORD *)a2 + 120))(a2, 32, 396048);
  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      v5 = "//Metal1.0     \n"
           "//LEN=0000000236\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
           "    const constant float4* hg_Params [[ buffer(0) ]], \n"
           "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
           "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    half4 r0;\n"
           "    FragmentOut output;\n"
           "\n"
           "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    output.color0 = float4(r0)*hg_Params[0];\n"
           "    return output;\n"
           "}\n"
           "//MD5=5499c239:9891868e:bd9ea6d3:bd30d467\n"
           "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      v5 = "//Metal1.0     \n"
           "//LEN=0000000228\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
           "    const constant float4* hg_Params [[ buffer(0) ]], \n"
           "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
           "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    float4 r0;\n"
           "    FragmentOut output;\n"
           "\n"
           "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    output.color0 = r0*hg_Params[0];\n"
           "    return output;\n"
           "}\n"
           "//MD5=6eae314a:ee581af3:fdfce447:74b07bd6\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    v5 = 0;
  }
  else
  {
    v5 = "//GLfs2.0      \n"
         "//LEN=00000001f6\n"
         "#ifndef GL_ES\n"
         "#define lowp\n"
         "#define mediump\n"
         "#define highp\n"
         "#endif\n"
         "#define defaultp mediump\n"
         "uniform defaultp sampler2D hg_Texture0;\n"
         "uniform defaultp vec4 hg_ProgramLocal0;\n"
         "varying highp vec4 hg_TexCoord0;\n"
         "void main()\n"
         "{\n"
         "    defaultp vec4 r0;\n"
         "\n"
         "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
         "    gl_FragColor = r0*hg_ProgramLocal0;\n"
         "}\n"
         "//MD5=78149511:5c47b7fc:9d3dfb0a:c601ba4b\n"
         "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
  (*(void (**)(HGRenderer *, uint64_t, uint64_t))(*(_QWORD *)a2 + 120))(a2, 32, v3);
  return v5;
}

double HGHWBlendFlipped::State::State(HGHWBlendFlipped::State *this)
{
  __int128 v6;
  double result;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  __asm { FMOV            V1.4S, #1.0 }
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = _Q1;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_OWORD *)this + 5) = xmmword_1B3050F70;
  *((int32x4_t *)this + 6) = vdupq_n_s32(0x358637BDu);
  *((int32x4_t *)this + 7) = vdupq_n_s32(0x3F804020u);
  *((_OWORD *)this + 8) = xmmword_1B3051600;
  *((_OWORD *)this + 9) = xmmword_1B3051610;
  *((int32x4_t *)this + 10) = vdupq_n_s32(0x7F800000u);
  *((_OWORD *)this + 11) = xmmword_1B3051630;
  *((_OWORD *)this + 12) = xmmword_1B3051640;
  *((_OWORD *)this + 13) = xmmword_1B3051510;
  *((_OWORD *)this + 14) = xmmword_1B3051650;
  *((_OWORD *)this + 15) = xmmword_1B3051660;
  *((_OWORD *)this + 16) = xmmword_1B3051670;
  *((_OWORD *)this + 17) = xmmword_1B3051680;
  *((_OWORD *)this + 18) = xmmword_1B3051690;
  *((_OWORD *)this + 19) = xmmword_1B30516A0;
  *((_OWORD *)this + 20) = xmmword_1B30516B0;
  *((_OWORD *)this + 21) = xmmword_1B30516C0;
  *((_OWORD *)this + 22) = xmmword_1B30516D0;
  *((_OWORD *)this + 23) = xmmword_1B3525AF0;
  *((_OWORD *)this + 24) = xmmword_1B3525D60;
  *((_OWORD *)this + 25) = xmmword_1B3058FA0;
  *((_OWORD *)this + 26) = xmmword_1B3525D70;
  *((_OWORD *)this + 27) = xmmword_1B3052320;
  *((int32x4_t *)this + 28) = vdupq_n_s32(0x7F7FFFFFu);
  *((_OWORD *)this + 29) = xmmword_1B3525D80;
  *((_OWORD *)this + 30) = xmmword_1B3525D90;
  *((_OWORD *)this + 31) = xmmword_1B30514E0;
  *((_OWORD *)this + 32) = xmmword_1B304EFF0;
  *(_QWORD *)&_Q1 = 0x3F0000003FLL;
  *((_QWORD *)&_Q1 + 1) = 0x3F0000003FLL;
  *((_OWORD *)this + 33) = xmmword_1B3525920;
  *((_OWORD *)this + 34) = _Q1;
  *((_OWORD *)this + 35) = xmmword_1B3525930;
  *((_OWORD *)this + 36) = xmmword_1B3525940;
  *((_OWORD *)this + 37) = xmmword_1B3525950;
  *((_OWORD *)this + 38) = xmmword_1B3525960;
  *((_OWORD *)this + 39) = xmmword_1B3525970;
  *((_OWORD *)this + 40) = xmmword_1B3525980;
  *((_OWORD *)this + 41) = xmmword_1B3525990;
  *((_OWORD *)this + 42) = xmmword_1B35259A0;
  *((_OWORD *)this + 43) = xmmword_1B35259B0;
  *((_OWORD *)this + 44) = xmmword_1B35259C0;
  *((_OWORD *)this + 45) = xmmword_1B35259D0;
  *((_OWORD *)this + 46) = xmmword_1B35259E0;
  *((_OWORD *)this + 47) = xmmword_1B35259F0;
  *((_OWORD *)this + 48) = xmmword_1B3525A00;
  *((_OWORD *)this + 49) = xmmword_1B3525A10;
  *((_OWORD *)this + 50) = xmmword_1B3525A20;
  *((_OWORD *)this + 51) = xmmword_1B3525A30;
  *((_OWORD *)this + 52) = xmmword_1B3525A40;
  *((_OWORD *)this + 53) = xmmword_1B3525DA0;
  *((_OWORD *)this + 54) = xmmword_1B3525A60;
  *((_OWORD *)this + 55) = xmmword_1B3525DB0;
  *((_OWORD *)this + 56) = xmmword_1B3525DC0;
  *((_OWORD *)this + 57) = xmmword_1B3051570;
  *((_OWORD *)this + 58) = xmmword_1B3052960;
  *((_OWORD *)this + 59) = xmmword_1B3525DD0;
  *((_OWORD *)this + 60) = xmmword_1B3525DE0;
  *((_OWORD *)this + 61) = xmmword_1B3525DF0;
  *((_OWORD *)this + 62) = xmmword_1B3525E00;
  *((_OWORD *)this + 63) = xmmword_1B3053570;
  *((_OWORD *)this + 64) = xmmword_1B3525860;
  *((_OWORD *)this + 65) = xmmword_1B3525870;
  *((_OWORD *)this + 66) = xmmword_1B3525880;
  *((_OWORD *)this + 67) = xmmword_1B3525890;
  *((_OWORD *)this + 68) = xmmword_1B35258A0;
  *((_OWORD *)this + 69) = xmmword_1B35258B0;
  *((_OWORD *)this + 70) = xmmword_1B35258C0;
  *((_OWORD *)this + 71) = xmmword_1B35258D0;
  *((_OWORD *)this + 72) = xmmword_1B35258E0;
  *((_OWORD *)this + 73) = xmmword_1B35258F0;
  *((_OWORD *)this + 74) = xmmword_1B3525900;
  *((_OWORD *)this + 75) = xmmword_1B3525E10;
  *((_OWORD *)this + 76) = xmmword_1B3525E20;
  *((_OWORD *)this + 77) = xmmword_1B3525E30;
  *((_OWORD *)this + 78) = xmmword_1B351FBB0;
  *((_OWORD *)this + 79) = xmmword_1B3525E40;
  *((_OWORD *)this + 80) = xmmword_1B3525E50;
  *((_OWORD *)this + 81) = xmmword_1B3525E60;
  *((_OWORD *)this + 82) = xmmword_1B3525E70;
  *((_OWORD *)this + 83) = xmmword_1B3525E80;
  *((_OWORD *)this + 84) = xmmword_1B351FB30;
  *((_OWORD *)this + 85) = xmmword_1B3525E90;
  *((_OWORD *)this + 86) = xmmword_1B3525EA0;
  *(_QWORD *)&v6 = 0xC0000000C0000000;
  *((_QWORD *)&v6 + 1) = 0xC0000000C0000000;
  *((_OWORD *)this + 87) = v6;
  result = 0.0000878906136;
  *((_OWORD *)this + 88) = xmmword_1B3525EB0;
  return result;
}

uint64_t GetBlendNormalTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  float32x4_t v45;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v39 = 0;
        v40 = 16 * v10;
        v41 = 16 * v9;
        v42 = 16 * v8;
        v43 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v44 = 0;
          do
          {
            v45 = vmulq_f32(v6[v44 / 0x10], *a2);
            v7[v44 / 0x10] = vaddq_f32(v45, vmulq_f32(v5[v44 / 0x10], vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 3))));
            v44 += 16;
          }
          while (v43 != v44);
          ++v39;
          v5 = (float32x4_t *)((char *)v5 + v40);
          v6 = (float32x4_t *)((char *)v6 + v41);
          v7 = (float32x4_t *)((char *)v7 + v42);
        }
        while (v39 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = vmulq_f32(v6[v18], *a2);
          v27 = vmulq_f32(v6[v18 + 1], *a2);
          v28 = vmulq_f32(v6[v18 + 2], *a2);
          v29 = vmulq_f32(v6[v18 + 3], *a2);
          v30 = a2[3];
          v31 = vaddq_f32(v27, vmulq_f32(v5[v18 + 1], vsubq_f32(v30, (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3))));
          v32 = vaddq_f32(v28, vmulq_f32(v5[v18 + 2], vsubq_f32(v30, (float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3))));
          v33 = vaddq_f32(v29, vmulq_f32(v5[v18 + 3], vsubq_f32(v30, (float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 3))));
          v34 = &v7[v18];
          *v34 = vaddq_f32(v26, vmulq_f32(v5[v18], vsubq_f32(v30, (float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3))));
          v34[1] = v31;
          v19 += 4;
          v18 += 4;
          v34[2] = v32;
          v34[3] = v33;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v35 = *v23++;
            v36 = v35;
            v37 = *v24++;
            v38 = vmulq_f32(v37, *a2);
            *v25++ = vaddq_f32(v38, vmulq_f32(v36, vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 3))));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendSubtractTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t *v42;
  float32x4_t *v43;
  float32x4_t *v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t v50;
  int8x16_t v51;
  float32x4_t *v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v60 = 0;
        v61 = 16 * v10;
        v62 = 16 * v9;
        v63 = 16 * v8;
        v64 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v65 = 0;
          do
          {
            v66 = v5[v65 / 0x10];
            v67 = vmulq_f32(v6[v65 / 0x10], *(float32x4_t *)a2);
            v68 = vmulq_laneq_f32(v67, v66, 3);
            v69 = vmulq_laneq_f32(v66, v67, 3);
            v70 = vsubq_f32(vaddq_f32(v66, v67), v68);
            v7[v65 / 0x10] = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v69, v68), *((float32x4_t *)a2 + 4)), *((float32x4_t *)a2 + 3)), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v70, (int8x16_t)vsubq_f32(v70, v69)));
            v65 += 16;
          }
          while (v64 != v65);
          ++v60;
          v5 = (float32x4_t *)((char *)v5 + v61);
          v6 = (float32x4_t *)((char *)v6 + v62);
          v7 = (float32x4_t *)((char *)v7 + v63);
        }
        while (v60 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v5[v18];
          v24 = v5[v18 + 1];
          v25 = v5[v18 + 2];
          v26 = v5[v18 + 3];
          v27 = vmulq_f32(v6[v18], *(float32x4_t *)a2);
          v28 = vmulq_f32(v6[v18 + 1], *(float32x4_t *)a2);
          v29 = vmulq_f32(v6[v18 + 2], *(float32x4_t *)a2);
          v30 = vmulq_f32(v6[v18 + 3], *(float32x4_t *)a2);
          v31 = vmulq_laneq_f32(v27, v23, 3);
          v32 = vmulq_laneq_f32(v28, v24, 3);
          v33 = vmulq_laneq_f32(v29, v25, 3);
          v34 = vmulq_laneq_f32(v30, v26, 3);
          v35 = vmulq_laneq_f32(v23, v27, 3);
          v36 = vmulq_laneq_f32(v24, v28, 3);
          v37 = vmulq_laneq_f32(v25, v29, 3);
          v38 = vmulq_laneq_f32(v26, v30, 3);
          v39 = vaddq_f32(v23, v27);
          v41 = *((float32x4_t *)a2 + 3);
          v40 = *((float32x4_t *)a2 + 4);
          v42 = v22;
          v43 = v21;
          v44 = v20;
          v45 = vminq_f32(vmaxq_f32(vsubq_f32(v35, v31), v40), v41);
          v46 = vsubq_f32(v39, v31);
          v47 = vsubq_f32(vaddq_f32(v24, v28), v32);
          v48 = vsubq_f32(vaddq_f32(v25, v29), v33);
          v49 = vsubq_f32(vaddq_f32(v26, v30), v34);
          v50 = (int8x16_t)vsubq_f32(v46, v35);
          v51 = *((int8x16_t *)a2 + 5);
          v52 = &v7[v18];
          *v52 = vaddq_f32(v45, (float32x4_t)vbslq_s8(v51, (int8x16_t)v46, v50));
          v52[1] = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v36, v32), v40), v41), (float32x4_t)vbslq_s8(v51, (int8x16_t)v47, (int8x16_t)vsubq_f32(v47, v36)));
          v19 += 4;
          v18 += 4;
          v52[2] = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v37, v33), v40), v41), (float32x4_t)vbslq_s8(v51, (int8x16_t)v48, (int8x16_t)vsubq_f32(v48, v37)));
          v52[3] = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v38, v34), v40), v41), (float32x4_t)vbslq_s8(v51, (int8x16_t)v49, (int8x16_t)vsubq_f32(v49, v38)));
          v22 = v42 + 4;
          v21 += 4;
          v20 += 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v53 = *v42++;
            v54 = v53;
            v55 = *v43++;
            v56 = vmulq_f32(v55, *(float32x4_t *)a2);
            v57 = vmulq_laneq_f32(v56, v54, 3);
            v58 = vmulq_laneq_f32(v54, v56, 3);
            v59 = vsubq_f32(vaddq_f32(v54, v56), v57);
            *v44++ = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v58, v57), *((float32x4_t *)a2 + 4)), *((float32x4_t *)a2 + 3)), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v59, (int8x16_t)vsubq_f32(v59, v58)));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendSubtractPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = *((float32x4_t *)a2 + 7);
        v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v17 = vmulq_f32(vrecpeq_f32(v16), v15);
        v18 = vmulq_f32(v13, vmulq_f32(v17, vrecpsq_f32(v17, v16)));
        v19 = *((float32x4_t *)a2 + 4);
        v20 = vmaxq_f32(v18, v19);
        v21 = *((int8x16_t *)a2 + 8);
        v22 = *((float32x4_t *)a2 + 9);
        v23 = *((float32x4_t *)a2 + 3);
        v24 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v20), (int8x16_t)v23);
        v25 = *((int8x16_t *)a2 + 10);
        v26 = *((float32x4_t *)a2 + 11);
        v27 = *((float32x4_t *)a2 + 12);
        v28 = *((float32x4_t *)a2 + 13);
        v29 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v24, v27));
        v30 = vsubq_f32(vsubq_f32(v24, v23), vmulq_f32(vmulq_f32(v28, v29), v24));
        v31 = *((float32x4_t *)a2 + 14);
        v32 = *((float32x4_t *)a2 + 15);
        v33 = *((float32x4_t *)a2 + 16);
        v34 = *((float32x4_t *)a2 + 17);
        v35 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v22, v20))), v26), v29), vmulq_f32(v30, vaddq_f32(vaddq_f32(v33, vmulq_f32(v30, v34)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(v31, vmulq_f32(v32, v30))))));
        v36 = *((float32x4_t *)a2 + 1);
        v37 = *((float32x4_t *)a2 + 18);
        v38 = *((float32x4_t *)a2 + 19);
        v39 = vmaxq_f32(vmulq_f32(v36, v35), v37);
        v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        v41 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v40, v39)));
        v42 = vsubq_f32(v39, v41);
        v43 = *((float32x4_t *)a2 + 20);
        v44 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v46 = vmulq_f32(vaddq_f32(v23, vmulq_f32(v42, vaddq_f32(v44, vmulq_f32(v42, vaddq_f32(v38, vmulq_f32(v43, v42)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v41)), 0x17uLL));
        v47 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v48 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), v14);
        v49 = vmulq_f32(v15, vrecpeq_f32(v48));
        v50 = vmulq_f32(v47, vmulq_f32(v49, vrecpsq_f32(v49, v48)));
        v51 = vmaxq_f32(v50, v19);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v51), (int8x16_t)v23);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v52, v27));
        v54 = vsubq_f32(vsubq_f32(v52, v23), vmulq_f32(vmulq_f32(v28, v53), v52));
        v55 = vmaxq_f32(vmulq_f32(v36, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v22, v51))), v26), v53), vmulq_f32(v54, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v54)), vmulq_f32(vmulq_f32(v54, v54), vaddq_f32(v31, vmulq_f32(v32, v54))))))), v37);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        v59 = vminq_f32(vmaxq_f32(vsubq_f32(v46, vmulq_f32(vaddq_f32(v23, vmulq_f32(v58, vaddq_f32(v44, vmulq_f32(v58, vaddq_f32(v38, vmulq_f32(v43, v58)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v45), 0x17uLL))), v19), v23);
        v60 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v59), (int8x16_t)v23);
        v61 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v60, v27));
        v62 = vsubq_f32(vsubq_f32(v60, v23), vmulq_f32(vmulq_f32(v28, v61), v60));
        v63 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v59, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v22, v59))), v26), v61), vmulq_f32(v62, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v62)), vmulq_f32(vmulq_f32(v62, v62), vaddq_f32(v31, vmulq_f32(v32, v62))))))), v37);
        v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
        v65 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v64, v63)));
        v66 = vsubq_f32(v63, v65);
        v67 = vmulq_f32(vaddq_f32(v23, vmulq_f32(v66, vaddq_f32(v44, vmulq_f32(v66, vaddq_f32(v38, vmulq_f32(v43, v66)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v65), v45), 0x17uLL));
        v67.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v67, (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(vsubq_f32(v67, v50), v13, 3))), v13), v47, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendSubtractQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v16 = *((float32x4_t *)a2 + 7);
        v17 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v16);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 3);
        v21 = *((float32x4_t *)a2 + 4);
        v22 = *((float32x4_t *)a2 + 23);
        v23 = *((float32x4_t *)a2 + 24);
        v24 = vminq_f32(vmaxq_f32(v19, v21), v22);
        v25 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v24), (int8x16_t)v20);
        v26 = *((float32x4_t *)a2 + 9);
        v27 = *((int8x16_t *)a2 + 10);
        v28 = *((float32x4_t *)a2 + 11);
        v29 = *((float32x4_t *)a2 + 12);
        v30 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v25, v29));
        v31 = *((float32x4_t *)a2 + 13);
        v32 = *((float32x4_t *)a2 + 14);
        v33 = vsubq_f32(vsubq_f32(v25, v20), vmulq_f32(vmulq_f32(v31, v30), v25));
        v34 = *((float32x4_t *)a2 + 15);
        v35 = *((float32x4_t *)a2 + 16);
        v36 = *((float32x4_t *)a2 + 17);
        v37 = *((float32x4_t *)a2 + 18);
        v38 = vmaxq_f32(vmulq_f32(v23, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v24))), v28), v30), vmulq_f32(v33, vaddq_f32(vaddq_f32(v35, vmulq_f32(v33, v36)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v32, vmulq_f32(v34, v33))))))), v37);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *((float32x4_t *)a2 + 19);
        v43 = *((float32x4_t *)a2 + 20);
        v44 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v46 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v41, vaddq_f32(v44, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v40)), 0x17uLL));
        v47 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v48 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), v14);
        v49 = vmulq_f32(v16, vrecpeq_f32(v48));
        v50 = vmulq_f32(v47, vmulq_f32(v49, vrecpsq_f32(v49, v48)));
        v51 = vminq_f32(vmaxq_f32(v50, v21), v22);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v51), (int8x16_t)v20);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v52, v29));
        v54 = vsubq_f32(vsubq_f32(v52, v20), vmulq_f32(vmulq_f32(v31, v53), v52));
        v55 = vmaxq_f32(vmulq_f32(v23, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v51))), v28), v53), vmulq_f32(v54, vaddq_f32(vaddq_f32(v35, vmulq_f32(v36, v54)), vmulq_f32(vmulq_f32(v54, v54), vaddq_f32(v32, vmulq_f32(v34, v54))))))), v37);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        v59 = vminq_f32(vmaxq_f32(vsubq_f32(v46, vmulq_f32(vaddq_f32(v20, vmulq_f32(v58, vaddq_f32(v44, vmulq_f32(v58, vaddq_f32(v42, vmulq_f32(v43, v58)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v45), 0x17uLL))), v21), v20);
        v60 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v59), (int8x16_t)v20);
        v61 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v60, v29));
        v62 = vsubq_f32(vsubq_f32(v60, v20), vmulq_f32(vmulq_f32(v31, v61), v60));
        v63 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v59, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v59))), v28), v61), vmulq_f32(v62, vaddq_f32(vaddq_f32(v35, vmulq_f32(v36, v62)), vmulq_f32(vmulq_f32(v62, v62), vaddq_f32(v32, vmulq_f32(v34, v62))))))), v37);
        v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
        v65 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v64, v63)));
        v66 = vsubq_f32(v63, v65);
        v67 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v66, vaddq_f32(v44, vmulq_f32(v66, vaddq_f32(v42, vmulq_f32(v43, v66)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v65), v45), 0x17uLL));
        v67.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v67, (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(vsubq_f32(v67, v50), v13, 3))), v13), v47, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendDarkenTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  uint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t *v26;
  int v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 3)
    {
      if ((int)v4 >= 1)
      {
        v47 = 0;
        v48 = 16 * v10;
        v49 = 16 * v9;
        v50 = 16 * v8;
        v51 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v52 = 0;
          do
          {
            v53 = v5[v52 / 0x10];
            v54 = vmulq_f32(v6[v52 / 0x10], *a2);
            v55 = vmulq_laneq_f32(v54, v53, 3);
            v56 = vmulq_laneq_f32(v53, v54, 3);
            v7[v52 / 0x10] = vaddq_f32(vminq_f32(v55, v56), vsubq_f32(vsubq_f32(vaddq_f32(v53, v54), v55), v56));
            v52 += 16;
          }
          while (v51 != v52);
          ++v47;
          v5 = (float32x4_t *)((char *)v5 + v48);
          v6 = (float32x4_t *)((char *)v6 + v49);
          v7 = (float32x4_t *)((char *)v7 + v50);
        }
        while (v47 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 3;
      v16 = v6 + 3;
      v17 = v7 + 3;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = 3;
        v21 = v17;
        v22 = v16;
        v23 = v15;
        do
        {
          v24 = v23;
          v25 = v22;
          v26 = v21;
          v27 = v20;
          v28 = v5[v18];
          v29 = v5[v18 + 1];
          v30 = v5[v18 + 2];
          v31 = vmulq_f32(v6[v18], *a2);
          v32 = vmulq_f32(v6[v18 + 1], *a2);
          v33 = vmulq_f32(v6[v18 + 2], *a2);
          v34 = vmulq_laneq_f32(v31, v28, 3);
          v35 = vmulq_laneq_f32(v32, v29, 3);
          v36 = vmulq_laneq_f32(v33, v30, 3);
          v37 = vmulq_laneq_f32(v28, v31, 3);
          v38 = vmulq_laneq_f32(v29, v32, 3);
          v39 = vmulq_laneq_f32(v30, v33, 3);
          v40 = &v7[v18];
          v19 += 3;
          v18 += 3;
          v23 += 3;
          *v40 = vaddq_f32(vminq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v40[1] = vaddq_f32(vminq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v40[2] = vaddq_f32(vminq_f32(v36, v39), vsubq_f32(vsubq_f32(vaddq_f32(v30, v33), v36), v39));
          v22 += 3;
          v21 += 3;
          v20 = v27 + 3;
        }
        while (v19 < v4 - 2);
        if ((int)v4 > (int)v19)
        {
          do
          {
            v41 = *v24++;
            v42 = v41;
            v43 = *v25++;
            v44 = vmulq_f32(v43, *a2);
            v45 = vmulq_laneq_f32(v44, v42, 3);
            v46 = vmulq_laneq_f32(v42, v44, 3);
            *v26++ = vaddq_f32(vminq_f32(v45, v46), vsubq_f32(vsubq_f32(vaddq_f32(v42, v44), v45), v46));
            ++v27;
          }
          while ((int)v4 > v27);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendMultiplyTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  float32x4_t v44;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v38 = 0;
        v39 = 16 * v10;
        v40 = 16 * v9;
        v41 = 16 * v8;
        v42 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v43 = 0;
          do
          {
            v44 = vmulq_f32(v6[v43 / 0x10], *a2);
            v7[v43 / 0x10] = vaddq_f32(vaddq_f32(vmulq_f32(v5[v43 / 0x10], v44), vsubq_f32(v44, vmulq_laneq_f32(v44, v5[v43 / 0x10], 3))), vsubq_f32(v5[v43 / 0x10], vmulq_laneq_f32(v5[v43 / 0x10], v44, 3)));
            v43 += 16;
          }
          while (v42 != v43);
          ++v38;
          v5 = (float32x4_t *)((char *)v5 + v39);
          v6 = (float32x4_t *)((char *)v6 + v40);
          v7 = (float32x4_t *)((char *)v7 + v41);
        }
        while (v38 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = vmulq_f32(v6[v18], *a2);
          v27 = vmulq_f32(v6[v18 + 1], *a2);
          v28 = vmulq_f32(v6[v18 + 2], *a2);
          v29 = vmulq_f32(v6[v18 + 3], *a2);
          v30 = vaddq_f32(vaddq_f32(vmulq_f32(v5[v18 + 1], v27), vsubq_f32(v27, vmulq_laneq_f32(v27, v5[v18 + 1], 3))), vsubq_f32(v5[v18 + 1], vmulq_laneq_f32(v5[v18 + 1], v27, 3)));
          v31 = vaddq_f32(vaddq_f32(vmulq_f32(v5[v18 + 2], v28), vsubq_f32(v28, vmulq_laneq_f32(v28, v5[v18 + 2], 3))), vsubq_f32(v5[v18 + 2], vmulq_laneq_f32(v5[v18 + 2], v28, 3)));
          v32 = vaddq_f32(vaddq_f32(vmulq_f32(v5[v18 + 3], v29), vsubq_f32(v29, vmulq_laneq_f32(v29, v5[v18 + 3], 3))), vsubq_f32(v5[v18 + 3], vmulq_laneq_f32(v5[v18 + 3], v29, 3)));
          v33 = &v7[v18];
          *v33 = vaddq_f32(vaddq_f32(vmulq_f32(v5[v18], v26), vsubq_f32(v26, vmulq_laneq_f32(v26, v5[v18], 3))), vsubq_f32(v5[v18], vmulq_laneq_f32(v5[v18], v26, 3)));
          v33[1] = v30;
          v19 += 4;
          v18 += 4;
          v33[2] = v31;
          v33[3] = v32;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v34 = *v23++;
            v35 = v34;
            v36 = *v24++;
            v37 = vmulq_f32(v36, *a2);
            *v25++ = vaddq_f32(vaddq_f32(vmulq_f32(v35, v37), vsubq_f32(v37, vmulq_laneq_f32(v37, v35, 3))), vsubq_f32(v35, vmulq_laneq_f32(v35, v37, 3)));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendColorBurnTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int8x16_t v53;
  int32x4_t v54;
  int32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t *v58;
  int v59;
  uint64_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int32x4_t v80;
  float32x4_t v81;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v59 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *a2);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13), *a2);
      v16 = *(float32x4_t *)(v7 + v13 - 16);
      v17 = *(float32x4_t *)(v7 + v13);
      v18 = (int8x16_t)a2[5];
      v19 = a2[6];
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v19);
      v21 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v19);
      v22 = a2[7];
      v23 = vmulq_f32(vrecpeq_f32(v20), v22);
      v24 = vmulq_f32(vrecpeq_f32(v21), v22);
      v25 = vmulq_f32(v23, vrecpsq_f32(v23, v20));
      v26 = vmulq_f32(v24, vrecpsq_f32(v24, v21));
      v27 = vmulq_f32(v14, v25);
      v28 = vmulq_f32(v15, v26);
      v29 = a2[26];
      v30 = a2[27];
      v31 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v14, (int8x16_t)vmaxq_f32(v27, v29));
      v32 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v15, (int8x16_t)vmaxq_f32(v28, v29));
      v33 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v19);
      v34 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 3), v19);
      v35 = vmulq_f32(v22, vrecpeq_f32(v33));
      v36 = vmulq_f32(v22, vrecpeq_f32(v34));
      v37 = vmulq_f32(v16, vmulq_f32(v35, vrecpsq_f32(v35, v33)));
      v38 = vmulq_f32(v17, vmulq_f32(v36, vrecpsq_f32(v36, v34)));
      v40 = a2[3];
      v39 = a2[4];
      v41 = (float32x4_t)vandq_s8((int8x16_t)v40, (int8x16_t)vceqq_f32(v27, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v40, (int8x16_t)vceqq_f32(v37, v40));
      v43 = (float32x4_t)vandq_s8((int8x16_t)v40, (int8x16_t)vceqq_f32(v38, v40));
      v44 = vsubq_f32(v40, v37);
      v45 = (float32x4_t)vandq_s8((int8x16_t)v40, (int8x16_t)vceqq_f32(v28, v39));
      v46 = vsubq_f32(v40, v38);
      v47 = vmaxq_f32(vmulq_f32(v22, vrecpeq_f32(v31)), v30);
      v48 = vmaxq_f32(vmulq_f32(v22, vrecpeq_f32(v32)), v30);
      v49 = a2[28];
      v50 = a2[29];
      v51 = vminq_f32(v47, v49);
      v52 = vminq_f32(v48, v49);
      v53 = (int8x16_t)vmulq_f32(v46, vmulq_f32(v52, vrecpsq_f32(v32, v52)));
      v54 = (int32x4_t)vbslq_s8(v18, (int8x16_t)v14, (int8x16_t)vmulq_f32(vsubq_f32(v50, (float32x4_t)vbslq_s8(v18, (int8x16_t)v14, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v14, (int8x16_t)vmulq_f32(v44, vmulq_f32(v51, vrecpsq_f32(v31, v51)))), v50))), (float32x4_t)vbslq_s8(
                                                     v18,
                                                     (int8x16_t)v14,
                                                     vandq_s8((int8x16_t)v50, (int8x16_t)vcgtq_f32(v27, v39)))));
      v55 = (int32x4_t)vbslq_s8(v18, (int8x16_t)v15, (int8x16_t)vmulq_f32(vsubq_f32(v50, (float32x4_t)vbslq_s8(v18, (int8x16_t)v15, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v15, v53), v50))), (float32x4_t)vbslq_s8(v18, (int8x16_t)v15, vandq_s8((int8x16_t)v50, (int8x16_t)vcgtq_f32(v28, v39)))));
      v27.i32[3] = 1.0;
      v56 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v14, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v41, v42), v39), (int8x16_t)v50, vbslq_s8(v18, (int8x16_t)v14, vbslq_s8((int8x16_t)vcgtq_f32(v41, v39), (int8x16_t)v39, vbslq_s8(v18, (int8x16_t)v14, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v54, 3), v39), (int8x16_t)v54, (int8x16_t)v39))))));
      v57 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v15, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v45, v43), v39), (int8x16_t)v50, vbslq_s8(v18, (int8x16_t)v15, vbslq_s8((int8x16_t)vcgtq_f32(v45, v39), (int8x16_t)v39, vbslq_s8(v18, (int8x16_t)v15, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v55, 3), v39), (int8x16_t)v55, (int8x16_t)v39))))));
      v28.i32[3] = 1.0;
      v58 = (float32x4_t *)(v6 + v13);
      v58[-1] = vaddq_f32(v16, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v27, (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(vsubq_f32(v56, v27), v16, 3))), v16), v56, 3));
      *v58 = vaddq_f32(v17, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v28, (int8x16_t)vaddq_f32(v28, vmulq_laneq_f32(vsubq_f32(v57, v28), v17, 3))), v17), v57, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v59 = -v12;
    if (v59 >= v5)
      goto LABEL_3;
LABEL_10:
    v60 = 16 * v59;
    v61 = *(float32x4_t *)(v7 + v60);
    v62 = vmulq_f32(*(float32x4_t *)(v8 + v60), *a2);
    v64 = (int8x16_t)a2[5];
    v63 = a2[6];
    v65 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v62, 3), v63);
    v66 = a2[7];
    v67 = vmulq_f32(vrecpeq_f32(v65), v66);
    v68 = vmulq_f32(v62, vmulq_f32(v67, vrecpsq_f32(v67, v65)));
    v69 = (float32x4_t)vbslq_s8(v64, (int8x16_t)v62, (int8x16_t)vmaxq_f32(v68, a2[26]));
    v70 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 3), v63);
    v71 = vmulq_f32(v66, vrecpeq_f32(v70));
    v72 = vmulq_f32(v61, vmulq_f32(v71, vrecpsq_f32(v71, v70)));
    v74 = a2[3];
    v73 = a2[4];
    v75 = (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vceqq_f32(v68, v73));
    v76 = (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vceqq_f32(v72, v74));
    v77 = vsubq_f32(v74, v72);
    v78 = a2[29];
    v79 = vminq_f32(vmaxq_f32(vmulq_f32(v66, vrecpeq_f32(v69)), a2[27]), a2[28]);
    v80 = (int32x4_t)vbslq_s8(v64, (int8x16_t)v62, (int8x16_t)vmulq_f32(vsubq_f32(v78, (float32x4_t)vbslq_s8(v64, (int8x16_t)v62, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v64, (int8x16_t)v62, (int8x16_t)vmulq_f32(v77, vmulq_f32(v79, vrecpsq_f32(v69, v79)))), v78))), (float32x4_t)vbslq_s8(
                                                   v64,
                                                   (int8x16_t)v62,
                                                   vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v68, v73)))));
    v81 = (float32x4_t)vbslq_s8(v64, (int8x16_t)v62, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v75, v76), v73), (int8x16_t)v78, vbslq_s8(v64, (int8x16_t)v62, vbslq_s8((int8x16_t)vcgtq_f32(v75, v73), (int8x16_t)v73, vbslq_s8(v64, (int8x16_t)v62, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v80, 3), v73), (int8x16_t)v80, (int8x16_t)v73))))));
    v68.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v60) = vaddq_f32(v61, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v64, (int8x16_t)v68, (int8x16_t)vaddq_f32(v68, vmulq_laneq_f32(vsubq_f32(v81, v68), v61, 3))), v61), v81, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendColorBurnPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v15 = *((float32x4_t *)a2 + 6);
        v14 = *((float32x4_t *)a2 + 7);
        v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
        v17 = vmulq_f32(vrecpeq_f32(v16), v14);
        v18 = vmulq_f32(v13, vmulq_f32(v17, vrecpsq_f32(v17, v16)));
        v19 = *((float32x4_t *)a2 + 4);
        v20 = *((int8x16_t *)a2 + 5);
        v21 = vmaxq_f32(v18, v19);
        v23 = *((int8x16_t *)a2 + 8);
        v22 = *((float32x4_t *)a2 + 9);
        v24 = *((float32x4_t *)a2 + 29);
        v25 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v21), (int8x16_t)v24);
        v27 = *((int8x16_t *)a2 + 10);
        v26 = *((float32x4_t *)a2 + 11);
        v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v22, v21))), v26);
        v30 = *((float32x4_t *)a2 + 12);
        v29 = *((float32x4_t *)a2 + 13);
        v31 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v30));
        v32 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v29, v31), v25));
        v33 = *((float32x4_t *)a2 + 14);
        v34 = *((float32x4_t *)a2 + 15);
        v35 = *((float32x4_t *)a2 + 16);
        v36 = *((float32x4_t *)a2 + 17);
        v37 = vaddq_f32(vaddq_f32(v28, v31), vmulq_f32(v32, vaddq_f32(vaddq_f32(v35, vmulq_f32(v32, v36)), vmulq_f32(vmulq_f32(v32, v32), vaddq_f32(v33, vmulq_f32(v34, v32))))));
        v38 = *((float32x4_t *)a2 + 1);
        v39 = vmulq_f32(v38, v37);
        v41 = *((float32x4_t *)a2 + 18);
        v40 = *((float32x4_t *)a2 + 19);
        v42 = vmaxq_f32(v39, v41);
        v43 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
        v44 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v43, v42)));
        v45 = vsubq_f32(v42, v44);
        v46 = *((float32x4_t *)a2 + 20);
        v47 = *((float32x4_t *)a2 + 21);
        v48 = *((int32x4_t *)a2 + 22);
        v49 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v45, vaddq_f32(v47, vmulq_f32(v45, vaddq_f32(v40, vmulq_f32(v46, v45)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v48, vcvtq_s32_f32(v44)), 0x17uLL));
        v50 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v51 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3), v15);
        v52 = vmulq_f32(v14, vrecpeq_f32(v51));
        v53 = vmaxq_f32(vmulq_f32(v50, vmulq_f32(v52, vrecpsq_f32(v52, v51))), v19);
        v54 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v53), (int8x16_t)v24);
        v55 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v54, v30));
        v56 = vsubq_f32(vsubq_f32(v54, v24), vmulq_f32(vmulq_f32(v29, v55), v54));
        v57 = vmaxq_f32(vmulq_f32(v38, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v53, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v22, v53))), v26), v55), vmulq_f32(v56, vaddq_f32(vaddq_f32(v35, vmulq_f32(v36, v56)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v33, vmulq_f32(v34, v56))))))), v41);
        v58 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
        v59 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v58, v57)));
        v60 = vsubq_f32(v57, v59);
        v61 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v50, (int8x16_t)vmulq_f32(vaddq_f32(v24, vmulq_f32(v60, vaddq_f32(v47, vmulq_f32(v60, vaddq_f32(v40, vmulq_f32(v46, v60)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v59), v48), 0x17uLL)));
        v62 = *((float32x4_t *)a2 + 26);
        v63 = vmaxq_f32(v61, v62);
        v64 = vminq_f32(vmaxq_f32(vmulq_f32(v14, vrecpeq_f32(v63)), *((float32x4_t *)a2 + 27)), *((float32x4_t *)a2 + 28));
        v65 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgeq_f32(v62, v61)), v19);
        v66 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v50, vorrq_s8(vandq_s8(vandq_s8((int8x16_t)v24, (int8x16_t)vcgeq_f32(v49, v24)), v65), vbicq_s8((int8x16_t)vsubq_f32(v24, vminq_f32(vmulq_f32(vsubq_f32(v24, v49), vmulq_f32(v64, vrecpsq_f32(v63, v64))), v24)), v65)));
        v67 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, v23), (int8x16_t)v24);
        v68 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v22, v66))), v26);
        v69 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v67, v30));
        v70 = vsubq_f32(vsubq_f32(v67, v24), vmulq_f32(vmulq_f32(v29, v69), v67));
        v71 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(v68, v69), vmulq_f32(v70, vaddq_f32(vaddq_f32(v35, vmulq_f32(v36, v70)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(v33, vmulq_f32(v34, v70))))))), v41);
        v72 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
        v73 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v72, v71)));
        v74 = vsubq_f32(v71, v73);
        v53.i32[3] = 1.0;
        v75 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v50, (int8x16_t)vmulq_f32(vaddq_f32(v24, vmulq_f32(v74, vaddq_f32(v47, vmulq_f32(v74, vaddq_f32(v40, vmulq_f32(v46, v74)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v73), v48), 0x17uLL)));
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v20, (int8x16_t)v53, (int8x16_t)vaddq_f32(v53, vmulq_laneq_f32(vsubq_f32(v75, v53), v13, 3))), v13), v75, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendColorBurnQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v15 = *((float32x4_t *)a2 + 6);
        v14 = *((float32x4_t *)a2 + 7);
        v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
        v17 = vmulq_f32(vrecpeq_f32(v16), v14);
        v18 = vmulq_f32(v13, vmulq_f32(v17, vrecpsq_f32(v17, v16)));
        v19 = *((float32x4_t *)a2 + 4);
        v20 = *((int8x16_t *)a2 + 5);
        v21 = vmaxq_f32(v18, v19);
        v22 = *((int32x4_t *)a2 + 22);
        v23 = *((float32x4_t *)a2 + 23);
        v24 = vminq_f32(v21, v23);
        v26 = *((int8x16_t *)a2 + 8);
        v25 = *((float32x4_t *)a2 + 9);
        v27 = *((float32x4_t *)a2 + 29);
        v28 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v24), (int8x16_t)v27);
        v30 = *((int8x16_t *)a2 + 10);
        v29 = *((float32x4_t *)a2 + 11);
        v31 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v25, v24))), v29);
        v33 = *((float32x4_t *)a2 + 12);
        v32 = *((float32x4_t *)a2 + 13);
        v34 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v28, v33));
        v35 = vaddq_f32(v31, v34);
        v36 = vsubq_f32(vsubq_f32(v28, v27), vmulq_f32(vmulq_f32(v32, v34), v28));
        v37 = *((float32x4_t *)a2 + 14);
        v38 = *((float32x4_t *)a2 + 15);
        v39 = *((float32x4_t *)a2 + 16);
        v40 = *((float32x4_t *)a2 + 17);
        v41 = vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v36, v40)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v37, vmulq_f32(v38, v36))))));
        v42 = *((float32x4_t *)a2 + 24);
        v43 = vmulq_f32(v42, v41);
        v44 = *((float32x4_t *)a2 + 18);
        v45 = *((float32x4_t *)a2 + 19);
        v46 = vmaxq_f32(v43, v44);
        v47 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
        v48 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v47, v46)));
        v49 = vsubq_f32(v46, v48);
        v50 = *((float32x4_t *)a2 + 20);
        v51 = *((float32x4_t *)a2 + 21);
        v52 = vmulq_f32(vaddq_f32(v27, vmulq_f32(v49, vaddq_f32(v51, vmulq_f32(v49, vaddq_f32(v45, vmulq_f32(v50, v49)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v22, vcvtq_s32_f32(v48)), 0x17uLL));
        v53 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v54 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3), v15);
        v55 = vmulq_f32(v14, vrecpeq_f32(v54));
        v56 = vmaxq_f32(vmulq_f32(v53, vmulq_f32(v55, vrecpsq_f32(v55, v54))), v19);
        v57 = vminq_f32(v56, v23);
        v58 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v57), (int8x16_t)v27);
        v59 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v58, v33));
        v60 = vsubq_f32(vsubq_f32(v58, v27), vmulq_f32(vmulq_f32(v32, v59), v58));
        v61 = vmaxq_f32(vmulq_f32(v42, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v57, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v25, v57))), v29), v59), vmulq_f32(v60, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v60)), vmulq_f32(vmulq_f32(v60, v60), vaddq_f32(v37, vmulq_f32(v38, v60))))))), v44);
        v62 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
        v63 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v62, v61)));
        v64 = vsubq_f32(v61, v63);
        v65 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v53, (int8x16_t)vmulq_f32(vaddq_f32(v27, vmulq_f32(v64, vaddq_f32(v51, vmulq_f32(v64, vaddq_f32(v45, vmulq_f32(v50, v64)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v63), v22), 0x17uLL)));
        v66 = *((float32x4_t *)a2 + 26);
        v67 = vmaxq_f32(v65, v66);
        v68 = vminq_f32(vmaxq_f32(vmulq_f32(v14, vrecpeq_f32(v67)), *((float32x4_t *)a2 + 27)), *((float32x4_t *)a2 + 28));
        v69 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgeq_f32(v66, v65)), v19);
        v70 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8(v20, (int8x16_t)v53, vorrq_s8(vandq_s8(vandq_s8((int8x16_t)v27, (int8x16_t)vcgeq_f32(v52, v27)), v69), vbicq_s8((int8x16_t)vsubq_f32(v27, vminq_f32(vmulq_f32(vsubq_f32(v27, v52), vmulq_f32(v68, vrecpsq_f32(v67, v68))), v27)), v69))), v19), *((float32x4_t *)a2 + 30));
        v71 = (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)v70), (int8x16_t)v27);
        v72 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v70, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v25, v70))), v29);
        v73 = (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v71, v33));
        v74 = vsubq_f32(vsubq_f32(v71, v27), vmulq_f32(vmulq_f32(v32, v73), v71));
        v75 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(v72, v73), vmulq_f32(v74, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v74)), vmulq_f32(vmulq_f32(v74, v74), vaddq_f32(v37, vmulq_f32(v38, v74))))))), v44);
        v76 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
        v77 = vsubq_f32(v76, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v76, v75)));
        v78 = vsubq_f32(v75, v77);
        v56.i32[3] = 1.0;
        v79 = (float32x4_t)vbslq_s8(v20, (int8x16_t)v53, (int8x16_t)vmulq_f32(vaddq_f32(v27, vmulq_f32(v78, vaddq_f32(v51, vmulq_f32(v78, vaddq_f32(v45, vmulq_f32(v50, v78)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v77), v22), 0x17uLL)));
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v20, (int8x16_t)v56, (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(vsubq_f32(v79, v56), v13, 3))), v13), v79, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendLinearBurnTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  int v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t *v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if (v4 < 2)
    {
      if (v4 == 1)
      {
        v32 = 16 * v8;
        do
        {
          v33 = vmulq_f32(*v6, *a2);
          v34 = vmulq_laneq_f32(v33, *v5, 3);
          v35 = vmulq_laneq_f32(*v5, v33, 3);
          *v7 = vaddq_f32(vsubq_f32(vsubq_f32(vaddq_f32(*v5, v33), v34), v35), vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v34, v35), (float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(*v5, v33), 3)), a2[4]), a2[3]));
          v5 += v10;
          v6 += v9;
          v7 = (float32x4_t *)((char *)v7 + v32);
          --v3;
        }
        while (v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v8;
      v13 = 16 * v10;
      v14 = 16 * v9;
      do
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = v5[v15];
          v18 = v5[v15 + 1];
          v19 = vmulq_f32(v6[v15], *a2);
          v20 = vmulq_f32(v6[v15 + 1], *a2);
          v21 = vmulq_laneq_f32(v19, v17, 3);
          v22 = vmulq_laneq_f32(v20, v18, 3);
          v23 = vmulq_laneq_f32(v17, v19, 3);
          v24 = vmulq_laneq_f32(v18, v20, 3);
          v26 = a2[3];
          v25 = a2[4];
          v27 = &v7[v15];
          *v27 = vaddq_f32(vsubq_f32(vsubq_f32(vaddq_f32(v17, v19), v21), v23), vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v21, v23), (float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v17, v19), 3)), v25), v26));
          v27[1] = vaddq_f32(vsubq_f32(vsubq_f32(vaddq_f32(v18, v20), v22), v24), vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v22, v24), (float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v18, v20), 3)), v25), v26));
          v16 -= 2;
          v15 += 2;
        }
        while (v4 + v16 > 1);
        if (v4 > -v16)
        {
          v28 = v5[v15];
          v29 = vmulq_f32(v6[v15], *a2);
          v30 = vmulq_laneq_f32(v29, v28, 3);
          v31 = vmulq_laneq_f32(v28, v29, 3);
          v7[v15] = vaddq_f32(vsubq_f32(vsubq_f32(vaddq_f32(v28, v29), v30), v31), vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v30, v31), (float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v28, v29), 3)), a2[4]), a2[3]));
        }
        ++v11;
        v7 = (float32x4_t *)((char *)v7 + v12);
        v5 = (float32x4_t *)((char *)v5 + v13);
        v6 = (float32x4_t *)((char *)v6 + v14);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendLinearBurnPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;
  int8x16_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  float32x4_t v106;
  float32x4_t v107;
  int8x16_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t *v132;
  int v133;
  uint64_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  int8x16_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  int8x16_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  int32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v133 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v16 = *(float32x4_t *)(v8 + v14);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = *((float32x4_t *)a2 + 7);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v17);
      v21 = vmulq_f32(vrecpeq_f32(v19), v18);
      v22 = vmulq_f32(vrecpeq_f32(v20), v18);
      v23 = vmulq_f32(v21, vrecpsq_f32(v21, v19));
      v24 = vmulq_f32(v22, vrecpsq_f32(v22, v20));
      v25 = *((float32x4_t *)a2 + 4);
      v26 = *((int8x16_t *)a2 + 5);
      v27 = vmaxq_f32(vmulq_f32(v15, v23), v25);
      v28 = vmaxq_f32(vmulq_f32(v16, v24), v25);
      v29 = *((int8x16_t *)a2 + 8);
      v30 = *((float32x4_t *)a2 + 9);
      v31 = *((float32x4_t *)a2 + 29);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v27), (int8x16_t)v31);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v28), (int8x16_t)v31);
      v35 = *((int8x16_t *)a2 + 10);
      v34 = *((float32x4_t *)a2 + 11);
      v36 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v30, v27)));
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v30, v28)));
      v38 = *((float32x4_t *)a2 + 12);
      v39 = *((float32x4_t *)a2 + 13);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v32, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v33, v38));
      v42 = vaddq_f32(vsubq_f32(v36, v34), v40);
      v43 = vaddq_f32(vsubq_f32(v37, v34), v41);
      v44 = vsubq_f32(vsubq_f32(v32, v31), vmulq_f32(vmulq_f32(v39, v40), v32));
      v45 = vsubq_f32(vsubq_f32(v33, v31), vmulq_f32(vmulq_f32(v39, v41), v33));
      v46 = *((float32x4_t *)a2 + 14);
      v47 = *((float32x4_t *)a2 + 15);
      v48 = *((float32x4_t *)a2 + 16);
      v49 = *((float32x4_t *)a2 + 17);
      v50 = *((float32x4_t *)a2 + 1);
      v51 = vmulq_f32(v50, vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v48, vmulq_f32(v44, v49)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v46, vmulq_f32(v47, v44)))))));
      v52 = vmulq_f32(v50, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v48, vmulq_f32(v45, v49)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v46, vmulq_f32(v47, v45)))))));
      v54 = *((float32x4_t *)a2 + 18);
      v53 = *((float32x4_t *)a2 + 19);
      v55 = vmaxq_f32(v51, v54);
      v56 = vmaxq_f32(v52, v54);
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v60 = *((float32x4_t *)a2 + 20);
      v59 = *((float32x4_t *)a2 + 21);
      v61 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v62 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v63 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v57, v55)));
      v64 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 3), v17);
      v65 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v62, 3), v17);
      v66 = vmulq_f32(v18, vrecpeq_f32(v64));
      v67 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v58, v56)));
      v68 = vmulq_f32(v18, vrecpeq_f32(v65));
      v69 = (int8x16_t)vmulq_f32(v66, vrecpsq_f32(v66, v64));
      v70 = (int8x16_t)vmulq_f32(v68, vrecpsq_f32(v68, v65));
      v71 = vsubq_f32(v55, v63);
      v72 = *((int8x16_t *)a2 + 31);
      v73 = *((float32x4_t *)a2 + 32);
      v74 = vandq_s8(v72, v70);
      v75 = vmulq_f32(v61, (float32x4_t)vorrq_s8(vandq_s8(v72, v69), (int8x16_t)v73));
      v76 = vmulq_f32(v62, (float32x4_t)vorrq_s8(v74, (int8x16_t)v73));
      v77 = vmaxq_f32(v75, v73);
      v78 = vmaxq_f32(v76, v73);
      v79 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v77), (int8x16_t)v31);
      v80 = (float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)v78), (int8x16_t)v31);
      v81 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v77, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v30, v77)));
      v82 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v78, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v30, v78))), v34);
      v83 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v79, v38));
      v84 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v80, v38));
      v85 = vaddq_f32(vsubq_f32(v81, v34), v83);
      v86 = vaddq_f32(v82, v84);
      v87 = vsubq_f32(vsubq_f32(v79, v31), vmulq_f32(vmulq_f32(v39, v83), v79));
      v88 = vsubq_f32(vsubq_f32(v80, v31), vmulq_f32(vmulq_f32(v39, v84), v80));
      v89 = vsubq_f32(v56, v67);
      v90 = vaddq_f32(v85, vmulq_f32(v87, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v87)), vmulq_f32(vmulq_f32(v87, v87), vaddq_f32(v46, vmulq_f32(v47, v87))))));
      v91 = *((int32x4_t *)a2 + 22);
      v92 = vmulq_f32(v50, vaddq_f32(v86, vmulq_f32(v88, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v88)), vmulq_f32(vmulq_f32(v88, v88), vaddq_f32(v46, vmulq_f32(v47, v88)))))));
      v93 = vmaxq_f32(vmulq_f32(v50, v90), v54);
      v94 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v71, vaddq_f32(v59, vmulq_f32(v71, vaddq_f32(v53, vmulq_f32(v60, v71)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v91, vcvtq_s32_f32(v63)), 0x17uLL));
      v95 = vmaxq_f32(v92, v54);
      v96 = vcvtq_f32_s32(vcvtq_s32_f32(v93));
      v97 = vcvtq_f32_s32(vcvtq_s32_f32(v95));
      v98 = vsubq_f32(v96, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v96, v93)));
      v99 = vsubq_f32(v97, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v97, v95)));
      v100 = vsubq_f32(v93, v98);
      v101 = vsubq_f32(v95, v99);
      v102 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v89, vaddq_f32(v59, vmulq_f32(v89, vaddq_f32(v53, vmulq_f32(v60, v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v91, vcvtq_s32_f32(v67)), 0x17uLL));
      v12 = 1.0;
      v103 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v94, vmulq_f32(vaddq_f32(v31, vmulq_f32(v100, vaddq_f32(v59, vmulq_f32(v100, vaddq_f32(v53, vmulq_f32(v60, v100)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v98), v91), 0x17uLL))), v31), v73), v31);
      v104 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v102, vmulq_f32(vaddq_f32(v31, vmulq_f32(v101, vaddq_f32(v59, vmulq_f32(v101, vaddq_f32(v53, vmulq_f32(v60, v101)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v99), v91), 0x17uLL))), v31), v73), v31);
      v105 = (int8x16_t)vcgtq_f32(v30, v103);
      v106 = (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v30, v104));
      v107 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v103, 0x17uLL)), (float32x4_t)vandq_s8(v35, v105));
      v108 = vandq_s8(v29, (int8x16_t)v103);
      v109 = vandq_s8(v29, (int8x16_t)v104);
      v110 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v104, 0x17uLL)), v106);
      v111 = (float32x4_t)vorrq_s8(v108, (int8x16_t)v31);
      v112 = vsubq_f32(v107, v34);
      v113 = vsubq_f32(v110, v34);
      v114 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v111, v38));
      v115 = vaddq_f32(v112, v114);
      v116 = vsubq_f32(vsubq_f32(v111, v31), vmulq_f32(vmulq_f32(v39, v114), v111));
      v117 = (float32x4_t)vorrq_s8(v109, (int8x16_t)v31);
      v118 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v117, v38));
      v119 = vsubq_f32(vsubq_f32(v117, v31), vmulq_f32(vmulq_f32(v39, v118), v117));
      v120 = vaddq_f32(vaddq_f32(v113, v118), vmulq_f32(v119, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v119)), vmulq_f32(vmulq_f32(v119, v119), vaddq_f32(v46, vmulq_f32(v47, v119))))));
      v121 = *((float32x4_t *)a2 + 2);
      v122 = vmaxq_f32(vmulq_f32(v121, vaddq_f32(v115, vmulq_f32(v116, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v116)), vmulq_f32(vmulq_f32(v116, v116), vaddq_f32(v46, vmulq_f32(v47, v116))))))), v54);
      v123 = vmaxq_f32(vmulq_f32(v121, v120), v54);
      v124 = vcvtq_f32_s32(vcvtq_s32_f32(v122));
      v125 = vcvtq_f32_s32(vcvtq_s32_f32(v123));
      v126 = vsubq_f32(v124, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v124, v122)));
      v127 = vsubq_f32(v125, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v125, v123)));
      v128 = vsubq_f32(v122, v126);
      v129 = vsubq_f32(v123, v127);
      v130 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v128, vaddq_f32(v59, vmulq_f32(v128, vaddq_f32(v53, vmulq_f32(v60, v128)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v126), v91), 0x17uLL));
      v130.i32[3] = 1.0;
      v131 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v129, vaddq_f32(v59, vmulq_f32(v129, vaddq_f32(v53, vmulq_f32(v60, v129)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v127), v91), 0x17uLL));
      v131.i32[3] = 1.0;
      v132 = (float32x4_t *)(v6 + v14);
      v132[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v26, (int8x16_t)v130, (int8x16_t)vaddq_f32(v75, vmulq_laneq_f32(vsubq_f32(v130, v75), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v75, 3));
      *v132 = vaddq_f32(v16, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v26, (int8x16_t)v131, (int8x16_t)vaddq_f32(v76, vmulq_laneq_f32(vsubq_f32(v131, v76), v16, 3))), v16), v76, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v133 = -v13;
    if (v133 >= v5)
      goto LABEL_3;
LABEL_10:
    v134 = 16 * v133;
    v135 = *(float32x4_t *)(v8 + v134);
    v136 = *((float32x4_t *)a2 + 6);
    v137 = *((float32x4_t *)a2 + 7);
    v138 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v135, 3), v136);
    v139 = vmulq_f32(vrecpeq_f32(v138), v137);
    v140 = vmaxq_f32(vmulq_f32(v135, vmulq_f32(v139, vrecpsq_f32(v139, v138))), *((float32x4_t *)a2 + 4));
    v141 = *((int8x16_t *)a2 + 8);
    v142 = *((float32x4_t *)a2 + 9);
    v143 = *((float32x4_t *)a2 + 29);
    v144 = (float32x4_t)vorrq_s8(vandq_s8(v141, (int8x16_t)v140), (int8x16_t)v143);
    v145 = *((int8x16_t *)a2 + 10);
    v146 = *((float32x4_t *)a2 + 11);
    v147 = *((float32x4_t *)a2 + 12);
    v148 = *((float32x4_t *)a2 + 13);
    v149 = (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v144, v147));
    v150 = vsubq_f32(vsubq_f32(v144, v143), vmulq_f32(vmulq_f32(v148, v149), v144));
    v151 = *((float32x4_t *)a2 + 14);
    v152 = *((float32x4_t *)a2 + 15);
    v153 = *((float32x4_t *)a2 + 16);
    v154 = *((float32x4_t *)a2 + 17);
    v155 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v140, 0x17uLL)), (float32x4_t)vandq_s8(v145, (int8x16_t)vcgtq_f32(v142, v140))), v146), v149), vmulq_f32(v150, vaddq_f32(vaddq_f32(v153, vmulq_f32(v150, v154)), vmulq_f32(vmulq_f32(v150, v150), vaddq_f32(v151, vmulq_f32(v152, v150))))));
    v156 = *((float32x4_t *)a2 + 1);
    v157 = *((float32x4_t *)a2 + 18);
    v158 = *((float32x4_t *)a2 + 19);
    v159 = vmaxq_f32(vmulq_f32(v156, v155), v157);
    v160 = vcvtq_f32_s32(vcvtq_s32_f32(v159));
    v161 = vsubq_f32(v160, (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v160, v159)));
    v162 = vsubq_f32(v159, v161);
    v163 = *((float32x4_t *)a2 + 20);
    v164 = *((float32x4_t *)a2 + 21);
    v165 = *((int32x4_t *)a2 + 22);
    v166 = vmulq_f32(vaddq_f32(v143, vmulq_f32(v162, vaddq_f32(v164, vmulq_f32(v162, vaddq_f32(v158, vmulq_f32(v163, v162)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v165, vcvtq_s32_f32(v161)), 0x17uLL));
    v167 = vmulq_f32(*(float32x4_t *)(v7 + v134), *(float32x4_t *)a2);
    v168 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v167, 3), v136);
    v169 = vmulq_f32(v137, vrecpeq_f32(v168));
    v170 = *((float32x4_t *)a2 + 32);
    v171 = vmulq_f32(v167, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v169, vrecpsq_f32(v169, v168))), (int8x16_t)v170));
    v172 = vmaxq_f32(v171, v170);
    v173 = (float32x4_t)vorrq_s8(vandq_s8(v141, (int8x16_t)v172), (int8x16_t)v143);
    v174 = (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v173, v147));
    v175 = vsubq_f32(vsubq_f32(v173, v143), vmulq_f32(vmulq_f32(v148, v174), v173));
    v176 = vmaxq_f32(vmulq_f32(v156, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v172, 0x17uLL)), (float32x4_t)vandq_s8(v145, (int8x16_t)vcgtq_f32(v142, v172))), v146), v174), vmulq_f32(v175, vaddq_f32(vaddq_f32(v153, vmulq_f32(v154, v175)), vmulq_f32(vmulq_f32(v175, v175), vaddq_f32(v151, vmulq_f32(v152, v175))))))), v157);
    v177 = vcvtq_f32_s32(vcvtq_s32_f32(v176));
    v178 = vsubq_f32(v177, (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v177, v176)));
    v179 = vsubq_f32(v176, v178);
    v180 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v166, vmulq_f32(vaddq_f32(v143, vmulq_f32(v179, vaddq_f32(v164, vmulq_f32(v179, vaddq_f32(v158, vmulq_f32(v163, v179)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v178), v165), 0x17uLL))), v143), v170), v143);
    v181 = (float32x4_t)vorrq_s8(vandq_s8(v141, (int8x16_t)v180), (int8x16_t)v143);
    v182 = (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v181, v147));
    v183 = vsubq_f32(vsubq_f32(v181, v143), vmulq_f32(vmulq_f32(v148, v182), v181));
    v184 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v180, 0x17uLL)), (float32x4_t)vandq_s8(v145, (int8x16_t)vcgtq_f32(v142, v180))), v146), v182), vmulq_f32(v183, vaddq_f32(vaddq_f32(v153, vmulq_f32(v154, v183)), vmulq_f32(vmulq_f32(v183, v183), vaddq_f32(v151, vmulq_f32(v152, v183))))))), v157);
    v185 = vcvtq_f32_s32(vcvtq_s32_f32(v184));
    v186 = vsubq_f32(v185, (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v185, v184)));
    v187 = vsubq_f32(v184, v186);
    v188 = vmulq_f32(vaddq_f32(v143, vmulq_f32(v187, vaddq_f32(v164, vmulq_f32(v187, vaddq_f32(v158, vmulq_f32(v163, v187)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v186), v165), 0x17uLL));
    v188.f32[3] = v12;
    *(float32x4_t *)(v6 + v134) = vaddq_f32(v135, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v188, (int8x16_t)vaddq_f32(v171, vmulq_laneq_f32(vsubq_f32(v188, v171), v135, 3))), v135), v171, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendLinearBurnQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t *v118;
  int v119;
  uint64_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  int8x16_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  int8x16_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  int32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v176;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v119 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v176 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v176, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18)));
      v25 = *((int8x16_t *)a2 + 31);
      v26 = *((float32x4_t *)a2 + 32);
      v27 = vmaxq_f32(vmulq_f32(v176, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v26);
      v29 = *((float32x4_t *)a2 + 23);
      v28 = *((float32x4_t *)a2 + 24);
      v30 = vminq_f32(vmaxq_f32(v24, v26), v29);
      v31 = vminq_f32(v27, v29);
      v32 = *((float32x4_t *)a2 + 29);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v30), (int8x16_t)v32);
      v35 = *((float32x4_t *)a2 + 9);
      v34 = *((int8x16_t *)a2 + 10);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v31), (int8x16_t)v32);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v30)));
      v39 = *((float32x4_t *)a2 + 11);
      v38 = *((float32x4_t *)a2 + 12);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v33, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v36, v38));
      v42 = vaddq_f32(vsubq_f32(v37, v39), v40);
      v44 = *((float32x4_t *)a2 + 13);
      v43 = *((float32x4_t *)a2 + 14);
      v45 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v31))), v39), v41);
      v46 = vsubq_f32(vsubq_f32(v33, v32), vmulq_f32(vmulq_f32(v44, v40), v33));
      v47 = vsubq_f32(vsubq_f32(v36, v32), vmulq_f32(vmulq_f32(v44, v41), v36));
      v49 = *((float32x4_t *)a2 + 15);
      v48 = *((float32x4_t *)a2 + 16);
      v51 = *((float32x4_t *)a2 + 17);
      v50 = *((float32x4_t *)a2 + 18);
      v52 = vmulq_f32(v28, vaddq_f32(v42, vmulq_f32(v46, vaddq_f32(vaddq_f32(v48, vmulq_f32(v46, v51)), vmulq_f32(vmulq_f32(v46, v46), vaddq_f32(v43, vmulq_f32(v49, v46)))))));
      v53 = vmulq_f32(v28, vaddq_f32(v45, vmulq_f32(v47, vaddq_f32(vaddq_f32(v48, vmulq_f32(v47, v51)), vmulq_f32(vmulq_f32(v47, v47), vaddq_f32(v43, vmulq_f32(v49, v47)))))));
      v54 = *((float32x4_t *)a2 + 19);
      v55 = *((float32x4_t *)a2 + 20);
      v56 = vmaxq_f32(v52, v50);
      v57 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v58 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v59 = vmaxq_f32(v53, v50);
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v16);
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), v16);
      v62 = vmulq_f32(v21, vrecpeq_f32(v60));
      v63 = vmulq_f32(v21, vrecpeq_f32(v61));
      v64 = vandq_s8(v25, (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v61)));
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v66 = vmulq_f32(v57, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v60))), (int8x16_t)v26));
      v67 = vmulq_f32(v58, (float32x4_t)vorrq_s8(v64, (int8x16_t)v26));
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v69 = vminq_f32(vmaxq_f32(v66, v26), v29);
      v70 = vminq_f32(vmaxq_f32(v67, v26), v29);
      v71 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v69), (int8x16_t)v32);
      v72 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v70), (int8x16_t)v32);
      v73 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v65, v56)));
      v74 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v69))), v39);
      v75 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v70, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v70))), v39);
      v76 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v71, v38));
      v77 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v72, v38));
      v78 = vaddq_f32(v74, v76);
      v79 = vaddq_f32(v75, v77);
      v80 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v68, v59)));
      v81 = vsubq_f32(vsubq_f32(v71, v32), vmulq_f32(vmulq_f32(v44, v76), v71));
      v82 = vsubq_f32(vsubq_f32(v72, v32), vmulq_f32(vmulq_f32(v44, v77), v72));
      v83 = vsubq_f32(v56, v73);
      v85 = *((float32x4_t *)a2 + 21);
      v84 = *((int32x4_t *)a2 + 22);
      v86 = vmulq_f32(v83, vaddq_f32(v85, vmulq_f32(v83, vaddq_f32(v54, vmulq_f32(v55, v83)))));
      v87 = vsubq_f32(v59, v80);
      v88 = vmulq_f32(v81, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v81)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v43, vmulq_f32(v49, v81)))));
      v12 = 1.0;
      v89 = vmaxq_f32(vmulq_f32(v28, vaddq_f32(v78, v88)), v50);
      v90 = vmaxq_f32(vmulq_f32(v28, vaddq_f32(v79, vmulq_f32(v82, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v43, vmulq_f32(v49, v82))))))), v50);
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v89));
      v92 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v93 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v91, v89)));
      v94 = vsubq_f32(v92, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v92, v90)));
      v95 = vsubq_f32(v89, v93);
      v96 = vsubq_f32(v90, v94);
      v97 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v32, v86), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v73)), 0x17uLL)), vmulq_f32(vaddq_f32(v32, vmulq_f32(v95, vaddq_f32(v85, vmulq_f32(v95, vaddq_f32(v54, vmulq_f32(v55, v95)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v93), v84), 0x17uLL))), v32), v26), v32);
      v98 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v32, vmulq_f32(v87, vaddq_f32(v85, vmulq_f32(v87, vaddq_f32(v54, vmulq_f32(v55, v87)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v80)), 0x17uLL)), vmulq_f32(vaddq_f32(v32, vmulq_f32(v96, vaddq_f32(v85, vmulq_f32(v96, vaddq_f32(v54, vmulq_f32(v55, v96)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v94), v84), 0x17uLL))), v32), v26), v32);
      v99 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v97, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v97)));
      v100 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v97), (int8x16_t)v32);
      v101 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v100, v38));
      v102 = vsubq_f32(vsubq_f32(v100, v32), vmulq_f32(vmulq_f32(v44, v101), v100));
      v103 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v98), (int8x16_t)v32);
      v104 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v103, v38));
      v105 = vsubq_f32(vsubq_f32(v103, v32), vmulq_f32(vmulq_f32(v44, v104), v103));
      v106 = vaddq_f32(vaddq_f32(vsubq_f32(v99, v39), v101), vmulq_f32(v102, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v102)), vmulq_f32(vmulq_f32(v102, v102), vaddq_f32(v43, vmulq_f32(v49, v102))))));
      v107 = *((float32x4_t *)a2 + 25);
      v108 = vmaxq_f32(vmulq_f32(v107, v106), v50);
      v109 = vmaxq_f32(vmulq_f32(v107, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v98))), v39), v104), vmulq_f32(v105, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v105)), vmulq_f32(vmulq_f32(v105, v105), vaddq_f32(v43, vmulq_f32(v49, v105))))))), v50);
      v110 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
      v111 = vcvtq_f32_s32(vcvtq_s32_f32(v109));
      v112 = vsubq_f32(v110, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v110, v108)));
      v113 = vsubq_f32(v111, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v111, v109)));
      v114 = vsubq_f32(v108, v112);
      v115 = vsubq_f32(v109, v113);
      v116 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v114, vaddq_f32(v85, vmulq_f32(v114, vaddq_f32(v54, vmulq_f32(v55, v114)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v112), v84), 0x17uLL));
      v116.i32[3] = 1.0;
      v117 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v115, vaddq_f32(v85, vmulq_f32(v115, vaddq_f32(v54, vmulq_f32(v55, v115)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v113), v84), 0x17uLL));
      v117.i32[3] = 1.0;
      v118 = (float32x4_t *)(v6 + v14);
      v118[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v116, (int8x16_t)vaddq_f32(v66, vmulq_laneq_f32(vsubq_f32(v116, v66), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v66, 3));
      *v118 = vaddq_f32(v176, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v117, (int8x16_t)vaddq_f32(v67, vmulq_laneq_f32(vsubq_f32(v117, v67), v176, 3))), v176), v67, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v119 = -v13;
    if (v119 >= v5)
      goto LABEL_3;
LABEL_10:
    v120 = 16 * v119;
    v121 = *(float32x4_t *)(v8 + v120);
    v122 = *((float32x4_t *)a2 + 6);
    v123 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v121, 3), v122);
    v124 = *((float32x4_t *)a2 + 7);
    v125 = *((int8x16_t *)a2 + 8);
    v126 = vmulq_f32(vrecpeq_f32(v123), v124);
    v127 = *((float32x4_t *)a2 + 32);
    v128 = *((float32x4_t *)a2 + 23);
    v129 = *((float32x4_t *)a2 + 24);
    v130 = vminq_f32(vmaxq_f32(vmulq_f32(v121, vmulq_f32(v126, vrecpsq_f32(v126, v123))), v127), v128);
    v131 = *((float32x4_t *)a2 + 29);
    v132 = (float32x4_t)vorrq_s8(vandq_s8(v125, (int8x16_t)v130), (int8x16_t)v131);
    v133 = *((float32x4_t *)a2 + 9);
    v134 = *((int8x16_t *)a2 + 10);
    v135 = *((float32x4_t *)a2 + 11);
    v136 = *((float32x4_t *)a2 + 12);
    v137 = (float32x4_t)vandq_s8((int8x16_t)v131, (int8x16_t)vcgtq_f32(v132, v136));
    v138 = *((float32x4_t *)a2 + 13);
    v139 = *((float32x4_t *)a2 + 14);
    v140 = vsubq_f32(vsubq_f32(v132, v131), vmulq_f32(vmulq_f32(v138, v137), v132));
    v141 = *((float32x4_t *)a2 + 15);
    v142 = *((float32x4_t *)a2 + 16);
    v143 = *((float32x4_t *)a2 + 17);
    v144 = *((float32x4_t *)a2 + 18);
    v145 = vmaxq_f32(vmulq_f32(v129, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v130, 0x17uLL)), (float32x4_t)vandq_s8(v134, (int8x16_t)vcgtq_f32(v133, v130))), v135), v137), vmulq_f32(v140, vaddq_f32(vaddq_f32(v142, vmulq_f32(v140, v143)), vmulq_f32(vmulq_f32(v140, v140), vaddq_f32(v139, vmulq_f32(v141, v140))))))), v144);
    v146 = vcvtq_f32_s32(vcvtq_s32_f32(v145));
    v147 = vsubq_f32(v146, (float32x4_t)vandq_s8((int8x16_t)v131, (int8x16_t)vcgtq_f32(v146, v145)));
    v148 = vsubq_f32(v145, v147);
    v149 = *((float32x4_t *)a2 + 19);
    v150 = *((float32x4_t *)a2 + 20);
    v151 = *((float32x4_t *)a2 + 21);
    v152 = *((int32x4_t *)a2 + 22);
    v153 = vmulq_f32(vaddq_f32(v131, vmulq_f32(v148, vaddq_f32(v151, vmulq_f32(v148, vaddq_f32(v149, vmulq_f32(v150, v148)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v152, vcvtq_s32_f32(v147)), 0x17uLL));
    v154 = vmulq_f32(*(float32x4_t *)(v7 + v120), *(float32x4_t *)a2);
    v155 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 3), v122);
    v156 = vmulq_f32(v124, vrecpeq_f32(v155));
    v157 = vmulq_f32(v154, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v156, vrecpsq_f32(v156, v155))), (int8x16_t)v127));
    v158 = vminq_f32(vmaxq_f32(v157, v127), v128);
    v159 = (float32x4_t)vorrq_s8(vandq_s8(v125, (int8x16_t)v158), (int8x16_t)v131);
    v160 = (float32x4_t)vandq_s8((int8x16_t)v131, (int8x16_t)vcgtq_f32(v159, v136));
    v161 = vsubq_f32(vsubq_f32(v159, v131), vmulq_f32(vmulq_f32(v138, v160), v159));
    v162 = vmaxq_f32(vmulq_f32(v129, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v158, 0x17uLL)), (float32x4_t)vandq_s8(v134, (int8x16_t)vcgtq_f32(v133, v158))), v135), v160), vmulq_f32(v161, vaddq_f32(vaddq_f32(v142, vmulq_f32(v143, v161)), vmulq_f32(vmulq_f32(v161, v161), vaddq_f32(v139, vmulq_f32(v141, v161))))))), v144);
    v163 = vcvtq_f32_s32(vcvtq_s32_f32(v162));
    v164 = vsubq_f32(v163, (float32x4_t)vandq_s8((int8x16_t)v131, (int8x16_t)vcgtq_f32(v163, v162)));
    v165 = vsubq_f32(v162, v164);
    v166 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v153, vmulq_f32(vaddq_f32(v131, vmulq_f32(v165, vaddq_f32(v151, vmulq_f32(v165, vaddq_f32(v149, vmulq_f32(v150, v165)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v164), v152), 0x17uLL))), v131), v127), v131);
    v167 = (float32x4_t)vorrq_s8(vandq_s8(v125, (int8x16_t)v166), (int8x16_t)v131);
    v168 = (float32x4_t)vandq_s8((int8x16_t)v131, (int8x16_t)vcgtq_f32(v167, v136));
    v169 = vsubq_f32(vsubq_f32(v167, v131), vmulq_f32(vmulq_f32(v138, v168), v167));
    v170 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v166, 0x17uLL)), (float32x4_t)vandq_s8(v134, (int8x16_t)vcgtq_f32(v133, v166))), v135), v168), vmulq_f32(v169, vaddq_f32(vaddq_f32(v142, vmulq_f32(v143, v169)), vmulq_f32(vmulq_f32(v169, v169), vaddq_f32(v139, vmulq_f32(v141, v169))))))), v144);
    v171 = vcvtq_f32_s32(vcvtq_s32_f32(v170));
    v172 = vsubq_f32(v171, (float32x4_t)vandq_s8((int8x16_t)v131, (int8x16_t)vcgtq_f32(v171, v170)));
    v173 = vsubq_f32(v170, v172);
    v174 = vmulq_f32(vaddq_f32(v131, vmulq_f32(v173, vaddq_f32(v151, vmulq_f32(v173, vaddq_f32(v149, vmulq_f32(v150, v173)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v172), v152), 0x17uLL));
    v174.f32[3] = v12;
    *(float32x4_t *)(v6 + v120) = vaddq_f32(v121, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v174, (int8x16_t)vaddq_f32(v157, vmulq_laneq_f32(vsubq_f32(v174, v157), v121, 3))), v121), v157, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendAddTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  int8x16_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  int8x16_t *v17;
  unint64_t v18;
  unint64_t v19;
  int8x16_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  int8x16_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v46 = 0;
        v47 = 16 * v10;
        v48 = 16 * v9;
        v49 = 16 * v8;
        v50 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v51 = 0;
          do
          {
            v52 = v6[v51 / 0x10];
            v53 = vmulq_f32(v5[v51 / 0x10], *(float32x4_t *)a2);
            v54 = vaddq_f32(v52, v53);
            v7[v51 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)vsubq_f32(v54, vmulq_f32(v52, v53)), (int8x16_t)v54);
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          v5 = (float32x4_t *)((char *)v5 + v47);
          v6 = (float32x4_t *)((char *)v6 + v48);
          v7 = (int8x16_t *)((char *)v7 + v49);
        }
        while (v46 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = v6[v18];
          v27 = v6[v18 + 1];
          v28 = v6[v18 + 2];
          v29 = v6[v18 + 3];
          v30 = vmulq_f32(v5[v18], *(float32x4_t *)a2);
          v31 = vmulq_f32(v5[v18 + 1], *(float32x4_t *)a2);
          v32 = vmulq_f32(v5[v18 + 2], *(float32x4_t *)a2);
          v33 = vmulq_f32(v5[v18 + 3], *(float32x4_t *)a2);
          v34 = vaddq_f32(v26, v30);
          v35 = vaddq_f32(v27, v31);
          v36 = vaddq_f32(v28, v32);
          v37 = vaddq_f32(v29, v33);
          v38 = (int8x16_t)vsubq_f32(v34, vmulq_f32(v26, v30));
          v39 = *((int8x16_t *)a2 + 5);
          v40 = &v7[v18];
          *v40 = vbslq_s8(v39, v38, (int8x16_t)v34);
          v40[1] = vbslq_s8(v39, (int8x16_t)vsubq_f32(v35, vmulq_f32(v27, v31)), (int8x16_t)v35);
          v19 += 4;
          v18 += 4;
          v40[2] = vbslq_s8(v39, (int8x16_t)vsubq_f32(v36, vmulq_f32(v28, v32)), (int8x16_t)v36);
          v40[3] = vbslq_s8(v39, (int8x16_t)vsubq_f32(v37, vmulq_f32(v29, v33)), (int8x16_t)v37);
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v41 = *v23++;
            v42 = v41;
            v43 = *v24++;
            v44 = vmulq_f32(v42, *(float32x4_t *)a2);
            v45 = vaddq_f32(v43, v44);
            *v25++ = vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)vsubq_f32(v45, vmulq_f32(v43, v44)), (int8x16_t)v45);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (int8x16_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (int8x16_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendLightenTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  uint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t *v26;
  int v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 3)
    {
      if ((int)v4 >= 1)
      {
        v47 = 0;
        v48 = 16 * v10;
        v49 = 16 * v9;
        v50 = 16 * v8;
        v51 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v52 = 0;
          do
          {
            v53 = v5[v52 / 0x10];
            v54 = vmulq_f32(v6[v52 / 0x10], *a2);
            v55 = vmulq_laneq_f32(v54, v53, 3);
            v56 = vmulq_laneq_f32(v53, v54, 3);
            v7[v52 / 0x10] = vaddq_f32(vmaxq_f32(v55, v56), vsubq_f32(vsubq_f32(vaddq_f32(v53, v54), v55), v56));
            v52 += 16;
          }
          while (v51 != v52);
          ++v47;
          v5 = (float32x4_t *)((char *)v5 + v48);
          v6 = (float32x4_t *)((char *)v6 + v49);
          v7 = (float32x4_t *)((char *)v7 + v50);
        }
        while (v47 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 3;
      v16 = v6 + 3;
      v17 = v7 + 3;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = 3;
        v21 = v17;
        v22 = v16;
        v23 = v15;
        do
        {
          v24 = v23;
          v25 = v22;
          v26 = v21;
          v27 = v20;
          v28 = v5[v18];
          v29 = v5[v18 + 1];
          v30 = v5[v18 + 2];
          v31 = vmulq_f32(v6[v18], *a2);
          v32 = vmulq_f32(v6[v18 + 1], *a2);
          v33 = vmulq_f32(v6[v18 + 2], *a2);
          v34 = vmulq_laneq_f32(v31, v28, 3);
          v35 = vmulq_laneq_f32(v32, v29, 3);
          v36 = vmulq_laneq_f32(v33, v30, 3);
          v37 = vmulq_laneq_f32(v28, v31, 3);
          v38 = vmulq_laneq_f32(v29, v32, 3);
          v39 = vmulq_laneq_f32(v30, v33, 3);
          v40 = &v7[v18];
          v19 += 3;
          v18 += 3;
          v23 += 3;
          *v40 = vaddq_f32(vmaxq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v40[1] = vaddq_f32(vmaxq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v40[2] = vaddq_f32(vmaxq_f32(v36, v39), vsubq_f32(vsubq_f32(vaddq_f32(v30, v33), v36), v39));
          v22 += 3;
          v21 += 3;
          v20 = v27 + 3;
        }
        while (v19 < v4 - 2);
        if ((int)v4 > (int)v19)
        {
          do
          {
            v41 = *v24++;
            v42 = v41;
            v43 = *v25++;
            v44 = vmulq_f32(v43, *a2);
            v45 = vmulq_laneq_f32(v44, v42, 3);
            v46 = vmulq_laneq_f32(v42, v44, 3);
            *v26++ = vaddq_f32(vmaxq_f32(v45, v46), vsubq_f32(vsubq_f32(vaddq_f32(v42, v44), v45), v46));
            ++v27;
          }
          while ((int)v4 > v27);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendScreenTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  float32x4_t v44;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v38 = 0;
        v39 = 16 * v10;
        v40 = 16 * v9;
        v41 = 16 * v8;
        v42 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v43 = 0;
          do
          {
            v44 = vmulq_f32(v6[v43 / 0x10], *a2);
            v7[v43 / 0x10] = vsubq_f32(vaddq_f32(v5[v43 / 0x10], v44), vminq_f32(vminq_f32(vmulq_f32(v5[v43 / 0x10], v44), v44), v5[v43 / 0x10]));
            v43 += 16;
          }
          while (v42 != v43);
          ++v38;
          v5 = (float32x4_t *)((char *)v5 + v39);
          v6 = (float32x4_t *)((char *)v6 + v40);
          v7 = (float32x4_t *)((char *)v7 + v41);
        }
        while (v38 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = vmulq_f32(v6[v18], *a2);
          v27 = vmulq_f32(v6[v18 + 1], *a2);
          v28 = vmulq_f32(v6[v18 + 2], *a2);
          v29 = vmulq_f32(v6[v18 + 3], *a2);
          v30 = vsubq_f32(vaddq_f32(v5[v18 + 1], v27), vminq_f32(vminq_f32(vmulq_f32(v5[v18 + 1], v27), v27), v5[v18 + 1]));
          v31 = vsubq_f32(vaddq_f32(v5[v18 + 2], v28), vminq_f32(vminq_f32(vmulq_f32(v5[v18 + 2], v28), v28), v5[v18 + 2]));
          v32 = vsubq_f32(vaddq_f32(v5[v18 + 3], v29), vminq_f32(vminq_f32(vmulq_f32(v5[v18 + 3], v29), v29), v5[v18 + 3]));
          v33 = &v7[v18];
          *v33 = vsubq_f32(vaddq_f32(v5[v18], v26), vminq_f32(vminq_f32(vmulq_f32(v5[v18], v26), v26), v5[v18]));
          v33[1] = v30;
          v19 += 4;
          v18 += 4;
          v33[2] = v31;
          v33[3] = v32;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v34 = *v23++;
            v35 = v34;
            v36 = *v24++;
            v37 = vmulq_f32(v36, *a2);
            *v25++ = vsubq_f32(vaddq_f32(v35, v37), vminq_f32(vminq_f32(vmulq_f32(v35, v37), v37), v35));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendScreenPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  int8x16_t v107;
  float32x4_t v108;
  int8x16_t v109;
  int8x16_t v110;
  float32x4_t v111;
  float32x4_t v112;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 29);
        v15 = *((float32x4_t *)a2 + 27);
        v111 = *((float32x4_t *)a2 + 28);
        v16 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v13, *((float32x4_t *)a2 + 30)), 3), v15), v111);
        v17 = vminq_f32(vmaxq_f32(vrecpeq_f32(v16), v15), v111);
        v18 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpsq_f32(v16, v17)), v15), v111);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v16, v18)));
        v20 = *((float32x4_t *)a2 + 32);
        v112 = v20;
        v107 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32(*((float32x4_t *)a2 + 1), v20)), v20);
        v21 = (float32x4_t)vbslq_s8(v107, (int8x16_t)v14, (int8x16_t)vmaxq_f32(v19, v20));
        v108 = *((float32x4_t *)a2 + 9);
        v109 = *((int8x16_t *)a2 + 33);
        v110 = *((int8x16_t *)a2 + 8);
        v22 = (int8x16_t)vcgtq_f32(v108, v21);
        v23 = (int8x16_t)vmulq_f32(v21, vaddq_f32(v14, (float32x4_t)vandq_s8(v109, v22)));
        v24 = (float32x4_t)vorrq_s8(vandq_s8(v110, v23), (int8x16_t)v14);
        v105 = *((float32x4_t *)a2 + 4);
        v25 = *((float32x4_t *)a2 + 10);
        v26 = *((int8x16_t *)a2 + 34);
        v27 = *((int8x16_t *)a2 + 35);
        v28 = *((float32x4_t *)a2 + 12);
        v29 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v24, v28));
        v30 = vaddq_f32(vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vceqq_f32(v25, v21)), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v21, v105), v26), (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vceqq_f32(v105, v21))), (float32x4_t)vandq_s8(v27, v22))), *((float32x4_t *)a2 + 11)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL))), v29);
        v31 = vsubq_f32(vsubq_f32(v24, v14), vmulq_f32(vmulq_f32(*((float32x4_t *)a2 + 13), v29), v24));
        v32 = vmulq_f32(v31, v31);
        v106 = *((float32x4_t *)a2 + 38);
        v33 = *((float32x4_t *)a2 + 40);
        v34 = *((float32x4_t *)a2 + 42);
        v104 = *((float32x4_t *)a2 + 43);
        v35 = *((float32x4_t *)a2 + 45);
        v100 = *((float32x4_t *)a2 + 44);
        v36 = vmulq_f32(*((float32x4_t *)a2 + 1), vaddq_f32(v30, vmulq_f32(v31, vaddq_f32(v100, vmulq_f32(v31, vaddq_f32(vaddq_f32(vaddq_f32(v34, vmulq_f32(v31, v104)), vmulq_f32(v32, vaddq_f32(v33, vmulq_f32(*((float32x4_t *)a2 + 41), v31)))), vmulq_f32(vmulq_f32(v32, v32), vaddq_f32(vaddq_f32(v106, vmulq_f32(*((float32x4_t *)a2 + 39), v31)), vmulq_f32(v32,
                                vaddq_f32(*((float32x4_t *)a2 + 36), vmulq_f32(*((float32x4_t *)a2 + 37), v31)))))))))));
        v101 = *((float32x4_t *)a2 + 46);
        v37 = vminq_f32(vmaxq_f32(v36, v35), v101);
        v38 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
        v39 = vsubq_f32(v38, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v38, v37)));
        v40 = vsubq_f32(v37, v39);
        v41 = *((float32x4_t *)a2 + 49);
        v98 = *((float32x4_t *)a2 + 47);
        v99 = *((float32x4_t *)a2 + 48);
        v103 = *((float32x4_t *)a2 + 50);
        v42 = vmulq_f32(v40, v40);
        v43 = *((float32x4_t *)a2 + 52);
        v97 = *((float32x4_t *)a2 + 53);
        v44 = *((float32x4_t *)a2 + 51);
        v45 = (int8x16_t)vcgtq_f32(v97, v39);
        v102 = *((int32x4_t *)a2 + 22);
        v46 = *((float32x4_t *)a2 + 54);
        v47 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v48 = *((float32x4_t *)a2 + 27);
        v49 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v47, v46), 3), v48), v111);
        v50 = vminq_f32(vmaxq_f32(vrecpeq_f32(v49), v48), v111);
        v51 = vminq_f32(vmaxq_f32(vmulq_f32(v50, vrecpsq_f32(v49, v50)), v48), v111);
        v52 = vmulq_f32(v51, vrecpsq_f32(v49, v51));
        v52.i32[3] = 1.0;
        v53 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v36), (int8x16_t)vcgezq_f32(v36))), v112), (int8x16_t)vmulq_f32(vaddq_f32(v14, (float32x4_t)vandq_s8(v45, (int8x16_t)v46)), vmulq_f32(vaddq_f32(v14, vmulq_f32(v40, vaddq_f32(vaddq_f32(v44, vmulq_f32(v40, v43)), vmulq_f32(v42, vaddq_f32(
                                                      vaddq_f32(v41, vmulq_f32(v103, v40)),
                                                      vmulq_f32(v42, vaddq_f32(v98, vmulq_f32(v99, v40)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(v102, vcvtq_s32_f32(vaddq_f32(v39, (float32x4_t)vandq_s8(v27, v45)))), 0x17uLL))), (int8x16_t)v36);
        v54 = vmulq_f32(v47, v52);
        v55 = (float32x4_t)vbslq_s8(v107, (int8x16_t)v14, (int8x16_t)vmaxq_f32(v54, v112));
        v56 = (int8x16_t)vcgtq_f32(v108, v55);
        v57 = vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v55, v105), v26), (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vceqq_f32(v55, v105))), (float32x4_t)vandq_s8(v27, v56));
        v58 = (int8x16_t)vmulq_f32(v55, vaddq_f32(v14, (float32x4_t)vandq_s8(v109, v56)));
        v59 = *((float32x4_t *)a2 + 11);
        v60 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vceqq_f32(v55, v25)), v57), v59), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v58, 0x17uLL)));
        v61 = (float32x4_t)vorrq_s8(vandq_s8(v110, v58), (int8x16_t)v14);
        v62 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v61, v28));
        v63 = *((float32x4_t *)a2 + 13);
        v64 = vsubq_f32(vsubq_f32(v61, v14), vmulq_f32(vmulq_f32(v63, v62), v61));
        v65 = *((float32x4_t *)a2 + 37);
        v66 = *((float32x4_t *)a2 + 36);
        v67 = vmulq_f32(v64, v64);
        v68 = *((float32x4_t *)a2 + 41);
        v69 = vmulq_f32(*((float32x4_t *)a2 + 1), vaddq_f32(vaddq_f32(v60, v62), vmulq_f32(v64, vaddq_f32(v100, vmulq_f32(v64, vaddq_f32(vaddq_f32(vaddq_f32(v34, vmulq_f32(v104, v64)), vmulq_f32(v67, vaddq_f32(v33, vmulq_f32(v68, v64)))), vmulq_f32(vmulq_f32(v67, v67), vaddq_f32(vaddq_f32(v106, vmulq_f32(*((float32x4_t *)a2 + 39), v64)), vmulq_f32(v67, vaddq_f32(v66, vmulq_f32(v65, v64)))))))))));
        v70 = vminq_f32(vmaxq_f32(v69, v35), v101);
        v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
        v72 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v71, v70)));
        v73 = vsubq_f32(v70, v72);
        v74 = vmulq_f32(v73, v73);
        v75 = (int8x16_t)vcgtq_f32(v97, v72);
        v76 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v69), (int8x16_t)vcgezq_f32(v69))), v112), (int8x16_t)vmulq_f32(vaddq_f32(v14, (float32x4_t)vandq_s8(v75, (int8x16_t)v46)), vmulq_f32(vaddq_f32(v14, vmulq_f32(v73, vaddq_f32(vaddq_f32(v44, vmulq_f32(v43, v73)), vmulq_f32(v74, vaddq_f32(
                                                      vaddq_f32(v41, vmulq_f32(v103, v73)),
                                                      vmulq_f32(v74, vaddq_f32(v98, vmulq_f32(v99, v73)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(vaddq_f32(v72, (float32x4_t)vandq_s8(v27, v75))), v102), 0x17uLL))), (int8x16_t)v69);
        v77 = (int8x16_t)vsubq_f32(vaddq_f32(v53, v76), vminq_f32(vminq_f32(vmulq_f32(v53, v76), v76), v53));
        v78 = *((float32x4_t *)a2 + 2);
        v79 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32(v78, v112)), v112), (int8x16_t)v14, v77);
        v80 = (int8x16_t)vcgtq_f32(v108, v79);
        v81 = vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v79, v105), v26), (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vceqq_f32(v79, v105))), (float32x4_t)vandq_s8(v27, v80));
        v82 = (int8x16_t)vmulq_f32(v79, vaddq_f32(v14, (float32x4_t)vandq_s8(v109, v80)));
        v83 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vceqq_f32(v79, v25)), v81), v59), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)));
        v84 = (float32x4_t)vorrq_s8(vandq_s8(v110, v82), (int8x16_t)v14);
        v85 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v84, v28));
        v86 = vsubq_f32(vsubq_f32(v84, v14), vmulq_f32(vmulq_f32(v63, v85), v84));
        v87 = vmulq_f32(v86, v86);
        v88 = vmulq_f32(v78, vaddq_f32(vaddq_f32(v83, v85), vmulq_f32(v86, vaddq_f32(v100, vmulq_f32(v86, vaddq_f32(vaddq_f32(vaddq_f32(v34, vmulq_f32(v104, v86)), vmulq_f32(v87, vaddq_f32(*((float32x4_t *)a2 + 40), vmulq_f32(v68, v86)))), vmulq_f32(vmulq_f32(v87, v87), vaddq_f32(vaddq_f32(v106, vmulq_f32(*((float32x4_t *)a2 + 39), v86)), vmulq_f32(v87, vaddq_f32(v66, vmulq_f32(v65, v86)))))))))));
        v89 = vminq_f32(vmaxq_f32(v88, v35), v101);
        v90 = vcvtq_f32_s32(vcvtq_s32_f32(v89));
        v91 = vsubq_f32(v90, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v90, v89)));
        v92 = vsubq_f32(v89, v91);
        v93 = vmulq_f32(v92, v92);
        v94 = (int8x16_t)vcgtq_f32(v97, v91);
        v95 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v88), (int8x16_t)vcgezq_f32(v88))), v112), (int8x16_t)vmulq_f32(vaddq_f32(v14, (float32x4_t)vandq_s8(v94, (int8x16_t)v46)), vmulq_f32(vaddq_f32(v14, vmulq_f32(v92, vaddq_f32(vaddq_f32(v44, vmulq_f32(v43, v92)), vmulq_f32(v93, vaddq_f32(
                                                      vaddq_f32(v41, vmulq_f32(v103, v92)),
                                                      vmulq_f32(v93, vaddq_f32(v98, vmulq_f32(v99, v92)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(vaddq_f32(v91, (float32x4_t)vandq_s8(v27, v94))), v102), 0x17uLL))), (int8x16_t)v88);
        v95.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(*(float32x4_t *)(v5 + v12), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v95, (int8x16_t)vaddq_f32(v54, vmulq_laneq_f32(vsubq_f32(v95, v54), *(float32x4_t *)(v5 + v12), 3))), *(float32x4_t *)(v5 + v12)), v54, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendScreenQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  int8x16_t v127;
  float32x4_t *v128;
  int v129;
  uint64_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  int8x16_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  int8x16_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  int32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v187;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v129 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v187 = *(float32x4_t *)(v8 + v14);
      v16 = *((float32x4_t *)a2 + 6);
      v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v187, 3), v16);
      v20 = *((float32x4_t *)a2 + 7);
      v19 = *((int8x16_t *)a2 + 8);
      v21 = vmulq_f32(vrecpeq_f32(v17), v20);
      v22 = vmulq_f32(vrecpeq_f32(v18), v20);
      v23 = vmulq_f32(v15, vmulq_f32(v21, vrecpsq_f32(v21, v17)));
      v25 = *((int8x16_t *)a2 + 31);
      v24 = *((float32x4_t *)a2 + 32);
      v26 = vmaxq_f32(vmulq_f32(v187, vmulq_f32(v22, vrecpsq_f32(v22, v18))), v24);
      v28 = *((float32x4_t *)a2 + 23);
      v27 = *((float32x4_t *)a2 + 24);
      v29 = vminq_f32(vmaxq_f32(v23, v24), v28);
      v30 = vminq_f32(v26, v28);
      v31 = *((float32x4_t *)a2 + 29);
      v32 = *((float32x4_t *)a2 + 30);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v29), (int8x16_t)v31);
      v35 = *((float32x4_t *)a2 + 9);
      v34 = *((int8x16_t *)a2 + 10);
      v36 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v30), (int8x16_t)v31);
      v37 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v29)));
      v39 = *((float32x4_t *)a2 + 11);
      v38 = *((float32x4_t *)a2 + 12);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v33, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v36, v38));
      v42 = vaddq_f32(vsubq_f32(v37, v39), v40);
      v44 = *((float32x4_t *)a2 + 13);
      v43 = *((float32x4_t *)a2 + 14);
      v45 = vmulq_f32(v44, v41);
      v46 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v30))), v39), v41);
      v47 = vmulq_f32(vmulq_f32(v44, v40), v33);
      v48 = vmulq_f32(v45, v36);
      v49 = vsubq_f32(vsubq_f32(v33, v31), v47);
      v50 = vsubq_f32(vsubq_f32(v36, v31), v48);
      v52 = *((float32x4_t *)a2 + 15);
      v51 = *((float32x4_t *)a2 + 16);
      v54 = *((float32x4_t *)a2 + 17);
      v53 = *((float32x4_t *)a2 + 18);
      v55 = vaddq_f32(v46, vmulq_f32(v50, vaddq_f32(vaddq_f32(v51, vmulq_f32(v50, v54)), vmulq_f32(vmulq_f32(v50, v50), vaddq_f32(v43, vmulq_f32(v52, v50))))));
      v56 = vmulq_f32(v27, vaddq_f32(v42, vmulq_f32(v49, vaddq_f32(vaddq_f32(v51, vmulq_f32(v49, v54)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v43, vmulq_f32(v52, v49)))))));
      v57 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v58 = vmaxq_f32(v56, v53);
      v59 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v60 = vmaxq_f32(vmulq_f32(v27, v55), v53);
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v16);
      v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v16);
      v63 = vmulq_f32(v20, vrecpeq_f32(v61));
      v64 = vmulq_f32(v20, vrecpeq_f32(v62));
      v65 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v64, vrecpsq_f32(v64, v62))), (int8x16_t)v24);
      v66 = vmulq_f32(v57, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v61))), (int8x16_t)v24));
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v68 = vmulq_f32(v59, v65);
      v69 = vminq_f32(vmaxq_f32(v66, v24), v28);
      v70 = vminq_f32(vmaxq_f32(v68, v24), v28);
      v71 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v72 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v69), (int8x16_t)v31);
      v73 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v70), (int8x16_t)v31);
      v74 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v72, v38));
      v75 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v73, v38));
      v76 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v69))), v39), v74);
      v77 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v70, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v70))), v39), v75);
      v78 = vmulq_f32(vmulq_f32(v44, v74), v72);
      v79 = vsubq_f32(v67, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v67, v58)));
      v80 = vmulq_f32(vmulq_f32(v44, v75), v73);
      v81 = vsubq_f32(v72, v31);
      v82 = vsubq_f32(v73, v31);
      v83 = vsubq_f32(v81, v78);
      v84 = vsubq_f32(v82, v80);
      v85 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v71, v60)));
      v86 = vsubq_f32(v58, v79);
      v88 = *((float32x4_t *)a2 + 19);
      v87 = *((float32x4_t *)a2 + 20);
      v90 = *((float32x4_t *)a2 + 21);
      v89 = *((int32x4_t *)a2 + 22);
      v91 = vsubq_f32(v60, v85);
      v92 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v76, vmulq_f32(v83, vaddq_f32(vaddq_f32(v51, vmulq_f32(v54, v83)), vmulq_f32(vmulq_f32(v83, v83), vaddq_f32(v43, vmulq_f32(v52, v83))))))), v53);
      v93 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v86, vaddq_f32(v90, vmulq_f32(v86, vaddq_f32(v88, vmulq_f32(v87, v86)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v89, vcvtq_s32_f32(v79)), 0x17uLL));
      v94 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v77, vmulq_f32(v84, vaddq_f32(vaddq_f32(v51, vmulq_f32(v54, v84)), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(v43, vmulq_f32(v52, v84))))))), v53);
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      v96 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v97 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v95, v92)));
      v98 = vsubq_f32(v96, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v96, v94)));
      v99 = vcvtq_s32_f32(v85);
      v12 = 1.0;
      v100 = vsubq_f32(v92, v97);
      v101 = vsubq_f32(v94, v98);
      v102 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v91, vaddq_f32(v90, vmulq_f32(v91, vaddq_f32(v88, vmulq_f32(v87, v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v89, v99), 0x17uLL));
      v103 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v100, vaddq_f32(v90, vmulq_f32(v100, vaddq_f32(v88, vmulq_f32(v87, v100)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v97), v89), 0x17uLL));
      v104 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v101, vaddq_f32(v90, vmulq_f32(v101, vaddq_f32(v88, vmulq_f32(v87, v101)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v98), v89), 0x17uLL));
      v105 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v93, v103), vminq_f32(vminq_f32(vmulq_f32(v93, v103), v103), v93)), v24), v32);
      v106 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v102, v104), vminq_f32(vminq_f32(vmulq_f32(v102, v104), v104), v102)), v24), v32);
      v107 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v105, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v105)));
      v108 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v105), (int8x16_t)v31);
      v109 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v108, v38));
      v110 = vaddq_f32(vsubq_f32(v107, v39), v109);
      v111 = vsubq_f32(vsubq_f32(v108, v31), vmulq_f32(vmulq_f32(v44, v109), v108));
      v112 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v106), (int8x16_t)v31);
      v113 = (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v112, v38));
      v114 = vsubq_f32(vsubq_f32(v112, v31), vmulq_f32(vmulq_f32(v44, v113), v112));
      v115 = vaddq_f32(v110, vmulq_f32(v111, vaddq_f32(vaddq_f32(v51, vmulq_f32(v54, v111)), vmulq_f32(vmulq_f32(v111, v111), vaddq_f32(v43, vmulq_f32(v52, v111))))));
      v116 = *((float32x4_t *)a2 + 25);
      v117 = vmaxq_f32(vmulq_f32(v116, v115), v53);
      v118 = vmaxq_f32(vmulq_f32(v116, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v106, 0x17uLL)), (float32x4_t)vandq_s8(v34, (int8x16_t)vcgtq_f32(v35, v106))), v39), v113), vmulq_f32(v114, vaddq_f32(vaddq_f32(v51, vmulq_f32(v54, v114)), vmulq_f32(vmulq_f32(v114, v114), vaddq_f32(v43, vmulq_f32(v52, v114))))))), v53);
      v119 = vcvtq_f32_s32(vcvtq_s32_f32(v117));
      v120 = vcvtq_f32_s32(vcvtq_s32_f32(v118));
      v121 = vsubq_f32(v119, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v119, v117)));
      v122 = vsubq_f32(v120, (float32x4_t)vandq_s8((int8x16_t)v31, (int8x16_t)vcgtq_f32(v120, v118)));
      v123 = vsubq_f32(v117, v121);
      v124 = vsubq_f32(v118, v122);
      v125 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v123, vaddq_f32(v90, vmulq_f32(v123, vaddq_f32(v88, vmulq_f32(v87, v123)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v121), v89), 0x17uLL));
      v125.i32[3] = 1.0;
      v126 = vmulq_f32(vaddq_f32(v31, vmulq_f32(v124, vaddq_f32(v90, vmulq_f32(v124, vaddq_f32(v88, vmulq_f32(v87, v124)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v122), v89), 0x17uLL));
      v126.i32[3] = 1.0;
      v127 = *((int8x16_t *)a2 + 5);
      v128 = (float32x4_t *)(v6 + v14);
      v128[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v127, (int8x16_t)v125, (int8x16_t)vaddq_f32(v66, vmulq_laneq_f32(vsubq_f32(v125, v66), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v66, 3));
      *v128 = vaddq_f32(v187, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v127, (int8x16_t)v126, (int8x16_t)vaddq_f32(v68, vmulq_laneq_f32(vsubq_f32(v126, v68), v187, 3))), v187), v68, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v129 = -v13;
    if (v129 >= v5)
      goto LABEL_3;
LABEL_10:
    v130 = 16 * v129;
    v131 = *(float32x4_t *)(v8 + v130);
    v132 = *((float32x4_t *)a2 + 6);
    v133 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v131, 3), v132);
    v135 = *((float32x4_t *)a2 + 7);
    v134 = *((int8x16_t *)a2 + 8);
    v136 = vmulq_f32(vrecpeq_f32(v133), v135);
    v137 = *((float32x4_t *)a2 + 32);
    v138 = *((float32x4_t *)a2 + 23);
    v139 = *((float32x4_t *)a2 + 24);
    v140 = vminq_f32(vmaxq_f32(vmulq_f32(v131, vmulq_f32(v136, vrecpsq_f32(v136, v133))), v137), v138);
    v141 = *((float32x4_t *)a2 + 29);
    v142 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)v140), (int8x16_t)v141);
    v143 = *((float32x4_t *)a2 + 9);
    v144 = *((int8x16_t *)a2 + 10);
    v145 = *((float32x4_t *)a2 + 11);
    v146 = *((float32x4_t *)a2 + 12);
    v147 = (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v142, v146));
    v148 = *((float32x4_t *)a2 + 13);
    v149 = *((float32x4_t *)a2 + 14);
    v150 = vsubq_f32(vsubq_f32(v142, v141), vmulq_f32(vmulq_f32(v148, v147), v142));
    v151 = *((float32x4_t *)a2 + 15);
    v152 = *((float32x4_t *)a2 + 16);
    v154 = *((float32x4_t *)a2 + 17);
    v153 = *((float32x4_t *)a2 + 18);
    v155 = vmaxq_f32(vmulq_f32(v139, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v140, 0x17uLL)), (float32x4_t)vandq_s8(v144, (int8x16_t)vcgtq_f32(v143, v140))), v145), v147), vmulq_f32(v150, vaddq_f32(vaddq_f32(v152, vmulq_f32(v150, v154)), vmulq_f32(vmulq_f32(v150, v150), vaddq_f32(v149, vmulq_f32(v151, v150))))))), v153);
    v156 = vcvtq_f32_s32(vcvtq_s32_f32(v155));
    v157 = vsubq_f32(v156, (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v156, v155)));
    v158 = vsubq_f32(v155, v157);
    v159 = *((float32x4_t *)a2 + 19);
    v160 = *((float32x4_t *)a2 + 20);
    v161 = *((float32x4_t *)a2 + 21);
    v162 = *((int32x4_t *)a2 + 22);
    v163 = vmulq_f32(*(float32x4_t *)(v7 + v130), *(float32x4_t *)a2);
    v164 = vmulq_f32(vaddq_f32(v141, vmulq_f32(v158, vaddq_f32(v161, vmulq_f32(v158, vaddq_f32(v159, vmulq_f32(v160, v158)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v162, vcvtq_s32_f32(v157)), 0x17uLL));
    v165 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v163, 3), v132);
    v166 = vmulq_f32(v135, vrecpeq_f32(v165));
    v167 = vmulq_f32(v163, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v166, vrecpsq_f32(v166, v165))), (int8x16_t)v137));
    v168 = vminq_f32(vmaxq_f32(v167, v137), v138);
    v169 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)v168), (int8x16_t)v141);
    v170 = (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v169, v146));
    v171 = vsubq_f32(vsubq_f32(v169, v141), vmulq_f32(vmulq_f32(v148, v170), v169));
    v172 = vmaxq_f32(vmulq_f32(v139, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v168, 0x17uLL)), (float32x4_t)vandq_s8(v144, (int8x16_t)vcgtq_f32(v143, v168))), v145), v170), vmulq_f32(v171, vaddq_f32(vaddq_f32(v152, vmulq_f32(v154, v171)), vmulq_f32(vmulq_f32(v171, v171), vaddq_f32(v149, vmulq_f32(v151, v171))))))), v153);
    v173 = vcvtq_f32_s32(vcvtq_s32_f32(v172));
    v174 = vsubq_f32(v173, (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v173, v172)));
    v175 = vsubq_f32(v172, v174);
    v176 = vmulq_f32(vaddq_f32(v141, vmulq_f32(v175, vaddq_f32(v161, vmulq_f32(v175, vaddq_f32(v159, vmulq_f32(v160, v175)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v174), v162), 0x17uLL));
    v177 = vminq_f32(vmaxq_f32(vsubq_f32(vaddq_f32(v164, v176), vminq_f32(vminq_f32(vmulq_f32(v164, v176), v176), v164)), v137), *((float32x4_t *)a2 + 30));
    v178 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)v177), (int8x16_t)v141);
    v179 = (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v178, v146));
    v180 = vsubq_f32(vsubq_f32(v178, v141), vmulq_f32(vmulq_f32(v148, v179), v178));
    v181 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v177, 0x17uLL)), (float32x4_t)vandq_s8(v144, (int8x16_t)vcgtq_f32(v143, v177))), v145), v179), vmulq_f32(v180, vaddq_f32(vaddq_f32(v152, vmulq_f32(v154, v180)), vmulq_f32(vmulq_f32(v180, v180), vaddq_f32(v149, vmulq_f32(v151, v180))))))), v153);
    v182 = vcvtq_f32_s32(vcvtq_s32_f32(v181));
    v183 = vsubq_f32(v182, (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v182, v181)));
    v184 = vsubq_f32(v181, v183);
    v185 = vmulq_f32(vaddq_f32(v141, vmulq_f32(v184, vaddq_f32(v161, vmulq_f32(v184, vaddq_f32(v159, vmulq_f32(v160, v184)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v183), v162), 0x17uLL));
    v185.f32[3] = v12;
    *(float32x4_t *)(v6 + v130) = vaddq_f32(v131, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v185, (int8x16_t)vaddq_f32(v167, vmulq_laneq_f32(vsubq_f32(v185, v167), v131, 3))), v131), v167, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendColorDodgeTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t *v47;
  int v48;
  uint64_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v48 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *(float32x4_t *)a2);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13), *(float32x4_t *)a2);
      v16 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3);
      v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3);
      v19 = *((int8x16_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v20 = vmaxq_f32(v16, v18);
      v21 = vmaxq_f32(v17, v18);
      v22 = *((float32x4_t *)a2 + 7);
      v23 = vmulq_f32(vrecpeq_f32(v20), v22);
      v24 = vmulq_f32(vrecpeq_f32(v21), v22);
      v25 = vmulq_f32(v23, vrecpsq_f32(v23, v20));
      v26 = vmulq_f32(v24, vrecpsq_f32(v24, v21));
      v27 = *(float32x4_t *)(v7 + v13 - 16);
      v28 = *(float32x4_t *)(v7 + v13);
      v29 = vmulq_f32(v14, v25);
      v30 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3), v18);
      v31 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3), v18);
      v32 = vmulq_f32(v15, v26);
      v33 = vmulq_f32(v22, vrecpeq_f32(v30));
      v35 = *((float32x4_t *)a2 + 28);
      v34 = *((float32x4_t *)a2 + 29);
      v36 = *((float32x4_t *)a2 + 26);
      v37 = *((float32x4_t *)a2 + 27);
      v38 = vmaxq_f32(vsubq_f32(v34, v29), v36);
      v39 = vmaxq_f32(vsubq_f32(v34, v32), v36);
      v40 = vmulq_f32(v22, vrecpeq_f32(v31));
      v41 = vmulq_f32(v33, vrecpsq_f32(v33, v30));
      v42 = vminq_f32(vmaxq_f32(vmulq_f32(v22, vrecpeq_f32(v38)), v37), v35);
      v43 = vminq_f32(vmaxq_f32(vmulq_f32(v22, vrecpeq_f32(v39)), v37), v35);
      v44 = vmulq_f32(v27, v41);
      v45 = vmulq_f32(v28, vmulq_f32(v40, vrecpsq_f32(v40, v31)));
      v46 = *((float32x4_t *)a2 + 32);
      v29.i32[3] = 1.0;
      v32.i32[3] = 1.0;
      v47 = (float32x4_t *)(v6 + v13);
      v47[-1] = vaddq_f32(v27, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v19, (int8x16_t)v29, (int8x16_t)vaddq_f32(v29, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgeq_f32(v14, v16)), v46), (int8x16_t)v34, vbslq_s8((int8x16_t)vcgtq_f32(v44, v46),
                                                                       (int8x16_t)vminq_f32(vmulq_f32(v44, vmulq_f32(v42, vrecpsq_f32(v38, v42))), v34), (int8x16_t)v46)), v29), v27, 3))), v27), v14, 3));
      *v47 = vaddq_f32(v28, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v19, (int8x16_t)v32, (int8x16_t)vaddq_f32(v32, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgeq_f32(v15, v17)), v46), (int8x16_t)v34, vbslq_s8((int8x16_t)vcgtq_f32(v45, v46),
                                                                    (int8x16_t)vminq_f32(vmulq_f32(v45, vmulq_f32(v43, vrecpsq_f32(v39, v43))), v34), (int8x16_t)v46)), v32), v28, 3))), v28), v15, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v48 = -v12;
    if (v48 >= v5)
      goto LABEL_3;
LABEL_10:
    v49 = 16 * v48;
    v50 = vmulq_f32(*(float32x4_t *)(v8 + v49), *(float32x4_t *)a2);
    v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
    v52 = *((float32x4_t *)a2 + 6);
    v53 = vmaxq_f32(v51, v52);
    v54 = *((float32x4_t *)a2 + 7);
    v55 = vmulq_f32(vrecpeq_f32(v53), v54);
    v56 = vmulq_f32(v50, vmulq_f32(v55, vrecpsq_f32(v55, v53)));
    v57 = *(float32x4_t *)(v7 + v49);
    v58 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v52);
    v59 = vmulq_f32(v54, vrecpeq_f32(v58));
    v60 = vmulq_f32(v59, vrecpsq_f32(v59, v58));
    v61 = *((float32x4_t *)a2 + 29);
    v62 = vmaxq_f32(vsubq_f32(v61, v56), *((float32x4_t *)a2 + 26));
    v63 = vminq_f32(vmaxq_f32(vmulq_f32(v54, vrecpeq_f32(v62)), *((float32x4_t *)a2 + 27)), *((float32x4_t *)a2 + 28));
    v64 = vmulq_f32(v57, v60);
    v56.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v49) = vaddq_f32(v57, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v56, (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v61, (int8x16_t)vcgeq_f32(v50, v51)), *((float32x4_t *)a2 + 32)), (int8x16_t)v61, vbslq_s8((int8x16_t)vcgtq_f32(v64, *((float32x4_t *)a2 + 32)),
                                                                                        (int8x16_t)vminq_f32(vmulq_f32(v64, vmulq_f32(v63, vrecpsq_f32(v62, v63))), v61), *((int8x16_t *)a2 + 32))), v56), v57, 3))), v57), v50, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendColorDodgePOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 26);
    v9 = *((_QWORD *)a1 + 2);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v17 = *((float32x4_t *)a2 + 7);
        v16 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v17);
        v19 = *((float32x4_t *)a2 + 32);
        v20 = vmaxq_f32(vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15))), v19);
        v21 = *((float32x4_t *)a2 + 29);
        v22 = vminq_f32(v20, v21);
        v23 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v22), (int8x16_t)v21);
        v24 = *((float32x4_t *)a2 + 9);
        v25 = *((int8x16_t *)a2 + 10);
        v26 = *((float32x4_t *)a2 + 11);
        v27 = *((float32x4_t *)a2 + 12);
        v28 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v27));
        v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v22))), v26), v28);
        v31 = *((float32x4_t *)a2 + 13);
        v30 = *((float32x4_t *)a2 + 14);
        v32 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v31, v28), v23));
        v33 = *((float32x4_t *)a2 + 15);
        v34 = *((float32x4_t *)a2 + 16);
        v36 = *((float32x4_t *)a2 + 17);
        v35 = *((float32x4_t *)a2 + 18);
        v37 = vaddq_f32(v29, vmulq_f32(v32, vaddq_f32(vaddq_f32(v34, vmulq_f32(v32, v36)), vmulq_f32(vmulq_f32(v32, v32), vaddq_f32(v30, vmulq_f32(v33, v32))))));
        v38 = *((float32x4_t *)a2 + 1);
        v39 = vmaxq_f32(vmulq_f32(v38, v37), v35);
        v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        v41 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v40, v39)));
        v42 = vsubq_f32(v39, v41);
        v43 = *((float32x4_t *)a2 + 19);
        v44 = *((float32x4_t *)a2 + 20);
        v45 = *((float32x4_t *)a2 + 21);
        v46 = *((int32x4_t *)a2 + 22);
        v47 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v42, vaddq_f32(v45, vmulq_f32(v42, vaddq_f32(v43, vmulq_f32(v44, v42)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v41)), 0x17uLL));
        v48 = *(float32x4_t *)(v6 + v12);
        v49 = vmulq_f32(v48, *(float32x4_t *)a2);
        v50 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3), v14);
        v51 = vmulq_f32(v17, vrecpeq_f32(v50));
        v52 = vmulq_f32(v48, vmulq_f32(v51, vrecpsq_f32(v51, v50)));
        v53 = vminq_f32(vmaxq_f32(v52, v19), v21);
        v54 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v53), (int8x16_t)v21);
        v55 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v54, v27));
        v56 = vsubq_f32(vsubq_f32(v54, v21), vmulq_f32(vmulq_f32(v31, v55), v54));
        v57 = vmaxq_f32(vmulq_f32(v38, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v53, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v53))), v26), v55), vmulq_f32(v56, vaddq_f32(vaddq_f32(v34, vmulq_f32(v36, v56)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v30, vmulq_f32(v33, v56))))))), v35);
        v58 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
        v59 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v58, v57)));
        v60 = vsubq_f32(v57, v59);
        v61 = vsubq_f32(v21, vmulq_f32(vaddq_f32(v21, vmulq_f32(v60, vaddq_f32(v45, vmulq_f32(v60, vaddq_f32(v43, vmulq_f32(v44, v60)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v59), v46), 0x17uLL)));
        v62 = *((float32x4_t *)a2 + 26);
        v63 = vmaxq_f32(v61, v62);
        v64 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpeq_f32(v63)), *((float32x4_t *)a2 + 27)), *((float32x4_t *)a2 + 28));
        v65 = (int8x16_t)vminq_f32(vmulq_f32(v47, vmulq_f32(v64, vrecpsq_f32(v63, v64))), v21);
        v66 = (int8x16_t)vcgtq_f32(v47, v19);
        v67 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgeq_f32(v62, v61)), v19);
        v68 = (float32x4_t)vorrq_s8(vandq_s8(vandq_s8((int8x16_t)v21, v66), v67), vbicq_s8(v65, v67));
        v69 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v68, v16), (int8x16_t)v21);
        v70 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v68))), v26);
        v71 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v69, v27));
        v72 = vsubq_f32(vsubq_f32(v69, v21), vmulq_f32(vmulq_f32(v31, v71), v69));
        v73 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(v70, v71), vmulq_f32(v72, vaddq_f32(vaddq_f32(v34, vmulq_f32(v36, v72)), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(v30, vmulq_f32(v33, v72))))))), v35);
        v74 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
        v75 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v74, v73)));
        v76 = vsubq_f32(v73, v75);
        *(float32x4_t *)(v9 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), *((int8x16_t *)a2 + 53), (int8x16_t)vaddq_f32(v52, vmulq_laneq_f32(vsubq_f32(vmulq_f32(vaddq_f32(v21, vmulq_f32(v76, vaddq_f32(v45, vmulq_f32(v76,
                                                                                     vaddq_f32(v43, vmulq_f32(v44, v76)))))),
                                                                             (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v75), v46), 0x17uLL)), v52), v13, 3))), v13), v49, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v7;
      v6 += v8;
      v9 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendColorDodgeQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = 16 * *((int *)a1 + 22);
    v8 = 16 * *((int *)a1 + 26);
    v9 = *((_QWORD *)a1 + 2);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v17 = *((float32x4_t *)a2 + 7);
        v16 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v17);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 32);
        v21 = vmaxq_f32(v19, v20);
        v22 = *((float32x4_t *)a2 + 29);
        v23 = vminq_f32(v21, v22);
        v24 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v23), (int8x16_t)v22);
        v25 = *((float32x4_t *)a2 + 9);
        v26 = *((int8x16_t *)a2 + 10);
        v27 = *((float32x4_t *)a2 + 11);
        v28 = *((float32x4_t *)a2 + 12);
        v29 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v24, v28));
        v30 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v23))), v27), v29);
        v32 = *((float32x4_t *)a2 + 13);
        v31 = *((float32x4_t *)a2 + 14);
        v33 = vsubq_f32(vsubq_f32(v24, v22), vmulq_f32(vmulq_f32(v32, v29), v24));
        v35 = *((float32x4_t *)a2 + 15);
        v34 = *((float32x4_t *)a2 + 16);
        v37 = *((float32x4_t *)a2 + 17);
        v36 = *((float32x4_t *)a2 + 18);
        v38 = vaddq_f32(v30, vmulq_f32(v33, vaddq_f32(vaddq_f32(v34, vmulq_f32(v33, v37)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v31, vmulq_f32(v35, v33))))));
        v39 = *((float32x4_t *)a2 + 24);
        v40 = vmaxq_f32(vmulq_f32(v39, v38), v36);
        v41 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
        v42 = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v41, v40)));
        v43 = vsubq_f32(v40, v42);
        v44 = *((float32x4_t *)a2 + 19);
        v45 = *((float32x4_t *)a2 + 20);
        v46 = *((float32x4_t *)a2 + 21);
        v47 = *((int32x4_t *)a2 + 22);
        v48 = *(float32x4_t *)(v6 + v12);
        v49 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v43, vaddq_f32(v46, vmulq_f32(v43, vaddq_f32(v44, vmulq_f32(v45, v43)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v47, vcvtq_s32_f32(v42)), 0x17uLL));
        v50 = vmulq_f32(v48, *(float32x4_t *)a2);
        v51 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3), v14);
        v52 = vmulq_f32(v17, vrecpeq_f32(v51));
        v53 = vmulq_f32(v48, vmulq_f32(v52, vrecpsq_f32(v52, v51)));
        v54 = vminq_f32(vmaxq_f32(v53, v20), v22);
        v55 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v54), (int8x16_t)v22);
        v56 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v55, v28));
        v57 = vsubq_f32(vsubq_f32(v55, v22), vmulq_f32(vmulq_f32(v32, v56), v55));
        v58 = vmaxq_f32(vmulq_f32(v39, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v54, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v54))), v27), v56), vmulq_f32(v57, vaddq_f32(vaddq_f32(v34, vmulq_f32(v37, v57)), vmulq_f32(vmulq_f32(v57, v57), vaddq_f32(v31, vmulq_f32(v35, v57))))))), v36);
        v59 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
        v60 = vsubq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v59, v58)));
        v61 = vsubq_f32(v58, v60);
        v62 = vsubq_f32(v22, vmulq_f32(vaddq_f32(v22, vmulq_f32(v61, vaddq_f32(v46, vmulq_f32(v61, vaddq_f32(v44, vmulq_f32(v45, v61)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v60), v47), 0x17uLL)));
        v63 = *((float32x4_t *)a2 + 26);
        v64 = vmaxq_f32(v62, v63);
        v65 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpeq_f32(v64)), *((float32x4_t *)a2 + 27)), *((float32x4_t *)a2 + 28));
        v66 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v63, v62)), v20);
        v67 = vminq_f32(vmaxq_f32((float32x4_t)vorrq_s8(vandq_s8(vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v49, v20)), v66), vbicq_s8((int8x16_t)vminq_f32(vmulq_f32(v49, vmulq_f32(v65, vrecpsq_f32(v64, v65))), v22), v66)), v20), *((float32x4_t *)a2 + 30));
        v68 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v67), (int8x16_t)v22);
        v69 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v67, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v67))), v27);
        v70 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v68, v28));
        v71 = vsubq_f32(vsubq_f32(v68, v22), vmulq_f32(vmulq_f32(v32, v70), v68));
        v72 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(v69, v70), vmulq_f32(v71, vaddq_f32(vaddq_f32(v34, vmulq_f32(v37, v71)), vmulq_f32(vmulq_f32(v71, v71), vaddq_f32(v31, vmulq_f32(v35, v71))))))), v36);
        v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
        v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v73, v72)));
        v75 = vsubq_f32(v72, v74);
        *(float32x4_t *)(v9 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), *((int8x16_t *)a2 + 53), (int8x16_t)vaddq_f32(v53, vmulq_laneq_f32(vsubq_f32(vmulq_f32(vaddq_f32(v22, vmulq_f32(v75, vaddq_f32(v46, vmulq_f32(v75,
                                                                                     vaddq_f32(v44, vmulq_f32(v45, v75)))))),
                                                                             (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v74), v47), 0x17uLL)), v53), v13, 3))), v13), v50, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v7;
      v6 += v8;
      v9 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendLinearDodgeTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t *v49;
  uint64_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    while (v5 < 3)
    {
      LODWORD(v50) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v8 += v9;
      v6 += v10;
      v7 += v11;
      if (v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 32;
    do
    {
      v14 = *(float32x4_t *)(v8 + v13 - 32);
      v15 = *(float32x4_t *)(v8 + v13 - 16);
      v16 = *(float32x4_t *)(v8 + v13);
      v18 = *((int8x16_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v17);
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v21 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v17);
      v22 = *((float32x4_t *)a2 + 7);
      v23 = vmulq_f32(vrecpeq_f32(v19), v22);
      v24 = vmulq_f32(vrecpeq_f32(v20), v22);
      v25 = vmulq_f32(vrecpeq_f32(v21), v22);
      v26 = vmulq_f32(*(float32x4_t *)(v7 + v13 - 32), *(float32x4_t *)a2);
      v27 = vmulq_f32(*(float32x4_t *)(v7 + v13 - 16), *(float32x4_t *)a2);
      v28 = vmulq_f32(*(float32x4_t *)(v7 + v13), *(float32x4_t *)a2);
      v29 = vmulq_f32(v23, vrecpsq_f32(v23, v19));
      v30 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3), v17);
      v31 = vmulq_f32(v24, vrecpsq_f32(v24, v20));
      v32 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3), v17);
      v33 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3), v17);
      v34 = vmulq_f32(v25, vrecpsq_f32(v25, v21));
      v35 = vmulq_f32(v22, vrecpeq_f32(v30));
      v36 = vmulq_f32(v22, vrecpeq_f32(v32));
      v37 = vmulq_f32(v22, vrecpeq_f32(v33));
      v38 = (int8x16_t)vmulq_f32(v36, vrecpsq_f32(v36, v32));
      v39 = (int8x16_t)vmulq_f32(v37, vrecpsq_f32(v37, v33));
      v40 = *((int8x16_t *)a2 + 31);
      v41 = *((int8x16_t *)a2 + 32);
      v42 = vmulq_f32(v26, (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)vmulq_f32(v35, vrecpsq_f32(v35, v30))), v41));
      v43 = vmulq_f32(v27, (float32x4_t)vorrq_s8(vandq_s8(v40, v38), v41));
      v44 = vmulq_f32(v28, (float32x4_t)vorrq_s8(vandq_s8(v40, v39), v41));
      v45 = *((float32x4_t *)a2 + 29);
      v46 = vminq_f32(vaddq_f32(vmulq_f32(v14, v29), v42), v45);
      v47 = vminq_f32(vaddq_f32(vmulq_f32(v15, v31), v43), v45);
      v48 = vminq_f32(vaddq_f32(vmulq_f32(v16, v34), v44), v45);
      v46.i32[3] = 1.0;
      v47.i32[3] = 1.0;
      v48.i32[3] = 1.0;
      v49 = (float32x4_t *)(v6 + v13);
      v49[-2] = vaddq_f32(v14, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v46, (int8x16_t)vaddq_f32(v42, vmulq_laneq_f32(vsubq_f32(v46, v42), v14, 3))), v14), v42, 3));
      v49[-1] = vaddq_f32(v15, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v47, (int8x16_t)vaddq_f32(v43, vmulq_laneq_f32(vsubq_f32(v47, v43), v15, 3))), v15), v43, 3));
      *v49 = vaddq_f32(v16, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v48, (int8x16_t)vaddq_f32(v44, vmulq_laneq_f32(vsubq_f32(v48, v44), v16, 3))), v16), v44, 3));
      v12 -= 3;
      v13 += 48;
    }
    while (v5 + v12 > 2);
    LODWORD(v50) = -v12;
    if ((int)v50 >= v5)
      goto LABEL_3;
LABEL_10:
    v50 = v50;
    do
    {
      v51 = *(float32x4_t *)(v8 + 16 * v50);
      v52 = *((float32x4_t *)a2 + 6);
      v53 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3), v52);
      v54 = *((float32x4_t *)a2 + 7);
      v55 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v50), *(float32x4_t *)a2);
      v56 = vmulq_f32(vrecpeq_f32(v53), v54);
      v57 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3), v52);
      v58 = vmulq_f32(v54, vrecpeq_f32(v57));
      v59 = vmulq_f32(v55, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v58, vrecpsq_f32(v58, v57))), *((int8x16_t *)a2 + 32)));
      v60 = vminq_f32(vaddq_f32(vmulq_f32(v51, vmulq_f32(v56, vrecpsq_f32(v56, v53))), v59), *((float32x4_t *)a2 + 29));
      v60.i32[3] = 1.0;
      *(float32x4_t *)(v6 + 16 * v50++) = vaddq_f32(v51, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v60, (int8x16_t)vaddq_f32(v59, vmulq_laneq_f32(vsubq_f32(v60, v59), v51, 3))), v51), v59, 3));
    }
    while (v50 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendLinearDodgePOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t *v122;
  int v123;
  uint64_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  int32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v123 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v16 = *(float32x4_t *)(v8 + v14 - 16);
      v15 = *(float32x4_t *)(v8 + v14);
      v18 = *((int8x16_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v17);
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v22 = *((float32x4_t *)a2 + 7);
      v21 = *((int8x16_t *)a2 + 8);
      v23 = vmulq_f32(vrecpeq_f32(v19), v22);
      v24 = vmulq_f32(vrecpeq_f32(v20), v22);
      v26 = *((int8x16_t *)a2 + 31);
      v25 = *((float32x4_t *)a2 + 32);
      v27 = vmaxq_f32(vmulq_f32(v16, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v25);
      v28 = vmaxq_f32(vmulq_f32(v15, vmulq_f32(v24, vrecpsq_f32(v24, v20))), v25);
      v29 = *((float32x4_t *)a2 + 29);
      v30 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v27), (int8x16_t)v29);
      v32 = *((float32x4_t *)a2 + 9);
      v31 = *((int8x16_t *)a2 + 10);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v28), (int8x16_t)v29);
      v34 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v27)));
      v36 = *((float32x4_t *)a2 + 11);
      v35 = *((float32x4_t *)a2 + 12);
      v37 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v30, v35));
      v38 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v33, v35));
      v39 = vaddq_f32(vsubq_f32(v34, v36), v37);
      v41 = *((float32x4_t *)a2 + 13);
      v40 = *((float32x4_t *)a2 + 14);
      v42 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v28))), v36), v38);
      v43 = vsubq_f32(vsubq_f32(v30, v29), vmulq_f32(vmulq_f32(v41, v37), v30));
      v44 = vsubq_f32(vsubq_f32(v33, v29), vmulq_f32(vmulq_f32(v41, v38), v33));
      v46 = *((float32x4_t *)a2 + 15);
      v45 = *((float32x4_t *)a2 + 16);
      v48 = *((float32x4_t *)a2 + 17);
      v47 = *((float32x4_t *)a2 + 18);
      v49 = vaddq_f32(v39, vmulq_f32(v43, vaddq_f32(vaddq_f32(v45, vmulq_f32(v43, v48)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v40, vmulq_f32(v46, v43))))));
      v50 = *((float32x4_t *)a2 + 1);
      v51 = vmaxq_f32(vmulq_f32(v50, v49), v47);
      v52 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v45, vmulq_f32(v44, v48)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v40, vmulq_f32(v46, v44))))))), v47);
      v53 = *((float32x4_t *)a2 + 19);
      v54 = *((float32x4_t *)a2 + 20);
      v55 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v57 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v58 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3), v17);
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v17);
      v61 = vmulq_f32(v22, vrecpeq_f32(v59));
      v62 = vmulq_f32(v22, vrecpeq_f32(v60));
      v63 = (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v60));
      v64 = vmulq_f32(v55, (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)vmulq_f32(v61, vrecpsq_f32(v61, v59))), (int8x16_t)v25));
      v65 = vmulq_f32(v57, (float32x4_t)vorrq_s8(vandq_s8(v26, v63), (int8x16_t)v25));
      v66 = vmaxq_f32(v64, v25);
      v67 = vmaxq_f32(v65, v25);
      v68 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v66), (int8x16_t)v29);
      v69 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v67), (int8x16_t)v29);
      v70 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v56, v51)));
      v71 = vsubq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v58, v52)));
      v72 = vsubq_f32(v51, v70);
      v73 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v68, v35));
      v74 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v69, v35));
      v75 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v66))), v36), v73);
      v76 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v67, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v67))), v36), v74);
      v77 = vsubq_f32(vsubq_f32(v68, v29), vmulq_f32(vmulq_f32(v41, v73), v68));
      v78 = vsubq_f32(vsubq_f32(v69, v29), vmulq_f32(vmulq_f32(v41, v74), v69));
      v80 = *((float32x4_t *)a2 + 21);
      v79 = *((int32x4_t *)a2 + 22);
      v81 = vsubq_f32(v52, v71);
      v82 = vaddq_f32(v76, vmulq_f32(v78, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v40, vmulq_f32(v46, v78))))));
      v83 = vcvtq_s32_f32(v71);
      v12 = 1.0;
      v84 = vmulq_f32(vaddq_f32(v29, vmulq_f32(v72, vaddq_f32(v80, vmulq_f32(v72, vaddq_f32(v53, vmulq_f32(v54, v72)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v79, vcvtq_s32_f32(v70)), 0x17uLL));
      v85 = vmulq_f32(v50, v82);
      v86 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v75, vmulq_f32(v77, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v40, vmulq_f32(v46, v77))))))), v47);
      v87 = vmaxq_f32(v85, v47);
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v89 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
      v90 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v88, v86)));
      v91 = vsubq_f32(v89, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v89, v87)));
      v92 = vsubq_f32(v86, v90);
      v93 = vsubq_f32(v87, v91);
      v94 = vminq_f32(vaddq_f32(v84, vmulq_f32(vaddq_f32(v29, vmulq_f32(v92, vaddq_f32(v80, vmulq_f32(v92, vaddq_f32(v53, vmulq_f32(v54, v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v90), v79), 0x17uLL))), v29);
      v95 = vminq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v29, vmulq_f32(v81, vaddq_f32(v80, vmulq_f32(v81, vaddq_f32(v53, vmulq_f32(v54, v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v79, v83), 0x17uLL)), vmulq_f32(vaddq_f32(v29, vmulq_f32(v93, vaddq_f32(v80, vmulq_f32(v93, vaddq_f32(v53, vmulq_f32(v54, v93)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v91), v79), 0x17uLL))), v29);
      v96 = (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v94));
      v97 = (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v95));
      v98 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), v96);
      v99 = vandq_s8(v21, (int8x16_t)v94);
      v100 = vandq_s8(v21, (int8x16_t)v95);
      v101 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v95, 0x17uLL)), v97);
      v102 = (float32x4_t)vorrq_s8(v99, (int8x16_t)v29);
      v103 = vsubq_f32(v98, v36);
      v104 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v102, v35));
      v105 = vsubq_f32(vsubq_f32(v102, v29), vmulq_f32(vmulq_f32(v41, v104), v102));
      v106 = (float32x4_t)vorrq_s8(v100, (int8x16_t)v29);
      v107 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v106, v35));
      v108 = vsubq_f32(vsubq_f32(v106, v29), vmulq_f32(vmulq_f32(v41, v107), v106));
      v109 = vaddq_f32(vaddq_f32(vsubq_f32(v101, v36), v107), vmulq_f32(v108, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v108)), vmulq_f32(vmulq_f32(v108, v108), vaddq_f32(v40, vmulq_f32(v46, v108))))));
      v110 = *((float32x4_t *)a2 + 2);
      v111 = vmaxq_f32(vmulq_f32(v110, vaddq_f32(vaddq_f32(v103, v104), vmulq_f32(v105, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v105)), vmulq_f32(vmulq_f32(v105, v105), vaddq_f32(v40, vmulq_f32(v46, v105))))))), v47);
      v112 = vmaxq_f32(vmulq_f32(v110, v109), v47);
      v113 = vcvtq_f32_s32(vcvtq_s32_f32(v111));
      v114 = vcvtq_f32_s32(vcvtq_s32_f32(v112));
      v115 = vsubq_f32(v113, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v113, v111)));
      v116 = vsubq_f32(v114, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v114, v112)));
      v117 = vsubq_f32(v111, v115);
      v118 = vsubq_f32(v112, v116);
      v119 = vmulq_f32(vaddq_f32(v29, vmulq_f32(v117, vaddq_f32(v80, vmulq_f32(v117, vaddq_f32(v53, vmulq_f32(v54, v117)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v115), v79), 0x17uLL));
      v119.i32[3] = 1.0;
      v120 = vmulq_f32(vaddq_f32(v29, vmulq_f32(v118, vaddq_f32(v80, vmulq_f32(v118, vaddq_f32(v53, vmulq_f32(v54, v118)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v116), v79), 0x17uLL));
      v120.i32[3] = 1.0;
      v121 = vaddq_f32(*(float32x4_t *)(v8 + v14), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v120, (int8x16_t)vaddq_f32(v65, vmulq_laneq_f32(vsubq_f32(v120, v65), *(float32x4_t *)(v8 + v14), 3))), *(float32x4_t *)(v8 + v14)), v65, 3));
      v122 = (float32x4_t *)(v6 + v14);
      v122[-1] = vaddq_f32(v16, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v119, (int8x16_t)vaddq_f32(v64, vmulq_laneq_f32(vsubq_f32(v119, v64), v16, 3))), v16), v64, 3));
      *v122 = v121;
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v123 = -v13;
    if (v123 >= v5)
      goto LABEL_3;
LABEL_10:
    v124 = 16 * v123;
    v125 = *(float32x4_t *)(v8 + v124);
    v126 = *((float32x4_t *)a2 + 6);
    v127 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v125, 3), v126);
    v128 = *((float32x4_t *)a2 + 7);
    v129 = *((int8x16_t *)a2 + 8);
    v130 = vmulq_f32(vrecpeq_f32(v127), v128);
    v131 = *((float32x4_t *)a2 + 32);
    v132 = vmaxq_f32(vmulq_f32(v125, vmulq_f32(v130, vrecpsq_f32(v130, v127))), v131);
    v133 = *((float32x4_t *)a2 + 29);
    v134 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v132), (int8x16_t)v133);
    v135 = *((float32x4_t *)a2 + 9);
    v136 = *((int8x16_t *)a2 + 10);
    v137 = *((float32x4_t *)a2 + 11);
    v138 = *((float32x4_t *)a2 + 12);
    v139 = (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v134, v138));
    v140 = *((float32x4_t *)a2 + 13);
    v141 = *((float32x4_t *)a2 + 14);
    v142 = vsubq_f32(vsubq_f32(v134, v133), vmulq_f32(vmulq_f32(v140, v139), v134));
    v143 = *((float32x4_t *)a2 + 15);
    v144 = *((float32x4_t *)a2 + 16);
    v145 = *((float32x4_t *)a2 + 17);
    v146 = *((float32x4_t *)a2 + 18);
    v147 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v132, 0x17uLL)), (float32x4_t)vandq_s8(v136, (int8x16_t)vcgtq_f32(v135, v132))), v137), v139), vmulq_f32(v142, vaddq_f32(vaddq_f32(v144, vmulq_f32(v142, v145)), vmulq_f32(vmulq_f32(v142, v142), vaddq_f32(v141, vmulq_f32(v143, v142))))));
    v148 = *((float32x4_t *)a2 + 1);
    v149 = vmaxq_f32(vmulq_f32(v148, v147), v146);
    v150 = vcvtq_f32_s32(vcvtq_s32_f32(v149));
    v151 = vsubq_f32(v150, (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v150, v149)));
    v152 = vsubq_f32(v149, v151);
    v153 = *((float32x4_t *)a2 + 19);
    v154 = *((float32x4_t *)a2 + 20);
    v155 = *((float32x4_t *)a2 + 21);
    v156 = *((int32x4_t *)a2 + 22);
    v157 = vmulq_f32(*(float32x4_t *)(v7 + v124), *(float32x4_t *)a2);
    v158 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v157, 3), v126);
    v159 = vmulq_f32(v128, vrecpeq_f32(v158));
    v160 = vmulq_f32(v157, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v159, vrecpsq_f32(v159, v158))), (int8x16_t)v131));
    v161 = vmaxq_f32(v160, v131);
    v162 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v161), (int8x16_t)v133);
    v163 = (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v162, v138));
    v164 = vsubq_f32(vsubq_f32(v162, v133), vmulq_f32(vmulq_f32(v140, v163), v162));
    v165 = vmaxq_f32(vmulq_f32(v148, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v161, 0x17uLL)), (float32x4_t)vandq_s8(v136, (int8x16_t)vcgtq_f32(v135, v161))), v137), v163), vmulq_f32(v164, vaddq_f32(vaddq_f32(v144, vmulq_f32(v145, v164)), vmulq_f32(vmulq_f32(v164, v164), vaddq_f32(v141, vmulq_f32(v143, v164))))))), v146);
    v166 = vcvtq_f32_s32(vcvtq_s32_f32(v165));
    v167 = vsubq_f32(v166, (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v166, v165)));
    v168 = vsubq_f32(v165, v167);
    v169 = vminq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v133, vmulq_f32(v152, vaddq_f32(v155, vmulq_f32(v152, vaddq_f32(v153, vmulq_f32(v154, v152)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v156, vcvtq_s32_f32(v151)), 0x17uLL)), vmulq_f32(vaddq_f32(v133, vmulq_f32(v168, vaddq_f32(v155, vmulq_f32(v168, vaddq_f32(v153, vmulq_f32(v154, v168)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v167), v156), 0x17uLL))), v133);
    v170 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v169), (int8x16_t)v133);
    v171 = (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v170, v138));
    v172 = vsubq_f32(vsubq_f32(v170, v133), vmulq_f32(vmulq_f32(v140, v171), v170));
    v173 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v169, 0x17uLL)), (float32x4_t)vandq_s8(v136, (int8x16_t)vcgtq_f32(v135, v169))), v137), v171), vmulq_f32(v172, vaddq_f32(vaddq_f32(v144, vmulq_f32(v145, v172)), vmulq_f32(vmulq_f32(v172, v172), vaddq_f32(v141, vmulq_f32(v143, v172))))))), v146);
    v174 = vcvtq_f32_s32(vcvtq_s32_f32(v173));
    v175 = vsubq_f32(v174, (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v174, v173)));
    v176 = vsubq_f32(v173, v175);
    v177 = vmulq_f32(vaddq_f32(v133, vmulq_f32(v176, vaddq_f32(v155, vmulq_f32(v176, vaddq_f32(v153, vmulq_f32(v154, v176)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v175), v156), 0x17uLL));
    v177.f32[3] = v12;
    *(float32x4_t *)(v6 + v124) = vaddq_f32(v125, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v177, (int8x16_t)vaddq_f32(v160, vmulq_laneq_f32(vsubq_f32(v177, v160), v125, 3))), v125), v160, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendLinearDodgeQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t *v115;
  int v116;
  uint64_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  int8x16_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  int8x16_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  int32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v173;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v116 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v173 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v173, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v22, vrecpsq_f32(v22, v18));
      v25 = vmulq_f32(v23, vrecpsq_f32(v23, v19));
      v27 = *((int8x16_t *)a2 + 31);
      v26 = *((float32x4_t *)a2 + 32);
      v28 = *((float32x4_t *)a2 + 23);
      v29 = *((float32x4_t *)a2 + 24);
      v30 = vminq_f32(vmaxq_f32(vmulq_f32(v15, v24), v26), v28);
      v31 = vminq_f32(vmaxq_f32(vmulq_f32(v173, v25), v26), v28);
      v32 = *((float32x4_t *)a2 + 29);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v30), (int8x16_t)v32);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v31), (int8x16_t)v32);
      v36 = *((float32x4_t *)a2 + 9);
      v35 = *((int8x16_t *)a2 + 10);
      v38 = *((float32x4_t *)a2 + 11);
      v37 = *((float32x4_t *)a2 + 12);
      v39 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v30))), v38);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v33, v37));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v34, v37));
      v43 = *((float32x4_t *)a2 + 13);
      v42 = *((float32x4_t *)a2 + 14);
      v44 = vaddq_f32(v39, v40);
      v45 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v31))), v38), v41);
      v46 = vsubq_f32(vsubq_f32(v33, v32), vmulq_f32(vmulq_f32(v43, v40), v33));
      v47 = vsubq_f32(vsubq_f32(v34, v32), vmulq_f32(vmulq_f32(v43, v41), v34));
      v49 = *((float32x4_t *)a2 + 15);
      v48 = *((float32x4_t *)a2 + 16);
      v51 = *((float32x4_t *)a2 + 17);
      v50 = *((float32x4_t *)a2 + 18);
      v52 = vmaxq_f32(vmulq_f32(v29, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(vaddq_f32(v48, vmulq_f32(v46, v51)), vmulq_f32(vmulq_f32(v46, v46), vaddq_f32(v42, vmulq_f32(v49, v46))))))), v50);
      v53 = vmaxq_f32(vmulq_f32(v29, vaddq_f32(v45, vmulq_f32(v47, vaddq_f32(vaddq_f32(v48, vmulq_f32(v47, v51)), vmulq_f32(vmulq_f32(v47, v47), vaddq_f32(v42, vmulq_f32(v49, v47))))))), v50);
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v56 = *((float32x4_t *)a2 + 19);
      v57 = *((float32x4_t *)a2 + 20);
      v58 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v54, v52)));
      v59 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v60 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v61 = vsubq_f32(v55, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v55, v53)));
      v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v16);
      v63 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 3), v16);
      v64 = vsubq_f32(v52, v58);
      v65 = vmulq_f32(v21, vrecpeq_f32(v62));
      v66 = vmulq_f32(v21, vrecpeq_f32(v63));
      v67 = (int8x16_t)vmulq_f32(v65, vrecpsq_f32(v65, v62));
      v68 = (int8x16_t)vmulq_f32(v66, vrecpsq_f32(v66, v63));
      v70 = *((float32x4_t *)a2 + 21);
      v69 = *((int32x4_t *)a2 + 22);
      v71 = vmulq_f32(v59, (float32x4_t)vorrq_s8(vandq_s8(v27, v67), (int8x16_t)v26));
      v72 = vmulq_f32(v60, (float32x4_t)vorrq_s8(vandq_s8(v27, v68), (int8x16_t)v26));
      v73 = vminq_f32(vmaxq_f32(v71, v26), v28);
      v74 = vminq_f32(vmaxq_f32(v72, v26), v28);
      v75 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v73), (int8x16_t)v32);
      v76 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v74), (int8x16_t)v32);
      v77 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v75, v37));
      v78 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v73, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v73))), v38), v77);
      v79 = vsubq_f32(vsubq_f32(v75, v32), vmulq_f32(vmulq_f32(v43, v77), v75));
      v80 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v76, v37));
      v81 = vsubq_f32(v53, v61);
      v82 = vsubq_f32(vsubq_f32(v76, v32), vmulq_f32(vmulq_f32(v43, v80), v76));
      v83 = vmaxq_f32(vmulq_f32(v29, vaddq_f32(v78, vmulq_f32(v79, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v79)), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(v42, vmulq_f32(v49, v79))))))), v50);
      v84 = vmaxq_f32(vmulq_f32(v29, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v74, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v74))), v38), v80), vmulq_f32(v82, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v42, vmulq_f32(v49, v82))))))), v50);
      v85 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v86 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
      v87 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v85, v83)));
      v88 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v86, v84)));
      v89 = vaddq_f32(v32, vmulq_f32(v81, vaddq_f32(v70, vmulq_f32(v81, vaddq_f32(v56, vmulq_f32(v57, v81))))));
      v90 = vcvtq_s32_f32(v61);
      v12 = 1.0;
      v91 = vsubq_f32(v83, v87);
      v92 = vsubq_f32(v84, v88);
      v93 = vmaxq_f32(vminq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v32, vmulq_f32(v64, vaddq_f32(v70, vmulq_f32(v64, vaddq_f32(v56, vmulq_f32(v57, v64)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v69, vcvtq_s32_f32(v58)), 0x17uLL)), vmulq_f32(vaddq_f32(v32, vmulq_f32(v91, vaddq_f32(v70, vmulq_f32(v91, vaddq_f32(v56, vmulq_f32(v57, v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v87), v69), 0x17uLL))), v32), v26);
      v94 = vmaxq_f32(vminq_f32(vaddq_f32(vmulq_f32(v89, (float32x4_t)vshlq_n_s32(vaddq_s32(v69, v90), 0x17uLL)), vmulq_f32(vaddq_f32(v32, vmulq_f32(v92, vaddq_f32(v70, vmulq_f32(v92, vaddq_f32(v56, vmulq_f32(v57, v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v88), v69), 0x17uLL))), v32), v26);
      v95 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v93, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v93)));
      v96 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v93), (int8x16_t)v32);
      v97 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v96, v37));
      v98 = vaddq_f32(vsubq_f32(v95, v38), v97);
      v99 = vsubq_f32(vsubq_f32(v96, v32), vmulq_f32(vmulq_f32(v43, v97), v96));
      v100 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v94), (int8x16_t)v32);
      v101 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v100, v37));
      v102 = vsubq_f32(vsubq_f32(v100, v32), vmulq_f32(vmulq_f32(v43, v101), v100));
      v103 = vaddq_f32(v98, vmulq_f32(v99, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v99)), vmulq_f32(vmulq_f32(v99, v99), vaddq_f32(v42, vmulq_f32(v49, v99))))));
      v104 = *((float32x4_t *)a2 + 25);
      v105 = vmaxq_f32(vmulq_f32(v104, v103), v50);
      v106 = vmaxq_f32(vmulq_f32(v104, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v94, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v94))), v38), v101), vmulq_f32(v102, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v102)), vmulq_f32(vmulq_f32(v102, v102), vaddq_f32(v42, vmulq_f32(v49, v102))))))), v50);
      v107 = vcvtq_f32_s32(vcvtq_s32_f32(v105));
      v108 = vcvtq_f32_s32(vcvtq_s32_f32(v106));
      v109 = vsubq_f32(v107, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v107, v105)));
      v110 = vsubq_f32(v108, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v108, v106)));
      v111 = vsubq_f32(v105, v109);
      v112 = vsubq_f32(v106, v110);
      v113 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v111, vaddq_f32(v70, vmulq_f32(v111, vaddq_f32(v56, vmulq_f32(v57, v111)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v109), v69), 0x17uLL));
      v113.i32[3] = 1.0;
      v114 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v112, vaddq_f32(v70, vmulq_f32(v112, vaddq_f32(v56, vmulq_f32(v57, v112)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v110), v69), 0x17uLL));
      v114.i32[3] = 1.0;
      v115 = (float32x4_t *)(v6 + v14);
      v115[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v113, (int8x16_t)vaddq_f32(v71, vmulq_laneq_f32(vsubq_f32(v113, v71), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v71, 3));
      *v115 = vaddq_f32(v173, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v114, (int8x16_t)vaddq_f32(v72, vmulq_laneq_f32(vsubq_f32(v114, v72), v173, 3))), v173), v72, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v116 = -v13;
    if (v116 >= v5)
      goto LABEL_3;
LABEL_10:
    v117 = 16 * v116;
    v118 = *(float32x4_t *)(v8 + v117);
    v119 = *((float32x4_t *)a2 + 6);
    v120 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3), v119);
    v121 = *((float32x4_t *)a2 + 7);
    v122 = *((int8x16_t *)a2 + 8);
    v123 = vmulq_f32(vrecpeq_f32(v120), v121);
    v124 = *((float32x4_t *)a2 + 32);
    v125 = *((float32x4_t *)a2 + 23);
    v126 = *((float32x4_t *)a2 + 24);
    v127 = vminq_f32(vmaxq_f32(vmulq_f32(v118, vmulq_f32(v123, vrecpsq_f32(v123, v120))), v124), v125);
    v128 = *((float32x4_t *)a2 + 29);
    v129 = (float32x4_t)vorrq_s8(vandq_s8(v122, (int8x16_t)v127), (int8x16_t)v128);
    v130 = *((float32x4_t *)a2 + 9);
    v131 = *((int8x16_t *)a2 + 10);
    v132 = *((float32x4_t *)a2 + 11);
    v133 = *((float32x4_t *)a2 + 12);
    v134 = (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v129, v133));
    v135 = *((float32x4_t *)a2 + 13);
    v136 = *((float32x4_t *)a2 + 14);
    v137 = vsubq_f32(vsubq_f32(v129, v128), vmulq_f32(vmulq_f32(v135, v134), v129));
    v138 = *((float32x4_t *)a2 + 15);
    v139 = *((float32x4_t *)a2 + 16);
    v140 = *((float32x4_t *)a2 + 17);
    v141 = *((float32x4_t *)a2 + 18);
    v142 = vmaxq_f32(vmulq_f32(v126, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v127, 0x17uLL)), (float32x4_t)vandq_s8(v131, (int8x16_t)vcgtq_f32(v130, v127))), v132), v134), vmulq_f32(v137, vaddq_f32(vaddq_f32(v139, vmulq_f32(v137, v140)), vmulq_f32(vmulq_f32(v137, v137), vaddq_f32(v136, vmulq_f32(v138, v137))))))), v141);
    v143 = vcvtq_f32_s32(vcvtq_s32_f32(v142));
    v144 = vsubq_f32(v143, (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v143, v142)));
    v145 = vsubq_f32(v142, v144);
    v146 = *((float32x4_t *)a2 + 19);
    v147 = *((float32x4_t *)a2 + 20);
    v148 = *((float32x4_t *)a2 + 21);
    v149 = *((int32x4_t *)a2 + 22);
    v150 = vmulq_f32(vaddq_f32(v128, vmulq_f32(v145, vaddq_f32(v148, vmulq_f32(v145, vaddq_f32(v146, vmulq_f32(v147, v145)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v149, vcvtq_s32_f32(v144)), 0x17uLL));
    v151 = vmulq_f32(*(float32x4_t *)(v7 + v117), *(float32x4_t *)a2);
    v152 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v151, 3), v119);
    v153 = vmulq_f32(v121, vrecpeq_f32(v152));
    v154 = vmulq_f32(v151, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v153, vrecpsq_f32(v153, v152))), (int8x16_t)v124));
    v155 = vminq_f32(vmaxq_f32(v154, v124), v125);
    v156 = (float32x4_t)vorrq_s8(vandq_s8(v122, (int8x16_t)v155), (int8x16_t)v128);
    v157 = (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v156, v133));
    v158 = vsubq_f32(vsubq_f32(v156, v128), vmulq_f32(vmulq_f32(v135, v157), v156));
    v159 = vmaxq_f32(vmulq_f32(v126, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v155, 0x17uLL)), (float32x4_t)vandq_s8(v131, (int8x16_t)vcgtq_f32(v130, v155))), v132), v157), vmulq_f32(v158, vaddq_f32(vaddq_f32(v139, vmulq_f32(v140, v158)), vmulq_f32(vmulq_f32(v158, v158), vaddq_f32(v136, vmulq_f32(v138, v158))))))), v141);
    v160 = vcvtq_f32_s32(vcvtq_s32_f32(v159));
    v161 = vsubq_f32(v160, (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v160, v159)));
    v162 = vsubq_f32(v159, v161);
    v163 = vmaxq_f32(vminq_f32(vaddq_f32(v150, vmulq_f32(vaddq_f32(v128, vmulq_f32(v162, vaddq_f32(v148, vmulq_f32(v162, vaddq_f32(v146, vmulq_f32(v147, v162)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v161), v149), 0x17uLL))), v128), v124);
    v164 = (float32x4_t)vorrq_s8(vandq_s8(v122, (int8x16_t)v163), (int8x16_t)v128);
    v165 = (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v164, v133));
    v166 = vsubq_f32(vsubq_f32(v164, v128), vmulq_f32(vmulq_f32(v135, v165), v164));
    v167 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v163, 0x17uLL)), (float32x4_t)vandq_s8(v131, (int8x16_t)vcgtq_f32(v130, v163))), v132), v165), vmulq_f32(v166, vaddq_f32(vaddq_f32(v139, vmulq_f32(v140, v166)), vmulq_f32(vmulq_f32(v166, v166), vaddq_f32(v136, vmulq_f32(v138, v166))))))), v141);
    v168 = vcvtq_f32_s32(vcvtq_s32_f32(v167));
    v169 = vsubq_f32(v168, (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v168, v167)));
    v170 = vsubq_f32(v167, v169);
    v171 = vmulq_f32(vaddq_f32(v128, vmulq_f32(v170, vaddq_f32(v148, vmulq_f32(v170, vaddq_f32(v146, vmulq_f32(v147, v170)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v169), v149), 0x17uLL));
    v171.f32[3] = v12;
    *(float32x4_t *)(v6 + v117) = vaddq_f32(v118, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v171, (int8x16_t)vaddq_f32(v154, vmulq_laneq_f32(vsubq_f32(v171, v154), v118, 3))), v118), v154, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendOverlayTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  __int128 v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t *v52;
  int v53;
  uint64_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v53 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *(float32x4_t *)a2);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13), *(float32x4_t *)a2);
      v16 = *(float32x4_t *)(v7 + v13 - 16);
      v17 = *(float32x4_t *)(v7 + v13);
      v19 = *((int8x16_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v18);
      v21 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v18);
      v22 = *((float32x4_t *)a2 + 7);
      v23 = vmulq_f32(vrecpeq_f32(v20), v22);
      v24 = vmulq_f32(vrecpeq_f32(v21), v22);
      v25 = (int8x16_t)vmulq_f32(v23, vrecpsq_f32(v23, v20));
      v26 = (int8x16_t)vmulq_f32(v24, vrecpsq_f32(v24, v21));
      v27 = *((int8x16_t *)a2 + 31);
      v28 = *((float32x4_t *)a2 + 32);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v27, v25), (int8x16_t)v28);
      v30 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v18);
      v31 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 3), v18);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v27, v26), (int8x16_t)v28);
      v33 = vmulq_f32(v22, vrecpeq_f32(v30));
      v34 = vmulq_f32(v22, vrecpeq_f32(v31));
      v35 = vmulq_f32(v14, v29);
      v36 = vmulq_f32(v16, vmulq_f32(v33, vrecpsq_f32(v33, v30)));
      v37 = vmulq_f32(v17, vmulq_f32(v34, vrecpsq_f32(v34, v31)));
      v38 = vmulq_f32(v15, v32);
      v39 = vmulq_f32(v35, v36);
      v40 = vmulq_f32(v38, v37);
      v41 = vaddq_f32(v39, v39);
      v42 = vaddq_f32(v40, v40);
      v43 = *((_OWORD *)a2 + 55);
      v44 = vsubq_f32(vmulq_n_f32(vaddq_f32(v35, v36), *(float *)&v43), v41);
      v45 = vmulq_n_f32(vaddq_f32(v38, v37), *(float *)&v43);
      v46 = *((float32x4_t *)a2 + 13);
      v47 = (int8x16_t)vcgtq_f32(v46, v36);
      v48 = (int8x16_t)vcgtq_f32(v46, v37);
      v49 = *((float32x4_t *)a2 + 29);
      v50 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v49, v47), v28), (int8x16_t)v41, (int8x16_t)vsubq_f32(v44, v49));
      v50.i32[3] = 1.0;
      v51 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v49, v48), v28), (int8x16_t)v42, (int8x16_t)vsubq_f32(vsubq_f32(v45, v42), v49));
      v51.i32[3] = 1.0;
      v52 = (float32x4_t *)(v6 + v13);
      v52[-1] = vaddq_f32(v16, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v19, (int8x16_t)v50, (int8x16_t)vaddq_f32(v35, vmulq_laneq_f32(vsubq_f32(v50, v35), v16, 3))), v16), v35, 3));
      *v52 = vaddq_f32(v17, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v19, (int8x16_t)v51, (int8x16_t)vaddq_f32(v38, vmulq_laneq_f32(vsubq_f32(v51, v38), v17, 3))), v17), v38, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v53 = -v12;
    if (v53 >= v5)
      goto LABEL_3;
LABEL_10:
    v54 = 16 * v53;
    v55 = *(float32x4_t *)(v7 + v54);
    v56 = vmulq_f32(*(float32x4_t *)(v8 + v54), *(float32x4_t *)a2);
    v57 = *((float32x4_t *)a2 + 6);
    v58 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3), v57);
    v59 = *((float32x4_t *)a2 + 7);
    v60 = vmulq_f32(vrecpeq_f32(v58), v59);
    v61 = *((float32x4_t *)a2 + 32);
    v62 = vmulq_f32(v56, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v60, vrecpsq_f32(v60, v58))), (int8x16_t)v61));
    v63 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3), v57);
    v64 = vmulq_f32(v59, vrecpeq_f32(v63));
    v65 = vmulq_f32(v55, vmulq_f32(v64, vrecpsq_f32(v64, v63)));
    v66 = vmulq_f32(v62, v65);
    v67 = vaddq_f32(v66, v66);
    v68 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8(*((int8x16_t *)a2 + 29), (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 13), v65)), v61), (int8x16_t)v67, (int8x16_t)vsubq_f32(vsubq_f32(vmulq_n_f32(vaddq_f32(v62, v65), COERCE_FLOAT(*((_OWORD *)a2 + 55))), v67), *((float32x4_t *)a2 + 29)));
    v68.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v54) = vaddq_f32(v55, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v68, (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(vsubq_f32(v68, v62), v55, 3))), v55), v62, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendOverlayPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t *v123;
  int v124;
  uint64_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  int8x16_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  int32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  int8x16_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v185;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v124 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v185 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v185, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v25 = *((int8x16_t *)a2 + 31);
      v24 = *((float32x4_t *)a2 + 32);
      v26 = vmaxq_f32(vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18))), v24);
      v27 = vmaxq_f32(vmulq_f32(v185, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v24);
      v28 = *((float32x4_t *)a2 + 29);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v26), (int8x16_t)v28);
      v30 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v27), (int8x16_t)v28);
      v32 = *((float32x4_t *)a2 + 9);
      v31 = *((int8x16_t *)a2 + 10);
      v34 = *((float32x4_t *)a2 + 11);
      v33 = *((float32x4_t *)a2 + 12);
      v35 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v27))), v34);
      v36 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v29, v33));
      v37 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v30, v33));
      v39 = *((float32x4_t *)a2 + 13);
      v38 = *((float32x4_t *)a2 + 14);
      v40 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v26))), v34), v36);
      v41 = vmulq_f32(v39, v36);
      v42 = vmulq_f32(vmulq_f32(v39, v37), v30);
      v43 = vaddq_f32(v35, v37);
      v44 = vsubq_f32(vsubq_f32(v29, v28), vmulq_f32(v41, v29));
      v45 = vsubq_f32(vsubq_f32(v30, v28), v42);
      v47 = *((float32x4_t *)a2 + 15);
      v46 = *((float32x4_t *)a2 + 16);
      v49 = *((float32x4_t *)a2 + 17);
      v48 = *((float32x4_t *)a2 + 18);
      v50 = *((float32x4_t *)a2 + 1);
      v51 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v40, vmulq_f32(v44, vaddq_f32(vaddq_f32(v46, vmulq_f32(v44, v49)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v38, vmulq_f32(v47, v44))))))), v48);
      v52 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v46, vmulq_f32(v45, v49)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v38, vmulq_f32(v47, v45))))))), v48);
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v54, v52)));
      v57 = *((float32x4_t *)a2 + 19);
      v58 = *((float32x4_t *)a2 + 20);
      v59 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v60 = vsubq_f32(v51, v55);
      v61 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v16);
      v63 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 3), v16);
      v64 = vmulq_f32(v21, vrecpeq_f32(v62));
      v65 = vmulq_f32(v21, vrecpeq_f32(v63));
      v66 = (int8x16_t)vmulq_f32(v64, vrecpsq_f32(v64, v62));
      v68 = *((float32x4_t *)a2 + 21);
      v67 = *((int32x4_t *)a2 + 22);
      v69 = vmulq_f32(v59, (float32x4_t)vorrq_s8(vandq_s8(v25, v66), (int8x16_t)v24));
      v70 = vmulq_f32(v61, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v65, vrecpsq_f32(v65, v63))), (int8x16_t)v24));
      v71 = vmaxq_f32(v69, v24);
      v72 = vmaxq_f32(v70, v24);
      v73 = vmulq_f32(v60, vaddq_f32(v68, vmulq_f32(v60, vaddq_f32(v57, vmulq_f32(v58, v60)))));
      v74 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v71), (int8x16_t)v28);
      v75 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v72), (int8x16_t)v28);
      v76 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v74, v33));
      v77 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v71, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v71))), v34), v76);
      v78 = vsubq_f32(vsubq_f32(v74, v28), vmulq_f32(vmulq_f32(v39, v76), v74));
      v79 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v75, v33));
      v80 = vsubq_f32(v52, v56);
      v81 = vsubq_f32(vsubq_f32(v75, v28), vmulq_f32(vmulq_f32(v39, v79), v75));
      v82 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v77, vmulq_f32(v78, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v38, vmulq_f32(v47, v78))))))), v48);
      v83 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v72))), v34), v79), vmulq_f32(v81, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v81)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v38, vmulq_f32(v47, v81))))))), v48);
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vmulq_f32(vaddq_f32(v28, v73), (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v55)), 0x17uLL));
      v86 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v87 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v84, v82)));
      v88 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v86, v83)));
      v89 = vcvtq_s32_f32(v56);
      v12 = 1.0;
      v90 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v80, vaddq_f32(v68, vmulq_f32(v80, vaddq_f32(v57, vmulq_f32(v58, v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v67, v89), 0x17uLL));
      v91 = vsubq_f32(v82, v87);
      v92 = vsubq_f32(v83, v88);
      v93 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v91, vaddq_f32(v68, vmulq_f32(v91, vaddq_f32(v57, vmulq_f32(v58, v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v87), v67), 0x17uLL));
      v94 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v92, vaddq_f32(v68, vmulq_f32(v92, vaddq_f32(v57, vmulq_f32(v58, v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v88), v67), 0x17uLL));
      v95 = vaddq_f32(v85, v85);
      v96 = (int8x16_t)vmulq_f32(v95, v93);
      v97 = vsubq_f32(v95, v28);
      v98 = (int8x16_t)vsubq_f32(vaddq_f32(v97, v93), vminq_f32(vminq_f32(vmulq_f32(v97, v93), v97), v93));
      v99 = vaddq_f32(v90, v90);
      v100 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgeq_f32(v39, v85)), v24), v96, v98);
      v101 = (int8x16_t)vmulq_f32(v99, v94);
      v102 = vsubq_f32(v99, v28);
      v103 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgeq_f32(v39, v90)), v24), v101, (int8x16_t)vsubq_f32(vaddq_f32(v102, v94), vminq_f32(vminq_f32(vmulq_f32(v102, v94), v102), v94)));
      v104 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v100, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v100)));
      v105 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v100), (int8x16_t)v28);
      v106 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v105, v33));
      v107 = vsubq_f32(vsubq_f32(v105, v28), vmulq_f32(vmulq_f32(v39, v106), v105));
      v108 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v103), (int8x16_t)v28);
      v109 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v108, v33));
      v110 = vsubq_f32(vsubq_f32(v108, v28), vmulq_f32(vmulq_f32(v39, v109), v108));
      v111 = vaddq_f32(vaddq_f32(vsubq_f32(v104, v34), v106), vmulq_f32(v107, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(v38, vmulq_f32(v47, v107))))));
      v112 = *((float32x4_t *)a2 + 2);
      v113 = vmaxq_f32(vmulq_f32(v112, v111), v48);
      v114 = vmaxq_f32(vmulq_f32(v112, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v103, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v103))), v34), v109), vmulq_f32(v110, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v110)), vmulq_f32(vmulq_f32(v110, v110), vaddq_f32(v38, vmulq_f32(v47, v110))))))), v48);
      v115 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
      v116 = vcvtq_f32_s32(vcvtq_s32_f32(v114));
      v117 = vsubq_f32(v115, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v115, v113)));
      v118 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v116, v114)));
      v119 = vsubq_f32(v113, v117);
      v120 = vsubq_f32(v114, v118);
      v121 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v119, vaddq_f32(v68, vmulq_f32(v119, vaddq_f32(v57, vmulq_f32(v58, v119)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v117), v67), 0x17uLL));
      v121.i32[3] = 1.0;
      v122 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v120, vaddq_f32(v68, vmulq_f32(v120, vaddq_f32(v57, vmulq_f32(v58, v120)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v118), v67), 0x17uLL));
      v122.i32[3] = 1.0;
      v123 = (float32x4_t *)(v6 + v14);
      v123[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v121, (int8x16_t)vaddq_f32(v69, vmulq_laneq_f32(vsubq_f32(v121, v69), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v69, 3));
      *v123 = vaddq_f32(v185, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v122, (int8x16_t)vaddq_f32(v70, vmulq_laneq_f32(vsubq_f32(v122, v70), v185, 3))), v185), v70, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v124 = -v13;
    if (v124 >= v5)
      goto LABEL_3;
LABEL_10:
    v125 = 16 * v124;
    v126 = *(float32x4_t *)(v8 + v125);
    v127 = *((float32x4_t *)a2 + 6);
    v128 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v126, 3), v127);
    v130 = *((float32x4_t *)a2 + 7);
    v129 = *((int8x16_t *)a2 + 8);
    v131 = vmulq_f32(vrecpeq_f32(v128), v130);
    v132 = *((float32x4_t *)a2 + 32);
    v133 = vmaxq_f32(vmulq_f32(v126, vmulq_f32(v131, vrecpsq_f32(v131, v128))), v132);
    v134 = *((float32x4_t *)a2 + 29);
    v135 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v133), (int8x16_t)v134);
    v136 = *((float32x4_t *)a2 + 9);
    v137 = *((int8x16_t *)a2 + 10);
    v138 = *((float32x4_t *)a2 + 11);
    v139 = *((float32x4_t *)a2 + 12);
    v140 = (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v135, v139));
    v141 = *((float32x4_t *)a2 + 13);
    v142 = *((float32x4_t *)a2 + 14);
    v143 = vsubq_f32(vsubq_f32(v135, v134), vmulq_f32(vmulq_f32(v141, v140), v135));
    v144 = *((float32x4_t *)a2 + 15);
    v145 = *((float32x4_t *)a2 + 16);
    v146 = *((float32x4_t *)a2 + 17);
    v147 = *((float32x4_t *)a2 + 18);
    v148 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v133, 0x17uLL)), (float32x4_t)vandq_s8(v137, (int8x16_t)vcgtq_f32(v136, v133))), v138), v140), vmulq_f32(v143, vaddq_f32(vaddq_f32(v145, vmulq_f32(v143, v146)), vmulq_f32(vmulq_f32(v143, v143), vaddq_f32(v142, vmulq_f32(v144, v143))))));
    v149 = *((float32x4_t *)a2 + 1);
    v150 = vmaxq_f32(vmulq_f32(v149, v148), v147);
    v151 = vcvtq_f32_s32(vcvtq_s32_f32(v150));
    v152 = vsubq_f32(v151, (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v151, v150)));
    v153 = vsubq_f32(v150, v152);
    v154 = *((float32x4_t *)a2 + 19);
    v155 = *((float32x4_t *)a2 + 20);
    v156 = *((float32x4_t *)a2 + 21);
    v157 = *((int32x4_t *)a2 + 22);
    v158 = vmulq_f32(vaddq_f32(v134, vmulq_f32(v153, vaddq_f32(v156, vmulq_f32(v153, vaddq_f32(v154, vmulq_f32(v155, v153)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v157, vcvtq_s32_f32(v152)), 0x17uLL));
    v159 = vmulq_f32(*(float32x4_t *)(v7 + v125), *(float32x4_t *)a2);
    v160 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v159, 3), v127);
    v161 = vmulq_f32(v130, vrecpeq_f32(v160));
    v162 = vmulq_f32(v159, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v161, vrecpsq_f32(v161, v160))), (int8x16_t)v132));
    v163 = vmaxq_f32(v162, v132);
    v164 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v163), (int8x16_t)v134);
    v165 = (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v164, v139));
    v166 = vsubq_f32(vsubq_f32(v164, v134), vmulq_f32(vmulq_f32(v141, v165), v164));
    v167 = vmaxq_f32(vmulq_f32(v149, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v163, 0x17uLL)), (float32x4_t)vandq_s8(v137, (int8x16_t)vcgtq_f32(v136, v163))), v138), v165), vmulq_f32(v166, vaddq_f32(vaddq_f32(v145, vmulq_f32(v146, v166)), vmulq_f32(vmulq_f32(v166, v166), vaddq_f32(v142, vmulq_f32(v144, v166))))))), v147);
    v168 = vcvtq_f32_s32(vcvtq_s32_f32(v167));
    v169 = vsubq_f32(v168, (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v168, v167)));
    v170 = vsubq_f32(v167, v169);
    v171 = vmulq_f32(vaddq_f32(v134, vmulq_f32(v170, vaddq_f32(v156, vmulq_f32(v170, vaddq_f32(v154, vmulq_f32(v155, v170)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v169), v157), 0x17uLL));
    v172 = vaddq_f32(v158, v158);
    v173 = (int8x16_t)vmulq_f32(v172, v171);
    v174 = vsubq_f32(v172, v134);
    v175 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgeq_f32(v141, v158)), v132), v173, (int8x16_t)vsubq_f32(vaddq_f32(v174, v171), vminq_f32(vminq_f32(vmulq_f32(v174, v171), v174), v171)));
    v176 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v175), (int8x16_t)v134);
    v177 = (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v176, v139));
    v178 = vsubq_f32(vsubq_f32(v176, v134), vmulq_f32(vmulq_f32(v141, v177), v176));
    v179 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v175, 0x17uLL)), (float32x4_t)vandq_s8(v137, (int8x16_t)vcgtq_f32(v136, v175))), v138), v177), vmulq_f32(v178, vaddq_f32(vaddq_f32(v145, vmulq_f32(v146, v178)), vmulq_f32(vmulq_f32(v178, v178), vaddq_f32(v142, vmulq_f32(v144, v178))))))), v147);
    v180 = vcvtq_f32_s32(vcvtq_s32_f32(v179));
    v181 = vsubq_f32(v180, (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v180, v179)));
    v182 = vsubq_f32(v179, v181);
    v183 = vmulq_f32(vaddq_f32(v134, vmulq_f32(v182, vaddq_f32(v156, vmulq_f32(v182, vaddq_f32(v154, vmulq_f32(v155, v182)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v181), v157), 0x17uLL));
    v183.f32[3] = v12;
    *(float32x4_t *)(v6 + v125) = vaddq_f32(v126, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v183, (int8x16_t)vaddq_f32(v162, vmulq_laneq_f32(vsubq_f32(v183, v162), v126, 3))), v126), v162, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendOverlayQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t *v130;
  int v131;
  uint64_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  int8x16_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  int32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  int8x16_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v192;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v131 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v192 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v192, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18)));
      v26 = *((int8x16_t *)a2 + 31);
      v25 = *((float32x4_t *)a2 + 32);
      v28 = *((float32x4_t *)a2 + 23);
      v27 = *((float32x4_t *)a2 + 24);
      v29 = vmaxq_f32(vmulq_f32(v192, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v25);
      v30 = vminq_f32(vmaxq_f32(v24, v25), v28);
      v31 = vminq_f32(v29, v28);
      v32 = *((float32x4_t *)a2 + 29);
      v33 = *((float32x4_t *)a2 + 30);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v30), (int8x16_t)v32);
      v36 = *((float32x4_t *)a2 + 9);
      v35 = *((int8x16_t *)a2 + 10);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v31), (int8x16_t)v32);
      v39 = *((float32x4_t *)a2 + 11);
      v38 = *((float32x4_t *)a2 + 12);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v34, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v37, v38));
      v43 = *((float32x4_t *)a2 + 13);
      v42 = *((float32x4_t *)a2 + 14);
      v44 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v30))), v39), v40);
      v45 = vmulq_f32(v43, v40);
      v46 = vmulq_f32(vmulq_f32(v43, v41), v37);
      v47 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v31))), v39), v41);
      v48 = vsubq_f32(vsubq_f32(v34, v32), vmulq_f32(v45, v34));
      v49 = vsubq_f32(vsubq_f32(v37, v32), v46);
      v51 = *((float32x4_t *)a2 + 15);
      v50 = *((float32x4_t *)a2 + 16);
      v53 = *((float32x4_t *)a2 + 17);
      v52 = *((float32x4_t *)a2 + 18);
      v54 = vaddq_f32(v47, vmulq_f32(v49, vaddq_f32(vaddq_f32(v50, vmulq_f32(v49, v53)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v42, vmulq_f32(v51, v49))))));
      v55 = vmulq_f32(v27, vaddq_f32(v44, vmulq_f32(v48, vaddq_f32(vaddq_f32(v50, vmulq_f32(v48, v53)), vmulq_f32(vmulq_f32(v48, v48), vaddq_f32(v42, vmulq_f32(v51, v48)))))));
      v56 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v57 = vmaxq_f32(v55, v52);
      v58 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3), v16);
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), v16);
      v61 = vmaxq_f32(vmulq_f32(v27, v54), v52);
      v62 = vmulq_f32(v21, vrecpeq_f32(v59));
      v63 = vmulq_f32(v21, vrecpeq_f32(v60));
      v64 = vmulq_f32(v56, (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v59))), (int8x16_t)v25));
      v65 = vmulq_f32(v58, (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v60))), (int8x16_t)v25));
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v67 = vminq_f32(vmaxq_f32(v64, v25), v28);
      v68 = vminq_f32(vmaxq_f32(v65, v25), v28);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v70 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v67), (int8x16_t)v32);
      v71 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v68), (int8x16_t)v32);
      v72 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v70, v38));
      v73 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v71, v38));
      v74 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v67, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v67))), v39), v72);
      v75 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v68))), v39), v73);
      v76 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v66, v57)));
      v77 = vsubq_f32(vsubq_f32(v70, v32), vmulq_f32(vmulq_f32(v43, v72), v70));
      v78 = vsubq_f32(vsubq_f32(v71, v32), vmulq_f32(vmulq_f32(v43, v73), v71));
      v79 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v69, v61)));
      v80 = vsubq_f32(v57, v76);
      v81 = *((float32x4_t *)a2 + 19);
      v82 = *((float32x4_t *)a2 + 20);
      v83 = vaddq_f32(v74, vmulq_f32(v77, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v42, vmulq_f32(v51, v77))))));
      v84 = *((float32x4_t *)a2 + 21);
      v85 = *((int32x4_t *)a2 + 22);
      v86 = vmulq_f32(v80, vaddq_f32(v84, vmulq_f32(v80, vaddq_f32(v81, vmulq_f32(v82, v80)))));
      v87 = vsubq_f32(v61, v79);
      v12 = 1.0;
      v88 = vmulq_f32(vaddq_f32(v32, v86), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v76)), 0x17uLL));
      v89 = vmaxq_f32(vmulq_f32(v27, v83), v52);
      v90 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v75, vmulq_f32(v78, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v42, vmulq_f32(v51, v78))))))), v52);
      v91 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v87, vaddq_f32(v84, vmulq_f32(v87, vaddq_f32(v81, vmulq_f32(v82, v87)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v79)), 0x17uLL));
      v92 = vcvtq_f32_s32(vcvtq_s32_f32(v89));
      v93 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v94 = vsubq_f32(v92, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v92, v89)));
      v95 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v93, v90)));
      v96 = vsubq_f32(v89, v94);
      v97 = vsubq_f32(v90, v95);
      v98 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v96, vaddq_f32(v84, vmulq_f32(v96, vaddq_f32(v81, vmulq_f32(v82, v96)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v94), v85), 0x17uLL));
      v99 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v97, vaddq_f32(v84, vmulq_f32(v97, vaddq_f32(v81, vmulq_f32(v82, v97)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v95), v85), 0x17uLL));
      v100 = vaddq_f32(v88, v88);
      v101 = (int8x16_t)vmulq_f32(v100, v98);
      v102 = vsubq_f32(v100, v32);
      v103 = (int8x16_t)vsubq_f32(vaddq_f32(v102, v98), vminq_f32(vminq_f32(vmulq_f32(v102, v98), v102), v98));
      v104 = vaddq_f32(v91, v91);
      v105 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgeq_f32(v43, v88)), v25), v101, v103);
      v106 = (int8x16_t)vmulq_f32(v104, v99);
      v107 = vsubq_f32(v104, v32);
      v108 = vminq_f32(vmaxq_f32(v105, v25), v33);
      v109 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgeq_f32(v43, v91)), v25), v106, (int8x16_t)vsubq_f32(vaddq_f32(v107, v99), vminq_f32(vminq_f32(vmulq_f32(v107, v99), v107), v99))), v25), v33);
      v110 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v108, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v108)));
      v111 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v108), (int8x16_t)v32);
      v112 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v111, v38));
      v113 = vaddq_f32(vsubq_f32(v110, v39), v112);
      v114 = vsubq_f32(vsubq_f32(v111, v32), vmulq_f32(vmulq_f32(v43, v112), v111));
      v115 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v109), (int8x16_t)v32);
      v116 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v115, v38));
      v117 = vsubq_f32(vsubq_f32(v115, v32), vmulq_f32(vmulq_f32(v43, v116), v115));
      v118 = vaddq_f32(v113, vmulq_f32(v114, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v114)), vmulq_f32(vmulq_f32(v114, v114), vaddq_f32(v42, vmulq_f32(v51, v114))))));
      v119 = *((float32x4_t *)a2 + 25);
      v120 = vmaxq_f32(vmulq_f32(v119, v118), v52);
      v121 = vmaxq_f32(vmulq_f32(v119, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v109, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v109))), v39), v116), vmulq_f32(v117, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v117)), vmulq_f32(vmulq_f32(v117, v117), vaddq_f32(v42, vmulq_f32(v51, v117))))))), v52);
      v122 = vcvtq_f32_s32(vcvtq_s32_f32(v120));
      v123 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
      v124 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v122, v120)));
      v125 = vsubq_f32(v123, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v123, v121)));
      v126 = vsubq_f32(v120, v124);
      v127 = vsubq_f32(v121, v125);
      v128 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v126, vaddq_f32(v84, vmulq_f32(v126, vaddq_f32(v81, vmulq_f32(v82, v126)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v124), v85), 0x17uLL));
      v128.i32[3] = 1.0;
      v129 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v127, vaddq_f32(v84, vmulq_f32(v127, vaddq_f32(v81, vmulq_f32(v82, v127)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v125), v85), 0x17uLL));
      v129.i32[3] = 1.0;
      v130 = (float32x4_t *)(v6 + v14);
      v130[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v128, (int8x16_t)vaddq_f32(v64, vmulq_laneq_f32(vsubq_f32(v128, v64), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v64, 3));
      *v130 = vaddq_f32(v192, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v129, (int8x16_t)vaddq_f32(v65, vmulq_laneq_f32(vsubq_f32(v129, v65), v192, 3))), v192), v65, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v131 = -v13;
    if (v131 >= v5)
      goto LABEL_3;
LABEL_10:
    v132 = 16 * v131;
    v133 = *(float32x4_t *)(v8 + v132);
    v134 = *((float32x4_t *)a2 + 6);
    v135 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v133, 3), v134);
    v137 = *((float32x4_t *)a2 + 7);
    v136 = *((int8x16_t *)a2 + 8);
    v138 = vmulq_f32(vrecpeq_f32(v135), v137);
    v139 = *((float32x4_t *)a2 + 32);
    v140 = *((float32x4_t *)a2 + 23);
    v141 = *((float32x4_t *)a2 + 24);
    v142 = vminq_f32(vmaxq_f32(vmulq_f32(v133, vmulq_f32(v138, vrecpsq_f32(v138, v135))), v139), v140);
    v143 = *((float32x4_t *)a2 + 29);
    v144 = (float32x4_t)vorrq_s8(vandq_s8(v136, (int8x16_t)v142), (int8x16_t)v143);
    v145 = *((float32x4_t *)a2 + 9);
    v146 = *((int8x16_t *)a2 + 10);
    v147 = *((float32x4_t *)a2 + 11);
    v148 = *((float32x4_t *)a2 + 12);
    v149 = (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v144, v148));
    v150 = *((float32x4_t *)a2 + 13);
    v151 = *((float32x4_t *)a2 + 14);
    v152 = vsubq_f32(vsubq_f32(v144, v143), vmulq_f32(vmulq_f32(v150, v149), v144));
    v153 = *((float32x4_t *)a2 + 15);
    v154 = *((float32x4_t *)a2 + 16);
    v156 = *((float32x4_t *)a2 + 17);
    v155 = *((float32x4_t *)a2 + 18);
    v157 = vmaxq_f32(vmulq_f32(v141, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v142, 0x17uLL)), (float32x4_t)vandq_s8(v146, (int8x16_t)vcgtq_f32(v145, v142))), v147), v149), vmulq_f32(v152, vaddq_f32(vaddq_f32(v154, vmulq_f32(v152, v156)), vmulq_f32(vmulq_f32(v152, v152), vaddq_f32(v151, vmulq_f32(v153, v152))))))), v155);
    v158 = vcvtq_f32_s32(vcvtq_s32_f32(v157));
    v159 = vsubq_f32(v158, (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v158, v157)));
    v160 = vsubq_f32(v157, v159);
    v161 = *((float32x4_t *)a2 + 19);
    v162 = *((float32x4_t *)a2 + 20);
    v163 = *((float32x4_t *)a2 + 21);
    v164 = *((int32x4_t *)a2 + 22);
    v165 = vmulq_f32(vaddq_f32(v143, vmulq_f32(v160, vaddq_f32(v163, vmulq_f32(v160, vaddq_f32(v161, vmulq_f32(v162, v160)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v164, vcvtq_s32_f32(v159)), 0x17uLL));
    v166 = vmulq_f32(*(float32x4_t *)(v7 + v132), *(float32x4_t *)a2);
    v167 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v166, 3), v134);
    v168 = vmulq_f32(v137, vrecpeq_f32(v167));
    v169 = vmulq_f32(v166, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v168, vrecpsq_f32(v168, v167))), (int8x16_t)v139));
    v170 = vminq_f32(vmaxq_f32(v169, v139), v140);
    v171 = (float32x4_t)vorrq_s8(vandq_s8(v136, (int8x16_t)v170), (int8x16_t)v143);
    v172 = (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v171, v148));
    v173 = vsubq_f32(vsubq_f32(v171, v143), vmulq_f32(vmulq_f32(v150, v172), v171));
    v174 = vmaxq_f32(vmulq_f32(v141, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v170, 0x17uLL)), (float32x4_t)vandq_s8(v146, (int8x16_t)vcgtq_f32(v145, v170))), v147), v172), vmulq_f32(v173, vaddq_f32(vaddq_f32(v154, vmulq_f32(v156, v173)), vmulq_f32(vmulq_f32(v173, v173), vaddq_f32(v151, vmulq_f32(v153, v173))))))), v155);
    v175 = vcvtq_f32_s32(vcvtq_s32_f32(v174));
    v176 = vsubq_f32(v175, (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v175, v174)));
    v177 = vsubq_f32(v174, v176);
    v178 = vmulq_f32(vaddq_f32(v143, vmulq_f32(v177, vaddq_f32(v163, vmulq_f32(v177, vaddq_f32(v161, vmulq_f32(v162, v177)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v176), v164), 0x17uLL));
    v179 = vaddq_f32(v165, v165);
    v180 = (int8x16_t)vmulq_f32(v179, v178);
    v181 = vsubq_f32(v179, v143);
    v182 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgeq_f32(v150, v165)), v139), v180, (int8x16_t)vsubq_f32(vaddq_f32(v181, v178), vminq_f32(vminq_f32(vmulq_f32(v181, v178), v181), v178))), v139), *((float32x4_t *)a2 + 30));
    v183 = (float32x4_t)vorrq_s8(vandq_s8(v136, (int8x16_t)v182), (int8x16_t)v143);
    v184 = (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v183, v148));
    v185 = vsubq_f32(vsubq_f32(v183, v143), vmulq_f32(vmulq_f32(v150, v184), v183));
    v186 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v182, 0x17uLL)), (float32x4_t)vandq_s8(v146, (int8x16_t)vcgtq_f32(v145, v182))), v147), v184), vmulq_f32(v185, vaddq_f32(vaddq_f32(v154, vmulq_f32(v156, v185)), vmulq_f32(vmulq_f32(v185, v185), vaddq_f32(v151, vmulq_f32(v153, v185))))))), v155);
    v187 = vcvtq_f32_s32(vcvtq_s32_f32(v186));
    v188 = vsubq_f32(v187, (float32x4_t)vandq_s8((int8x16_t)v143, (int8x16_t)vcgtq_f32(v187, v186)));
    v189 = vsubq_f32(v186, v188);
    v190 = vmulq_f32(vaddq_f32(v143, vmulq_f32(v189, vaddq_f32(v163, vmulq_f32(v189, vaddq_f32(v161, vmulq_f32(v162, v189)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v188), v164), 0x17uLL));
    v190.f32[3] = v12;
    *(float32x4_t *)(v6 + v132) = vaddq_f32(v133, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v190, (int8x16_t)vaddq_f32(v169, vmulq_laneq_f32(vsubq_f32(v190, v169), v133, 3))), v133), v169, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendSoftLightTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v17;
  uint64_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t *v74;
  int v75;
  uint64_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    __asm { FMOV            V0.4S, #1.0 }
    while (v5 < 2)
    {
      v75 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v17 = 0;
    v18 = 16;
    do
    {
      v20 = *(float32x4_t *)(v8 + v18 - 16);
      v19 = *(float32x4_t *)(v8 + v18);
      v21 = *((float32x4_t *)a2 + 55);
      v22 = *((float32x4_t *)a2 + 56);
      v24 = *((float32x4_t *)a2 + 27);
      v23 = *((float32x4_t *)a2 + 28);
      v25 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v20, v21), 3), v24), v23);
      v26 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v19, v21), 3), v24), v23);
      v27 = vminq_f32(vmaxq_f32(vrecpeq_f32(v25), v24), v23);
      v28 = vminq_f32(vmaxq_f32(vrecpeq_f32(v26), v24), v23);
      v29 = vminq_f32(vmaxq_f32(vmulq_f32(v27, vrecpsq_f32(v25, v27)), v24), v23);
      v30 = vminq_f32(vmaxq_f32(vmulq_f32(v28, vrecpsq_f32(v26, v28)), v24), v23);
      v31 = vmulq_f32(v29, vrecpsq_f32(v25, v29));
      v32 = vmulq_f32(v30, vrecpsq_f32(v26, v30));
      v33 = vmulq_f32(v20, v31);
      v34 = vmulq_f32(v19, v32);
      v35 = *((float32x4_t *)a2 + 57);
      v36 = *((float32x4_t *)a2 + 58);
      v37 = vaddq_f32(v22, vmulq_f32(v33, v35));
      v38 = vaddq_f32(v22, vmulq_f32(v34, v35));
      v39 = (int8x16_t)vaddq_f32(v36, vmulq_f32(v33, v37));
      v40 = vminq_f32(vrsqrteq_f32(v33), v23);
      v41 = vminq_f32(vrsqrteq_f32(v34), v23);
      v42 = (int8x16_t)vaddq_f32(v36, vmulq_f32(v34, v38));
      v43 = vminq_f32(vmulq_f32(v40, vrsqrtsq_f32(vmulq_f32(v33, v40), v40)), v23);
      v44 = vminq_f32(vmulq_f32(v41, vrsqrtsq_f32(vmulq_f32(v34, v41), v41)), v23);
      v45 = *((float32x4_t *)a2 + 59);
      v46 = (int8x16_t)vcgeq_f32(v45, v33);
      v47 = (int8x16_t)vcgeq_f32(v45, v34);
      v48 = vmulq_f32(*(float32x4_t *)(v7 + v18 - 16), *(float32x4_t *)a2);
      v49 = vmulq_f32(*(float32x4_t *)(v7 + v18), *(float32x4_t *)a2);
      v50 = (float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v49, v45), 3);
      v51 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v48, v45), 3), v24), v23);
      v52 = vminq_f32(vmaxq_f32(v50, v24), v23);
      v53 = vminq_f32(vmaxq_f32(vrecpeq_f32(v51), v24), v23);
      v54 = vminq_f32(vmaxq_f32(vrecpeq_f32(v52), v24), v23);
      v55 = vmulq_f32(v54, vrecpsq_f32(v52, v54));
      v56 = *((float32x4_t *)a2 + 29);
      v57 = vbslq_s8((int8x16_t)vcgtq_f32(v34, v23), _Q0, (int8x16_t)vminq_f32(vmulq_f32(v44, vrsqrtsq_f32(vmulq_f32(v34, v44), v44)), v23));
      v58 = vmaxq_f32(vmulq_f32(v53, vrecpsq_f32(v51, v53)), v24);
      v59 = vmaxq_f32(v55, v24);
      v60 = *((float32x4_t *)a2 + 32);
      v61 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v56, v46), v60), v39, vbslq_s8((int8x16_t)vcgtq_f32(v33, v23), _Q0, (int8x16_t)vminq_f32(vmulq_f32(v43, vrsqrtsq_f32(vmulq_f32(v33, v43), v43)), v23)));
      v62 = vminq_f32(v58, v23);
      v63 = vminq_f32(v59, v23);
      v64 = vmulq_f32(v62, vrecpsq_f32(v51, v62));
      v65 = vmulq_f32(v63, vrecpsq_f32(v52, v63));
      v64.i32[3] = 1.0;
      v65.i32[3] = 1.0;
      v66 = vmulq_f32(v48, v64);
      v67 = vmulq_f32(v49, v65);
      v68 = vsubq_f32(v56, vmulq_f32(v21, v66));
      v69 = vsubq_f32(v56, vmulq_f32(v21, v67));
      v70 = *((float32x4_t *)a2 + 13);
      v71 = vsubq_f32(v33, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v56, (int8x16_t)vcgeq_f32(v70, v66)), v60), (int8x16_t)vmulq_f32(vsubq_f32(v56, v33), vmulq_f32(v33, v68)), (int8x16_t)vmulq_f32(vsubq_f32(vmulq_f32(v33, v61), v33), v68)));
      v72 = vsubq_f32(v34, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v56, (int8x16_t)vcgeq_f32(v70, v67)), v60), (int8x16_t)vmulq_f32(vsubq_f32(v56, v34), vmulq_f32(v34, v69)), (int8x16_t)vmulq_f32(vsubq_f32(vmulq_f32(v34, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v56, v47), v60), v42, v57)), v34), v69)));
      v71.i32[3] = 1.0;
      v72.i32[3] = 1.0;
      v73 = *((int8x16_t *)a2 + 5);
      v74 = (float32x4_t *)(v6 + v18);
      v74[-1] = vaddq_f32(v20, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v73, (int8x16_t)v71, (int8x16_t)vaddq_f32(v66, vmulq_laneq_f32(vsubq_f32(v71, v66), v20, 3))), v20), v66, 3));
      *v74 = vaddq_f32(v19, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v73, (int8x16_t)v72, (int8x16_t)vaddq_f32(v67, vmulq_laneq_f32(vsubq_f32(v72, v67), v19, 3))), v19), v67, 3));
      v17 -= 2;
      v18 += 32;
    }
    while (v5 + v17 > 1);
    v75 = -v17;
    if (v75 >= v5)
      goto LABEL_3;
LABEL_10:
    v76 = 16 * v75;
    v77 = *(float32x4_t *)(v8 + v76);
    v78 = *((float32x4_t *)a2 + 55);
    v79 = *((float32x4_t *)a2 + 27);
    v80 = *((float32x4_t *)a2 + 28);
    v81 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v77, v78), 3), v79), v80);
    v82 = vminq_f32(vmaxq_f32(vrecpeq_f32(v81), v79), v80);
    v83 = vminq_f32(vmaxq_f32(vmulq_f32(v82, vrecpsq_f32(v81, v82)), v79), v80);
    v84 = vmulq_f32(v77, vmulq_f32(v83, vrecpsq_f32(v81, v83)));
    v85 = vminq_f32(vrsqrteq_f32(v84), v80);
    v86 = vminq_f32(vmulq_f32(v85, vrsqrtsq_f32(vmulq_f32(v84, v85), v85)), v80);
    v87 = vbslq_s8((int8x16_t)vcgtq_f32(v84, v80), _Q0, (int8x16_t)vminq_f32(vmulq_f32(v86, vrsqrtsq_f32(vmulq_f32(v84, v86), v86)), v80));
    v88 = *((float32x4_t *)a2 + 59);
    v89 = *((float32x4_t *)a2 + 29);
    v90 = *((float32x4_t *)a2 + 32);
    v91 = vmulq_f32(v84, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v89, (int8x16_t)vcgeq_f32(v88, v84)), v90), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 58), vmulq_f32(v84, vaddq_f32(*((float32x4_t *)a2 + 56), vmulq_f32(v84, *((float32x4_t *)a2 + 57))))), v87));
    v92 = vmulq_f32(*(float32x4_t *)(v7 + v76), *(float32x4_t *)a2);
    v93 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v92, v88), 3), v79), v80);
    v94 = vminq_f32(vmaxq_f32(vrecpeq_f32(v93), v79), v80);
    v95 = vminq_f32(vmaxq_f32(vmulq_f32(v94, vrecpsq_f32(v93, v94)), v79), v80);
    v96 = vmulq_f32(v95, vrecpsq_f32(v93, v95));
    v96.i32[3] = 1.0;
    v97 = vmulq_f32(v92, v96);
    v98 = vsubq_f32(v89, vmulq_f32(v78, v97));
    v99 = vsubq_f32(v84, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v89, (int8x16_t)vcgeq_f32(*((float32x4_t *)a2 + 13), v97)), v90), (int8x16_t)vmulq_f32(vsubq_f32(v89, v84), vmulq_f32(v84, v98)), (int8x16_t)vmulq_f32(vsubq_f32(v91, v84), v98)));
    v99.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v76) = vaddq_f32(v77, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v99, (int8x16_t)vaddq_f32(v97, vmulq_laneq_f32(vsubq_f32(v99, v97), v77, 3))), v77), v97, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendSoftLightPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  int8x16_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t v106;
  int32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    __asm { FMOV            V0.4S, #1.0 }
    v101 = _Q0;
    do
    {
      v17 = 0;
      do
      {
        v18 = *((float32x4_t *)a2 + 59);
        v119 = *(float32x4_t *)(v5 + v17);
        v20 = *((float32x4_t *)a2 + 27);
        v19 = *((float32x4_t *)a2 + 28);
        v21 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v119, v18), 3), v20), v19);
        v22 = vminq_f32(vmaxq_f32(vrecpeq_f32(v21), v20), v19);
        v23 = vminq_f32(vmaxq_f32(vmulq_f32(v22, vrecpsq_f32(v21, v22)), v20), v19);
        v24 = *((float32x4_t *)a2 + 32);
        v25 = *((float32x4_t *)a2 + 1);
        v26 = *((float32x4_t *)a2 + 29);
        v27 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vceqq_f32(v25, v24)), v24);
        v28 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v26, (int8x16_t)vmaxq_f32(vmulq_f32(v119, vmulq_f32(v23, vrecpsq_f32(v21, v23))), v24));
        v118 = *((float32x4_t *)a2 + 9);
        v29 = (int8x16_t)vcgtq_f32(v118, v28);
        v30 = (int8x16_t)vmulq_f32(v28, vaddq_f32(v26, (float32x4_t)vandq_s8(*((int8x16_t *)a2 + 33), v29)));
        v31 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 8), v30), (int8x16_t)v26);
        v32 = *((float32x4_t *)a2 + 4);
        v33 = *((float32x4_t *)a2 + 10);
        v34 = *((int8x16_t *)a2 + 35);
        v103 = *((int8x16_t *)a2 + 34);
        v35 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vceqq_f32(v33, v28)), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v28, v32), v103), (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vceqq_f32(v32, v28))), (float32x4_t)vandq_s8(v34, v29))), *((float32x4_t *)a2 + 11)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)));
        v117 = *((float32x4_t *)a2 + 12);
        v36 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v31, v117));
        v37 = vaddq_f32(v35, v36);
        v102 = *((float32x4_t *)a2 + 13);
        v38 = vsubq_f32(vsubq_f32(v31, v26), vmulq_f32(vmulq_f32(v102, v36), v31));
        v39 = vmulq_f32(v38, v38);
        v40 = *((float32x4_t *)a2 + 36);
        v104 = *((float32x4_t *)a2 + 37);
        v115 = *((float32x4_t *)a2 + 38);
        v116 = *((float32x4_t *)a2 + 39);
        v41 = *((float32x4_t *)a2 + 40);
        v114 = *((float32x4_t *)a2 + 42);
        v110 = *((float32x4_t *)a2 + 44);
        v111 = *((float32x4_t *)a2 + 45);
        v42 = vmulq_f32(v25, vaddq_f32(v37, vmulq_f32(v38, vaddq_f32(v110, vmulq_f32(v38, vaddq_f32(vaddq_f32(vaddq_f32(v114, vmulq_f32(v38, *((float32x4_t *)a2 + 43))), vmulq_f32(v39, vaddq_f32(v41, vmulq_f32(*((float32x4_t *)a2 + 41), v38)))), vmulq_f32(vmulq_f32(v39, v39), vaddq_f32(vaddq_f32(v115, vmulq_f32(v116, v38)), vmulq_f32(v39, vaddq_f32(v40, vmulq_f32(v104, v38)))))))))));
        v113 = *((float32x4_t *)a2 + 46);
        v120 = *((float32x4_t *)a2 + 47);
        v43 = vminq_f32(vmaxq_f32(v42, v111), v113);
        v44 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
        v45 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v44, v43)));
        v46 = vsubq_f32(v43, v45);
        v108 = *((float32x4_t *)a2 + 49);
        v109 = *((float32x4_t *)a2 + 48);
        v105 = *((float32x4_t *)a2 + 50);
        v47 = vmulq_f32(v46, v46);
        v121 = *((float32x4_t *)a2 + 51);
        v122 = *((float32x4_t *)a2 + 52);
        v123 = *((float32x4_t *)a2 + 53);
        v48 = (int8x16_t)vcgtq_f32(v123, v45);
        v107 = *((int32x4_t *)a2 + 22);
        v106 = *((int8x16_t *)a2 + 54);
        v49 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, vorrq_s8((int8x16_t)vcltzq_f32(v42), (int8x16_t)vcgezq_f32(v42))), v24), (int8x16_t)vmulq_f32(vaddq_f32(v26, (float32x4_t)vandq_s8(v106, v48)), vmulq_f32(vaddq_f32(v26, vmulq_f32(v46, vaddq_f32(vaddq_f32(v121, vmulq_f32(v46, v122)), vmulq_f32(v47, vaddq_f32(
                                                      vaddq_f32(v108, vmulq_f32(v105, v46)),
                                                      vmulq_f32(v47, vaddq_f32(v120, vmulq_f32(v109, v46)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(v107, vcvtq_s32_f32(vaddq_f32(v45, (float32x4_t)vandq_s8(v34, v48)))), 0x17uLL))), (int8x16_t)v42);
        v50 = vminq_f32(vrsqrteq_f32(v49), v19);
        v51 = vminq_f32(vmulq_f32(v50, vrsqrtsq_f32(vmulq_f32(v50, v49), v50)), v19);
        v52 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v18, v49)), v24), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 58), vmulq_f32(v49, vaddq_f32(*((float32x4_t *)a2 + 56), vmulq_f32(*((float32x4_t *)a2 + 57), v49)))), vbslq_s8((int8x16_t)vcgtq_f32(v49, v19), v101, (int8x16_t)vminq_f32(vmulq_f32(v51, vrsqrtsq_f32(vmulq_f32(v49, v51), v51)), v19)));
        v53 = vmulq_f32(*(float32x4_t *)(v6 + v17), *(float32x4_t *)a2);
        v54 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v53, v18), 3), v20), v19);
        v55 = vminq_f32(vmaxq_f32(vrecpeq_f32(v54), v20), v19);
        v56 = vminq_f32(vmaxq_f32(vmulq_f32(v55, vrecpsq_f32(v54, v55)), v20), v19);
        v112 = vmulq_f32(v53, vmulq_f32(v56, vrecpsq_f32(v54, v56)));
        v57 = *((int8x16_t *)a2 + 5);
        v58 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v26, vbslq_s8(v57, (int8x16_t)v53, (int8x16_t)vmaxq_f32(v112, v24)));
        v59 = (int8x16_t)vcgtq_f32(v118, v58);
        v60 = vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v58, v32), v103), (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vceqq_f32(v32, v58))), (float32x4_t)vandq_s8(v34, v59));
        v61 = *((int8x16_t *)a2 + 33);
        v62 = (int8x16_t)vmulq_f32(vaddq_f32(v26, (float32x4_t)vandq_s8(v61, v59)), v58);
        v63 = *((float32x4_t *)a2 + 11);
        v64 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vceqq_f32(v33, v58)), v60), v63), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v62, 0x17uLL)));
        v65 = *((int8x16_t *)a2 + 8);
        v66 = (float32x4_t)vorrq_s8(vandq_s8(v65, v62), (int8x16_t)v26);
        v67 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v66, v117));
        v68 = vaddq_f32(v64, v67);
        v69 = vsubq_f32(vsubq_f32(v66, v26), vmulq_f32(vmulq_f32(v102, v67), v66));
        v70 = vmulq_f32(v69, v69);
        v71 = vaddq_f32(vaddq_f32(v115, vmulq_f32(v116, v69)), vmulq_f32(v70, vaddq_f32(v40, vmulq_f32(v104, v69))));
        v72 = *((float32x4_t *)a2 + 41);
        v73 = vmulq_f32(v25, vaddq_f32(v68, vmulq_f32(v69, vaddq_f32(v110, vmulq_f32(v69, vaddq_f32(vaddq_f32(vaddq_f32(v114, vmulq_f32(*((float32x4_t *)a2 + 43), v69)), vmulq_f32(v70, vaddq_f32(v41, vmulq_f32(v72, v69)))), vmulq_f32(vmulq_f32(v70, v70), v71)))))));
        v74 = vminq_f32(vmaxq_f32(v73, v111), v113);
        v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
        v76 = vsubq_f32(v75, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v75, v74)));
        v77 = vsubq_f32(v74, v76);
        v78 = vmulq_f32(v77, v77);
        v79 = (int8x16_t)vcgtq_f32(v123, v76);
        v80 = (float32x4_t)vbslq_s8(v57, (int8x16_t)v53, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, vorrq_s8((int8x16_t)vcltzq_f32(v73), (int8x16_t)vcgezq_f32(v73))), v24), (int8x16_t)vmulq_f32(vaddq_f32(v26, (float32x4_t)vandq_s8(v106, v79)), vmulq_f32(vaddq_f32(v26, vmulq_f32(v77, vaddq_f32(vaddq_f32(v121, vmulq_f32(v122, v77)),
                                                    vmulq_f32(v78, vaddq_f32(vaddq_f32(v108, vmulq_f32(v105, v77)), vmulq_f32(v78, vaddq_f32(v120, vmulq_f32(v109, v77)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(vaddq_f32(v76, (float32x4_t)vandq_s8(v34, v79))), v107), 0x17uLL))), (int8x16_t)v73));
        v81 = vsubq_f32(v26, vmulq_f32(*((float32x4_t *)a2 + 55), v80));
        v82 = *((float32x4_t *)a2 + 2);
        v83 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vceqq_f32(v82, v24)), v24), (int8x16_t)v26, (int8x16_t)vsubq_f32(v49, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v102, v80)), v24), (int8x16_t)vmulq_f32(vsubq_f32(v26, v49), vmulq_f32(v49, v81)), (int8x16_t)vmulq_f32(vsubq_f32(vmulq_f32(v49, v52), v49), v81))));
        v84 = (int8x16_t)vcgtq_f32(v118, v83);
        v85 = vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v83, v32), v103), (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vceqq_f32(v83, v32))), (float32x4_t)vandq_s8(v34, v84));
        v86 = (int8x16_t)vmulq_f32(v83, vaddq_f32(v26, (float32x4_t)vandq_s8(v61, v84)));
        v87 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vceqq_f32(v83, v33)), v85), v63), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v86, 0x17uLL)));
        v88 = (float32x4_t)vorrq_s8(vandq_s8(v65, v86), (int8x16_t)v26);
        v89 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v88, v117));
        v90 = vsubq_f32(vsubq_f32(v88, v26), vmulq_f32(vmulq_f32(v102, v89), v88));
        v91 = vmulq_f32(v90, v90);
        v92 = vmulq_f32(v82, vaddq_f32(vaddq_f32(v87, v89), vmulq_f32(v90, vaddq_f32(v110, vmulq_f32(v90, vaddq_f32(vaddq_f32(vaddq_f32(v114, vmulq_f32(*((float32x4_t *)a2 + 43), v90)), vmulq_f32(v91, vaddq_f32(v41, vmulq_f32(v72, v90)))), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(vaddq_f32(v115, vmulq_f32(v116, v90)), vmulq_f32(v91, vaddq_f32(*((float32x4_t *)a2 + 36), vmulq_f32(v104, v90)))))))))));
        v93 = vminq_f32(vmaxq_f32(v92, v111), v113);
        v94 = vcvtq_f32_s32(vcvtq_s32_f32(v93));
        v95 = vsubq_f32(v94, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v94, v93)));
        v96 = vsubq_f32(v93, v95);
        v97 = vmulq_f32(v96, v96);
        v98 = (int8x16_t)vcgtq_f32(v123, v95);
        v99 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v26, vorrq_s8((int8x16_t)vcltzq_f32(v92), (int8x16_t)vcgezq_f32(v92))), v24), (int8x16_t)vmulq_f32(vaddq_f32(v26, (float32x4_t)vandq_s8(v106, v98)), vmulq_f32(vaddq_f32(v26, vmulq_f32(v96, vaddq_f32(vaddq_f32(v121, vmulq_f32(v122, v96)), vmulq_f32(v97, vaddq_f32(
                                                      vaddq_f32(v108, vmulq_f32(v105, v96)),
                                                      vmulq_f32(v97, vaddq_f32(v120, vmulq_f32(v109, v96)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(vaddq_f32(v95, (float32x4_t)vandq_s8(v34, v98))), v107), 0x17uLL))), (int8x16_t)v92);
        v99.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v17) = vaddq_f32(v119, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v57, (int8x16_t)v99, (int8x16_t)vaddq_f32(v112, vmulq_laneq_f32(vsubq_f32(v99, v112), v119, 3))), v119), v80, 3));
        v17 += 16;
      }
      while (v11 != v17);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendSoftLightQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  float32x4_t v93;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  int8x16_t v112;
  int8x16_t v113;
  int8x16_t v114;
  float32x4_t v115;
  float32x4_t v116;
  int32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    __asm { FMOV            V0.4S, #1.0 }
    v95 = _Q0;
    do
    {
      v17 = 0;
      do
      {
        v116 = *((float32x4_t *)a2 + 59);
        v120 = *(float32x4_t *)(v5 + v17);
        v19 = *((float32x4_t *)a2 + 27);
        v18 = *((float32x4_t *)a2 + 28);
        v20 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v120, v116), 3), v19), v18);
        v21 = vminq_f32(vmaxq_f32(vrecpeq_f32(v20), v19), v18);
        v22 = vminq_f32(vmaxq_f32(vmulq_f32(v21, vrecpsq_f32(v20, v21)), v19), v18);
        v23 = *((float32x4_t *)a2 + 32);
        v119 = *((float32x4_t *)a2 + 23);
        v117 = *((int32x4_t *)a2 + 22);
        v115 = *((float32x4_t *)a2 + 25);
        v99 = *((float32x4_t *)a2 + 24);
        v24 = *((float32x4_t *)a2 + 29);
        v114 = *((int8x16_t *)a2 + 33);
        v25 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vceqq_f32(v99, v23)), v23);
        v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v24, (int8x16_t)vminq_f32(vmaxq_f32(vmulq_f32(v120, vmulq_f32(v22, vrecpsq_f32(v20, v22))), v23), v119));
        v27 = (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 9), v26);
        v28 = (int8x16_t)vmulq_f32(v26, vaddq_f32(v24, (float32x4_t)vandq_s8(v114, v27)));
        v29 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 8), v28), (int8x16_t)v24);
        v30 = *((float32x4_t *)a2 + 4);
        v112 = *((int8x16_t *)a2 + 5);
        v113 = *((int8x16_t *)a2 + 8);
        v32 = *((float32x4_t *)a2 + 10);
        v31 = *((float32x4_t *)a2 + 11);
        v33 = *((int8x16_t *)a2 + 34);
        v34 = *((int8x16_t *)a2 + 35);
        v35 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vceqq_f32(v32, v26)), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v26, v30), v33), (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vceqq_f32(v30, v26))), (float32x4_t)vandq_s8(v34, v27))), v31), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)));
        v36 = *((float32x4_t *)a2 + 13);
        v109 = *((float32x4_t *)a2 + 12);
        v37 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v29, v109));
        v38 = vaddq_f32(v35, v37);
        v39 = vsubq_f32(vsubq_f32(v29, v24), vmulq_f32(vmulq_f32(v36, v37), v29));
        v40 = *((float32x4_t *)a2 + 36);
        v97 = *((float32x4_t *)a2 + 39);
        v98 = *((float32x4_t *)a2 + 38);
        v41 = vmulq_f32(v39, v39);
        v107 = *((float32x4_t *)a2 + 41);
        v110 = *((float32x4_t *)a2 + 42);
        v111 = *((float32x4_t *)a2 + 43);
        v102 = *((float32x4_t *)a2 + 44);
        v42 = vmulq_f32(v99, vaddq_f32(v38, vmulq_f32(v39, vaddq_f32(v102, vmulq_f32(v39, vaddq_f32(vaddq_f32(vaddq_f32(v110, vmulq_f32(v39, v111)), vmulq_f32(v41, vaddq_f32(*((float32x4_t *)a2 + 40), vmulq_f32(v107, v39)))), vmulq_f32(vmulq_f32(v41, v41), vaddq_f32(vaddq_f32(v98, vmulq_f32(v97, v39)), vmulq_f32(v41, vaddq_f32(v40, vmulq_f32(*((float32x4_t *)a2 + 37), v39)))))))))));
        v108 = *((float32x4_t *)a2 + 46);
        v43 = vminq_f32(vmaxq_f32(v42, *((float32x4_t *)a2 + 45)), v108);
        v44 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
        v45 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v44, v43)));
        v46 = vsubq_f32(v43, v45);
        v105 = *((float32x4_t *)a2 + 47);
        v106 = *((float32x4_t *)a2 + 48);
        v104 = *((float32x4_t *)a2 + 49);
        v96 = *((float32x4_t *)a2 + 50);
        v47 = vmulq_f32(v46, v46);
        v100 = *((float32x4_t *)a2 + 51);
        v101 = *((float32x4_t *)a2 + 53);
        v48 = (int8x16_t)vcgtq_f32(v101, v45);
        v103 = *((int8x16_t *)a2 + 54);
        v49 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, vorrq_s8((int8x16_t)vcltzq_f32(v42), (int8x16_t)vcgezq_f32(v42))), v23), (int8x16_t)vmulq_f32(vaddq_f32(v24, (float32x4_t)vandq_s8(v103, v48)), vmulq_f32(vaddq_f32(v24, vmulq_f32(v46, vaddq_f32(vaddq_f32(v100, vmulq_f32(v46, *((float32x4_t *)a2 + 52))), vmulq_f32(v47, vaddq_f32(
                                                      vaddq_f32(v104, vmulq_f32(v96, v46)),
                                                      vmulq_f32(v47, vaddq_f32(v105, vmulq_f32(v106, v46)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(v117, vcvtq_s32_f32(vaddq_f32(v45, (float32x4_t)vandq_s8(v34, v48)))), 0x17uLL))), (int8x16_t)v42);
        v50 = vminq_f32(vrsqrteq_f32(v49), v18);
        v51 = vminq_f32(vmulq_f32(v50, vrsqrtsq_f32(vmulq_f32(v50, v49), v50)), v18);
        v118 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgeq_f32(v116, v49)), v23), (int8x16_t)vaddq_f32(*((float32x4_t *)a2 + 58), vmulq_f32(v49, vaddq_f32(*((float32x4_t *)a2 + 56), vmulq_f32(*((float32x4_t *)a2 + 57), v49)))), vbslq_s8((int8x16_t)vcgtq_f32(v49, v18), v95, (int8x16_t)vminq_f32(vmulq_f32(v51, vrsqrtsq_f32(vmulq_f32(v49, v51), v51)), v18)));
        v52 = vmulq_f32(*(float32x4_t *)(v6 + v17), *(float32x4_t *)a2);
        v53 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmaxq_f32(v52, v116), 3), v19), v18);
        v54 = vminq_f32(vmaxq_f32(vrecpeq_f32(v53), v19), v18);
        v55 = vminq_f32(vmaxq_f32(vmulq_f32(v54, vrecpsq_f32(v53, v54)), v19), v18);
        v56 = vmulq_f32(v52, vmulq_f32(v55, vrecpsq_f32(v53, v55)));
        v57 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v24, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v112, (int8x16_t)v52, (int8x16_t)vmaxq_f32(v56, v23)), v119));
        v58 = *((float32x4_t *)a2 + 9);
        v59 = (int8x16_t)vcgtq_f32(v58, v57);
        v60 = vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v57, v30), v33), (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vceqq_f32(v57, v30))), (float32x4_t)vandq_s8(v34, v59));
        v61 = (int8x16_t)vmulq_f32(v57, vaddq_f32(v24, (float32x4_t)vandq_s8(v114, v59)));
        v62 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vceqq_f32(v57, v32)), v60), v31), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v61, 0x17uLL)));
        v63 = (float32x4_t)vorrq_s8(vandq_s8(v113, v61), (int8x16_t)v24);
        v64 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v63, v109));
        v65 = vsubq_f32(vsubq_f32(v63, v24), vmulq_f32(vmulq_f32(v36, v64), v63));
        v66 = vmulq_f32(v65, v65);
        v67 = vmulq_f32(v99, vaddq_f32(vaddq_f32(v62, v64), vmulq_f32(v65, vaddq_f32(v102, vmulq_f32(v65, vaddq_f32(vaddq_f32(vaddq_f32(v110, vmulq_f32(v111, v65)), vmulq_f32(v66, vaddq_f32(*((float32x4_t *)a2 + 40), vmulq_f32(v107, v65)))), vmulq_f32(vmulq_f32(v66, v66), vaddq_f32(vaddq_f32(v98, vmulq_f32(v97, v65)), vmulq_f32(v66, vaddq_f32(v40, vmulq_f32(*((float32x4_t *)a2 + 37), v65)))))))))));
        v68 = vminq_f32(vmaxq_f32(v67, *((float32x4_t *)a2 + 45)), v108);
        v69 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
        v70 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v69, v68)));
        v71 = vsubq_f32(v68, v70);
        v72 = vmulq_f32(v71, v71);
        v73 = *((float32x4_t *)a2 + 52);
        v74 = (int8x16_t)vcgtq_f32(v101, v70);
        v75 = (float32x4_t)vbslq_s8(v112, (int8x16_t)v52, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, vorrq_s8((int8x16_t)vcltzq_f32(v67), (int8x16_t)vcgezq_f32(v67))), v23), (int8x16_t)vmulq_f32(vaddq_f32(v24, (float32x4_t)vandq_s8(v103, v74)), vmulq_f32(vaddq_f32(v24, vmulq_f32(v71, vaddq_f32(vaddq_f32(v100, vmulq_f32(v73, v71)),
                                                    vmulq_f32(v72, vaddq_f32(vaddq_f32(v104, vmulq_f32(v96, v71)), vmulq_f32(v72, vaddq_f32(v105, vmulq_f32(v106, v71)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(vaddq_f32(v70, (float32x4_t)vandq_s8(v34, v74))), v117), 0x17uLL))), (int8x16_t)v67));
        v76 = vsubq_f32(v24, vmulq_f32(*((float32x4_t *)a2 + 55), v75));
        v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vceqq_f32(v115, v23)), v23), (int8x16_t)v24, (int8x16_t)vminq_f32(vmaxq_f32(vsubq_f32(v49, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgeq_f32(v36, v75)), v23), (int8x16_t)vmulq_f32(vsubq_f32(v24, v49), vmulq_f32(v49, v76)), (int8x16_t)vmulq_f32(vsubq_f32(vmulq_f32(v49, v118), v49),
                                                                          v76))),
                                            v23),
                                          *((float32x4_t *)a2 + 30)));
        v78 = (int8x16_t)vcgtq_f32(v58, v77);
        v79 = vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v77, v30), *((int8x16_t *)a2 + 34)), (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vceqq_f32(v77, v30))), (float32x4_t)vandq_s8(v34, v78));
        v80 = (int8x16_t)vmulq_f32(v77, vaddq_f32(v24, (float32x4_t)vandq_s8(v114, v78)));
        v81 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vceqq_f32(v77, v32)), v79), v31), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v80, 0x17uLL)));
        v82 = (float32x4_t)vorrq_s8(vandq_s8(v113, v80), (int8x16_t)v24);
        v83 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v82, v109));
        v84 = vsubq_f32(vsubq_f32(v82, v24), vmulq_f32(vmulq_f32(v36, v83), v82));
        v85 = vmulq_f32(v84, v84);
        v86 = vmulq_f32(v115, vaddq_f32(vaddq_f32(v81, v83), vmulq_f32(v84, vaddq_f32(v102, vmulq_f32(v84, vaddq_f32(vaddq_f32(vaddq_f32(v110, vmulq_f32(v111, v84)), vmulq_f32(v85, vaddq_f32(*((float32x4_t *)a2 + 40), vmulq_f32(v107, v84)))), vmulq_f32(vmulq_f32(v85, v85), vaddq_f32(vaddq_f32(v98, vmulq_f32(v97, v84)), vmulq_f32(v85,
                                vaddq_f32(*((float32x4_t *)a2 + 36), vmulq_f32(*((float32x4_t *)a2 + 37), v84)))))))))));
        v87 = vminq_f32(vmaxq_f32(v86, *((float32x4_t *)a2 + 45)), v108);
        v88 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
        v89 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v88, v87)));
        v90 = vsubq_f32(v87, v89);
        v91 = vmulq_f32(v90, v90);
        v92 = (int8x16_t)vcgtq_f32(v101, v89);
        v93 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, vorrq_s8((int8x16_t)vcltzq_f32(v86), (int8x16_t)vcgezq_f32(v86))), v23), (int8x16_t)vmulq_f32(vaddq_f32(v24, (float32x4_t)vandq_s8(v103, v92)), vmulq_f32(vaddq_f32(v24, vmulq_f32(v90, vaddq_f32(vaddq_f32(v100, vmulq_f32(v73, v90)), vmulq_f32(v91, vaddq_f32(
                                                      vaddq_f32(v104, vmulq_f32(v96, v90)),
                                                      vmulq_f32(v91, vaddq_f32(v105, vmulq_f32(v106, v90)))))))),
                                            (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(vaddq_f32(v89, (float32x4_t)vandq_s8(v34, v92))), v117), 0x17uLL))), (int8x16_t)v86);
        v93.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v17) = vaddq_f32(v120, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v112, (int8x16_t)v93, (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(vsubq_f32(v93, v56), v120, 3))), v120), v75, 3));
        v17 += 16;
      }
      while (v11 != v17);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendHardLightTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t *v49;
  int v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v50 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *a2);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13), *a2);
      v17 = (int8x16_t)a2[5];
      v16 = a2[6];
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v20 = a2[7];
      v21 = vmulq_f32(vrecpeq_f32(v18), v20);
      v22 = vmulq_f32(vrecpeq_f32(v19), v20);
      v23 = vmulq_f32(v21, vrecpsq_f32(v21, v18));
      v24 = vmulq_f32(v22, vrecpsq_f32(v22, v19));
      v25 = *(float32x4_t *)(v7 + v13 - 16);
      v26 = *(float32x4_t *)(v7 + v13);
      v27 = vmulq_f32(v14, v23);
      v28 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3), v16);
      v29 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3), v16);
      v30 = vmulq_f32(v15, v24);
      v31 = vmulq_f32(v20, vrecpeq_f32(v28));
      v32 = vmulq_f32(v20, vrecpeq_f32(v29));
      v33 = vmulq_f32(v32, vrecpsq_f32(v32, v29));
      v34 = vmulq_f32(v25, vmulq_f32(v31, vrecpsq_f32(v31, v28)));
      v35 = vaddq_f32(v27, v27);
      v36 = vaddq_f32(v30, v30);
      v37 = a2[29];
      v38 = vmulq_f32(v26, v33);
      v39 = vsubq_f32(v35, v37);
      v40 = vsubq_f32(v36, v37);
      v41 = vsubq_f32(vaddq_f32(v34, v39), vminq_f32(v34, vminq_f32(v39, vmulq_f32(v34, v39))));
      v42 = vsubq_f32(vaddq_f32(v38, v40), vminq_f32(v38, vminq_f32(v40, vmulq_f32(v38, v40))));
      v43 = vmulq_f32(v35, v34);
      v44 = a2[60];
      v45 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v14, (int8x16_t)vmulq_f32(v14, v44));
      v46 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v15, (int8x16_t)vmulq_f32(v15, v44));
      v47 = vaddq_f32(v41, vmulq_f32(vsubq_f32(v43, v41), (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v45, vnegq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 3))), (int8x16_t)v37, (int8x16_t)0)));
      v47.i32[3] = 1.0;
      v48 = vaddq_f32(v42, vmulq_f32(vsubq_f32(vmulq_f32(v36, v38), v42), (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v46, vnegq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v46, 3))), (int8x16_t)v37, (int8x16_t)0)));
      v48.i32[3] = 1.0;
      v49 = (float32x4_t *)(v6 + v13);
      v49[-1] = vaddq_f32(v25, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v47, (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(vsubq_f32(v47, v27), v25, 3))), v25), v45, 3));
      *v49 = vaddq_f32(v26, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v48, (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(vsubq_f32(v48, v30), v26, 3))), v26), v46, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v50 = -v12;
    if (v50 >= v5)
      goto LABEL_3;
LABEL_10:
    v51 = 16 * v50;
    v52 = vmulq_f32(*(float32x4_t *)(v8 + v51), *a2);
    v54 = (int8x16_t)a2[5];
    v53 = a2[6];
    v55 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), v53);
    v56 = a2[7];
    v57 = vmulq_f32(vrecpeq_f32(v55), v56);
    v58 = vmulq_f32(v52, vmulq_f32(v57, vrecpsq_f32(v57, v55)));
    v59 = *(float32x4_t *)(v7 + v51);
    v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v53);
    v61 = vmulq_f32(v56, vrecpeq_f32(v60));
    v62 = vmulq_f32(v59, vmulq_f32(v61, vrecpsq_f32(v61, v60)));
    v63 = vaddq_f32(v58, v58);
    v64 = a2[29];
    v65 = vsubq_f32(v63, v64);
    v66 = vsubq_f32(vaddq_f32(v62, v65), vminq_f32(v62, vminq_f32(v65, vmulq_f32(v62, v65))));
    v67 = (float32x4_t)vbslq_s8(v54, (int8x16_t)v52, (int8x16_t)vmulq_f32(v52, a2[60]));
    v68 = vaddq_f32(v66, vmulq_f32(vsubq_f32(vmulq_f32(v63, v62), v66), (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v67, vnegq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3))), (int8x16_t)v64, (int8x16_t)0)));
    v68.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v51) = vaddq_f32(v59, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v54, (int8x16_t)v68, (int8x16_t)vaddq_f32(v58, vmulq_laneq_f32(vsubq_f32(v68, v58), v59, 3))), v59), v67, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendHardLightPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t *v123;
  int v124;
  uint64_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  int8x16_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  int32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  int8x16_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v185;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v124 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v185 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v185, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v25 = *((int8x16_t *)a2 + 31);
      v24 = *((float32x4_t *)a2 + 32);
      v26 = vmaxq_f32(vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18))), v24);
      v27 = vmaxq_f32(vmulq_f32(v185, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v24);
      v28 = *((float32x4_t *)a2 + 29);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v26), (int8x16_t)v28);
      v30 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v27), (int8x16_t)v28);
      v32 = *((float32x4_t *)a2 + 9);
      v31 = *((int8x16_t *)a2 + 10);
      v34 = *((float32x4_t *)a2 + 11);
      v33 = *((float32x4_t *)a2 + 12);
      v35 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v27))), v34);
      v36 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v29, v33));
      v37 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v30, v33));
      v39 = *((float32x4_t *)a2 + 13);
      v38 = *((float32x4_t *)a2 + 14);
      v40 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v26))), v34), v36);
      v41 = vmulq_f32(v39, v36);
      v42 = vmulq_f32(vmulq_f32(v39, v37), v30);
      v43 = vaddq_f32(v35, v37);
      v44 = vsubq_f32(vsubq_f32(v29, v28), vmulq_f32(v41, v29));
      v45 = vsubq_f32(vsubq_f32(v30, v28), v42);
      v47 = *((float32x4_t *)a2 + 15);
      v46 = *((float32x4_t *)a2 + 16);
      v49 = *((float32x4_t *)a2 + 17);
      v48 = *((float32x4_t *)a2 + 18);
      v50 = *((float32x4_t *)a2 + 1);
      v51 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v40, vmulq_f32(v44, vaddq_f32(vaddq_f32(v46, vmulq_f32(v44, v49)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v38, vmulq_f32(v47, v44))))))), v48);
      v52 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v46, vmulq_f32(v45, v49)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v38, vmulq_f32(v47, v45))))))), v48);
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v54, v52)));
      v57 = *((float32x4_t *)a2 + 19);
      v58 = *((float32x4_t *)a2 + 20);
      v59 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v60 = vsubq_f32(v51, v55);
      v61 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v16);
      v63 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 3), v16);
      v64 = vmulq_f32(v21, vrecpeq_f32(v62));
      v65 = vmulq_f32(v21, vrecpeq_f32(v63));
      v66 = (int8x16_t)vmulq_f32(v64, vrecpsq_f32(v64, v62));
      v68 = *((float32x4_t *)a2 + 21);
      v67 = *((int32x4_t *)a2 + 22);
      v69 = vmulq_f32(v59, (float32x4_t)vorrq_s8(vandq_s8(v25, v66), (int8x16_t)v24));
      v70 = vmulq_f32(v61, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v65, vrecpsq_f32(v65, v63))), (int8x16_t)v24));
      v71 = vmaxq_f32(v69, v24);
      v72 = vmaxq_f32(v70, v24);
      v73 = vmulq_f32(v60, vaddq_f32(v68, vmulq_f32(v60, vaddq_f32(v57, vmulq_f32(v58, v60)))));
      v74 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v71), (int8x16_t)v28);
      v75 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v72), (int8x16_t)v28);
      v76 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v74, v33));
      v77 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v71, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v71))), v34), v76);
      v78 = vsubq_f32(vsubq_f32(v74, v28), vmulq_f32(vmulq_f32(v39, v76), v74));
      v79 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v75, v33));
      v80 = vsubq_f32(v52, v56);
      v81 = vsubq_f32(vsubq_f32(v75, v28), vmulq_f32(vmulq_f32(v39, v79), v75));
      v82 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(v77, vmulq_f32(v78, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v38, vmulq_f32(v47, v78))))))), v48);
      v83 = vmaxq_f32(vmulq_f32(v50, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v72))), v34), v79), vmulq_f32(v81, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v81)), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(v38, vmulq_f32(v47, v81))))))), v48);
      v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      v85 = vmulq_f32(vaddq_f32(v28, v73), (float32x4_t)vshlq_n_s32(vaddq_s32(v67, vcvtq_s32_f32(v55)), 0x17uLL));
      v86 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      v87 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v84, v82)));
      v88 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v86, v83)));
      v89 = vsubq_f32(v82, v87);
      v90 = vsubq_f32(v83, v88);
      v91 = vcvtq_s32_f32(v56);
      v12 = 1.0;
      v92 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v80, vaddq_f32(v68, vmulq_f32(v80, vaddq_f32(v57, vmulq_f32(v58, v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v67, v91), 0x17uLL));
      v93 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v89, vaddq_f32(v68, vmulq_f32(v89, vaddq_f32(v57, vmulq_f32(v58, v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v87), v67), 0x17uLL));
      v94 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v90, vaddq_f32(v68, vmulq_f32(v90, vaddq_f32(v57, vmulq_f32(v58, v90)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v88), v67), 0x17uLL));
      v95 = vaddq_f32(v93, v93);
      v96 = (int8x16_t)vmulq_f32(v85, v95);
      v97 = vsubq_f32(v95, v28);
      v98 = (int8x16_t)vsubq_f32(vaddq_f32(v85, v97), vminq_f32(vminq_f32(vmulq_f32(v85, v97), v97), v85));
      v99 = vaddq_f32(v94, v94);
      v100 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgeq_f32(v39, v93)), v24), v96, v98);
      v101 = (int8x16_t)vmulq_f32(v92, v99);
      v102 = vsubq_f32(v99, v28);
      v103 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgeq_f32(v39, v94)), v24), v101, (int8x16_t)vsubq_f32(vaddq_f32(v92, v102), vminq_f32(vminq_f32(vmulq_f32(v92, v102), v102), v92)));
      v104 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v100, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v100)));
      v105 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v100), (int8x16_t)v28);
      v106 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v105, v33));
      v107 = vsubq_f32(vsubq_f32(v105, v28), vmulq_f32(vmulq_f32(v39, v106), v105));
      v108 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v103), (int8x16_t)v28);
      v109 = (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v108, v33));
      v110 = vsubq_f32(vsubq_f32(v108, v28), vmulq_f32(vmulq_f32(v39, v109), v108));
      v111 = vaddq_f32(vaddq_f32(vsubq_f32(v104, v34), v106), vmulq_f32(v107, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(v38, vmulq_f32(v47, v107))))));
      v112 = *((float32x4_t *)a2 + 2);
      v113 = vmaxq_f32(vmulq_f32(v112, v111), v48);
      v114 = vmaxq_f32(vmulq_f32(v112, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v103, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v32, v103))), v34), v109), vmulq_f32(v110, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v110)), vmulq_f32(vmulq_f32(v110, v110), vaddq_f32(v38, vmulq_f32(v47, v110))))))), v48);
      v115 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
      v116 = vcvtq_f32_s32(vcvtq_s32_f32(v114));
      v117 = vsubq_f32(v115, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v115, v113)));
      v118 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v116, v114)));
      v119 = vsubq_f32(v113, v117);
      v120 = vsubq_f32(v114, v118);
      v121 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v119, vaddq_f32(v68, vmulq_f32(v119, vaddq_f32(v57, vmulq_f32(v58, v119)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v117), v67), 0x17uLL));
      v121.i32[3] = 1.0;
      v122 = vmulq_f32(vaddq_f32(v28, vmulq_f32(v120, vaddq_f32(v68, vmulq_f32(v120, vaddq_f32(v57, vmulq_f32(v58, v120)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v118), v67), 0x17uLL));
      v122.i32[3] = 1.0;
      v123 = (float32x4_t *)(v6 + v14);
      v123[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v121, (int8x16_t)vaddq_f32(v69, vmulq_laneq_f32(vsubq_f32(v121, v69), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v69, 3));
      *v123 = vaddq_f32(v185, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v122, (int8x16_t)vaddq_f32(v70, vmulq_laneq_f32(vsubq_f32(v122, v70), v185, 3))), v185), v70, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v124 = -v13;
    if (v124 >= v5)
      goto LABEL_3;
LABEL_10:
    v125 = 16 * v124;
    v126 = *(float32x4_t *)(v8 + v125);
    v127 = *((float32x4_t *)a2 + 6);
    v128 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v126, 3), v127);
    v130 = *((float32x4_t *)a2 + 7);
    v129 = *((int8x16_t *)a2 + 8);
    v131 = vmulq_f32(vrecpeq_f32(v128), v130);
    v132 = *((float32x4_t *)a2 + 32);
    v133 = vmaxq_f32(vmulq_f32(v126, vmulq_f32(v131, vrecpsq_f32(v131, v128))), v132);
    v134 = *((float32x4_t *)a2 + 29);
    v135 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v133), (int8x16_t)v134);
    v136 = *((float32x4_t *)a2 + 9);
    v137 = *((int8x16_t *)a2 + 10);
    v138 = *((float32x4_t *)a2 + 11);
    v139 = *((float32x4_t *)a2 + 12);
    v140 = (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v135, v139));
    v141 = *((float32x4_t *)a2 + 13);
    v142 = *((float32x4_t *)a2 + 14);
    v143 = vsubq_f32(vsubq_f32(v135, v134), vmulq_f32(vmulq_f32(v141, v140), v135));
    v144 = *((float32x4_t *)a2 + 15);
    v145 = *((float32x4_t *)a2 + 16);
    v146 = *((float32x4_t *)a2 + 17);
    v147 = *((float32x4_t *)a2 + 18);
    v148 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v133, 0x17uLL)), (float32x4_t)vandq_s8(v137, (int8x16_t)vcgtq_f32(v136, v133))), v138), v140), vmulq_f32(v143, vaddq_f32(vaddq_f32(v145, vmulq_f32(v143, v146)), vmulq_f32(vmulq_f32(v143, v143), vaddq_f32(v142, vmulq_f32(v144, v143))))));
    v149 = *((float32x4_t *)a2 + 1);
    v150 = vmaxq_f32(vmulq_f32(v149, v148), v147);
    v151 = vcvtq_f32_s32(vcvtq_s32_f32(v150));
    v152 = vsubq_f32(v151, (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v151, v150)));
    v153 = vsubq_f32(v150, v152);
    v154 = *((float32x4_t *)a2 + 19);
    v155 = *((float32x4_t *)a2 + 20);
    v156 = *((float32x4_t *)a2 + 21);
    v157 = *((int32x4_t *)a2 + 22);
    v158 = vmulq_f32(vaddq_f32(v134, vmulq_f32(v153, vaddq_f32(v156, vmulq_f32(v153, vaddq_f32(v154, vmulq_f32(v155, v153)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v157, vcvtq_s32_f32(v152)), 0x17uLL));
    v159 = vmulq_f32(*(float32x4_t *)(v7 + v125), *(float32x4_t *)a2);
    v160 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v159, 3), v127);
    v161 = vmulq_f32(v130, vrecpeq_f32(v160));
    v162 = vmulq_f32(v159, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v161, vrecpsq_f32(v161, v160))), (int8x16_t)v132));
    v163 = vmaxq_f32(v162, v132);
    v164 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v163), (int8x16_t)v134);
    v165 = (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v164, v139));
    v166 = vsubq_f32(vsubq_f32(v164, v134), vmulq_f32(vmulq_f32(v141, v165), v164));
    v167 = vmaxq_f32(vmulq_f32(v149, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v163, 0x17uLL)), (float32x4_t)vandq_s8(v137, (int8x16_t)vcgtq_f32(v136, v163))), v138), v165), vmulq_f32(v166, vaddq_f32(vaddq_f32(v145, vmulq_f32(v146, v166)), vmulq_f32(vmulq_f32(v166, v166), vaddq_f32(v142, vmulq_f32(v144, v166))))))), v147);
    v168 = vcvtq_f32_s32(vcvtq_s32_f32(v167));
    v169 = vsubq_f32(v168, (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v168, v167)));
    v170 = vsubq_f32(v167, v169);
    v171 = vmulq_f32(vaddq_f32(v134, vmulq_f32(v170, vaddq_f32(v156, vmulq_f32(v170, vaddq_f32(v154, vmulq_f32(v155, v170)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v169), v157), 0x17uLL));
    v172 = vaddq_f32(v171, v171);
    v173 = (int8x16_t)vmulq_f32(v158, v172);
    v174 = vsubq_f32(v172, v134);
    v175 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgeq_f32(v141, v171)), v132), v173, (int8x16_t)vsubq_f32(vaddq_f32(v158, v174), vminq_f32(vminq_f32(vmulq_f32(v158, v174), v174), v158)));
    v176 = (float32x4_t)vorrq_s8(vandq_s8(v129, (int8x16_t)v175), (int8x16_t)v134);
    v177 = (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v176, v139));
    v178 = vsubq_f32(vsubq_f32(v176, v134), vmulq_f32(vmulq_f32(v141, v177), v176));
    v179 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v175, 0x17uLL)), (float32x4_t)vandq_s8(v137, (int8x16_t)vcgtq_f32(v136, v175))), v138), v177), vmulq_f32(v178, vaddq_f32(vaddq_f32(v145, vmulq_f32(v146, v178)), vmulq_f32(vmulq_f32(v178, v178), vaddq_f32(v142, vmulq_f32(v144, v178))))))), v147);
    v180 = vcvtq_f32_s32(vcvtq_s32_f32(v179));
    v181 = vsubq_f32(v180, (float32x4_t)vandq_s8((int8x16_t)v134, (int8x16_t)vcgtq_f32(v180, v179)));
    v182 = vsubq_f32(v179, v181);
    v183 = vmulq_f32(vaddq_f32(v134, vmulq_f32(v182, vaddq_f32(v156, vmulq_f32(v182, vaddq_f32(v154, vmulq_f32(v155, v182)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v181), v157), 0x17uLL));
    v183.f32[3] = v12;
    *(float32x4_t *)(v6 + v125) = vaddq_f32(v126, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v183, (int8x16_t)vaddq_f32(v162, vmulq_laneq_f32(vsubq_f32(v183, v162), v126, 3))), v126), v162, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendHardLightQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int8x16_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t *v128;
  int v129;
  uint64_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  int8x16_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  int8x16_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  int32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  int8x16_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v190;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v129 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v190 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v190, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18)));
      v26 = *((int8x16_t *)a2 + 31);
      v25 = *((float32x4_t *)a2 + 32);
      v28 = *((float32x4_t *)a2 + 23);
      v27 = *((float32x4_t *)a2 + 24);
      v29 = vmaxq_f32(vmulq_f32(v190, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v25);
      v30 = vminq_f32(vmaxq_f32(v24, v25), v28);
      v31 = vminq_f32(v29, v28);
      v32 = *((float32x4_t *)a2 + 29);
      v33 = *((float32x4_t *)a2 + 30);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v30), (int8x16_t)v32);
      v36 = *((float32x4_t *)a2 + 9);
      v35 = *((int8x16_t *)a2 + 10);
      v37 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v31), (int8x16_t)v32);
      v39 = *((float32x4_t *)a2 + 11);
      v38 = *((float32x4_t *)a2 + 12);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v34, v38));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v37, v38));
      v43 = *((float32x4_t *)a2 + 13);
      v42 = *((float32x4_t *)a2 + 14);
      v44 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v30))), v39), v40);
      v45 = vmulq_f32(v43, v40);
      v46 = vmulq_f32(vmulq_f32(v43, v41), v37);
      v47 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v31))), v39), v41);
      v48 = vsubq_f32(vsubq_f32(v34, v32), vmulq_f32(v45, v34));
      v49 = vsubq_f32(vsubq_f32(v37, v32), v46);
      v51 = *((float32x4_t *)a2 + 15);
      v50 = *((float32x4_t *)a2 + 16);
      v53 = *((float32x4_t *)a2 + 17);
      v52 = *((float32x4_t *)a2 + 18);
      v54 = vaddq_f32(v47, vmulq_f32(v49, vaddq_f32(vaddq_f32(v50, vmulq_f32(v49, v53)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v42, vmulq_f32(v51, v49))))));
      v55 = vmulq_f32(v27, vaddq_f32(v44, vmulq_f32(v48, vaddq_f32(vaddq_f32(v50, vmulq_f32(v48, v53)), vmulq_f32(vmulq_f32(v48, v48), vaddq_f32(v42, vmulq_f32(v51, v48)))))));
      v56 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v57 = vmaxq_f32(v55, v52);
      v58 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3), v16);
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), v16);
      v61 = vmaxq_f32(vmulq_f32(v27, v54), v52);
      v62 = vmulq_f32(v21, vrecpeq_f32(v59));
      v63 = vmulq_f32(v21, vrecpeq_f32(v60));
      v64 = vmulq_f32(v56, (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v59))), (int8x16_t)v25));
      v65 = vmulq_f32(v58, (float32x4_t)vorrq_s8(vandq_s8(v26, (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v60))), (int8x16_t)v25));
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v57));
      v67 = vminq_f32(vmaxq_f32(v64, v25), v28);
      v68 = vminq_f32(vmaxq_f32(v65, v25), v28);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v70 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v67), (int8x16_t)v32);
      v71 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v68), (int8x16_t)v32);
      v72 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v70, v38));
      v73 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v71, v38));
      v74 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v67, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v67))), v39), v72);
      v75 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v68))), v39), v73);
      v76 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v66, v57)));
      v77 = vsubq_f32(vsubq_f32(v70, v32), vmulq_f32(vmulq_f32(v43, v72), v70));
      v78 = vsubq_f32(vsubq_f32(v71, v32), vmulq_f32(vmulq_f32(v43, v73), v71));
      v79 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v69, v61)));
      v80 = vsubq_f32(v57, v76);
      v81 = *((float32x4_t *)a2 + 19);
      v82 = *((float32x4_t *)a2 + 20);
      v83 = *((float32x4_t *)a2 + 21);
      v84 = *((int32x4_t *)a2 + 22);
      v85 = vsubq_f32(v61, v79);
      v86 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v74, vmulq_f32(v77, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v42, vmulq_f32(v51, v77))))))), v52);
      v87 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v75, vmulq_f32(v78, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v42, vmulq_f32(v51, v78))))))), v52);
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v89 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v88, v86)));
      v90 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
      v91 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v80, vaddq_f32(v83, vmulq_f32(v80, vaddq_f32(v81, vmulq_f32(v82, v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v76)), 0x17uLL));
      v92 = vsubq_f32(v90, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v90, v87)));
      v93 = vsubq_f32(v86, v89);
      v94 = vsubq_f32(v87, v92);
      v12 = 1.0;
      v95 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v93, vaddq_f32(v83, vmulq_f32(v93, vaddq_f32(v81, vmulq_f32(v82, v93)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v89), v84), 0x17uLL));
      v96 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v94, vaddq_f32(v83, vmulq_f32(v94, vaddq_f32(v81, vmulq_f32(v82, v94)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v92), v84), 0x17uLL));
      v97 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v85, vaddq_f32(v83, vmulq_f32(v85, vaddq_f32(v81, vmulq_f32(v82, v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v79)), 0x17uLL));
      v98 = vaddq_f32(v95, v95);
      v99 = (int8x16_t)vmulq_f32(v91, v98);
      v100 = vsubq_f32(v98, v32);
      v101 = (int8x16_t)vsubq_f32(vaddq_f32(v91, v100), vminq_f32(vminq_f32(vmulq_f32(v91, v100), v100), v91));
      v102 = vaddq_f32(v96, v96);
      v103 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgeq_f32(v43, v95)), v25), v99, v101);
      v104 = (int8x16_t)vmulq_f32(v97, v102);
      v105 = vsubq_f32(v102, v32);
      v106 = vminq_f32(vmaxq_f32(v103, v25), v33);
      v107 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgeq_f32(v43, v96)), v25), v104, (int8x16_t)vsubq_f32(vaddq_f32(v97, v105), vminq_f32(vminq_f32(vmulq_f32(v97, v105), v105), v97))), v25), v33);
      v108 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v106, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v106)));
      v109 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v106), (int8x16_t)v32);
      v110 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v109, v38));
      v111 = vaddq_f32(vsubq_f32(v108, v39), v110);
      v112 = vsubq_f32(vsubq_f32(v109, v32), vmulq_f32(vmulq_f32(v43, v110), v109));
      v113 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v107), (int8x16_t)v32);
      v114 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v113, v38));
      v115 = vsubq_f32(vsubq_f32(v113, v32), vmulq_f32(vmulq_f32(v43, v114), v113));
      v116 = vaddq_f32(v111, vmulq_f32(v112, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v112)), vmulq_f32(vmulq_f32(v112, v112), vaddq_f32(v42, vmulq_f32(v51, v112))))));
      v117 = *((float32x4_t *)a2 + 25);
      v118 = vmaxq_f32(vmulq_f32(v117, v116), v52);
      v119 = vmaxq_f32(vmulq_f32(v117, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v107, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v107))), v39), v114), vmulq_f32(v115, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v115)), vmulq_f32(vmulq_f32(v115, v115), vaddq_f32(v42, vmulq_f32(v51, v115))))))), v52);
      v120 = vcvtq_f32_s32(vcvtq_s32_f32(v118));
      v121 = vcvtq_f32_s32(vcvtq_s32_f32(v119));
      v122 = vsubq_f32(v120, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v120, v118)));
      v123 = vsubq_f32(v121, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v121, v119)));
      v124 = vsubq_f32(v118, v122);
      v125 = vsubq_f32(v119, v123);
      v126 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v124, vaddq_f32(v83, vmulq_f32(v124, vaddq_f32(v81, vmulq_f32(v82, v124)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v122), v84), 0x17uLL));
      v126.i32[3] = 1.0;
      v127 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v125, vaddq_f32(v83, vmulq_f32(v125, vaddq_f32(v81, vmulq_f32(v82, v125)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v123), v84), 0x17uLL));
      v127.i32[3] = 1.0;
      v128 = (float32x4_t *)(v6 + v14);
      v128[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v126, (int8x16_t)vaddq_f32(v64, vmulq_laneq_f32(vsubq_f32(v126, v64), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v64, 3));
      *v128 = vaddq_f32(v190, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v127, (int8x16_t)vaddq_f32(v65, vmulq_laneq_f32(vsubq_f32(v127, v65), v190, 3))), v190), v65, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v129 = -v13;
    if (v129 >= v5)
      goto LABEL_3;
LABEL_10:
    v130 = 16 * v129;
    v131 = *(float32x4_t *)(v8 + v130);
    v132 = *((float32x4_t *)a2 + 6);
    v133 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v131, 3), v132);
    v135 = *((float32x4_t *)a2 + 7);
    v134 = *((int8x16_t *)a2 + 8);
    v136 = vmulq_f32(vrecpeq_f32(v133), v135);
    v137 = *((float32x4_t *)a2 + 32);
    v138 = *((float32x4_t *)a2 + 23);
    v139 = *((float32x4_t *)a2 + 24);
    v140 = vminq_f32(vmaxq_f32(vmulq_f32(v131, vmulq_f32(v136, vrecpsq_f32(v136, v133))), v137), v138);
    v141 = *((float32x4_t *)a2 + 29);
    v142 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)v140), (int8x16_t)v141);
    v143 = *((float32x4_t *)a2 + 9);
    v144 = *((int8x16_t *)a2 + 10);
    v145 = *((float32x4_t *)a2 + 11);
    v146 = *((float32x4_t *)a2 + 12);
    v147 = (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v142, v146));
    v148 = *((float32x4_t *)a2 + 13);
    v149 = *((float32x4_t *)a2 + 14);
    v150 = vsubq_f32(vsubq_f32(v142, v141), vmulq_f32(vmulq_f32(v148, v147), v142));
    v151 = *((float32x4_t *)a2 + 15);
    v152 = *((float32x4_t *)a2 + 16);
    v154 = *((float32x4_t *)a2 + 17);
    v153 = *((float32x4_t *)a2 + 18);
    v155 = vmaxq_f32(vmulq_f32(v139, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v140, 0x17uLL)), (float32x4_t)vandq_s8(v144, (int8x16_t)vcgtq_f32(v143, v140))), v145), v147), vmulq_f32(v150, vaddq_f32(vaddq_f32(v152, vmulq_f32(v150, v154)), vmulq_f32(vmulq_f32(v150, v150), vaddq_f32(v149, vmulq_f32(v151, v150))))))), v153);
    v156 = vcvtq_f32_s32(vcvtq_s32_f32(v155));
    v157 = vsubq_f32(v156, (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v156, v155)));
    v158 = vsubq_f32(v155, v157);
    v159 = *((float32x4_t *)a2 + 19);
    v160 = *((float32x4_t *)a2 + 20);
    v161 = *((float32x4_t *)a2 + 21);
    v162 = *((int32x4_t *)a2 + 22);
    v163 = vmulq_f32(vaddq_f32(v141, vmulq_f32(v158, vaddq_f32(v161, vmulq_f32(v158, vaddq_f32(v159, vmulq_f32(v160, v158)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v162, vcvtq_s32_f32(v157)), 0x17uLL));
    v164 = vmulq_f32(*(float32x4_t *)(v7 + v130), *(float32x4_t *)a2);
    v165 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v164, 3), v132);
    v166 = vmulq_f32(v135, vrecpeq_f32(v165));
    v167 = vmulq_f32(v164, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v166, vrecpsq_f32(v166, v165))), (int8x16_t)v137));
    v168 = vminq_f32(vmaxq_f32(v167, v137), v138);
    v169 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)v168), (int8x16_t)v141);
    v170 = (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v169, v146));
    v171 = vsubq_f32(vsubq_f32(v169, v141), vmulq_f32(vmulq_f32(v148, v170), v169));
    v172 = vmaxq_f32(vmulq_f32(v139, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v168, 0x17uLL)), (float32x4_t)vandq_s8(v144, (int8x16_t)vcgtq_f32(v143, v168))), v145), v170), vmulq_f32(v171, vaddq_f32(vaddq_f32(v152, vmulq_f32(v154, v171)), vmulq_f32(vmulq_f32(v171, v171), vaddq_f32(v149, vmulq_f32(v151, v171))))))), v153);
    v173 = vcvtq_f32_s32(vcvtq_s32_f32(v172));
    v174 = vsubq_f32(v173, (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v173, v172)));
    v175 = vsubq_f32(v172, v174);
    v176 = vmulq_f32(vaddq_f32(v141, vmulq_f32(v175, vaddq_f32(v161, vmulq_f32(v175, vaddq_f32(v159, vmulq_f32(v160, v175)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v174), v162), 0x17uLL));
    v177 = vaddq_f32(v176, v176);
    v178 = (int8x16_t)vmulq_f32(v163, v177);
    v179 = vsubq_f32(v177, v141);
    v180 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgeq_f32(v148, v176)), v137), v178, (int8x16_t)vsubq_f32(vaddq_f32(v163, v179), vminq_f32(vminq_f32(vmulq_f32(v163, v179), v179), v163))), v137), *((float32x4_t *)a2 + 30));
    v181 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)v180), (int8x16_t)v141);
    v182 = (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v181, v146));
    v183 = vsubq_f32(vsubq_f32(v181, v141), vmulq_f32(vmulq_f32(v148, v182), v181));
    v184 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v180, 0x17uLL)), (float32x4_t)vandq_s8(v144, (int8x16_t)vcgtq_f32(v143, v180))), v145), v182), vmulq_f32(v183, vaddq_f32(vaddq_f32(v152, vmulq_f32(v154, v183)), vmulq_f32(vmulq_f32(v183, v183), vaddq_f32(v149, vmulq_f32(v151, v183))))))), v153);
    v185 = vcvtq_f32_s32(vcvtq_s32_f32(v184));
    v186 = vsubq_f32(v185, (float32x4_t)vandq_s8((int8x16_t)v141, (int8x16_t)vcgtq_f32(v185, v184)));
    v187 = vsubq_f32(v184, v186);
    v188 = vmulq_f32(vaddq_f32(v141, vmulq_f32(v187, vaddq_f32(v161, vmulq_f32(v187, vaddq_f32(v159, vmulq_f32(v160, v187)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v186), v162), 0x17uLL));
    v188.f32[3] = v12;
    *(float32x4_t *)(v6 + v130) = vaddq_f32(v131, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v188, (int8x16_t)vaddq_f32(v167, vmulq_laneq_f32(vsubq_f32(v188, v167), v131, 3))), v131), v167, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendVividLightTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int8x16_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *((int8x16_t *)a2 + 5);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = (float32x4_t)vbslq_s8(v13, *(int8x16_t *)(v5 + v12), (int8x16_t)vminq_f32(*(float32x4_t *)(v5 + v12), (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v5 + v12), 3)));
        v16 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v14);
        v17 = vrecpeq_f32(v16);
        v18 = vmulq_f32(v17, vrecpsq_f32(v17, v16));
        v19 = vmulq_f32(vmulq_f32(v18, vrecpsq_f32(v18, v16)), v15);
        v20 = *((float32x4_t *)a2 + 32);
        v21 = vmaxq_f32(v19, v20);
        v22 = *((float32x4_t *)a2 + 29);
        v23 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v24 = (float32x4_t)vbslq_s8(v13, (int8x16_t)v23, (int8x16_t)vminq_f32(v23, (float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 3)));
        v25 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3), v14);
        v26 = vrecpeq_f32(v25);
        v27 = vmulq_f32(v26, vrecpsq_f32(v26, v25));
        v28 = vminq_f32(vmaxq_f32(vmulq_f32(v24, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v27, vrecpsq_f32(v27, v25))), (int8x16_t)v20)), *((float32x4_t *)a2 + 4)), *((float32x4_t *)a2 + 3));
        v29 = *((float32x4_t *)a2 + 13);
        v30 = *((float32x4_t *)a2 + 61);
        v31 = *((float32x4_t *)a2 + 62);
        v32 = vaddq_f32(v29, vmulq_f32(vminq_f32(v21, v22), v30));
        v33 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
        v34 = vmulq_f32(v31, vsubq_f32(v33, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v33, v32))));
        v35 = vaddq_f32(v29, vmulq_f32(v28, v30));
        v36 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
        v37 = (float32x4_t)vbslq_s8(v13, (int8x16_t)v28, (int8x16_t)vmulq_f32(v31, vsubq_f32(v36, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v36, v35)))));
        v38 = vsubq_f32(v22, v34);
        v39 = vmaxq_f32(v37, v31);
        v40 = *((float32x4_t *)a2 + 27);
        v41 = *((float32x4_t *)a2 + 28);
        v42 = vminq_f32(vmaxq_f32(vrecpeq_f32(v39), v40), v41);
        v43 = vminq_f32(vmaxq_f32(vmulq_f32(v42, vrecpsq_f32(v39, v42)), v40), v41);
        v44 = vmulq_f32(vsubq_f32(v39, vmulq_laneq_f32(v38, v31, 3)), vmulq_f32(v43, vrecpsq_f32(v39, v43)));
        v45 = vmulq_f32(v29, v38);
        v46 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v29, v24, 3), v24));
        v47 = vmulq_f32(v46, vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v37, v45), (int8x16_t)v22, (int8x16_t)0), v44));
        v48 = vsubq_f32(v22, v46);
        v49 = vminq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(vaddq_f32(v29, v45), v37)));
        v50 = vmaxq_f32(vsubq_f32(v22, v37), v31);
        v51 = vaddq_f32(v50, v50);
        v52 = vminq_f32(vmaxq_f32(vrecpeq_f32(v51), v40), v41);
        v53 = vminq_f32(vmaxq_f32(vmulq_f32(v52, vrecpsq_f32(v51, v52)), v40), v41);
        v54 = vaddq_f32(vmulq_f32(v48, (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(vnegq_f32(v49), *((float32x4_t *)a2 + 63)), (int8x16_t)v22, (int8x16_t)0)), vaddq_f32(v47, vmulq_f32(v49, vmulq_f32(v34, vmulq_f32(v53, vrecpsq_f32(v51, v53))))));
        v54.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v13, (int8x16_t)v54, (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v54, v37), v15, 3), v37)), v15), v37, 3), v15);
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendVividLightPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v104;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v16 = vrecpeq_f32(v15);
        v17 = vmulq_f32(v16, vrecpsq_f32(v16, v15));
        v18 = vmulq_f32(v13, vmulq_f32(v17, vrecpsq_f32(v17, v15)));
        v19 = *((float32x4_t *)a2 + 32);
        v20 = vmaxq_f32(v18, v19);
        v21 = *((float32x4_t *)a2 + 29);
        v22 = *((float32x4_t *)a2 + 1);
        v23 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v22, v19)), v19);
        v24 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v21, (int8x16_t)vminq_f32(v20, v21));
        v25 = *((float32x4_t *)a2 + 9);
        v104 = *((int8x16_t *)a2 + 8);
        v26 = (float32x4_t)vorrq_s8(vandq_s8(v104, (int8x16_t)v24), (int8x16_t)v21);
        v28 = *((int8x16_t *)a2 + 10);
        v27 = *((float32x4_t *)a2 + 11);
        v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v28, (int8x16_t)vcgtq_f32(v25, v24))), v27);
        v31 = *((float32x4_t *)a2 + 12);
        v30 = *((float32x4_t *)a2 + 13);
        v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v31));
        v33 = vaddq_f32(v29, v32);
        v34 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
        v35 = vmulq_f32(v34, v34);
        v36 = *((float32x4_t *)a2 + 64);
        v37 = *((float32x4_t *)a2 + 65);
        v38 = *((float32x4_t *)a2 + 66);
        v39 = *((float32x4_t *)a2 + 67);
        v40 = *((float32x4_t *)a2 + 68);
        v41 = *((float32x4_t *)a2 + 69);
        v42 = vaddq_f32(vaddq_f32(v40, vmulq_f32(v41, v34)), vmulq_f32(v35, vaddq_f32(vaddq_f32(v36, vmulq_f32(v37, v34)), vmulq_f32(v35, vaddq_f32(v38, vmulq_f32(v39, v34))))));
        v43 = *((float32x4_t *)a2 + 70);
        v44 = vmulq_f32(v22, vaddq_f32(v33, vmulq_f32(v34, vaddq_f32(v43, vmulq_f32(v34, v42)))));
        v45 = *((float32x4_t *)a2 + 18);
        v46 = vmaxq_f32(v44, v45);
        v47 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
        v48 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v47, v46)));
        v49 = vsubq_f32(v46, v48);
        v50 = *((float32x4_t *)a2 + 71);
        v51 = *((float32x4_t *)a2 + 72);
        v52 = *((float32x4_t *)a2 + 73);
        v53 = *((float32x4_t *)a2 + 74);
        v54 = *((float32x4_t *)a2 + 75);
        v55 = vcvtq_s32_f32(v48);
        v56 = *((int32x4_t *)a2 + 22);
        v57 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v49, vaddq_f32(v54, vmulq_f32(v49, vaddq_f32(vaddq_f32(v52, vmulq_f32(v53, v49)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v50, vmulq_f32(v51, v49)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v56, v55), 0x17uLL));
        v58 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), v14);
        v60 = vrecpeq_f32(v59);
        v61 = vmulq_f32(v60, vrecpsq_f32(v60, v59));
        v62 = vmulq_f32(v58, vmulq_f32(v61, vrecpsq_f32(v61, v59)));
        v63 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v21, (int8x16_t)vminq_f32(vmaxq_f32(v62, v19), v21));
        v64 = (float32x4_t)vorrq_s8(vandq_s8(v104, (int8x16_t)v63), (int8x16_t)v21);
        v65 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v64, v31));
        v66 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v63, 0x17uLL)), (float32x4_t)vandq_s8(v28, (int8x16_t)vcgtq_f32(v25, v63))), v27), v65);
        v67 = vsubq_f32(vsubq_f32(v64, v21), vmulq_f32(vmulq_f32(v30, v65), v64));
        v68 = vmulq_f32(v67, v67);
        v69 = vmaxq_f32(vmulq_f32(v22, vaddq_f32(v66, vmulq_f32(v67, vaddq_f32(v43, vmulq_f32(v67, vaddq_f32(vaddq_f32(v40, vmulq_f32(v41, v67)), vmulq_f32(v68, vaddq_f32(vaddq_f32(v36, vmulq_f32(v37, v67)), vmulq_f32(v68, vaddq_f32(v38, vmulq_f32(v39, v67))))))))))), v45);
        v70 = vcvtq_f32_s32(vcvtq_s32_f32(v69));
        v71 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v70, v69)));
        v72 = vsubq_f32(v69, v71);
        v73 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v72, vaddq_f32(v54, vmulq_f32(v72, vaddq_f32(vaddq_f32(v52, vmulq_f32(v53, v72)), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(v50, vmulq_f32(v51, v72)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v71), v56), 0x17uLL));
        v74 = *((float32x4_t *)a2 + 62);
        v75 = vmaxq_f32(v73, v74);
        v76 = *((float32x4_t *)a2 + 27);
        v77 = *((float32x4_t *)a2 + 28);
        v78 = vminq_f32(vmaxq_f32(vrecpeq_f32(v75), v76), v77);
        v79 = vminq_f32(vmaxq_f32(vmulq_f32(v78, vrecpsq_f32(v75, v78)), v76), v77);
        v80 = vmulq_f32(v79, vrecpsq_f32(v75, v79));
        v81 = *((float32x4_t *)a2 + 55);
        v82 = vaddq_f32(v81, vmulq_f32(v73, *((float32x4_t *)a2 + 60)));
        v83 = vmaxq_f32(v82, v74);
        v84 = vminq_f32(vmaxq_f32(vrecpeq_f32(v83), v76), v77);
        v85 = vminq_f32(vmaxq_f32(vmulq_f32(v84, vrecpsq_f32(v83, v84)), v76), v77);
        v86 = (int8x16_t)vmulq_f32(v57, vmulq_f32(v85, vrecpsq_f32(v83, v85)));
        v87 = vsubq_f32(v73, vmulq_laneq_f32(vsubq_f32(v21, v57), v54, 3));
        v88 = vmulq_f32(v80, v87);
        v89 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v87, v19));
        v90 = (int8x16_t)vcgtq_f32(v19, vsubq_f32(v73, vaddq_f32(v21, vmulq_f32(v57, *((float32x4_t *)a2 + 76)))));
        v91 = vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgeq_f32(v74, v89)), v19), (int8x16_t)v19, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgeq_f32(v74, v82)), v19), (int8x16_t)v21, vbslq_s8(v90, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgeq_f32(v73, v30)), (float32x4_t)vandq_s8(v90, (int8x16_t)v21)),
                                                  v19),
                                     v86,
                                     (int8x16_t)vmulq_f32(v88, vminq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v30, v73)), v89))), (int8x16_t)v81))), v19);
        v92 = *((float32x4_t *)a2 + 2);
        v93 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vceqq_f32(v92, v19)), v19), (int8x16_t)v21, (int8x16_t)vminq_f32(v91, v21));
        v94 = (float32x4_t)vorrq_s8(vandq_s8(v104, (int8x16_t)v93), (int8x16_t)v21);
        v95 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v94, v31));
        v96 = vsubq_f32(vsubq_f32(v94, v21), vmulq_f32(vmulq_f32(v30, v95), v94));
        v97 = vmulq_f32(v96, v96);
        v98 = vmaxq_f32(vmulq_f32(v92, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v93, 0x17uLL)), (float32x4_t)vandq_s8(v28, (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 9), v93))), *((float32x4_t *)a2 + 11)), v95), vmulq_f32(v96, vaddq_f32(v43, vmulq_f32(v96, vaddq_f32(vaddq_f32(v40, vmulq_f32(v41, v96)), vmulq_f32(
                              v97,
                              vaddq_f32(vaddq_f32(v36, vmulq_f32(v37, v96)), vmulq_f32(v97, vaddq_f32(v38, vmulq_f32(v39, v96))))))))))), v45);
        v99 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
        v100 = vsubq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v99, v98)));
        v101 = vsubq_f32(v98, v100);
        v102 = vmulq_f32(vaddq_f32(v21, vmulq_f32(v101, vaddq_f32(v54, vmulq_f32(v101, vaddq_f32(vaddq_f32(v52, vmulq_f32(v53, v101)), vmulq_f32(vmulq_f32(v101, v101), vaddq_f32(v50, vmulq_f32(v51, v101)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v100), v56), 0x17uLL));
        v102.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(*(float32x4_t *)(v5 + v12), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v102, (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(vsubq_f32(v102, v62), *(float32x4_t *)(v5 + v12), 3))), *(float32x4_t *)(v5 + v12)), v58, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendVividLightQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v17 = *((float32x4_t *)a2 + 7);
        v16 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v17);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 32);
        v21 = vmaxq_f32(v19, v20);
        v22 = *((float32x4_t *)a2 + 29);
        v23 = vminq_f32(v21, v22);
        v24 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v23), (int8x16_t)v22);
        v25 = *((float32x4_t *)a2 + 9);
        v26 = *((int8x16_t *)a2 + 10);
        v28 = *((float32x4_t *)a2 + 11);
        v27 = *((float32x4_t *)a2 + 12);
        v29 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v24, v27));
        v30 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v23))), v28), v29);
        v32 = *((float32x4_t *)a2 + 13);
        v31 = *((float32x4_t *)a2 + 14);
        v33 = vsubq_f32(vsubq_f32(v24, v22), vmulq_f32(vmulq_f32(v32, v29), v24));
        v35 = *((float32x4_t *)a2 + 15);
        v34 = *((float32x4_t *)a2 + 16);
        v37 = *((float32x4_t *)a2 + 17);
        v36 = *((float32x4_t *)a2 + 18);
        v38 = *((float32x4_t *)a2 + 24);
        v39 = vmaxq_f32(vmulq_f32(v38, vaddq_f32(v30, vmulq_f32(v33, vaddq_f32(vaddq_f32(v34, vmulq_f32(v33, v37)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v31, vmulq_f32(v35, v33))))))), v36);
        v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        v41 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v40, v39)));
        v42 = vsubq_f32(v39, v41);
        v43 = *((float32x4_t *)a2 + 19);
        v44 = *((float32x4_t *)a2 + 20);
        v46 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v47 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v42, vaddq_f32(v46, vmulq_f32(v42, vaddq_f32(v43, vmulq_f32(v44, v42)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v41)), 0x17uLL));
        v48 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v49 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3), v14);
        v50 = vmulq_f32(v17, vrecpeq_f32(v49));
        v51 = vmulq_f32(v48, vmulq_f32(v50, vrecpsq_f32(v50, v49)));
        v52 = vminq_f32(vmaxq_f32(v51, v20), v22);
        v53 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v52), (int8x16_t)v22);
        v54 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v53, v27));
        v55 = vsubq_f32(vsubq_f32(v53, v22), vmulq_f32(vmulq_f32(v32, v54), v53));
        v56 = vmaxq_f32(vmulq_f32(v38, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v52, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v52))), v28), v54), vmulq_f32(v55, vaddq_f32(vaddq_f32(v34, vmulq_f32(v37, v55)), vmulq_f32(vmulq_f32(v55, v55), vaddq_f32(v31, vmulq_f32(v35, v55))))))), v36);
        v57 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
        v58 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v57, v56)));
        v59 = vsubq_f32(v56, v58);
        v60 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v59, vaddq_f32(v46, vmulq_f32(v59, vaddq_f32(v43, vmulq_f32(v44, v59)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v58), v45), 0x17uLL));
        v61 = *((float32x4_t *)a2 + 62);
        v62 = vmaxq_f32(v60, v61);
        v63 = *((float32x4_t *)a2 + 27);
        v64 = *((float32x4_t *)a2 + 28);
        v65 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpeq_f32(v62)), v63), v64);
        v66 = vmulq_f32(v65, vrecpsq_f32(v62, v65));
        v67 = *((float32x4_t *)a2 + 55);
        v68 = vaddq_f32(v67, vmulq_f32(v60, *((float32x4_t *)a2 + 60)));
        v69 = vmaxq_f32(v68, v61);
        v70 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpeq_f32(v69)), v63), v64);
        v71 = vmulq_f32(v70, vrecpsq_f32(v69, v70));
        v72 = *((float32x4_t *)a2 + 76);
        v73 = vsubq_f32(v60, vmulq_laneq_f32(vsubq_f32(v22, v47), v72, 3));
        v74 = vmulq_f32(v66, v73);
        v75 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v73, v20));
        v76 = (int8x16_t)vcgtq_f32(v20, vsubq_f32(v60, vaddq_f32(v22, vmulq_f32(v47, v72))));
        v77 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v61, v75)), v20), (int8x16_t)v20, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v61, v68)), v20), (int8x16_t)v22, vbslq_s8(v76, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v60, v32)),
                                                      (float32x4_t)vandq_s8(v76, (int8x16_t)v22)),
                                                    v20),
                                       (int8x16_t)vmulq_f32(v47, v71),
                                       (int8x16_t)vmulq_f32(v74, vminq_f32((float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v32, v60)), v75))), (int8x16_t)v67))), v20), v22);
        v78 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v77), (int8x16_t)v22);
        v79 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v78, v27));
        v80 = vsubq_f32(vsubq_f32(v78, v22), vmulq_f32(vmulq_f32(v32, v79), v78));
        v81 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v77, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v77))), v28), v79), vmulq_f32(v80, vaddq_f32(vaddq_f32(v34, vmulq_f32(v37, v80)), vmulq_f32(vmulq_f32(v80, v80), vaddq_f32(v31, vmulq_f32(v35, v80))))))), v36);
        v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
        v83 = vsubq_f32(v82, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v82, v81)));
        v84 = vsubq_f32(v81, v83);
        v85 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v84, vaddq_f32(v46, vmulq_f32(v84, vaddq_f32(v43, vmulq_f32(v44, v84)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v83), v45), 0x17uLL));
        v85.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v85, (int8x16_t)vaddq_f32(v51, vmulq_laneq_f32(vsubq_f32(v85, v51), v13, 3))), v13), v48, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendLinearLightTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t *v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    while (v5 < 3)
    {
      LODWORD(v51) = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v8 += v9;
      v6 += v10;
      v7 += v11;
      if (v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 32;
    do
    {
      v14 = *(float32x4_t *)(v8 + v13 - 32);
      v15 = *(float32x4_t *)(v8 + v13 - 16);
      v16 = *(float32x4_t *)(v8 + v13);
      v18 = *((int8x16_t *)a2 + 5);
      v17 = *((float32x4_t *)a2 + 6);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v17);
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v21 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v17);
      v22 = *((float32x4_t *)a2 + 7);
      v23 = vmulq_f32(vrecpeq_f32(v19), v22);
      v24 = vmulq_f32(vrecpeq_f32(v20), v22);
      v25 = vmulq_f32(vrecpeq_f32(v21), v22);
      v26 = vmulq_f32(*(float32x4_t *)(v7 + v13 - 32), *(float32x4_t *)a2);
      v27 = vmulq_f32(*(float32x4_t *)(v7 + v13 - 16), *(float32x4_t *)a2);
      v28 = vmulq_f32(*(float32x4_t *)(v7 + v13), *(float32x4_t *)a2);
      v29 = vmulq_f32(v23, vrecpsq_f32(v23, v19));
      v30 = vmulq_f32(v24, vrecpsq_f32(v24, v20));
      v31 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3), v17);
      v32 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3), v17);
      v33 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3), v17);
      v34 = vmulq_f32(v25, vrecpsq_f32(v25, v21));
      v35 = vmulq_f32(v22, vrecpeq_f32(v31));
      v36 = vmulq_f32(v22, vrecpeq_f32(v32));
      v37 = vmulq_f32(v22, vrecpeq_f32(v33));
      v38 = (int8x16_t)vmulq_f32(v36, vrecpsq_f32(v36, v32));
      v39 = (int8x16_t)vmulq_f32(v37, vrecpsq_f32(v37, v33));
      v40 = *((int8x16_t *)a2 + 31);
      v41 = *((float32x4_t *)a2 + 32);
      v42 = vmulq_f32(v26, (float32x4_t)vorrq_s8(vandq_s8(v40, (int8x16_t)vmulq_f32(v35, vrecpsq_f32(v35, v31))), (int8x16_t)v41));
      v43 = vmulq_f32(v27, (float32x4_t)vorrq_s8(vandq_s8(v40, v38), (int8x16_t)v41));
      v44 = vmulq_f32(v28, (float32x4_t)vorrq_s8(vandq_s8(v40, v39), (int8x16_t)v41));
      v45 = *((float32x4_t *)a2 + 29);
      v46 = *((float32x4_t *)a2 + 60);
      v47 = vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v14, v29), vaddq_f32(v45, vmulq_f32(v46, v42))), v41), v45);
      v48 = vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v15, v30), vaddq_f32(v45, vmulq_f32(v46, v43))), v41), v45);
      v49 = vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v16, v34), vaddq_f32(v45, vmulq_f32(v46, v44))), v41), v45);
      v47.i32[3] = 1.0;
      v48.i32[3] = 1.0;
      v49.i32[3] = 1.0;
      v50 = (float32x4_t *)(v6 + v13);
      v50[-2] = vaddq_f32(v14, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v47, (int8x16_t)vaddq_f32(v42, vmulq_laneq_f32(vsubq_f32(v47, v42), v14, 3))), v14), v42, 3));
      v50[-1] = vaddq_f32(v15, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v48, (int8x16_t)vaddq_f32(v43, vmulq_laneq_f32(vsubq_f32(v48, v43), v15, 3))), v15), v43, 3));
      *v50 = vaddq_f32(v16, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v18, (int8x16_t)v49, (int8x16_t)vaddq_f32(v44, vmulq_laneq_f32(vsubq_f32(v49, v44), v16, 3))), v16), v44, 3));
      v12 -= 3;
      v13 += 48;
    }
    while (v5 + v12 > 2);
    LODWORD(v51) = -v12;
    if ((int)v51 >= v5)
      goto LABEL_3;
LABEL_10:
    v51 = v51;
    do
    {
      v52 = *(float32x4_t *)(v8 + 16 * v51);
      v53 = *((float32x4_t *)a2 + 6);
      v54 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), v53);
      v55 = vmulq_f32(*(float32x4_t *)(v7 + 16 * v51), *(float32x4_t *)a2);
      v56 = *((float32x4_t *)a2 + 7);
      v57 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3), v53);
      v58 = vmulq_f32(v56, vrecpeq_f32(v57));
      v59 = vmulq_f32(vrecpeq_f32(v54), v56);
      v60 = *((float32x4_t *)a2 + 32);
      v61 = vmulq_f32(v55, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v58, vrecpsq_f32(v58, v57))), (int8x16_t)v60));
      v62 = vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v52, vmulq_f32(v59, vrecpsq_f32(v59, v54))), vaddq_f32(*((float32x4_t *)a2 + 29), vmulq_f32(*((float32x4_t *)a2 + 60), v61))), v60), *((float32x4_t *)a2 + 29));
      v62.i32[3] = 1.0;
      *(float32x4_t *)(v6 + 16 * v51++) = vaddq_f32(v52, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v62, (int8x16_t)vaddq_f32(v61, vmulq_laneq_f32(vsubq_f32(v62, v61), v52, 3))), v52), v61, 3));
    }
    while (v51 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendLinearLightPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t *v117;
  int v118;
  uint64_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int8x16_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  int8x16_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  int32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v174;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v118 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v174 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v174, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18)));
      v25 = *((int8x16_t *)a2 + 31);
      v26 = *((float32x4_t *)a2 + 32);
      v27 = vmulq_f32(v174, vmulq_f32(v23, vrecpsq_f32(v23, v19)));
      v28 = vmaxq_f32(v24, v26);
      v29 = vmaxq_f32(v27, v26);
      v30 = *((float32x4_t *)a2 + 29);
      v31 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v28), (int8x16_t)v30);
      v33 = *((float32x4_t *)a2 + 9);
      v32 = *((int8x16_t *)a2 + 10);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v29), (int8x16_t)v30);
      v35 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v28)));
      v37 = *((float32x4_t *)a2 + 11);
      v36 = *((float32x4_t *)a2 + 12);
      v38 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v31, v36));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v34, v36));
      v40 = vaddq_f32(vsubq_f32(v35, v37), v38);
      v42 = *((float32x4_t *)a2 + 13);
      v41 = *((float32x4_t *)a2 + 14);
      v43 = vmulq_f32(vmulq_f32(v42, v39), v34);
      v44 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v29))), v37), v39);
      v45 = vsubq_f32(vsubq_f32(v31, v30), vmulq_f32(vmulq_f32(v42, v38), v31));
      v46 = vsubq_f32(vsubq_f32(v34, v30), v43);
      v48 = *((float32x4_t *)a2 + 15);
      v47 = *((float32x4_t *)a2 + 16);
      v50 = *((float32x4_t *)a2 + 17);
      v49 = *((float32x4_t *)a2 + 18);
      v51 = vaddq_f32(v40, vmulq_f32(v45, vaddq_f32(vaddq_f32(v47, vmulq_f32(v45, v50)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v41, vmulq_f32(v48, v45))))));
      v52 = *((float32x4_t *)a2 + 1);
      v53 = vmulq_f32(v52, vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(vaddq_f32(v47, vmulq_f32(v46, v50)), vmulq_f32(vmulq_f32(v46, v46), vaddq_f32(v41, vmulq_f32(v48, v46)))))));
      v54 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v55 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v56 = vmaxq_f32(vmulq_f32(v52, v51), v49);
      v57 = *((float32x4_t *)a2 + 19);
      v58 = *((float32x4_t *)a2 + 20);
      v59 = vmaxq_f32(v53, v49);
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3), v16);
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3), v16);
      v62 = vmulq_f32(v21, vrecpeq_f32(v60));
      v63 = vmulq_f32(v21, vrecpeq_f32(v61));
      v64 = vandq_s8(v25, (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v61)));
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
      v66 = vmulq_f32(v54, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v60))), (int8x16_t)v26));
      v67 = vmulq_f32(v55, (float32x4_t)vorrq_s8(v64, (int8x16_t)v26));
      v68 = vmaxq_f32(v66, v26);
      v69 = vmaxq_f32(v67, v26);
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
      v71 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v68), (int8x16_t)v30);
      v72 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v69), (int8x16_t)v30);
      v73 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v65, v56)));
      v74 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v71, v36));
      v75 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v72, v36));
      v76 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v68))), v37), v74);
      v77 = vsubq_f32(vsubq_f32(v71, v30), vmulq_f32(vmulq_f32(v42, v74), v71));
      v78 = vsubq_f32(vsubq_f32(v72, v30), vmulq_f32(vmulq_f32(v42, v75), v72));
      v79 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v70, v59)));
      v80 = vsubq_f32(v56, v73);
      v82 = *((float32x4_t *)a2 + 21);
      v81 = *((int32x4_t *)a2 + 22);
      v83 = vaddq_f32(v76, vmulq_f32(v77, vaddq_f32(vaddq_f32(v47, vmulq_f32(v50, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v41, vmulq_f32(v48, v77))))));
      v84 = vsubq_f32(v59, v79);
      v12 = 1.0;
      v85 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v80, vaddq_f32(v82, vmulq_f32(v80, vaddq_f32(v57, vmulq_f32(v58, v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v81, vcvtq_s32_f32(v73)), 0x17uLL));
      v86 = vmaxq_f32(vmulq_f32(v52, v83), v49);
      v87 = vmaxq_f32(vmulq_f32(v52, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v69))), v37), v75), vmulq_f32(v78, vaddq_f32(vaddq_f32(v47, vmulq_f32(v50, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v41, vmulq_f32(v48, v78))))))), v49);
      v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      v89 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
      v90 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v88, v86)));
      v91 = vsubq_f32(v89, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v89, v87)));
      v92 = vsubq_f32(v86, v90);
      v93 = vsubq_f32(v87, v91);
      v94 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v92, vaddq_f32(v82, vmulq_f32(v92, vaddq_f32(v57, vmulq_f32(v58, v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v90), v81), 0x17uLL));
      v95 = *((float32x4_t *)a2 + 60);
      v96 = vminq_f32(vmaxq_f32(vsubq_f32(v85, vaddq_f32(v30, vmulq_f32(v95, v94))), v26), v30);
      v97 = vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(vaddq_f32(v30, vmulq_f32(v84, vaddq_f32(v82, vmulq_f32(v84, vaddq_f32(v57, vmulq_f32(v58, v84)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v81, vcvtq_s32_f32(v79)), 0x17uLL)), vaddq_f32(v30, vmulq_f32(v95, vmulq_f32(vaddq_f32(v30, vmulq_f32(v93, vaddq_f32(v82, vmulq_f32(v93, vaddq_f32(v57, vmulq_f32(v58, v93)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v91), v81), 0x17uLL))))), v26), v30);
      v98 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v96, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v96)));
      v99 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v96), (int8x16_t)v30);
      v100 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v99, v36));
      v101 = vsubq_f32(vsubq_f32(v99, v30), vmulq_f32(vmulq_f32(v42, v100), v99));
      v102 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v97), (int8x16_t)v30);
      v103 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v102, v36));
      v104 = vsubq_f32(vsubq_f32(v102, v30), vmulq_f32(vmulq_f32(v42, v103), v102));
      v105 = vaddq_f32(vaddq_f32(vsubq_f32(v98, v37), v100), vmulq_f32(v101, vaddq_f32(vaddq_f32(v47, vmulq_f32(v50, v101)), vmulq_f32(vmulq_f32(v101, v101), vaddq_f32(v41, vmulq_f32(v48, v101))))));
      v106 = *((float32x4_t *)a2 + 2);
      v107 = vmaxq_f32(vmulq_f32(v106, v105), v49);
      v108 = vmaxq_f32(vmulq_f32(v106, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v97, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v97))), v37), v103), vmulq_f32(v104, vaddq_f32(vaddq_f32(v47, vmulq_f32(v50, v104)), vmulq_f32(vmulq_f32(v104, v104), vaddq_f32(v41, vmulq_f32(v48, v104))))))), v49);
      v109 = vcvtq_f32_s32(vcvtq_s32_f32(v107));
      v110 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
      v111 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v109, v107)));
      v112 = vsubq_f32(v110, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v110, v108)));
      v113 = vsubq_f32(v107, v111);
      v114 = vsubq_f32(v108, v112);
      v115 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v113, vaddq_f32(v82, vmulq_f32(v113, vaddq_f32(v57, vmulq_f32(v58, v113)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v111), v81), 0x17uLL));
      v115.i32[3] = 1.0;
      v116 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v114, vaddq_f32(v82, vmulq_f32(v114, vaddq_f32(v57, vmulq_f32(v58, v114)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v112), v81), 0x17uLL));
      v116.i32[3] = 1.0;
      v117 = (float32x4_t *)(v6 + v14);
      v117[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v115, (int8x16_t)vaddq_f32(v66, vmulq_laneq_f32(vsubq_f32(v115, v66), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v66, 3));
      *v117 = vaddq_f32(v174, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v116, (int8x16_t)vaddq_f32(v67, vmulq_laneq_f32(vsubq_f32(v116, v67), v174, 3))), v174), v67, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v118 = -v13;
    if (v118 >= v5)
      goto LABEL_3;
LABEL_10:
    v119 = 16 * v118;
    v120 = *(float32x4_t *)(v8 + v119);
    v121 = *((float32x4_t *)a2 + 6);
    v122 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v120, 3), v121);
    v123 = *((float32x4_t *)a2 + 7);
    v124 = *((int8x16_t *)a2 + 8);
    v125 = vmulq_f32(vrecpeq_f32(v122), v123);
    v126 = *((float32x4_t *)a2 + 32);
    v127 = vmaxq_f32(vmulq_f32(v120, vmulq_f32(v125, vrecpsq_f32(v125, v122))), v126);
    v128 = *((float32x4_t *)a2 + 29);
    v129 = (float32x4_t)vorrq_s8(vandq_s8(v124, (int8x16_t)v127), (int8x16_t)v128);
    v130 = *((float32x4_t *)a2 + 9);
    v131 = *((int8x16_t *)a2 + 10);
    v132 = *((float32x4_t *)a2 + 11);
    v133 = *((float32x4_t *)a2 + 12);
    v134 = (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v129, v133));
    v135 = *((float32x4_t *)a2 + 13);
    v136 = *((float32x4_t *)a2 + 14);
    v137 = vsubq_f32(vsubq_f32(v129, v128), vmulq_f32(vmulq_f32(v135, v134), v129));
    v138 = *((float32x4_t *)a2 + 15);
    v139 = *((float32x4_t *)a2 + 16);
    v140 = *((float32x4_t *)a2 + 17);
    v141 = *((float32x4_t *)a2 + 18);
    v142 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v127, 0x17uLL)), (float32x4_t)vandq_s8(v131, (int8x16_t)vcgtq_f32(v130, v127))), v132), v134), vmulq_f32(v137, vaddq_f32(vaddq_f32(v139, vmulq_f32(v137, v140)), vmulq_f32(vmulq_f32(v137, v137), vaddq_f32(v136, vmulq_f32(v138, v137))))));
    v143 = *((float32x4_t *)a2 + 1);
    v144 = vmaxq_f32(vmulq_f32(v143, v142), v141);
    v145 = vcvtq_f32_s32(vcvtq_s32_f32(v144));
    v146 = vsubq_f32(v145, (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v145, v144)));
    v147 = vsubq_f32(v144, v146);
    v148 = *((float32x4_t *)a2 + 19);
    v149 = *((float32x4_t *)a2 + 20);
    v150 = *((float32x4_t *)a2 + 21);
    v151 = *((int32x4_t *)a2 + 22);
    v152 = vmulq_f32(*(float32x4_t *)(v7 + v119), *(float32x4_t *)a2);
    v153 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v152, 3), v121);
    v154 = vmulq_f32(v123, vrecpeq_f32(v153));
    v155 = vmulq_f32(v152, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v154, vrecpsq_f32(v154, v153))), (int8x16_t)v126));
    v156 = vmaxq_f32(v155, v126);
    v157 = (float32x4_t)vorrq_s8(vandq_s8(v124, (int8x16_t)v156), (int8x16_t)v128);
    v158 = (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v157, v133));
    v159 = vsubq_f32(vsubq_f32(v157, v128), vmulq_f32(vmulq_f32(v135, v158), v157));
    v160 = vmaxq_f32(vmulq_f32(v143, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v156, 0x17uLL)), (float32x4_t)vandq_s8(v131, (int8x16_t)vcgtq_f32(v130, v156))), v132), v158), vmulq_f32(v159, vaddq_f32(vaddq_f32(v139, vmulq_f32(v140, v159)), vmulq_f32(vmulq_f32(v159, v159), vaddq_f32(v136, vmulq_f32(v138, v159))))))), v141);
    v161 = vcvtq_f32_s32(vcvtq_s32_f32(v160));
    v162 = vsubq_f32(v161, (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v161, v160)));
    v163 = vsubq_f32(v160, v162);
    v164 = vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(vaddq_f32(v128, vmulq_f32(v147, vaddq_f32(v150, vmulq_f32(v147, vaddq_f32(v148, vmulq_f32(v149, v147)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v151, vcvtq_s32_f32(v146)), 0x17uLL)), vaddq_f32(v128, vmulq_f32(*((float32x4_t *)a2 + 60), vmulq_f32(vaddq_f32(v128, vmulq_f32(v163, vaddq_f32(v150, vmulq_f32(v163, vaddq_f32(v148, vmulq_f32(v149, v163)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v162), v151), 0x17uLL))))), v126), v128);
    v165 = (float32x4_t)vorrq_s8(vandq_s8(v124, (int8x16_t)v164), (int8x16_t)v128);
    v166 = (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v165, v133));
    v167 = vsubq_f32(vsubq_f32(v165, v128), vmulq_f32(vmulq_f32(v135, v166), v165));
    v168 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v164, 0x17uLL)), (float32x4_t)vandq_s8(v131, (int8x16_t)vcgtq_f32(v130, v164))), v132), v166), vmulq_f32(v167, vaddq_f32(vaddq_f32(v139, vmulq_f32(v140, v167)), vmulq_f32(vmulq_f32(v167, v167), vaddq_f32(v136, vmulq_f32(v138, v167))))))), v141);
    v169 = vcvtq_f32_s32(vcvtq_s32_f32(v168));
    v170 = vsubq_f32(v169, (float32x4_t)vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v169, v168)));
    v171 = vsubq_f32(v168, v170);
    v172 = vmulq_f32(vaddq_f32(v128, vmulq_f32(v171, vaddq_f32(v150, vmulq_f32(v171, vaddq_f32(v148, vmulq_f32(v149, v171)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v170), v151), 0x17uLL));
    v172.f32[3] = v12;
    *(float32x4_t *)(v6 + v119) = vaddq_f32(v120, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v172, (int8x16_t)vaddq_f32(v155, vmulq_laneq_f32(vsubq_f32(v172, v155), v120, 3))), v120), v155, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendLinearLightQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t *v120;
  int v121;
  uint64_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  int8x16_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  int32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v178;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    v12 = 1.0;
    while (v5 < 2)
    {
      v121 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = *(float32x4_t *)(v8 + v14 - 16);
      v178 = *(float32x4_t *)(v8 + v14);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v178, 3), v16);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v15, vmulq_f32(v22, vrecpsq_f32(v22, v18)));
      v25 = *((int8x16_t *)a2 + 31);
      v26 = *((float32x4_t *)a2 + 32);
      v28 = *((float32x4_t *)a2 + 23);
      v27 = *((float32x4_t *)a2 + 24);
      v29 = vmaxq_f32(vmulq_f32(v178, vmulq_f32(v23, vrecpsq_f32(v23, v19))), v26);
      v30 = vminq_f32(vmaxq_f32(v24, v26), v28);
      v31 = vminq_f32(v29, v28);
      v32 = *((float32x4_t *)a2 + 29);
      v33 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v30), (int8x16_t)v32);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v31), (int8x16_t)v32);
      v36 = *((float32x4_t *)a2 + 9);
      v35 = *((int8x16_t *)a2 + 10);
      v38 = *((float32x4_t *)a2 + 11);
      v37 = *((float32x4_t *)a2 + 12);
      v39 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v30))), v38);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v33, v37));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v34, v37));
      v43 = *((float32x4_t *)a2 + 13);
      v42 = *((float32x4_t *)a2 + 14);
      v44 = vaddq_f32(v39, v40);
      v45 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v31))), v38), v41);
      v46 = vsubq_f32(vsubq_f32(v33, v32), vmulq_f32(vmulq_f32(v43, v40), v33));
      v47 = vsubq_f32(vsubq_f32(v34, v32), vmulq_f32(vmulq_f32(v43, v41), v34));
      v49 = *((float32x4_t *)a2 + 15);
      v48 = *((float32x4_t *)a2 + 16);
      v51 = *((float32x4_t *)a2 + 17);
      v50 = *((float32x4_t *)a2 + 18);
      v52 = vaddq_f32(v44, vmulq_f32(v46, vaddq_f32(vaddq_f32(v48, vmulq_f32(v46, v51)), vmulq_f32(vmulq_f32(v46, v46), vaddq_f32(v42, vmulq_f32(v49, v46))))));
      v53 = vaddq_f32(v45, vmulq_f32(v47, vaddq_f32(vaddq_f32(v48, vmulq_f32(v47, v51)), vmulq_f32(vmulq_f32(v47, v47), vaddq_f32(v42, vmulq_f32(v49, v47))))));
      v54 = *((float32x4_t *)a2 + 19);
      v55 = *((float32x4_t *)a2 + 20);
      v56 = vmulq_f32(*(float32x4_t *)(v7 + v14 - 16), *(float32x4_t *)a2);
      v57 = vmulq_f32(*(float32x4_t *)(v7 + v14), *(float32x4_t *)a2);
      v58 = vmaxq_f32(vmulq_f32(v27, v52), v50);
      v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3), v16);
      v60 = vmaxq_f32(vmulq_f32(v27, v53), v50);
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v16);
      v62 = vmulq_f32(v21, vrecpeq_f32(v59));
      v63 = vmulq_f32(v21, vrecpeq_f32(v61));
      v64 = vandq_s8(v25, (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v61)));
      v65 = vmulq_f32(v56, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v59))), (int8x16_t)v26));
      v66 = vmulq_f32(v57, (float32x4_t)vorrq_s8(v64, (int8x16_t)v26));
      v67 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v68 = vminq_f32(vmaxq_f32(v65, v26), v28);
      v69 = vminq_f32(vmaxq_f32(v66, v26), v28);
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      v71 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v68), (int8x16_t)v32);
      v72 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v69), (int8x16_t)v32);
      v73 = vsubq_f32(v67, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v67, v58)));
      v74 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v71, v37));
      v75 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v72, v37));
      v76 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v68))), v38), v74);
      v77 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v69))), v38), v75);
      v78 = vsubq_f32(vsubq_f32(v71, v32), vmulq_f32(vmulq_f32(v43, v74), v71));
      v79 = vsubq_f32(vsubq_f32(v72, v32), vmulq_f32(vmulq_f32(v43, v75), v72));
      v80 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v70, v60)));
      v81 = vsubq_f32(v58, v73);
      v83 = *((float32x4_t *)a2 + 21);
      v82 = *((int32x4_t *)a2 + 22);
      v84 = vaddq_f32(v76, vmulq_f32(v78, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v42, vmulq_f32(v49, v78))))));
      v85 = vsubq_f32(v60, v80);
      v12 = 1.0;
      v86 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v81, vaddq_f32(v83, vmulq_f32(v81, vaddq_f32(v54, vmulq_f32(v55, v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v82, vcvtq_s32_f32(v73)), 0x17uLL));
      v87 = vmaxq_f32(vmulq_f32(v27, v84), v50);
      v88 = vmaxq_f32(vmulq_f32(v27, vaddq_f32(v77, vmulq_f32(v79, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v79)), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(v42, vmulq_f32(v49, v79))))))), v50);
      v89 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
      v90 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v85, vaddq_f32(v83, vmulq_f32(v85, vaddq_f32(v54, vmulq_f32(v55, v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v82, vcvtq_s32_f32(v80)), 0x17uLL));
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v88));
      v92 = vsubq_f32(v89, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v89, v87)));
      v93 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v91, v88)));
      v94 = vsubq_f32(v87, v92);
      v95 = vsubq_f32(v88, v93);
      v96 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v94, vaddq_f32(v83, vmulq_f32(v94, vaddq_f32(v54, vmulq_f32(v55, v94)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v92), v82), 0x17uLL));
      v97 = *((float32x4_t *)a2 + 60);
      v98 = vminq_f32(vmaxq_f32(vsubq_f32(v86, vaddq_f32(v32, vmulq_f32(v97, v96))), v26), v32);
      v99 = vminq_f32(vmaxq_f32(vsubq_f32(v90, vaddq_f32(v32, vmulq_f32(v97, vmulq_f32(vaddq_f32(v32, vmulq_f32(v95, vaddq_f32(v83, vmulq_f32(v95, vaddq_f32(v54, vmulq_f32(v55, v95)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v93), v82), 0x17uLL))))), v26), v32);
      v100 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v98, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v98)));
      v101 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v98), (int8x16_t)v32);
      v102 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v101, v37));
      v103 = vaddq_f32(vsubq_f32(v100, v38), v102);
      v104 = vsubq_f32(vsubq_f32(v101, v32), vmulq_f32(vmulq_f32(v43, v102), v101));
      v105 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v99), (int8x16_t)v32);
      v106 = (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v105, v37));
      v107 = vsubq_f32(vsubq_f32(v105, v32), vmulq_f32(vmulq_f32(v43, v106), v105));
      v108 = vaddq_f32(v103, vmulq_f32(v104, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v104)), vmulq_f32(vmulq_f32(v104, v104), vaddq_f32(v42, vmulq_f32(v49, v104))))));
      v109 = *((float32x4_t *)a2 + 25);
      v110 = vmaxq_f32(vmulq_f32(v109, v108), v50);
      v111 = vmaxq_f32(vmulq_f32(v109, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v99, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v36, v99))), v38), v106), vmulq_f32(v107, vaddq_f32(vaddq_f32(v48, vmulq_f32(v51, v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(v42, vmulq_f32(v49, v107))))))), v50);
      v112 = vcvtq_f32_s32(vcvtq_s32_f32(v110));
      v113 = vcvtq_f32_s32(vcvtq_s32_f32(v111));
      v114 = vsubq_f32(v112, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v112, v110)));
      v115 = vsubq_f32(v113, (float32x4_t)vandq_s8((int8x16_t)v32, (int8x16_t)vcgtq_f32(v113, v111)));
      v116 = vsubq_f32(v110, v114);
      v117 = vsubq_f32(v111, v115);
      v118 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v116, vaddq_f32(v83, vmulq_f32(v116, vaddq_f32(v54, vmulq_f32(v55, v116)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v114), v82), 0x17uLL));
      v118.i32[3] = 1.0;
      v119 = vmulq_f32(vaddq_f32(v32, vmulq_f32(v117, vaddq_f32(v83, vmulq_f32(v117, vaddq_f32(v54, vmulq_f32(v55, v117)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v115), v82), 0x17uLL));
      v119.i32[3] = 1.0;
      v120 = (float32x4_t *)(v6 + v14);
      v120[-1] = vaddq_f32(*(float32x4_t *)(v8 + v14 - 16), vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v118, (int8x16_t)vaddq_f32(v65, vmulq_laneq_f32(vsubq_f32(v118, v65), *(float32x4_t *)(v8 + v14 - 16), 3))), *(float32x4_t *)(v8 + v14 - 16)), v65, 3));
      *v120 = vaddq_f32(v178, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v119, (int8x16_t)vaddq_f32(v66, vmulq_laneq_f32(vsubq_f32(v119, v66), v178, 3))), v178), v66, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v121 = -v13;
    if (v121 >= v5)
      goto LABEL_3;
LABEL_10:
    v122 = 16 * v121;
    v123 = *(float32x4_t *)(v8 + v122);
    v124 = *((float32x4_t *)a2 + 6);
    v125 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v123, 3), v124);
    v127 = *((float32x4_t *)a2 + 7);
    v126 = *((int8x16_t *)a2 + 8);
    v128 = vmulq_f32(vrecpeq_f32(v125), v127);
    v129 = *((float32x4_t *)a2 + 32);
    v130 = *((float32x4_t *)a2 + 23);
    v131 = *((float32x4_t *)a2 + 24);
    v132 = vminq_f32(vmaxq_f32(vmulq_f32(v123, vmulq_f32(v128, vrecpsq_f32(v128, v125))), v129), v130);
    v133 = *((float32x4_t *)a2 + 29);
    v134 = (float32x4_t)vorrq_s8(vandq_s8(v126, (int8x16_t)v132), (int8x16_t)v133);
    v135 = *((float32x4_t *)a2 + 9);
    v136 = *((int8x16_t *)a2 + 10);
    v137 = *((float32x4_t *)a2 + 11);
    v138 = *((float32x4_t *)a2 + 12);
    v139 = (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v134, v138));
    v140 = *((float32x4_t *)a2 + 13);
    v141 = *((float32x4_t *)a2 + 14);
    v142 = vsubq_f32(vsubq_f32(v134, v133), vmulq_f32(vmulq_f32(v140, v139), v134));
    v143 = *((float32x4_t *)a2 + 15);
    v144 = *((float32x4_t *)a2 + 16);
    v145 = *((float32x4_t *)a2 + 17);
    v146 = *((float32x4_t *)a2 + 18);
    v147 = vmaxq_f32(vmulq_f32(v131, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v132, 0x17uLL)), (float32x4_t)vandq_s8(v136, (int8x16_t)vcgtq_f32(v135, v132))), v137), v139), vmulq_f32(v142, vaddq_f32(vaddq_f32(v144, vmulq_f32(v142, v145)), vmulq_f32(vmulq_f32(v142, v142), vaddq_f32(v141, vmulq_f32(v143, v142))))))), v146);
    v148 = vcvtq_f32_s32(vcvtq_s32_f32(v147));
    v149 = vsubq_f32(v148, (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v148, v147)));
    v150 = vsubq_f32(v147, v149);
    v151 = *((float32x4_t *)a2 + 19);
    v152 = *((float32x4_t *)a2 + 20);
    v153 = *((float32x4_t *)a2 + 21);
    v154 = *((int32x4_t *)a2 + 22);
    v155 = vmulq_f32(vaddq_f32(v133, vmulq_f32(v150, vaddq_f32(v153, vmulq_f32(v150, vaddq_f32(v151, vmulq_f32(v152, v150)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v154, vcvtq_s32_f32(v149)), 0x17uLL));
    v156 = vmulq_f32(*(float32x4_t *)(v7 + v122), *(float32x4_t *)a2);
    v157 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v156, 3), v124);
    v158 = vmulq_f32(v127, vrecpeq_f32(v157));
    v159 = vmulq_f32(v156, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v158, vrecpsq_f32(v158, v157))), (int8x16_t)v129));
    v160 = vminq_f32(vmaxq_f32(v159, v129), v130);
    v161 = (float32x4_t)vorrq_s8(vandq_s8(v126, (int8x16_t)v160), (int8x16_t)v133);
    v162 = (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v161, v138));
    v163 = vsubq_f32(vsubq_f32(v161, v133), vmulq_f32(vmulq_f32(v140, v162), v161));
    v164 = vmaxq_f32(vmulq_f32(v131, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v160, 0x17uLL)), (float32x4_t)vandq_s8(v136, (int8x16_t)vcgtq_f32(v135, v160))), v137), v162), vmulq_f32(v163, vaddq_f32(vaddq_f32(v144, vmulq_f32(v145, v163)), vmulq_f32(vmulq_f32(v163, v163), vaddq_f32(v141, vmulq_f32(v143, v163))))))), v146);
    v165 = vcvtq_f32_s32(vcvtq_s32_f32(v164));
    v166 = vsubq_f32(v165, (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v165, v164)));
    v167 = vsubq_f32(v164, v166);
    v168 = vminq_f32(vmaxq_f32(vsubq_f32(v155, vaddq_f32(v133, vmulq_f32(*((float32x4_t *)a2 + 60), vmulq_f32(vaddq_f32(v133, vmulq_f32(v167, vaddq_f32(v153, vmulq_f32(v167, vaddq_f32(v151, vmulq_f32(v152, v167)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v166), v154), 0x17uLL))))), v129), v133);
    v169 = (float32x4_t)vorrq_s8(vandq_s8(v126, (int8x16_t)v168), (int8x16_t)v133);
    v170 = (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v169, v138));
    v171 = vsubq_f32(vsubq_f32(v169, v133), vmulq_f32(vmulq_f32(v140, v170), v169));
    v172 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v168, 0x17uLL)), (float32x4_t)vandq_s8(v136, (int8x16_t)vcgtq_f32(v135, v168))), v137), v170), vmulq_f32(v171, vaddq_f32(vaddq_f32(v144, vmulq_f32(v145, v171)), vmulq_f32(vmulq_f32(v171, v171), vaddq_f32(v141, vmulq_f32(v143, v171))))))), v146);
    v173 = vcvtq_f32_s32(vcvtq_s32_f32(v172));
    v174 = vsubq_f32(v173, (float32x4_t)vandq_s8((int8x16_t)v133, (int8x16_t)vcgtq_f32(v173, v172)));
    v175 = vsubq_f32(v172, v174);
    v176 = vmulq_f32(vaddq_f32(v133, vmulq_f32(v175, vaddq_f32(v153, vmulq_f32(v175, vaddq_f32(v151, vmulq_f32(v152, v175)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v174), v154), 0x17uLL));
    v176.f32[3] = v12;
    *(float32x4_t *)(v6 + v122) = vaddq_f32(v123, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v176, (int8x16_t)vaddq_f32(v159, vmulq_laneq_f32(vsubq_f32(v176, v159), v123, 3))), v123), v159, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendPinLightTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t *v54;
  int v55;
  uint64_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v55 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *(float32x4_t *)a2);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13), *(float32x4_t *)a2);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v20 = *((float32x4_t *)a2 + 7);
      v21 = vmulq_f32(vrecpeq_f32(v18), v20);
      v22 = vmulq_f32(vrecpeq_f32(v19), v20);
      v23 = (int8x16_t)vmulq_f32(v21, vrecpsq_f32(v21, v18));
      v24 = (int8x16_t)vmulq_f32(v22, vrecpsq_f32(v22, v19));
      v25 = *((int8x16_t *)a2 + 31);
      v26 = *((float32x4_t *)a2 + 32);
      v27 = vandq_s8(v25, v24);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v25, v23), (int8x16_t)v26);
      v29 = *(float32x4_t *)(v7 + v13 - 16);
      v30 = *(float32x4_t *)(v7 + v13);
      v31 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 3), v16);
      v32 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 3), v16);
      v33 = vmulq_f32(v14, v28);
      v34 = vmulq_f32(v20, vrecpeq_f32(v31));
      v35 = vmulq_f32(v20, vrecpeq_f32(v32));
      v36 = vmulq_f32(v15, (float32x4_t)vorrq_s8(v27, (int8x16_t)v26));
      v37 = vmulq_f32(v35, vrecpsq_f32(v35, v32));
      v38 = vmulq_f32(v29, vmulq_f32(v34, vrecpsq_f32(v34, v31)));
      v39 = vmulq_f32(v30, v37);
      v40 = vaddq_f32(v33, v33);
      v41 = vaddq_f32(v36, v36);
      v42 = *((float32x4_t *)a2 + 29);
      v43 = (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgtq_f32(v38, v40));
      v44 = (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgtq_f32(v39, v41));
      v45 = vmulq_f32(v40, v43);
      v46 = vmulq_f32(v41, v44);
      v47 = vsubq_f32(v40, v42);
      v48 = vsubq_f32(v41, v42);
      v49 = (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgeq_f32(v47, v38));
      v50 = vaddq_f32(v45, vmulq_f32(v47, v49));
      v51 = (float32x4_t)vandq_s8((int8x16_t)v42, (int8x16_t)vcgeq_f32(v48, v39));
      v52 = vaddq_f32(v50, vmulq_f32(v38, (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v43, v49)), v26), (int8x16_t)v42, (int8x16_t)0)));
      v52.i32[3] = 1.0;
      v53 = vaddq_f32(vaddq_f32(vmulq_f32(v48, v51), v46), vmulq_f32(v39, (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v44, v51)), v26), (int8x16_t)v42, (int8x16_t)0)));
      v53.i32[3] = 1.0;
      v54 = (float32x4_t *)(v6 + v13);
      v54[-1] = vaddq_f32(v29, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v52, (int8x16_t)vaddq_f32(v33, vmulq_laneq_f32(vsubq_f32(v52, v33), v29, 3))), v29), v33, 3));
      *v54 = vaddq_f32(v30, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v53, (int8x16_t)vaddq_f32(v36, vmulq_laneq_f32(vsubq_f32(v53, v36), v30, 3))), v30), v36, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v55 = -v12;
    if (v55 >= v5)
      goto LABEL_3;
LABEL_10:
    v56 = 16 * v55;
    v57 = vmulq_f32(*(float32x4_t *)(v8 + v56), *(float32x4_t *)a2);
    v58 = *((float32x4_t *)a2 + 6);
    v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v58);
    v60 = *((float32x4_t *)a2 + 7);
    v61 = vmulq_f32(vrecpeq_f32(v59), v60);
    v62 = *((float32x4_t *)a2 + 32);
    v63 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v61, vrecpsq_f32(v61, v59))), (int8x16_t)v62);
    v64 = *(float32x4_t *)(v7 + v56);
    v65 = vmulq_f32(v57, v63);
    v66 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3), v58);
    v67 = vmulq_f32(v60, vrecpeq_f32(v66));
    v68 = vmulq_f32(v64, vmulq_f32(v67, vrecpsq_f32(v67, v66)));
    v69 = vaddq_f32(v65, v65);
    v70 = *((float32x4_t *)a2 + 29);
    v71 = (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v68, v69));
    v72 = vmulq_f32(v69, v71);
    v73 = vsubq_f32(v69, v70);
    v74 = (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgeq_f32(v73, v68));
    v75 = vaddq_f32(vaddq_f32(vmulq_f32(v73, v74), v72), vmulq_f32(v68, (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v71, v74)), v62), (int8x16_t)v70, (int8x16_t)0)));
    v75.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v56) = vaddq_f32(v64, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v75, (int8x16_t)vaddq_f32(v65, vmulq_laneq_f32(vsubq_f32(v75, v65), v64, 3))), v64), v65, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendPinLightPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  int8x16_t v123;
  float32x4_t *v124;
  int v125;
  uint64_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  int8x16_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  int8x16_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  int32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v187;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    v12 = 1.0;
    while (v5 < 2)
    {
      v125 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v14 - 16), *(float32x4_t *)a2);
      v16 = vmulq_f32(*(float32x4_t *)(v8 + v14), *(float32x4_t *)a2);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v17);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = (int8x16_t)vmulq_f32(v22, vrecpsq_f32(v22, v18));
      v25 = *((int8x16_t *)a2 + 31);
      v26 = *((float32x4_t *)a2 + 32);
      v27 = vmulq_f32(v15, (float32x4_t)vorrq_s8(vandq_s8(v25, v24), (int8x16_t)v26));
      v187 = vmulq_f32(v16, (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)vmulq_f32(v23, vrecpsq_f32(v23, v19))), (int8x16_t)v26));
      v28 = vmaxq_f32(v27, v26);
      v29 = vmaxq_f32(v187, v26);
      v30 = *((float32x4_t *)a2 + 29);
      v31 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v28), (int8x16_t)v30);
      v33 = *((float32x4_t *)a2 + 9);
      v32 = *((int8x16_t *)a2 + 10);
      v34 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v29), (int8x16_t)v30);
      v36 = *((float32x4_t *)a2 + 11);
      v35 = *((float32x4_t *)a2 + 12);
      v37 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v31, v35));
      v38 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v34, v35));
      v39 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v28))), v36), v37);
      v41 = *((float32x4_t *)a2 + 13);
      v40 = *((float32x4_t *)a2 + 14);
      v42 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v29))), v36), v38);
      v43 = vsubq_f32(vsubq_f32(v31, v30), vmulq_f32(vmulq_f32(v41, v37), v31));
      v44 = vsubq_f32(vsubq_f32(v34, v30), vmulq_f32(vmulq_f32(v41, v38), v34));
      v46 = *((float32x4_t *)a2 + 15);
      v45 = *((float32x4_t *)a2 + 16);
      v48 = *((float32x4_t *)a2 + 17);
      v47 = *((float32x4_t *)a2 + 18);
      v49 = *((float32x4_t *)a2 + 1);
      v50 = vmaxq_f32(vmulq_f32(v49, vaddq_f32(v39, vmulq_f32(v43, vaddq_f32(vaddq_f32(v45, vmulq_f32(v43, v48)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v40, vmulq_f32(v46, v43))))))), v47);
      v51 = vmaxq_f32(vmulq_f32(v49, vaddq_f32(v42, vmulq_f32(v44, vaddq_f32(vaddq_f32(v45, vmulq_f32(v44, v48)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v40, vmulq_f32(v46, v44))))))), v47);
      v52 = vcvtq_f32_s32(vcvtq_s32_f32(v50));
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v54 = vsubq_f32(v52, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v52, v50)));
      v55 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v53, v51)));
      v56 = vsubq_f32(v50, v54);
      v57 = *((float32x4_t *)a2 + 19);
      v58 = *((float32x4_t *)a2 + 20);
      v60 = *(float32x4_t *)(v7 + v14 - 16);
      v59 = *(float32x4_t *)(v7 + v14);
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 3), v17);
      v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v17);
      v63 = vmulq_f32(v21, vrecpeq_f32(v61));
      v64 = vmulq_f32(v21, vrecpeq_f32(v62));
      v66 = *((float32x4_t *)a2 + 21);
      v65 = *((int32x4_t *)a2 + 22);
      v67 = vmaxq_f32(vmulq_f32(v60, vmulq_f32(v63, vrecpsq_f32(v63, v61))), v26);
      v68 = vmaxq_f32(vmulq_f32(v59, vmulq_f32(v64, vrecpsq_f32(v64, v62))), v26);
      v69 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v67), (int8x16_t)v30);
      v70 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v68), (int8x16_t)v30);
      v71 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v69, v35));
      v72 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v67, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v67))), v36), v71);
      v73 = vsubq_f32(vsubq_f32(v69, v30), vmulq_f32(vmulq_f32(v41, v71), v69));
      v74 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v70, v35));
      v75 = vsubq_f32(v51, v55);
      v76 = vsubq_f32(vsubq_f32(v70, v30), vmulq_f32(vmulq_f32(v41, v74), v70));
      v77 = vmaxq_f32(vmulq_f32(v49, vaddq_f32(v72, vmulq_f32(v73, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v73)), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(v40, vmulq_f32(v46, v73))))))), v47);
      v78 = vmaxq_f32(vmulq_f32(v49, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v68))), v36), v74), vmulq_f32(v76, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v76)), vmulq_f32(vmulq_f32(v76, v76), vaddq_f32(v40, vmulq_f32(v46, v76))))))), v47);
      v79 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v56, vaddq_f32(v66, vmulq_f32(v56, vaddq_f32(v57, vmulq_f32(v58, v56)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v65, vcvtq_s32_f32(v54)), 0x17uLL));
      v80 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
      v82 = vsubq_f32(v80, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v80, v77)));
      v83 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v81, v78)));
      v84 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v75, vaddq_f32(v66, vmulq_f32(v75, vaddq_f32(v57, vmulq_f32(v58, v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v65, vcvtq_s32_f32(v55)), 0x17uLL));
      v85 = vsubq_f32(v77, v82);
      v86 = vsubq_f32(v78, v83);
      v87 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v85, vaddq_f32(v66, vmulq_f32(v85, vaddq_f32(v57, vmulq_f32(v58, v85)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v82), v65), 0x17uLL));
      v88 = vaddq_f32(v79, v79);
      v89 = vaddq_f32(v84, v84);
      v90 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v86, vaddq_f32(v66, vmulq_f32(v86, vaddq_f32(v57, vmulq_f32(v58, v86)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v83), v65), 0x17uLL));
      v91 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v87, v88));
      v92 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v90, v89));
      v93 = vsubq_f32(v88, v30);
      v94 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v93, v87));
      v95 = vaddq_f32(vmulq_f32(v93, v94), vmulq_f32(v88, v91));
      v96 = vsubq_f32(v89, v30);
      v97 = vaddq_f32(v91, v94);
      v98 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v96, v90));
      v99 = vaddq_f32(vmulq_f32(v96, v98), vmulq_f32(v89, v92));
      v100 = (int8x16_t)vcgeq_f32(vnegq_f32(v97), v26);
      v101 = (int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v92, v98)), v26);
      v12 = 1.0;
      v102 = vaddq_f32(v95, vmulq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v30, v100)));
      v103 = vaddq_f32(v99, vmulq_f32(v90, (float32x4_t)vandq_s8((int8x16_t)v30, v101)));
      v104 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v102, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v102)));
      v105 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v102), (int8x16_t)v30);
      v106 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v105, v35));
      v107 = vsubq_f32(vsubq_f32(v105, v30), vmulq_f32(vmulq_f32(v41, v106), v105));
      v108 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v103), (int8x16_t)v30);
      v109 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v108, v35));
      v110 = vsubq_f32(vsubq_f32(v108, v30), vmulq_f32(vmulq_f32(v41, v109), v108));
      v111 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v103, 0x17uLL)), (float32x4_t)vandq_s8(v32, (int8x16_t)vcgtq_f32(v33, v103))), v36), v109), vmulq_f32(v110, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v110)), vmulq_f32(vmulq_f32(v110, v110), vaddq_f32(v40, vmulq_f32(v46, v110))))));
      v112 = *((float32x4_t *)a2 + 2);
      v113 = vmaxq_f32(vmulq_f32(v112, vaddq_f32(vaddq_f32(vsubq_f32(v104, v36), v106), vmulq_f32(v107, vaddq_f32(vaddq_f32(v45, vmulq_f32(v48, v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(v40, vmulq_f32(v46, v107))))))), v47);
      v114 = vmaxq_f32(vmulq_f32(v112, v111), v47);
      v115 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
      v116 = vcvtq_f32_s32(vcvtq_s32_f32(v114));
      v117 = vsubq_f32(v115, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v115, v113)));
      v118 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v116, v114)));
      v119 = vsubq_f32(v113, v117);
      v120 = vsubq_f32(v114, v118);
      v121 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v119, vaddq_f32(v66, vmulq_f32(v119, vaddq_f32(v57, vmulq_f32(v58, v119)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v117), v65), 0x17uLL));
      v121.i32[3] = 1.0;
      v122 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v120, vaddq_f32(v66, vmulq_f32(v120, vaddq_f32(v57, vmulq_f32(v58, v120)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v118), v65), 0x17uLL));
      v122.i32[3] = 1.0;
      v123 = *((int8x16_t *)a2 + 5);
      v124 = (float32x4_t *)(v6 + v14);
      v124[-1] = vaddq_f32(v60, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v123, (int8x16_t)v121, (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(vsubq_f32(v121, v27), v60, 3))), v60), v27, 3));
      *v124 = vaddq_f32(v59, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v123, (int8x16_t)v122, (int8x16_t)vaddq_f32(v187, vmulq_laneq_f32(vsubq_f32(v122, v187), v59, 3))), v59), v187, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v125 = -v13;
    if (v125 >= v5)
      goto LABEL_3;
LABEL_10:
    v126 = 16 * v125;
    v127 = *((float32x4_t *)a2 + 1);
    v128 = vmulq_f32(*(float32x4_t *)(v8 + v126), *(float32x4_t *)a2);
    v129 = *((float32x4_t *)a2 + 6);
    v130 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3), v129);
    v132 = *((float32x4_t *)a2 + 7);
    v131 = *((int8x16_t *)a2 + 8);
    v133 = vmulq_f32(vrecpeq_f32(v130), v132);
    v134 = *((float32x4_t *)a2 + 32);
    v135 = vmulq_f32(v128, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v133, vrecpsq_f32(v133, v130))), (int8x16_t)v134));
    v136 = vmaxq_f32(v135, v134);
    v137 = *((float32x4_t *)a2 + 29);
    v138 = (float32x4_t)vorrq_s8(vandq_s8(v131, (int8x16_t)v136), (int8x16_t)v137);
    v139 = *((float32x4_t *)a2 + 9);
    v140 = *((int8x16_t *)a2 + 10);
    v141 = *((float32x4_t *)a2 + 11);
    v142 = *((float32x4_t *)a2 + 12);
    v143 = (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v138, v142));
    v144 = *((float32x4_t *)a2 + 13);
    v145 = *((float32x4_t *)a2 + 14);
    v146 = vsubq_f32(vsubq_f32(v138, v137), vmulq_f32(vmulq_f32(v144, v143), v138));
    v147 = *((float32x4_t *)a2 + 15);
    v148 = *((float32x4_t *)a2 + 16);
    v149 = *((float32x4_t *)a2 + 17);
    v150 = *((float32x4_t *)a2 + 18);
    v151 = vmaxq_f32(vmulq_f32(v127, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v136, 0x17uLL)), (float32x4_t)vandq_s8(v140, (int8x16_t)vcgtq_f32(v139, v136))), v141), v143), vmulq_f32(v146, vaddq_f32(vaddq_f32(v148, vmulq_f32(v146, v149)), vmulq_f32(vmulq_f32(v146, v146), vaddq_f32(v145, vmulq_f32(v147, v146))))))), v150);
    v152 = vcvtq_f32_s32(vcvtq_s32_f32(v151));
    v153 = vsubq_f32(v152, (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v152, v151)));
    v154 = vsubq_f32(v151, v153);
    v155 = *((float32x4_t *)a2 + 19);
    v156 = *((float32x4_t *)a2 + 20);
    v158 = *((float32x4_t *)a2 + 21);
    v157 = *((int32x4_t *)a2 + 22);
    v159 = vmulq_f32(vaddq_f32(v137, vmulq_f32(v154, vaddq_f32(v158, vmulq_f32(v154, vaddq_f32(v155, vmulq_f32(v156, v154)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v157, vcvtq_s32_f32(v153)), 0x17uLL));
    v160 = *(float32x4_t *)(v7 + v126);
    v161 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v160, 3), v129);
    v162 = vmulq_f32(v132, vrecpeq_f32(v161));
    v163 = vmaxq_f32(vmulq_f32(v160, vmulq_f32(v162, vrecpsq_f32(v162, v161))), v134);
    v164 = (float32x4_t)vorrq_s8(vandq_s8(v131, (int8x16_t)v163), (int8x16_t)v137);
    v165 = (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v164, v142));
    v166 = vsubq_f32(vsubq_f32(v164, v137), vmulq_f32(vmulq_f32(v144, v165), v164));
    v167 = vmaxq_f32(vmulq_f32(v127, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v163, 0x17uLL)), (float32x4_t)vandq_s8(v140, (int8x16_t)vcgtq_f32(v139, v163))), v141), v165), vmulq_f32(v166, vaddq_f32(vaddq_f32(v148, vmulq_f32(v149, v166)), vmulq_f32(vmulq_f32(v166, v166), vaddq_f32(v145, vmulq_f32(v147, v166))))))), v150);
    v168 = vcvtq_f32_s32(vcvtq_s32_f32(v167));
    v169 = vsubq_f32(v168, (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v168, v167)));
    v170 = vsubq_f32(v167, v169);
    v171 = vmulq_f32(vaddq_f32(v137, vmulq_f32(v170, vaddq_f32(v158, vmulq_f32(v170, vaddq_f32(v155, vmulq_f32(v156, v170)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v169), v157), 0x17uLL));
    v172 = vaddq_f32(v159, v159);
    v173 = (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v171, v172));
    v174 = vmulq_f32(v172, v173);
    v175 = vsubq_f32(v172, v137);
    v176 = (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgeq_f32(v175, v171));
    v177 = vaddq_f32(vaddq_f32(vmulq_f32(v175, v176), v174), vmulq_f32(v171, (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v173, v176)), v134))));
    v178 = (float32x4_t)vorrq_s8(vandq_s8(v131, (int8x16_t)v177), (int8x16_t)v137);
    v179 = (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v178, v142));
    v180 = vsubq_f32(vsubq_f32(v178, v137), vmulq_f32(vmulq_f32(v144, v179), v178));
    v181 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v177, 0x17uLL)), (float32x4_t)vandq_s8(v140, (int8x16_t)vcgtq_f32(v139, v177))), v141), v179), vmulq_f32(v180, vaddq_f32(vaddq_f32(v148, vmulq_f32(v149, v180)), vmulq_f32(vmulq_f32(v180, v180), vaddq_f32(v145, vmulq_f32(v147, v180))))))), v150);
    v182 = vcvtq_f32_s32(vcvtq_s32_f32(v181));
    v183 = vsubq_f32(v182, (float32x4_t)vandq_s8((int8x16_t)v137, (int8x16_t)vcgtq_f32(v182, v181)));
    v184 = vsubq_f32(v181, v183);
    v185 = vmulq_f32(vaddq_f32(v137, vmulq_f32(v184, vaddq_f32(v158, vmulq_f32(v184, vaddq_f32(v155, vmulq_f32(v156, v184)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v183), v157), 0x17uLL));
    v185.f32[3] = v12;
    *(float32x4_t *)(v6 + v126) = vaddq_f32(v160, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v185, (int8x16_t)vaddq_f32(v135, vmulq_laneq_f32(vsubq_f32(v185, v135), v160, 3))), v160), v135, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendPinLightQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  int8x16_t v135;
  float32x4_t *v136;
  int v137;
  uint64_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  int8x16_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  int8x16_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  int32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v200;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    v12 = 1.0;
    while (v5 < 2)
    {
      v137 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v14 - 16), *(float32x4_t *)a2);
      v16 = vmulq_f32(*(float32x4_t *)(v8 + v14), *(float32x4_t *)a2);
      v17 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v17);
      v21 = *((float32x4_t *)a2 + 7);
      v20 = *((int8x16_t *)a2 + 8);
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = (int8x16_t)vmulq_f32(v22, vrecpsq_f32(v22, v18));
      v25 = (int8x16_t)vmulq_f32(v23, vrecpsq_f32(v23, v19));
      v26 = *((int8x16_t *)a2 + 31);
      v27 = *((float32x4_t *)a2 + 32);
      v28 = vmulq_f32(v15, (float32x4_t)vorrq_s8(vandq_s8(v26, v24), (int8x16_t)v27));
      v29 = vmulq_f32(v16, (float32x4_t)vorrq_s8(vandq_s8(v26, v25), (int8x16_t)v27));
      v31 = *((float32x4_t *)a2 + 23);
      v30 = *((float32x4_t *)a2 + 24);
      v32 = vminq_f32(vmaxq_f32(v28, v27), v31);
      v33 = vminq_f32(vmaxq_f32(v29, v27), v31);
      v34 = *((float32x4_t *)a2 + 29);
      v200 = *((float32x4_t *)a2 + 30);
      v35 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v32), (int8x16_t)v34);
      v37 = *((float32x4_t *)a2 + 9);
      v36 = *((int8x16_t *)a2 + 10);
      v38 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v33), (int8x16_t)v34);
      v40 = *((float32x4_t *)a2 + 11);
      v39 = *((float32x4_t *)a2 + 12);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v35, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v38, v39));
      v43 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v37, v32))), v40), v41);
      v45 = *((float32x4_t *)a2 + 13);
      v44 = *((float32x4_t *)a2 + 14);
      v46 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v37, v33))), v40), v42);
      v47 = vsubq_f32(vsubq_f32(v35, v34), vmulq_f32(vmulq_f32(v45, v41), v35));
      v48 = vsubq_f32(vsubq_f32(v38, v34), vmulq_f32(vmulq_f32(v45, v42), v38));
      v50 = *((float32x4_t *)a2 + 15);
      v49 = *((float32x4_t *)a2 + 16);
      v52 = *((float32x4_t *)a2 + 17);
      v51 = *((float32x4_t *)a2 + 18);
      v53 = vmulq_f32(v30, vaddq_f32(v43, vmulq_f32(v47, vaddq_f32(vaddq_f32(v49, vmulq_f32(v47, v52)), vmulq_f32(vmulq_f32(v47, v47), vaddq_f32(v44, vmulq_f32(v50, v47)))))));
      v54 = vmulq_f32(v30, vaddq_f32(v46, vmulq_f32(v48, vaddq_f32(vaddq_f32(v49, vmulq_f32(v48, v52)), vmulq_f32(vmulq_f32(v48, v48), vaddq_f32(v44, vmulq_f32(v50, v48)))))));
      v55 = vmaxq_f32(v53, v51);
      v57 = *(float32x4_t *)(v7 + v14 - 16);
      v56 = *(float32x4_t *)(v7 + v14);
      v58 = vmaxq_f32(v54, v51);
      v59 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v17);
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3), v17);
      v61 = vmulq_f32(v21, vrecpeq_f32(v59));
      v62 = vmulq_f32(v21, vrecpeq_f32(v60));
      v63 = vmulq_f32(v62, vrecpsq_f32(v62, v60));
      v64 = vmaxq_f32(vmulq_f32(v57, vmulq_f32(v61, vrecpsq_f32(v61, v59))), v27);
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v66 = vminq_f32(v64, v31);
      v67 = vminq_f32(vmaxq_f32(vmulq_f32(v56, v63), v27), v31);
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v58));
      v69 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v66), (int8x16_t)v34);
      v70 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v67), (int8x16_t)v34);
      v71 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v69, v39));
      v72 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v70, v39));
      v73 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v37, v66))), v40), v71);
      v74 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v67, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v37, v67))), v40), v72);
      v75 = vmulq_f32(vmulq_f32(v45, v71), v69);
      v76 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v65, v55)));
      v77 = vsubq_f32(vsubq_f32(v69, v34), v75);
      v78 = vsubq_f32(vsubq_f32(v70, v34), vmulq_f32(vmulq_f32(v45, v72), v70));
      v79 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v68, v58)));
      v80 = vsubq_f32(v55, v76);
      v81 = *((float32x4_t *)a2 + 19);
      v82 = *((float32x4_t *)a2 + 20);
      v83 = vaddq_f32(v73, vmulq_f32(v77, vaddq_f32(vaddq_f32(v49, vmulq_f32(v52, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v44, vmulq_f32(v50, v77))))));
      v85 = *((float32x4_t *)a2 + 21);
      v84 = *((int32x4_t *)a2 + 22);
      v86 = vsubq_f32(v58, v79);
      v87 = vmaxq_f32(vmulq_f32(v30, v83), v51);
      v88 = vmaxq_f32(vmulq_f32(v30, vaddq_f32(v74, vmulq_f32(v78, vaddq_f32(vaddq_f32(v49, vmulq_f32(v52, v78)), vmulq_f32(vmulq_f32(v78, v78), vaddq_f32(v44, vmulq_f32(v50, v78))))))), v51);
      v89 = vmulq_f32(v86, vaddq_f32(v85, vmulq_f32(v86, vaddq_f32(v81, vmulq_f32(v82, v86)))));
      v90 = vcvtq_f32_s32(vcvtq_s32_f32(v87));
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v88));
      v92 = vsubq_f32(v90, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v90, v87)));
      v93 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v91, v88)));
      v94 = vmulq_f32(vaddq_f32(v34, vmulq_f32(v80, vaddq_f32(v85, vmulq_f32(v80, vaddq_f32(v81, vmulq_f32(v82, v80)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v76)), 0x17uLL));
      v95 = vsubq_f32(v87, v92);
      v96 = vsubq_f32(v88, v93);
      v97 = vmulq_f32(vaddq_f32(v34, v89), (float32x4_t)vshlq_n_s32(vaddq_s32(v84, vcvtq_s32_f32(v79)), 0x17uLL));
      v98 = vmulq_f32(vaddq_f32(v34, vmulq_f32(v95, vaddq_f32(v85, vmulq_f32(v95, vaddq_f32(v81, vmulq_f32(v82, v95)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v92), v84), 0x17uLL));
      v99 = vmulq_f32(vaddq_f32(v34, vmulq_f32(v96, vaddq_f32(v85, vmulq_f32(v96, vaddq_f32(v81, vmulq_f32(v82, v96)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v93), v84), 0x17uLL));
      v100 = vaddq_f32(v94, v94);
      v101 = vaddq_f32(v97, v97);
      v102 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v98, v100));
      v103 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v99, v101));
      v104 = vmulq_f32(v100, v102);
      v105 = vmulq_f32(v101, v103);
      v106 = vsubq_f32(v100, v34);
      v107 = vsubq_f32(v101, v34);
      v108 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgeq_f32(v106, v98));
      v109 = vaddq_f32(vmulq_f32(v106, v108), v104);
      v110 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgeq_f32(v107, v99));
      v111 = vaddq_f32(vmulq_f32(v107, v110), v105);
      v112 = vaddq_f32(v103, v110);
      v12 = 1.0;
      v113 = vminq_f32(vmaxq_f32(vaddq_f32(v109, vmulq_f32(v98, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v102, v108)), v27)))), v27), v200);
      v114 = vminq_f32(vmaxq_f32(vaddq_f32(v111, vmulq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgeq_f32(vnegq_f32(v112), v27)))), v27), v200);
      v115 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v113, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v37, v113)));
      v116 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v113), (int8x16_t)v34);
      v117 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v116, v39));
      v118 = vaddq_f32(vsubq_f32(v115, v40), v117);
      v119 = vsubq_f32(vsubq_f32(v116, v34), vmulq_f32(vmulq_f32(v45, v117), v116));
      v120 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v114), (int8x16_t)v34);
      v121 = (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v120, v39));
      v122 = vsubq_f32(vsubq_f32(v120, v34), vmulq_f32(vmulq_f32(v45, v121), v120));
      v123 = vaddq_f32(v118, vmulq_f32(v119, vaddq_f32(vaddq_f32(v49, vmulq_f32(v52, v119)), vmulq_f32(vmulq_f32(v119, v119), vaddq_f32(v44, vmulq_f32(v50, v119))))));
      v124 = *((float32x4_t *)a2 + 25);
      v125 = vmaxq_f32(vmulq_f32(v124, v123), v51);
      v126 = vmaxq_f32(vmulq_f32(v124, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v114, 0x17uLL)), (float32x4_t)vandq_s8(v36, (int8x16_t)vcgtq_f32(v37, v114))), v40), v121), vmulq_f32(v122, vaddq_f32(vaddq_f32(v49, vmulq_f32(v52, v122)), vmulq_f32(vmulq_f32(v122, v122), vaddq_f32(v44, vmulq_f32(v50, v122))))))), v51);
      v127 = vcvtq_f32_s32(vcvtq_s32_f32(v125));
      v128 = vcvtq_f32_s32(vcvtq_s32_f32(v126));
      v129 = vsubq_f32(v127, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v127, v125)));
      v130 = vsubq_f32(v128, (float32x4_t)vandq_s8((int8x16_t)v34, (int8x16_t)vcgtq_f32(v128, v126)));
      v131 = vsubq_f32(v125, v129);
      v132 = vsubq_f32(v126, v130);
      v133 = vmulq_f32(vaddq_f32(v34, vmulq_f32(v131, vaddq_f32(v85, vmulq_f32(v131, vaddq_f32(v81, vmulq_f32(v82, v131)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v129), v84), 0x17uLL));
      v133.i32[3] = 1.0;
      v134 = vmulq_f32(vaddq_f32(v34, vmulq_f32(v132, vaddq_f32(v85, vmulq_f32(v132, vaddq_f32(v81, vmulq_f32(v82, v132)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v130), v84), 0x17uLL));
      v134.i32[3] = 1.0;
      v135 = *((int8x16_t *)a2 + 5);
      v136 = (float32x4_t *)(v6 + v14);
      v136[-1] = vaddq_f32(v57, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v135, (int8x16_t)v133, (int8x16_t)vaddq_f32(v28, vmulq_laneq_f32(vsubq_f32(v133, v28), v57, 3))), v57), v28, 3));
      *v136 = vaddq_f32(v56, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v135, (int8x16_t)v134, (int8x16_t)vaddq_f32(v29, vmulq_laneq_f32(vsubq_f32(v134, v29), v56, 3))), v56), v29, 3));
      v13 -= 2;
      v14 += 32;
    }
    while (v5 + v13 > 1);
    v137 = -v13;
    if (v137 >= v5)
      goto LABEL_3;
LABEL_10:
    v138 = 16 * v137;
    v139 = vmulq_f32(*(float32x4_t *)(v8 + v138), *(float32x4_t *)a2);
    v140 = *((float32x4_t *)a2 + 6);
    v141 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3), v140);
    v143 = *((float32x4_t *)a2 + 7);
    v142 = *((int8x16_t *)a2 + 8);
    v144 = vmulq_f32(vrecpeq_f32(v141), v143);
    v145 = *((float32x4_t *)a2 + 32);
    v146 = vmulq_f32(v139, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v144, vrecpsq_f32(v144, v141))), (int8x16_t)v145));
    v147 = *((float32x4_t *)a2 + 23);
    v148 = *((float32x4_t *)a2 + 24);
    v149 = vminq_f32(vmaxq_f32(v146, v145), v147);
    v150 = *((float32x4_t *)a2 + 29);
    v151 = (float32x4_t)vorrq_s8(vandq_s8(v142, (int8x16_t)v149), (int8x16_t)v150);
    v152 = *((float32x4_t *)a2 + 9);
    v153 = *((int8x16_t *)a2 + 10);
    v154 = *((float32x4_t *)a2 + 11);
    v155 = *((float32x4_t *)a2 + 12);
    v156 = (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v151, v155));
    v157 = *((float32x4_t *)a2 + 13);
    v158 = *((float32x4_t *)a2 + 14);
    v159 = vsubq_f32(vsubq_f32(v151, v150), vmulq_f32(vmulq_f32(v157, v156), v151));
    v160 = *((float32x4_t *)a2 + 15);
    v161 = *((float32x4_t *)a2 + 16);
    v162 = *((float32x4_t *)a2 + 17);
    v163 = *((float32x4_t *)a2 + 18);
    v164 = vmaxq_f32(vmulq_f32(v148, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v149, 0x17uLL)), (float32x4_t)vandq_s8(v153, (int8x16_t)vcgtq_f32(v152, v149))), v154), v156), vmulq_f32(v159, vaddq_f32(vaddq_f32(v161, vmulq_f32(v159, v162)), vmulq_f32(vmulq_f32(v159, v159), vaddq_f32(v158, vmulq_f32(v160, v159))))))), v163);
    v165 = vcvtq_f32_s32(vcvtq_s32_f32(v164));
    v166 = vsubq_f32(v165, (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v165, v164)));
    v167 = vsubq_f32(v164, v166);
    v168 = *((float32x4_t *)a2 + 19);
    v169 = *((float32x4_t *)a2 + 20);
    v170 = *((float32x4_t *)a2 + 21);
    v171 = *((int32x4_t *)a2 + 22);
    v172 = vmulq_f32(vaddq_f32(v150, vmulq_f32(v167, vaddq_f32(v170, vmulq_f32(v167, vaddq_f32(v168, vmulq_f32(v169, v167)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v171, vcvtq_s32_f32(v166)), 0x17uLL));
    v173 = *(float32x4_t *)(v7 + v138);
    v174 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v173, 3), v140);
    v175 = vmulq_f32(v143, vrecpeq_f32(v174));
    v176 = vminq_f32(vmaxq_f32(vmulq_f32(v173, vmulq_f32(v175, vrecpsq_f32(v175, v174))), v145), v147);
    v177 = (float32x4_t)vorrq_s8(vandq_s8(v142, (int8x16_t)v176), (int8x16_t)v150);
    v178 = (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v177, v155));
    v179 = vsubq_f32(vsubq_f32(v177, v150), vmulq_f32(vmulq_f32(v157, v178), v177));
    v180 = vmaxq_f32(vmulq_f32(v148, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v176, 0x17uLL)), (float32x4_t)vandq_s8(v153, (int8x16_t)vcgtq_f32(v152, v176))), v154), v178), vmulq_f32(v179, vaddq_f32(vaddq_f32(v161, vmulq_f32(v162, v179)), vmulq_f32(vmulq_f32(v179, v179), vaddq_f32(v158, vmulq_f32(v160, v179))))))), v163);
    v181 = vcvtq_f32_s32(vcvtq_s32_f32(v180));
    v182 = vsubq_f32(v181, (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v181, v180)));
    v183 = vsubq_f32(v180, v182);
    v184 = vmulq_f32(vaddq_f32(v150, vmulq_f32(v183, vaddq_f32(v170, vmulq_f32(v183, vaddq_f32(v168, vmulq_f32(v169, v183)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v182), v171), 0x17uLL));
    v185 = vaddq_f32(v172, v172);
    v186 = (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v184, v185));
    v187 = vmulq_f32(v185, v186);
    v188 = vsubq_f32(v185, v150);
    v189 = (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgeq_f32(v188, v184));
    v190 = vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v188, v189), v187), vmulq_f32(v184, (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgeq_f32(vnegq_f32(vaddq_f32(v186, v189)), v145)))), v145), *((float32x4_t *)a2 + 30));
    v191 = (float32x4_t)vorrq_s8(vandq_s8(v142, (int8x16_t)v190), (int8x16_t)v150);
    v192 = (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v191, v155));
    v193 = vsubq_f32(vsubq_f32(v191, v150), vmulq_f32(vmulq_f32(v157, v192), v191));
    v194 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v190, 0x17uLL)), (float32x4_t)vandq_s8(v153, (int8x16_t)vcgtq_f32(v152, v190))), v154), v192), vmulq_f32(v193, vaddq_f32(vaddq_f32(v161, vmulq_f32(v162, v193)), vmulq_f32(vmulq_f32(v193, v193), vaddq_f32(v158, vmulq_f32(v160, v193))))))), v163);
    v195 = vcvtq_f32_s32(vcvtq_s32_f32(v194));
    v196 = vsubq_f32(v195, (float32x4_t)vandq_s8((int8x16_t)v150, (int8x16_t)vcgtq_f32(v195, v194)));
    v197 = vsubq_f32(v194, v196);
    v198 = vmulq_f32(vaddq_f32(v150, vmulq_f32(v197, vaddq_f32(v170, vmulq_f32(v197, vaddq_f32(v168, vmulq_f32(v169, v197)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v196), v171), 0x17uLL));
    v198.f32[3] = v12;
    *(float32x4_t *)(v6 + v138) = vaddq_f32(v173, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v198, (int8x16_t)vaddq_f32(v146, vmulq_laneq_f32(vsubq_f32(v198, v146), v173, 3))), v173), v146, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendHardMixTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  __int128 v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t *v79;
  int v80;
  uint64_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 12);
    v8 = *((_QWORD *)a1 + 10);
    v9 = 16 * *((int *)a1 + 22);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 26);
    while (v5 < 2)
    {
      v80 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = *(float32x4_t *)(v8 + v13 - 16);
      v15 = *(float32x4_t *)(v8 + v13);
      v17 = *((int8x16_t *)a2 + 5);
      v16 = *((float32x4_t *)a2 + 6);
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v16);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v16);
      v20 = *((float32x4_t *)a2 + 7);
      v21 = vmulq_f32(vrecpeq_f32(v18), v20);
      v22 = vmulq_f32(vrecpeq_f32(v19), v20);
      v23 = vmulq_f32(v21, vrecpsq_f32(v21, v18));
      v24 = vmulq_f32(*(float32x4_t *)(v7 + v13 - 16), *(float32x4_t *)a2);
      v25 = vmulq_f32(v22, vrecpsq_f32(v22, v19));
      v26 = vmulq_f32(*(float32x4_t *)(v7 + v13), *(float32x4_t *)a2);
      v27 = vmulq_f32(v14, v23);
      v28 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3), v16);
      v29 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3), v16);
      v30 = vmulq_f32(v20, vrecpeq_f32(v28));
      v31 = vmulq_f32(v15, v25);
      v32 = vmulq_f32(v20, vrecpeq_f32(v29));
      v33 = (int8x16_t)vmulq_f32(v30, vrecpsq_f32(v30, v28));
      v34 = (int8x16_t)vmulq_f32(v32, vrecpsq_f32(v32, v29));
      v36 = *((int8x16_t *)a2 + 31);
      v35 = *((float32x4_t *)a2 + 32);
      v37 = vmulq_f32(v24, (float32x4_t)vorrq_s8(vandq_s8(v36, v33), (int8x16_t)v35));
      v38 = vmulq_f32(v26, (float32x4_t)vorrq_s8(vandq_s8(v36, v34), (int8x16_t)v35));
      v39 = *((float32x4_t *)a2 + 29);
      v40 = *((float32x4_t *)a2 + 77);
      v41 = vmulq_f32(vsubq_f32(v39, v27), v40);
      v42 = vmulq_f32(vsubq_f32(v39, v31), v40);
      v43 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      v44 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      v45 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v43, v41)));
      v46 = *((float32x4_t *)a2 + 78);
      v47 = vmulq_f32(v46, v45);
      v48 = vmulq_f32(v46, vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v44, v42))));
      v49 = *((_OWORD *)a2 + 79);
      v50 = vsubq_f32(v47, vmulq_n_f32(v27, *(float *)&v49));
      v51 = vsubq_f32(v48, vmulq_n_f32(v31, *(float *)&v49));
      v52 = vmulq_lane_f32(*((float32x4_t *)a2 + 80), *(float32x2_t *)&v49, 1);
      v53 = vsubq_f32(v50, v52);
      v54 = vsubq_f32(v51, v52);
      v55 = *((float32x4_t *)a2 + 81);
      v56 = vmulq_f32(v47, v55);
      v57 = vmulq_f32(v55, v48);
      v58 = (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(v37, v53));
      v59 = (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(v38, v54));
      v60 = *((float32x4_t *)a2 + 82);
      v61 = vmulq_f32(v60, vsubq_f32(v37, v53));
      v62 = vmulq_f32(v60, vsubq_f32(v38, v54));
      v63 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
      v64 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v65 = vsubq_f32(v63, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v63, v61)));
      v66 = *((float32x4_t *)a2 + 83);
      v67 = vmulq_f32(vminq_f32(v59, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v57, v38))), vmulq_f32(v66, vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v64, v62)))));
      v68 = *((float32x4_t *)a2 + 84);
      v69 = vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(v37, v56)), vmulq_f32(vminq_f32(v58, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v56, v37))), vmulq_f32(v66, v65)));
      v70 = vminq_f32((float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v68, v27)), v58);
      v71 = vminq_f32((float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(v68, v31)), v59);
      v72 = *((float32x4_t *)a2 + 85);
      v73 = vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(v38, v57)), v67);
      v74 = vminq_f32(vmulq_f32(v70, vmulq_f32(v27, v72)), v69);
      v75 = vmulq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(vnegq_f32(v70), v35)));
      v76 = *((float32x4_t *)a2 + 86);
      v77 = vmaxq_f32(vmulq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(v27, v76)), (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(vminq_f32(v56, v39), v37))), vmulq_f32(v72, vsubq_f32(v27, v76))), vaddq_f32(v75, v74));
      v77.i32[3] = 1.0;
      v78 = vmaxq_f32(vmulq_f32(vmulq_f32(v72, vsubq_f32(v31, v76)), vminq_f32((float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(v31, v76)), (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgtq_f32(vminq_f32(v57, v39), v38)))), vaddq_f32(vmulq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v39, (int8x16_t)vcgeq_f32(vnegq_f32(v71), v35))), vminq_f32(vmulq_f32(v71, vmulq_f32(v31, v72)), v73)));
      v78.i32[3] = 1.0;
      v79 = (float32x4_t *)(v6 + v13);
      v79[-1] = vaddq_f32(v14, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v77, (int8x16_t)vaddq_f32(v37, vmulq_laneq_f32(vsubq_f32(v77, v37), v14, 3))), v14), v37, 3));
      *v79 = vaddq_f32(v15, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v78, (int8x16_t)vaddq_f32(v38, vmulq_laneq_f32(vsubq_f32(v78, v38), v15, 3))), v15), v38, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v80 = -v12;
    if (v80 >= v5)
      goto LABEL_3;
LABEL_10:
    v81 = 16 * v80;
    v82 = *(float32x4_t *)(v8 + v81);
    v83 = *((float32x4_t *)a2 + 6);
    v84 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v82, 3), v83);
    v85 = *((float32x4_t *)a2 + 7);
    v86 = vmulq_f32(vrecpeq_f32(v84), v85);
    v87 = vmulq_f32(v86, vrecpsq_f32(v86, v84));
    v88 = vmulq_f32(*(float32x4_t *)(v7 + v81), *(float32x4_t *)a2);
    v89 = vmulq_f32(v82, v87);
    v90 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v88, 3), v83);
    v91 = vmulq_f32(v85, vrecpeq_f32(v90));
    v92 = *((float32x4_t *)a2 + 32);
    v93 = vmulq_f32(v88, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v91, vrecpsq_f32(v91, v90))), (int8x16_t)v92));
    v94 = *((float32x4_t *)a2 + 29);
    v95 = vmulq_f32(vsubq_f32(v94, v89), *((float32x4_t *)a2 + 77));
    v96 = vcvtq_f32_s32(vcvtq_s32_f32(v95));
    v97 = vmulq_f32(*((float32x4_t *)a2 + 78), vsubq_f32(v96, (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v96, v95))));
    v98 = vsubq_f32(vsubq_f32(v97, vmulq_n_f32(v89, COERCE_FLOAT(*((_OWORD *)a2 + 79)))), vmulq_lane_f32(*((float32x4_t *)a2 + 80), *(float32x2_t *)((char *)a2 + 1264), 1));
    v99 = (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgeq_f32(v93, v98));
    v100 = vmulq_f32(*((float32x4_t *)a2 + 81), v97);
    v101 = vmulq_f32(*((float32x4_t *)a2 + 82), vsubq_f32(v93, v98));
    v102 = vcvtq_f32_s32(vcvtq_s32_f32(v101));
    v103 = vaddq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgeq_f32(v93, v100)), vmulq_f32(vminq_f32(v99, (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v100, v93))), vmulq_f32(*((float32x4_t *)a2 + 83), vsubq_f32(v102, (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v102, v101))))));
    v104 = vminq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(*((float32x4_t *)a2 + 84), v89)), v99);
    v105 = vmaxq_f32(vmulq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgeq_f32(v89, *((float32x4_t *)a2 + 86))), (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(vminq_f32(v100, v94), v93))), vmulq_f32(*((float32x4_t *)a2 + 85), vsubq_f32(v89, *((float32x4_t *)a2 + 86)))), vaddq_f32(vminq_f32(vmulq_f32(v104, vmulq_f32(v89, *((float32x4_t *)a2 + 85))), v103), vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgeq_f32(vnegq_f32(v104), v92)), v103)));
    v105.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v81) = vaddq_f32(v82, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v105, (int8x16_t)vaddq_f32(v93, vmulq_laneq_f32(vsubq_f32(v105, v93), v82, 3))), v82), v93, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendHardMixPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  float32x4_t v106;
  int8x16_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t *v112;
  int v113;
  uint64_t v114;
  float32x4_t v115;
  float32x4_t v116;
  int8x16_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  int8x16_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int32x4_t v147;
  int8x16_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v113 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = *((float32x4_t *)a2 + 1);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *(float32x4_t *)a2);
      v16 = vmulq_f32(*(float32x4_t *)(v8 + v13), *(float32x4_t *)a2);
      v17 = *((int8x16_t *)a2 + 5);
      v18 = *((float32x4_t *)a2 + 6);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v18);
      v20 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v18);
      v22 = *((float32x4_t *)a2 + 7);
      v21 = *((int8x16_t *)a2 + 8);
      v23 = vmulq_f32(vrecpeq_f32(v19), v22);
      v24 = vmulq_f32(vrecpeq_f32(v20), v22);
      v25 = vmulq_f32(v23, vrecpsq_f32(v23, v19));
      v26 = vmulq_f32(v24, vrecpsq_f32(v24, v20));
      v27 = vmulq_f32(v15, v25);
      v28 = vmulq_f32(v16, v26);
      v29 = *((float32x4_t *)a2 + 32);
      v30 = *((float32x4_t *)a2 + 29);
      v31 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v15, (int8x16_t)vminq_f32(vmaxq_f32(v27, v29), v30));
      v32 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v16, (int8x16_t)vminq_f32(vmaxq_f32(v28, v29), v30));
      v33 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v31, v21), (int8x16_t)v30);
      v34 = *((float32x4_t *)a2 + 9);
      v35 = *((int8x16_t *)a2 + 10);
      v36 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v32, v21), (int8x16_t)v30);
      v38 = *((float32x4_t *)a2 + 11);
      v37 = *((float32x4_t *)a2 + 12);
      v39 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v33, v37));
      v40 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v36, v37));
      v41 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v34, v31))), v38), v39);
      v43 = *((float32x4_t *)a2 + 13);
      v42 = *((float32x4_t *)a2 + 14);
      v44 = vmulq_f32(v43, v40);
      v45 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x17uLL)), (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v34, v32))), v38), v40);
      v46 = vmulq_f32(vmulq_f32(v43, v39), v33);
      v47 = vmulq_f32(v44, v36);
      v48 = vsubq_f32(vsubq_f32(v33, v30), v46);
      v49 = vsubq_f32(vsubq_f32(v36, v30), v47);
      v51 = *((float32x4_t *)a2 + 15);
      v50 = *((float32x4_t *)a2 + 16);
      v53 = *((float32x4_t *)a2 + 17);
      v52 = *((float32x4_t *)a2 + 18);
      v54 = vmaxq_f32(vmulq_f32(v14, vaddq_f32(v41, vmulq_f32(v48, vaddq_f32(vaddq_f32(v50, vmulq_f32(v48, v53)), vmulq_f32(vmulq_f32(v48, v48), vaddq_f32(v42, vmulq_f32(v51, v48))))))), v52);
      v55 = vmaxq_f32(vmulq_f32(v14, vaddq_f32(v45, vmulq_f32(v49, vaddq_f32(vaddq_f32(v50, vmulq_f32(v49, v53)), vmulq_f32(vmulq_f32(v49, v49), vaddq_f32(v42, vmulq_f32(v51, v49))))))), v52);
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v59 = *(float32x4_t *)(v7 + v13 - 16);
      v58 = *(float32x4_t *)(v7 + v13);
      v60 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v56, v54)));
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3), v18);
      v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), v18);
      v63 = vmulq_f32(v22, vrecpeq_f32(v61));
      v64 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v57, v55)));
      v65 = vmulq_f32(v22, vrecpeq_f32(v62));
      v66 = vmulq_f32(v63, vrecpsq_f32(v63, v61));
      v67 = *((float32x4_t *)a2 + 19);
      v68 = *((float32x4_t *)a2 + 20);
      v69 = vsubq_f32(v54, v60);
      v70 = vmulq_f32(v65, vrecpsq_f32(v65, v62));
      v71 = vsubq_f32(v55, v64);
      v72 = vminq_f32(vmaxq_f32(vmulq_f32(v59, v66), v29), v30);
      v73 = vminq_f32(vmaxq_f32(vmulq_f32(v58, v70), v29), v30);
      v74 = (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v34, v72));
      v75 = (float32x4_t)vandq_s8(v35, (int8x16_t)vcgtq_f32(v34, v73));
      v76 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v72), (int8x16_t)v30);
      v77 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v73), (int8x16_t)v30);
      v78 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v73, 0x17uLL)), v75);
      v79 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), v74), v38);
      v80 = vsubq_f32(v78, v38);
      v81 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v76, v37));
      v82 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v77, v37));
      v83 = vaddq_f32(v80, v82);
      v84 = vmulq_f32(v43, v82);
      v85 = vsubq_f32(vsubq_f32(v76, v30), vmulq_f32(vmulq_f32(v43, v81), v76));
      v87 = *((float32x4_t *)a2 + 21);
      v86 = *((int32x4_t *)a2 + 22);
      v88 = vsubq_f32(vsubq_f32(v77, v30), vmulq_f32(v84, v77));
      v89 = vaddq_f32(v42, vmulq_f32(v51, v85));
      v90 = vaddq_f32(v83, vmulq_f32(v88, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v88)), vmulq_f32(vmulq_f32(v88, v88), vaddq_f32(v42, vmulq_f32(v51, v88))))));
      v91 = vmulq_f32(v14, vaddq_f32(vaddq_f32(v79, v81), vmulq_f32(v85, vaddq_f32(vaddq_f32(v50, vmulq_f32(v53, v85)), vmulq_f32(vmulq_f32(v85, v85), v89)))));
      v92 = vmulq_f32(v14, v90);
      v93 = vmaxq_f32(v91, v52);
      v94 = vmaxq_f32(v92, v52);
      v95 = vcvtq_f32_s32(vcvtq_s32_f32(v93));
      v96 = vcvtq_f32_s32(vcvtq_s32_f32(v94));
      v97 = vsubq_f32(v95, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v95, v93)));
      v98 = vsubq_f32(v96, (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgtq_f32(v96, v94)));
      v99 = vsubq_f32(v93, v97);
      v100 = vsubq_f32(v94, v98);
      v101 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v15, (int8x16_t)vmulq_f32(vaddq_f32(v30, vmulq_f32(v69, vaddq_f32(v87, vmulq_f32(v69, vaddq_f32(v67, vmulq_f32(v68, v69)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v86, vcvtq_s32_f32(v60)), 0x17uLL)));
      v102 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v16, (int8x16_t)vmulq_f32(vaddq_f32(v30, vmulq_f32(v71, vaddq_f32(v87, vmulq_f32(v71, vaddq_f32(v67, vmulq_f32(v68, v71)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v86, vcvtq_s32_f32(v64)), 0x17uLL)));
      v103 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v99, vaddq_f32(v87, vmulq_f32(v99, vaddq_f32(v67, vmulq_f32(v68, v99)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v97), v86), 0x17uLL));
      v104 = vmulq_f32(vaddq_f32(v30, vmulq_f32(v100, vaddq_f32(v87, vmulq_f32(v100, vaddq_f32(v67, vmulq_f32(v68, v100)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v98), v86), 0x17uLL));
      v105 = vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v101, vsubq_f32(v30, v103)));
      v106 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v29, v103));
      v107 = vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v102, vsubq_f32(v30, v104)));
      v108 = (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v101, v30));
      v109 = vminq_f32((float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v29, v104)), (float32x4_t)vandq_s8((int8x16_t)v30, (int8x16_t)vcgeq_f32(v102, v30)));
      v110 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v106, v108), v29), (int8x16_t)v29, v105);
      v110.i32[3] = 1.0;
      v111 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v109, v29), (int8x16_t)v29, v107);
      v111.i32[3] = 1.0;
      v112 = (float32x4_t *)(v6 + v13);
      v112[-1] = vaddq_f32(v59, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v110, (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(vsubq_f32(v110, v27), v59, 3))), v59), v101, 3));
      *v112 = vaddq_f32(v58, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v111, (int8x16_t)vaddq_f32(v28, vmulq_laneq_f32(vsubq_f32(v111, v28), v58, 3))), v58), v102, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v113 = -v12;
    if (v113 >= v5)
      goto LABEL_3;
LABEL_10:
    v114 = 16 * v113;
    v115 = *((float32x4_t *)a2 + 1);
    v116 = vmulq_f32(*(float32x4_t *)(v8 + v114), *(float32x4_t *)a2);
    v117 = *((int8x16_t *)a2 + 5);
    v118 = *((float32x4_t *)a2 + 6);
    v119 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3), v118);
    v120 = *((float32x4_t *)a2 + 7);
    v121 = *((int8x16_t *)a2 + 8);
    v122 = vmulq_f32(vrecpeq_f32(v119), v120);
    v123 = vmulq_f32(v116, vmulq_f32(v122, vrecpsq_f32(v122, v119)));
    v124 = *((float32x4_t *)a2 + 32);
    v125 = *((float32x4_t *)a2 + 29);
    v126 = (float32x4_t)vbslq_s8(v117, (int8x16_t)v116, (int8x16_t)vminq_f32(vmaxq_f32(v123, v124), v125));
    v127 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v126, v121), (int8x16_t)v125);
    v128 = *((float32x4_t *)a2 + 9);
    v129 = *((int8x16_t *)a2 + 10);
    v130 = *((float32x4_t *)a2 + 11);
    v131 = *((float32x4_t *)a2 + 12);
    v132 = (float32x4_t)vandq_s8((int8x16_t)v125, (int8x16_t)vcgtq_f32(v127, v131));
    v133 = *((float32x4_t *)a2 + 13);
    v134 = *((float32x4_t *)a2 + 14);
    v135 = vsubq_f32(vsubq_f32(v127, v125), vmulq_f32(vmulq_f32(v133, v132), v127));
    v136 = *((float32x4_t *)a2 + 15);
    v137 = *((float32x4_t *)a2 + 16);
    v138 = *((float32x4_t *)a2 + 17);
    v139 = *((float32x4_t *)a2 + 18);
    v140 = vmaxq_f32(vmulq_f32(v115, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v126, 0x17uLL)), (float32x4_t)vandq_s8(v129, (int8x16_t)vcgtq_f32(v128, v126))), v130), v132), vmulq_f32(v135, vaddq_f32(vaddq_f32(v137, vmulq_f32(v135, v138)), vmulq_f32(vmulq_f32(v135, v135), vaddq_f32(v134, vmulq_f32(v136, v135))))))), v139);
    v141 = vcvtq_f32_s32(vcvtq_s32_f32(v140));
    v142 = vsubq_f32(v141, (float32x4_t)vandq_s8((int8x16_t)v125, (int8x16_t)vcgtq_f32(v141, v140)));
    v143 = vsubq_f32(v140, v142);
    v144 = *((float32x4_t *)a2 + 19);
    v145 = *((float32x4_t *)a2 + 20);
    v146 = *((float32x4_t *)a2 + 21);
    v147 = *((int32x4_t *)a2 + 22);
    v148 = (int8x16_t)vmulq_f32(vaddq_f32(v125, vmulq_f32(v143, vaddq_f32(v146, vmulq_f32(v143, vaddq_f32(v144, vmulq_f32(v145, v143)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v147, vcvtq_s32_f32(v142)), 0x17uLL));
    v149 = *(float32x4_t *)(v7 + v114);
    v150 = (float32x4_t)vbslq_s8(v117, (int8x16_t)v116, v148);
    v151 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v149, 3), v118);
    v152 = vmulq_f32(v120, vrecpeq_f32(v151));
    v153 = vminq_f32(vmaxq_f32(vmulq_f32(v149, vmulq_f32(v152, vrecpsq_f32(v152, v151))), v124), v125);
    v154 = (float32x4_t)vorrq_s8(vandq_s8(v121, (int8x16_t)v153), (int8x16_t)v125);
    v155 = (float32x4_t)vandq_s8((int8x16_t)v125, (int8x16_t)vcgtq_f32(v154, v131));
    v156 = vsubq_f32(vsubq_f32(v154, v125), vmulq_f32(vmulq_f32(v133, v155), v154));
    v157 = vmaxq_f32(vmulq_f32(v115, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v153, 0x17uLL)), (float32x4_t)vandq_s8(v129, (int8x16_t)vcgtq_f32(v128, v153))), v130), v155), vmulq_f32(v156, vaddq_f32(vaddq_f32(v137, vmulq_f32(v138, v156)), vmulq_f32(vmulq_f32(v156, v156), vaddq_f32(v134, vmulq_f32(v136, v156))))))), v139);
    v158 = vcvtq_f32_s32(vcvtq_s32_f32(v157));
    v159 = vsubq_f32(v158, (float32x4_t)vandq_s8((int8x16_t)v125, (int8x16_t)vcgtq_f32(v158, v157)));
    v160 = vsubq_f32(v157, v159);
    v161 = vmulq_f32(vaddq_f32(v125, vmulq_f32(v160, vaddq_f32(v146, vmulq_f32(v160, vaddq_f32(v144, vmulq_f32(v145, v160)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v159), v147), 0x17uLL));
    v162 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v125, (int8x16_t)vcgeq_f32(v124, v161)), (float32x4_t)vandq_s8((int8x16_t)v125, (int8x16_t)vcgeq_f32(v150, v125))), v124), (int8x16_t)v124, vbslq_s8((int8x16_t)vcgeq_f32(v150, vsubq_f32(v125, v161)), (int8x16_t)v125, (int8x16_t)0));
    v162.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v114) = vaddq_f32(v149, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v117, (int8x16_t)v162, (int8x16_t)vaddq_f32(v123, vmulq_laneq_f32(vsubq_f32(v162, v123), v149, 3))), v149), v150, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendHardMixQTTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int8x16_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t *v106;
  int v107;
  uint64_t v108;
  float32x4_t v109;
  int8x16_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  int8x16_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  int32x4_t v142;
  int8x16_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((_QWORD *)a1 + 10);
    v8 = *((_QWORD *)a1 + 12);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * *((int *)a1 + 22);
    while (v5 < 2)
    {
      v107 = 0;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v9;
      v7 += v11;
      v6 += v10;
      if (++v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = 16;
    do
    {
      v14 = vmulq_f32(*(float32x4_t *)(v8 + v13 - 16), *a2);
      v15 = vmulq_f32(*(float32x4_t *)(v8 + v13), *a2);
      v16 = (int8x16_t)a2[5];
      v17 = a2[6];
      v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3), v17);
      v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v17);
      v21 = a2[7];
      v20 = (int8x16_t)a2[8];
      v22 = vmulq_f32(vrecpeq_f32(v18), v21);
      v23 = vmulq_f32(vrecpeq_f32(v19), v21);
      v24 = vmulq_f32(v22, vrecpsq_f32(v22, v18));
      v25 = vmulq_f32(v23, vrecpsq_f32(v23, v19));
      v26 = vmulq_f32(v14, v24);
      v27 = vmulq_f32(v15, v25);
      v28 = a2[32];
      v29 = a2[29];
      v30 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v14, (int8x16_t)vminq_f32(vmaxq_f32(v26, v28), v29));
      v31 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v15, (int8x16_t)vminq_f32(vmaxq_f32(v27, v28), v29));
      v32 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v30, v20), (int8x16_t)v29);
      v34 = a2[9];
      v33 = (int8x16_t)a2[10];
      v35 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v31, v20), (int8x16_t)v29);
      v37 = a2[11];
      v36 = a2[12];
      v38 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v32, v36));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v35, v36));
      v40 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v34, v30))), v37), v38);
      v42 = a2[13];
      v41 = a2[14];
      v43 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x17uLL)), (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v34, v31))), v37), v39);
      v44 = vsubq_f32(vsubq_f32(v32, v29), vmulq_f32(vmulq_f32(v42, v38), v32));
      v45 = vsubq_f32(vsubq_f32(v35, v29), vmulq_f32(vmulq_f32(v42, v39), v35));
      v47 = a2[15];
      v46 = a2[16];
      v49 = a2[17];
      v48 = a2[18];
      v50 = vaddq_f32(v40, vmulq_f32(v44, vaddq_f32(vaddq_f32(v46, vmulq_f32(v44, v49)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v41, vmulq_f32(v47, v44))))));
      v51 = a2[24];
      v52 = vmulq_f32(v51, vaddq_f32(v43, vmulq_f32(v45, vaddq_f32(vaddq_f32(v46, vmulq_f32(v45, v49)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v41, vmulq_f32(v47, v45)))))));
      v53 = vmaxq_f32(vmulq_f32(v51, v50), v48);
      v54 = vmaxq_f32(v52, v48);
      v55 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v58 = *(float32x4_t *)(v7 + v13 - 16);
      v57 = *(float32x4_t *)(v7 + v13);
      v59 = vsubq_f32(v55, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v55, v53)));
      v60 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), v17);
      v61 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), v17);
      v62 = vmulq_f32(v21, vrecpeq_f32(v60));
      v63 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v56, v54)));
      v64 = vmulq_f32(v21, vrecpeq_f32(v61));
      v65 = vmulq_f32(v62, vrecpsq_f32(v62, v60));
      v66 = a2[19];
      v67 = a2[20];
      v68 = vsubq_f32(v53, v59);
      v69 = vmulq_f32(v64, vrecpsq_f32(v64, v61));
      v70 = vsubq_f32(v54, v63);
      v71 = vminq_f32(vmaxq_f32(vmulq_f32(v58, v65), v28), v29);
      v72 = vminq_f32(vmaxq_f32(vmulq_f32(v57, v69), v28), v29);
      v73 = (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v34, v71));
      v74 = (float32x4_t)vandq_s8(v33, (int8x16_t)vcgtq_f32(v34, v72));
      v75 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v71), (int8x16_t)v29);
      v76 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v72), (int8x16_t)v29);
      v77 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), v74);
      v78 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v71, 0x17uLL)), v73), v37);
      v79 = vsubq_f32(v77, v37);
      v80 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v75, v36));
      v81 = (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v76, v36));
      v82 = vaddq_f32(v79, v81);
      v83 = vmulq_f32(v42, v81);
      v84 = vsubq_f32(vsubq_f32(v75, v29), vmulq_f32(vmulq_f32(v42, v80), v75));
      v86 = a2[21];
      v85 = (int32x4_t)a2[22];
      v87 = vsubq_f32(vsubq_f32(v76, v29), vmulq_f32(v83, v76));
      v88 = vaddq_f32(v82, vmulq_f32(v87, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v87)), vmulq_f32(vmulq_f32(v87, v87), vaddq_f32(v41, vmulq_f32(v47, v87))))));
      v89 = vmaxq_f32(vmulq_f32(v51, vaddq_f32(vaddq_f32(v78, v80), vmulq_f32(v84, vaddq_f32(vaddq_f32(v46, vmulq_f32(v49, v84)), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(v41, vmulq_f32(v47, v84))))))), v48);
      v90 = vmaxq_f32(vmulq_f32(v51, v88), v48);
      v91 = vcvtq_f32_s32(vcvtq_s32_f32(v89));
      v92 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
      v93 = vsubq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v91, v89)));
      v94 = vsubq_f32(v92, (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgtq_f32(v92, v90)));
      v95 = vsubq_f32(v89, v93);
      v96 = vsubq_f32(v90, v94);
      v97 = vmulq_f32(v96, vaddq_f32(v86, vmulq_f32(v96, vaddq_f32(v66, vmulq_f32(v67, v96)))));
      v98 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v14, (int8x16_t)vmulq_f32(vaddq_f32(v29, vmulq_f32(v68, vaddq_f32(v86, vmulq_f32(v68, vaddq_f32(v66, vmulq_f32(v67, v68)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v59)), 0x17uLL)));
      v99 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v15, (int8x16_t)vmulq_f32(vaddq_f32(v29, vmulq_f32(v70, vaddq_f32(v86, vmulq_f32(v70, vaddq_f32(v66, vmulq_f32(v67, v70)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v85, vcvtq_s32_f32(v63)), 0x17uLL)));
      v100 = vmulq_f32(vaddq_f32(v29, vmulq_f32(v95, vaddq_f32(v86, vmulq_f32(v95, vaddq_f32(v66, vmulq_f32(v67, v95)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v93), v85), 0x17uLL));
      v101 = vmulq_f32(vaddq_f32(v29, v97), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v94), v85), 0x17uLL));
      v102 = vandq_s8((int8x16_t)v29, (int8x16_t)vcgeq_f32(v99, vsubq_f32(v29, v101)));
      v103 = vminq_f32((float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgeq_f32(v28, v101)), (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgeq_f32(v99, v29)));
      v104 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgeq_f32(v28, v100)), (float32x4_t)vandq_s8((int8x16_t)v29, (int8x16_t)vcgeq_f32(v98, v29))), v28), (int8x16_t)v28, vandq_s8((int8x16_t)v29, (int8x16_t)vcgeq_f32(v98, vsubq_f32(v29, v100))));
      v104.i32[3] = 1.0;
      v105 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v103, v28), (int8x16_t)v28, v102);
      v105.i32[3] = 1.0;
      v106 = (float32x4_t *)(v6 + v13);
      v106[-1] = vaddq_f32(v58, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v16, (int8x16_t)v104, (int8x16_t)vaddq_f32(v26, vmulq_laneq_f32(vsubq_f32(v104, v26), v58, 3))), v58), v98, 3));
      *v106 = vaddq_f32(v57, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v16, (int8x16_t)v105, (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(vsubq_f32(v105, v27), v57, 3))), v57), v99, 3));
      v12 -= 2;
      v13 += 32;
    }
    while (v5 + v12 > 1);
    v107 = -v12;
    if (v107 >= v5)
      goto LABEL_3;
LABEL_10:
    v108 = 16 * v107;
    v109 = vmulq_f32(*(float32x4_t *)(v8 + v108), *a2);
    v110 = (int8x16_t)a2[5];
    v111 = a2[6];
    v112 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v109, 3), v111);
    v114 = a2[7];
    v113 = (int8x16_t)a2[8];
    v115 = vmulq_f32(vrecpeq_f32(v112), v114);
    v116 = vmulq_f32(v109, vmulq_f32(v115, vrecpsq_f32(v115, v112)));
    v117 = a2[32];
    v118 = a2[29];
    v119 = (float32x4_t)vbslq_s8(v110, (int8x16_t)v109, (int8x16_t)vminq_f32(vmaxq_f32(v116, v117), v118));
    v120 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v119, v113), (int8x16_t)v118);
    v121 = a2[9];
    v122 = (int8x16_t)a2[10];
    v123 = a2[11];
    v124 = a2[12];
    v125 = (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgtq_f32(v120, v124));
    v126 = a2[13];
    v127 = a2[14];
    v128 = vsubq_f32(vsubq_f32(v120, v118), vmulq_f32(vmulq_f32(v126, v125), v120));
    v129 = a2[15];
    v130 = a2[16];
    v131 = a2[17];
    v132 = a2[18];
    v133 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v119, 0x17uLL)), (float32x4_t)vandq_s8(v122, (int8x16_t)vcgtq_f32(v121, v119))), v123), v125), vmulq_f32(v128, vaddq_f32(vaddq_f32(v130, vmulq_f32(v128, v131)), vmulq_f32(vmulq_f32(v128, v128), vaddq_f32(v127, vmulq_f32(v129, v128))))));
    v134 = a2[24];
    v135 = vmaxq_f32(vmulq_f32(v134, v133), v132);
    v136 = vcvtq_f32_s32(vcvtq_s32_f32(v135));
    v137 = vsubq_f32(v136, (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgtq_f32(v136, v135)));
    v138 = vsubq_f32(v135, v137);
    v139 = a2[19];
    v140 = a2[20];
    v141 = a2[21];
    v142 = (int32x4_t)a2[22];
    v143 = (int8x16_t)vmulq_f32(vaddq_f32(v118, vmulq_f32(v138, vaddq_f32(v141, vmulq_f32(v138, vaddq_f32(v139, vmulq_f32(v140, v138)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v142, vcvtq_s32_f32(v137)), 0x17uLL));
    v144 = *(float32x4_t *)(v7 + v108);
    v145 = (float32x4_t)vbslq_s8(v110, (int8x16_t)v109, v143);
    v146 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v144, 3), v111);
    v147 = vmulq_f32(v114, vrecpeq_f32(v146));
    v148 = vminq_f32(vmaxq_f32(vmulq_f32(v144, vmulq_f32(v147, vrecpsq_f32(v147, v146))), v117), v118);
    v149 = (float32x4_t)vorrq_s8(vandq_s8(v113, (int8x16_t)v148), (int8x16_t)v118);
    v150 = (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgtq_f32(v149, v124));
    v151 = vsubq_f32(vsubq_f32(v149, v118), vmulq_f32(vmulq_f32(v126, v150), v149));
    v152 = vmaxq_f32(vmulq_f32(v134, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v148, 0x17uLL)), (float32x4_t)vandq_s8(v122, (int8x16_t)vcgtq_f32(v121, v148))), v123), v150), vmulq_f32(v151, vaddq_f32(vaddq_f32(v130, vmulq_f32(v131, v151)), vmulq_f32(vmulq_f32(v151, v151), vaddq_f32(v127, vmulq_f32(v129, v151))))))), v132);
    v153 = vcvtq_f32_s32(vcvtq_s32_f32(v152));
    v154 = vsubq_f32(v153, (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgtq_f32(v153, v152)));
    v155 = vsubq_f32(v152, v154);
    v156 = vmulq_f32(vaddq_f32(v118, vmulq_f32(v155, vaddq_f32(v141, vmulq_f32(v155, vaddq_f32(v139, vmulq_f32(v140, v155)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v154), v142), 0x17uLL));
    v157 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgeq_f32(v117, v156)), (float32x4_t)vandq_s8((int8x16_t)v118, (int8x16_t)vcgeq_f32(v145, v118))), v117), (int8x16_t)v117, vbslq_s8((int8x16_t)vcgeq_f32(v145, vsubq_f32(v118, v156)), (int8x16_t)v118, (int8x16_t)0));
    v157.i32[3] = 1.0;
    *(float32x4_t *)(v6 + v108) = vaddq_f32(v144, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v110, (int8x16_t)v157, (int8x16_t)vaddq_f32(v116, vmulq_laneq_f32(vsubq_f32(v157, v116), v144, 3))), v144), v145, 3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetBlendDifferenceTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t *v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v55 = 0;
        v56 = 16 * v10;
        v57 = 16 * v9;
        v58 = 16 * v8;
        v59 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v60 = 0;
          do
          {
            v61 = v5[v60 / 0x10];
            v62 = vmulq_f32(v6[v60 / 0x10], *(float32x4_t *)a2);
            v63 = vmulq_laneq_f32(v62, v61, 3);
            v64 = vmulq_laneq_f32(v61, v62, 3);
            v65 = vsubq_f32(vaddq_f32(v61, v62), v63);
            v7[v60 / 0x10] = vaddq_f32(vabdq_f32(v63, v64), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v65, (int8x16_t)vsubq_f32(v65, v64)));
            v60 += 16;
          }
          while (v59 != v60);
          ++v55;
          v5 = (float32x4_t *)((char *)v5 + v56);
          v6 = (float32x4_t *)((char *)v6 + v57);
          v7 = (float32x4_t *)((char *)v7 + v58);
        }
        while (v55 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = v5[v18];
          v27 = v5[v18 + 1];
          v28 = v5[v18 + 2];
          v29 = v5[v18 + 3];
          v30 = vmulq_f32(v6[v18], *(float32x4_t *)a2);
          v31 = vmulq_f32(v6[v18 + 1], *(float32x4_t *)a2);
          v32 = vmulq_f32(v6[v18 + 2], *(float32x4_t *)a2);
          v33 = vmulq_f32(v6[v18 + 3], *(float32x4_t *)a2);
          v34 = vmulq_laneq_f32(v30, v26, 3);
          v35 = vmulq_laneq_f32(v31, v27, 3);
          v36 = vmulq_laneq_f32(v32, v28, 3);
          v37 = vmulq_laneq_f32(v33, v29, 3);
          v38 = vmulq_laneq_f32(v26, v30, 3);
          v39 = vmulq_laneq_f32(v27, v31, 3);
          v40 = vmulq_laneq_f32(v28, v32, 3);
          v41 = vmulq_laneq_f32(v29, v33, 3);
          v42 = vsubq_f32(vaddq_f32(v26, v30), v34);
          v43 = vsubq_f32(vaddq_f32(v27, v31), v35);
          v44 = vsubq_f32(vaddq_f32(v28, v32), v36);
          v45 = vsubq_f32(vaddq_f32(v29, v33), v37);
          v46 = *((int8x16_t *)a2 + 5);
          v47 = &v7[v18];
          *v47 = vaddq_f32(vabdq_f32(v34, v38), (float32x4_t)vbslq_s8(v46, (int8x16_t)v42, (int8x16_t)vsubq_f32(v42, v38)));
          v47[1] = vaddq_f32(vabdq_f32(v35, v39), (float32x4_t)vbslq_s8(v46, (int8x16_t)v43, (int8x16_t)vsubq_f32(v43, v39)));
          v19 += 4;
          v18 += 4;
          v47[2] = vaddq_f32(vabdq_f32(v36, v40), (float32x4_t)vbslq_s8(v46, (int8x16_t)v44, (int8x16_t)vsubq_f32(v44, v40)));
          v47[3] = vaddq_f32(vabdq_f32(v37, v41), (float32x4_t)vbslq_s8(v46, (int8x16_t)v45, (int8x16_t)vsubq_f32(v45, v41)));
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v48 = *v23++;
            v49 = v48;
            v50 = *v24++;
            v51 = vmulq_f32(v50, *(float32x4_t *)a2);
            v52 = vmulq_laneq_f32(v51, v49, 3);
            v53 = vmulq_laneq_f32(v49, v51, 3);
            v54 = vsubq_f32(vaddq_f32(v49, v51), v52);
            *v25++ = vaddq_f32(vabdq_f32(v52, v53), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v54, (int8x16_t)vsubq_f32(v54, v53)));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendDifferencePOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v16 = *((float32x4_t *)a2 + 7);
        v17 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v16);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 32);
        v21 = vmaxq_f32(v19, v20);
        v22 = *((float32x4_t *)a2 + 29);
        v23 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v21), (int8x16_t)v22);
        v24 = *((float32x4_t *)a2 + 9);
        v25 = *((int8x16_t *)a2 + 10);
        v26 = *((float32x4_t *)a2 + 11);
        v27 = *((float32x4_t *)a2 + 12);
        v28 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v23, v27));
        v29 = *((float32x4_t *)a2 + 13);
        v30 = *((float32x4_t *)a2 + 14);
        v31 = vsubq_f32(vsubq_f32(v23, v22), vmulq_f32(vmulq_f32(v29, v28), v23));
        v32 = *((float32x4_t *)a2 + 15);
        v33 = *((float32x4_t *)a2 + 16);
        v34 = *((float32x4_t *)a2 + 17);
        v35 = *((float32x4_t *)a2 + 18);
        v36 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v21))), v26), v28), vmulq_f32(v31, vaddq_f32(vaddq_f32(v33, vmulq_f32(v31, v34)), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(v30, vmulq_f32(v32, v31))))));
        v37 = *((float32x4_t *)a2 + 1);
        v38 = vmaxq_f32(vmulq_f32(v37, v36), v35);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *((float32x4_t *)a2 + 19);
        v43 = *((float32x4_t *)a2 + 20);
        v44 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v46 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v47 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v41, vaddq_f32(v44, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v40)), 0x17uLL));
        v48 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v46, 3), v14);
        v49 = vmulq_f32(v16, vrecpeq_f32(v48));
        v50 = vmulq_f32(v46, vmulq_f32(v49, vrecpsq_f32(v49, v48)));
        v51 = vmaxq_f32(v50, v20);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v51), (int8x16_t)v22);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v52, v27));
        v54 = vsubq_f32(vsubq_f32(v52, v22), vmulq_f32(vmulq_f32(v29, v53), v52));
        v55 = vmaxq_f32(vmulq_f32(v37, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v51))), v26), v53), vmulq_f32(v54, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v54)), vmulq_f32(vmulq_f32(v54, v54), vaddq_f32(v30, vmulq_f32(v32, v54))))))), v35);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        v59 = vabdq_f32(v47, vmulq_f32(vaddq_f32(v22, vmulq_f32(v58, vaddq_f32(v44, vmulq_f32(v58, vaddq_f32(v42, vmulq_f32(v43, v58)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v45), 0x17uLL)));
        v60 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v59), (int8x16_t)v22);
        v61 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v60, v27));
        v62 = vsubq_f32(vsubq_f32(v60, v22), vmulq_f32(vmulq_f32(v29, v61), v60));
        v63 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v59, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v59))), v26), v61), vmulq_f32(v62, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v62)), vmulq_f32(vmulq_f32(v62, v62), vaddq_f32(v30, vmulq_f32(v32, v62))))))), v35);
        v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
        v65 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v64, v63)));
        v66 = vsubq_f32(v63, v65);
        v67 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v66, vaddq_f32(v44, vmulq_f32(v66, vaddq_f32(v42, vmulq_f32(v43, v66)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v65), v45), 0x17uLL));
        v67.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v67, (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(vsubq_f32(v67, v50), v13, 3))), v13), v46, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendDifferenceQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v16 = *((float32x4_t *)a2 + 7);
        v17 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v16);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 32);
        v21 = *((float32x4_t *)a2 + 23);
        v22 = *((float32x4_t *)a2 + 24);
        v23 = vminq_f32(vmaxq_f32(v19, v20), v21);
        v24 = *((float32x4_t *)a2 + 29);
        v25 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v23), (int8x16_t)v24);
        v26 = *((float32x4_t *)a2 + 9);
        v27 = *((int8x16_t *)a2 + 10);
        v28 = *((float32x4_t *)a2 + 11);
        v29 = *((float32x4_t *)a2 + 12);
        v30 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v29));
        v31 = *((float32x4_t *)a2 + 13);
        v32 = *((float32x4_t *)a2 + 14);
        v33 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v31, v30), v25));
        v34 = *((float32x4_t *)a2 + 15);
        v35 = *((float32x4_t *)a2 + 16);
        v37 = *((float32x4_t *)a2 + 17);
        v36 = *((float32x4_t *)a2 + 18);
        v38 = vmaxq_f32(vmulq_f32(v22, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v23))), v28), v30), vmulq_f32(v33, vaddq_f32(vaddq_f32(v35, vmulq_f32(v33, v37)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v32, vmulq_f32(v34, v33))))))), v36);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *((float32x4_t *)a2 + 19);
        v43 = *((float32x4_t *)a2 + 20);
        v44 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v46 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v41, vaddq_f32(v44, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v40)), 0x17uLL));
        v47 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v48 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), v14);
        v49 = vmulq_f32(v16, vrecpeq_f32(v48));
        v50 = vmulq_f32(v47, vmulq_f32(v49, vrecpsq_f32(v49, v48)));
        v51 = vminq_f32(vmaxq_f32(v50, v20), v21);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v51), (int8x16_t)v24);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v52, v29));
        v54 = vsubq_f32(vsubq_f32(v52, v24), vmulq_f32(vmulq_f32(v31, v53), v52));
        v55 = vmaxq_f32(vmulq_f32(v22, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v51))), v28), v53), vmulq_f32(v54, vaddq_f32(vaddq_f32(v35, vmulq_f32(v37, v54)), vmulq_f32(vmulq_f32(v54, v54), vaddq_f32(v32, vmulq_f32(v34, v54))))))), v36);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        v59 = vminq_f32(vabdq_f32(v46, vmulq_f32(vaddq_f32(v24, vmulq_f32(v58, vaddq_f32(v44, vmulq_f32(v58, vaddq_f32(v42, vmulq_f32(v43, v58)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v45), 0x17uLL))), *((float32x4_t *)a2 + 30));
        v60 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v59), (int8x16_t)v24);
        v61 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v60, v29));
        v62 = vsubq_f32(vsubq_f32(v60, v24), vmulq_f32(vmulq_f32(v31, v61), v60));
        v63 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v59, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v59))), v28), v61), vmulq_f32(v62, vaddq_f32(vaddq_f32(v35, vmulq_f32(v37, v62)), vmulq_f32(vmulq_f32(v62, v62), vaddq_f32(v32, vmulq_f32(v34, v62))))))), v36);
        v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
        v65 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v64, v63)));
        v66 = vsubq_f32(v63, v65);
        v67 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v66, vaddq_f32(v44, vmulq_f32(v66, vaddq_f32(v42, vmulq_f32(v43, v66)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v65), v45), 0x17uLL));
        v67.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v67, (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(vsubq_f32(v67, v50), v13, 3))), v13), v47, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendExclusionTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  uint64_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if (v4 < 2)
    {
      if (v4 == 1)
      {
        v38 = 16 * v8;
        do
        {
          v39 = vmulq_f32(*v6, *(float32x4_t *)a2);
          v40 = vmulq_laneq_f32(v39, *v5, 3);
          v41 = vmulq_laneq_f32(*v5, v39, 3);
          v42 = vsubq_f32(vaddq_f32(*v5, v39), v40);
          *v7 = vaddq_f32(vaddq_f32(v41, vaddq_f32(v40, vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(*v5, v39)))), (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v42, (int8x16_t)vsubq_f32(v42, v41)));
          v5 += v10;
          v6 += v9;
          v7 = (float32x4_t *)((char *)v7 + v38);
          --v3;
        }
        while (v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v8;
      v13 = 16 * v10;
      v14 = 16 * v9;
      do
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = v5[v15];
          v18 = v5[v15 + 1];
          v19 = vmulq_f32(v6[v15], *(float32x4_t *)a2);
          v20 = vmulq_f32(v6[v15 + 1], *(float32x4_t *)a2);
          v21 = vmulq_laneq_f32(v19, v17, 3);
          v22 = vmulq_laneq_f32(v20, v18, 3);
          v23 = vmulq_laneq_f32(v17, v19, 3);
          v24 = vmulq_laneq_f32(v18, v20, 3);
          v25 = *((float32x4_t *)a2 + 87);
          v26 = vaddq_f32(v23, vaddq_f32(v21, vmulq_f32(v25, vmulq_f32(v17, v19))));
          v27 = vaddq_f32(v24, vaddq_f32(v22, vmulq_f32(v25, vmulq_f32(v18, v20))));
          v28 = vsubq_f32(vaddq_f32(v17, v19), v21);
          v29 = vsubq_f32(vaddq_f32(v18, v20), v22);
          v30 = *((int8x16_t *)a2 + 5);
          v31 = &v7[v15];
          *v31 = vaddq_f32(v26, (float32x4_t)vbslq_s8(v30, (int8x16_t)v28, (int8x16_t)vsubq_f32(v28, v23)));
          v31[1] = vaddq_f32(v27, (float32x4_t)vbslq_s8(v30, (int8x16_t)v29, (int8x16_t)vsubq_f32(v29, v24)));
          v16 -= 2;
          v15 += 2;
        }
        while (v4 + v16 > 1);
        if (v4 > -v16)
        {
          v32 = v5[v15];
          v33 = vmulq_f32(v6[v15], *(float32x4_t *)a2);
          v34 = vmulq_laneq_f32(v33, v32, 3);
          v35 = vmulq_laneq_f32(v32, v33, 3);
          v36 = vaddq_f32(v35, vaddq_f32(v34, vmulq_f32(*((float32x4_t *)a2 + 87), vmulq_f32(v32, v33))));
          v37 = vsubq_f32(vaddq_f32(v32, v33), v34);
          v7[v15] = vaddq_f32(v36, (float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v37, (int8x16_t)vsubq_f32(v37, v35)));
        }
        ++v11;
        v7 = (float32x4_t *)((char *)v7 + v12);
        v5 = (float32x4_t *)((char *)v5 + v13);
        v6 = (float32x4_t *)((char *)v6 + v14);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendExclusionPOWTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v16 = *((float32x4_t *)a2 + 7);
        v17 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v16);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 32);
        v21 = vmaxq_f32(v19, v20);
        v22 = *((float32x4_t *)a2 + 29);
        v23 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v21), (int8x16_t)v22);
        v24 = *((float32x4_t *)a2 + 9);
        v25 = *((int8x16_t *)a2 + 10);
        v26 = *((float32x4_t *)a2 + 11);
        v27 = *((float32x4_t *)a2 + 12);
        v28 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v23, v27));
        v29 = *((float32x4_t *)a2 + 13);
        v30 = *((float32x4_t *)a2 + 14);
        v31 = vsubq_f32(vsubq_f32(v23, v22), vmulq_f32(vmulq_f32(v29, v28), v23));
        v32 = *((float32x4_t *)a2 + 15);
        v33 = *((float32x4_t *)a2 + 16);
        v34 = *((float32x4_t *)a2 + 17);
        v35 = *((float32x4_t *)a2 + 18);
        v36 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v21))), v26), v28), vmulq_f32(v31, vaddq_f32(vaddq_f32(v33, vmulq_f32(v31, v34)), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(v30, vmulq_f32(v32, v31))))));
        v37 = *((float32x4_t *)a2 + 1);
        v38 = vmaxq_f32(vmulq_f32(v37, v36), v35);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *((float32x4_t *)a2 + 19);
        v43 = *((float32x4_t *)a2 + 20);
        v44 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v46 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v41, vaddq_f32(v44, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v40)), 0x17uLL));
        v47 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v48 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), v14);
        v49 = vmulq_f32(v16, vrecpeq_f32(v48));
        v50 = vmulq_f32(v47, vmulq_f32(v49, vrecpsq_f32(v49, v48)));
        v51 = vmaxq_f32(v50, v20);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v51), (int8x16_t)v22);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v52, v27));
        v54 = vsubq_f32(vsubq_f32(v52, v22), vmulq_f32(vmulq_f32(v29, v53), v52));
        v55 = vmaxq_f32(vmulq_f32(v37, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v51))), v26), v53), vmulq_f32(v54, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v54)), vmulq_f32(vmulq_f32(v54, v54), vaddq_f32(v30, vmulq_f32(v32, v54))))))), v35);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        v59 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v58, vaddq_f32(v44, vmulq_f32(v58, vaddq_f32(v42, vmulq_f32(v43, v58)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v45), 0x17uLL));
        v60 = vaddq_f32(vaddq_f32(v46, v59), vmulq_laneq_f32(vmulq_f32(v46, v59), *((float32x4_t *)a2 + 87), 2));
        v61 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v60), (int8x16_t)v22);
        v62 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v61, v27));
        v63 = vsubq_f32(vsubq_f32(v61, v22), vmulq_f32(vmulq_f32(v29, v62), v61));
        v64 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 2), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v60, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v24, v60))), v26), v62), vmulq_f32(v63, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v63)), vmulq_f32(vmulq_f32(v63, v63), vaddq_f32(v30, vmulq_f32(v32, v63))))))), v35);
        v65 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
        v66 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v65, v64)));
        v67 = vsubq_f32(v64, v66);
        v68 = vmulq_f32(vaddq_f32(v22, vmulq_f32(v67, vaddq_f32(v44, vmulq_f32(v67, vaddq_f32(v42, vmulq_f32(v43, v67)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v66), v45), 0x17uLL));
        v68.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v68, (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(vsubq_f32(v68, v50), v13, 3))), v13), v47, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendExclusionQTTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1 && *((_DWORD *)a1 + 2) - *(_DWORD *)a1 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a1 + 10);
    v6 = *((_QWORD *)a1 + 12);
    v7 = *((_QWORD *)a1 + 2);
    v8 = 16 * *((int *)a1 + 22);
    v9 = 16 * *((int *)a1 + 26);
    v10 = 16 * *((int *)a1 + 6);
    v11 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    do
    {
      v12 = 0;
      do
      {
        v13 = *(float32x4_t *)(v5 + v12);
        v14 = *((float32x4_t *)a2 + 6);
        v15 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v14);
        v16 = *((float32x4_t *)a2 + 7);
        v17 = *((int8x16_t *)a2 + 8);
        v18 = vmulq_f32(vrecpeq_f32(v15), v16);
        v19 = vmulq_f32(v13, vmulq_f32(v18, vrecpsq_f32(v18, v15)));
        v20 = *((float32x4_t *)a2 + 32);
        v21 = *((float32x4_t *)a2 + 23);
        v22 = *((float32x4_t *)a2 + 24);
        v23 = vminq_f32(vmaxq_f32(v19, v20), v21);
        v24 = *((float32x4_t *)a2 + 29);
        v25 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v23), (int8x16_t)v24);
        v26 = *((float32x4_t *)a2 + 9);
        v27 = *((int8x16_t *)a2 + 10);
        v28 = *((float32x4_t *)a2 + 11);
        v29 = *((float32x4_t *)a2 + 12);
        v30 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v25, v29));
        v31 = *((float32x4_t *)a2 + 13);
        v32 = *((float32x4_t *)a2 + 14);
        v33 = vsubq_f32(vsubq_f32(v25, v24), vmulq_f32(vmulq_f32(v31, v30), v25));
        v34 = *((float32x4_t *)a2 + 15);
        v35 = *((float32x4_t *)a2 + 16);
        v37 = *((float32x4_t *)a2 + 17);
        v36 = *((float32x4_t *)a2 + 18);
        v38 = vmaxq_f32(vmulq_f32(v22, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v23))), v28), v30), vmulq_f32(v33, vaddq_f32(vaddq_f32(v35, vmulq_f32(v33, v37)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v32, vmulq_f32(v34, v33))))))), v36);
        v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v39, v38)));
        v41 = vsubq_f32(v38, v40);
        v42 = *((float32x4_t *)a2 + 19);
        v43 = *((float32x4_t *)a2 + 20);
        v44 = *((float32x4_t *)a2 + 21);
        v45 = *((int32x4_t *)a2 + 22);
        v46 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v41, vaddq_f32(v44, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v45, vcvtq_s32_f32(v40)), 0x17uLL));
        v47 = vmulq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)a2);
        v48 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), v14);
        v49 = vmulq_f32(v16, vrecpeq_f32(v48));
        v50 = vmulq_f32(v47, vmulq_f32(v49, vrecpsq_f32(v49, v48)));
        v51 = vminq_f32(vmaxq_f32(v50, v20), v21);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v51), (int8x16_t)v24);
        v53 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v52, v29));
        v54 = vsubq_f32(vsubq_f32(v52, v24), vmulq_f32(vmulq_f32(v31, v53), v52));
        v55 = vmaxq_f32(vmulq_f32(v22, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v51))), v28), v53), vmulq_f32(v54, vaddq_f32(vaddq_f32(v35, vmulq_f32(v37, v54)), vmulq_f32(vmulq_f32(v54, v54), vaddq_f32(v32, vmulq_f32(v34, v54))))))), v36);
        v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v56, v55)));
        v58 = vsubq_f32(v55, v57);
        v59 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v58, vaddq_f32(v44, vmulq_f32(v58, vaddq_f32(v42, vmulq_f32(v43, v58)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v45), 0x17uLL));
        v60 = vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(v46, v59), vmulq_laneq_f32(vmulq_f32(v46, v59), *((float32x4_t *)a2 + 87), 2)), v20), *((float32x4_t *)a2 + 30));
        v61 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v60), (int8x16_t)v24);
        v62 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v61, v29));
        v63 = vsubq_f32(vsubq_f32(v61, v24), vmulq_f32(vmulq_f32(v31, v62), v61));
        v64 = vmaxq_f32(vmulq_f32(*((float32x4_t *)a2 + 25), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v60, 0x17uLL)), (float32x4_t)vandq_s8(v27, (int8x16_t)vcgtq_f32(v26, v60))), v28), v62), vmulq_f32(v63, vaddq_f32(vaddq_f32(v35, vmulq_f32(v37, v63)), vmulq_f32(vmulq_f32(v63, v63), vaddq_f32(v32, vmulq_f32(v34, v63))))))), v36);
        v65 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
        v66 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v65, v64)));
        v67 = vsubq_f32(v64, v66);
        v68 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v67, vaddq_f32(v44, vmulq_f32(v67, vaddq_f32(v42, vmulq_f32(v43, v67)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v66), v45), 0x17uLL));
        v68.i32[3] = 1.0;
        *(float32x4_t *)(v7 + v12) = vaddq_f32(v13, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)v68, (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(vsubq_f32(v68, v50), v13, 3))), v13), v47, 3));
        v12 += 16;
      }
      while (v11 != v12);
      ++v4;
      v5 += v8;
      v6 += v9;
      v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t GetBlendStencilAlphaTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v34 = 0;
        v35 = 16 * v10;
        v36 = 16 * v9;
        v37 = 16 * v8;
        v38 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v39 = 0;
          do
          {
            v7[v39 / 0x10] = vmulq_laneq_f32(v6[v39 / 0x10], vmulq_f32(v5[v39 / 0x10], *a2), 3);
            v39 += 16;
          }
          while (v38 != v39);
          ++v34;
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
          v7 = (float32x4_t *)((char *)v7 + v37);
        }
        while (v34 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = (float32x4_t)vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 0xCuLL);
          v27 = vmulq_n_f32(v6[v18 + 1], vmulq_laneq_f32(v26, v5[v18 + 1], 3).f32[0]);
          v28 = vmulq_n_f32(v6[v18 + 2], vmulq_laneq_f32(v26, v5[v18 + 2], 3).f32[0]);
          v29 = vmulq_n_f32(v6[v18 + 3], vmulq_laneq_f32(v26, v5[v18 + 3], 3).f32[0]);
          v30 = &v7[v18];
          *v30 = vmulq_n_f32(v6[v18], vmulq_laneq_f32(v26, v5[v18], 3).f32[0]);
          v30[1] = v27;
          v19 += 4;
          v18 += 4;
          v30[2] = v28;
          v30[3] = v29;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v31 = *v23++;
            v32 = v31;
            v33 = *v24++;
            *v25++ = vmulq_laneq_f32(v33, vmulq_f32(v32, *a2), 3);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendStencilLumaTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  float32x4_t v45;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v39 = 0;
        v40 = 16 * v10;
        v41 = 16 * v9;
        v42 = 16 * v8;
        v43 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v44 = 0;
          do
          {
            v45 = vmulq_f32(vmulq_f32(v5[v44 / 0x10], *a2), a2[88]);
            v7[v44 / 0x10] = vmulq_n_f32(v6[v44 / 0x10], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).f32[0]);
            v44 += 16;
          }
          while (v43 != v44);
          ++v39;
          v5 = (float32x4_t *)((char *)v5 + v40);
          v6 = (float32x4_t *)((char *)v6 + v41);
          v7 = (float32x4_t *)((char *)v7 + v42);
        }
        while (v39 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = a2[88];
          v27 = vmulq_f32(vmulq_f32(v5[v18], *a2), v26);
          v28 = vmulq_f32(vmulq_f32(v5[v18 + 1], *a2), v26);
          v29 = vmulq_f32(vmulq_f32(v5[v18 + 2], *a2), v26);
          v30 = vmulq_f32(vmulq_f32(v5[v18 + 3], *a2), v26);
          v31 = vmulq_n_f32(v6[v18 + 1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]);
          v32 = vmulq_n_f32(v6[v18 + 2], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]);
          v33 = vmulq_n_f32(v6[v18 + 3], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]);
          v34 = &v7[v18];
          *v34 = vmulq_n_f32(v6[v18], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]);
          v34[1] = v31;
          v19 += 4;
          v18 += 4;
          v34[2] = v32;
          v34[3] = v33;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v35 = *v23++;
            v36 = vmulq_f32(v35, *a2);
            v37 = *v24++;
            v38 = vmulq_f32(v36, a2[88]);
            *v25++ = vmulq_n_f32(v37, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendSilhouetteAlphaTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  int32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  int32x4_t *v22;
  int32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t *v30;
  int32x4_t v31;
  float v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (int32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v34 = 0;
        v35 = 16 * v10;
        v36 = 16 * v9;
        v37 = 16 * v8;
        v38 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v39 = 0;
          do
          {
            v7[v39 / 0x10] = vaddq_f32(v6[v39 / 0x10], vmulq_n_f32(v6[v39 / 0x10], vmulq_laneq_f32(vnegq_f32((float32x4_t)vdupq_laneq_s32(v5[v39 / 0x10], 3)), *a2, 3).f32[0]));
            v39 += 16;
          }
          while (v38 != v39);
          ++v34;
          v5 = (int32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
          v7 = (float32x4_t *)((char *)v7 + v37);
        }
        while (v34 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = (float32x4_t)vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 0xCuLL);
          v27 = vaddq_f32(v6[v18 + 1], vmulq_n_f32(v6[v18 + 1], vmulq_f32(v26, vnegq_f32((float32x4_t)vdupq_laneq_s32(v5[v18 + 1], 3))).f32[0]));
          v28 = vaddq_f32(v6[v18 + 2], vmulq_n_f32(v6[v18 + 2], vmulq_f32(v26, vnegq_f32((float32x4_t)vdupq_laneq_s32(v5[v18 + 2], 3))).f32[0]));
          v29 = vaddq_f32(v6[v18 + 3], vmulq_n_f32(v6[v18 + 3], vmulq_f32(v26, vnegq_f32((float32x4_t)vdupq_laneq_s32(v5[v18 + 3], 3))).f32[0]));
          v30 = &v7[v18];
          *v30 = vaddq_f32(v6[v18], vmulq_n_f32(v6[v18], vmulq_f32(v26, vnegq_f32((float32x4_t)vdupq_laneq_s32(v5[v18], 3))).f32[0]));
          v30[1] = v27;
          v19 += 4;
          v18 += 4;
          v30[2] = v28;
          v30[3] = v29;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v31 = *v23++;
            LODWORD(v32) = vmulq_laneq_f32(vnegq_f32((float32x4_t)vdupq_laneq_s32(v31, 3)), *a2, 3).u32[0];
            v33 = *v24++;
            *v25++ = vaddq_f32(v33, vmulq_n_f32(v33, v32));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (int32x4_t *)((char *)v5 + v14);
        v15 = (int32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendSilhouetteLumaTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t *v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t *v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v62 = 0;
        v63 = 16 * v10;
        v64 = 16 * v9;
        v65 = 16 * v8;
        v66 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v67 = 0;
          do
          {
            v68 = v5[v67 / 0x10];
            v69 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3), a2[6]);
            v70 = vmulq_f32(vrecpeq_f32(v69), a2[7]);
            v71 = vmulq_f32(a2[88], vmulq_f32(*a2, vmulq_f32(v68, vmulq_f32(v70, vrecpsq_f32(v70, v69)))));
            v7[v67 / 0x10] = vmulq_n_f32(v6[v67 / 0x10], vsubq_f32(a2[29], vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v71, (int8x16_t)v71, 8uLL), vaddq_f32(v71, (float32x4_t)vrev64q_s32((int32x4_t)v71))), a2[32]), a2[29])).f32[0]);
            v67 += 16;
          }
          while (v66 != v67);
          ++v62;
          v5 = (float32x4_t *)((char *)v5 + v63);
          v6 = (float32x4_t *)((char *)v6 + v64);
          v7 = (float32x4_t *)((char *)v7 + v65);
        }
        while (v62 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v5[v18];
          v24 = v5[v18 + 1];
          v25 = v5[v18 + 2];
          v26 = v5[v18 + 3];
          v27 = v22;
          v28 = v21;
          v29 = a2[6];
          v30 = a2[7];
          v31 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 3), v29);
          v32 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3), v29);
          v33 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3), v29);
          v34 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3), v29);
          v35 = vmulq_f32(vrecpeq_f32(v31), v30);
          v36 = vmulq_f32(vrecpeq_f32(v32), v30);
          v37 = vmulq_f32(vrecpeq_f32(v33), v30);
          v38 = vmulq_f32(vrecpeq_f32(v34), v30);
          v39 = vmulq_f32(vmulq_f32(v23, vmulq_f32(v35, vrecpsq_f32(v35, v31))), *a2);
          v40 = a2[88];
          v41 = vmulq_f32(v39, v40);
          v42 = vmulq_f32(vmulq_f32(vmulq_f32(v24, vmulq_f32(v36, vrecpsq_f32(v36, v32))), *a2), v40);
          v43 = vmulq_f32(vmulq_f32(vmulq_f32(v25, vmulq_f32(v37, vrecpsq_f32(v37, v33))), *a2), v40);
          v44 = vmulq_f32(v40, vmulq_f32(*a2, vmulq_f32(v26, vmulq_f32(v38, vrecpsq_f32(v38, v34)))));
          v45 = a2[32];
          v46 = vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL), vaddq_f32(v41, (float32x4_t)vrev64q_s32((int32x4_t)v41))), v45);
          v47 = vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL), vaddq_f32(v42, (float32x4_t)vrev64q_s32((int32x4_t)v42))), v45);
          v48 = vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL), vaddq_f32(v43, (float32x4_t)vrev64q_s32((int32x4_t)v43))), v45);
          v49 = vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), vaddq_f32(v44, (float32x4_t)vrev64q_s32((int32x4_t)v44))), v45);
          v50 = a2[29];
          v51 = v20;
          v52 = vmulq_n_f32(v6[v18], vsubq_f32(v50, vminq_f32(v46, v50)).f32[0]);
          v53 = vmulq_n_f32(v6[v18 + 1], vsubq_f32(v50, vminq_f32(v47, v50)).f32[0]);
          v54 = vmulq_n_f32(v6[v18 + 2], vsubq_f32(v50, vminq_f32(v48, v50)).f32[0]);
          v55 = vmulq_n_f32(v6[v18 + 3], vsubq_f32(v50, vminq_f32(v49, v50)).f32[0]);
          v56 = &v7[v18];
          v19 += 4;
          v18 += 4;
          *v56 = v52;
          v56[1] = v53;
          v56[2] = v54;
          v56[3] = v55;
          v22 += 4;
          v21 += 4;
          v20 = v51 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v57 = *v27++;
            v58 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 3), a2[6]);
            v59 = vmulq_f32(vrecpeq_f32(v58), a2[7]);
            v60 = vmulq_f32(a2[88], vmulq_f32(*a2, vmulq_f32(v57, vmulq_f32(v59, vrecpsq_f32(v59, v58)))));
            v61 = *v28++;
            *v51++ = vmulq_n_f32(v61, vsubq_f32(a2[29], vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL), vaddq_f32(v60, (float32x4_t)vrev64q_s32((int32x4_t)v60))), a2[32]), a2[29])).f32[0]);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendBehindTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v34 = 0;
        v35 = 16 * v10;
        v36 = 16 * v9;
        v37 = 16 * v8;
        v38 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v39 = 0;
          do
          {
            v7[v39 / 0x10] = vaddq_f32(v5[v39 / 0x10], vmulq_f32(vmulq_f32(v6[v39 / 0x10], *a2), vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v39 / 0x10], 3))));
            v39 += 16;
          }
          while (v38 != v39);
          ++v34;
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
          v7 = (float32x4_t *)((char *)v7 + v37);
        }
        while (v34 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = a2[3];
          v27 = vaddq_f32(v5[v18 + 1], vmulq_f32(vmulq_f32(v6[v18 + 1], *a2), vsubq_f32(v26, (float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v18 + 1], 3))));
          v28 = vaddq_f32(v5[v18 + 2], vmulq_f32(vmulq_f32(v6[v18 + 2], *a2), vsubq_f32(v26, (float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v18 + 2], 3))));
          v29 = vaddq_f32(v5[v18 + 3], vmulq_f32(vmulq_f32(v6[v18 + 3], *a2), vsubq_f32(v26, (float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v18 + 3], 3))));
          v30 = &v7[v18];
          *v30 = vaddq_f32(v5[v18], vmulq_f32(vmulq_f32(v6[v18], *a2), vsubq_f32(v26, (float32x4_t)vdupq_laneq_s32((int32x4_t)v5[v18], 3))));
          v30[1] = v27;
          v19 += 4;
          v18 += 4;
          v30[2] = v28;
          v30[3] = v29;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v31 = *v23++;
            v32 = v31;
            v33 = *v24++;
            *v25++ = vaddq_f32(v32, vmulq_f32(vmulq_f32(v33, *a2), vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 3))));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendAlphaAddTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  uint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  int8x16_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  int8x16_t *v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  int8x16_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  int8x16_t *v26;
  int v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x2_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  int8x16_t *v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v7 = (int8x16_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 26);
    v10 = *((int *)a1 + 22);
    if ((int)v4 < 3)
    {
      if ((int)v4 >= 1)
      {
        v72 = 0;
        v73 = 16 * v10;
        v74 = 16 * v9;
        v75 = 16 * v8;
        v76 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v77 = 0;
          do
          {
            v78 = v5[v77 / 0x10];
            v79 = vmulq_f32(v6[v77 / 0x10], *(float32x4_t *)a2);
            v80 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 3), *((float32x4_t *)a2 + 6));
            v81 = vmulq_f32(vrecpeq_f32(v80), *((float32x4_t *)a2 + 7));
            v82 = vmulq_f32(v78, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v81, vrecpsq_f32(v81, v80))), *((int8x16_t *)a2 + 32)));
            v7[v77 / 0x10] = vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v79, v82), *((float32x4_t *)a2 + 88)), *((float32x4_t *)a2 + 86)), (int8x16_t)vaddq_f32(v79, vmulq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v82, 3), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(*((float32x4_t *)a2 + 29), (float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3)), 0)), v82)));
            v77 += 16;
          }
          while (v76 != v77);
          ++v72;
          v5 = (float32x4_t *)((char *)v5 + v73);
          v6 = (float32x4_t *)((char *)v6 + v74);
          v7 = (int8x16_t *)((char *)v7 + v75);
        }
        while (v72 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 3;
      v16 = v6 + 3;
      v17 = v7 + 3;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = 3;
        v21 = v17;
        v22 = v16;
        v23 = v15;
        do
        {
          v24 = v23;
          v25 = v22;
          v26 = v21;
          v27 = v20;
          v28 = v5[v18];
          v29 = v5[v18 + 1];
          v30 = v5[v18 + 2];
          v31 = vmulq_f32(v6[v18], *(float32x4_t *)a2);
          v32 = vmulq_f32(v6[v18 + 1], *(float32x4_t *)a2);
          v33 = *((float32x4_t *)a2 + 29);
          v34 = vmulq_f32(v6[v18 + 2], *(float32x4_t *)a2);
          v36 = *((int8x16_t *)a2 + 5);
          v35 = *((float32x4_t *)a2 + 6);
          v37 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3), v35);
          v38 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 3), v35);
          v39 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 3), v35);
          v40 = *((float32x4_t *)a2 + 7);
          v41 = vmulq_f32(vrecpeq_f32(v37), v40);
          v42 = vmulq_f32(vrecpeq_f32(v38), v40);
          v43 = vmulq_f32(vrecpeq_f32(v39), v40);
          v44 = (int32x2_t)vsubq_f32(v33, (float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 3)).u64[0];
          v45 = (int8x16_t)vmulq_f32(v41, vrecpsq_f32(v41, v37));
          v46 = (int8x16_t)vmulq_f32(v42, vrecpsq_f32(v42, v38));
          v47 = *((int8x16_t *)a2 + 31);
          v48 = *((int8x16_t *)a2 + 32);
          v49 = vmulq_f32(v28, (float32x4_t)vorrq_s8(vandq_s8(v47, v45), v48));
          v50 = vmulq_f32(v29, (float32x4_t)vorrq_s8(vandq_s8(v47, v46), v48));
          v51 = vmulq_f32(v30, (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)vmulq_f32(v43, vrecpsq_f32(v43, v39))), v48));
          v52 = (int8x16_t)vaddq_f32(v31, vmulq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 3), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v33, (float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 3)), 0)), v49));
          v53 = vmulq_f32(v51, vminq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v33, (float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 3)), 0)));
          v54 = vaddq_f32(v31, v49);
          v55 = vaddq_f32(v32, v50);
          v56 = (int8x16_t)vaddq_f32(v32, vmulq_f32(v50, vminq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3), (float32x4_t)vdupq_lane_s32(v44, 0))));
          v57 = vaddq_f32(v34, v51);
          v58 = *((float32x4_t *)a2 + 88);
          v59 = vmaxq_f32(v54, v58);
          v60 = vmaxq_f32(v55, v58);
          v61 = vmaxq_f32(v57, v58);
          v62 = (int8x16_t)vaddq_f32(v34, v53);
          v63 = *((float32x4_t *)a2 + 86);
          v64 = &v7[v18];
          v19 += 3;
          v18 += 3;
          v23 += 3;
          *v64 = vbslq_s8(v36, (int8x16_t)vminq_f32(v59, v63), v52);
          v64[1] = vbslq_s8(v36, (int8x16_t)vminq_f32(v60, v63), v56);
          v64[2] = vbslq_s8(v36, (int8x16_t)vminq_f32(v61, v63), v62);
          v22 += 3;
          v21 += 3;
          v20 = v27 + 3;
        }
        while (v19 < v4 - 2);
        if ((int)v4 > (int)v19)
        {
          do
          {
            v65 = *v24++;
            v66 = v65;
            v67 = *v25++;
            v68 = vmulq_f32(v67, *(float32x4_t *)a2);
            v69 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3), *((float32x4_t *)a2 + 6));
            v70 = vmulq_f32(vrecpeq_f32(v69), *((float32x4_t *)a2 + 7));
            v71 = vmulq_f32(v66, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v70, vrecpsq_f32(v70, v69))), *((int8x16_t *)a2 + 32)));
            *v26++ = vbslq_s8(*((int8x16_t *)a2 + 5), (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v68, v71), *((float32x4_t *)a2 + 88)), *((float32x4_t *)a2 + 86)), (int8x16_t)vaddq_f32(v68, vmulq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(*((float32x4_t *)a2 + 29), (float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3)), 0)), v71)));
            ++v27;
          }
          while ((int)v4 > v27);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (int8x16_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (int8x16_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendLuminescentPremulTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t *v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t *v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v64 = 0;
        v65 = 16 * v10;
        v66 = 16 * v9;
        v67 = 16 * v8;
        v68 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v69 = 0;
          do
          {
            v70 = vmulq_f32(v5[v69 / 0x10], *(float32x4_t *)a2);
            v71 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3);
            v72 = vmaxq_f32(v71, *((float32x4_t *)a2 + 6));
            v73 = vmulq_f32(vrecpeq_f32(v72), *((float32x4_t *)a2 + 7));
            v7[v69 / 0x10] = vaddq_f32(vmulq_f32(v70, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v73, vrecpsq_f32(v73, v72))), *((int8x16_t *)a2 + 32))), vmulq_n_f32(v6[v69 / 0x10], vsubq_f32(*((float32x4_t *)a2 + 29), v71).f32[0]));
            v69 += 16;
          }
          while (v68 != v69);
          ++v64;
          v5 = (float32x4_t *)((char *)v5 + v65);
          v6 = (float32x4_t *)((char *)v6 + v66);
          v7 = (float32x4_t *)((char *)v7 + v67);
        }
        while (v64 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = vmulq_f32(v5[v18], *(float32x4_t *)a2);
          v25 = vmulq_f32(v5[v18 + 1], *(float32x4_t *)a2);
          v26 = vmulq_f32(v5[v18 + 2], *(float32x4_t *)a2);
          v27 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3);
          v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3);
          v29 = vmulq_f32(v5[v18 + 3], *(float32x4_t *)a2);
          v30 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3);
          v31 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 3);
          v32 = v21;
          v33 = v20;
          v34 = *((float32x4_t *)a2 + 6);
          v35 = *((float32x4_t *)a2 + 7);
          v36 = vmaxq_f32(v27, v34);
          v37 = vmaxq_f32(v28, v34);
          v38 = vmaxq_f32(v30, v34);
          v39 = vmaxq_f32(v31, v34);
          v40 = vmulq_f32(vrecpeq_f32(v36), v35);
          v41 = vmulq_f32(vrecpeq_f32(v37), v35);
          v42 = vmulq_f32(vrecpeq_f32(v38), v35);
          v43 = vmulq_f32(vrecpeq_f32(v39), v35);
          v44 = (int8x16_t)vmulq_f32(v40, vrecpsq_f32(v40, v36));
          v45 = (int8x16_t)vmulq_f32(v43, vrecpsq_f32(v43, v39));
          v47 = *((int8x16_t *)a2 + 31);
          v46 = *((int8x16_t *)a2 + 32);
          v48 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)vmulq_f32(v41, vrecpsq_f32(v41, v37))), v46);
          v49 = (float32x4_t)vorrq_s8(vandq_s8(v47, (int8x16_t)vmulq_f32(v42, vrecpsq_f32(v42, v38))), v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(v47, v45), v46);
          v51 = vmulq_f32(v24, (float32x4_t)vorrq_s8(vandq_s8(v47, v44), v46));
          v52 = *((float32x4_t *)a2 + 29);
          v53 = vaddq_f32(v51, vmulq_n_f32(v6[v18], vsubq_f32(v52, v27).f32[0]));
          v54 = vaddq_f32(vmulq_f32(v25, v48), vmulq_n_f32(v6[v18 + 1], vsubq_f32(v52, v28).f32[0]));
          v55 = vaddq_f32(vmulq_f32(v26, v49), vmulq_n_f32(v6[v18 + 2], vsubq_f32(v52, v30).f32[0]));
          v56 = vaddq_f32(vmulq_f32(v29, v50), vmulq_n_f32(v6[v18 + 3], vsubq_f32(v52, v31).f32[0]));
          v57 = &v7[v18];
          v19 += 4;
          v18 += 4;
          *v57 = v53;
          v57[1] = v54;
          v57[2] = v55;
          v57[3] = v56;
          v22 += 4;
          v21 = v32 + 4;
          v20 += 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v58 = *v23++;
            v59 = vmulq_f32(v58, *(float32x4_t *)a2);
            v60 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3);
            v61 = vmaxq_f32(v60, *((float32x4_t *)a2 + 6));
            v62 = vmulq_f32(vrecpeq_f32(v61), *((float32x4_t *)a2 + 7));
            v63 = *v32++;
            *v33++ = vaddq_f32(vmulq_f32(v59, (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)a2 + 31), (int8x16_t)vmulq_f32(v62, vrecpsq_f32(v62, v61))), *((int8x16_t *)a2 + 32))), vmulq_n_f32(v63, vsubq_f32(*((float32x4_t *)a2 + 29), v60).f32[0]));
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendMinStraightTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v33 = 0;
        v34 = 16 * v10;
        v35 = 16 * v9;
        v36 = 16 * v8;
        v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v7[v38 / 0x10] = vminq_f32(v6[v38 / 0x10], v5[v38 / 0x10]);
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          v5 = (float32x4_t *)((char *)v5 + v34);
          v6 = (float32x4_t *)((char *)v6 + v35);
          v7 = (float32x4_t *)((char *)v7 + v36);
        }
        while (v33 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = vminq_f32(v6[v18 + 1], v5[v18 + 1]);
          v27 = vminq_f32(v6[v18 + 2], v5[v18 + 2]);
          v28 = vminq_f32(v6[v18 + 3], v5[v18 + 3]);
          v29 = &v7[v18];
          *v29 = vminq_f32(v6[v18], v5[v18]);
          v29[1] = v26;
          v19 += 4;
          v18 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v30 = *v23++;
            v31 = v30;
            v32 = *v24++;
            *v25++ = vminq_f32(v32, v31);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendMaxStraightTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v33 = 0;
        v34 = 16 * v10;
        v35 = 16 * v9;
        v36 = 16 * v8;
        v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v7[v38 / 0x10] = vmaxq_f32(v6[v38 / 0x10], v5[v38 / 0x10]);
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          v5 = (float32x4_t *)((char *)v5 + v34);
          v6 = (float32x4_t *)((char *)v6 + v35);
          v7 = (float32x4_t *)((char *)v7 + v36);
        }
        while (v33 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = vmaxq_f32(v6[v18 + 1], v5[v18 + 1]);
          v27 = vmaxq_f32(v6[v18 + 2], v5[v18 + 2]);
          v28 = vmaxq_f32(v6[v18 + 3], v5[v18 + 3]);
          v29 = &v7[v18];
          *v29 = vmaxq_f32(v6[v18], v5[v18]);
          v29[1] = v26;
          v19 += 4;
          v18 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v30 = *v23++;
            v31 = v30;
            v32 = *v24++;
            *v25++ = vmaxq_f32(v32, v31);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendSubtractStraightTile(HGTile *a1, float32x4_t *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t *v16;
  float32x4_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = (float32x4_t *)*((_QWORD *)a1 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a1 + 10);
    v7 = (float32x4_t *)*((_QWORD *)a1 + 2);
    v8 = *((int *)a1 + 6);
    v9 = *((int *)a1 + 22);
    v10 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v35 = 0;
        v36 = 16 * v10;
        v37 = 16 * v9;
        v38 = 16 * v8;
        v39 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v40 = 0;
          do
          {
            v7[v40 / 0x10] = vminq_f32(vmaxq_f32(vsubq_f32(v6[v40 / 0x10], v5[v40 / 0x10]), a2[4]), a2[3]);
            v40 += 16;
          }
          while (v39 != v40);
          ++v35;
          v5 = (float32x4_t *)((char *)v5 + v36);
          v6 = (float32x4_t *)((char *)v6 + v37);
          v7 = (float32x4_t *)((char *)v7 + v38);
        }
        while (v35 != v3);
      }
    }
    else
    {
      v11 = 0;
      v12 = 16 * v9;
      v13 = 16 * v8;
      v14 = 16 * v10;
      v15 = v5 + 4;
      v16 = v6 + 4;
      v17 = v7 + 4;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        v22 = v15;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v27 = a2[3];
          v26 = a2[4];
          v28 = vminq_f32(vmaxq_f32(vsubq_f32(v6[v18 + 1], v5[v18 + 1]), v26), v27);
          v29 = vminq_f32(vmaxq_f32(vsubq_f32(v6[v18 + 2], v5[v18 + 2]), v26), v27);
          v30 = vminq_f32(vmaxq_f32(vsubq_f32(v6[v18 + 3], v5[v18 + 3]), v26), v27);
          v31 = &v7[v18];
          *v31 = vminq_f32(vmaxq_f32(vsubq_f32(v6[v18], v5[v18]), v26), v27);
          v31[1] = v28;
          v19 += 4;
          v18 += 4;
          v31[2] = v29;
          v31[3] = v30;
          v22 += 4;
          v21 += 4;
          v20 = v25 + 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v32 = *v23++;
            v33 = v32;
            v34 = *v24++;
            *v25++ = vminq_f32(vmaxq_f32(vsubq_f32(v34, v33), a2[4]), a2[3]);
            ++v19;
          }
          while (v19 < v4);
        }
        ++v11;
        v6 = (float32x4_t *)((char *)v6 + v12);
        v7 = (float32x4_t *)((char *)v7 + v13);
        v5 = (float32x4_t *)((char *)v5 + v14);
        v15 = (float32x4_t *)((char *)v15 + v14);
        v16 = (float32x4_t *)((char *)v16 + v12);
        v17 = (float32x4_t *)((char *)v17 + v13);
      }
      while (v11 != v3);
    }
  }
  return 0;
}

uint64_t GetBlendReplaceTile(HGTile *a1, HGHWBlendFlipped::State *a2, HGNode *a3)
{
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  __int128 *v12;
  _OWORD *v13;
  unint64_t v14;
  _OWORD *v15;
  __int128 *v16;
  uint64_t v17;
  __int128 *v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _OWORD *v23;
  __int128 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v3 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    v5 = *((_QWORD *)a1 + 12);
    v6 = *((_QWORD *)a1 + 2);
    v7 = *((int *)a1 + 6);
    v8 = *((int *)a1 + 26);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v25 = 0;
        v26 = 16 * v8;
        v27 = 16 * v7;
        v28 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        do
        {
          v29 = 0;
          do
          {
            *(_OWORD *)(v6 + v29) = *(_OWORD *)(v5 + v29);
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          v5 += v26;
          v6 += v27;
        }
        while (v25 != v3);
      }
    }
    else
    {
      v9 = 0;
      v10 = 16 * v7;
      v11 = 16 * v8;
      v12 = (__int128 *)(v5 + 64);
      v13 = (_OWORD *)(v6 + 64);
      do
      {
        v14 = 0;
        v15 = v13;
        v16 = v12;
        v17 = 32;
        do
        {
          v18 = v16;
          v19 = v15;
          v20 = *(_OWORD *)(v5 + v17 - 16);
          v21 = *(_OWORD *)(v5 + v17);
          v22 = *(_OWORD *)(v5 + v17 + 16);
          v23 = (_OWORD *)(v6 + v17);
          *(v23 - 2) = *(_OWORD *)(v5 + v17 - 32);
          *(v23 - 1) = v20;
          v14 += 4;
          *v23 = v21;
          v23[1] = v22;
          v17 += 64;
          v16 += 4;
          v15 = v19 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v14)
        {
          do
          {
            v24 = *v18++;
            *v19++ = v24;
            ++v14;
          }
          while (v14 < v4);
        }
        ++v9;
        v6 += v10;
        v5 += v11;
        v12 = (__int128 *)((char *)v12 + v11);
        v13 = (_OWORD *)((char *)v13 + v10);
      }
      while (v9 != v3);
    }
  }
  return 0;
}

const char *GetBlendNormalProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = c0.xxxx - r1.wwww;\n"
             "    output.color0 = float4(r0)*float4(r2) + float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a17166cb:4ae482ef:781fc3b7:6143d1a9\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000352\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = c0.xxxx - r1.wwww;\n"
             "    output.color0 = r0*r2 + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=72391b35:a8654f9f:aaa4f0df:bd71ee76\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000301\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = c0.xxxx - r1.wwww;\n"
           "    gl_FragColor = r0*r2 + r1;\n"
           "}\n"
           "//MD5=542a3d1f:8a8f31c6:53e2357c:1b7afc62\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSubtractProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003a2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = clamp(r3 - r2, 0.00000h, 1.00000h);\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = float4(r1) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5556c7ef:9907aedc:58ff1d84:51fc5242\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000037e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = clamp(r3 - r2, 0.00000f, 1.00000f);\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = r1 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=eb3b3781:87b777cb:53a6f193:08ae603e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000332\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r1 = r1 + r0;\n"
           "    r0 = clamp(r3 - r2, vec4(0.00000), vec4(1.00000));\n"
           "    r1 = r1 - r2;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    gl_FragColor = r1 + r0;\n"
           "}\n"
           "//MD5=254c5683:f5388fc5:b71b3a31:31a6659c\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSubtractPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000525\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[1].xyz));\n"
             "    r1.xyz = clamp(r1.xyz - r4.xyz, 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[2].xyz));\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=034ccae4:2e639f3d:9ea960d6:10ce456c\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
             "    r1.xyz = clamp(r1.xyz - r4.xyz, 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ae2c251d:13023d9b:095473c3:7353733d\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004f0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal1.xyz);\n"
           "    r1.xyz = clamp(r1.xyz - r4.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal2.xyz);\n"
           "    r1.w = c0.y;\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=84dc302c:232db03c:dcab2955:8389158c\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSubtractQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000589\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.955999970);\n"
             "    const half4 c1 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r1.xyz = clamp(r1.xyz - r4.xyz, 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r1.w = c1.w;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=e6045bc0:ce073225:cd26248f:d1cec9f3\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000561\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.955999970);\n"
             "    const float4 c1 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r1.xyz = clamp(r1.xyz - r4.xyz, 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r1.w = c1.w;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e5cd0c1d:31c65fb7:fa29cf4f:c5e5698b\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000513\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.955999970);\n"
           "    const mediump vec4 c1 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = min(r4.xyz, c0.yyy);\n"
           "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
           "    r1.xyz = clamp(r1.xyz - r4.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r1.w = c1.w;\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=02349a7c:fed5d8f9:e2fcbb52:0a45f6f4\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendDarkenProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000384\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmin(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c27f10d4:1c0c8ccb:86556908:22917918\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000360\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmin(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fdd9d0ee:dddc8b61:10b27a4f:f7a7aa8e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000309\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = min(r2, r3);\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=c6b1e65f:1950bd8f:9345f58d:ea3a6afc\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendMultiplyProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000354\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = -r1*r0.wwww + r1;\n"
             "    r3 = -r0*r1.wwww + r0;\n"
             "    r0 = r1*r0 + r2;\n"
             "    output.color0 = float4(r0) + float4(r3);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2db727f4:10641e46:bf7ee213:c988baf5\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = -r1*r0.wwww + r1;\n"
             "    r3 = -r0*r1.wwww + r0;\n"
             "    r0 = r1*r0 + r2;\n"
             "    output.color0 = r0 + r3;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5063fff:bf9e290b:1a9bab81:f35d0dd5\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002da\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = -r1*r0.wwww + r1;\n"
           "    r3 = -r0*r1.wwww + r0;\n"
           "    r0 = r1*r0 + r2;\n"
           "    gl_FragColor = r0 + r3;\n"
           "}\n"
           "//MD5=af7494ed:87347fbf:050c93a0:b950cd3d\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendColorBurnProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000627\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(9.999999717e-10, 0.000000000, 1.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r2.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r0.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r1.xyz / fmax(r1.w, 6.10350e-05h);\n"
             "    r4.xyz = half3(r2.xyz == c0.yyy);\n"
             "    r5.xyz = r4.xyz;\n"
             "    r6.xyz = half3(r3.xyz == c0.zzz);\n"
             "    r6.xyz = fmin(r4.xyz, r6.xyz);\n"
             "    r3.xyz = c0.zzz - r3.xyz;\n"
             "    r0.xyz = r3.xyz/r0.xyz;\n"
             "    r0.xyz = fmin(r0.xyz, c0.zzz);\n"
             "    r4.xyz = c0.zzz - r0.xyz;\n"
             "    r0.xyz = half3(c0.yyy < r2.xyz);\n"
             "    r0.xyz = r0.xyz*r4.xyz;\n"
             "    r0.xyz = select(c0.yyy, r0.xyz, -r0.www < 0.00000h);\n"
             "    r0.xyz = select(r0.xyz, c0.yyy, -r5.xyz < 0.00000h);\n"
             "    r0.xyz = select(r0.xyz, c0.zzz, -r6.xyz < 0.00000h);\n"
             "    r2.w = c0.z;\n"
             "    r2.xyz = mix(r2.xyz, r0.xyz, r1.www);\n"
             "    output.color0 = mix(float4(r1), float4(r2), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=e3b571e8:4940a7ed:ce51028e:9c72262e\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000600\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(9.999999717e-10, 0.000000000, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r2.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r0.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
             "    r4.xyz = float3(r2.xyz == c0.yyy);\n"
             "    r5.xyz = r4.xyz;\n"
             "    r6.xyz = float3(r3.xyz == c0.zzz);\n"
             "    r6.xyz = fmin(r4.xyz, r6.xyz);\n"
             "    r3.xyz = c0.zzz - r3.xyz;\n"
             "    r0.xyz = r3.xyz/r0.xyz;\n"
             "    r0.xyz = fmin(r0.xyz, c0.zzz);\n"
             "    r4.xyz = c0.zzz - r0.xyz;\n"
             "    r0.xyz = float3(c0.yyy < r2.xyz);\n"
             "    r0.xyz = r0.xyz*r4.xyz;\n"
             "    r0.xyz = select(c0.yyy, r0.xyz, -r0.www < 0.00000f);\n"
             "    r0.xyz = select(r0.xyz, c0.yyy, -r5.xyz < 0.00000f);\n"
             "    r0.xyz = select(r0.xyz, c0.zzz, -r6.xyz < 0.00000f);\n"
             "    r2.w = c0.z;\n"
             "    r2.xyz = mix(r2.xyz, r0.xyz, r1.www);\n"
             "    output.color0 = mix(r1, r2, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b37b40a:6c2b9bdc:4847a80f:c21ea799\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000657\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(9.999999717e-10, 0.000000000, 1.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r2.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r0.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r1.xyz / max(r1.w, 1.00000e-06);\n"
           "    r4.xyz = vec3(equal(r2.xyz, c0.yyy));\n"
           "    r5.xyz = r4.xyz;\n"
           "    r6.xyz = vec3(equal(r3.xyz, c0.zzz));\n"
           "    r6.xyz = min(r4.xyz, r6.xyz);\n"
           "    r3.xyz = c0.zzz - r3.xyz;\n"
           "    r0.xyz = r3.xyz/r0.xyz;\n"
           "    r0.xyz = min(r0.xyz, c0.zzz);\n"
           "    r4.xyz = c0.zzz - r0.xyz;\n"
           "    r0.xyz = vec3(lessThan(c0.yyy, r2.xyz));\n"
           "    r0.xyz = r0.xyz*r4.xyz;\n"
           "    r0.xyz = vec3(-r0.w < 0.00000 ? r0.x : c0.y, -r0.w < 0.00000 ? r0.y : c0.y, -r0.w < 0.00000 ? r0.z : c0.y"
           ");\n"
           "    r0.xyz = vec3(-r5.x < 0.00000 ? c0.y : r0.x, -r5.y < 0.00000 ? c0.y : r0.y, -r5.z < 0.00000 ? c0.y : r0.z"
           ");\n"
           "    r0.xyz = vec3(-r6.x < 0.00000 ? c0.z : r0.x, -r6.y < 0.00000 ? c0.z : r0.y, -r6.z < 0.00000 ? c0.z : r0.z"
           ");\n"
           "    r2.w = c0.z;\n"
           "    r2.xyz = mix(r2.xyz, r0.xyz, r1.www);\n"
           "    gl_FragColor = mix(r1, r2, r0.wwww);\n"
           "}\n"
           "//MD5=46eb5a7d:62f64092:72a1ef9e:d5f944bf\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendColorBurnPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000617\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 9.999999717e-10, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r2.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r4.xyz = c0.yyy - r1.xyz;\n"
             "    r5.xyz = fmax(r2.xyz, c0.zzz);\n"
             "    r4.xyz = r4.xyz/r5.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = c0.yyy - r4.xyz;\n"
             "    r5.xyz = half3(r2.xyz <= c0.zzz);\n"
             "    r1.xyz = half3(r1.xyz >= c0.yyy);\n"
             "    r2.xyz = select(r4.xyz, r1.xyz, -r5.xyz < 0.00000h);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[2].xyz));\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=570d76cb:990c55a1:9dbbc68d:b1868c41\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 9.999999717e-10, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r2.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r4.xyz = c0.yyy - r1.xyz;\n"
             "    r5.xyz = fmax(r2.xyz, c0.zzz);\n"
             "    r4.xyz = r4.xyz/r5.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = c0.yyy - r4.xyz;\n"
             "    r5.xyz = float3(r2.xyz <= c0.zzz);\n"
             "    r1.xyz = float3(r1.xyz >= c0.yyy);\n"
             "    r2.xyz = select(r4.xyz, r1.xyz, -r5.xyz < 0.00000f);\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[2].xyz);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=94e0ae90:7e6a7b2c:b8290b58:4acf0b3c\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000628\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 9.999999717e-10, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r2.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r4.xyz = c0.yyy - r1.xyz;\n"
           "    r5.xyz = max(r2.xyz, c0.zzz);\n"
           "    r4.xyz = r4.xyz/r5.xyz;\n"
           "    r4.xyz = min(r4.xyz, c0.yyy);\n"
           "    r4.xyz = c0.yyy - r4.xyz;\n"
           "    r5.xyz = vec3(lessThanEqual(r2.xyz, c0.zzz));\n"
           "    r1.xyz = vec3(greaterThanEqual(r1.xyz, c0.yyy));\n"
           "    r2.xyz = vec3(-r5.x < 0.00000 ? r1.x : r4.x, -r5.y < 0.00000 ? r1.y : r4.y, -r5.z < 0.00000 ? r1.z : r4.z"
           ");\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal2.xyz);\n"
           "    r3.w = c0.y;\n"
           "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=b8b6f47a:39f7acf9:ab910287:9769e876\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendColorBurnQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000006eb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const half4 c1 = half4(9.999999717e-10, 1.149999976, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r2.xyz = r4.xyz;\n"
             "    r4.xyz = c0.www - r1.xyz;\n"
             "    r5.xyz = fmax(r2.xyz, c1.xxx);\n"
             "    r4.xyz = r4.xyz/r5.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, c0.www);\n"
             "    r4.xyz = c0.www - r4.xyz;\n"
             "    r5.xyz = half3(r2.xyz <= c1.xxx);\n"
             "    r1.xyz = half3(r1.xyz >= c0.www);\n"
             "    r2.xyz = select(r4.xyz, r1.xyz, -r5.xyz < 0.00000h);\n"
             "    r5.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r5.xyz = fmin(r5.xyz, c1.yyy);\n"
             "    r5.xyz = pow(r5.xyz, c1.zzz);\n"
             "    r2.xyz = r5.xyz;\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=b24af1d8:c66873ac:1ac9e078:474f68f7\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006c5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const float4 c1 = float4(9.999999717e-10, 1.149999976, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r2.xyz = r4.xyz;\n"
             "    r4.xyz = c0.www - r1.xyz;\n"
             "    r5.xyz = fmax(r2.xyz, c1.xxx);\n"
             "    r4.xyz = r4.xyz/r5.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, c0.www);\n"
             "    r4.xyz = c0.www - r4.xyz;\n"
             "    r5.xyz = float3(r2.xyz <= c1.xxx);\n"
             "    r1.xyz = float3(r1.xyz >= c0.www);\n"
             "    r2.xyz = select(r4.xyz, r1.xyz, -r5.xyz < 0.00000f);\n"
             "    r5.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r5.xyz = fmin(r5.xyz, c1.yyy);\n"
             "    r5.xyz = pow(r5.xyz, c1.zzz);\n"
             "    r2.xyz = r5.xyz;\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6e59c7c:6e77db2c:beaf9e2c:7f713442\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006b9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(9.999999717e-10, 1.149999976, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = min(r3.xyz, c0.yyy);\n"
           "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
           "    r2.xyz = r4.xyz;\n"
           "    r4.xyz = c0.www - r1.xyz;\n"
           "    r5.xyz = max(r2.xyz, c1.xxx);\n"
           "    r4.xyz = r4.xyz/r5.xyz;\n"
           "    r4.xyz = min(r4.xyz, c0.www);\n"
           "    r4.xyz = c0.www - r4.xyz;\n"
           "    r5.xyz = vec3(lessThanEqual(r2.xyz, c1.xxx));\n"
           "    r1.xyz = vec3(greaterThanEqual(r1.xyz, c0.www));\n"
           "    r2.xyz = vec3(-r5.x < 0.00000 ? r1.x : r4.x, -r5.y < 0.00000 ? r1.y : r4.y, -r5.z < 0.00000 ? r1.z : r4.z"
           ");\n"
           "    r5.xyz = max(r2.xyz, c0.xxx);\n"
           "    r5.xyz = min(r5.xyz, c1.yyy);\n"
           "    r5.xyz = pow(r5.xyz, c1.zzz);\n"
           "    r2.xyz = r5.xyz;\n"
           "    r3.w = c0.w;\n"
           "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=d00bfd1e:46e646ab:20a8e4c3:a66a4c56\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearBurnProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ba\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = r2 + r3;\n"
             "    r4 = clamp(-r0.wwww*r1.wwww + r4, 0.00000h, 1.00000h);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1e101a38:54591478:d95a8dbd:601ba2c4\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000396\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = r2 + r3;\n"
             "    r4 = clamp(-r0.wwww*r1.wwww + r4, 0.00000f, 1.00000f);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c72365fd:e4bc0949:da522ad9:1b6a1f34\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000034a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = r2 + r3;\n"
           "    r4 = clamp(-r0.wwww*r1.wwww + r4, vec4(0.00000), vec4(1.00000));\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=9d2b7873:452b0865:aacc462f:f22ff194\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearBurnPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000544\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = clamp(r3.xyz - c0.yyy, 0.00000h, 1.00000h);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[2].xyz));\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=a9713799:756f6449:5191fac6:7e9abec6\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = clamp(r3.xyz - c0.yyy, 0.00000f, 1.00000f);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=42e95b47:a261d26c:4fe538a3:da7f5eaa\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r3.xyz = r1.xyz + r3.xyz;\n"
           "    r3.xyz = clamp(r3.xyz - c0.yyy, vec3(0.00000), vec3(1.00000));\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal2.xyz);\n"
           "    r3.w = c0.y;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=0e9a47db:8ccb5db8:82974fe5:1f953a2d\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearBurnQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005a8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const half4 c1 = half4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = clamp(r3.xyz - c0.www, 0.00000h, 1.00000h);\n"
             "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=ea3b487e:9feeec33:989fec51:af7bdd13\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000581\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const float4 c1 = float4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = clamp(r3.xyz - c0.www, 0.00000f, 1.00000f);\n"
             "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=767767e7:fa948aa9:bec4bb27:9a9ec375\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000531\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r3.xyz = r1.xyz + r3.xyz;\n"
           "    r3.xyz = clamp(r3.xyz - c0.www, vec3(0.00000), vec3(1.00000));\n"
           "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
           "    r3.w = c0.w;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=97f98cb2:abd3d476:86b68c1d:f9f6d488\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendAddProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000367\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r2.x = r0.w + r1.w;\n"
             "    output.color0.xyz = float3(r0.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = -float(r0.w)*float(r1.w) + float(r2.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1077a5d1:4400e12a:074ef54d:d15010d2\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000032e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r2.x = r0.w + r1.w;\n"
             "    output.color0.xyz = r0.xyz + r1.xyz;\n"
             "    output.color0.w = -r0.w*r1.w + r2.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bebc6a57:5f9c4eeb:0ea65bab:3d4908ab\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r2.x = r0.w + r1.w;\n"
           "    gl_FragColor.xyz = r0.xyz + r1.xyz;\n"
           "    gl_FragColor.w = -r0.w*r1.w + r2.x;\n"
           "}\n"
           "//MD5=67b2e44f:8950f5a2:c10a502c:ed08d97b\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLightenProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000384\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmax(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=255abd10:393d4261:149de1f9:66e2ba1d\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000360\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmax(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a08d3b39:c090c511:0017968a:c922b48e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000309\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = max(r2, r3);\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=10f025ae:65373697:69030409:e5173d3b\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendScreenProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0;\n"
             "    r2 = fmin(r2, r1);\n"
             "    r2 = fmin(r2, r0);\n"
             "    r1 = r1 + r0;\n"
             "    output.color0 = float4(r1) - float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9771d01d:626a2747:a548b6f1:28e1d417\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000331\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0;\n"
             "    r2 = fmin(r2, r1);\n"
             "    r2 = fmin(r2, r0);\n"
             "    r1 = r1 + r0;\n"
             "    output.color0 = r1 - r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=31490d41:d9f1dc14:0dca0a9a:b384361c\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0;\n"
           "    r2 = min(r2, r1);\n"
           "    r2 = min(r2, r0);\n"
           "    r1 = r1 + r0;\n"
           "    gl_FragColor = r1 - r2;\n"
           "}\n"
           "//MD5=8190ca66:f656822d:4e06b98f:6e1ba269\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendScreenPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000058f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r4.xyz = r3.xyz*r1.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
             "    r4.xyz = fmin(r4.xyz, r1.xyz);\n"
             "    r3.xyz = r3.xyz + r1.xyz;\n"
             "    r3.xyz = r3.xyz - r4.xyz;\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[2].xyz));\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=9cb777d8:f315bb64:41240f63:eb3a88f5\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000551\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r4.xyz = r3.xyz*r1.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
             "    r4.xyz = fmin(r4.xyz, r1.xyz);\n"
             "    r3.xyz = r3.xyz + r1.xyz;\n"
             "    r3.xyz = r3.xyz - r4.xyz;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9eb4b424:300923a1:73d6aee5:2c9b65f1\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000053d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r4.xyz = r3.xyz*r1.xyz;\n"
           "    r4.xyz = min(r4.xyz, r3.xyz);\n"
           "    r4.xyz = min(r4.xyz, r1.xyz);\n"
           "    r3.xyz = r3.xyz + r1.xyz;\n"
           "    r3.xyz = r3.xyz - r4.xyz;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal2.xyz);\n"
           "    r3.w = c0.y;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=6cd4fd6c:8997112f:cde379a7:0f37f6bd\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendScreenQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000639\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
             "    const half4 c1 = half4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r4.xyz = r3.xyz*r1.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
             "    r4.xyz = fmin(r4.xyz, r1.xyz);\n"
             "    r3.xyz = r3.xyz + r1.xyz;\n"
             "    r3.xyz = r3.xyz - r4.xyz;\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.www);\n"
             "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
             "    r3.w = c1.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=463725cf:d032ea9b:4288667c:a7f0289e\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000612\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
             "    const float4 c1 = float4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r4.xyz = r3.xyz*r1.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
             "    r4.xyz = fmin(r4.xyz, r1.xyz);\n"
             "    r3.xyz = r3.xyz + r1.xyz;\n"
             "    r3.xyz = r3.xyz - r4.xyz;\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.www);\n"
             "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
             "    r3.w = c1.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5d9e90d5:f3ade941:b5ed64bc:6c6f4219\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005b4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r4.xyz = r3.xyz*r1.xyz;\n"
           "    r4.xyz = min(r4.xyz, r3.xyz);\n"
           "    r4.xyz = min(r4.xyz, r1.xyz);\n"
           "    r3.xyz = r3.xyz + r1.xyz;\n"
           "    r3.xyz = r3.xyz - r4.xyz;\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.www);\n"
           "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
           "    r3.w = c1.y;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=1f12d7ed:2832c3f9:864a4c65:58ad5448\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendColorDodgeProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000529\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = c0.xxx - r1.xyz;\n"
             "    r4.xyz = fmax(r4.xyz, c0.yyy);\n"
             "    r4.xyz = r3.xyz/r4.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, c0.xxx);\n"
             "    r4.xyz = select(c0.zzz, r4.xyz, -r3.xyz < 0.00000h);\n"
             "    r3.xyz = half3(r0.xyz >= r0.www);\n"
             "    r4.xyz = select(r4.xyz, c0.xxx, -r3.xyz < 0.00000h);\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r1.xyz, r4.xyz, r2.www);\n"
             "    output.color0 = mix(float4(r2), float4(r1), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=eb46fb6d:135380f4:ebc9cb5e:140c4fdd\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000500\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = c0.xxx - r1.xyz;\n"
             "    r4.xyz = fmax(r4.xyz, c0.yyy);\n"
             "    r4.xyz = r3.xyz/r4.xyz;\n"
             "    r4.xyz = fmin(r4.xyz, c0.xxx);\n"
             "    r4.xyz = select(c0.zzz, r4.xyz, -r3.xyz < 0.00000f);\n"
             "    r3.xyz = float3(r0.xyz >= r0.www);\n"
             "    r4.xyz = select(r4.xyz, c0.xxx, -r3.xyz < 0.00000f);\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r1.xyz, r4.xyz, r2.www);\n"
             "    output.color0 = mix(r2, r1, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5777bfff:41079900:ca302613:434c6b5b\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000522\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = c0.xxx - r1.xyz;\n"
           "    r4.xyz = max(r4.xyz, c0.yyy);\n"
           "    r4.xyz = r3.xyz/r4.xyz;\n"
           "    r4.xyz = min(r4.xyz, c0.xxx);\n"
           "    r4.xyz = vec3(-r3.x < 0.00000 ? r4.x : c0.z, -r3.y < 0.00000 ? r4.y : c0.z, -r3.z < 0.00000 ? r4.z : c0.z"
           ");\n"
           "    r3.xyz = vec3(greaterThanEqual(r0.xyz, r0.www));\n"
           "    r4.xyz = vec3(-r3.x < 0.00000 ? c0.x : r4.x, -r3.y < 0.00000 ? c0.x : r4.y, -r3.z < 0.00000 ? c0.x : r4.z"
           ");\n"
           "    r1.w = c0.x;\n"
           "    r1.xyz = mix(r1.xyz, r4.xyz, r2.www);\n"
           "    gl_FragColor = mix(r2, r1, r0.wwww);\n"
           "}\n"
           "//MD5=5d4d2b6e:d26c940d:c6b5f085:80c4d725\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendColorDodgePOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000602\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r3.w = r2.w*half(hg_Params[0].w);\n"
             "    r2.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[1].xyz));\n"
             "    r4.xyz = c0.xxx - r4.xyz;\n"
             "    r5.xyz = fmax(r4.xyz, c0.yyy);\n"
             "    r5.xyz = r1.xyz/r5.xyz;\n"
             "    r5.xyz = fmin(r5.xyz, c0.xxx);\n"
             "    r4.xyz = half3(r4.xyz <= c0.yyy);\n"
             "    r1.xyz = half3(r1.xyz > c0.zzz);\n"
             "    r4.xyz = select(r5.xyz, r1.xyz, -r4.xyz < 0.00000h);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[2].xyz));\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r3.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=4848c2c8:05058208:3463283e:ea9b21ca\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005c6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r3.w = r2.w*hg_Params[0].w;\n"
             "    r2.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
             "    r4.xyz = c0.xxx - r4.xyz;\n"
             "    r5.xyz = fmax(r4.xyz, c0.yyy);\n"
             "    r5.xyz = r1.xyz/r5.xyz;\n"
             "    r5.xyz = fmin(r5.xyz, c0.xxx);\n"
             "    r4.xyz = float3(r4.xyz <= c0.yyy);\n"
             "    r1.xyz = float3(r1.xyz > c0.zzz);\n"
             "    r4.xyz = select(r5.xyz, r1.xyz, -r4.xyz < 0.00000f);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[2].xyz);\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r3.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=823372e4:ca232079:b3360744:b919756b\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000626\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = clamp(r0.xyz / max(r0.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r3.w = r2.w*hg_ProgramLocal0.w;\n"
           "    r2.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal1.xyz);\n"
           "    r4.xyz = c0.xxx - r4.xyz;\n"
           "    r5.xyz = max(r4.xyz, c0.yyy);\n"
           "    r5.xyz = r1.xyz/r5.xyz;\n"
           "    r5.xyz = min(r5.xyz, c0.xxx);\n"
           "    r4.xyz = vec3(lessThanEqual(r4.xyz, c0.yyy));\n"
           "    r1.xyz = vec3(greaterThan(r1.xyz, c0.zzz));\n"
           "    r4.xyz = vec3(-r4.x < 0.00000 ? r1.x : r5.x, -r4.y < 0.00000 ? r1.y : r5.y, -r4.z < 0.00000 ? r1.z : r5.z"
           ");\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal2.xyz);\n"
           "    r1.w = c0.x;\n"
           "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r3.wwww);\n"
           "}\n"
           "//MD5=a6379189:7d4fb9ae:eea59fd4:02257bc6\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendColorDodgeQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000666\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5109999776, 1.000000000, 9.999999717e-10, 0.000000000);\n"
             "    const half4 c1 = half4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r3.w = r2.w*half(hg_Params[0].w);\n"
             "    r2.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
             "    r4.xyz = c0.yyy - r4.xyz;\n"
             "    r5.xyz = fmax(r4.xyz, c0.zzz);\n"
             "    r5.xyz = r1.xyz/r5.xyz;\n"
             "    r5.xyz = fmin(r5.xyz, c0.yyy);\n"
             "    r4.xyz = half3(r4.xyz <= c0.zzz);\n"
             "    r1.xyz = half3(r1.xyz > c0.www);\n"
             "    r4.xyz = select(r5.xyz, r1.xyz, -r4.xyz < 0.00000h);\n"
             "    r4.xyz = fmax(r4.xyz, c0.www);\n"
             "    r4.xyz = fmin(r4.xyz, c1.xxx);\n"
             "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r3.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=a825f080:a4ac046d:ab7fcd15:0e541422\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000641\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5109999776, 1.000000000, 9.999999717e-10, 0.000000000);\n"
             "    const float4 c1 = float4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r3.w = r2.w*hg_Params[0].w;\n"
             "    r2.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
             "    r4.xyz = c0.yyy - r4.xyz;\n"
             "    r5.xyz = fmax(r4.xyz, c0.zzz);\n"
             "    r5.xyz = r1.xyz/r5.xyz;\n"
             "    r5.xyz = fmin(r5.xyz, c0.yyy);\n"
             "    r4.xyz = float3(r4.xyz <= c0.zzz);\n"
             "    r1.xyz = float3(r1.xyz > c0.www);\n"
             "    r4.xyz = select(r5.xyz, r1.xyz, -r4.xyz < 0.00000f);\n"
             "    r4.xyz = fmax(r4.xyz, c0.www);\n"
             "    r4.xyz = fmin(r4.xyz, c1.xxx);\n"
             "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r3.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6182d137:41b680cb:e86f79a1:e9c16f93\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000649\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.5109999776, 1.000000000, 9.999999717e-10, 0.000000000);\n"
           "    const mediump vec4 c1 = vec4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = clamp(r0.xyz / max(r0.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r3.w = r2.w*hg_ProgramLocal0.w;\n"
           "    r2.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
           "    r4.xyz = c0.yyy - r4.xyz;\n"
           "    r5.xyz = max(r4.xyz, c0.zzz);\n"
           "    r5.xyz = r1.xyz/r5.xyz;\n"
           "    r5.xyz = min(r5.xyz, c0.yyy);\n"
           "    r4.xyz = vec3(lessThanEqual(r4.xyz, c0.zzz));\n"
           "    r1.xyz = vec3(greaterThan(r1.xyz, c0.www));\n"
           "    r4.xyz = vec3(-r4.x < 0.00000 ? r1.x : r5.x, -r4.y < 0.00000 ? r1.y : r5.y, -r4.z < 0.00000 ? r1.z : r5.z"
           ");\n"
           "    r4.xyz = max(r4.xyz, c0.www);\n"
           "    r4.xyz = min(r4.xyz, c1.xxx);\n"
           "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
           "    r1.w = c0.y;\n"
           "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r3.wwww);\n"
           "}\n"
           "//MD5=3331242c:7b9d6b7f:6e61b8e3:31fcd2bf\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearDodgeProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = r1.xyz + r2.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=2994a515:9ecc05bf:f2990959:ef67ab18\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000422\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = r1.xyz + r2.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c886f95:429aa15c:a9a60901:698f617f\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = r1.xyz + r2.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.w = c0.x;\n"
           "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=67389797:72f13dd9:f45f9433:860ed739\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearDodgePOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000052e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[2].xyz));\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=a575e245:a49bec3a:0ee60d69:989db91e\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a0d6d2f0:b1e11a71:8cbc1e87:86e1188c\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ed\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r3.xyz = r1.xyz + r3.xyz;\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal2.xyz);\n"
           "    r3.w = c0.y;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=fcc38052:32e620d5:51813cad:d4a108bc\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearDodgeQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005b5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const half4 c1 = half4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = fmin(r3.xyz, c0.www);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=ac3c62e7:7d110473:b80b8fa2:fc79b15b\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000058e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const float4 c1 = float4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r3.xyz = r1.xyz + r3.xyz;\n"
             "    r3.xyz = fmin(r3.xyz, c0.www);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7419b180:053dbc45:003c272d:25ce14a4\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000532\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r3.xyz = r1.xyz + r3.xyz;\n"
           "    r3.xyz = min(r3.xyz, c0.www);\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
           "    r3.w = c0.w;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=8a5bfb96:e7b90f62:cae30235:e7c2ce54\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendOverlayProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000050d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 6.10350e-05h);\n"
             "    r3.xyz = r2.xyz*r0.xyz;\n"
             "    r3.xyz = r3.xyz + r3.xyz;\n"
             "    r4.xyz = r2.xyz + r0.xyz;\n"
             "    r4.xyz = r4.xyz*c0.xxx + -r3.xyz;\n"
             "    r4.xyz = r4.xyz - c0.yyy;\n"
             "    r2.xyz = half3(r2.xyz < c0.zzz);\n"
             "    r2.xyz = select(r4.xyz, r3.xyz, -r2.xyz < 0.00000h);\n"
             "    r2.w = c0.y;\n"
             "    r2.xyz = mix(r0.xyz, r2.xyz, r1.www);\n"
             "    output.color0 = mix(float4(r1), float4(r2), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=b28e7c1a:e0e82696:bcf63c43:105fbdea\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
             "    r3.xyz = r2.xyz*r0.xyz;\n"
             "    r3.xyz = r3.xyz + r3.xyz;\n"
             "    r4.xyz = r2.xyz + r0.xyz;\n"
             "    r4.xyz = r4.xyz*c0.xxx + -r3.xyz;\n"
             "    r4.xyz = r4.xyz - c0.yyy;\n"
             "    r2.xyz = float3(r2.xyz < c0.zzz);\n"
             "    r2.xyz = select(r4.xyz, r3.xyz, -r2.xyz < 0.00000f);\n"
             "    r2.w = c0.y;\n"
             "    r2.xyz = mix(r0.xyz, r2.xyz, r1.www);\n"
             "    output.color0 = mix(r1, r2, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9321f93f:7488729d:35a1a22a:a763d105\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r2.xyz = r1.xyz / max(r1.w, 1.00000e-06);\n"
           "    r3.xyz = r2.xyz*r0.xyz;\n"
           "    r3.xyz = r3.xyz + r3.xyz;\n"
           "    r4.xyz = r2.xyz + r0.xyz;\n"
           "    r4.xyz = r4.xyz*c0.xxx + -r3.xyz;\n"
           "    r4.xyz = r4.xyz - c0.yyy;\n"
           "    r2.xyz = vec3(lessThan(r2.xyz, c0.zzz));\n"
           "    r2.xyz = vec3(-r2.x < 0.00000 ? r3.x : r4.x, -r2.y < 0.00000 ? r3.y : r4.y, -r2.z < 0.00000 ? r3.z : r4.z"
           ");\n"
           "    r2.w = c0.y;\n"
           "    r2.xyz = mix(r0.xyz, r2.xyz, r1.www);\n"
           "    gl_FragColor = mix(r1, r2, r0.wwww);\n"
           "}\n"
           "//MD5=ae14c320:17f28241:54485286:f3a00e3c\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendOverlayPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000064f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r4.xyz = r1.xyz + r1.xyz;\n"
             "    r5.xyz = r3.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.yyy;\n"
             "    r6.xyz = r4.xyz*r3.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r3.xyz);\n"
             "    r4.xyz = r4.xyz + r3.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r1.xyz = half3(r1.xyz <= c0.zzz);\n"
             "    r1.xyz = select(r6.xyz, r5.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[2].xyz));\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=9f416334:320ea46e:176f3d79:1a759af9\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000612\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r4.xyz = r1.xyz + r1.xyz;\n"
             "    r5.xyz = r3.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.yyy;\n"
             "    r6.xyz = r4.xyz*r3.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r3.xyz);\n"
             "    r4.xyz = r4.xyz + r3.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r1.xyz = float3(r1.xyz <= c0.zzz);\n"
             "    r1.xyz = select(r6.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8e764b01:1ce75bdd:50cd5d13:7dd1e78f\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000650\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r4.xyz = r1.xyz + r1.xyz;\n"
           "    r5.xyz = r3.xyz*r4.xyz;\n"
           "    r4.xyz = r4.xyz - c0.yyy;\n"
           "    r6.xyz = r4.xyz*r3.xyz;\n"
           "    r6.xyz = min(r6.xyz, r4.xyz);\n"
           "    r6.xyz = min(r6.xyz, r3.xyz);\n"
           "    r4.xyz = r4.xyz + r3.xyz;\n"
           "    r6.xyz = r4.xyz - r6.xyz;\n"
           "    r1.xyz = vec3(lessThanEqual(r1.xyz, c0.zzz));\n"
           "    r1.xyz = vec3(-r1.x < 0.00000 ? r5.x : r6.x, -r1.y < 0.00000 ? r5.y : r6.y, -r1.z < 0.00000 ? r5.z : r6.z"
           ");\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal2.xyz);\n"
           "    r1.w = c0.y;\n"
           "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=81e7f4e5:5472836a:28cdb561:e2462c87\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendOverlayQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000006f9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const half4 c1 = half4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r4.xyz = r1.xyz + r1.xyz;\n"
             "    r5.xyz = r3.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.www;\n"
             "    r6.xyz = r4.xyz*r3.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r3.xyz);\n"
             "    r4.xyz = r4.xyz + r3.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r1.xyz = half3(r1.xyz <= c1.xxx);\n"
             "    r1.xyz = select(r6.xyz, r5.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c1.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
             "    r1.w = c0.w;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=6f56df97:801925a4:63241fe7:a14a102e\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006d3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const float4 c1 = float4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r4.xyz = r1.xyz + r1.xyz;\n"
             "    r5.xyz = r3.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.www;\n"
             "    r6.xyz = r4.xyz*r3.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r3.xyz);\n"
             "    r4.xyz = r4.xyz + r3.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r1.xyz = float3(r1.xyz <= c1.xxx);\n"
             "    r1.xyz = select(r6.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c1.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
             "    r1.w = c0.w;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8271038f:3a3334ac:47a554cf:a42b31d8\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006b7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r4.xyz = r1.xyz + r1.xyz;\n"
           "    r5.xyz = r3.xyz*r4.xyz;\n"
           "    r4.xyz = r4.xyz - c0.www;\n"
           "    r6.xyz = r4.xyz*r3.xyz;\n"
           "    r6.xyz = min(r6.xyz, r4.xyz);\n"
           "    r6.xyz = min(r6.xyz, r3.xyz);\n"
           "    r4.xyz = r4.xyz + r3.xyz;\n"
           "    r6.xyz = r4.xyz - r6.xyz;\n"
           "    r1.xyz = vec3(lessThanEqual(r1.xyz, c1.xxx));\n"
           "    r1.xyz = vec3(-r1.x < 0.00000 ? r5.x : r6.x, -r1.y < 0.00000 ? r5.y : r6.y, -r1.z < 0.00000 ? r5.z : r6.z"
           ");\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c1.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
           "    r1.w = c0.w;\n"
           "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=657329ef:7c68d51a:e62d0977:40fdf6dd\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSoftLightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000063c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(16.00000000, -12.00000000, 4.000000000, 0.2500000000);\n"
             "    const half4 c1 = half4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
             "    r2.xyz = r1.xyz*r2.xyz + c0.zzz;\n"
             "    r2.xyz = r1.xyz*r2.xyz;\n"
             "    r3.xyz = sqrt(r1.xyz);\n"
             "    r4.xyz = half3(c0.www >= r1.xyz);\n"
             "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000h);\n"
             "    r4 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r4 = r4*half4(hg_Params[0]);\n"
             "    r4 = r4 / half4(fmax(r4.www, 6.10350e-05h), 1.);\n"
             "    r2.xyz = -r4.xyz*c1.xxx + c1.yyy;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, -r2.xyz);\n"
             "    r2.xyz = r2.xyz*r1.xyz;\n"
             "    r2.xyz = mix(r1.xyz, c1.yyy, -r2.xyz);\n"
             "    r1.xyz = half3(c1.zzz >= r4.xyz);\n"
             "    r1.xyz = select(r3.xyz, r2.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.w = c1.y;\n"
             "    r1.xyz = mix(r4.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r4.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=f2885101:ca6d8f9e:6f4e5f49:743acf4a\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000617\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(16.00000000, -12.00000000, 4.000000000, 0.2500000000);\n"
             "    const float4 c1 = float4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
             "    r2.xyz = r1.xyz*r2.xyz + c0.zzz;\n"
             "    r2.xyz = r1.xyz*r2.xyz;\n"
             "    r3.xyz = sqrt(r1.xyz);\n"
             "    r4.xyz = float3(c0.www >= r1.xyz);\n"
             "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000f);\n"
             "    r4 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r4 = r4*hg_Params[0];\n"
             "    r4 = r4 / float4(fmax(r4.www, 1.00000e-06f), 1.);\n"
             "    r2.xyz = -r4.xyz*c1.xxx + c1.yyy;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, -r2.xyz);\n"
             "    r2.xyz = r2.xyz*r1.xyz;\n"
             "    r2.xyz = mix(r1.xyz, c1.yyy, -r2.xyz);\n"
             "    r1.xyz = float3(c1.zzz >= r4.xyz);\n"
             "    r1.xyz = select(r3.xyz, r2.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.w = c1.y;\n"
             "    r1.xyz = mix(r4.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r4.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=009bb21d:6ea0a9c1:3abdcf14:215477da\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000063d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(16.00000000, -12.00000000, 4.000000000, 0.2500000000);\n"
           "    const highp vec4 c1 = vec4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
           "    r2.xyz = r1.xyz*r2.xyz + c0.zzz;\n"
           "    r2.xyz = r1.xyz*r2.xyz;\n"
           "    r3.xyz = sqrt(r1.xyz);\n"
           "    r4.xyz = vec3(greaterThanEqual(c0.www, r1.xyz));\n"
           "    r3.xyz = vec3(-r4.x < 0.00000 ? r2.x : r3.x, -r4.y < 0.00000 ? r2.y : r3.y, -r4.z < 0.00000 ? r2.z : r3.z"
           ");\n"
           "    r4 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r4 = r4*hg_ProgramLocal0;\n"
           "    r4 = r4 / vec4(max(r4.www, 1.00000e-06), 1.);\n"
           "    r2.xyz = -r4.xyz*c1.xxx + c1.yyy;\n"
           "    r3.xyz = mix(r1.xyz, r3.xyz, -r2.xyz);\n"
           "    r2.xyz = r2.xyz*r1.xyz;\n"
           "    r2.xyz = mix(r1.xyz, c1.yyy, -r2.xyz);\n"
           "    r1.xyz = vec3(greaterThanEqual(c1.zzz, r4.xyz));\n"
           "    r1.xyz = vec3(-r1.x < 0.00000 ? r2.x : r3.x, -r1.y < 0.00000 ? r2.y : r3.y, -r1.z < 0.00000 ? r2.z : r3.z"
           ");\n"
           "    r1.w = c1.y;\n"
           "    r1.xyz = mix(r4.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r4.wwww);\n"
           "}\n"
           "//MD5=b7f22967:b5ddbff9:c12d4f8a:fa380820\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSoftLightPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000071a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 16.00000000, -12.00000000, 4.000000000);\n"
             "    const half4 c1 = half4(0.2500000000, 2.000000000, 1.000000000, 0.5000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2.xyz = r1.xyz*c0.yyy + c0.zzz;\n"
             "    r2.xyz = r1.xyz*r2.xyz + c0.www;\n"
             "    r2.xyz = r1.xyz*r2.xyz;\n"
             "    r3.xyz = sqrt(r1.xyz);\n"
             "    r4.xyz = half3(c1.xxx >= r1.xyz);\n"
             "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000h);\n"
             "    r4 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r4 = r4*half4(hg_Params[0]);\n"
             "    r2.xyz = r4.xyz / fmax(r4.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[1].xyz));\n"
             "    r5.xyz = -r4.xyz*c1.yyy + c1.zzz;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
             "    r5.xyz = r5.xyz*r1.xyz;\n"
             "    r5.xyz = mix(r1.xyz, c1.zzz, -r5.xyz);\n"
             "    r1.xyz = half3(c1.www >= r4.xyz);\n"
             "    r1.xyz = select(r3.xyz, r5.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[2].xyz));\n"
             "    r1.w = c1.z;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r4.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=ac341a7a:4962d79f:36ee3b54:d9a2549e\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006df\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 16.00000000, -12.00000000, 4.000000000);\n"
             "    const float4 c1 = float4(0.2500000000, 2.000000000, 1.000000000, 0.5000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2.xyz = r1.xyz*c0.yyy + c0.zzz;\n"
             "    r2.xyz = r1.xyz*r2.xyz + c0.www;\n"
             "    r2.xyz = r1.xyz*r2.xyz;\n"
             "    r3.xyz = sqrt(r1.xyz);\n"
             "    r4.xyz = float3(c1.xxx >= r1.xyz);\n"
             "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000f);\n"
             "    r4 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r4 = r4*hg_Params[0];\n"
             "    r2.xyz = r4.xyz / fmax(r4.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
             "    r5.xyz = -r4.xyz*c1.yyy + c1.zzz;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
             "    r5.xyz = r5.xyz*r1.xyz;\n"
             "    r5.xyz = mix(r1.xyz, c1.zzz, -r5.xyz);\n"
             "    r1.xyz = float3(c1.www >= r4.xyz);\n"
             "    r1.xyz = select(r3.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
             "    r1.w = c1.z;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r4.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=57e12965:ab4896b2:a795f806:2f8ec6b3\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000075b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 16.00000000, -12.00000000, 4.000000000);\n"
           "    const highp vec4 c1 = vec4(0.2500000000, 2.000000000, 1.000000000, 0.5000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2.xyz = r1.xyz*c0.yyy + c0.zzz;\n"
           "    r2.xyz = r1.xyz*r2.xyz + c0.www;\n"
           "    r2.xyz = r1.xyz*r2.xyz;\n"
           "    r3.xyz = sqrt(r1.xyz);\n"
           "    r4.xyz = vec3(greaterThanEqual(c1.xxx, r1.xyz));\n"
           "    r3.xyz = vec3(-r4.x < 0.00000 ? r2.x : r3.x, -r4.y < 0.00000 ? r2.y : r3.y, -r4.z < 0.00000 ? r2.z : r3.z"
           ");\n"
           "    r4 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r4 = r4*hg_ProgramLocal0;\n"
           "    r2.xyz = r4.xyz / max(r4.w, 1.00000e-06);\n"
           "    r4.xyz = max(r2.xyz, c0.xxx);\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal1.xyz);\n"
           "    r5.xyz = -r4.xyz*c1.yyy + c1.zzz;\n"
           "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
           "    r5.xyz = r5.xyz*r1.xyz;\n"
           "    r5.xyz = mix(r1.xyz, c1.zzz, -r5.xyz);\n"
           "    r1.xyz = vec3(greaterThanEqual(c1.www, r4.xyz));\n"
           "    r1.xyz = vec3(-r1.x < 0.00000 ? r5.x : r3.x, -r1.y < 0.00000 ? r5.y : r3.y, -r1.z < 0.00000 ? r5.z : r3.z"
           ");\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal2.xyz);\n"
           "    r1.w = c1.z;\n"
           "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r4.wwww);\n"
           "}\n"
           "//MD5=4c5b11f8:81aaea79:396d40ce:84da30a8\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSoftLightQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000007d9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 16.00000000);\n"
             "    const half4 c1 = half4(-12.00000000, 4.000000000, 0.2500000000, 2.000000000);\n"
             "    const half4 c2 = half4(1.000000000, 0.5000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r1.xyz*c0.www + c1.xxx;\n"
             "    r2.xyz = r1.xyz*r2.xyz + c1.yyy;\n"
             "    r2.xyz = r1.xyz*r2.xyz;\n"
             "    r3.xyz = sqrt(r1.xyz);\n"
             "    r4.xyz = half3(c1.zzz >= r1.xyz);\n"
             "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000h);\n"
             "    r4 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r4 = r4*half4(hg_Params[0]);\n"
             "    r2.xyz = r4.xyz / fmax(r4.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r5.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r5.xyz = pow(r5.xyz, c0.zzz);\n"
             "    r4.xyz = r5.xyz;\n"
             "    r5.xyz = -r4.xyz*c1.www + c2.xxx;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
             "    r5.xyz = r5.xyz*r1.xyz;\n"
             "    r5.xyz = mix(r1.xyz, c2.xxx, -r5.xyz);\n"
             "    r1.xyz = half3(c2.yyy >= r4.xyz);\n"
             "    r1.xyz = select(r3.xyz, r5.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c2.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c2.www);\n"
             "    r1.w = c2.x;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r4.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=ae1ba670:608a990c:37e7c403:e6d1efee\n"
             "//SIG=00400000:00000003:00000003:00000003:0003:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000007b5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 16.00000000);\n"
             "    const float4 c1 = float4(-12.00000000, 4.000000000, 0.2500000000, 2.000000000);\n"
             "    const float4 c2 = float4(1.000000000, 0.5000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r1.xyz*c0.www + c1.xxx;\n"
             "    r2.xyz = r1.xyz*r2.xyz + c1.yyy;\n"
             "    r2.xyz = r1.xyz*r2.xyz;\n"
             "    r3.xyz = sqrt(r1.xyz);\n"
             "    r4.xyz = float3(c1.zzz >= r1.xyz);\n"
             "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000f);\n"
             "    r4 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r4 = r4*hg_Params[0];\n"
             "    r2.xyz = r4.xyz / fmax(r4.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r5.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r5.xyz = pow(r5.xyz, c0.zzz);\n"
             "    r4.xyz = r5.xyz;\n"
             "    r5.xyz = -r4.xyz*c1.www + c2.xxx;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
             "    r5.xyz = r5.xyz*r1.xyz;\n"
             "    r5.xyz = mix(r1.xyz, c2.xxx, -r5.xyz);\n"
             "    r1.xyz = float3(c2.yyy >= r4.xyz);\n"
             "    r1.xyz = select(r3.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c2.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c2.www);\n"
             "    r1.w = c2.x;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r4.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=203ccc37:9ac4d81c:fcfebc9f:c4e646a8\n"
             "//SIG=00000000:00000003:00000003:00000000:0003:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000007d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 16.00000000);\n"
           "    const highp vec4 c1 = vec4(-12.00000000, 4.000000000, 0.2500000000, 2.000000000);\n"
           "    const highp vec4 c2 = vec4(1.000000000, 0.5000000000, 1.149999976, 1.955999970);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r1.xyz*c0.www + c1.xxx;\n"
           "    r2.xyz = r1.xyz*r2.xyz + c1.yyy;\n"
           "    r2.xyz = r1.xyz*r2.xyz;\n"
           "    r3.xyz = sqrt(r1.xyz);\n"
           "    r4.xyz = vec3(greaterThanEqual(c1.zzz, r1.xyz));\n"
           "    r3.xyz = vec3(-r4.x < 0.00000 ? r2.x : r3.x, -r4.y < 0.00000 ? r2.y : r3.y, -r4.z < 0.00000 ? r2.z : r3.z"
           ");\n"
           "    r4 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r4 = r4*hg_ProgramLocal0;\n"
           "    r2.xyz = r4.xyz / max(r4.w, 1.00000e-06);\n"
           "    r4.xyz = max(r2.xyz, c0.xxx);\n"
           "    r5.xyz = min(r4.xyz, c0.yyy);\n"
           "    r5.xyz = pow(r5.xyz, c0.zzz);\n"
           "    r4.xyz = r5.xyz;\n"
           "    r5.xyz = -r4.xyz*c1.www + c2.xxx;\n"
           "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
           "    r5.xyz = r5.xyz*r1.xyz;\n"
           "    r5.xyz = mix(r1.xyz, c2.xxx, -r5.xyz);\n"
           "    r1.xyz = vec3(greaterThanEqual(c2.yyy, r4.xyz));\n"
           "    r1.xyz = vec3(-r1.x < 0.00000 ? r5.x : r3.x, -r1.y < 0.00000 ? r5.y : r3.y, -r1.z < 0.00000 ? r5.z : r3.z"
           ");\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c2.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c2.www);\n"
           "    r1.w = c2.x;\n"
           "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r4.wwww);\n"
           "}\n"
           "//MD5=76e103f1:325cc33e:a0c3bd31:ef68dad9\n"
           "//SIG=00000000:00000003:00000003:00000000:0003:0001:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendHardLightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000057e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, -2.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = r1.xyz + r1.xyz;\n"
             "    r5.xyz = r4.xyz - c0.xxx;\n"
             "    r6.xyz = r3.xyz*r5.xyz;\n"
             "    r6.xyz = fmin(r5.xyz, r6.xyz);\n"
             "    r6.xyz = fmin(r3.xyz, r6.xyz);\n"
             "    r5.xyz = r3.xyz + r5.xyz;\n"
             "    r5.xyz = r5.xyz - r6.xyz;\n"
             "    r4.xyz = r4.xyz*r3.xyz + -r5.xyz;\n"
             "    r0.xyz = r0.xyz*c0.yyy;\n"
             "    r6.xyz = half3(r0.xyz >= -r0.www);\n"
             "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
             "    r6.w = c0.x;\n"
             "    r6.xyz = mix(r1.xyz, r6.xyz, r2.www);\n"
             "    output.color0 = mix(float4(r2), float4(r6), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=4dc39e36:774dd9c2:12072e36:e7d0aa91\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000555\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, -2.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = r1.xyz + r1.xyz;\n"
             "    r5.xyz = r4.xyz - c0.xxx;\n"
             "    r6.xyz = r3.xyz*r5.xyz;\n"
             "    r6.xyz = fmin(r5.xyz, r6.xyz);\n"
             "    r6.xyz = fmin(r3.xyz, r6.xyz);\n"
             "    r5.xyz = r3.xyz + r5.xyz;\n"
             "    r5.xyz = r5.xyz - r6.xyz;\n"
             "    r4.xyz = r4.xyz*r3.xyz + -r5.xyz;\n"
             "    r0.xyz = r0.xyz*c0.yyy;\n"
             "    r6.xyz = float3(r0.xyz >= -r0.www);\n"
             "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
             "    r6.w = c0.x;\n"
             "    r6.xyz = mix(r1.xyz, r6.xyz, r2.www);\n"
             "    output.color0 = mix(r2, r6, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1df03d78:938bb1c5:7b299762:da0bfa4f\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000509\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, -2.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = r1.xyz + r1.xyz;\n"
           "    r5.xyz = r4.xyz - c0.xxx;\n"
           "    r6.xyz = r3.xyz*r5.xyz;\n"
           "    r6.xyz = min(r5.xyz, r6.xyz);\n"
           "    r6.xyz = min(r3.xyz, r6.xyz);\n"
           "    r5.xyz = r3.xyz + r5.xyz;\n"
           "    r5.xyz = r5.xyz - r6.xyz;\n"
           "    r4.xyz = r4.xyz*r3.xyz + -r5.xyz;\n"
           "    r0.xyz = r0.xyz*c0.yyy;\n"
           "    r6.xyz = vec3(greaterThanEqual(r0.xyz, -r0.www));\n"
           "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
           "    r6.w = c0.x;\n"
           "    r6.xyz = mix(r1.xyz, r6.xyz, r2.www);\n"
           "    gl_FragColor = mix(r2, r6, r0.wwww);\n"
           "}\n"
           "//MD5=f2c1d192:4fa88e30:a50dc5c5:819a4683\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendHardLightPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000064f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r4.xyz = r3.xyz + r3.xyz;\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.yyy;\n"
             "    r6.xyz = r4.xyz*r1.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r1.xyz);\n"
             "    r4.xyz = r4.xyz + r1.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r3.xyz = half3(r3.xyz <= c0.zzz);\n"
             "    r3.xyz = select(r6.xyz, r5.xyz, -r3.xyz < 0.00000h);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[2].xyz));\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=e71b1879:600fc532:2fe088c5:6a90dcf1\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000612\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r4.xyz = r3.xyz + r3.xyz;\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.yyy;\n"
             "    r6.xyz = r4.xyz*r1.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r1.xyz);\n"
             "    r4.xyz = r4.xyz + r1.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r3.xyz = float3(r3.xyz <= c0.zzz);\n"
             "    r3.xyz = select(r6.xyz, r5.xyz, -r3.xyz < 0.00000f);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=caed7240:b8b0b1a3:53add7ee:4c93bd3c\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000650\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r4.xyz = r3.xyz + r3.xyz;\n"
           "    r5.xyz = r1.xyz*r4.xyz;\n"
           "    r4.xyz = r4.xyz - c0.yyy;\n"
           "    r6.xyz = r4.xyz*r1.xyz;\n"
           "    r6.xyz = min(r6.xyz, r4.xyz);\n"
           "    r6.xyz = min(r6.xyz, r1.xyz);\n"
           "    r4.xyz = r4.xyz + r1.xyz;\n"
           "    r6.xyz = r4.xyz - r6.xyz;\n"
           "    r3.xyz = vec3(lessThanEqual(r3.xyz, c0.zzz));\n"
           "    r3.xyz = vec3(-r3.x < 0.00000 ? r5.x : r6.x, -r3.y < 0.00000 ? r5.y : r6.y, -r3.z < 0.00000 ? r5.z : r6.z"
           ");\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal2.xyz);\n"
           "    r3.w = c0.y;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=208f68f0:03533ea7:c626a300:da37b88c\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendHardLightQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000006f9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const half4 c1 = half4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r4.xyz = r3.xyz + r3.xyz;\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.www;\n"
             "    r6.xyz = r4.xyz*r1.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r1.xyz);\n"
             "    r4.xyz = r4.xyz + r1.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r3.xyz = half3(r3.xyz <= c1.xxx);\n"
             "    r3.xyz = select(r6.xyz, r5.xyz, -r3.xyz < 0.00000h);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c1.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c1.zzz);\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=d96dd13c:cb507d58:d5a78b44:b12a9aa0\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006d3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const float4 c1 = float4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r4.xyz = r3.xyz + r3.xyz;\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = r4.xyz - c0.www;\n"
             "    r6.xyz = r4.xyz*r1.xyz;\n"
             "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
             "    r6.xyz = fmin(r6.xyz, r1.xyz);\n"
             "    r4.xyz = r4.xyz + r1.xyz;\n"
             "    r6.xyz = r4.xyz - r6.xyz;\n"
             "    r3.xyz = float3(r3.xyz <= c1.xxx);\n"
             "    r3.xyz = select(r6.xyz, r5.xyz, -r3.xyz < 0.00000f);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c1.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c1.zzz);\n"
             "    r3.w = c0.w;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ca1be53f:09e2be89:bbaafb83:4e65c87e\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006b7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r4.xyz = r3.xyz + r3.xyz;\n"
           "    r5.xyz = r1.xyz*r4.xyz;\n"
           "    r4.xyz = r4.xyz - c0.www;\n"
           "    r6.xyz = r4.xyz*r1.xyz;\n"
           "    r6.xyz = min(r6.xyz, r4.xyz);\n"
           "    r6.xyz = min(r6.xyz, r1.xyz);\n"
           "    r4.xyz = r4.xyz + r1.xyz;\n"
           "    r6.xyz = r4.xyz - r6.xyz;\n"
           "    r3.xyz = vec3(lessThanEqual(r3.xyz, c1.xxx));\n"
           "    r3.xyz = vec3(-r3.x < 0.00000 ? r5.x : r6.x, -r3.y < 0.00000 ? r5.y : r6.y, -r3.z < 0.00000 ? r5.z : r6.z"
           ");\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c1.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c1.zzz);\n"
           "    r3.w = c0.w;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=c4bb2fac:5c8cfa33:b1fe9701:c5e16e8f\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendVividLightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000854\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(65536.00000, 0.5000000000, 1.525878906e-05, 1.000000000);\n"
             "    const half4 c1 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmin(r0.xyz, r0.www);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3 = clamp(r2 / half4(fmax(r2.www, 6.10350e-05h), 1.), 0.00000h, 1.00000h);\n"
             "    r1.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r1.xyz = r1.xyz*c0.zzz;\n"
             "    r4.xyz = r3.xyz*c0.xxx + c0.yyy;\n"
             "    r4.xyz = floor(r4.xyz);\n"
             "    r3.xyz = r4.xyz*c0.zzz;\n"
             "    r4.xyz = c0.www - r1.xyz;\n"
             "    r5.xyz = fmax(r3.xyz, c0.zzz);\n"
             "    r6.xyz = -c0.yyy*r4.xyz + r5.xyz;\n"
             "    r6.xyz = r6.xyz/r5.xyz;\n"
             "    r4.xyz = r4.xyz*c0.yyy;\n"
             "    r5.xyz = half3(-r3.xyz < -r4.xyz);\n"
             "    r6.xyz = r6.xyz*r5.xyz;\n"
             "    r5.xyz = c0.yyy*r2.www;\n"
             "    r5.xyz = half3(r2.xyz < r5.xyz);\n"
             "    r6.xyz = r6.xyz*r5.xyz;\n"
             "    r5.xyz = c0.www - r5.xyz;\n"
             "    r4.xyz = r4.xyz + c0.yyy;\n"
             "    r4.xyz = half3(r3.xyz < r4.xyz);\n"
             "    r4.xyz = fmin(r5.xyz, r4.xyz);\n"
             "    r2.xyz = c0.www - r3.xyz;\n"
             "    r2.xyz = fmax(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + r2.xyz;\n"
             "    r2.xyz = r1.xyz/r2.xyz;\n"
             "    r6.xyz = r2.xyz*r4.xyz + r6.xyz;\n"
             "    r4.xyz = half3(-r4.xyz >= c1.xxx);\n"
             "    r6.xyz = r5.xyz*r4.xyz + r6.xyz;\n"
             "    r6.w = c0.w;\n"
             "    r6.xyz = mix(r3.xyz, r6.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r6), float4(r3.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=860b139e:1d795f3e:df37c946:1fffbf4f\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000831\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(65536.00000, 0.5000000000, 1.525878906e-05, 1.000000000);\n"
             "    const float4 c1 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmin(r0.xyz, r0.www);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3 = clamp(r2 / float4(fmax(r2.www, 1.00000e-06f), 1.), 0.00000f, 1.00000f);\n"
             "    r1.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r1.xyz = r1.xyz*c0.zzz;\n"
             "    r4.xyz = r3.xyz*c0.xxx + c0.yyy;\n"
             "    r4.xyz = floor(r4.xyz);\n"
             "    r3.xyz = r4.xyz*c0.zzz;\n"
             "    r4.xyz = c0.www - r1.xyz;\n"
             "    r5.xyz = fmax(r3.xyz, c0.zzz);\n"
             "    r6.xyz = -c0.yyy*r4.xyz + r5.xyz;\n"
             "    r6.xyz = r6.xyz/r5.xyz;\n"
             "    r4.xyz = r4.xyz*c0.yyy;\n"
             "    r5.xyz = float3(-r3.xyz < -r4.xyz);\n"
             "    r6.xyz = r6.xyz*r5.xyz;\n"
             "    r5.xyz = c0.yyy*r2.www;\n"
             "    r5.xyz = float3(r2.xyz < r5.xyz);\n"
             "    r6.xyz = r6.xyz*r5.xyz;\n"
             "    r5.xyz = c0.www - r5.xyz;\n"
             "    r4.xyz = r4.xyz + c0.yyy;\n"
             "    r4.xyz = float3(r3.xyz < r4.xyz);\n"
             "    r4.xyz = fmin(r5.xyz, r4.xyz);\n"
             "    r2.xyz = c0.www - r3.xyz;\n"
             "    r2.xyz = fmax(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + r2.xyz;\n"
             "    r2.xyz = r1.xyz/r2.xyz;\n"
             "    r6.xyz = r2.xyz*r4.xyz + r6.xyz;\n"
             "    r4.xyz = float3(-r4.xyz >= c1.xxx);\n"
             "    r6.xyz = r5.xyz*r4.xyz + r6.xyz;\n"
             "    r6.w = c0.w;\n"
             "    r6.xyz = mix(r3.xyz, r6.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r6, r3.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bef7475f:dfb4827d:dc9666bf:9f365699\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000007ff\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(65536.00000, 0.5000000000, 1.525878906e-05, 1.000000000);\n"
           "    const highp vec4 c1 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = min(r0.xyz, r0.www);\n"
           "    r1.xyz = clamp(r0.xyz / max(r0.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2.xyz = min(r2.xyz, r2.www);\n"
           "    r3 = clamp(r2 / vec4(max(r2.www, 1.00000e-06), 1.), vec4(0.00000), vec4(1.00000));\n"
           "    r1.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
           "    r1.xyz = floor(r1.xyz);\n"
           "    r1.xyz = r1.xyz*c0.zzz;\n"
           "    r4.xyz = r3.xyz*c0.xxx + c0.yyy;\n"
           "    r4.xyz = floor(r4.xyz);\n"
           "    r3.xyz = r4.xyz*c0.zzz;\n"
           "    r4.xyz = c0.www - r1.xyz;\n"
           "    r5.xyz = max(r3.xyz, c0.zzz);\n"
           "    r6.xyz = -c0.yyy*r4.xyz + r5.xyz;\n"
           "    r6.xyz = r6.xyz/r5.xyz;\n"
           "    r4.xyz = r4.xyz*c0.yyy;\n"
           "    r5.xyz = vec3(lessThan(-r3.xyz, -r4.xyz));\n"
           "    r6.xyz = r6.xyz*r5.xyz;\n"
           "    r5.xyz = c0.yyy*r2.www;\n"
           "    r5.xyz = vec3(lessThan(r2.xyz, r5.xyz));\n"
           "    r6.xyz = r6.xyz*r5.xyz;\n"
           "    r5.xyz = c0.www - r5.xyz;\n"
           "    r4.xyz = r4.xyz + c0.yyy;\n"
           "    r4.xyz = vec3(lessThan(r3.xyz, r4.xyz));\n"
           "    r4.xyz = min(r5.xyz, r4.xyz);\n"
           "    r2.xyz = c0.www - r3.xyz;\n"
           "    r2.xyz = max(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + r2.xyz;\n"
           "    r2.xyz = r1.xyz/r2.xyz;\n"
           "    r6.xyz = r2.xyz*r4.xyz + r6.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(-r4.xyz, c1.xxx));\n"
           "    r6.xyz = r5.xyz*r4.xyz + r6.xyz;\n"
           "    r6.w = c0.w;\n"
           "    r6.xyz = mix(r3.xyz, r6.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r6, r3.wwww);\n"
           "}\n"
           "//MD5=3385f905:b7f9aecb:b3a8cce1:6c362943\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendVividLightPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000008d1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, -0.5000000000, 1.525878906e-05, -2.000000000);\n"
             "    const half4 c1 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[1].xyz));\n"
             "    r5.xyz = c0.xxx - r1.xyz;\n"
             "    r5.xyz = c0.yyy*r5.xyz + r4.xyz;\n"
             "    r6.xyz = fmax(r4.xyz, c0.zzz);\n"
             "    r6.xyz = r5.xyz/r6.xyz;\n"
             "    r7.xyz = c0.yyy*r1.xyz + c0.xxx;\n"
             "    r7.xyz = r4.xyz - r7.xyz;\n"
             "    r8.xyz = c0.www*r4.xyz + -c0.www;\n"
             "    r9.xyz = fmax(r8.xyz, c0.zzz);\n"
             "    r9.xyz = r1.xyz/r9.xyz;\n"
             "    r1.xyz = half3(r4.xyz < -c0.yyy);\n"
             "    r5.xyz = half3(r5.xyz > c1.xxx);\n"
             "    r10.xyz = half3(r7.xyz < c1.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, r5.xyz);\n"
             "    r1.xyz = r1.xyz*r6.xyz;\n"
             "    r4.xyz = half3(r4.xyz >= -c0.yyy);\n"
             "    r4.xyz = fmin(r4.xyz, r10.xyz);\n"
             "    r1.xyz = select(r1.xyz, r9.xyz, -r4.xyz < 0.00000h);\n"
             "    r1.xyz = select(-c0.www, r1.xyz, r7.xyz < 0.00000h);\n"
             "    r8.xyz = half3(r8.xyz <= c0.zzz);\n"
             "    r1.xyz = select(r1.xyz, c0.xxx, -r8.xyz < 0.00000h);\n"
             "    r5.xyz = half3(r5.xyz <= c0.zzz);\n"
             "    r1.xyz = clamp(select(r1.xyz, c1.xxx, -r5.xyz < 0.00000h), 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[2].xyz));\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=0232deb4:a2a102a2:9272d2b4:911a63fb\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0003:000b:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000089a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, -0.5000000000, 1.525878906e-05, -2.000000000);\n"
             "    const float4 c1 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
             "    r5.xyz = c0.xxx - r1.xyz;\n"
             "    r5.xyz = c0.yyy*r5.xyz + r4.xyz;\n"
             "    r6.xyz = fmax(r4.xyz, c0.zzz);\n"
             "    r6.xyz = r5.xyz/r6.xyz;\n"
             "    r7.xyz = c0.yyy*r1.xyz + c0.xxx;\n"
             "    r7.xyz = r4.xyz - r7.xyz;\n"
             "    r8.xyz = c0.www*r4.xyz + -c0.www;\n"
             "    r9.xyz = fmax(r8.xyz, c0.zzz);\n"
             "    r9.xyz = r1.xyz/r9.xyz;\n"
             "    r1.xyz = float3(r4.xyz < -c0.yyy);\n"
             "    r5.xyz = float3(r5.xyz > c1.xxx);\n"
             "    r10.xyz = float3(r7.xyz < c1.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, r5.xyz);\n"
             "    r1.xyz = r1.xyz*r6.xyz;\n"
             "    r4.xyz = float3(r4.xyz >= -c0.yyy);\n"
             "    r4.xyz = fmin(r4.xyz, r10.xyz);\n"
             "    r1.xyz = select(r1.xyz, r9.xyz, -r4.xyz < 0.00000f);\n"
             "    r1.xyz = select(-c0.www, r1.xyz, r7.xyz < 0.00000f);\n"
             "    r8.xyz = float3(r8.xyz <= c0.zzz);\n"
             "    r1.xyz = select(r1.xyz, c0.xxx, -r8.xyz < 0.00000f);\n"
             "    r5.xyz = float3(r5.xyz <= c0.zzz);\n"
             "    r1.xyz = clamp(select(r1.xyz, c1.xxx, -r5.xyz < 0.00000f), 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
             "    r1.w = c0.x;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0f0a249f:bb6b0d3b:2c8c6c7c:237b4708\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0003:000b:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000009c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, -0.5000000000, 1.525878906e-05, -2.000000000);\n"
           "    const highp vec4 c1 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = clamp(r0.xyz / max(r0.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal1.xyz);\n"
           "    r5.xyz = c0.xxx - r1.xyz;\n"
           "    r5.xyz = c0.yyy*r5.xyz + r4.xyz;\n"
           "    r6.xyz = max(r4.xyz, c0.zzz);\n"
           "    r6.xyz = r5.xyz/r6.xyz;\n"
           "    r7.xyz = c0.yyy*r1.xyz + c0.xxx;\n"
           "    r7.xyz = r4.xyz - r7.xyz;\n"
           "    r8.xyz = c0.www*r4.xyz + -c0.www;\n"
           "    r9.xyz = max(r8.xyz, c0.zzz);\n"
           "    r9.xyz = r1.xyz/r9.xyz;\n"
           "    r1.xyz = vec3(lessThan(r4.xyz, -c0.yyy));\n"
           "    r5.xyz = vec3(greaterThan(r5.xyz, c1.xxx));\n"
           "    r10.xyz = vec3(lessThan(r7.xyz, c1.xxx));\n"
           "    r1.xyz = min(r1.xyz, r5.xyz);\n"
           "    r1.xyz = r1.xyz*r6.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(r4.xyz, -c0.yyy));\n"
           "    r4.xyz = min(r4.xyz, r10.xyz);\n"
           "    r1.xyz = vec3(-r4.x < 0.00000 ? r9.x : r1.x, -r4.y < 0.00000 ? r9.y : r1.y, -r4.z < 0.00000 ? r9.z : r1.z"
           ");\n"
           "    r1.xyz = vec3(r7.x < 0.00000 ? r1.x : -c0.w, r7.y < 0.00000 ? r1.y : -c0.w, r7.z < 0.00000 ? r1.z : -c0.w"
           ");\n"
           "    r8.xyz = vec3(lessThanEqual(r8.xyz, c0.zzz));\n"
           "    r1.xyz = vec3(-r8.x < 0.00000 ? c0.x : r1.x, -r8.y < 0.00000 ? c0.x : r1.y, -r8.z < 0.00000 ? c0.x : r1.z"
           ");\n"
           "    r5.xyz = vec3(lessThanEqual(r5.xyz, c0.zzz));\n"
           "    r1.xyz = clamp(vec3(-r5.x < 0.00000 ? c1.x : r1.x, -r5.y < 0.00000 ? c1.x : r1.y, -r5.z < 0.00000 ? c1.x "
           ": r1.z), vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal2.xyz);\n"
           "    r1.w = c0.x;\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=ab1cfc80:d8d8806a:4a63a3ba:c4b495ff\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0003:000b:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendVividLightQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000089f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5109999776, 1.000000000, -0.5000000000, 1.525878906e-05);\n"
             "    const half4 c1 = half4(-2.000000000, 0.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
             "    r5.xyz = c0.yyy - r1.xyz;\n"
             "    r5.xyz = c0.zzz*r5.xyz + r4.xyz;\n"
             "    r6.xyz = fmax(r4.xyz, c0.www);\n"
             "    r6.xyz = r5.xyz/r6.xyz;\n"
             "    r7.xyz = c0.zzz*r1.xyz + c0.yyy;\n"
             "    r7.xyz = r4.xyz - r7.xyz;\n"
             "    r8.xyz = c1.xxx*r4.xyz + -c1.xxx;\n"
             "    r9.xyz = fmax(r8.xyz, c0.www);\n"
             "    r9.xyz = r1.xyz/r9.xyz;\n"
             "    r1.xyz = half3(r4.xyz < -c0.zzz);\n"
             "    r5.xyz = half3(r5.xyz > c1.yyy);\n"
             "    r10.xyz = half3(r7.xyz < c1.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r5.xyz);\n"
             "    r1.xyz = r1.xyz*r6.xyz;\n"
             "    r4.xyz = half3(r4.xyz >= -c0.zzz);\n"
             "    r4.xyz = fmin(r4.xyz, r10.xyz);\n"
             "    r1.xyz = select(r1.xyz, r9.xyz, -r4.xyz < 0.00000h);\n"
             "    r1.xyz = select(-c1.xxx, r1.xyz, r7.xyz < 0.00000h);\n"
             "    r8.xyz = half3(r8.xyz <= c0.www);\n"
             "    r1.xyz = select(r1.xyz, c0.yyy, -r8.xyz < 0.00000h);\n"
             "    r5.xyz = half3(r5.xyz <= c0.www);\n"
             "    r1.xyz = clamp(select(r1.xyz, c1.yyy, -r5.xyz < 0.00000h), 0.00000h, 1.00000h);\n"
             "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=b0561d61:6a43df94:4ba5fca1:d10fa381\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:000b:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000087d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5109999776, 1.000000000, -0.5000000000, 1.525878906e-05);\n"
             "    const float4 c1 = float4(-2.000000000, 0.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
             "    r5.xyz = c0.yyy - r1.xyz;\n"
             "    r5.xyz = c0.zzz*r5.xyz + r4.xyz;\n"
             "    r6.xyz = fmax(r4.xyz, c0.www);\n"
             "    r6.xyz = r5.xyz/r6.xyz;\n"
             "    r7.xyz = c0.zzz*r1.xyz + c0.yyy;\n"
             "    r7.xyz = r4.xyz - r7.xyz;\n"
             "    r8.xyz = c1.xxx*r4.xyz + -c1.xxx;\n"
             "    r9.xyz = fmax(r8.xyz, c0.www);\n"
             "    r9.xyz = r1.xyz/r9.xyz;\n"
             "    r1.xyz = float3(r4.xyz < -c0.zzz);\n"
             "    r5.xyz = float3(r5.xyz > c1.yyy);\n"
             "    r10.xyz = float3(r7.xyz < c1.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r5.xyz);\n"
             "    r1.xyz = r1.xyz*r6.xyz;\n"
             "    r4.xyz = float3(r4.xyz >= -c0.zzz);\n"
             "    r4.xyz = fmin(r4.xyz, r10.xyz);\n"
             "    r1.xyz = select(r1.xyz, r9.xyz, -r4.xyz < 0.00000f);\n"
             "    r1.xyz = select(-c1.xxx, r1.xyz, r7.xyz < 0.00000f);\n"
             "    r8.xyz = float3(r8.xyz <= c0.www);\n"
             "    r1.xyz = select(r1.xyz, c0.yyy, -r8.xyz < 0.00000f);\n"
             "    r5.xyz = float3(r5.xyz <= c0.www);\n"
             "    r1.xyz = clamp(select(r1.xyz, c1.yyy, -r5.xyz < 0.00000f), 0.00000f, 1.00000f);\n"
             "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ee4d2d45:03421f83:160cf487:36c5e88a\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:000b:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000095b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.5109999776, 1.000000000, -0.5000000000, 1.525878906e-05);\n"
           "    const mediump vec4 c1 = vec4(-2.000000000, 0.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = clamp(r0.xyz / max(r0.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
           "    r5.xyz = c0.yyy - r1.xyz;\n"
           "    r5.xyz = c0.zzz*r5.xyz + r4.xyz;\n"
           "    r6.xyz = max(r4.xyz, c0.www);\n"
           "    r6.xyz = r5.xyz/r6.xyz;\n"
           "    r7.xyz = c0.zzz*r1.xyz + c0.yyy;\n"
           "    r7.xyz = r4.xyz - r7.xyz;\n"
           "    r8.xyz = c1.xxx*r4.xyz + -c1.xxx;\n"
           "    r9.xyz = max(r8.xyz, c0.www);\n"
           "    r9.xyz = r1.xyz/r9.xyz;\n"
           "    r1.xyz = vec3(lessThan(r4.xyz, -c0.zzz));\n"
           "    r5.xyz = vec3(greaterThan(r5.xyz, c1.yyy));\n"
           "    r10.xyz = vec3(lessThan(r7.xyz, c1.yyy));\n"
           "    r1.xyz = min(r1.xyz, r5.xyz);\n"
           "    r1.xyz = r1.xyz*r6.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(r4.xyz, -c0.zzz));\n"
           "    r4.xyz = min(r4.xyz, r10.xyz);\n"
           "    r1.xyz = vec3(-r4.x < 0.00000 ? r9.x : r1.x, -r4.y < 0.00000 ? r9.y : r1.y, -r4.z < 0.00000 ? r9.z : r1.z"
           ");\n"
           "    r1.xyz = vec3(r7.x < 0.00000 ? r1.x : -c1.x, r7.y < 0.00000 ? r1.y : -c1.x, r7.z < 0.00000 ? r1.z : -c1.x"
           ");\n"
           "    r8.xyz = vec3(lessThanEqual(r8.xyz, c0.www));\n"
           "    r1.xyz = vec3(-r8.x < 0.00000 ? c0.y : r1.x, -r8.y < 0.00000 ? c0.y : r1.y, -r8.z < 0.00000 ? c0.y : r1.z"
           ");\n"
           "    r5.xyz = vec3(lessThanEqual(r5.xyz, c0.www));\n"
           "    r1.xyz = clamp(vec3(-r5.x < 0.00000 ? c1.y : r1.x, -r5.y < 0.00000 ? c1.y : r1.y, -r5.z < 0.00000 ? c1.y "
           ": r1.z), vec3(0.00000), vec3(1.00000));\n"
           "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
           "    r1.w = c0.y;\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=08cf9d02:159f02c2:339b4c54:2a4cd7e4\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:000b:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearLightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000046d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-2.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = c0.xxx*r2.xyz + c0.yyy;\n"
             "    r1.xyz = clamp(r1.xyz - r3.xyz, 0.00000h, 1.00000h);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=9b374a4d:618dca95:31e3810e:f814ed70\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000444\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-2.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = c0.xxx*r2.xyz + c0.yyy;\n"
             "    r1.xyz = clamp(r1.xyz - r3.xyz, 0.00000f, 1.00000f);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=40b940f3:1f266e49:9dc37cd8:be76aebf\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-2.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = c0.xxx*r2.xyz + c0.yyy;\n"
           "    r1.xyz = clamp(r1.xyz - r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r1.w = c0.y;\n"
           "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=0e6d5794:be18b5e4:26de3756:d940281d\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearLightPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000054c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r3.xyz = c0.yyy*r3.xyz + c0.zzz;\n"
             "    r3.xyz = clamp(r1.xyz - r3.xyz, 0.00000h, 1.00000h);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[2].xyz));\n"
             "    r3.w = c0.z;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=b2adfa6d:5685d164:6c142e5d:d32c6f72\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r3.xyz = c0.yyy*r3.xyz + c0.zzz;\n"
             "    r3.xyz = clamp(r1.xyz - r3.xyz, 0.00000f, 1.00000f);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
             "    r3.w = c0.z;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e0ff3b42:d41f28be:204066d6:f911f41d\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000516\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r3.xyz = c0.yyy*r3.xyz + c0.zzz;\n"
           "    r3.xyz = clamp(r1.xyz - r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal2.xyz);\n"
           "    r3.w = c0.z;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=d732ba98:c176e883:c77ce82c:831e5c3b\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLinearLightQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005b0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
             "    const half4 c1 = half4(1.000000000, 1.955999970, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r3.xyz = c0.www*r3.xyz + c1.xxx;\n"
             "    r3.xyz = clamp(r1.xyz - r3.xyz, 0.00000h, 1.00000h);\n"
             "    r3.xyz = pow(r3.xyz, c1.yyy);\n"
             "    r3.w = c1.x;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r3), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=bbb69a9e:8cb57392:655ac6ea:e4cfe22c\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000589\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
             "    const float4 c1 = float4(1.000000000, 1.955999970, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r3.xyz = c0.www*r3.xyz + c1.xxx;\n"
             "    r3.xyz = clamp(r1.xyz - r3.xyz, 0.00000f, 1.00000f);\n"
             "    r3.xyz = pow(r3.xyz, c1.yyy);\n"
             "    r3.w = c1.x;\n"
             "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r3, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3e7d2d63:4fc60f37:87f4c605:b892890b\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000539\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
           "    const mediump vec4 c1 = vec4(1.000000000, 1.955999970, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = max(r2.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r3.xyz = c0.www*r3.xyz + c1.xxx;\n"
           "    r3.xyz = clamp(r1.xyz - r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r3.xyz = pow(r3.xyz, c1.yyy);\n"
           "    r3.w = c1.x;\n"
           "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r3, r2.wwww);\n"
           "}\n"
           "//MD5=b90ad3a1:89e1e496:f631717e:cdf37be6\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendPinLightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000054c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 6.10350e-05h);\n"
             "    r3.xyz = r0.xyz + r0.xyz;\n"
             "    r4.xyz = half3(r3.xyz < r2.xyz);\n"
             "    r5.xyz = r3.xyz*r4.xyz;\n"
             "    r3.xyz = r3.xyz - c0.xxx;\n"
             "    r6.xyz = half3(r3.xyz >= r2.xyz);\n"
             "    r5.xyz = r3.xyz*r6.xyz + r5.xyz;\n"
             "    r4.xyz = r4.xyz + r6.xyz;\n"
             "    r4.xyz = half3(-r4.xyz >= c0.yyy);\n"
             "    r5.xyz = r2.xyz*r4.xyz + r5.xyz;\n"
             "    r5.w = c0.x;\n"
             "    r5.xyz = mix(r0.xyz, r5.xyz, r1.www);\n"
             "    output.color0 = mix(float4(r1), float4(r5), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=7df624e8:22d53432:86d605dd:9166256c\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000526\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
             "    r3.xyz = r0.xyz + r0.xyz;\n"
             "    r4.xyz = float3(r3.xyz < r2.xyz);\n"
             "    r5.xyz = r3.xyz*r4.xyz;\n"
             "    r3.xyz = r3.xyz - c0.xxx;\n"
             "    r6.xyz = float3(r3.xyz >= r2.xyz);\n"
             "    r5.xyz = r3.xyz*r6.xyz + r5.xyz;\n"
             "    r4.xyz = r4.xyz + r6.xyz;\n"
             "    r4.xyz = float3(-r4.xyz >= c0.yyy);\n"
             "    r5.xyz = r2.xyz*r4.xyz + r5.xyz;\n"
             "    r5.w = c0.x;\n"
             "    r5.xyz = mix(r0.xyz, r5.xyz, r1.www);\n"
             "    output.color0 = mix(r1, r5, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c465eebd:b5f1632e:9c876833:f8fadb07\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ef\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r2.xyz = r1.xyz / max(r1.w, 1.00000e-06);\n"
           "    r3.xyz = r0.xyz + r0.xyz;\n"
           "    r4.xyz = vec3(lessThan(r3.xyz, r2.xyz));\n"
           "    r5.xyz = r3.xyz*r4.xyz;\n"
           "    r3.xyz = r3.xyz - c0.xxx;\n"
           "    r6.xyz = vec3(greaterThanEqual(r3.xyz, r2.xyz));\n"
           "    r5.xyz = r3.xyz*r6.xyz + r5.xyz;\n"
           "    r4.xyz = r4.xyz + r6.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(-r4.xyz, c0.yyy));\n"
           "    r5.xyz = r2.xyz*r4.xyz + r5.xyz;\n"
           "    r5.w = c0.x;\n"
           "    r5.xyz = mix(r0.xyz, r5.xyz, r1.www);\n"
           "    gl_FragColor = mix(r1, r5, r0.wwww);\n"
           "}\n"
           "//MD5=1af7a367:c41788ce:15a4d906:3e42f215\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendPinLightPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000062b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r1.xyz = r1.xyz + r1.xyz;\n"
             "    r4.xyz = half3(r1.xyz < r3.xyz);\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r1.xyz = r1.xyz - c0.yyy;\n"
             "    r6.xyz = half3(r1.xyz >= r3.xyz);\n"
             "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
             "    r4.xyz = r4.xyz + r6.xyz;\n"
             "    r4.xyz = half3(-r4.xyz >= c0.xxx);\n"
             "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
             "    r5.xyz = pow(r5.xyz, half3(hg_Params[2].xyz));\n"
             "    r5.w = c0.y;\n"
             "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
             "    output.color0 = mix(float4(r2), float4(r5), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=9af4ba9b:79bc497a:393fb1d5:90191490\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r1.xyz = r1.xyz + r1.xyz;\n"
             "    r4.xyz = float3(r1.xyz < r3.xyz);\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r1.xyz = r1.xyz - c0.yyy;\n"
             "    r6.xyz = float3(r1.xyz >= r3.xyz);\n"
             "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
             "    r4.xyz = r4.xyz + r6.xyz;\n"
             "    r4.xyz = float3(-r4.xyz >= c0.xxx);\n"
             "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
             "    r5.xyz = pow(r5.xyz, hg_Params[2].xyz);\n"
             "    r5.w = c0.y;\n"
             "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
             "    output.color0 = mix(r2, r5, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e85210a2:7c50ee70:49b88d81:88ef8ea2\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000611\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r1.xyz = r1.xyz + r1.xyz;\n"
           "    r4.xyz = vec3(lessThan(r1.xyz, r3.xyz));\n"
           "    r5.xyz = r1.xyz*r4.xyz;\n"
           "    r1.xyz = r1.xyz - c0.yyy;\n"
           "    r6.xyz = vec3(greaterThanEqual(r1.xyz, r3.xyz));\n"
           "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
           "    r4.xyz = r4.xyz + r6.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(-r4.xyz, c0.xxx));\n"
           "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
           "    r5.xyz = pow(r5.xyz, hg_ProgramLocal2.xyz);\n"
           "    r5.w = c0.y;\n"
           "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
           "    gl_FragColor = mix(r2, r5, r0.wwww);\n"
           "}\n"
           "//MD5=79e0a9a4:c9d6f62f:1ada738e:70249948\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendPinLightQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000006d5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const half4 c1 = half4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r1.xyz = r1.xyz + r1.xyz;\n"
             "    r4.xyz = half3(r1.xyz < r3.xyz);\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r1.xyz = r1.xyz - c0.www;\n"
             "    r6.xyz = half3(r1.xyz >= r3.xyz);\n"
             "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
             "    r4.xyz = r4.xyz + r6.xyz;\n"
             "    r4.xyz = half3(-r4.xyz >= c0.xxx);\n"
             "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
             "    r5.xyz = fmax(r5.xyz, c0.xxx);\n"
             "    r5.xyz = fmin(r5.xyz, c1.xxx);\n"
             "    r5.xyz = pow(r5.xyz, c1.yyy);\n"
             "    r5.w = c0.w;\n"
             "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
             "    output.color0 = mix(float4(r2), float4(r5), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab0c5205:580e439b:b1f89457:0e406e50\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006b1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
             "    const float4 c1 = float4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
             "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
             "    r1.xyz = r1.xyz + r1.xyz;\n"
             "    r4.xyz = float3(r1.xyz < r3.xyz);\n"
             "    r5.xyz = r1.xyz*r4.xyz;\n"
             "    r1.xyz = r1.xyz - c0.www;\n"
             "    r6.xyz = float3(r1.xyz >= r3.xyz);\n"
             "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
             "    r4.xyz = r4.xyz + r6.xyz;\n"
             "    r4.xyz = float3(-r4.xyz >= c0.xxx);\n"
             "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
             "    r5.xyz = fmax(r5.xyz, c0.xxx);\n"
             "    r5.xyz = fmin(r5.xyz, c1.xxx);\n"
             "    r5.xyz = pow(r5.xyz, c1.yyy);\n"
             "    r5.w = c0.w;\n"
             "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
             "    output.color0 = mix(r2, r5, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=400277fe:8c48c377:5bc2b694:718f4f05\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000678\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r3.xyz = max(r3.xyz, c0.xxx);\n"
           "    r3.xyz = min(r3.xyz, c0.yyy);\n"
           "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
           "    r1.xyz = r1.xyz + r1.xyz;\n"
           "    r4.xyz = vec3(lessThan(r1.xyz, r3.xyz));\n"
           "    r5.xyz = r1.xyz*r4.xyz;\n"
           "    r1.xyz = r1.xyz - c0.www;\n"
           "    r6.xyz = vec3(greaterThanEqual(r1.xyz, r3.xyz));\n"
           "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
           "    r4.xyz = r4.xyz + r6.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(-r4.xyz, c0.xxx));\n"
           "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
           "    r5.xyz = max(r5.xyz, c0.xxx);\n"
           "    r5.xyz = min(r5.xyz, c1.xxx);\n"
           "    r5.xyz = pow(r5.xyz, c1.yyy);\n"
           "    r5.w = c0.w;\n"
           "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
           "    gl_FragColor = mix(r2, r5, r0.wwww);\n"
           "}\n"
           "//MD5=0c429fe7:c30c1e7d:f6c41481:35876db9\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendHardMixProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000008dd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 65535.00000, 1.525902189e-05, 0.003921568859);\n"
             "    const half4 c1 = half4(-0.7500000000, 3.039975672e-05, 1.003921628, 32895.00000);\n"
             "    const half4 c2 = half4(0.007751937956, 254.9999847, 0.000000000, 0.9960784316);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r2 = r2 / half4(fmax(r2.www, 6.10350e-05h), 1.);\n"
             "    r3.xyz = c0.xxx - r1.xyz;\n"
             "    r3.xyz = r3.xyz*c0.yyy;\n"
             "    r3.xyz = floor(r3.xyz);\n"
             "    r3.xyz = r3.xyz*c0.zzz;\n"
             "    r4.xyz = -r1.xyz*c0.www + r3.xyz;\n"
             "    r4.xyz = c1.xxx*c1.yyy + r4.xyz;\n"
             "    r5.xyz = half3(r2.xyz >= r4.xyz);\n"
             "    r3.xyz = r3.xyz*c1.zzz;\n"
             "    r6.xyz = half3(r2.xyz < r3.xyz);\n"
             "    r4.xyz = r2.xyz - r4.xyz;\n"
             "    r4.xyz = r4.xyz*c1.www;\n"
             "    r4.xyz = floor(r4.xyz);\n"
             "    r4.xyz = c2.xxx*r4.xyz;\n"
             "    r6.xyz = fmin(r5.xyz, r6.xyz);\n"
             "    r4.xyz = r4.xyz*r6.xyz;\n"
             "    r6.xyz = half3(r2.xyz >= r3.xyz);\n"
             "    r6.xyz = r6.xyz + r4.xyz;\n"
             "    r3.xyz = fmin(r3.xyz, c0.xxx);\n"
             "    r4.xyz = half3(r1.xyz < c0.www);\n"
             "    r4.xyz = fmin(r4.xyz, r5.xyz);\n"
             "    r5.xyz = r1.xyz*c2.yyy;\n"
             "    r5.xyz = r5.xyz*r4.xyz;\n"
             "    r5.xyz = fmin(r5.xyz, r6.xyz);\n"
             "    r4.xyz = half3(-r4.xyz >= c2.zzz);\n"
             "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
             "    r4.xyz = half3(r1.xyz >= c2.www);\n"
             "    r3.xyz = half3(r2.xyz < r3.xyz);\n"
             "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
             "    r1.xyz = r1.xyz - c2.www;\n"
             "    r1.xyz = r1.xyz*c2.yyy;\n"
             "    r1.xyz = r1.xyz*r4.xyz;\n"
             "    r6.xyz = fmax(r1.xyz, r6.xyz);\n"
             "    r6.w = c0.x;\n"
             "    r6.xyz = mix(r2.xyz, r6.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r6), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=6abbb958:d4a3d475:7d2c51bc:e6abde98\n"
             "//SIG=00400000:00000003:00000003:00000003:0003:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000008bf\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 65535.00000, 1.525902189e-05, 0.003921568859);\n"
             "    const float4 c1 = float4(-0.7500000000, 3.039975672e-05, 1.003921628, 32895.00000);\n"
             "    const float4 c2 = float4(0.007751937956, 254.9999847, 0.000000000, 0.9960784316);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
             "    r3.xyz = c0.xxx - r1.xyz;\n"
             "    r3.xyz = r3.xyz*c0.yyy;\n"
             "    r3.xyz = floor(r3.xyz);\n"
             "    r3.xyz = r3.xyz*c0.zzz;\n"
             "    r4.xyz = -r1.xyz*c0.www + r3.xyz;\n"
             "    r4.xyz = c1.xxx*c1.yyy + r4.xyz;\n"
             "    r5.xyz = float3(r2.xyz >= r4.xyz);\n"
             "    r3.xyz = r3.xyz*c1.zzz;\n"
             "    r6.xyz = float3(r2.xyz < r3.xyz);\n"
             "    r4.xyz = r2.xyz - r4.xyz;\n"
             "    r4.xyz = r4.xyz*c1.www;\n"
             "    r4.xyz = floor(r4.xyz);\n"
             "    r4.xyz = c2.xxx*r4.xyz;\n"
             "    r6.xyz = fmin(r5.xyz, r6.xyz);\n"
             "    r4.xyz = r4.xyz*r6.xyz;\n"
             "    r6.xyz = float3(r2.xyz >= r3.xyz);\n"
             "    r6.xyz = r6.xyz + r4.xyz;\n"
             "    r3.xyz = fmin(r3.xyz, c0.xxx);\n"
             "    r4.xyz = float3(r1.xyz < c0.www);\n"
             "    r4.xyz = fmin(r4.xyz, r5.xyz);\n"
             "    r5.xyz = r1.xyz*c2.yyy;\n"
             "    r5.xyz = r5.xyz*r4.xyz;\n"
             "    r5.xyz = fmin(r5.xyz, r6.xyz);\n"
             "    r4.xyz = float3(-r4.xyz >= c2.zzz);\n"
             "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
             "    r4.xyz = float3(r1.xyz >= c2.www);\n"
             "    r3.xyz = float3(r2.xyz < r3.xyz);\n"
             "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
             "    r1.xyz = r1.xyz - c2.www;\n"
             "    r1.xyz = r1.xyz*c2.yyy;\n"
             "    r1.xyz = r1.xyz*r4.xyz;\n"
             "    r6.xyz = fmax(r1.xyz, r6.xyz);\n"
             "    r6.w = c0.x;\n"
             "    r6.xyz = mix(r2.xyz, r6.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r6, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c1e965ac:25bf6706:05b8ec7b:4093af55\n"
             "//SIG=00000000:00000003:00000003:00000000:0003:0001:0007:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000008b4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 65535.00000, 1.525902189e-05, 0.003921568859);\n"
           "    const mediump vec4 c1 = vec4(-0.7500000000, 3.039975672e-05, 1.003921628, 32895.00000);\n"
           "    const mediump vec4 c2 = vec4(0.007751937956, 254.9999847, 0.000000000, 0.9960784316);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r2 = r2 / vec4(max(r2.www, 1.00000e-06), 1.);\n"
           "    r3.xyz = c0.xxx - r1.xyz;\n"
           "    r3.xyz = r3.xyz*c0.yyy;\n"
           "    r3.xyz = floor(r3.xyz);\n"
           "    r3.xyz = r3.xyz*c0.zzz;\n"
           "    r4.xyz = -r1.xyz*c0.www + r3.xyz;\n"
           "    r4.xyz = c1.xxx*c1.yyy + r4.xyz;\n"
           "    r5.xyz = vec3(greaterThanEqual(r2.xyz, r4.xyz));\n"
           "    r3.xyz = r3.xyz*c1.zzz;\n"
           "    r6.xyz = vec3(lessThan(r2.xyz, r3.xyz));\n"
           "    r4.xyz = r2.xyz - r4.xyz;\n"
           "    r4.xyz = r4.xyz*c1.www;\n"
           "    r4.xyz = floor(r4.xyz);\n"
           "    r4.xyz = c2.xxx*r4.xyz;\n"
           "    r6.xyz = min(r5.xyz, r6.xyz);\n"
           "    r4.xyz = r4.xyz*r6.xyz;\n"
           "    r6.xyz = vec3(greaterThanEqual(r2.xyz, r3.xyz));\n"
           "    r6.xyz = r6.xyz + r4.xyz;\n"
           "    r3.xyz = min(r3.xyz, c0.xxx);\n"
           "    r4.xyz = vec3(lessThan(r1.xyz, c0.www));\n"
           "    r4.xyz = min(r4.xyz, r5.xyz);\n"
           "    r5.xyz = r1.xyz*c2.yyy;\n"
           "    r5.xyz = r5.xyz*r4.xyz;\n"
           "    r5.xyz = min(r5.xyz, r6.xyz);\n"
           "    r4.xyz = vec3(greaterThanEqual(-r4.xyz, c2.zzz));\n"
           "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
           "    r4.xyz = vec3(greaterThanEqual(r1.xyz, c2.www));\n"
           "    r3.xyz = vec3(lessThan(r2.xyz, r3.xyz));\n"
           "    r4.xyz = min(r4.xyz, r3.xyz);\n"
           "    r1.xyz = r1.xyz - c2.www;\n"
           "    r1.xyz = r1.xyz*c2.yyy;\n"
           "    r1.xyz = r1.xyz*r4.xyz;\n"
           "    r6.xyz = max(r1.xyz, r6.xyz);\n"
           "    r6.w = c0.x;\n"
           "    r6.xyz = mix(r2.xyz, r6.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r6, r2.wwww);\n"
           "}\n"
           "//MD5=c83ffaba:f8e1e893:06e2d049:b3453f56\n"
           "//SIG=00000000:00000003:00000003:00000000:0003:0001:0007:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendHardMixPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = clamp(r2.xyz / fmax(r2.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r4.xyz = c0.xxx - r3.xyz;\n"
             "    r4.xyz = half3(r4.xyz <= r0.xyz);\n"
             "    r3.xyz = half3(r3.xyz <= c0.yyy);\n"
             "    r5.xyz = half3(r0.xyz >= c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, r5.xyz);\n"
             "    r3.xyz = select(r4.xyz, c0.yyy, -r3.xyz < 0.00000h);\n"
             "    r3.w = c0.x;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
             "    output.color0 = mix(float4(r2), float4(r3), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=cbd2f72c:10e44047:4a5970ce:dbe69896\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0002:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000579\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = clamp(r2.xyz / fmax(r2.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
             "    r4.xyz = c0.xxx - r3.xyz;\n"
             "    r4.xyz = float3(r4.xyz <= r0.xyz);\n"
             "    r3.xyz = float3(r3.xyz <= c0.yyy);\n"
             "    r5.xyz = float3(r0.xyz >= c0.xxx);\n"
             "    r3.xyz = fmin(r3.xyz, r5.xyz);\n"
             "    r3.xyz = select(r4.xyz, c0.yyy, -r3.xyz < 0.00000f);\n"
             "    r3.w = c0.x;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
             "    output.color0 = mix(r2, r3, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9e7d49d5:be156bfe:8f123f5e:66202703\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0002:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005be\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r0.xyz = clamp(r1.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r3.xyz = clamp(r2.xyz / max(r2.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r4.xyz = c0.xxx - r3.xyz;\n"
           "    r4.xyz = vec3(lessThanEqual(r4.xyz, r0.xyz));\n"
           "    r3.xyz = vec3(lessThanEqual(r3.xyz, c0.yyy));\n"
           "    r5.xyz = vec3(greaterThanEqual(r0.xyz, c0.xxx));\n"
           "    r3.xyz = min(r3.xyz, r5.xyz);\n"
           "    r3.xyz = vec3(-r3.x < 0.00000 ? c0.y : r4.x, -r3.y < 0.00000 ? c0.y : r4.y, -r3.z < 0.00000 ? c0.y : r4.z"
           ");\n"
           "    r3.w = c0.x;\n"
           "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
           "    gl_FragColor = mix(r2, r3, r0.wwww);\n"
           "}\n"
           "//MD5=50f562ff:ef85c03c:af2578db:ac8cd17a\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0002:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendHardMixQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005b7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5109999776, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000h, 1.00000h);\n"
             "    r2.xyz = r0.xyz;\n"
             "    r2.xyz = pow(r2.xyz, c0.xxx);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = clamp(r2.xyz / fmax(r2.w, 6.10350e-05h), 0.00000h, 1.00000h);\n"
             "    r3.xyz = pow(r3.xyz, c0.xxx);\n"
             "    r4.xyz = c0.yyy - r3.xyz;\n"
             "    r4.xyz = half3(r4.xyz <= r0.xyz);\n"
             "    r3.xyz = half3(r3.xyz <= c0.zzz);\n"
             "    r5.xyz = half3(r0.xyz >= c0.yyy);\n"
             "    r3.xyz = fmin(r3.xyz, r5.xyz);\n"
             "    r3.xyz = select(r4.xyz, c0.zzz, -r3.xyz < 0.00000h);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
             "    output.color0 = mix(float4(r2), float4(r3), float4(r0.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=77b52b70:424956c9:4d640b7c:4911f1d0\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000590\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5109999776, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
             "    r2.xyz = r0.xyz;\n"
             "    r2.xyz = pow(r2.xyz, c0.xxx);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r3.xyz = clamp(r2.xyz / fmax(r2.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
             "    r3.xyz = pow(r3.xyz, c0.xxx);\n"
             "    r4.xyz = c0.yyy - r3.xyz;\n"
             "    r4.xyz = float3(r4.xyz <= r0.xyz);\n"
             "    r3.xyz = float3(r3.xyz <= c0.zzz);\n"
             "    r5.xyz = float3(r0.xyz >= c0.yyy);\n"
             "    r3.xyz = fmin(r3.xyz, r5.xyz);\n"
             "    r3.xyz = select(r4.xyz, c0.zzz, -r3.xyz < 0.00000f);\n"
             "    r3.w = c0.y;\n"
             "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
             "    output.color0 = mix(r2, r3, r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ca1350d1:fc2694e6:6e384c30:3a8ef345\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005a6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.5109999776, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r0.xyz = clamp(r1.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r2.xyz = r0.xyz;\n"
           "    r2.xyz = pow(r2.xyz, c0.xxx);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r3.xyz = clamp(r2.xyz / max(r2.w, 1.00000e-06), vec3(0.00000), vec3(1.00000));\n"
           "    r3.xyz = pow(r3.xyz, c0.xxx);\n"
           "    r4.xyz = c0.yyy - r3.xyz;\n"
           "    r4.xyz = vec3(lessThanEqual(r4.xyz, r0.xyz));\n"
           "    r3.xyz = vec3(lessThanEqual(r3.xyz, c0.zzz));\n"
           "    r5.xyz = vec3(greaterThanEqual(r0.xyz, c0.yyy));\n"
           "    r3.xyz = min(r3.xyz, r5.xyz);\n"
           "    r3.xyz = vec3(-r3.x < 0.00000 ? c0.z : r4.x, -r3.y < 0.00000 ? c0.z : r4.y, -r3.z < 0.00000 ? c0.z : r4.z"
           ");\n"
           "    r3.w = c0.y;\n"
           "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
           "    gl_FragColor = mix(r2, r3, r0.wwww);\n"
           "}\n"
           "//MD5=d10b6575:504b3910:06449ca6:e5a9005d\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendDifferenceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000038d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = r2 - r3;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = float4(r1) + float4(fabs(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=28640d6b:a7f4cbd7:1398d5ad:4f2b97e5\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = r2 - r3;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = r1 + fabs(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=78eeb002:cd99131f:366f4560:2b2f0811\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r1 = r1 + r0;\n"
           "    r0 = r2 - r3;\n"
           "    r1 = r1 - r2;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    gl_FragColor = r1 + abs(r0);\n"
           "}\n"
           "//MD5=167e3881:cda035d5:2b7bb7d9:07a634d1\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendDifferencePOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000510\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[1].xyz));\n"
             "    r1.xyz = r1.xyz - r4.xyz;\n"
             "    r1.xyz = pow(fabs(r1.xyz), half3(hg_Params[2].xyz));\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=832d1e12:7e146cc6:ed9fa6b8:960b6859\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004d1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
             "    r1.xyz = r1.xyz - r4.xyz;\n"
             "    r1.xyz = pow(fabs(r1.xyz), hg_Params[2].xyz);\n"
             "    r1.w = c0.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=95e972db:78c79115:c2255fa8:a9b642e4\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal1.xyz);\n"
           "    r1.xyz = r1.xyz - r4.xyz;\n"
           "    r1.xyz = pow(abs(r1.xyz), hg_ProgramLocal2.xyz);\n"
           "    r1.w = c0.y;\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=844141b7:6f0dff52:1ccf774d:e6df7bdf\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendDifferenceQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000597\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
             "    const half4 c1 = half4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r1.xyz = r1.xyz - r4.xyz;\n"
             "    r1.xyz = fmin(fabs(r1.xyz), c0.www);\n"
             "    r1.xyz = pow(r1.xyz, c1.xxx);\n"
             "    r1.w = c1.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r1), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=7e88c717:604f97d1:354f9a24:f0876eac\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000056f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
             "    const float4 c1 = float4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r1.xyz = r1.xyz - r4.xyz;\n"
             "    r1.xyz = fmin(fabs(r1.xyz), c0.www);\n"
             "    r1.xyz = pow(r1.xyz, c1.xxx);\n"
             "    r1.w = c1.y;\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r1, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=010388f2:1c3aea3e:579d0770:458ba830\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000515\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = min(r4.xyz, c0.yyy);\n"
           "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
           "    r1.xyz = r1.xyz - r4.xyz;\n"
           "    r1.xyz = min(abs(r1.xyz), c0.www);\n"
           "    r1.xyz = pow(r1.xyz, c1.xxx);\n"
           "    r1.w = c1.y;\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r1, r2.wwww);\n"
           "}\n"
           "//MD5=f9e8be4c:9ffa5667:af0daeb8:121866ac\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendExclusionProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000406\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = r0*r1;\n"
             "    r4 = c0.xxxx*r4 + r2;\n"
             "    r4 = r4 + r3;\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1be1e8b8:4f83dbba:c5944c1a:4d913d97\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = r0*r1;\n"
             "    r4 = c0.xxxx*r4 + r2;\n"
             "    r4 = r4 + r3;\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=0f532412:67fd3d19:e6e32c9a:f2d80e5e\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000393\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = r0*r1;\n"
           "    r4 = c0.xxxx*r4 + r2;\n"
           "    r4 = r4 + r3;\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=7c7ef45c:2a9b315f:68065765:88d684a8\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendExclusionPOWProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000550\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[1].xyz));\n"
             "    r5.xyz = r1.xyz + r4.xyz;\n"
             "    r4.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = c0.yyy*r4.xyz + r5.xyz;\n"
             "    r4.xyz = pow(r4.xyz, half3(hg_Params[2].xyz));\n"
             "    r4.w = c0.z;\n"
             "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r4), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ada872c:69cf577f:d04e3da1:b5571db0\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000511\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
             "    r5.xyz = r1.xyz + r4.xyz;\n"
             "    r4.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = c0.yyy*r4.xyz + r5.xyz;\n"
             "    r4.xyz = pow(r4.xyz, hg_Params[2].xyz);\n"
             "    r4.w = c0.z;\n"
             "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r4, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ae6728af:869ecc44:7da2cc97:129b83d9\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0003:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000511\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal1.xyz);\n"
           "    r5.xyz = r1.xyz + r4.xyz;\n"
           "    r4.xyz = r1.xyz*r4.xyz;\n"
           "    r4.xyz = c0.yyy*r4.xyz + r5.xyz;\n"
           "    r4.xyz = pow(r4.xyz, hg_ProgramLocal2.xyz);\n"
           "    r4.w = c0.z;\n"
           "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r4, r2.wwww);\n"
           "}\n"
           "//MD5=aae0a4a9:2a6b5046:aca59177:262e0a3c\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendExclusionQTProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
             "    const half4 c1 = half4(1.149999976, 1.955999970, 1.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*half4(hg_Params[0]);\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 6.10350e-05h);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r5.xyz = r1.xyz + r4.xyz;\n"
             "    r4.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = c0.www*r4.xyz + r5.xyz;\n"
             "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c1.xxx);\n"
             "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
             "    r4.w = c1.z;\n"
             "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(float4(r0), float4(r4), float4(r2.wwww));\n"
             "    return output;\n"
             "}\n"
             "//MD5=453c5bfe:3a2b37d9:78df4aea:008674ec\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005d2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
             "    const float4 c1 = float4(1.149999976, 1.955999970, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
             "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
             "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
             "    r5.xyz = r1.xyz + r4.xyz;\n"
             "    r4.xyz = r1.xyz*r4.xyz;\n"
             "    r4.xyz = c0.www*r4.xyz + r5.xyz;\n"
             "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
             "    r4.xyz = fmin(r4.xyz, c1.xxx);\n"
             "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
             "    r4.w = c1.z;\n"
             "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
             "    output.color0 = mix(r0, r4, r2.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a9ccd72:b47ae297:d4668882:ade8d5d9\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0001:0006:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000578\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
           "    const mediump vec4 c1 = vec4(1.149999976, 1.955999970, 1.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r3.xyz = r2.xyz / max(r2.w, 1.00000e-06);\n"
           "    r4.xyz = max(r3.xyz, c0.xxx);\n"
           "    r4.xyz = min(r4.xyz, c0.yyy);\n"
           "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
           "    r5.xyz = r1.xyz + r4.xyz;\n"
           "    r4.xyz = r1.xyz*r4.xyz;\n"
           "    r4.xyz = c0.www*r4.xyz + r5.xyz;\n"
           "    r4.xyz = max(r4.xyz, c0.xxx);\n"
           "    r4.xyz = min(r4.xyz, c1.xxx);\n"
           "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
           "    r4.w = c1.z;\n"
           "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
           "    gl_FragColor = mix(r0, r4, r2.wwww);\n"
           "}\n"
           "//MD5=d59a60b1:f04eab3d:b9d735e0:71fcfd2a\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0001:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendStencilAlphaProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000030c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).w;\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = r0.w*half(hg_Params[0].w);\n"
             "    output.color0 = float4(r0.xxxx)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=01f634c8:f7748912:786afaf7:eb888de8\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ea\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).w;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = r0.w*hg_Params[0].w;\n"
             "    output.color0 = r0.xxxx*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e1ec9237:e9f18bbe:72542b57:68628fe1\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000294\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture1, hg_TexCoord1.xy).w;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.x = r0.w*hg_ProgramLocal0.w;\n"
           "    gl_FragColor = r0.xxxx*r1;\n"
           "}\n"
           "//MD5=b08281d5:65ec7cc3:7ffdfd68:7096132c\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendStencilLumaProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000038b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = dot(r0.xyz, c0.xyz);\n"
             "    output.color0 = float4(r0.xxxx)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cb176b52:a0693719:b9ea283b:0759c643\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = dot(r0.xyz, c0.xyz);\n"
             "    output.color0 = r0.xxxx*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d4787518:3c8759ce:80b33876:1f8c5248\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000318\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.x = dot(r0.xyz, c0.xyz);\n"
           "    gl_FragColor = r0.xxxx*r1;\n"
           "}\n"
           "//MD5=23b25b93:d546e82f:8b4aad79:2f25e687\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSilhouetteAlphaProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000031a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).w;\n"
             "    r0.x = -r0.w*half(hg_Params[0].w);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.xxxx)*float4(r1) + float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9639d417:186a031c:6b3aa441:ce5f8528\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).w;\n"
             "    r0.x = -r0.w*hg_Params[0].w;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.xxxx*r1 + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ff209aa:1783dfd7:95f3f37d:6ad71923\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000029a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture1, hg_TexCoord1.xy).w;\n"
           "    r0.x = -r0.w*hg_ProgramLocal0.w;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.xxxx*r1 + r1;\n"
           "}\n"
           "//MD5=19e8d72e:ec77a61e:4a0e0cff:0c6215d9\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSilhouetteLumaProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003e6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.3000000119, 0.5899999738, 0.1099999994, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz);\n"
             "    r0.x = clamp(dot(r0.xyz, c0.xyz), 0.00000h, 1.00000h);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = c0.w - r0.x;\n"
             "    output.color0 = float4(r0.xxxx)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9e7e6220:f1380266:ad59740d:425602c4\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.3000000119, 0.5899999738, 0.1099999994, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz;\n"
             "    r0.x = clamp(dot(r0.xyz, c0.xyz), 0.00000f, 1.00000f);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = c0.w - r0.x;\n"
             "    output.color0 = r0.xxxx*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fb2eb236:cf333580:86a36a28:2a089a43\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000036c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.3000000119, 0.5899999738, 0.1099999994, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz;\n"
           "    r0.x = clamp(dot(r0.xyz, c0.xyz), 0.00000, 1.00000);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.x = c0.w - r0.x;\n"
           "    gl_FragColor = r0.xxxx*r1;\n"
           "}\n"
           "//MD5=e2bac880:05dd91d1:f2a01b5a:12c55cfd\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendBehindProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = c0.xxxx - r0.wwww;\n"
             "    output.color0 = float4(r1)*float4(r2) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c58d73cf:5abaf669:0ed24989:47f4d1f7\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000352\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = c0.xxxx - r0.wwww;\n"
             "    output.color0 = r1*r2 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=02fd7083:75fd7153:81b391cd:51351952\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000301\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = c0.xxxx - r0.wwww;\n"
           "    gl_FragColor = r1*r2 + r0;\n"
           "}\n"
           "//MD5=82fdf0d8:1de86e49:9e296160:488420c6\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendAlphaAddProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000426\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2.x = c0.x - r1.w;\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r2.x = fmin(r0.w, r2.x);\n"
             "    output.color0.xyz = float3(r2.xxx)*float3(r0.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = clamp(float(r0.w) + float(r1.w), 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f90028c9:ac63ee31:0582ec0a:01d4319f\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2.x = c0.x - r1.w;\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r2.x = fmin(r0.w, r2.x);\n"
             "    output.color0.xyz = r2.xxx*r0.xyz + r1.xyz;\n"
             "    output.color0.w = clamp(r0.w + r1.w, 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0565429:874f6bf5:70c5b692:ec699c87\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000393\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2.x = c0.x - r1.w;\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r2.x = min(r0.w, r2.x);\n"
           "    gl_FragColor.xyz = r2.xxx*r0.xyz + r1.xyz;\n"
           "    gl_FragColor.w = clamp(r0.w + r1.w, 0.00000, 1.00000);\n"
           "}\n"
           "//MD5=519e231c:8b7219f5:a42034e9:24325591\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendLuminescentPremulProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*half4(hg_Params[0]);\n"
             "    r1 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.x = c0.x - r0.w;\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.xxxx)*float4(r2) + float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4132c413:bcc37b85:4b94d3c8:0580063c\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000389\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0*hg_Params[0];\n"
             "    r1 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.x = c0.x - r0.w;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.xxxx*r2 + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c94102b6:ee9b78d3:499e2062:7f0e1fd3\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000331\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0*hg_ProgramLocal0;\n"
           "    r1 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.x = c0.x - r0.w;\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.xxxx*r2 + r1;\n"
           "}\n"
           "//MD5=9933e453:22266e50:58e77a45:3ff8c33e\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendMinStraightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = fmin(float4(r1), float4(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=e422aa77:fd499568:6292261a:786077e6\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = fmin(r1, r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c2060382:fef5a3d6:92ed6008:7e348a1a\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000245\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = min(r1, r0);\n"
           "}\n"
           "//MD5=1f97ac0b:acd5be17:20490fe1:20b20394\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendMaxStraightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = fmax(float4(r1), float4(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=03194d2d:d20b76be:1b007e7e:6478a81a\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = fmax(r1, r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=171e71e1:20e2dcdc:551a9dc4:7e3e5749\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000245\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = max(r1, r0);\n"
           "}\n"
           "//MD5=e85b8e93:7e9743a9:dad95728:be4f740e\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendSubtractStraightProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002fb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = clamp(float4(r1) - float4(r0), 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92942aee:6402e443:1f8f2364:d3f2b823\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = clamp(r1 - r0, 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c7624c53:65bc4fcc:16ba9d4f:cb0cc5f3\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000266\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = clamp(r1 - r0, vec4(0.00000), vec4(1.00000));\n"
           "}\n"
           "//MD5=a985dc25:2f53039b:0982af3e:9557b499\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetBlendReplaceProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000267\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0 = (float4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d0da0c39:be03e007:4040bbc7:73e91771\n"
             "//SIG=00400000:00000002:00000002:00000002:0000:0000:0000:0000:0000:0000:0004:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000260\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=691a6891:f45ce721:5a5c5bc2:06c9787e\n"
             "//SIG=00000000:00000002:00000002:00000000:0000:0000:0000:0000:0000:0000:0004:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001bb\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "\n"
           "    gl_FragColor = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "}\n"
           "//MD5=a4b83d08:d3b1ca52:9cad844e:b351838f\n"
           "//SIG=00000000:00000002:00000002:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void InitBlendNormalProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendNormal_hgc_visible", "//Metal1.0     \n//LEN=00000001ac\n[[ visible ]] FragmentOut BlendNormal_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = c0.xxxx - r1.wwww;\n"
    "    output.color0 = r0*r2 + r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B79870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B798A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7989CLL);
}

void InitBlendSubtractProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSubtract_hgc_visible", "//Metal1.0     \n//LEN=00000001da\n[[ visible ]] FragmentOut BlendSubtract_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r1 = r1 + r0;\n"
    "    r0 = clamp(r3 - r2, 0.00000f, 1.00000f);\n"
    "    r1 = r1 - r2;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    output.color0 = r1 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B79B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B79B78(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B79B70);
}

void InitBlendSubtractPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSubtractPOW_hgc_visible", "//Metal1.0     \n//LEN=0000000345\n[[ visible ]] FragmentOut BlendSubtractPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
    "    r1.xyz = clamp(r1.xyz - r4.xyz, 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
    "    r1.w = c0.y;\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B79E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B79E4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B79E44);
}

void InitBlendSubtractQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSubtractQT_hgc_visible", "//Metal1.0     \n//LEN=00000003bf\n[[ visible ]] FragmentOut BlendSubtractQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.955999970);\n"
    "    const float4 c1 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
    "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
    "    r1.xyz = clamp(r1.xyz - r4.xyz, 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, c0.www);\n"
    "    r1.w = c1.w;\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7A0EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7A120(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7A118);
}

void InitBlendDarkenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendDarken_hgc_visible", "//Metal1.0     \n//LEN=00000001ba\n[[ visible ]] FragmentOut BlendDarken_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = fmin(r2, r3);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7A3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7A3F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7A3ECLL);
}

void InitBlendMultiplyProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendMultiply_hgc_visible", "//Metal1.0     \n//LEN=000000018c\n[[ visible ]] FragmentOut BlendMultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = -r1*r0.wwww + r1;\n"
    "    r3 = -r0*r1.wwww + r0;\n"
    "    r0 = r1*r0 + r2;\n"
    "    output.color0 = r0 + r3;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7A694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7A6C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7A6C0);
}

void InitBlendColorBurnProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendColorBurn_hgc_visible", "//Metal1.0     \n//LEN=000000045d\n[[ visible ]] FragmentOut BlendColorBurn_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(9.999999717e-10, 0.000000000, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1 = color0;\n"
    "    r2.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r0.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
    "    r4.xyz = float3(r2.xyz == c0.yyy);\n"
    "    r5.xyz = r4.xyz;\n"
    "    r6.xyz = float3(r3.xyz == c0.zzz);\n"
    "    r6.xyz = fmin(r4.xyz, r6.xyz);\n"
    "    r3.xyz = c0.zzz - r3.xyz;\n"
    "    r0.xyz = r3.xyz/r0.xyz;\n"
    "    r0.xyz = fmin(r0.xyz, c0.zzz);\n"
    "    r4.xyz = c0.zzz - r0.xyz;\n"
    "    r0.xyz = float3(c0.yyy < r2.xyz);\n"
    "    r0.xyz = r0.xyz*r4.xyz;\n"
    "    r0.xyz = select(c0.yyy, r0.xyz, -r0.www < 0.00000f);\n"
    "    r0.xyz = select(r0.xyz, c0.yyy, -r5.xyz < 0.00000f);\n"
    "    r0.xyz = select(r0.xyz, c0.zzz, -r6.xyz < 0.00000f);\n"
    "    r2.w = c0.z;\n"
    "    r2.xyz = mix(r2.xyz, r0.xyz, r1.www);\n"
    "    output.color0 = mix(r1, r2, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7A968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7A99C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7A994);
}

void InitBlendColorBurnPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendColorBurnPOW_hgc_visible", "//Metal1.0     \n//LEN=000000043a\n[[ visible ]] FragmentOut BlendColorBurnPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 9.999999717e-10, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r2.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r4.xyz = c0.yyy - r1.xyz;\n"
    "    r5.xyz = fmax(r2.xyz, c0.zzz);\n"
    "    r4.xyz = r4.xyz/r5.xyz;\n"
    "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
    "    r4.xyz = c0.yyy - r4.xyz;\n"
    "    r5.xyz = float3(r2.xyz <= c0.zzz);\n"
    "    r1.xyz = float3(r1.xyz >= c0.yyy);\n"
    "    r2.xyz = select(r4.xyz, r1.xyz, -r5.xyz < 0.00000f);\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[2].xyz);\n"
    "    r3.w = c0.y;\n"
    "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7AC3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7AC70(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7AC68);
}

void InitBlendColorBurnQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendColorBurnQT_hgc_visible", "//Metal1.0     \n//LEN=0000000524\n[[ visible ]] FragmentOut BlendColorBurnQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
    "    const float4 c1 = float4(9.999999717e-10, 1.149999976, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
    "    r2.xyz = r4.xyz;\n"
    "    r4.xyz = c0.www - r1.xyz;\n"
    "    r5.xyz = fmax(r2.xyz, c1.xxx);\n"
    "    r4.xyz = r4.xyz/r5.xyz;\n"
    "    r4.xyz = fmin(r4.xyz, c0.www);\n"
    "    r4.xyz = c0.www - r4.xyz;\n"
    "    r5.xyz = float3(r2.xyz <= c1.xxx);\n"
    "    r1.xyz = float3(r1.xyz >= c0.www);\n"
    "    r2.xyz = select(r4.xyz, r1.xyz, -r5.xyz < 0.00000f);\n"
    "    r5.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r5.xyz = fmin(r5.xyz, c1.yyy);\n"
    "    r5.xyz = pow(r5.xyz, c1.zzz);\n"
    "    r2.xyz = r5.xyz;\n"
    "    r3.w = c0.w;\n"
    "    r3.xyz = mix(r3.xyz, r2.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7AF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7AF44(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7AF3CLL);
}

void InitBlendLinearBurnProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearBurn_hgc_visible", "//Metal1.0     \n//LEN=00000001f4\n[[ visible ]] FragmentOut BlendLinearBurn_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = r2 + r3;\n"
    "    r4 = clamp(-r0.wwww*r1.wwww + r4, 0.00000f, 1.00000f);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7B1E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7B218(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7B210);
}

void InitBlendLinearBurnPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearBurnPOW_hgc_visible", "//Metal1.0     \n//LEN=0000000367\n[[ visible ]] FragmentOut BlendLinearBurnPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r3.xyz = r1.xyz + r3.xyz;\n"
    "    r3.xyz = clamp(r3.xyz - c0.yyy, 0.00000f, 1.00000f);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
    "    r3.w = c0.y;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7B4B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7B4EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7B4E4);
}

void InitBlendLinearBurnQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearBurnQT_hgc_visible", "//Metal1.0     \n//LEN=00000003e1\n[[ visible ]] FragmentOut BlendLinearBurnQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
    "    const float4 c1 = float4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r3.xyz = r1.xyz + r3.xyz;\n"
    "    r3.xyz = clamp(r3.xyz - c0.www, 0.00000f, 1.00000f);\n"
    "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
    "    r3.w = c0.w;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7B78C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7B7C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7B7B8);
}

void InitBlendAddProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendAdd_hgc_visible", "//Metal1.0     \n//LEN=0000000185\n[[ visible ]] FragmentOut BlendAdd_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r1 = color0;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r2.x = r0.w + r1.w;\n"
    "    output.color0.xyz = r0.xyz + r1.xyz;\n"
    "    output.color0.w = -r0.w*r1.w + r2.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7BA60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7BA94(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7BA8CLL);
}

void InitBlendLightenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLighten_hgc_visible", "//Metal1.0     \n//LEN=00000001bb\n[[ visible ]] FragmentOut BlendLighten_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = fmax(r2, r3);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7BD34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7BD68(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7BD60);
}

void InitBlendScreenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendScreen_hgc_visible", "//Metal1.0     \n//LEN=000000018b\n[[ visible ]] FragmentOut BlendScreen_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0;\n"
    "    r2 = fmin(r2, r1);\n"
    "    r2 = fmin(r2, r0);\n"
    "    r1 = r1 + r0;\n"
    "    output.color0 = r1 - r2;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7C008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7C03C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7C034);
}

void InitBlendScreenPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendScreenPOW_hgc_visible", "//Metal1.0     \n//LEN=00000003ae\n[[ visible ]] FragmentOut BlendScreenPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r4.xyz = r3.xyz*r1.xyz;\n"
    "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
    "    r4.xyz = fmin(r4.xyz, r1.xyz);\n"
    "    r3.xyz = r3.xyz + r1.xyz;\n"
    "    r3.xyz = r3.xyz - r4.xyz;\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
    "    r3.w = c0.y;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7C2DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7C310(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7C308);
}

void InitBlendScreenQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendScreenQT_hgc_visible", "//Metal1.0     \n//LEN=000000046e\n[[ visible ]] FragmentOut BlendScreenQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
    "    const float4 c1 = float4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r4.xyz = r3.xyz*r1.xyz;\n"
    "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
    "    r4.xyz = fmin(r4.xyz, r1.xyz);\n"
    "    r3.xyz = r3.xyz + r1.xyz;\n"
    "    r3.xyz = r3.xyz - r4.xyz;\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.www);\n"
    "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
    "    r3.w = c1.y;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7C5B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7C5E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7C5DCLL);
}

void InitBlendColorDodgeProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendColorDodge_hgc_visible", "//Metal1.0     \n//LEN=000000035e\n[[ visible ]] FragmentOut BlendColorDodge_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2 = color0;\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = c0.xxx - r1.xyz;\n"
    "    r4.xyz = fmax(r4.xyz, c0.yyy);\n"
    "    r4.xyz = r3.xyz/r4.xyz;\n"
    "    r4.xyz = fmin(r4.xyz, c0.xxx);\n"
    "    r4.xyz = select(c0.zzz, r4.xyz, -r3.xyz < 0.00000f);\n"
    "    r3.xyz = float3(r0.xyz >= r0.www);\n"
    "    r4.xyz = select(r4.xyz, c0.xxx, -r3.xyz < 0.00000f);\n"
    "    r1.w = c0.x;\n"
    "    r1.xyz = mix(r1.xyz, r4.xyz, r2.www);\n"
    "    output.color0 = mix(r2, r1, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7C884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7C8B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7C8B0);
}

void InitBlendColorDodgePOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendColorDodgePOW_hgc_visible", "//Metal1.0     \n//LEN=0000000427\n[[ visible ]] FragmentOut BlendColorDodgePOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 9.999999717e-10, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r3.w = r2.w*hg_Params[0].w;\n"
    "    r2.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
    "    r4.xyz = c0.xxx - r4.xyz;\n"
    "    r5.xyz = fmax(r4.xyz, c0.yyy);\n"
    "    r5.xyz = r1.xyz/r5.xyz;\n"
    "    r5.xyz = fmin(r5.xyz, c0.xxx);\n"
    "    r4.xyz = float3(r4.xyz <= c0.yyy);\n"
    "    r1.xyz = float3(r1.xyz > c0.zzz);\n"
    "    r4.xyz = select(r5.xyz, r1.xyz, -r4.xyz < 0.00000f);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[2].xyz);\n"
    "    r1.w = c0.x;\n"
    "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r3.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7CB58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7CB8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7CB84);
}

void InitBlendColorDodgeQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendColorDodgeQT_hgc_visible", "//Metal1.0     \n//LEN=00000004a1\n[[ visible ]] FragmentOut BlendColorDodgeQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.5109999776, 1.000000000, 9.999999717e-10, 0.000000000);\n"
    "    const float4 c1 = float4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
    "    r2 = color1;\n"
    "    r3.w = r2.w*hg_Params[0].w;\n"
    "    r2.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
    "    r4.xyz = c0.yyy - r4.xyz;\n"
    "    r5.xyz = fmax(r4.xyz, c0.zzz);\n"
    "    r5.xyz = r1.xyz/r5.xyz;\n"
    "    r5.xyz = fmin(r5.xyz, c0.yyy);\n"
    "    r4.xyz = float3(r4.xyz <= c0.zzz);\n"
    "    r1.xyz = float3(r1.xyz > c0.www);\n"
    "    r4.xyz = select(r5.xyz, r1.xyz, -r4.xyz < 0.00000f);\n"
    "    r4.xyz = fmax(r4.xyz, c0.www);\n"
    "    r4.xyz = fmin(r4.xyz, c1.xxx);\n"
    "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
    "    r1.w = c0.y;\n"
    "    r1.xyz = mix(r2.xyz, r4.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r3.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7CE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7CE60(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7CE58);
}

void InitBlendLinearDodgeProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearDodge_hgc_visible", "//Metal1.0     \n//LEN=0000000281\n[[ visible ]] FragmentOut BlendLinearDodge_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = r1.xyz + r2.xyz;\n"
    "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
    "    r1.w = c0.x;\n"
    "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7D100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7D134(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7D12CLL);
}

void InitBlendLinearDodgePOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearDodgePOW_hgc_visible", "//Metal1.0     \n//LEN=0000000352\n[[ visible ]] FragmentOut BlendLinearDodgePOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r3.xyz = r1.xyz + r3.xyz;\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
    "    r3.w = c0.y;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7D3D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7D408(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7D400);
}

void InitBlendLinearDodgeQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearDodgeQT_hgc_visible", "//Metal1.0     \n//LEN=00000003ef\n[[ visible ]] FragmentOut BlendLinearDodgeQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
    "    const float4 c1 = float4(1.955999970, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r3.xyz = r1.xyz + r3.xyz;\n"
    "    r3.xyz = fmin(r3.xyz, c0.www);\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, c1.xxx);\n"
    "    r3.w = c0.w;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7D6A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7D6DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7D6D4);
}

void InitBlendOverlayProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendOverlay_hgc_visible", "//Metal1.0     \n//LEN=0000000340\n[[ visible ]] FragmentOut BlendOverlay_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1 = color0;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
    "    r3.xyz = r2.xyz*r0.xyz;\n"
    "    r3.xyz = r3.xyz + r3.xyz;\n"
    "    r4.xyz = r2.xyz + r0.xyz;\n"
    "    r4.xyz = r4.xyz*c0.xxx + -r3.xyz;\n"
    "    r4.xyz = r4.xyz - c0.yyy;\n"
    "    r2.xyz = float3(r2.xyz < c0.zzz);\n"
    "    r2.xyz = select(r4.xyz, r3.xyz, -r2.xyz < 0.00000f);\n"
    "    r2.w = c0.y;\n"
    "    r2.xyz = mix(r0.xyz, r2.xyz, r1.www);\n"
    "    output.color0 = mix(r1, r2, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7D97C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7D9B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7D9A8);
}

void InitBlendOverlayPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendOverlayPOW_hgc_visible", "//Metal1.0     \n//LEN=0000000470\n[[ visible ]] FragmentOut BlendOverlayPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r4.xyz = r1.xyz + r1.xyz;\n"
    "    r5.xyz = r3.xyz*r4.xyz;\n"
    "    r4.xyz = r4.xyz - c0.yyy;\n"
    "    r6.xyz = r4.xyz*r3.xyz;\n"
    "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
    "    r6.xyz = fmin(r6.xyz, r3.xyz);\n"
    "    r4.xyz = r4.xyz + r3.xyz;\n"
    "    r6.xyz = r4.xyz - r6.xyz;\n"
    "    r1.xyz = float3(r1.xyz <= c0.zzz);\n"
    "    r1.xyz = select(r6.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
    "    r1.w = c0.y;\n"
    "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7DC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7DC84(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7DC7CLL);
}

void InitBlendOverlayQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendOverlayQT_hgc_visible", "//Metal1.0     \n//LEN=0000000530\n[[ visible ]] FragmentOut BlendOverlayQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
    "    const float4 c1 = float4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r4.xyz = r1.xyz + r1.xyz;\n"
    "    r5.xyz = r3.xyz*r4.xyz;\n"
    "    r4.xyz = r4.xyz - c0.www;\n"
    "    r6.xyz = r4.xyz*r3.xyz;\n"
    "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
    "    r6.xyz = fmin(r6.xyz, r3.xyz);\n"
    "    r4.xyz = r4.xyz + r3.xyz;\n"
    "    r6.xyz = r4.xyz - r6.xyz;\n"
    "    r1.xyz = float3(r1.xyz <= c1.xxx);\n"
    "    r1.xyz = select(r6.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c1.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
    "    r1.w = c0.w;\n"
    "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7DF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7DF58(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7DF50);
}

void InitBlendSoftLightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSoftLight_hgc_visible", "//Metal1.0     \n//LEN=0000000474\n[[ visible ]] FragmentOut BlendSoftLight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(16.00000000, -12.00000000, 4.000000000, 0.2500000000);\n"
    "    const float4 c1 = float4(2.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
    "    r2.xyz = r1.xyz*r2.xyz + c0.zzz;\n"
    "    r2.xyz = r1.xyz*r2.xyz;\n"
    "    r3.xyz = sqrt(r1.xyz);\n"
    "    r4.xyz = float3(c0.www >= r1.xyz);\n"
    "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000f);\n"
    "    r4 = color1;\n"
    "    r4 = r4*hg_Params[0];\n"
    "    r4 = r4 / float4(fmax(r4.www, 1.00000e-06f), 1.);\n"
    "    r2.xyz = -r4.xyz*c1.xxx + c1.yyy;\n"
    "    r3.xyz = mix(r1.xyz, r3.xyz, -r2.xyz);\n"
    "    r2.xyz = r2.xyz*r1.xyz;\n"
    "    r2.xyz = mix(r1.xyz, c1.yyy, -r2.xyz);\n"
    "    r1.xyz = float3(c1.zzz >= r4.xyz);\n"
    "    r1.xyz = select(r3.xyz, r2.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.w = c1.y;\n"
    "    r1.xyz = mix(r4.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r4.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7E1F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7E22C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7E224);
}

void InitBlendSoftLightPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSoftLightPOW_hgc_visible", "//Metal1.0     \n//LEN=000000053f\n[[ visible ]] FragmentOut BlendSoftLightPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 16.00000000, -12.00000000, 4.000000000);\n"
    "    const float4 c1 = float4(0.2500000000, 2.000000000, 1.000000000, 0.5000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2.xyz = r1.xyz*c0.yyy + c0.zzz;\n"
    "    r2.xyz = r1.xyz*r2.xyz + c0.www;\n"
    "    r2.xyz = r1.xyz*r2.xyz;\n"
    "    r3.xyz = sqrt(r1.xyz);\n"
    "    r4.xyz = float3(c1.xxx >= r1.xyz);\n"
    "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000f);\n"
    "    r4 = color1;\n"
    "    r4 = r4*hg_Params[0];\n"
    "    r2.xyz = r4.xyz / fmax(r4.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
    "    r5.xyz = -r4.xyz*c1.yyy + c1.zzz;\n"
    "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
    "    r5.xyz = r5.xyz*r1.xyz;\n"
    "    r5.xyz = mix(r1.xyz, c1.zzz, -r5.xyz);\n"
    "    r1.xyz = float3(c1.www >= r4.xyz);\n"
    "    r1.xyz = select(r3.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
    "    r1.w = c1.z;\n"
    "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r4.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7E4CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7E500(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7E4F8);
}

void InitBlendSoftLightQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSoftLightQT_hgc_visible", "//Metal1.0     \n//LEN=0000000614\n[[ visible ]] FragmentOut BlendSoftLightQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 16.00000000);\n"
    "    const float4 c1 = float4(-12.00000000, 4.000000000, 0.2500000000, 2.000000000);\n"
    "    const float4 c2 = float4(1.000000000, 0.5000000000, 1.149999976, 1.955999970);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2.xyz = r1.xyz*c0.www + c1.xxx;\n"
    "    r2.xyz = r1.xyz*r2.xyz + c1.yyy;\n"
    "    r2.xyz = r1.xyz*r2.xyz;\n"
    "    r3.xyz = sqrt(r1.xyz);\n"
    "    r4.xyz = float3(c1.zzz >= r1.xyz);\n"
    "    r3.xyz = select(r3.xyz, r2.xyz, -r4.xyz < 0.00000f);\n"
    "    r4 = color1;\n"
    "    r4 = r4*hg_Params[0];\n"
    "    r2.xyz = r4.xyz / fmax(r4.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r5.xyz = fmin(r4.xyz, c0.yyy);\n"
    "    r5.xyz = pow(r5.xyz, c0.zzz);\n"
    "    r4.xyz = r5.xyz;\n"
    "    r5.xyz = -r4.xyz*c1.www + c2.xxx;\n"
    "    r3.xyz = mix(r1.xyz, r3.xyz, -r5.xyz);\n"
    "    r5.xyz = r5.xyz*r1.xyz;\n"
    "    r5.xyz = mix(r1.xyz, c2.xxx, -r5.xyz);\n"
    "    r1.xyz = float3(c2.yyy >= r4.xyz);\n"
    "    r1.xyz = select(r3.xyz, r5.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c2.zzz);\n"
    "    r1.xyz = pow(r1.xyz, c2.www);\n"
    "    r1.w = c2.x;\n"
    "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r4.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7E7A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7E7D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7E7CCLL);
}

void InitBlendHardLightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendHardLight_hgc_visible", "//Metal1.0     \n//LEN=00000003b2\n[[ visible ]] FragmentOut BlendHardLight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, -2.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2 = color0;\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = r1.xyz + r1.xyz;\n"
    "    r5.xyz = r4.xyz - c0.xxx;\n"
    "    r6.xyz = r3.xyz*r5.xyz;\n"
    "    r6.xyz = fmin(r5.xyz, r6.xyz);\n"
    "    r6.xyz = fmin(r3.xyz, r6.xyz);\n"
    "    r5.xyz = r3.xyz + r5.xyz;\n"
    "    r5.xyz = r5.xyz - r6.xyz;\n"
    "    r4.xyz = r4.xyz*r3.xyz + -r5.xyz;\n"
    "    r0.xyz = r0.xyz*c0.yyy;\n"
    "    r6.xyz = float3(r0.xyz >= -r0.www);\n"
    "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
    "    r6.w = c0.x;\n"
    "    r6.xyz = mix(r1.xyz, r6.xyz, r2.www);\n"
    "    output.color0 = mix(r2, r6, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7EA74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7EAA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7EAA0);
}

void InitBlendHardLightPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendHardLightPOW_hgc_visible", "//Metal1.0     \n//LEN=0000000472\n[[ visible ]] FragmentOut BlendHardLightPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r4.xyz = r3.xyz + r3.xyz;\n"
    "    r5.xyz = r1.xyz*r4.xyz;\n"
    "    r4.xyz = r4.xyz - c0.yyy;\n"
    "    r6.xyz = r4.xyz*r1.xyz;\n"
    "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
    "    r6.xyz = fmin(r6.xyz, r1.xyz);\n"
    "    r4.xyz = r4.xyz + r1.xyz;\n"
    "    r6.xyz = r4.xyz - r6.xyz;\n"
    "    r3.xyz = float3(r3.xyz <= c0.zzz);\n"
    "    r3.xyz = select(r6.xyz, r5.xyz, -r3.xyz < 0.00000f);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
    "    r3.w = c0.y;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7ED48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7ED7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7ED74);
}

void InitBlendHardLightQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendHardLightQT_hgc_visible", "//Metal1.0     \n//LEN=0000000532\n[[ visible ]] FragmentOut BlendHardLightQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
    "    const float4 c1 = float4(0.5000000000, 1.149999976, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r4.xyz = r3.xyz + r3.xyz;\n"
    "    r5.xyz = r1.xyz*r4.xyz;\n"
    "    r4.xyz = r4.xyz - c0.www;\n"
    "    r6.xyz = r4.xyz*r1.xyz;\n"
    "    r6.xyz = fmin(r6.xyz, r4.xyz);\n"
    "    r6.xyz = fmin(r6.xyz, r1.xyz);\n"
    "    r4.xyz = r4.xyz + r1.xyz;\n"
    "    r6.xyz = r4.xyz - r6.xyz;\n"
    "    r3.xyz = float3(r3.xyz <= c1.xxx);\n"
    "    r3.xyz = select(r6.xyz, r5.xyz, -r3.xyz < 0.00000f);\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c1.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c1.zzz);\n"
    "    r3.w = c0.w;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7F01C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7F050(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7F048);
}

void InitBlendVividLightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendVividLight_hgc_visible", "//Metal1.0     \n//LEN=000000068f\n[[ visible ]] FragmentOut BlendVividLight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(65536.00000, 0.5000000000, 1.525878906e-05, 1.000000000);\n"
    "    const float4 c1 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmin(r0.xyz, r0.www);\n"
    "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2.xyz = fmin(r2.xyz, r2.www);\n"
    "    r3 = clamp(r2 / float4(fmax(r2.www, 1.00000e-06f), 1.), 0.00000f, 1.00000f);\n"
    "    r1.xyz = r1.xyz*c0.xxx + c0.yyy;\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r1.xyz = r1.xyz*c0.zzz;\n"
    "    r4.xyz = r3.xyz*c0.xxx + c0.yyy;\n"
    "    r4.xyz = floor(r4.xyz);\n"
    "    r3.xyz = r4.xyz*c0.zzz;\n"
    "    r4.xyz = c0.www - r1.xyz;\n"
    "    r5.xyz = fmax(r3.xyz, c0.zzz);\n"
    "    r6.xyz = -c0.yyy*r4.xyz + r5.xyz;\n"
    "    r6.xyz = r6.xyz/r5.xyz;\n"
    "    r4.xyz = r4.xyz*c0.yyy;\n"
    "    r5.xyz = float3(-r3.xyz < -r4.xyz);\n"
    "    r6.xyz = r6.xyz*r5.xyz;\n"
    "    r5.xyz = c0.yyy*r2.www;\n"
    "    r5.xyz = float3(r2.xyz < r5.xyz);\n"
    "    r6.xyz = r6.xyz*r5.xyz;\n"
    "    r5.xyz = c0.www - r5.xyz;\n"
    "    r4.xyz = r4.xyz + c0.yyy;\n"
    "    r4.xyz = float3(r3.xyz < r4.xyz);\n"
    "    r4.xyz = fmin(r5.xyz, r4.xyz);\n"
    "    r2.xyz = c0.www - r3.xyz;\n"
    "    r2.xyz = fmax(r2.xyz, c0.zzz);\n"
    "    r2.xyz = r2.xyz + r2.xyz;\n"
    "    r2.xyz = r1.xyz/r2.xyz;\n"
    "    r6.xyz = r2.xyz*r4.xyz + r6.xyz;\n"
    "    r4.xyz = float3(-r4.xyz >= c1.xxx);\n"
    "    r6.xyz = r5.xyz*r4.xyz + r6.xyz;\n"
    "    r6.w = c0.w;\n"
    "    r6.xyz = mix(r3.xyz, r6.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r6, r3.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7F2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7F324(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7F31CLL);
}

void InitBlendVividLightPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendVividLightPOW_hgc_visible", "//Metal1.0     \n//LEN=00000006fb\n[[ visible ]] FragmentOut BlendVividLightPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, -0.5000000000, 1.525878906e-05, -2.000000000);\n"
    "    const float4 c1 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
    "    r5.xyz = c0.xxx - r1.xyz;\n"
    "    r5.xyz = c0.yyy*r5.xyz + r4.xyz;\n"
    "    r6.xyz = fmax(r4.xyz, c0.zzz);\n"
    "    r6.xyz = r5.xyz/r6.xyz;\n"
    "    r7.xyz = c0.yyy*r1.xyz + c0.xxx;\n"
    "    r7.xyz = r4.xyz - r7.xyz;\n"
    "    r8.xyz = c0.www*r4.xyz + -c0.www;\n"
    "    r9.xyz = fmax(r8.xyz, c0.zzz);\n"
    "    r9.xyz = r1.xyz/r9.xyz;\n"
    "    r1.xyz = float3(r4.xyz < -c0.yyy);\n"
    "    r5.xyz = float3(r5.xyz > c1.xxx);\n"
    "    r10.xyz = float3(r7.xyz < c1.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, r5.xyz);\n"
    "    r1.xyz = r1.xyz*r6.xyz;\n"
    "    r4.xyz = float3(r4.xyz >= -c0.yyy);\n"
    "    r4.xyz = fmin(r4.xyz, r10.xyz);\n"
    "    r1.xyz = select(r1.xyz, r9.xyz, -r4.xyz < 0.00000f);\n"
    "    r1.xyz = select(-c0.www, r1.xyz, r7.xyz < 0.00000f);\n"
    "    r8.xyz = float3(r8.xyz <= c0.zzz);\n"
    "    r1.xyz = select(r1.xyz, c0.xxx, -r8.xyz < 0.00000f);\n"
    "    r5.xyz = float3(r5.xyz <= c0.zzz);\n"
    "    r1.xyz = clamp(select(r1.xyz, c1.xxx, -r5.xyz < 0.00000f), 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[2].xyz);\n"
    "    r1.w = c0.x;\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7F5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7F5F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7F5F0);
}

void InitBlendVividLightQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendVividLightQT_hgc_visible", "//Metal1.0     \n//LEN=00000006dd\n[[ visible ]] FragmentOut BlendVividLightQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.5109999776, 1.000000000, -0.5000000000, 1.525878906e-05);\n"
    "    const float4 c1 = float4(-2.000000000, 0.000000000, 1.955999970, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = clamp(r0.xyz / fmax(r0.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, c0.xxx);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
    "    r4.xyz = pow(r4.xyz, c0.xxx);\n"
    "    r5.xyz = c0.yyy - r1.xyz;\n"
    "    r5.xyz = c0.zzz*r5.xyz + r4.xyz;\n"
    "    r6.xyz = fmax(r4.xyz, c0.www);\n"
    "    r6.xyz = r5.xyz/r6.xyz;\n"
    "    r7.xyz = c0.zzz*r1.xyz + c0.yyy;\n"
    "    r7.xyz = r4.xyz - r7.xyz;\n"
    "    r8.xyz = c1.xxx*r4.xyz + -c1.xxx;\n"
    "    r9.xyz = fmax(r8.xyz, c0.www);\n"
    "    r9.xyz = r1.xyz/r9.xyz;\n"
    "    r1.xyz = float3(r4.xyz < -c0.zzz);\n"
    "    r5.xyz = float3(r5.xyz > c1.yyy);\n"
    "    r10.xyz = float3(r7.xyz < c1.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, r5.xyz);\n"
    "    r1.xyz = r1.xyz*r6.xyz;\n"
    "    r4.xyz = float3(r4.xyz >= -c0.zzz);\n"
    "    r4.xyz = fmin(r4.xyz, r10.xyz);\n"
    "    r1.xyz = select(r1.xyz, r9.xyz, -r4.xyz < 0.00000f);\n"
    "    r1.xyz = select(-c1.xxx, r1.xyz, r7.xyz < 0.00000f);\n"
    "    r8.xyz = float3(r8.xyz <= c0.www);\n"
    "    r1.xyz = select(r1.xyz, c0.yyy, -r8.xyz < 0.00000f);\n"
    "    r5.xyz = float3(r5.xyz <= c0.www);\n"
    "    r1.xyz = clamp(select(r1.xyz, c1.yyy, -r5.xyz < 0.00000f), 0.00000f, 1.00000f);\n"
    "    r1.xyz = pow(r1.xyz, c1.zzz);\n"
    "    r1.w = c0.y;\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7F898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7F8CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7F8C4);
}

void InitBlendLinearLightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearLight_hgc_visible", "//Metal1.0     \n//LEN=00000002a3\n[[ visible ]] FragmentOut BlendLinearLight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(-2.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = c0.xxx*r2.xyz + c0.yyy;\n"
    "    r1.xyz = clamp(r1.xyz - r3.xyz, 0.00000f, 1.00000f);\n"
    "    r1.w = c0.y;\n"
    "    r1.xyz = mix(r2.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7FB6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7FBA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7FB98);
}

void InitBlendLinearLightPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearLightPOW_hgc_visible", "//Metal1.0     \n//LEN=0000000370\n[[ visible ]] FragmentOut BlendLinearLightPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r3.xyz = c0.yyy*r3.xyz + c0.zzz;\n"
    "    r3.xyz = clamp(r1.xyz - r3.xyz, 0.00000f, 1.00000f);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[2].xyz);\n"
    "    r3.w = c0.z;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B7FE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B7FE74(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B7FE6CLL);
}

void InitBlendLinearLightQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLinearLightQT_hgc_visible", "//Metal1.0     \n//LEN=00000003ea\n[[ visible ]] FragmentOut BlendLinearLightQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
    "    const float4 c1 = float4(1.000000000, 1.955999970, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r3.xyz = c0.www*r3.xyz + c1.xxx;\n"
    "    r3.xyz = clamp(r1.xyz - r3.xyz, 0.00000f, 1.00000f);\n"
    "    r3.xyz = pow(r3.xyz, c1.yyy);\n"
    "    r3.w = c1.x;\n"
    "    r3.xyz = mix(r2.xyz, r3.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r3, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B80114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B80148(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B80140);
}

void InitBlendPinLightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendPinLight_hgc_visible", "//Metal1.0     \n//LEN=0000000382\n[[ visible ]] FragmentOut BlendPinLight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1 = color0;\n"
    "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
    "    r3.xyz = r0.xyz + r0.xyz;\n"
    "    r4.xyz = float3(r3.xyz < r2.xyz);\n"
    "    r5.xyz = r3.xyz*r4.xyz;\n"
    "    r3.xyz = r3.xyz - c0.xxx;\n"
    "    r6.xyz = float3(r3.xyz >= r2.xyz);\n"
    "    r5.xyz = r3.xyz*r6.xyz + r5.xyz;\n"
    "    r4.xyz = r4.xyz + r6.xyz;\n"
    "    r4.xyz = float3(-r4.xyz >= c0.yyy);\n"
    "    r5.xyz = r2.xyz*r4.xyz + r5.xyz;\n"
    "    r5.w = c0.x;\n"
    "    r5.xyz = mix(r0.xyz, r5.xyz, r1.www);\n"
    "    output.color0 = mix(r1, r5, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B803E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B8041C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B80414);
}

void InitBlendPinLightPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendPinLightPOW_hgc_visible", "//Metal1.0     \n//LEN=000000044f\n[[ visible ]] FragmentOut BlendPinLightPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color0;\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r1.xyz = r1.xyz + r1.xyz;\n"
    "    r4.xyz = float3(r1.xyz < r3.xyz);\n"
    "    r5.xyz = r1.xyz*r4.xyz;\n"
    "    r1.xyz = r1.xyz - c0.yyy;\n"
    "    r6.xyz = float3(r1.xyz >= r3.xyz);\n"
    "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
    "    r4.xyz = r4.xyz + r6.xyz;\n"
    "    r4.xyz = float3(-r4.xyz >= c0.xxx);\n"
    "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
    "    r5.xyz = pow(r5.xyz, hg_Params[2].xyz);\n"
    "    r5.w = c0.y;\n"
    "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
    "    output.color0 = mix(r2, r5, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B806BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B806F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B806E8);
}

void InitBlendPinLightQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendPinLightQT_hgc_visible", "//Metal1.0     \n//LEN=000000050f\n[[ visible ]] FragmentOut BlendPinLightQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.000000000);\n"
    "    const float4 c1 = float4(1.149999976, 1.955999970, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color0;\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r3.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, c0.yyy);\n"
    "    r3.xyz = pow(r3.xyz, c0.zzz);\n"
    "    r1.xyz = r1.xyz + r1.xyz;\n"
    "    r4.xyz = float3(r1.xyz < r3.xyz);\n"
    "    r5.xyz = r1.xyz*r4.xyz;\n"
    "    r1.xyz = r1.xyz - c0.www;\n"
    "    r6.xyz = float3(r1.xyz >= r3.xyz);\n"
    "    r5.xyz = r1.xyz*r6.xyz + r5.xyz;\n"
    "    r4.xyz = r4.xyz + r6.xyz;\n"
    "    r4.xyz = float3(-r4.xyz >= c0.xxx);\n"
    "    r5.xyz = r3.xyz*r4.xyz + r5.xyz;\n"
    "    r5.xyz = fmax(r5.xyz, c0.xxx);\n"
    "    r5.xyz = fmin(r5.xyz, c1.xxx);\n"
    "    r5.xyz = pow(r5.xyz, c1.yyy);\n"
    "    r5.w = c0.w;\n"
    "    r5.xyz = mix(r0.xyz, r5.xyz, r2.www);\n"
    "    output.color0 = mix(r2, r5, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B80990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B809C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B809BCLL);
}

void InitBlendHardMixProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendHardMix_hgc_visible", "//Metal1.0     \n//LEN=000000071a\n[[ visible ]] FragmentOut BlendHardMix_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 65535.00000, 1.525902189e-05, 0.003921568859);\n"
    "    const float4 c1 = float4(-0.7500000000, 3.039975672e-05, 1.003921628, 32895.00000);\n"
    "    const float4 c2 = float4(0.007751937956, 254.9999847, 0.000000000, 0.9960784316);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r2 = r2 / float4(fmax(r2.www, 1.00000e-06f), 1.);\n"
    "    r3.xyz = c0.xxx - r1.xyz;\n"
    "    r3.xyz = r3.xyz*c0.yyy;\n"
    "    r3.xyz = floor(r3.xyz);\n"
    "    r3.xyz = r3.xyz*c0.zzz;\n"
    "    r4.xyz = -r1.xyz*c0.www + r3.xyz;\n"
    "    r4.xyz = c1.xxx*c1.yyy + r4.xyz;\n"
    "    r5.xyz = float3(r2.xyz >= r4.xyz);\n"
    "    r3.xyz = r3.xyz*c1.zzz;\n"
    "    r6.xyz = float3(r2.xyz < r3.xyz);\n"
    "    r4.xyz = r2.xyz - r4.xyz;\n"
    "    r4.xyz = r4.xyz*c1.www;\n"
    "    r4.xyz = floor(r4.xyz);\n"
    "    r4.xyz = c2.xxx*r4.xyz;\n"
    "    r6.xyz = fmin(r5.xyz, r6.xyz);\n"
    "    r4.xyz = r4.xyz*r6.xyz;\n"
    "    r6.xyz = float3(r2.xyz >= r3.xyz);\n"
    "    r6.xyz = r6.xyz + r4.xyz;\n"
    "    r3.xyz = fmin(r3.xyz, c0.xxx);\n"
    "    r4.xyz = float3(r1.xyz < c0.www);\n"
    "    r4.xyz = fmin(r4.xyz, r5.xyz);\n"
    "    r5.xyz = r1.xyz*c2.yyy;\n"
    "    r5.xyz = r5.xyz*r4.xyz;\n"
    "    r5.xyz = fmin(r5.xyz, r6.xyz);\n"
    "    r4.xyz = float3(-r4.xyz >= c2.zzz);\n"
    "    r6.xyz = r6.xyz*r4.xyz + r5.xyz;\n"
    "    r4.xyz = float3(r1.xyz >= c2.www);\n"
    "    r3.xyz = float3(r2.xyz < r3.xyz);\n"
    "    r4.xyz = fmin(r4.xyz, r3.xyz);\n"
    "    r1.xyz = r1.xyz - c2.www;\n"
    "    r1.xyz = r1.xyz*c2.yyy;\n"
    "    r1.xyz = r1.xyz*r4.xyz;\n"
    "    r6.xyz = fmax(r1.xyz, r6.xyz);\n"
    "    r6.w = c0.x;\n"
    "    r6.xyz = mix(r2.xyz, r6.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r6, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B80C64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B80C98(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B80C90);
}

void InitBlendHardMixPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendHardMixPOW_hgc_visible", "//Metal1.0     \n//LEN=00000003d7\n[[ visible ]] FragmentOut BlendHardMixPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].xyz);\n"
    "    r2 = color0;\n"
    "    r3.xyz = clamp(r2.xyz / fmax(r2.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r3.xyz = pow(r3.xyz, hg_Params[1].xyz);\n"
    "    r4.xyz = c0.xxx - r3.xyz;\n"
    "    r4.xyz = float3(r4.xyz <= r0.xyz);\n"
    "    r3.xyz = float3(r3.xyz <= c0.yyy);\n"
    "    r5.xyz = float3(r0.xyz >= c0.xxx);\n"
    "    r3.xyz = fmin(r3.xyz, r5.xyz);\n"
    "    r3.xyz = select(r4.xyz, c0.yyy, -r3.xyz < 0.00000f);\n"
    "    r3.w = c0.x;\n"
    "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
    "    output.color0 = mix(r2, r3, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B80F38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B80F6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B80F64);
}

void InitBlendHardMixQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendHardMixQT_hgc_visible", "//Metal1.0     \n//LEN=00000003ed\n[[ visible ]] FragmentOut BlendHardMixQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.5109999776, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
    "    r2.xyz = r0.xyz;\n"
    "    r2.xyz = pow(r2.xyz, c0.xxx);\n"
    "    r0.xyz = r2.xyz;\n"
    "    r2 = color0;\n"
    "    r3.xyz = clamp(r2.xyz / fmax(r2.w, 1.00000e-06f), 0.00000f, 1.00000f);\n"
    "    r3.xyz = pow(r3.xyz, c0.xxx);\n"
    "    r4.xyz = c0.yyy - r3.xyz;\n"
    "    r4.xyz = float3(r4.xyz <= r0.xyz);\n"
    "    r3.xyz = float3(r3.xyz <= c0.zzz);\n"
    "    r5.xyz = float3(r0.xyz >= c0.yyy);\n"
    "    r3.xyz = fmin(r3.xyz, r5.xyz);\n"
    "    r3.xyz = select(r4.xyz, c0.zzz, -r3.xyz < 0.00000f);\n"
    "    r3.w = c0.y;\n"
    "    r3.xyz = mix(r1.xyz, r3.xyz, r2.www);\n"
    "    output.color0 = mix(r2, r3, r0.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B8120C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B81240(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B81238);
}

void InitBlendDifferenceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendDifference_hgc_visible", "//Metal1.0     \n//LEN=00000001c7\n[[ visible ]] FragmentOut BlendDifference_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r1 = r1 + r0;\n"
    "    r0 = r2 - r3;\n"
    "    r1 = r1 - r2;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    output.color0 = r1 + fabs(r0);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B814E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B81514(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B8150CLL);
}

void InitBlendDifferencePOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendDifferencePOW_hgc_visible", "//Metal1.0     \n//LEN=0000000332\n[[ visible ]] FragmentOut BlendDifferencePOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
    "    r1.xyz = r1.xyz - r4.xyz;\n"
    "    r1.xyz = pow(fabs(r1.xyz), hg_Params[2].xyz);\n"
    "    r1.w = c0.y;\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B817B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B817E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B817E0);
}

void InitBlendDifferenceQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendDifferenceQT_hgc_visible", "//Metal1.0     \n//LEN=00000003cf\n[[ visible ]] FragmentOut BlendDifferenceQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, 1.149999976);\n"
    "    const float4 c1 = float4(1.955999970, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
    "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
    "    r1.xyz = r1.xyz - r4.xyz;\n"
    "    r1.xyz = fmin(fabs(r1.xyz), c0.www);\n"
    "    r1.xyz = pow(r1.xyz, c1.xxx);\n"
    "    r1.w = c1.y;\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r1, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B81A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B81ABC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B81AB4);
}

void InitBlendExclusionProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendExclusion_hgc_visible", "//Metal1.0     \n//LEN=0000000241\n[[ visible ]] FragmentOut BlendExclusion_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = r0*r1;\n"
    "    r4 = c0.xxxx*r4 + r2;\n"
    "    r4 = r4 + r3;\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B81D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B81D90(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B81D88);
}

void InitBlendExclusionPOWProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendExclusionPOW_hgc_visible", "//Metal1.0     \n//LEN=0000000371\n[[ visible ]] FragmentOut BlendExclusionPOW_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -2.000000000, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[1].xyz);\n"
    "    r5.xyz = r1.xyz + r4.xyz;\n"
    "    r4.xyz = r1.xyz*r4.xyz;\n"
    "    r4.xyz = c0.yyy*r4.xyz + r5.xyz;\n"
    "    r4.xyz = pow(r4.xyz, hg_Params[2].xyz);\n"
    "    r4.w = c0.z;\n"
    "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r4, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B82030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B82064(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B8205CLL);
}

void InitBlendExclusionQTProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendExclusionQT_hgc_visible", "//Metal1.0     \n//LEN=0000000431\n[[ visible ]] FragmentOut BlendExclusionQT_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, 1.330000043, 0.5109999776, -2.000000000);\n"
    "    const float4 c1 = float4(1.149999976, 1.955999970, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
    "    r2 = color1;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r3.xyz = r2.xyz / fmax(r2.w, 1.00000e-06f);\n"
    "    r4.xyz = fmax(r3.xyz, c0.xxx);\n"
    "    r4.xyz = fmin(r4.xyz, c0.yyy);\n"
    "    r4.xyz = pow(r4.xyz, c0.zzz);\n"
    "    r5.xyz = r1.xyz + r4.xyz;\n"
    "    r4.xyz = r1.xyz*r4.xyz;\n"
    "    r4.xyz = c0.www*r4.xyz + r5.xyz;\n"
    "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
    "    r4.xyz = fmin(r4.xyz, c1.xxx);\n"
    "    r4.xyz = pow(r4.xyz, c1.yyy);\n"
    "    r4.w = c1.z;\n"
    "    r4.xyz = mix(r3.xyz, r4.xyz, r0.www);\n"
    "    output.color0 = mix(r0, r4, r2.wwww);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B82304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B82338(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B82330);
}

void InitBlendStencilAlphaProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendStencilAlpha_hgc_visible", "//Metal1.0     \n//LEN=000000014a\n[[ visible ]] FragmentOut BlendStencilAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color1.w;\n"
    "    r1 = color0;\n"
    "    r0.x = r0.w*hg_Params[0].w;\n"
    "    output.color0 = r0.xxxx*r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B825D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B8260C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B82604);
}

void InitBlendStencilLumaProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendStencilLuma_hgc_visible", "//Metal1.0     \n//LEN=00000001c8\n[[ visible ]] FragmentOut BlendStencilLuma_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = color1.xyz;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz;\n"
    "    r1 = color0;\n"
    "    r0.x = dot(r0.xyz, c0.xyz);\n"
    "    output.color0 = r0.xxxx*r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B828AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B828E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B828D8);
}

void InitBlendSilhouetteAlphaProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSilhouetteAlpha_hgc_visible", "//Metal1.0     \n//LEN=0000000153\n[[ visible ]] FragmentOut BlendSilhouetteAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color1.w;\n"
    "    r0.x = -r0.w*hg_Params[0].w;\n"
    "    r1 = color0;\n"
    "    output.color0 = r0.xxxx*r1 + r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B82B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B82BB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B82BACLL);
}

void InitBlendSilhouetteLumaProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSilhouetteLuma_hgc_visible", "//Metal1.0     \n//LEN=0000000226\n[[ visible ]] FragmentOut BlendSilhouetteLuma_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.3000000119, 0.5899999738, 0.1099999994, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz;\n"
    "    r0.x = clamp(dot(r0.xyz, c0.xyz), 0.00000f, 1.00000f);\n"
    "    r1 = color0;\n"
    "    r0.x = c0.w - r0.x;\n"
    "    output.color0 = r0.xxxx*r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B82E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B82E88(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B82E80);
}

void InitBlendBehindProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendBehind_hgc_visible", "//Metal1.0     \n//LEN=00000001ac\n[[ visible ]] FragmentOut BlendBehind_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = c0.xxxx - r0.wwww;\n"
    "    output.color0 = r1*r2 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B83128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B8315C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B83154);
}

void InitBlendAlphaAddProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendAlphaAdd_hgc_visible", "//Metal1.0     \n//LEN=000000024b\n[[ visible ]] FragmentOut BlendAlphaAdd_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2.x = c0.x - r1.w;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r2.x = fmin(r0.w, r2.x);\n"
    "    output.color0.xyz = r2.xxx*r0.xyz + r1.xyz;\n"
    "    output.color0.w = clamp(r0.w + r1.w, 0.00000f, 1.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B833FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B83430(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B83428);
}

void InitBlendLuminescentPremulProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendLuminescentPremul_hgc_visible", "//Metal1.0     \n//LEN=00000001ee\n[[ visible ]] FragmentOut BlendLuminescentPremul_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r0 = r0*hg_Params[0];\n"
    "    r1 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    r0.x = c0.x - r0.w;\n"
    "    r2 = color0;\n"
    "    output.color0 = r0.xxxx*r2 + r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B836D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B83704(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B836FCLL);
}

void InitBlendMinStraightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendMinStraight_hgc_visible", "//Metal1.0     \n//LEN=0000000127\n[[ visible ]] FragmentOut BlendMinStraight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r1 = color0;\n"
    "    output.color0 = fmin(r1, r0);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B839A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B839D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B839D0);
}

void InitBlendMaxStraightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendMaxStraight_hgc_visible", "//Metal1.0     \n//LEN=0000000127\n[[ visible ]] FragmentOut BlendMaxStraight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r1 = color0;\n"
    "    output.color0 = fmax(r1, r0);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B83C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B83CAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B83CA4);
}

void InitBlendSubtractStraightProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendSubtractStraight_hgc_visible", "//Metal1.0     \n//LEN=0000000142\n[[ visible ]] FragmentOut BlendSubtractStraight_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r1 = color0;\n"
    "    output.color0 = clamp(r1 - r0, 0.00000f, 1.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B83F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B83F80(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B83F78);
}

void InitBlendReplaceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "BlendReplace_hgc_visible", "//Metal1.0     \n//LEN=0000000114\n[[ visible ]] FragmentOut BlendReplace_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 color1)\n{\n    FragmentOut output;\n"
    "\n"
    "    output.color0 = color1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B842B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B842F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B842E8);
}

void HGLightWrap::HGLightWrap(HGLightWrap *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E6534E40;
  *(_QWORD *)(v1 + 416) = 0;
  *(_QWORD *)(v1 + 424) = 0;
  *(_QWORD *)(v1 + 408) = 0;
  *(_DWORD *)(v1 + 432) = 1065353216;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGLightWrap::~HGLightWrap(HGNode *this)
{
  void *v2;
  char *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = off_1E6534E40;
  v3 = (char *)this + 408;
  v2 = (void *)*((_QWORD *)this + 51);
  v4 = *((_QWORD *)v3 + 1) - (_QWORD)v2;
  if ((int)(v4 >> 3) >= 1)
  {
    v5 = (v4 >> 3) + 1;
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 51) + 8 * (v5 - 2));
      if (v6)
        MEMORY[0x1B5E29170](v6, 0x1000C40EED21634);
      --v5;
    }
    while (v5 > 1);
    v2 = (void *)*((_QWORD *)this + 51);
  }
  if (v2)
  {
    *((_QWORD *)this + 52) = v2;
    operator delete(v2);
  }
  HGNode::~HGNode(this);
}

{
  void *v2;
  char *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_1E6534E40;
  v3 = (char *)this + 408;
  v2 = (void *)*((_QWORD *)this + 51);
  v4 = *((_QWORD *)v3 + 1) - (_QWORD)v2;
  if ((int)(v4 >> 3) >= 1)
  {
    v5 = (v4 >> 3) + 1;
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 51) + 8 * (v5 - 2));
      if (v6)
        MEMORY[0x1B5E29170](v6, 0x1000C40EED21634);
      --v5;
    }
    while (v5 > 1);
    v2 = (void *)*((_QWORD *)this + 51);
  }
  if (v2)
  {
    *((_QWORD *)this + 52) = v2;
    operator delete(v2);
  }
  HGNode::~HGNode(this);
  HGObject::operator delete(v7);
}

uint64_t HGLightWrap::SetState(HGLightWrap *this, HGRenderer *a2, int a3)
{
  unint64_t v4;
  char **v5;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _BYTE *v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  _OWORD *v28;
  __int128 *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  __int128 v36;

  if (a3 == 1)
  {
    if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
    {
      v4 = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 5);
      if (v4 <= (uint64_t)(*((_QWORD *)this + 52) - *((_QWORD *)this + 51)) >> 3)
        return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
      goto LABEL_6;
    }
    v4 = 1;
    if (!((uint64_t)(*((_QWORD *)this + 52) - *((_QWORD *)this + 51)) >> 3))
    {
LABEL_6:
      v5 = (char **)((char *)this + 408);
      __asm { FMOV            V0.4S, #1.0 }
      v36 = _Q0;
      while (1)
      {
        v12 = (_OWORD *)operator new();
        v13 = v12;
        *v12 = 0u;
        v12[1] = v36;
        v12[2] = 0u;
        v15 = (char *)*((_QWORD *)this + 52);
        v14 = *((_QWORD *)this + 53);
        if ((unint64_t)v15 >= v14)
          break;
        *(_QWORD *)v15 = v12;
        v11 = (uint64_t)(v15 + 8);
LABEL_8:
        *((_QWORD *)this + 52) = v11;
        if (v4 <= (v11 - *((_QWORD *)this + 51)) >> 3)
          return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
      }
      v16 = *v5;
      v17 = v15 - *v5;
      v18 = v17 >> 3;
      v19 = (v17 >> 3) + 1;
      if (v19 >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v20 = v14 - (_QWORD)v16;
      if (v20 >> 2 > v19)
        v19 = v20 >> 2;
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v19;
      if (v21)
      {
        if (v21 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v22 = operator new(8 * v21);
        v23 = &v22[8 * v18];
        *v23 = v13;
        v11 = (uint64_t)(v23 + 1);
        if (v15 == v16)
          goto LABEL_28;
      }
      else
      {
        v22 = 0;
        v23 = (_QWORD *)(8 * v18);
        *(_QWORD *)(8 * v18) = v13;
        v11 = 8 * v18 + 8;
        if (v15 == v16)
        {
LABEL_28:
          *((_QWORD *)this + 51) = v23;
          *((_QWORD *)this + 52) = v11;
          *((_QWORD *)this + 53) = &v22[8 * v21];
          if (v15)
            operator delete(v15);
          goto LABEL_8;
        }
      }
      v24 = v15 - 8 - v16;
      if (v24 < 0x58)
        goto LABEL_35;
      if ((unint64_t)(v15 - &v22[v17]) < 0x20)
        goto LABEL_35;
      v25 = (v24 >> 3) + 1;
      v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
      v27 = &v15[-v26];
      v23 = (_QWORD *)((char *)v23 - v26);
      v28 = &v22[8 * v18 - 16];
      v29 = (__int128 *)(v15 - 16);
      v30 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v31 = *v29;
        *(v28 - 1) = *(v29 - 1);
        *v28 = v31;
        v28 -= 2;
        v29 -= 2;
        v30 -= 4;
      }
      while (v30);
      v15 = v27;
      if (v25 != (v25 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        do
        {
          v32 = *((_QWORD *)v15 - 1);
          v15 -= 8;
          *--v23 = v32;
        }
        while (v15 != v16);
      }
      v15 = *v5;
      goto LABEL_28;
    }
  }
  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

uint64_t HGLightWrap::GetDOD(HGLightWrap *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 >= 4)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HGLightWrap::GetROI(HGLightWrap *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 <= 3)
    return *(_QWORD *)&a4.var0;
  else
    return 0;
}

HGLightWrap *HGLightWrap::GetOutput(HGLightWrap *this, HGRenderer *a2)
{
  (*(void (**)(HGLightWrap *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 32);
  return this;
}

uint64_t HGLightWrap::SetParameter(HGLightWrap *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2)
    return 0xFFFFFFFFLL;
  *((float *)this + 108) = a3;
  return HGNode::SetParameter((HGNode *)this, 0, a3, a3, a3, a3, a7);
}

uint64_t HGLightWrap::Bind(HGLightWrap *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, **((_QWORD **)this + 51), 1);
  return 0;
}

float32x4_t HGLightWrap::UpdateLocalParameters(HGLightWrap *this, int a2)
{
  const float *v2;
  float32x4_t result;

  v2 = (const float *)((char *)this + 432);
  result = vld1q_dup_f32(v2);
  *(float32x4_t *)*(_QWORD *)(*((_QWORD *)this + 51) + 8 * a2) = result;
  return result;
}

uint64_t HGLightWrap::RenderTile(HGLightWrap *this, HGTile *a2)
{
  unsigned int v4;
  int32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  int v8;
  float32x4_t *v9;
  unint64_t v10;
  float32x4_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x4_t *v20;
  uint64_t v21;
  float32x4_t *v22;
  float32x4_t *v23;
  int32x4_t *v24;
  unint64_t v25;
  unint64_t v26;
  int32x4_t *v27;
  float32x4_t *v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  float32x4_t *v32;
  float32x4_t *v33;
  int32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t *v40;
  int32x4_t v41;
  int32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  size_t v53;
  unsigned int v54;
  int v55;
  int v56;
  int v57;
  size_t v58;
  char *v59;
  int v60;
  size_t v61;
  int i;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;

  v4 = *(_DWORD *)(*((_QWORD *)a2 + 42) + 160);
  (*(void (**)(HGLightWrap *, _QWORD))(*(_QWORD *)this + 576))(this, v4);
  v5 = (int32x4_t *)*((_QWORD *)a2 + 10);
  if (v5
    && (v6 = (float32x4_t *)*((_QWORD *)a2 + 12)) != 0
    && (v7 = (float32x4_t *)*((_QWORD *)a2 + 14)) != 0
    && *((float *)this + 108) > 0.0)
  {
    v8 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
    if (v8 >= 1)
    {
      v9 = *(float32x4_t **)(*((_QWORD *)this + 51) + 8 * (int)v4);
      v10 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
      v11 = (float32x4_t *)*((_QWORD *)a2 + 2);
      v12 = *((int *)a2 + 6);
      v13 = *((int *)a2 + 30);
      v14 = *((int *)a2 + 26);
      v15 = *((int *)a2 + 22);
      if ((int)v10 < 4)
      {
        if ((int)v10 >= 1)
        {
          v64 = 0;
          v65 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
          v66 = 16 * v13;
          v67 = 16 * v14;
          v68 = 16 * v15;
          do
          {
            v69 = 0;
            do
            {
              v11[v69 / 0x10] = vmulq_f32(*v9, vmulq_f32(v6[v69 / 0x10], vmulq_laneq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v9[1], (float32x4_t)vdupq_laneq_s32(v5[v69 / 0x10], 3)), v9[2]), v9[1]), v7[v69 / 0x10], 3)));
              v69 += 16;
            }
            while (v65 != v69);
            ++v64;
            v11 += v12;
            v7 = (float32x4_t *)((char *)v7 + v66);
            v6 = (float32x4_t *)((char *)v6 + v67);
            v5 = (int32x4_t *)((char *)v5 + v68);
          }
          while (v64 != v8);
        }
      }
      else
      {
        v16 = 0;
        v17 = 16 * v15;
        v18 = 16 * v13;
        v19 = 16 * v14;
        v20 = v11 + 4;
        v21 = 16 * v12;
        v22 = v7 + 4;
        v23 = v6 + 4;
        v24 = v5 + 4;
        do
        {
          v25 = 0;
          v26 = 0;
          v27 = v24;
          v28 = v23;
          v29 = v22;
          v30 = v20;
          do
          {
            v31 = v30;
            v32 = v29;
            v33 = v28;
            v34 = v27;
            v35 = v9[1];
            v36 = v9[2];
            v37 = vmulq_f32(vmulq_f32(v6[v25 + 1], vmulq_laneq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v35, (float32x4_t)vdupq_laneq_s32(v5[v25 + 1], 3)), v36), v35), v7[v25 + 1], 3)), *v9);
            v38 = vmulq_f32(vmulq_f32(v6[v25 + 2], vmulq_laneq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v35, (float32x4_t)vdupq_laneq_s32(v5[v25 + 2], 3)), v36), v35), v7[v25 + 2], 3)), *v9);
            v39 = vmulq_f32(*v9, vmulq_f32(v6[v25 + 3], vmulq_laneq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v35, (float32x4_t)vdupq_laneq_s32(v5[v25 + 3], 3)), v36), v35), v7[v25 + 3], 3)));
            v40 = &v11[v25];
            *v40 = vmulq_f32(vmulq_f32(v6[v25], vmulq_laneq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v35, (float32x4_t)vdupq_laneq_s32(v5[v25], 3)), v36), v35), v7[v25], 3)), *v9);
            v40[1] = v37;
            v26 += 4;
            v25 += 4;
            v30 += 4;
            v40[2] = v38;
            v40[3] = v39;
            v29 += 4;
            v28 += 4;
            v27 = v34 + 4;
          }
          while ((uint64_t)v26 < (uint64_t)(v10 - 3));
          if ((int)v10 > (int)v26)
          {
            do
            {
              v41 = *v34++;
              v42 = v41;
              v43 = *v33++;
              v44 = v43;
              v45 = *v32++;
              *v31++ = vmulq_f32(*v9, vmulq_f32(v44, vmulq_laneq_f32(vminq_f32(vmaxq_f32(vsubq_f32(v9[1], (float32x4_t)vdupq_laneq_s32(v42, 3)), v9[2]), v9[1]), v45, 3)));
              ++v26;
            }
            while (v26 < v10);
          }
          ++v16;
          v5 = (int32x4_t *)((char *)v5 + v17);
          v7 = (float32x4_t *)((char *)v7 + v18);
          v6 = (float32x4_t *)((char *)v6 + v19);
          v11 = (float32x4_t *)((char *)v11 + v21);
          v20 = (float32x4_t *)((char *)v20 + v21);
          v22 = (float32x4_t *)((char *)v22 + v18);
          v23 = (float32x4_t *)((char *)v23 + v19);
          v24 = (int32x4_t *)((char *)v24 + v17);
        }
        while (v16 != v8);
      }
    }
  }
  else
  {
    v46 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
    if (v46 >= 1)
    {
      v47 = *((_DWORD *)a2 + 2);
      v48 = *(_DWORD *)a2;
      v49 = v47 - *(_DWORD *)a2;
      v50 = v49 - 4;
      if (v49 < 4)
      {
        if (v49 >= 1)
        {
          v60 = 0;
          v61 = 16 * (v47 + ~v48) + 16;
          do
            bzero((void *)(*((_QWORD *)a2 + 2) + 16 * *((_DWORD *)a2 + 6) * v60++), v61);
          while (v46 != v60);
        }
      }
      else
      {
        if (v49 >= 7)
          v51 = 7;
        else
          v51 = v47 - *(_DWORD *)a2;
        v52 = v47 - v48 - v51 + 3;
        v53 = ((unint64_t)(v52 >> 2) << 6) + 64;
        v54 = v52 & 0xFFFFFFFC;
        v55 = v49 - v54;
        v56 = v50 - v54;
        if ((int)(v50 - v54) >= 1)
          v56 = 1;
        if (v55 <= 4)
        {
          for (i = 0; i != v46; ++i)
            bzero((void *)(*((_QWORD *)a2 + 2) + 16 * *((_DWORD *)a2 + 6) * i), v53);
        }
        else
        {
          v57 = 0;
          v58 = 16 * (v50 - v54 - v56) + 16;
          do
          {
            v59 = (char *)(*((_QWORD *)a2 + 2) + 16 * *((_DWORD *)a2 + 6) * v57);
            bzero(v59, v53);
            bzero(&v59[v53], v58);
            ++v57;
          }
          while (v46 != v57);
        }
      }
    }
  }
  return 0;
}

uint64_t HGLightWrap::RenderPage(HGNode *this, HGRect *a2)
{
  (*(void (**)(HGNode *, _QWORD))(*(_QWORD *)this + 576))(this, 0);
  return HGNode::RenderPage(this, a2);
}

uint64_t HGLightWrap::RenderPageMetal(HGNode *this, HGPage *a2)
{
  (*(void (**)(HGNode *, _QWORD))(*(_QWORD *)this + 576))(this, 0);
  return HGNode::RenderPageMetal(this, a2);
}

const char *HGLightWrap::GetProgram(HGLightWrap *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000043c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2.w = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).w;\n"
             "    r0 = clamp(c0.xxxx - r0.wwww, 0.00000h, 1.00000h);\n"
             "    r0 = r0*r2.wwww;\n"
             "    r1 = r0*r1;\n"
             "    output.color0 = float4(r1)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=75ca94e5:4c8b94c4:97725edc:ddf254f3\n"
             "//SIG=00400000:00000007:00000007:00000007:0001:0001:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000424\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2.w = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).w;\n"
             "    r0 = clamp(c0.xxxx - r0.wwww, 0.00000f, 1.00000f);\n"
             "    r0 = r0*r2.wwww;\n"
             "    r0 = r0*r1;\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=c8c5dd81:110d3923:ff429a4b:4018d85f\n"
             "//SIG=00000000:00000007:00000007:00000000:0001:0001:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003b9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture0, hg_TexCoord0.xy).w;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2.w = texture2D(hg_Texture2, hg_TexCoord2.xy).w;\n"
           "    r0 = clamp(c0.xxxx - r0.wwww, vec4(0.00000), vec4(1.00000));\n"
           "    r0 = r0*r2.wwww;\n"
           "    r0 = r0*r1;\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=1b8aa5b8:6e01dc15:8dfa7c9e:d9ed25f9\n"
           "//SIG=00000000:00000007:00000007:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HGLightWrap::InitProgramDescriptor(HGLightWrap *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "LightWrap_hgc_visible", "//Metal1.0     \n//LEN=0000000201\n[[ visible ]] FragmentOut LightWrap_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color0.w;\n"
    "    r1 = color1;\n"
    "    r2.w = color2.w;\n"
    "    r0 = clamp(c0.xxxx - r0.wwww, 0.00000f, 1.00000f);\n"
    "    r0 = r0*r2.wwww;\n"
    "    r0 = r0*r1;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B84FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  void **v23;
  void **v24;

  if (a18 < 0)
    operator delete(__p);
  if (a21)
  {
    v23 = a22;
    v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0)
          operator delete(*(v23 - 5));
        v23 -= 6;
      }
      while (v23 != a21);
      v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

void HGStencil::HGStencil(HGStencil *this)
{
  uint64_t v2;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E65350B0;
  *(_QWORD *)(v2 + 408) = 0;
  *(_QWORD *)(v2 + 416) = 0;
  *(_QWORD *)(v2 + 424) = 0;
  *(_QWORD *)(v2 + 432) = 1065353216;
  HGNode::SetFlags((HGNode *)v2, 0xFFFFFFFFLL, 512);
  (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 1024);
  (*(void (**)(HGStencil *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 32);
  (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 32);
  (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 32);
}

void sub_1B2B85104(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 416) = v5;
    operator delete(v5);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGStencil::~HGStencil(HGNode *this)
{
  void *v2;
  char *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = off_1E65350B0;
  v3 = (char *)this + 408;
  v2 = (void *)*((_QWORD *)this + 51);
  v4 = *((_QWORD *)v3 + 1) - (_QWORD)v2;
  if ((int)(v4 >> 3) >= 1)
  {
    v5 = (v4 >> 3) + 1;
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 51) + 8 * (v5 - 2));
      if (v6)
        MEMORY[0x1B5E29170](v6, 0x1000C40E0EAB150);
      --v5;
    }
    while (v5 > 1);
    v2 = (void *)*((_QWORD *)this + 51);
  }
  if (v2)
  {
    *((_QWORD *)this + 52) = v2;
    operator delete(v2);
  }
  HGNode::~HGNode(this);
}

{
  void *v2;
  char *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_1E65350B0;
  v3 = (char *)this + 408;
  v2 = (void *)*((_QWORD *)this + 51);
  v4 = *((_QWORD *)v3 + 1) - (_QWORD)v2;
  if ((int)(v4 >> 3) >= 1)
  {
    v5 = (v4 >> 3) + 1;
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 51) + 8 * (v5 - 2));
      if (v6)
        MEMORY[0x1B5E29170](v6, 0x1000C40E0EAB150);
      --v5;
    }
    while (v5 > 1);
    v2 = (void *)*((_QWORD *)this + 51);
  }
  if (v2)
  {
    *((_QWORD *)this + 52) = v2;
    operator delete(v2);
  }
  HGNode::~HGNode(this);
  HGObject::operator delete(v7);
}

uint64_t HGStencil::SetState(HGStencil *this, HGRenderer *a2, int a3)
{
  unint64_t v4;
  uint64_t **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _BYTE *v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _OWORD *v23;
  uint64_t *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;

  if (a3 == 1)
  {
    if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
    {
      v4 = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 5);
      if (v4 <= (uint64_t)(*((_QWORD *)this + 52) - *((_QWORD *)this + 51)) >> 3)
        return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
      goto LABEL_6;
    }
    v4 = 1;
    if (!((uint64_t)(*((_QWORD *)this + 52) - *((_QWORD *)this + 51)) >> 3))
    {
LABEL_6:
      v5 = (uint64_t **)((char *)this + 408);
      while (1)
      {
        v7 = operator new();
        v8 = v7;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_OWORD *)(v7 + 16) = xmmword_1B3525EB0;
        v10 = (uint64_t *)*((_QWORD *)this + 52);
        v9 = *((_QWORD *)this + 53);
        if ((unint64_t)v10 >= v9)
          break;
        *v10 = v7;
        v6 = (uint64_t)(v10 + 1);
LABEL_8:
        *((_QWORD *)this + 52) = v6;
        if (v4 <= (v6 - *((_QWORD *)this + 51)) >> 3)
          return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
      }
      v11 = *v5;
      v12 = (char *)v10 - (char *)*v5;
      v13 = v12 >> 3;
      v14 = (v12 >> 3) + 1;
      if (v14 >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v15 = v9 - (_QWORD)v11;
      if (v15 >> 2 > v14)
        v14 = v15 >> 2;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v14;
      if (v16)
      {
        if (v16 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v17 = operator new(8 * v16);
        v18 = (uint64_t *)&v17[8 * v13];
        *v18 = v8;
        v6 = (uint64_t)(v18 + 1);
        if (v10 == v11)
          goto LABEL_28;
      }
      else
      {
        v17 = 0;
        v18 = (uint64_t *)(8 * v13);
        *(_QWORD *)(8 * v13) = v8;
        v6 = 8 * v13 + 8;
        if (v10 == v11)
        {
LABEL_28:
          *((_QWORD *)this + 51) = v18;
          *((_QWORD *)this + 52) = v6;
          *((_QWORD *)this + 53) = &v17[8 * v16];
          if (v10)
            operator delete(v10);
          goto LABEL_8;
        }
      }
      v19 = (char *)(v10 - 1) - (char *)v11;
      if (v19 < 0x58)
        goto LABEL_35;
      if ((unint64_t)((char *)v10 - &v17[v12]) < 0x20)
        goto LABEL_35;
      v20 = (v19 >> 3) + 1;
      v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      v22 = &v10[v21 / 0xFFFFFFFFFFFFFFF8];
      v18 = (uint64_t *)((char *)v18 - v21);
      v23 = &v17[8 * v13 - 16];
      v24 = v10 - 2;
      v25 = v20 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v26 = *(_OWORD *)v24;
        *(v23 - 1) = *((_OWORD *)v24 - 1);
        *v23 = v26;
        v23 -= 2;
        v24 -= 4;
        v25 -= 4;
      }
      while (v25);
      v10 = v22;
      if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        do
        {
          v27 = *--v10;
          *--v18 = v27;
        }
        while (v10 != v11);
      }
      v10 = *v5;
      goto LABEL_28;
    }
  }
  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

uint64_t HGStencil::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;
  uint64_t DOD;
  uint64_t v9;
  uint64_t v10;
  HGNode *v11;
  uint64_t v12;
  uint64_t v13;

  if (a3 >= 2)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v10 = v9;
  v11 = HGRenderer::GetInput(a2, this, 1u);
  v12 = HGRenderer::GetDOD(a2, v11);
  return HGRectIntersection(DOD, v10, v12, v13);
}

uint64_t HGStencil::GetROI(HGStencil *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 <= 1)
    return *(_QWORD *)&a4.var0;
  else
    return 0;
}

uint64_t HGStencil::SetParameter(HGStencil *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 == 1)
  {
    *((float *)this + 108) = a3;
    return 1;
  }
  else if (a2)
  {
    return 0;
  }
  else
  {
    *((_DWORD *)this + 109) = vcvtms_s32_f32(a3);
    return 1;
  }
}

uint64_t HGStencil::Bind(HGStencil *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, **((_QWORD **)this + 51), 1);
  return 0;
}

float32x4_t HGStencil::UpdateLocalParameters(HGStencil *this, int a2)
{
  const float *v2;
  float32x4_t result;

  v2 = (const float *)((char *)this + 432);
  result = vld1q_dup_f32(v2);
  *(float32x4_t *)*(_QWORD *)(*((_QWORD *)this + 51) + 8 * a2) = result;
  return result;
}

uint64_t HGStencil::RenderTile(HGStencil *this, HGTile *a2)
{
  unsigned int v4;
  uint64_t v6;
  int v7;
  int v8;
  char *v9;
  uint64_t v10;
  unsigned int v11;
  size_t v12;
  uint64_t v13;
  unsigned int v14;
  signed int v15;
  size_t v16;
  int v17;
  size_t v18;
  uint64_t v19;

  v4 = *(_DWORD *)(*((_QWORD *)a2 + 42) + 160);
  (*(void (**)(HGStencil *, _QWORD))(*(_QWORD *)this + 576))(this, v4);
  if (*((_QWORD *)a2 + 10) && *((_QWORD *)a2 + 12) && *((float *)this + 108) > 0.0)
    return ((uint64_t (*)(HGTile *, _QWORD, HGStencil *))s_func_stencil_table[*((int *)this + 109)])(a2, *(_QWORD *)(*((_QWORD *)this + 51) + 8 * (int)v4), this);
  v6 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1));
  if ((int)v6 >= 1)
  {
    v7 = *((_DWORD *)a2 + 2);
    v8 = v7 - *(_DWORD *)a2;
    v9 = (char *)*((_QWORD *)a2 + 2);
    v10 = *((int *)a2 + 6);
    v11 = v8 - 4;
    if (v8 < 4)
    {
      if (v8 >= 1)
      {
        v18 = 16 * (v7 + ~*(_DWORD *)a2) + 16;
        v19 = 16 * v10;
        do
        {
          bzero(v9, v18);
          v9 += v19;
          LODWORD(v6) = v6 - 1;
        }
        while ((_DWORD)v6);
      }
    }
    else
    {
      v12 = ((unint64_t)(v11 >> 2) << 6) + 64;
      v13 = 16 * v10;
      v14 = v11 & 0xFFFFFFFC;
      v15 = (v11 & 0xFFFFFFFC) + 5;
      if (v8 > v15)
        v15 = v8;
      v16 = 16 * (v15 - v14 - 5) + 16;
      v17 = v14 + 4;
      do
      {
        bzero(v9, v12);
        if (v8 > v17)
          bzero(&v9[v12], v16);
        v9 += v13;
        --v6;
      }
      while (v6);
    }
  }
  return 0;
}

char *HGStencil::RenderPage(HGNode *this, HGRect *a2)
{
  (*(void (**)(HGNode *, _QWORD))(*(_QWORD *)this + 576))(this, 0);
  return HGStencil::RenderPagePlain(this, a2);
}

char *HGStencil::RenderPagePlain(HGNode *this, HGRect *a2)
{
  char *Buffer;
  HGHandler *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  HGPage *v13;

  HGPagePullTexturesGuard::HGPagePullTexturesGuard((HGPagePullTexturesGuard *)&v13, this, (HGPage *)a2);
  Buffer = *(char **)&a2->var2;
  if (Buffer)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)Buffer + 16))(*(_QWORD *)&a2->var2);
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer(*(_QWORD *)&a2->var0, a2[1], a2[2].var0, 0, (*((_DWORD *)this + 4) >> 12) & 1, LOBYTE(a2[15].var2));
    *(_QWORD *)&a2->var2 = Buffer;
  }
  (*(void (**)(_QWORD, char *))(**(_QWORD **)&a2->var0 + 144))(*(_QWORD *)&a2->var0, Buffer);
  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 0, *(_QWORD *)&a2[10].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 1, *(_QWORD *)&a2[11].var0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 2, *(_QWORD *)&a2[11].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 3, *(_QWORD *)&a2[12].var0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 4, *(_QWORD *)&a2[12].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 5, *(_QWORD *)&a2[13].var0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 6, *(_QWORD *)&a2[13].var2, 0, 0);
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)&a2->var0 + 152))(*(_QWORD *)&a2->var0, 7, *(_QWORD *)&a2[14].var0, 0, 0);
  v5 = (HGHandler *)(*(uint64_t (**)(_QWORD, _QWORD, HGNode *))(**(_QWORD **)&a2->var0 + 368))(*(_QWORD *)&a2->var0, *((_QWORD *)this + 8), this);
  (*(void (**)(HGNode *, HGRect *, _QWORD, HGHandler *))(*(_QWORD *)this + 488))(this, a2, 0, v5);
  v6 = (*(uint64_t (**)(HGNode *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 400))(this, *(_QWORD *)&a2->var0, 1, *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2);
  if (HGRectIsNull(v6, v7)
    || (v10 = (*(uint64_t (**)(HGNode *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 400))(this, *(_QWORD *)&a2->var0, 0, *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2), HGRectIsNull(v10, v11)))
  {
    HGGPURenderer::Clear(*(HGGPURenderer **)&a2->var0, a2[1], v8, v9);
  }
  else
  {
    HGGPURenderer::Rect(*(HGGPURenderer **)&a2->var0, v5, a2[1], 8);
  }
  (*(void (**)(HGNode *, HGRect *, _QWORD, HGHandler *))(*(_QWORD *)this + 496))(this, a2, 0, v5);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v13);
  return Buffer;
}

void sub_1B2B859E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B2B859F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B2B85A0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

char *HGStencil::RenderPageMetal(HGNode *this, HGRect *a2)
{
  (*(void (**)(HGNode *, _QWORD))(*(_QWORD *)this + 576))(this, 0);
  return HGStencil::RenderPagePlainMetal(this, a2);
}

char *HGStencil::RenderPagePlainMetal(HGNode *this, HGRect *a2)
{
  char *Buffer;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v11;
  HGMetalHandler *v12;
  HGMetalHandler *v13;
  uint64_t i;
  uint64_t v15;
  __n128 v16;
  HGPage *v17;

  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v17, this, (HGPage *)a2);
  Buffer = *(char **)&a2->var2;
  if (Buffer)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)Buffer + 16))(*(_QWORD *)&a2->var2);
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer(*(_QWORD *)&a2->var0, a2[1], a2[2].var0, 1, (*((_DWORD *)this + 4) >> 12) & 1, LOBYTE(a2[15].var2));
    *(_QWORD *)&a2->var2 = Buffer;
  }
  v5 = (*(uint64_t (**)(HGNode *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 400))(this, *(_QWORD *)&a2->var0, 1, *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2);
  if (HGRectIsNull(v5, v6)
    || (v8 = (*(uint64_t (**)(HGNode *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 400))(this, *(_QWORD *)&a2->var0, 0, *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2), HGRectIsNull(v8, v9)))
  {
    HGGPURenderer::ClearMetal(*(HGGPURenderer **)&a2->var0, (HGBitmap *)Buffer, a2[1], v7);
  }
  else
  {
    v11 = (const void *)(*(uint64_t (**)(_QWORD, _QWORD, HGNode *))(**(_QWORD **)&a2->var0 + 368))(*(_QWORD *)&a2->var0, *((_QWORD *)this + 8), this);
    if (v11)
    {
      if (v12)
      {
        v13 = v12;
        (*(void (**)(HGNode *, HGRect *, _QWORD, HGMetalHandler *))(*(_QWORD *)this + 488))(this, a2, 0, v12);
        HGMetalHandler::BindBuffer(v13, (HGBitmap *)Buffer);
        for (i = 0; i != 8; ++i)
        {
          v15 = *((_QWORD *)&a2[10].var2 + i);
          v16 = HGMetalHandler::BindTexture((HGMetalTexture ***)v13, i, (HGBitmap *)v15);
          if (v15)
          {
            (*(void (**)(HGMetalHandler *, uint64_t, _QWORD, __n128))(*(_QWORD *)v13 + 72))(v13, i, 0, v16);
            (*(void (**)(HGMetalHandler *, _QWORD, _QWORD))(*(_QWORD *)v13 + 48))(v13, 0, 0);
            (*(void (**)(HGMetalHandler *, uint64_t))(*(_QWORD *)v13 + 80))(v13, i);
            (*(void (**)(HGMetalHandler *))(*(_QWORD *)v13 + 88))(v13);
            (*(void (**)(HGMetalHandler *, double, double, double))(*(_QWORD *)v13 + 96))(v13, (double)-*(_DWORD *)(v15 + 20), (double)-*(_DWORD *)(v15 + 24), 0.0);
            (*(void (**)(HGMetalHandler *, _QWORD))(*(_QWORD *)v13 + 56))(v13, 0);
          }
        }
        (*(void (**)(HGMetalHandler *, _QWORD, _QWORD, uint64_t, __n128))(*(_QWORD *)v13 + 192))(v13, *(_QWORD *)&a2[1].var0, *(_QWORD *)&a2[1].var2, 8, v16);
        (*(void (**)(HGNode *, HGRect *, _QWORD, HGMetalHandler *))(*(_QWORD *)this + 496))(this, a2, 0, v13);
      }
    }
  }
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v17);
  return Buffer;
}

void sub_1B2B85CA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B2B85CBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B2B85CD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

uint64_t HGStencil::GetProgram(HGStencil *this, HGRenderer *a2)
{
  return s_gpu_stencil_table[*((int *)this + 109)](a2);
}

uint64_t HGStencil::InitProgramDescriptor(HGStencil *this, HGProgramDescriptor *a2)
{
  return s_programdesc_stencil_table[*((int *)this + 109)](a2);
}

uint64_t GetStencilAlphaTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 96);
    v5 = *(float32x4_t **)(a1 + 80);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 88);
    v9 = *(int *)(a1 + 104);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v33 = 0;
        v34 = 16 * v9;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v38 = 0;
          do
          {
            v6[v38 / 0x10] = vmulq_laneq_f32(v5[v38 / 0x10], vmulq_f32(v4[v38 / 0x10], *a2), 3);
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          v4 = (float32x4_t *)((char *)v4 + v34);
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = (float32x4_t)vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 0xCuLL);
          v26 = vmulq_n_f32(v5[v17 + 1], vmulq_laneq_f32(v25, v4[v17 + 1], 3).f32[0]);
          v27 = vmulq_n_f32(v5[v17 + 2], vmulq_laneq_f32(v25, v4[v17 + 2], 3).f32[0]);
          v28 = vmulq_n_f32(v5[v17 + 3], vmulq_laneq_f32(v25, v4[v17 + 3], 3).f32[0]);
          v29 = &v6[v17];
          *v29 = vmulq_n_f32(v5[v17], vmulq_laneq_f32(v25, v4[v17], 3).f32[0]);
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v30 = *v22++;
            v31 = v30;
            v32 = *v23++;
            *v24++ = vmulq_laneq_f32(v32, vmulq_f32(v31, *a2), 3);
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetStencilLumaTile(uint64_t a1, float32x4_t *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  float32x4_t v44;

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    v4 = *(float32x4_t **)(a1 + 96);
    v5 = *(float32x4_t **)(a1 + 80);
    v6 = *(float32x4_t **)(a1 + 16);
    v7 = *(int *)(a1 + 24);
    v8 = *(int *)(a1 + 88);
    v9 = *(int *)(a1 + 104);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v38 = 0;
        v39 = 16 * v9;
        v40 = 16 * v8;
        v41 = 16 * v7;
        v42 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          v43 = 0;
          do
          {
            v44 = vmulq_f32(vmulq_f32(v4[v43 / 0x10], *a2), a2[1]);
            v6[v43 / 0x10] = vmulq_n_f32(v5[v43 / 0x10], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0]);
            v43 += 16;
          }
          while (v42 != v43);
          ++v38;
          v4 = (float32x4_t *)((char *)v4 + v39);
          v5 = (float32x4_t *)((char *)v5 + v40);
          v6 = (float32x4_t *)((char *)v6 + v41);
        }
        while (v38 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = a2[1];
          v26 = vmulq_f32(vmulq_f32(v4[v17], *a2), v25);
          v27 = vmulq_f32(vmulq_f32(v4[v17 + 1], *a2), v25);
          v28 = vmulq_f32(vmulq_f32(v4[v17 + 2], *a2), v25);
          v29 = vmulq_f32(vmulq_f32(v4[v17 + 3], *a2), v25);
          v30 = vmulq_n_f32(v5[v17 + 1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]);
          v31 = vmulq_n_f32(v5[v17 + 2], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]);
          v32 = vmulq_n_f32(v5[v17 + 3], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]);
          v33 = &v6[v17];
          *v33 = vmulq_n_f32(v5[v17], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]);
          v33[1] = v30;
          v18 += 4;
          v17 += 4;
          v33[2] = v31;
          v33[3] = v32;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v34 = *v22++;
            v35 = vmulq_f32(v34, *a2);
            v36 = *v23++;
            v37 = vmulq_f32(v35, a2[1]);
            *v24++ = vmulq_n_f32(v36, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0]);
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

const char *GetStencilAlphaProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000030c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).w;\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = r0.w*half(hg_Params[0].w);\n"
             "    output.color0 = float4(r0.xxxx)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=01f634c8:f7748912:786afaf7:eb888de8\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002ea\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).w;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = r0.w*hg_Params[0].w;\n"
             "    output.color0 = r0.xxxx*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e1ec9237:e9f18bbe:72542b57:68628fe1\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000294\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture1, hg_TexCoord1.xy).w;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.x = r0.w*hg_ProgramLocal0.w;\n"
           "    gl_FragColor = r0.xxxx*r1;\n"
           "}\n"
           "//MD5=b08281d5:65ec7cc3:7ffdfd68:7096132c\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetStencilLumaProgram(HGRenderer *a1)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000038b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = dot(r0.xyz, c0.xyz);\n"
             "    output.color0 = float4(r0.xxxx)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cb176b52:a0693719:b9ea283b:0759c643\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.x = dot(r0.xyz, c0.xyz);\n"
             "    output.color0 = r0.xxxx*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d4787518:3c8759ce:80b33876:1f8c5248\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a1 + 128))(a1, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000318\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.x = dot(r0.xyz, c0.xyz);\n"
           "    gl_FragColor = r0.xxxx*r1;\n"
           "}\n"
           "//MD5=23b25b93:d546e82f:8b4aad79:2f25e687\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void InitStencilAlphaProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "StencilAlpha_hgc_visible", "//Metal1.0     \n//LEN=0000000145\n[[ visible ]] FragmentOut StencilAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color1.w;\n"
    "    r1 = color0;\n"
    "    r0.x = r0.w*hg_Params[0].w;\n"
    "    output.color0 = r0.xxxx*r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B864C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B864F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B864F0);
}

void InitStencilLumaProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "StencilLuma_hgc_visible", "//Metal1.0     \n//LEN=00000001c3\n[[ visible ]] FragmentOut StencilLuma_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.3000000119, 0.5899999738, 0.1099999994, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = color1.xyz;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz;\n"
    "    r1 = color0;\n"
    "    r0.x = dot(r0.xyz, c0.xyz);\n"
    "    output.color0 = r0.xxxx*r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B86798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B867CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B867C4);
}

const char *HgcSMAAEdgeDetect::GetProgram(HgcSMAAEdgeDetect *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r2.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).x;\n"
             "    r2.y = r0.x;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy).x;\n"
             "    r3.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord4.xy).x;\n"
             "    r2.z = r0.x;\n"
             "    r2.w = r3.x;\n"
             "    r1 = r1.xxxx - r2;\n"
             "    r1 = abs(r1);\n"
             "    r4.xy = half2(half2(hg_Params[0].xy) < r1.xy);\n"
             "    r5.xy = fmax(r1.xy, r1.zw);\n"
             "    r5.xy = fmax(r5.xx, r5.yy);\n"
             "    r6.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord5.xy).x;\n"
             "    r7.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord6.xy).x;\n"
             "    r2.z = r6.x;\n"
             "    r2.w = r7.x;\n"
             "    r2.xy = r2.xy - r2.zw;\n"
             "    r5.xy = fmax(r5.xy, fabs(r2.xy));\n"
             "    r5.xy = r5.xy*c0.xx;\n"
             "    r5.xy = half2(r5.xy < r1.xy);\n"
             "    output.color0.xy = fmin(float2(r4.xy), float2(r5.xy));\n"
             "    output.color0.zw = float2(c0.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f63bcefb:e47eb4ef:de86d16a:09e989d0\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0001:0008:0000:0000:0000:00fe:0000:0007:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r2.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).x;\n"
             "    r2.y = r0.x;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy).x;\n"
             "    r3.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord4.xy).x;\n"
             "    r2.z = r0.x;\n"
             "    r2.w = r3.x;\n"
             "    r1 = r1.xxxx - r2;\n"
             "    r1 = abs(r1);\n"
             "    r0.xy = float2(hg_Params[0].xy < r1.xy);\n"
             "    r3.xy = fmax(r1.xy, r1.zw);\n"
             "    r3.xy = fmax(r3.xx, r3.yy);\n"
             "    r4.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord5.xy).x;\n"
             "    r5.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord6.xy).x;\n"
             "    r2.z = r4.x;\n"
             "    r2.w = r5.x;\n"
             "    r2.xy = r2.xy - r2.zw;\n"
             "    r3.xy = fmax(r3.xy, fabs(r2.xy));\n"
             "    r3.xy = r3.xy*c0.xx;\n"
             "    r3.xy = float2(r3.xy < r1.xy);\n"
             "    output.color0.xy = fmin(r0.xy, r3.xy);\n"
             "    output.color0.zw = c0.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9b909250:9a031bd2:3464edfe:3dce087f\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0001:0006:0000:0000:0000:00fe:0000:0007:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000604\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r2.x = texture2D(hg_Texture0, hg_TexCoord2.xy).x;\n"
           "    r2.y = r0.x;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord3.xy).x;\n"
           "    r3.x = texture2D(hg_Texture0, hg_TexCoord4.xy).x;\n"
           "    r2.z = r0.x;\n"
           "    r2.w = r3.x;\n"
           "    r1 = r1.xxxx - r2;\n"
           "    r1 = abs(r1);\n"
           "    r0.xy = vec2(lessThan(hg_ProgramLocal0.xy, r1.xy));\n"
           "    r3.xy = max(r1.xy, r1.zw);\n"
           "    r3.xy = max(r3.xx, r3.yy);\n"
           "    r4.x = texture2D(hg_Texture0, hg_TexCoord5.xy).x;\n"
           "    r5.x = texture2D(hg_Texture0, hg_TexCoord6.xy).x;\n"
           "    r2.z = r4.x;\n"
           "    r2.w = r5.x;\n"
           "    r2.xy = r2.xy - r2.zw;\n"
           "    r3.xy = max(r3.xy, abs(r2.xy));\n"
           "    r3.xy = r3.xy*c0.xx;\n"
           "    r3.xy = vec2(lessThan(r3.xy, r1.xy));\n"
           "    gl_FragColor.xy = min(r0.xy, r3.xy);\n"
           "    gl_FragColor.zw = c0.yz;\n"
           "}\n"
           "//MD5=10405cea:bdc87dfa:dc2a500e:aab26e6b\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0001:0006:0000:0000:0000:0000:0000:0007:01:0:1:0\n";
  }
}

void HgcSMAAEdgeDetect::InitProgramDescriptor(HgcSMAAEdgeDetect *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSMAAEdgeDetect_hgc_visible", "//Metal1.0     \n//LEN=000000054f\n[[ visible ]] FragmentOut HgcSMAAEdgeDetect_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2,\n    float4 texCoord3,\n    float4 texCoord4,\n    float4 texCoord5,\n    float4 texCoord6)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).x;\n"
    "    r2.x = hg_Texture0.sample(hg_Sampler0, texCoord2.xy).x;\n"
    "    r2.y = r0.x;\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, texCoord3.xy).x;\n"
    "    r3.x = hg_Texture0.sample(hg_Sampler0, texCoord4.xy).x;\n"
    "    r2.z = r0.x;\n"
    "    r2.w = r3.x;\n"
    "    r1 = r1.xxxx - r2;\n"
    "    r1 = abs(r1);\n"
    "    r0.xy = float2(hg_Params[0].xy < r1.xy);\n"
    "    r3.xy = fmax(r1.xy, r1.zw);\n"
    "    r3.xy = fmax(r3.xx, r3.yy);\n"
    "    r4.x = hg_Texture0.sample(hg_Sampler0, texCoord5.xy).x;\n"
    "    r5.x = hg_Texture0.sample(hg_Sampler0, texCoord6.xy).x;\n"
    "    r2.z = r4.x;\n"
    "    r2.w = r5.x;\n"
    "    r2.xy = r2.xy - r2.zw;\n"
    "    r3.xy = fmax(r3.xy, fabs(r2.xy));\n"
    "    r3.xy = r3.xy*c0.xx;\n"
    "    r3.xy = float2(r3.xy < r1.xy);\n"
    "    output.color0.xy = fmin(r0.xy, r3.xy);\n"
    "    output.color0.zw = c0.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B86F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B86F94(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B86F8CLL);
}

char *HgcSMAAEdgeDetect::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EE0;
  strcpy(result, "HgcSMAAEdgeDetect [hgc1]");
  return result;
}

uint64_t HgcSMAAEdgeDetect::BindTexture(HgcSMAAEdgeDetect *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.0, -1.0, 0.0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -1.0, 0.0, 0.0);
  HGHandler::TexCoord(a2, 3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 1.0, 0.0, 0.0);
  HGHandler::TexCoord(a2, 4, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.0, 1.0, 0.0);
  HGHandler::TexCoord(a2, 5, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -2.0, 0.0, 0.0);
  HGHandler::TexCoord(a2, 6, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.0, -2.0, 0.0);
  return 0;
}

uint64_t HgcSMAAEdgeDetect::Bind(HgcSMAAEdgeDetect *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcSMAAEdgeDetect *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcSMAAEdgeDetect::RenderTile(HgcSMAAEdgeDetect *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int i;
  uint64_t v15;
  int8x16_t v16;
  int8x8_t v17;
  __int128 v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  int32x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x2_t v44;
  float32x4_t v45;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 2);
    v7 = 16 * v5;
    v8 = *((_QWORD *)a2 + 10);
    v9 = v8 + 16 * v5;
    v10 = -2 * v5;
    v11 = 16 * *((int *)a2 + 6);
    while (v4 < 2)
    {
      LODWORD(v13) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v7;
      v6 += v11;
      ++v3;
      v9 += v7;
      if (v3 == v2)
        return 0;
    }
    v12 = 0;
    v13 = 0;
    for (i = v4; i > 1; i -= 2)
    {
      v15 = *((_QWORD *)this + 51);
      v16 = *(int8x16_t *)(v15 + 16);
      v17 = (int8x8_t)vmvnq_s8(v16).u64[0];
      v18 = *(_OWORD *)(v8 + v12);
      *(int8x8_t *)v19.i8 = vorr_s8(vand_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)(v8 + 16 * v13 - 16)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v8 + 16 * ((int)v13 - (int)v5))), v17));
      *(int8x8_t *)v20.i8 = vorr_s8(vand_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)&v18), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v8 + 16 * ((int)v13 - (int)v5 + 1))), v17));
      v19.i64[1] = *(_QWORD *)(v8 + v12 + 16);
      v20.i64[1] = *(_QWORD *)(v8 + v12 + 32);
      v21 = *(int8x16_t *)(v15 + 32);
      v22 = *(int8x16_t *)(v15 + 48);
      v23 = (float32x4_t)vbslq_s8(v21, vextq_s8(*(int8x16_t *)(v9 + v12), *(int8x16_t *)(v9 + v12), 4uLL), v19);
      v24 = (float32x4_t)vbslq_s8(v21, vextq_s8(*(int8x16_t *)(v9 + v12 + 16), *(int8x16_t *)(v9 + v12 + 16), 4uLL), v20);
      v25 = vabdq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0), v23);
      v26 = vabdq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(v8 + v12 + 16), 0), v24);
      v27 = (int32x2_t)vmaxq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL)).u64[0];
      v28 = (int32x2_t)vmaxq_f32(v26, (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL)).u64[0];
      v23.i64[1] = *(_QWORD *)(v8 + v12 - 32);
      v29 = *(int8x16_t *)(v8 + 16 * (v10 + (int)v13));
      v30 = (float32x4_t)vbslq_s8(v21, vextq_s8(v29, v29, 4uLL), (int8x16_t)v23);
      v24.i64[1] = *(_QWORD *)(v8 + 16 * v13 - 16);
      v31 = (float32x4_t)vbslq_s8(v21, vextq_s8(*(int8x16_t *)(v8 + 16 * (v10 + (int)v13 + 1)), *(int8x16_t *)(v8 + 16 * (v10 + (int)v13 + 1)), 4uLL), (int8x16_t)v24);
      v32 = *(float32x4_t *)(v15 + 64);
      v33 = *(int8x16_t *)(v15 + 80);
      v34 = vbslq_s8(v33, (int8x16_t)vminq_f32((float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v25, *(float32x4_t *)v15)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v25, vmulq_f32(vmaxq_f32(vmaxq_f32((float32x4_t)vdupq_lane_s32(v27, 0), (float32x4_t)vdupq_lane_s32(v27, 1)), vabdq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL))), v32)))), (int8x16_t)v32);
      v35 = vbslq_s8(v33, (int8x16_t)vminq_f32((float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v26, *(float32x4_t *)v15)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v26, vmulq_f32(vmaxq_f32(vmaxq_f32((float32x4_t)vdupq_lane_s32(v28, 0), (float32x4_t)vdupq_lane_s32(v28, 1)), vabdq_f32(v31, (float32x4_t)vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL))), v32)))), (int8x16_t)v32);
      v13 += 2;
      v36 = (int8x16_t *)(v6 + v12);
      *v36 = v34;
      v36[1] = v35;
      v12 += 32;
    }
    if ((int)v13 >= v4)
      goto LABEL_3;
LABEL_10:
    v37 = 16 * v13;
    v38 = v8 + 16 * (int)v13;
    v39 = *((_QWORD *)this + 51);
    *(int8x8_t *)v40.i8 = vbsl_s8(*(int8x8_t *)(v39 + 16), *(int8x8_t *)(v38 - 16), (int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v8 + 16 * ((int)v13 - (int)v5))));
    v40.i64[1] = *(_QWORD *)(v8 + 16 * (v13 | 1));
    v41 = *(int8x16_t *)(v39 + 32);
    v42 = (float32x4_t)vbslq_s8(v41, vextq_s8(*(int8x16_t *)(v8 + 16 * ((int)v13 + (int)v5)), *(int8x16_t *)(v8 + 16 * ((int)v13 + (int)v5)), 4uLL), v40);
    v43 = vabdq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(v8 + v37), 0), v42);
    v44 = (int32x2_t)vmaxq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)).u64[0];
    v42.i64[1] = *(_QWORD *)(v38 - 32);
    v45 = (float32x4_t)vbslq_s8(v41, vextq_s8(*(int8x16_t *)(v8 + 16 * ((int)v13 - 2 * (int)v5)), *(int8x16_t *)(v8 + 16 * ((int)v13 - 2 * (int)v5)), 4uLL), (int8x16_t)v42);
    *(int8x16_t *)(v6 + v37) = vbslq_s8(*(int8x16_t *)(v39 + 80), (int8x16_t)vminq_f32((float32x4_t)vandq_s8(*(int8x16_t *)(v39 + 48), (int8x16_t)vcgtq_f32(v43, *(float32x4_t *)v39)), (float32x4_t)vandq_s8(*(int8x16_t *)(v39 + 48), (int8x16_t)vcgtq_f32(v43, vmulq_f32(vmaxq_f32(vmaxq_f32((float32x4_t)vdupq_lane_s32(v44, 0), (float32x4_t)vdupq_lane_s32(v44, 1)), vabdq_f32(v45, (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45,
                                                                                               8uLL))),
                                                                            *(float32x4_t *)(v39 + 64))))),
                                 *(int8x16_t *)(v39 + 64));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcSMAAEdgeDetect::GetDOD(HgcSMAAEdgeDetect *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HgcSMAAEdgeDetect::GetROI(HgcSMAAEdgeDetect *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

void HgcSMAAEdgeDetect::~HgcSMAAEdgeDetect(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6535350;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6535350;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcSMAAEdgeDetect::SetParameter(HgcSMAAEdgeDetect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcSMAAEdgeDetect::GetParameter(HgcSMAAEdgeDetect *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcSMAAPatternSearch::GetProgram(HgcSMAAPatternSearch *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_923;
    else
      return aMetal10Len0000_924;
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_362;
  }
}

void HgcSMAAPatternSearch::InitProgramDescriptor(HgcSMAAPatternSearch *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSMAAPatternSearch_hgc_visible", aMetal10Len0000_928);
}

void sub_1B2B88040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a20 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a23);
  _Unwind_Resume(a1);
}

void sub_1B2B88098(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B88090);
}

double HgcSMAAPatternSearch::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EF0;
  strcpy(v3, "HgcSMAAPatternSearch [hgc1]");
  return *(double *)"ernSearch [hgc1]";
}

uint64_t HgcSMAAPatternSearch::BindTexture(HgcSMAAPatternSearch *this, HGHandler *a2, int a3)
{
  __n128 v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;

  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
    }
    v8.n128_f32[0] = (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47));
    v9.n128_f32[0] = (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48));
    v10.n128_u32[0] = 0;
    v11.n128_u32[0] = 0;
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 2, v8, v9, v10, v11);
    return 0;
  }
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
    }
    v12.n128_f32[0] = (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47));
    v13.n128_f32[0] = (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48));
    v14.n128_u32[0] = 0;
    v15.n128_u32[0] = 0;
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 1, v12, v13, v14, v15);
    return 0;
  }
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v6.n128_u32[0] = 1.0;
    v7.n128_u32[0] = 1.0;
  }
  else
  {
    v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v4.n128_f32[0] = (float)*((int *)a2 + 60);
  v5.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v4, v5, v6, v7);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 4, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -4.0, 4.0, 0.0);
  HGHandler::TexCoord(a2, 3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -3.0, 3.0, 0.0);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.125, 1.25, 0.0);
  return 0;
}

uint64_t HgcSMAAPatternSearch::Bind(HgcSMAAPatternSearch *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HgcSMAAPatternSearch *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcSMAAPatternSearch::RenderTile(HgcSMAAPatternSearch *this, int32x2_t *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  uint64_t v8;
  int8x16_t v9;
  uint64_t v10;
  int32x2_t v11;
  uint64_t v12;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float32x4_t v26;
  float32x4_t v27;
  uint64_t v28;
  float32x4_t v29;
  int32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int32x2_t v35;
  int8x16_t v36;
  int8x8_t v37;
  uint64_t v38;
  int32x2_t v39;
  uint64_t v40;
  float32x4_t v41;
  int32x4_t v42;
  float32x2_t v43;
  float32x4_t *v44;
  float32x4_t v45;
  uint64_t v46;
  int8x16_t v47;
  float32x4_t v48;
  int32x4_t v49;
  float32x4_t *v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  int32x4_t v54;
  float32x4_t *v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x2_t v60;
  float32x4_t *v61;
  float32x4_t v62;
  int8x16_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x2_t v66;
  float32x4_t *v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int32x4_t v71;
  float32x2_t v72;
  float32x4_t *v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int32x4_t v77;
  float32x4_t v78;
  int32x4_t v79;
  float32x4_t v80;
  int32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  int8x16_t v92;
  float32x4_t v93;
  int32x2_t v94;
  int8x16_t v95;
  int8x16_t v96;
  int32x2_t v97;
  int8x16_t v98;
  int8x16_t v99;
  int8x16_t v100;
  int8x16_t v101;
  int8x16_t v102;
  int8x16_t v103;
  int8x16_t v104;
  int8x16_t v105;
  int8x16_t v106;
  int8x16_t v107;
  int32x2_t v108;
  __int32 v109;
  int8x16_t v110;
  float32x4_t v111;
  int32x4_t v112;
  float32x2_t v113;
  float32x4_t *v114;
  float32x4_t v115;
  uint64_t v116;
  float32x4_t v117;
  int32x4_t v118;
  float32x4_t *v119;
  float32x4_t v120;
  float32x4_t v121;
  int32x4_t v122;
  float32x4_t *v123;
  float32x4_t v124;
  int8x16_t v125;
  float32x4_t v126;
  int32x4_t v127;
  float32x4_t v128;
  int32x4_t v129;
  float32x4_t v130;
  int32x4_t v131;
  int8x16_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  int8x16_t v137;
  float32x4_t v138;
  int32x4_t v139;
  int8x16_t v140;
  int8x16_t v141;
  int8x16_t v142;
  int8x16_t v143;
  float32x4_t v144;
  int32x4_t v145;
  int8x16_t v146;
  int8x16_t v147;
  int8x16_t v148;
  float32x4_t v149;
  int32x4_t v150;
  int8x16_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  int8x16_t v155;
  float32x4_t v156;
  int8x16_t v157;
  int8x16_t v158;
  int8x16_t v159;
  float32x4_t v160;
  int32x4_t v161;
  float32x4_t v162;
  int32x4_t v163;
  int8x16_t v164;
  float32x4_t v165;
  float32x4_t v166;
  int32x4_t v167;
  int8x16_t v168;
  float32x4_t v169;
  int32x4_t v170;
  int8x16_t v171;
  int8x16_t v172;
  int8x16_t v173;
  int8x16_t v174;
  int8x16_t v175;
  int32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  int8x16_t v179;
  float32x4_t v180;
  int8x16_t v181;
  int8x16_t v182;
  int8x16_t v183;
  float32x4_t v184;
  int32x4_t v185;
  int8x16_t v186;
  float32x4_t v187;
  int32x4_t v188;
  int8x16_t v189;
  int8x16_t v190;
  float32x4_t v191;
  int32x4_t v192;
  int8x16_t v193;
  float32x4_t v194;
  float32x4_t v195;
  int8x16_t v196;
  int8x16_t v197;
  int8x16_t v198;
  float32x4_t v199;
  float32x4_t v200;
  int32x4_t v201;
  __int32 v202;
  __int32 v203;
  float32x4_t v204;
  int32x4_t v205;
  int8x16_t v206;
  int v207;
  __int32 v208;
  __int32 v209;
  float32x4_t v210;
  int8x16_t v211;
  __int128 v212;
  unsigned int v213;
  float32x4_t v214;
  int32x2_t v215;
  int32x4_t v216;
  float32x4_t v217;
  int32x4_t v218;
  float32x2_t v219;
  float32x4_t *v220;
  float32x4_t v221;
  int8x16_t v222;
  float32x4_t v223;
  int8x16_t v224;
  float32x4_t v225;
  int32x4_t v226;
  float32x4_t *v227;
  float32x4_t v228;
  int8x16_t v229;
  int8x16_t v230;
  float32x4_t v231;
  int32x4_t v232;
  float32x2_t v233;
  float32x4_t *v234;
  float32x4_t v235;
  int8x16_t v236;
  int8x16_t v237;
  float32x4_t v238;
  int32x4_t v239;
  float32x2_t v240;
  float32x4_t *v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  int32x4_t v245;
  float32x4_t v246;
  int32x4_t v247;
  float32x4_t v248;
  int32x4_t v249;
  float32x4_t v250;
  int32x4_t v251;
  int32x2_t v252;
  int8x16_t v253;
  int8x16_t v254;
  int8x16_t v255;
  int32x2_t v256;
  int8x16_t v257;
  int8x16_t v258;
  int8x16_t v259;
  int8x16_t v260;
  int8x16_t v261;
  int8x16_t v262;
  int8x16_t v263;
  int8x16_t v264;
  int32x2_t v265;
  int8x16_t v266;
  int8x16_t v267;
  float32x4_t v268;
  int8x16_t v269;
  float32x4_t v270;
  int32x4_t v271;
  float32x2_t v272;
  float32x4_t *v273;
  float32x4_t v274;
  int32x4_t v275;
  float32x4_t v276;
  int32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  int8x16_t v281;
  float32x4_t v282;
  int32x4_t v283;
  float32x2_t v284;
  float32x4_t *v285;
  float32x4_t v286;
  uint64_t v287;
  int8x16_t v288;
  float32x4_t v289;
  int32x4_t v290;
  float32x4_t *v291;
  float32x4_t v292;
  int8x16_t v293;
  float32x4_t v294;
  int32x4_t v295;
  float32x4_t v296;
  int32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  int32x4_t v300;
  float32x2_t v301;
  float32x4_t *v302;
  float32x4_t v303;
  int8x16_t v304;
  int8x16_t v305;
  float32x4_t v306;
  int32x4_t v307;
  float32x4_t *v308;
  float32x4_t v309;
  int8x16_t v310;
  int8x16_t v311;
  float32x4_t v312;
  int32x4_t v313;
  float32x2_t v314;
  float32x4_t *v315;
  float32x4_t v316;
  int8x16_t v317;
  int8x16_t v318;
  float32x4_t v319;
  int32x4_t v320;
  float32x2_t v321;
  float32x4_t *v322;
  float32x4_t v323;
  float32x4_t v324;
  float32x4_t v325;
  int32x4_t v326;
  float32x4_t v327;
  int32x4_t v328;
  float32x4_t v329;
  int32x4_t v330;
  float32x4_t v331;
  int32x4_t v332;
  int32x2_t v333;
  int8x16_t v334;
  int8x16_t v335;
  int8x16_t v336;
  int32x2_t v337;
  int8x16_t v338;
  int8x16_t v339;
  int8x16_t v340;
  int8x16_t v341;
  int8x16_t v342;
  int32x2_t v343;
  int8x16_t v344;
  int8x16_t v345;
  int8x16_t v346;
  int8x16_t v347;
  int8x16_t v348;
  float32x4_t v349;
  float32x4_t v350;
  int32x4_t v351;
  float32x2_t v352;
  float32x4_t *v353;
  float32x4_t v354;
  uint64_t v355;
  int8x16_t v356;
  float32x4_t v357;
  int32x4_t v358;
  float32x4_t *v359;
  float32x4_t v360;
  int8x16_t v361;
  float32x4_t v362;
  int32x4_t v363;
  float32x4_t *v364;
  float32x4_t v365;
  int8x16_t v366;
  int8x16_t v367;
  int8x16_t v368;
  float32x4_t v369;
  int32x4_t v370;
  float32x4_t *v371;
  float32x4_t v372;
  int8x16_t v373;
  int8x16_t v374;
  float32x4_t v375;
  int32x4_t v376;
  float32x2_t v377;
  float32x4_t *v378;
  float32x4_t v379;
  int8x16_t v380;
  int8x16_t v381;
  float32x4_t v382;
  int32x4_t v383;
  float32x2_t v384;
  float32x4_t *v385;
  float32x4_t v386;
  int8x16_t v387;
  int8x16_t v388;
  float32x4_t v389;
  float32x4_t v390;
  int32x4_t v391;
  float32x2_t v392;
  float32x4_t *v393;
  float32x4_t v394;
  float32x4_t v395;
  float32x4_t v396;
  int32x4_t v397;
  float32x4_t v398;
  int32x4_t v399;
  float32x4_t v400;
  int32x4_t v401;
  float32x4_t v402;
  int32x4_t v403;
  float32x4_t v404;
  int32x4_t v405;
  float32x4_t v406;
  int32x4_t v407;
  float32x4_t v408;
  int32x4_t v409;
  int32x2_t v410;
  int8x16_t v411;
  int32x2_t v412;
  int8x16_t v413;
  int8x16_t v414;
  int8x16_t v415;
  int8x16_t v416;
  int8x16_t v417;
  int8x16_t v418;
  int8x16_t v419;
  int32x2_t v420;
  int8x16_t v421;
  int32x2_t v422;
  int8x16_t v423;
  int8x16_t v424;
  int8x16_t v425;
  int8x16_t v426;
  float32x4_t v427;
  int32x4_t v428;
  float32x2_t v429;
  float32x4_t *v430;
  float32x4_t v431;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  float32x4_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  int32x2_t v441;
  int32x2_t v442;
  int8x16_t v443;
  __int128 v444;
  int8x16_t v445;
  int8x16_t v446;
  float32x4_t v447;
  int32x4_t v448;
  float32x4_t v449;
  float32x4_t v450;
  float32x4_t v451;
  int8x16_t v452;
  __int128 v453;
  int8x16_t v454;
  float32x2_t v455;
  float32x2_t v456;
  float32x4_t v457;
  __int128 v458;
  __int128 v459;
  float32x2_t v460;
  float32x2_t v461;

  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HgcSMAAPatternSearch *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *a2;
  v436 = (a2[1].i32[1] - HIDWORD(*(unint64_t *)a2));
  if ((int)v436 >= 1)
  {
    v7 = a2[1].i32[0] - v6.i32[0];
    if (v7 >= 1)
    {
      v8 = 0;
      *(float32x2_t *)v9.i8 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      v10 = a2[11].i32[0];
      v11 = a2[10];
      v12 = (v10 << 34) + 0x500000000;
      v435 = v10 << 32;
      __asm { FMOV            V1.2S, #-1.0 }
      v456 = vcvt_f32_s32(vsub_s32(a2[29], a2[28]));
      v455 = vadd_f32(v456, _D1);
      v461 = vcvt_f32_s32(vsub_s32(a2[31], a2[30]));
      v460 = vadd_f32(v461, _D1);
      v442 = a2[2];
      v434 = 16 * a2[3].i32[0];
      v18 = *(_QWORD *)&v11 - 16 * v10;
      v433 = 16 * v10;
      v19 = *(_QWORD *)&v11 + 16 * v10;
      v440 = 16 * v7;
      v20 = *(_QWORD *)&v11 - 32 * v10;
      v21 = *(_QWORD *)&v11 + 32 * v10;
      v22 = *(_QWORD *)&v11 - 48 * (int)v10;
      v23 = *(_QWORD *)&v11 + 48 * (int)v10;
      v24 = *(_QWORD *)&v11 + (v10 << 6);
      v25 = *(_QWORD *)&v11 - (v10 << 6);
      v26.i64[0] = 0x3F0000003F000000;
      v26.i64[1] = 0x3F0000003F000000;
      v441 = v11;
      v27 = (float32x4_t)v9;
      do
      {
        v28 = 0;
        v438 = v12;
        v439 = v8 + 1;
        v437 = v27;
        do
        {
          v38 = *((_QWORD *)this + 51);
          v39 = a2[10];
          v40 = a2[11].i32[0];
          v41 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 448)), (float32x4_t)v9);
          if (v5)
          {
            v42 = vaddq_s32(vcvtq_s32_f32(v41), vcltzq_f32(v41));
            v43 = (float32x2_t)vsubq_f32(v41, vcvtq_f32_s32(v42)).u64[0];
            v44 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v42.i32[0] + v42.i32[1] * (int)v40));
            v45 = vaddq_f32(*v44, vmulq_n_f32(vsubq_f32(v44[1], *v44), v43.f32[0]));
            v46 = (int)v40 + 1;
            v47 = (int8x16_t)vaddq_f32(v45, vmulq_lane_f32(vsubq_f32(vaddq_f32(v44[v40], vmulq_n_f32(vsubq_f32(v44[v46], v44[v40]), v43.f32[0])), v45), v43, 1));
            v48 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 464)), (float32x4_t)v9);
            v49 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
            v48.i64[0] = vsubq_f32(v48, vcvtq_f32_s32(v49)).u64[0];
            v50 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v49.i32[0] + v49.i32[1] * (int)v40));
            v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v48.f32[0]));
            v52 = (int8x16_t)vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v40], vmulq_n_f32(vsubq_f32(v50[v46], v50[v40]), v48.f32[0])), v51), *(float32x2_t *)v48.f32, 1));
            v53 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 528)), (float32x4_t)v9);
            v54 = vaddq_s32(vcvtq_s32_f32(v53), vcltzq_f32(v53));
            v53.i64[0] = vsubq_f32(v53, vcvtq_f32_s32(v54)).u64[0];
            v55 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v54.i32[0] + v54.i32[1] * (int)v40));
            v56 = vaddq_f32(*v55, vmulq_n_f32(vsubq_f32(v55[1], *v55), v53.f32[0]));
            v57 = (int8x16_t)vaddq_f32(v56, vmulq_lane_f32(vsubq_f32(vaddq_f32(v55[v40], vmulq_n_f32(vsubq_f32(v55[v46], v55[v40]), v53.f32[0])), v56), *(float32x2_t *)v53.f32, 1));
            v58 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 560)), (float32x4_t)v9);
            v59 = vaddq_s32(vcvtq_s32_f32(v58), vcltzq_f32(v58));
            v60 = (float32x2_t)vsubq_f32(v58, vcvtq_f32_s32(v59)).u64[0];
            v61 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v59.i32[0] + v59.i32[1] * (int)v40));
            v62 = vaddq_f32(*v61, vmulq_n_f32(vsubq_f32(v61[1], *v61), v60.f32[0]));
            v63 = (int8x16_t)vaddq_f32(v62, vmulq_lane_f32(vsubq_f32(vaddq_f32(v61[v40], vmulq_n_f32(vsubq_f32(v61[(int)v40 + 1], v61[v40]), v60.f32[0])), v62), v60, 1));
            v64 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 592)), (float32x4_t)v9);
            v65 = vaddq_s32(vcvtq_s32_f32(v64), vcltzq_f32(v64));
            v66 = (float32x2_t)vsubq_f32(v64, vcvtq_f32_s32(v65)).u64[0];
            v67 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v65.i32[0] + v65.i32[1] * (int)v40));
            v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v66.f32[0]));
            v69 = (int8x16_t)vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v40], vmulq_n_f32(vsubq_f32(v67[(int)v40 + 1], v67[v40]), v66.f32[0])), v68), v66, 1));
            v70 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 624)), (float32x4_t)v9);
            v71 = vaddq_s32(vcvtq_s32_f32(v70), vcltzq_f32(v70));
            v72 = (float32x2_t)vsubq_f32(v70, vcvtq_f32_s32(v71)).u64[0];
            v73 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v71.i32[0] + v71.i32[1] * (int)v40));
            v74 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v72.f32[0]));
            v75 = vaddq_f32(v74, vmulq_lane_f32(vsubq_f32(vaddq_f32(v73[v40], vmulq_n_f32(vsubq_f32(v73[(int)v40 + 1], v73[v40]), v72.f32[0])), v74), v72, 1));
          }
          else
          {
            v76 = vaddq_f32(v41, v26);
            v77 = vcvtq_s32_f32(v76);
            v76.i64[0] = vaddq_s32(v77, vcgtq_f32(vcvtq_f32_s32(v77), v76)).u64[0];
            v47 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v76.i32[0] + v76.i32[1] * (int)v40));
            v78 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 464)), (float32x4_t)v9), v26);
            v79 = vcvtq_s32_f32(v78);
            v78.i64[0] = vaddq_s32(v79, vcgtq_f32(vcvtq_f32_s32(v79), v78)).u64[0];
            v52 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v78.i32[0] + v78.i32[1] * (int)v40));
            v80 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 528)), (float32x4_t)v9), v26);
            v81 = vcvtq_s32_f32(v80);
            v80.i64[0] = vaddq_s32(v81, vcgtq_f32(vcvtq_f32_s32(v81), v80)).u64[0];
            v57 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v80.i32[0] + v80.i32[1] * (int)v40));
            v82 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 560)), (float32x4_t)v9), v26);
            v83 = vcvtq_s32_f32(v82);
            v82.i64[0] = vaddq_s32(v83, vcgtq_f32(vcvtq_f32_s32(v83), v82)).u64[0];
            v63 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v82.i32[0] + v82.i32[1] * (int)v40));
            v84 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 592)), (float32x4_t)v9), v26);
            v85 = vcvtq_s32_f32(v84);
            v84.i64[0] = vaddq_s32(v85, vcgtq_f32(vcvtq_f32_s32(v85), v84)).u64[0];
            v69 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v84.i32[0] + v84.i32[1] * (int)v40));
            v86 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 624)), (float32x4_t)v9), v26);
            v87 = vcvtq_s32_f32(v86);
            v86.i64[0] = vaddq_s32(v87, vcgtq_f32(vcvtq_f32_s32(v87), v86)).u64[0];
            v75 = *(float32x4_t *)(*(_QWORD *)&v39 + 16 * (v86.i32[0] + v86.i32[1] * (int)v40));
          }
          v88 = *(int8x16_t *)(v38 + 64);
          v90 = *(int8x16_t *)(v38 + 176);
          v89 = *(int8x16_t *)(v38 + 192);
          v91 = vmvnq_s8(v89);
          v92 = *(int8x16_t *)(v38 + 208);
          v93 = *(float32x4_t *)(v38 + 480);
          v94 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v52)), v90, v92).u64[0];
          v95 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v94, 0), (float32x4_t)vdupq_lane_s32(v94, 1)), (float32x4_t)v88);
          v96 = vbslq_s8(v95, v52, v47);
          v97 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v57)), v90, v92).u64[0];
          v98 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v97, 0), (float32x4_t)vdupq_lane_s32(v97, 1)), (float32x4_t)v88);
          v99 = vbslq_s8(v98, *(int8x16_t *)(v38 + 544), vbslq_s8(v95, *(int8x16_t *)(v38 + 512), *(int8x16_t *)(v38 + 496)));
          v100 = vbslq_s8(v98, v57, v96);
          v98.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v63)), v90, v92).u64[0];
          v101 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v98.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v98.i8, 1)), (float32x4_t)v88);
          v102 = vbslq_s8(v101, *(int8x16_t *)(v38 + 576), v99);
          v103 = vbslq_s8(v101, v63, v100);
          v101.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v69)), v90, v92).u64[0];
          v104 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.i8, 1)), (float32x4_t)v88);
          v105 = vbslq_s8(v104, *(int8x16_t *)(v38 + 608), v102);
          v103.i64[0] = vbslq_s8(v104, v69, v103).u64[0];
          v104.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, v75)), v90, v92).u64[0];
          v106 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104.i8, 1)), (float32x4_t)v88);
          v107 = vbslq_s8(v106, *(int8x16_t *)(v38 + 640), v105);
          v108 = a2[14];
          v458 = *(_OWORD *)(v38 + 672);
          v459 = *(_OWORD *)(v38 + 656);
          *(int32x2_t *)v103.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v461, vmul_f32(*(float32x2_t *)&v458, vmul_f32(*(float32x2_t *)(v38 + 656), (float32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v106.i8, *(int8x8_t *)v75.f32), vand_s8(*(int8x8_t *)v103.i8, (int8x8_t)*(_OWORD *)&vmvnq_s8(v106)))))), 0), v460));
          v109 = a2[15].i32[0];
          v457 = *(float32x4_t *)(v38 + 688);
          v110 = vandq_s8(v89, (int8x16_t)vsubq_f32((float32x4_t)v107, vmulq_f32(*(float32x4_t *)(*(_QWORD *)&v108 + 16 * (v103.i32[0] + v103.i32[1] * v109)), v457)));
          v111 = vsubq_f32(vaddq_f32(v27, (float32x4_t)vorrq_s8(v110, vandq_s8(v107, v91))), (float32x4_t)v9);
          v446 = v110;
          if (v5)
          {
            v112 = vaddq_s32(vcvtq_s32_f32(v111), vcltzq_f32(v111));
            v113 = (float32x2_t)vsubq_f32(v111, vcvtq_f32_s32(v112)).u64[0];
            v114 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v112.i32[0] + v112.i32[1] * (int)v40));
            v115 = vaddq_f32(*v114, vmulq_n_f32(vsubq_f32(v114[1], *v114), v113.f32[0]));
            v116 = (int)v40 + 1;
            v445 = (int8x16_t)vaddq_f32(v115, vmulq_lane_f32(vsubq_f32(vaddq_f32(v114[v40], vmulq_n_f32(vsubq_f32(v114[v116], v114[v40]), v113.f32[0])), v115), v113, 1));
            v117 = vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 704)), (float32x4_t)v9);
            v118 = vaddq_s32(vcvtq_s32_f32(v117), vcltzq_f32(v117));
            v117.i64[0] = vsubq_f32(v117, vcvtq_f32_s32(v118)).u64[0];
            v119 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v118.i32[0] + v118.i32[1] * (int)v40));
            v120 = vaddq_f32(*v119, vmulq_n_f32(vsubq_f32(v119[1], *v119), v117.f32[0]));
            v454 = (int8x16_t)vaddq_f32(v120, vmulq_lane_f32(vsubq_f32(vaddq_f32(v119[v40], vmulq_n_f32(vsubq_f32(v119[v116], v119[v40]), v117.f32[0])), v120), *(float32x2_t *)v117.f32, 1));
            v121 = vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 720)), (float32x4_t)v9);
            v122 = vaddq_s32(vcvtq_s32_f32(v121), vcltzq_f32(v121));
            v121.i64[0] = vsubq_f32(v121, vcvtq_f32_s32(v122)).u64[0];
            v123 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v122.i32[0] + v122.i32[1] * (int)v40));
            v124 = vaddq_f32(*v123, vmulq_n_f32(vsubq_f32(v123[1], *v123), v121.f32[0]));
            v125 = (int8x16_t)vaddq_f32(v124, vmulq_lane_f32(vsubq_f32(vaddq_f32(v123[v40], vmulq_n_f32(vsubq_f32(v123[v116], v123[v40]), v121.f32[0])), v124), *(float32x2_t *)v121.f32, 1));
          }
          else
          {
            v126 = vaddq_f32(v111, v26);
            v127 = vcvtq_s32_f32(v126);
            v126.i64[0] = vaddq_s32(v127, vcgtq_f32(vcvtq_f32_s32(v127), v126)).u64[0];
            v445 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v126.i32[0] + v126.i32[1] * (int)v40));
            v128 = vaddq_f32(vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 704)), (float32x4_t)v9), v26);
            v129 = vcvtq_s32_f32(v128);
            v128.i64[0] = vaddq_s32(v129, vcgtq_f32(vcvtq_f32_s32(v129), v128)).u64[0];
            v454 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v128.i32[0] + v128.i32[1] * (int)v40));
            v130 = vaddq_f32(vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 720)), (float32x4_t)v9), v26);
            v131 = vcvtq_s32_f32(v130);
            v130.i64[0] = vaddq_s32(v131, vcgtq_f32(vcvtq_f32_s32(v131), v130)).u64[0];
            v125 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v130.i32[0] + v130.i32[1] * (int)v40));
          }
          v132 = *(int8x16_t *)(v24 + v28 - 64);
          v134 = *(float32x4_t *)v38;
          v133 = *(float32x4_t *)(v38 + 16);
          v135 = vmulq_f32((float32x4_t)v132, *(float32x4_t *)v38);
          v136 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v135, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v135.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 48), *(int8x16_t *)(v38 + 32));
          v137 = *(int8x16_t *)(v23 + v28 - 48);
          v138 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v137);
          v139 = (int32x4_t)vsubq_f32(vaddq_f32(v138, (float32x4_t)vrev64q_s32((int32x4_t)v138)), v133);
          v140 = *(int8x16_t *)(v38 + 96);
          v141 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v139.i8, 0)), *(int8x16_t *)(v38 + 80), v136);
          v142 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vrev64q_s32(v139)), v137, v132);
          v143 = *(int8x16_t *)(v21 + v28 - 32);
          v144 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v143);
          v145 = (int32x4_t)vsubq_f32(vaddq_f32(v144, (float32x4_t)vrev64q_s32((int32x4_t)v144)), v133);
          v146 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v145.i8, 0)), v140, v141);
          v147 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vrev64q_s32(v145)), v143, v142);
          v148 = *(int8x16_t *)(v19 + v28 - 16);
          v149 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v148);
          v150 = (int32x4_t)vsubq_f32(vaddq_f32(v149, (float32x4_t)vrev64q_s32((int32x4_t)v149)), v133);
          v453 = *(_OWORD *)(*(_QWORD *)&v11 + v28);
          v452 = (int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v453, 0), (float32x4_t)v88);
          v151 = vbslq_s8(v452, (int8x16_t)vaddq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vrev64q_s32(v150)), v148, v147), 1), v133), 0), (float32x4_t)v88), v140, v88), (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v150.i8, 0)), v88, v146)), v88);
          v152 = vmulq_f32(*(float32x4_t *)v38, *(float32x4_t *)(v25 + v28 + 64));
          v153 = vmulq_f32(*(float32x4_t *)v38, *(float32x4_t *)(v22 + v28 + 48));
          v154 = vmulq_f32(*(float32x4_t *)v38, *(float32x4_t *)(v20 + v28 + 32));
          v155 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v154, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v154.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 160), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v153,
                                                                            (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v153.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 144), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v152, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v152.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 128), *(int8x16_t *)(v38 + 112))));
          v156 = vmulq_f32(*(float32x4_t *)v38, *(float32x4_t *)(v18 + v28 + 16));
          v157 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v156, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v156.f32, 1)), v133), 0)), v88, v155);
          v158 = (int8x16_t)vaddq_f32(v27, (float32x4_t)v151);
          v159 = (int8x16_t)vaddq_f32(v27, (float32x4_t)v157);
          v160 = vaddq_f32(vsubq_f32((float32x4_t)v158, (float32x4_t)v9), v26);
          v161 = vcvtq_s32_f32(v160);
          v160.i64[0] = vaddq_s32(v161, vcgtq_f32(vcvtq_f32_s32(v161), v160)).u64[0];
          v162 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v89, (int8x16_t)vsubq_f32((float32x4_t)v158, (float32x4_t)v90), v158), (float32x4_t)v9), v26);
          v163 = vcvtq_s32_f32(v162);
          v162.i64[0] = vaddq_s32(v163, vcgtq_f32(vcvtq_f32_s32(v163), v162)).u64[0];
          v164 = (int8x16_t)vaddq_f32((float32x4_t)v90, (float32x4_t)v159);
          v165 = (float32x4_t)vbslq_s8(v89, v164, v159);
          v166 = vaddq_f32(vsubq_f32(v165, (float32x4_t)v9), v26);
          v167 = vcvtq_s32_f32(v166);
          v166.i64[0] = vaddq_s32(v167, vcgtq_f32(vcvtq_f32_s32(v167), v166)).u64[0];
          v162.i64[0] = vbslq_s8(v89, (int8x16_t)vrev64q_s32(*(int32x4_t *)(*(_QWORD *)&v39+ 16 * (v162.i32[0] + v162.i32[1] * (int)v40))), (int8x16_t)vrev64q_s32(*(int32x4_t *)(*(_QWORD *)&v39+ 16 * (v160.i32[0] + v160.i32[1] * (int)v40)))).u64[0];
          v168 = vextq_s8(v9, *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v166.i32[0] + v166.i32[1] * (int)v40)), 0xCuLL);
          v168.i64[0] = v162.i64[0];
          v169 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v89, v164, (int8x16_t)vsubq_f32(v165, (float32x4_t)v92)), (float32x4_t)v9), v26);
          v170 = vcvtq_s32_f32(v169);
          v169.i64[0] = vaddq_s32(v170, vcgtq_f32(vcvtq_f32_s32(v170), v169)).u64[0];
          v171 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v169.i32[0] + v169.i32[1] * (int)v40));
          v172 = vbslq_s8(*(int8x16_t *)(v38 + 224), vextq_s8(v171, v171, 4uLL), v168);
          v171.i64[0] = *(_QWORD *)(v38 + 240);
          v174 = *(int8x16_t *)(v38 + 256);
          v173 = *(int8x16_t *)(v38 + 272);
          v175 = *(int8x16_t *)(v38 + 288);
          v176 = vrev64q_s32((int32x4_t)v151);
          *(float32x2_t *)v172.i8 = vmul_f32(vadd_f32(vmul_f32((float32x2_t)vqtbl1_s8(v172, *(int8x8_t *)v171.i8), *(float32x2_t *)v174.i8), (float32x2_t)vqtbl1_s8(v172, *(int8x8_t *)v173.i8)), (float32x2_t)vand_s8(*(int8x8_t *)v175.i8, (int8x8_t)*(_OWORD *)&vcgtq_f32((float32x4_t)v175, (float32x4_t)vbslq_s8(v89, vextq_s8(v151, v151, 8uLL), vextq_s8(v157, v157, 4uLL)))));
          v151.i64[0] = *(_QWORD *)(v38 + 304);
          v177 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)vbslq_s8(v89, *(int8x16_t *)(v25 + v28 - 48), *(int8x16_t *)(v25 + v28 - 64)));
          *(float32x2_t *)v172.i8 = vmul_f32(*(float32x2_t *)v151.i8, *(float32x2_t *)v172.i8);
          v178 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)vbslq_s8(v89, *(int8x16_t *)(v22 + v28 - 32), *(int8x16_t *)(v22 + v28 - 48)));
          v179 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v178, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v178.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 384), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v177,
                                                                            (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v177.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 368), *(int8x16_t *)(v38 + 352)));
          v180 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)vbslq_s8(v89, *(int8x16_t *)(v20 + v28 - 16), *(int8x16_t *)(v20 + v28 - 32)));
          v181 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v180, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v180.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 400), v179);
          v182 = vbslq_s8(v89, *(int8x16_t *)(*(_QWORD *)&v441 + (v12 >> 28)), *(int8x16_t *)(v24 + v28 + 64));
          v183 = vbslq_s8(v89, *(int8x16_t *)(v23 + v28 + 64), *(int8x16_t *)(v23 + v28 + 48));
          v184 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v183);
          v185 = (int32x4_t)vsubq_f32(vaddq_f32(v184, (float32x4_t)vrev64q_s32((int32x4_t)v184)), v133);
          v186 = vbslq_s8(v89, *(int8x16_t *)(v21 + v28 + 48), *(int8x16_t *)(v21 + v28 + 32));
          v187 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v186);
          v188 = (int32x4_t)vsubq_f32(vaddq_f32(v187, (float32x4_t)vrev64q_s32((int32x4_t)v187)), v133);
          v189 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v90, (float32x4_t)vrev64q_s32(v188)), v186, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v90, (float32x4_t)vrev64q_s32(v185)), v183, v182));
          v190 = vbslq_s8(v89, *(int8x16_t *)(v19 + v28 + 32), *(int8x16_t *)(v19 + v28 + 16));
          v191 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v190);
          v192 = (int32x4_t)vsubq_f32(vaddq_f32(v191, (float32x4_t)vrev64q_s32((int32x4_t)v191)), v133);
          v190.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v90, (float32x4_t)vrev64q_s32(v192)), v190, v189).u64[0];
          *(int8x8_t *)v189.i8 = vand_s8(*(int8x8_t *)v172.i8, *(int8x8_t *)v91.i8);
          v449 = (float32x4_t)v176;
          *(int8x8_t *)v172.i8 = vand_s8(*(int8x8_t *)v89.i8, (int8x8_t)vadd_f32(*(float32x2_t *)v176.i8, *(float32x2_t *)v172.i8));
          v451 = (float32x4_t)v157;
          v193 = *(int8x16_t *)(v38 + 416);
          *(int8x8_t *)v172.i8 = vorr_s8(vand_s8((int8x8_t)vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v157.i8), (float32x2_t)vorr_s8(*(int8x8_t *)v172.i8, *(int8x8_t *)v189.i8)), *(int8x8_t *)v91.i8), *(int8x8_t *)v172.i8);
          v194 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)vbslq_s8(v89, *(int8x16_t *)(v18 + v28), *(int8x16_t *)(v18 + v28 - 16)));
          v195 = vmulq_f32(*(float32x4_t *)v38, (float32x4_t)v182);
          v196 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v194, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v194.f32, 1)), v133), 0)), v88, v181);
          v197 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(*(_QWORD *)&v11 + v28 + 16), 0), (float32x4_t)v88), (int8x16_t)vaddq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v190.i8, 1), v133), 0), (float32x4_t)v88), v175, v88), (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v192.i8, 0)), v88,
                                               vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v188.i8, 0)), v175, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v185.i8, 0)), v174, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(vaddq_f32(v195, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v195.f32, 1)), v133), 0)), *(int8x16_t *)(v38 + 432), v193))))), v88);
          v198 = (int8x16_t)vaddq_f32(v27, (float32x4_t)v196);
          v199 = (float32x4_t)vbslq_s8(v89, (int8x16_t)vsubq_f32((float32x4_t)v198, (float32x4_t)v90), v198);
          v200 = vaddq_f32(vsubq_f32(v199, (float32x4_t)v9), v26);
          v201 = vcvtq_s32_f32(v200);
          v200.i64[0] = vaddq_s32(v201, vcgtq_f32(vcvtq_f32_s32(v201), v200)).u64[0];
          v202 = v200.i32[1];
          v203 = v200.i32[0];
          v204 = vaddq_f32(vsubq_f32(vsubq_f32(v199, (float32x4_t)v140), (float32x4_t)v9), v26);
          v205 = vcvtq_s32_f32(v204);
          v206 = (int8x16_t)vaddq_f32(v27, (float32x4_t)v197);
          v207 = v203 + v202 * v40;
          v204.i64[0] = vaddq_s32(v205, vcgtq_f32(vcvtq_f32_s32(v205), v204)).u64[0];
          v208 = v204.i32[1];
          v209 = v204.i32[0];
          v210 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v89, (int8x16_t)vaddq_f32((float32x4_t)v90, (float32x4_t)v206), v206), (float32x4_t)v9), v26);
          v211 = (int8x16_t)vcvtq_s32_f32(v210);
          v210.i64[0] = vaddq_s32((int32x4_t)v211, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v211), v210)).u64[0];
          *(int8x8_t *)v211.i8 = vorr_s8(vand_s8((int8x8_t)vrev64_s32(*(int32x2_t *)(*(_QWORD *)&v39+ 16 * (v209 + v208 * (int)v40))), *(int8x8_t *)v91.i8), vand_s8((int8x8_t)vrev64_s32(*(int32x2_t *)(*(_QWORD *)&v39 + 16 * v207)), *(int8x8_t *)v89.i8));
          v211.u64[1] = (unint64_t)vqtbl1_s8(*(int8x16_t *)(*(_QWORD *)&v39+ 16 * (v210.i32[0] + v210.i32[1] * (int)v40)), (int8x8_t)*(_OWORD *)&vextq_s8(v173, v173, 8uLL));
          v212 = *(_OWORD *)(v38 + 336);
          v213 = a2[13].u32[0];
          *(float32x2_t *)v210.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v174.i8, (float32x2_t)vqtbl1_s8(v211, *(int8x8_t *)v171.i8)), (float32x2_t)vqtbl1_s8(v211, *(int8x8_t *)v173.i8));
          v211.i64[0] = *(_QWORD *)(v38 + 320);
          v214.i64[0] = 0x3F0000003F000000;
          v214.i64[1] = 0x3F0000003F000000;
          *(int32x2_t *)v201.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v456, vadd_f32(*(float32x2_t *)v211.i8, vmul_f32(*(float32x2_t *)&v212, *(float32x2_t *)v172.i8))), 0), v455));
          *(float32x2_t *)v210.f32 = vmul_f32(*(float32x2_t *)v151.i8, vmul_f32(*(float32x2_t *)v210.f32, (float32x2_t)vand_s8(*(int8x8_t *)v175.i8, (int8x8_t)*(_OWORD *)&vcgtq_f32((float32x4_t)v175, (float32x4_t)vbslq_s8(v89, vextq_s8(v196, v196, 8uLL), vextq_s8(v197, v197, 4uLL))))));
          *(int8x8_t *)v206.i8 = vand_s8(*(int8x8_t *)v210.f32, *(int8x8_t *)v91.i8);
          *(int8x8_t *)v210.f32 = vand_s8(*(int8x8_t *)v89.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v210.f32, *(float32x2_t *)v196.i8));
          *(int32x2_t *)v210.f32 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v456, vadd_f32(*(float32x2_t *)v211.i8, vmul_f32(*(float32x2_t *)&v212, (float32x2_t)vorr_s8(vand_s8((int8x8_t)vadd_f32(*(float32x2_t *)v197.i8, (float32x2_t)vorr_s8(*(int8x8_t *)v210.f32, *(int8x8_t *)v206.i8)), *(int8x8_t *)v91.i8), *(int8x8_t *)v210.f32)))), 0), v455));
          *(int32x2_t *)v210.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v201.i8, *(int32x2_t *)v210.f32), vzip2_s32(*(int32x2_t *)v201.i8, *(int32x2_t *)v210.f32), vdup_n_s32(v213));
          v215 = a2[12];
          v216 = *(int32x4_t *)(*(_QWORD *)&v215 + 16 * v210.i32[1]);
          v217 = vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 768)), (float32x4_t)v9);
          v447 = *(float32x4_t *)(*(_QWORD *)&v215 + 16 * v210.i32[0]);
          if (v5)
          {
            v218 = vaddq_s32(vcvtq_s32_f32(v217), vcltzq_f32(v217));
            v219 = (float32x2_t)vsubq_f32(v217, vcvtq_f32_s32(v218)).u64[0];
            v220 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v218.i32[0] + v218.i32[1] * (int)v40));
            v221 = vaddq_f32(*v220, vmulq_n_f32(vsubq_f32(v220[1], *v220), v219.f32[0]));
            v222 = (int8x16_t)vaddq_f32(v221, vmulq_lane_f32(vsubq_f32(vaddq_f32(v220[v40], vmulq_n_f32(vsubq_f32(v220[(int)v40 + 1], v220[v40]), v219.f32[0])), v221), v219, 1));
            v223.i64[0] = 0x3F0000003F000000;
            v223.i64[1] = 0x3F0000003F000000;
            v224 = *(int8x16_t *)(v38 + 784);
            v225 = vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 800)), (float32x4_t)v9);
            v226 = vaddq_s32(vcvtq_s32_f32(v225), vcltzq_f32(v225));
            v225.i64[0] = vsubq_f32(v225, vcvtq_f32_s32(v226)).u64[0];
            v227 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v226.i32[0] + v226.i32[1] * (int)v40));
            v228 = vaddq_f32(*v227, vmulq_n_f32(vsubq_f32(v227[1], *v227), v225.f32[0]));
            v229 = (int8x16_t)vaddq_f32(v228, vmulq_lane_f32(vsubq_f32(vaddq_f32(v227[v40], vmulq_n_f32(vsubq_f32(v227[(int)v40 + 1], v227[v40]), v225.f32[0])), v228), *(float32x2_t *)v225.f32, 1));
            v230 = *(int8x16_t *)(v38 + 816);
            v231 = vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 832)), (float32x4_t)v9);
            v232 = vaddq_s32(vcvtq_s32_f32(v231), vcltzq_f32(v231));
            v233 = (float32x2_t)vsubq_f32(v231, vcvtq_f32_s32(v232)).u64[0];
            v234 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v232.i32[0] + v232.i32[1] * (int)v40));
            v235 = vaddq_f32(*v234, vmulq_n_f32(vsubq_f32(v234[1], *v234), v233.f32[0]));
            v236 = (int8x16_t)vaddq_f32(v235, vmulq_lane_f32(vsubq_f32(vaddq_f32(v234[v40], vmulq_n_f32(vsubq_f32(v234[(int)v40 + 1], v234[v40]), v233.f32[0])), v235), v233, 1));
            v237 = *(int8x16_t *)(v38 + 848);
            v238 = vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 864)), (float32x4_t)v9);
            v448 = v216;
            v239 = vaddq_s32(vcvtq_s32_f32(v238), vcltzq_f32(v238));
            v240 = (float32x2_t)vsubq_f32(v238, vcvtq_f32_s32(v239)).u64[0];
            v241 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v239.i32[0] + v239.i32[1] * (int)v40));
            v242 = vaddq_f32(*v241, vmulq_n_f32(vsubq_f32(v241[1], *v241), v240.f32[0]));
            v243 = vaddq_f32(v242, vmulq_lane_f32(vsubq_f32(vaddq_f32(v241[v40], vmulq_n_f32(vsubq_f32(v241[(int)v40 + 1], v241[v40]), v240.f32[0])), v242), v240, 1));
          }
          else
          {
            v244 = vaddq_f32(v217, v214);
            v245 = vcvtq_s32_f32(v244);
            v244.i64[0] = vaddq_s32(v245, vcgtq_f32(vcvtq_f32_s32(v245), v244)).u64[0];
            v222 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v244.i32[0] + v244.i32[1] * (int)v40));
            v223.i64[0] = 0x3F0000003F000000;
            v223.i64[1] = 0x3F0000003F000000;
            v224 = *(int8x16_t *)(v38 + 784);
            v246 = vaddq_f32(vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 800)), (float32x4_t)v9), v223);
            v247 = vcvtq_s32_f32(v246);
            v246.i64[0] = vaddq_s32(v247, vcgtq_f32(vcvtq_f32_s32(v247), v246)).u64[0];
            v229 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v246.i32[0] + v246.i32[1] * (int)v40));
            v230 = *(int8x16_t *)(v38 + 816);
            v248 = vaddq_f32(vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 832)), (float32x4_t)v9), v223);
            v249 = vcvtq_s32_f32(v248);
            v248.i64[0] = vaddq_s32(v249, vcgtq_f32(vcvtq_f32_s32(v249), v248)).u64[0];
            v236 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v248.i32[0] + v248.i32[1] * (int)v40));
            v237 = *(int8x16_t *)(v38 + 848);
            v448 = v216;
            v250 = vaddq_f32(vsubq_f32(vaddq_f32(v27, *(float32x4_t *)(v38 + 864)), (float32x4_t)v9), v223);
            v251 = vcvtq_s32_f32(v250);
            v250.i64[0] = vaddq_s32(v251, vcgtq_f32(vcvtq_f32_s32(v251), v250)).u64[0];
            v243 = *(float32x4_t *)(*(_QWORD *)&v39 + 16 * (v250.i32[0] + v250.i32[1] * (int)v40));
          }
          v252 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v125)), v90, v92).u64[0];
          v253 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v252, 0), (float32x4_t)vdupq_lane_s32(v252, 1)), (float32x4_t)v88);
          v254 = vbslq_s8(v253, *(int8x16_t *)(v38 + 752), *(int8x16_t *)(v38 + 736));
          v255 = vbslq_s8(v253, v125, v454);
          v256 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v222)), v90, v92).u64[0];
          v257 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v256, 0), (float32x4_t)vdupq_lane_s32(v256, 1)), (float32x4_t)v88);
          v258 = vbslq_s8(v257, v224, v254);
          v259 = vbslq_s8(v257, v222, v255);
          v257.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v229)), v90, v92).u64[0];
          v260 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v257.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v257.i8, 1)), (float32x4_t)v88);
          v261 = vbslq_s8(v260, v230, v258);
          v262 = vbslq_s8(v260, v229, v259);
          v260.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, (float32x4_t)v236)), v90, v92).u64[0];
          v263 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v260.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v260.i8, 1)), (float32x4_t)v88);
          v264 = vbslq_s8(v263, v237, v261);
          v265 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v93, v243)), v90, v92).u64[0];
          v262.i64[0] = vbslq_s8(v263, v236, v262).u64[0];
          v266 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v265, 0), (float32x4_t)vdupq_lane_s32(v265, 1)), (float32x4_t)v88);
          *(int32x2_t *)v262.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v461, vmul_f32(*(float32x2_t *)&v458, vadd_f32(*(float32x2_t *)(v38 + 896), vmul_f32(*(float32x2_t *)&v459, (float32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v266.i8, *(int8x8_t *)v243.f32), vand_s8(*(int8x8_t *)v262.i8, (int8x8_t)*(_OWORD *)&vmvnq_s8(v266))))))), 0), v460));
          v267 = vbslq_s8(v266, *(int8x16_t *)(v38 + 880), v264);
          v268 = (float32x4_t)vorrq_s8(vandq_s8(v89, (int8x16_t)vaddq_f32(vmulq_f32(v457, *(float32x4_t *)(*(_QWORD *)&v108+ 16 * (v262.i32[0] + v262.i32[1] * v109))), (float32x4_t)v267)), vandq_s8(v267, v91));
          v269 = (int8x16_t)vaddq_f32(v27, v268);
          v270 = vsubq_f32((float32x4_t)vorrq_s8(vandq_s8(v89, (int8x16_t)vaddq_f32((float32x4_t)v90, (float32x4_t)v269)), vandq_s8(v269, v91)), (float32x4_t)v9);
          if (v5)
          {
            v271 = vaddq_s32(vcvtq_s32_f32(v270), vcltzq_f32(v270));
            v272 = (float32x2_t)vsubq_f32(v270, vcvtq_f32_s32(v271)).u64[0];
            v273 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v271.i32[0] + v271.i32[1] * (int)v40));
            v274 = vaddq_f32(*v273, vmulq_n_f32(vsubq_f32(v273[1], *v273), v272.f32[0]));
            v275 = (int32x4_t)vaddq_f32(v274, vmulq_lane_f32(vsubq_f32(vaddq_f32(v273[v40], vmulq_n_f32(vsubq_f32(v273[(int)v40 + 1], v273[v40]), v272.f32[0])), v274), v272, 1));
          }
          else
          {
            v276 = vaddq_f32(v270, v223);
            v277 = vcvtq_s32_f32(v276);
            v276.i64[0] = vaddq_s32(v277, vcgtq_f32(vcvtq_f32_s32(v277), v276)).u64[0];
            v275 = *(int32x4_t *)(*(_QWORD *)&v39 + 16 * (v276.i32[0] + v276.i32[1] * (int)v40));
          }
          v278 = vabsq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vrev64q_s32((int32x4_t)v268), v91), v446));
          v279 = *(float32x4_t *)(v38 + 928);
          v280 = vminq_f32(vmulq_f32(vrsqrteq_f32(v278), *(float32x4_t *)(v38 + 912)), v279);
          *(int32x2_t *)v278.f32 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v456, vadd_f32(*(float32x2_t *)(v38 + 960), vmul_f32(*(float32x2_t *)&v212, vadd_f32(vmul_f32(*(float32x2_t *)v278.f32, vmin_f32(vmul_f32(*(float32x2_t *)v280.f32, (float32x2_t)*(_OWORD *)&vrsqrtsq_f32(vmulq_f32(v278, v280), v280)), *(float32x2_t *)v279.f32)), vmul_f32(
                                                   *(float32x2_t *)(v38 + 944),
                                                   (float32x2_t)*(_OWORD *)&vcvtq_f32_s32(vcvtq_s32_f32(vaddq_f32(v134, vmulq_f32((float32x4_t)v193, (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vrev64q_s32(v275), v91), vandq_s8(v89, v445))))))))))), 0), v455));
          v281 = *(int8x16_t *)(*(_QWORD *)&v215 + 16 * (int)(v278.i32[0] + v278.i32[1] * v213));
          v282 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 976)), (float32x4_t)v9);
          if (v5)
          {
            v283 = vaddq_s32(vcvtq_s32_f32(v282), vcltzq_f32(v282));
            v284 = (float32x2_t)vsubq_f32(v282, vcvtq_f32_s32(v283)).u64[0];
            v285 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v283.i32[0] + v283.i32[1] * (int)v40));
            v286 = vaddq_f32(*v285, vmulq_n_f32(vsubq_f32(v285[1], *v285), v284.f32[0]));
            v287 = (int)v40 + 1;
            v288 = (int8x16_t)vaddq_f32(v286, vmulq_lane_f32(vsubq_f32(vaddq_f32(v285[v40], vmulq_n_f32(vsubq_f32(v285[v287], v285[v40]), v284.f32[0])), v286), v284, 1));
            v289 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 992)), (float32x4_t)v9);
            v290 = vaddq_s32(vcvtq_s32_f32(v289), vcltzq_f32(v289));
            v289.i64[0] = vsubq_f32(v289, vcvtq_f32_s32(v290)).u64[0];
            v291 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v290.i32[0] + v290.i32[1] * (int)v40));
            v292 = vaddq_f32(*v291, vmulq_n_f32(vsubq_f32(v291[1], *v291), v289.f32[0]));
            v293 = (int8x16_t)vaddq_f32(v292, vmulq_lane_f32(vsubq_f32(vaddq_f32(v291[v40], vmulq_n_f32(vsubq_f32(v291[v287], v291[v40]), v289.f32[0])), v292), *(float32x2_t *)v289.f32, 1));
          }
          else
          {
            v294 = vaddq_f32(v282, v223);
            v295 = vcvtq_s32_f32(v294);
            v294.i64[0] = vaddq_s32(v295, vcgtq_f32(vcvtq_f32_s32(v295), v294)).u64[0];
            v288 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v294.i32[0] + v294.i32[1] * (int)v40));
            v296 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 992)), (float32x4_t)v9), v223);
            v297 = vcvtq_s32_f32(v296);
            v296.i64[0] = vaddq_s32(v297, vcgtq_f32(vcvtq_f32_s32(v297), v296)).u64[0];
            v293 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v296.i32[0] + v296.i32[1] * (int)v40));
          }
          v298 = *(float32x4_t *)(v38 + 1008);
          v299 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1056)), (float32x4_t)v9);
          if (v5)
          {
            v300 = vaddq_s32(vcvtq_s32_f32(v299), vcltzq_f32(v299));
            v301 = (float32x2_t)vsubq_f32(v299, vcvtq_f32_s32(v300)).u64[0];
            v302 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v300.i32[0] + v300.i32[1] * (int)v40));
            v303 = vaddq_f32(*v302, vmulq_n_f32(vsubq_f32(v302[1], *v302), v301.f32[0]));
            v304 = (int8x16_t)vaddq_f32(v303, vmulq_lane_f32(vsubq_f32(vaddq_f32(v302[v40], vmulq_n_f32(vsubq_f32(v302[(int)v40 + 1], v302[v40]), v301.f32[0])), v303), v301, 1));
            v305 = *(int8x16_t *)(v38 + 1072);
            v306 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1088)), (float32x4_t)v9);
            v444 = *(_OWORD *)(v38 + 944);
            v307 = vaddq_s32(vcvtq_s32_f32(v306), vcltzq_f32(v306));
            v306.i64[0] = vsubq_f32(v306, vcvtq_f32_s32(v307)).u64[0];
            v308 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v307.i32[0] + v307.i32[1] * (int)v40));
            v309 = vaddq_f32(*v308, vmulq_n_f32(vsubq_f32(v308[1], *v308), v306.f32[0]));
            v310 = (int8x16_t)vaddq_f32(v309, vmulq_lane_f32(vsubq_f32(vaddq_f32(v308[v40], vmulq_n_f32(vsubq_f32(v308[(int)v40 + 1], v308[v40]), v306.f32[0])), v309), *(float32x2_t *)v306.f32, 1));
            v311 = *(int8x16_t *)(v38 + 1104);
            v312 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1120)), (float32x4_t)v9);
            v443 = v281;
            v313 = vaddq_s32(vcvtq_s32_f32(v312), vcltzq_f32(v312));
            v314 = (float32x2_t)vsubq_f32(v312, vcvtq_f32_s32(v313)).u64[0];
            v315 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v313.i32[0] + v313.i32[1] * (int)v40));
            v316 = vaddq_f32(*v315, vmulq_n_f32(vsubq_f32(v315[1], *v315), v314.f32[0]));
            v317 = (int8x16_t)vaddq_f32(v316, vmulq_lane_f32(vsubq_f32(vaddq_f32(v315[v40], vmulq_n_f32(vsubq_f32(v315[(int)v40 + 1], v315[v40]), v314.f32[0])), v316), v314, 1));
            v318 = *(int8x16_t *)(v38 + 1136);
            v319 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1152)), (float32x4_t)v9);
            v450 = *(float32x4_t *)(v38 + 416);
            v320 = vaddq_s32(vcvtq_s32_f32(v319), vcltzq_f32(v319));
            v321 = (float32x2_t)vsubq_f32(v319, vcvtq_f32_s32(v320)).u64[0];
            v322 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v320.i32[0] + v320.i32[1] * (int)v40));
            v323 = vaddq_f32(*v322, vmulq_n_f32(vsubq_f32(v322[1], *v322), v321.f32[0]));
            v324 = vaddq_f32(v323, vmulq_lane_f32(vsubq_f32(vaddq_f32(v322[v40], vmulq_n_f32(vsubq_f32(v322[(int)v40 + 1], v322[v40]), v321.f32[0])), v323), v321, 1));
          }
          else
          {
            v325 = vaddq_f32(v299, v223);
            v326 = vcvtq_s32_f32(v325);
            v325.i64[0] = vaddq_s32(v326, vcgtq_f32(vcvtq_f32_s32(v326), v325)).u64[0];
            v304 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v325.i32[0] + v325.i32[1] * (int)v40));
            v305 = *(int8x16_t *)(v38 + 1072);
            v444 = *(_OWORD *)(v38 + 944);
            v327 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1088)), (float32x4_t)v9), v223);
            v328 = vcvtq_s32_f32(v327);
            v327.i64[0] = vaddq_s32(v328, vcgtq_f32(vcvtq_f32_s32(v328), v327)).u64[0];
            v310 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v327.i32[0] + v327.i32[1] * (int)v40));
            v311 = *(int8x16_t *)(v38 + 1104);
            v443 = v281;
            v329 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1120)), (float32x4_t)v9), v223);
            v330 = vcvtq_s32_f32(v329);
            v329.i64[0] = vaddq_s32(v330, vcgtq_f32(vcvtq_f32_s32(v330), v329)).u64[0];
            v317 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v329.i32[0] + v329.i32[1] * (int)v40));
            v318 = *(int8x16_t *)(v38 + 1136);
            v450 = *(float32x4_t *)(v38 + 416);
            v331 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1152)), (float32x4_t)v9), v223);
            v332 = vcvtq_s32_f32(v331);
            v331.i64[0] = vaddq_s32(v332, vcgtq_f32(vcvtq_f32_s32(v332), v331)).u64[0];
            v324 = *(float32x4_t *)(*(_QWORD *)&v39 + 16 * (v331.i32[0] + v331.i32[1] * (int)v40));
          }
          v333 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v293)), v92, v90).u64[0];
          v334 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v333, 0), (float32x4_t)vdupq_lane_s32(v333, 1)), (float32x4_t)v88);
          v335 = vbslq_s8(v334, *(int8x16_t *)(v38 + 1040), *(int8x16_t *)(v38 + 1024));
          v336 = vbslq_s8(v334, v293, v288);
          v337 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v304)), v92, v90).u64[0];
          v338 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v337, 0), (float32x4_t)vdupq_lane_s32(v337, 1)), (float32x4_t)v88);
          v339 = vbslq_s8(v338, v305, v335);
          v340 = vbslq_s8(v338, v304, v336);
          v338.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v310)), v92, v90).u64[0];
          v341 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v338.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v338.i8, 1)), (float32x4_t)v88);
          v342 = vbslq_s8(v341, v311, v339);
          v343 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v317)), v92, v90).u64[0];
          v344 = vbslq_s8(v341, v310, v340);
          v345 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v343, 0), (float32x4_t)vdupq_lane_s32(v343, 1)), (float32x4_t)v88);
          v346 = vbslq_s8(v345, v318, v342);
          v344.i64[0] = vbslq_s8(v345, v317, v344).u64[0];
          v345.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, v324)), v92, v90).u64[0];
          v347 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v345.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v345.i8, 1)), (float32x4_t)v88);
          *(int32x2_t *)v344.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v461, vmul_f32(*(float32x2_t *)&v458, vmul_f32(*(float32x2_t *)&v459, (float32x2_t)vrev64_s32((int32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v347.i8, *(int8x8_t *)v324.f32), vand_s8(*(int8x8_t *)v344.i8, (int8x8_t)*(_OWORD *)&vmvnq_s8(v347))))))), 0), v460));
          v348 = vbslq_s8(v347, *(int8x16_t *)(v38 + 1168), v346);
          v349 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vsubq_f32((float32x4_t)v348, vmulq_n_f32(v457, COERCE_FLOAT(*(_OWORD *)(*(_QWORD *)&v108+ 16 * (v344.i32[0] + v344.i32[1] * v109))))), v91), vandq_s8(v348, v89));
          v350 = vsubq_f32(vaddq_f32(v27, v349), (float32x4_t)v9);
          if (v5)
          {
            v351 = vaddq_s32(vcvtq_s32_f32(v350), vcltzq_f32(v350));
            v352 = (float32x2_t)vsubq_f32(v350, vcvtq_f32_s32(v351)).u64[0];
            v353 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v351.i32[0] + v351.i32[1] * (int)v40));
            v354 = vaddq_f32(*v353, vmulq_n_f32(vsubq_f32(v353[1], *v353), v352.f32[0]));
            v355 = (int)v40 + 1;
            v356 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v354, vmulq_lane_f32(vsubq_f32(vaddq_f32(v353[v40], vmulq_n_f32(vsubq_f32(v353[v355], v353[v40]), v352.f32[0])), v354), v352, 1)));
            v357 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1184)), (float32x4_t)v9);
            v358 = vaddq_s32(vcvtq_s32_f32(v357), vcltzq_f32(v357));
            v357.i64[0] = vsubq_f32(v357, vcvtq_f32_s32(v358)).u64[0];
            v359 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v358.i32[0] + v358.i32[1] * (int)v40));
            v360 = vaddq_f32(*v359, vmulq_n_f32(vsubq_f32(v359[1], *v359), v357.f32[0]));
            v361 = (int8x16_t)vaddq_f32(v360, vmulq_lane_f32(vsubq_f32(vaddq_f32(v359[v40], vmulq_n_f32(vsubq_f32(v359[v355], v359[v40]), v357.f32[0])), v360), *(float32x2_t *)v357.f32, 1));
            v362 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1200)), (float32x4_t)v9);
            v363 = vaddq_s32(vcvtq_s32_f32(v362), vcltzq_f32(v362));
            v362.i64[0] = vsubq_f32(v362, vcvtq_f32_s32(v363)).u64[0];
            v364 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v363.i32[0] + v363.i32[1] * (int)v40));
            v365 = vaddq_f32(*v364, vmulq_n_f32(vsubq_f32(v364[1], *v364), v362.f32[0]));
            v366 = (int8x16_t)vaddq_f32(v365, vmulq_lane_f32(vsubq_f32(vaddq_f32(v364[v40], vmulq_n_f32(vsubq_f32(v364[v355], v364[v40]), v362.f32[0])), v365), *(float32x2_t *)v362.f32, 1));
            v367 = *(int8x16_t *)(v38 + 1232);
            v368 = *(int8x16_t *)(v38 + 1216);
            v369 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1248)), (float32x4_t)v9);
            v370 = vaddq_s32(vcvtq_s32_f32(v369), vcltzq_f32(v369));
            v369.i64[0] = vsubq_f32(v369, vcvtq_f32_s32(v370)).u64[0];
            v371 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v370.i32[0] + v370.i32[1] * (int)v40));
            v372 = vaddq_f32(*v371, vmulq_n_f32(vsubq_f32(v371[1], *v371), v369.f32[0]));
            v373 = (int8x16_t)vaddq_f32(v372, vmulq_lane_f32(vsubq_f32(vaddq_f32(v371[v40], vmulq_n_f32(vsubq_f32(v371[v355], v371[v40]), v369.f32[0])), v372), *(float32x2_t *)v369.f32, 1));
            v374 = *(int8x16_t *)(v38 + 1264);
            v375 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1280)), (float32x4_t)v9);
            v376 = vaddq_s32(vcvtq_s32_f32(v375), vcltzq_f32(v375));
            v377 = (float32x2_t)vsubq_f32(v375, vcvtq_f32_s32(v376)).u64[0];
            v378 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v376.i32[0] + v376.i32[1] * (int)v40));
            v379 = vaddq_f32(*v378, vmulq_n_f32(vsubq_f32(v378[1], *v378), v377.f32[0]));
            v380 = (int8x16_t)vaddq_f32(v379, vmulq_lane_f32(vsubq_f32(vaddq_f32(v378[v40], vmulq_n_f32(vsubq_f32(v378[(int)v40 + 1], v378[v40]), v377.f32[0])), v379), v377, 1));
            v381 = *(int8x16_t *)(v38 + 1296);
            v382 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1312)), (float32x4_t)v9);
            v383 = vaddq_s32(vcvtq_s32_f32(v382), vcltzq_f32(v382));
            v384 = (float32x2_t)vsubq_f32(v382, vcvtq_f32_s32(v383)).u64[0];
            v385 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v383.i32[0] + v383.i32[1] * (int)v40));
            v386 = vaddq_f32(*v385, vmulq_n_f32(vsubq_f32(v385[1], *v385), v384.f32[0]));
            v387 = (int8x16_t)vaddq_f32(v386, vmulq_lane_f32(vsubq_f32(vaddq_f32(v385[v40], vmulq_n_f32(vsubq_f32(v385[(int)v40 + 1], v385[v40]), v384.f32[0])), v386), v384, 1));
            v388 = *(int8x16_t *)(v38 + 1328);
            v389 = vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1344)), (float32x4_t)v9);
            v390.i64[0] = 0x3F0000003F000000;
            v390.i64[1] = 0x3F0000003F000000;
            v391 = vaddq_s32(vcvtq_s32_f32(v389), vcltzq_f32(v389));
            v392 = (float32x2_t)vsubq_f32(v389, vcvtq_f32_s32(v391)).u64[0];
            v393 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v391.i32[0] + v391.i32[1] * (int)v40));
            v394 = vaddq_f32(*v393, vmulq_n_f32(vsubq_f32(v393[1], *v393), v392.f32[0]));
            v395 = vaddq_f32(v394, vmulq_lane_f32(vsubq_f32(vaddq_f32(v393[v40], vmulq_n_f32(vsubq_f32(v393[(int)v40 + 1], v393[v40]), v392.f32[0])), v394), v392, 1));
          }
          else
          {
            v396 = vaddq_f32(v350, v223);
            v397 = vcvtq_s32_f32(v396);
            v396.i64[0] = vaddq_s32(v397, vcgtq_f32(vcvtq_f32_s32(v397), v396)).u64[0];
            v356 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(*(_QWORD *)&v39 + 16 * (v396.i32[0] + v396.i32[1] * (int)v40)));
            v398 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1184)), (float32x4_t)v9), v223);
            v399 = vcvtq_s32_f32(v398);
            v398.i64[0] = vaddq_s32(v399, vcgtq_f32(vcvtq_f32_s32(v399), v398)).u64[0];
            v361 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v398.i32[0] + v398.i32[1] * (int)v40));
            v400 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1200)), (float32x4_t)v9), v223);
            v401 = vcvtq_s32_f32(v400);
            v400.i64[0] = vaddq_s32(v401, vcgtq_f32(vcvtq_f32_s32(v401), v400)).u64[0];
            v366 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v400.i32[0] + v400.i32[1] * (int)v40));
            v367 = *(int8x16_t *)(v38 + 1232);
            v368 = *(int8x16_t *)(v38 + 1216);
            v402 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1248)), (float32x4_t)v9), v223);
            v403 = vcvtq_s32_f32(v402);
            v402.i64[0] = vaddq_s32(v403, vcgtq_f32(vcvtq_f32_s32(v403), v402)).u64[0];
            v373 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v402.i32[0] + v402.i32[1] * (int)v40));
            v374 = *(int8x16_t *)(v38 + 1264);
            v404 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1280)), (float32x4_t)v9), v223);
            v405 = vcvtq_s32_f32(v404);
            v404.i64[0] = vaddq_s32(v405, vcgtq_f32(vcvtq_f32_s32(v405), v404)).u64[0];
            v380 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v404.i32[0] + v404.i32[1] * (int)v40));
            v381 = *(int8x16_t *)(v38 + 1296);
            v406 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1312)), (float32x4_t)v9), v223);
            v407 = vcvtq_s32_f32(v406);
            v406.i64[0] = vaddq_s32(v407, vcgtq_f32(vcvtq_f32_s32(v407), v406)).u64[0];
            v387 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v406.i32[0] + v406.i32[1] * (int)v40));
            v388 = *(int8x16_t *)(v38 + 1328);
            v390.i64[0] = 0x3F0000003F000000;
            v390.i64[1] = 0x3F0000003F000000;
            v408 = vaddq_f32(vsubq_f32(vsubq_f32(v27, *(float32x4_t *)(v38 + 1344)), (float32x4_t)v9), v223);
            v409 = vcvtq_s32_f32(v408);
            v408.i64[0] = vaddq_s32(v409, vcgtq_f32(vcvtq_f32_s32(v409), v408)).u64[0];
            v395 = *(float32x4_t *)(*(_QWORD *)&v39 + 16 * (v408.i32[0] + v408.i32[1] * (int)v40));
          }
          v410 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v366)), v92, v90).u64[0];
          v411 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v410, 0), (float32x4_t)vdupq_lane_s32(v410, 1)), (float32x4_t)v88);
          v412 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v373)), v92, v90).u64[0];
          v413 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v412, 0), (float32x4_t)vdupq_lane_s32(v412, 1)), (float32x4_t)v88);
          v414 = vbslq_s8(v413, v374, vbslq_s8(v411, v367, v368));
          v415 = vbslq_s8(v413, v373, vbslq_s8(v411, v366, v361));
          v413.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v380)), v92, v90).u64[0];
          v416 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v413.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v413.i8, 1)), (float32x4_t)v88);
          v417 = vbslq_s8(v416, v381, v414);
          v418 = vbslq_s8(v416, v380, v415);
          v416.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, (float32x4_t)v387)), v92, v90).u64[0];
          v419 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v416.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v416.i8, 1)), (float32x4_t)v88);
          v420 = (int32x2_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, vsubq_f32(v298, v395)), v92, v90).u64[0];
          v421 = (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v420, 0), (float32x4_t)vdupq_lane_s32(v420, 1)), (float32x4_t)v88);
          v422 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v461, vmul_f32(*(float32x2_t *)&v458, vadd_f32(*(float32x2_t *)(v38 + 896), vmul_f32(*(float32x2_t *)&v459, (float32x2_t)vrev64_s32((int32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v421.i8, *(int8x8_t *)v395.f32), vand_s8((int8x8_t)*(_OWORD *)&vbslq_s8(v419, v387, v418), (int8x8_t)*(_OWORD *)&vmvnq_s8(v421)))))))), 0), v460));
          v423 = vbslq_s8(v421, *(int8x16_t *)(v38 + 1360), vbslq_s8(v419, v388, v417));
          v424 = vandq_s8(v423, v89);
          v425 = vandq_s8((int8x16_t)vaddq_f32(vmulq_n_f32(v457, COERCE_FLOAT(*(_OWORD *)(*(_QWORD *)&v108 + 16 * (v422.i32[0] + v422.i32[1] * v109)))), (float32x4_t)v423), v91);
          v426 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vorrq_s8(v425, v424));
          v427 = vsubq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vaddq_f32((float32x4_t)v92, (float32x4_t)v426), v91), vandq_s8(v89, v426)), (float32x4_t)v9);
          if (v5)
          {
            v428 = vaddq_s32(vcvtq_s32_f32(v427), vcltzq_f32(v427));
            v429 = (float32x2_t)vsubq_f32(v427, vcvtq_f32_s32(v428)).u64[0];
            v430 = (float32x4_t *)(*(_QWORD *)&v39 + 16 * (v428.i32[0] + v428.i32[1] * (int)v40));
            v431 = vaddq_f32(*v430, vmulq_n_f32(vsubq_f32(v430[1], *v430), v429.f32[0]));
            v31 = (int8x16_t)vaddq_f32(v431, vmulq_lane_f32(vsubq_f32(vaddq_f32(v430[v40], vmulq_n_f32(vsubq_f32(v430[(int)v40 + 1], v430[v40]), v429.f32[0])), v431), v429, 1));
          }
          else
          {
            v29 = vaddq_f32(v427, v390);
            v30 = vcvtq_s32_f32(v29);
            v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
            v31 = *(int8x16_t *)(*(_QWORD *)&v39 + 16 * (v29.i32[0] + v29.i32[1] * (int)v40));
          }
          v32 = vaddq_f32(vmulq_n_f32(v447, *(float *)vandq_s8(v175, (int8x16_t)vcgtq_f32(vaddq_f32(v449, v451), (float32x4_t)v174)).i32), vmulq_n_f32((float32x4_t)vrev64q_s32(v448), *(float *)vandq_s8(v175, (int8x16_t)vcgtq_f32(vsubq_f32((float32x4_t)v197, (float32x4_t)v196), (float32x4_t)v174)).i32));
          v33 = vabsq_f32((float32x4_t)vorrq_s8(v425, vandq_s8((int8x16_t)vrev64q_s32((int32x4_t)v349), v89)));
          v34 = vminq_f32(vmulq_f32(*(float32x4_t *)(v38 + 912), vrsqrteq_f32(v33)), v279);
          v35 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v456, vadd_f32(*(float32x2_t *)(v38 + 960), vmul_f32(*(float32x2_t *)&v212, vadd_f32(vmul_f32(*(float32x2_t *)v33.f32, vmin_f32(vmul_f32(*(float32x2_t *)v34.f32, (float32x2_t)*(_OWORD *)&vrsqrtsq_f32(vmulq_f32(v33, v34), v34)), *(float32x2_t *)v279.f32)), vmul_f32(*(float32x2_t *)&v444, (float32x2_t)*(_OWORD *)&vcvtq_f32_s32(
                                                           vcvtq_s32_f32(vaddq_f32(v134, vmulq_f32(v450, (float32x4_t)vorrq_s8(vandq_s8(v31, v91), vandq_s8(v89, v356))))))))))), 0), v455));
          v36 = (int8x16_t)vcgtq_f32(v32, (float32x4_t)v88);
          v34.i64[0] = vmvnq_s8(v36).u64[0];
          v37 = vorr_s8(vand_s8(vorr_s8(vand_s8(*(int8x8_t *)(*(_QWORD *)&v215 + 16 * (int)(v35.i32[0] + v35.i32[1] * v213)), *(int8x8_t *)v452.i8), (int8x8_t)*(_OWORD *)&vbicq_s8(v88, v452)), *(int8x8_t *)v34.f32), vand_s8(*(int8x8_t *)v36.i8, *(int8x8_t *)v88.i8));
          *(int8x8_t *)v36.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v453, 1), (float32x4_t)v88), v443, v88), *(int8x8_t *)v34.f32), vand_s8(*(int8x8_t *)v36.i8, *(int8x8_t *)v32.f32));
          v36.u64[1] = (unint64_t)v37;
          *(int8x16_t *)(*(_QWORD *)&v442 + v28) = v36;
          v27 = vaddq_f32(v27, (float32x4_t)xmmword_1B304F230);
          v12 += 0x100000000;
          v28 += 16;
          v26.i64[0] = 0x3F0000003F000000;
          v26.i64[1] = 0x3F0000003F000000;
        }
        while (v440 != v28);
        v8 = v439;
        v12 = v438 + v435;
        *(_QWORD *)&v442 += v434;
        v27 = vaddq_f32(v437, (float32x4_t)xmmword_1B304F240);
        v18 += v433;
        v19 += v433;
        v20 += v433;
        v21 += v433;
        *(_QWORD *)&v11 += v433;
        v22 += v433;
        v23 += v433;
        v24 += v433;
        v25 += v433;
      }
      while (v439 != v436);
    }
  }
  return 0;
}

uint64_t HgcSMAAPatternSearch::GetDOD(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  HGNode *Input;
  uint64_t DOD;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  HGNode *v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3 == 2 || a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, a3);
    DOD = HGRenderer::GetDOD(a2, Input);
    v13 = HGRectIntersection(v5, v4, DOD, v12);
    if (!HGRectIsNull(v13, v14))
    {
      v15 = HGRenderer::GetInput(a2, this, 0);
      v16 = HGRenderer::GetDOD(a2, v15);
      return HGRectUnion(v16, v17, 0, 0);
    }
    return 0;
  }
  if (a3)
    return 0;
  if ((*(int (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
  {
    v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    HGRectGrow(v5, v4, v8);
  }
  return 0x8000000080000000;
}

uint64_t HgcSMAAPatternSearch::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  HGNode *v6;
  uint64_t DOD;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  HGNode *Input;

  if (a3 == 2 || a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, a3);
    return HGRenderer::GetDOD(a2, Input);
  }
  if (!a3)
  {
    v6 = HGRenderer::GetInput(a2, this, 0);
    DOD = HGRenderer::GetDOD(a2, v6);
    v9 = v8;
    if ((*(int (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) < 1)
      return DOD;
    v10 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(DOD, v9, v10);
  }
  return 0;
}

void HgcSMAAPatternSearch::~HgcSMAAPatternSearch(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65355A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4040DFEAD7);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65355A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4040DFEAD7);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65355A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4040DFEAD7);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcSMAAPatternSearch::SetParameter(HgcSMAAPatternSearch *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcSMAAPatternSearch::GetParameter(HgcSMAAPatternSearch *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcSMAABlend::GetProgram(HgcSMAABlend *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000054f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 9.999999747e-06, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xz = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xz;\n"
             "    r0.y = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord2.xy).y;\n"
             "    r0.w = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord3.xy).w;\n"
             "    r1.xy = r0.wy - r0.zx;\n"
             "    r1.xy = select(-r0.zx, r0.wy, r1.xy > 0.00000h);\n"
             "    r2.xy = abs(r1.xy);\n"
             "    r2.xy = r2.yy - r2.xx;\n"
             "    r2.xy = select(c0.yx, c0.xy, r2.xy < 0.00000h);\n"
             "    r1.xy = r1.xy*r2.xy;\n"
             "    r0.xy = half2(dot(r0, 1.00000h));\n"
             "    r0.xy = half2(c0.zz < r0.xy);\n"
             "    s0.xy = float2(r1.xy)*float2(r0.xy) + frag._texCoord0.xy;\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    output.color0 = (float4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=741f56be:ab313603:865b46ac:82d181bb\n"
             "//SIG=00400000:00000000:00000000:00000003:0001:0001:0004:0000:0000:0000:001e:0000:0004:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000518\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 9.999999747e-06, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xz;\n"
             "    r0.y = hg_Texture1.sample(hg_Sampler1, frag._texCoord2.xy).y;\n"
             "    r0.w = hg_Texture1.sample(hg_Sampler1, frag._texCoord3.xy).w;\n"
             "    r1.xy = r0.wy - r0.zx;\n"
             "    r1.xy = select(-r0.zx, r0.wy, r1.xy > 0.00000f);\n"
             "    r2.xy = abs(r1.xy);\n"
             "    r2.xy = r2.yy - r2.xx;\n"
             "    r2.xy = select(c0.yx, c0.xy, r2.xy < 0.00000f);\n"
             "    r1.xy = r1.xy*r2.xy;\n"
             "    r0.xy = float2(dot(r0, 1.00000f));\n"
             "    r0.xy = float2(c0.zz < r0.xy);\n"
             "    r1.xy = r1.xy*r0.xy + frag._texCoord0.xy;\n"
             "    r1.xy = r1.xy + hg_Params[0].xy;\n"
             "    r1.xy = r1.xy*hg_Params[0].zw;\n"
             "    output.color0 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b7af3f41:6b37361f:a8d61853:9193c802\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:001e:0000:0004:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000052b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 9.999999747e-06, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xz = texture2D(hg_Texture1, hg_TexCoord1.xy).xz;\n"
           "    r0.y = texture2D(hg_Texture1, hg_TexCoord2.xy).y;\n"
           "    r0.w = texture2D(hg_Texture1, hg_TexCoord3.xy).w;\n"
           "    r1.xy = r0.wy - r0.zx;\n"
           "    r1.xy = vec2(r1.x > 0.00000 ? r0.w : -r0.z, r1.y > 0.00000 ? r0.y : -r0.x);\n"
           "    r2.xy = abs(r1.xy);\n"
           "    r2.xy = r2.yy - r2.xx;\n"
           "    r2.xy = vec2(r2.x < 0.00000 ? c0.x : c0.y, r2.y < 0.00000 ? c0.y : c0.x);\n"
           "    r1.xy = r1.xy*r2.xy;\n"
           "    r0.xy = vec2(dot(r0, vec4(1.00000)));\n"
           "    r0.xy = vec2(lessThan(c0.zz, r0.xy));\n"
           "    r1.xy = r1.xy*r0.xy + hg_TexCoord0.xy;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal0.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal0.zw;\n"
           "    gl_FragColor = texture2D(hg_Texture0, r1.xy);\n"
           "}\n"
           "//MD5=5856c31f:bb2d9d4d:b266418a:0cacbda8\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0004:02:0:1:0\n";
  }
}

void HgcSMAABlend::InitProgramDescriptor(HgcSMAABlend *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSMAABlend_hgc_visible", "//Metal1.0     \n//LEN=0000000465\n[[ visible ]] FragmentOut HgcSMAABlend_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2,\n    float4 texCoord3)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 9.999999747e-06, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xz = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xz;\n"
    "    r0.y = hg_Texture1.sample(hg_Sampler1, texCoord2.xy).y;\n"
    "    r0.w = hg_Texture1.sample(hg_Sampler1, texCoord3.xy).w;\n"
    "    r1.xy = r0.wy - r0.zx;\n"
    "    r1.xy = select(-r0.zx, r0.wy, r1.xy > 0.00000f);\n"
    "    r2.xy = abs(r1.xy);\n"
    "    r2.xy = r2.yy - r2.xx;\n"
    "    r2.xy = select(c0.yx, c0.xy, r2.xy < 0.00000f);\n"
    "    r1.xy = r1.xy*r2.xy;\n"
    "    r0.xy = float2(dot(r0, 1.00000f));\n"
    "    r0.xy = float2(c0.zz < r0.xy);\n"
    "    r1.xy = r1.xy*r0.xy + texCoord0.xy;\n"
    "    r1.xy = r1.xy + hg_Params[0].xy;\n"
    "    r1.xy = r1.xy*hg_Params[0].zw;\n"
    "    output.color0 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B8ADD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a20 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a23);
  _Unwind_Resume(a1);
}

void sub_1B2B8AE24(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B8AE1CLL);
}

void HgcSMAABlend::shaderDescription(char *a1@<X8>)
{
  a1[23] = 19;
  strcpy(a1, "HgcSMAABlend [hgc1]");
}

uint64_t HgcSMAABlend::BindTexture(HgcSMAABlend *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      HGHandler::TexCoord(a2, 2, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.0, 1.0, 0.0);
      HGHandler::TexCoord(a2, 3, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 1.0, 0.0, 0.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    {
      v7.n128_u32[0] = 1.0;
      v8.n128_u32[0] = 1.0;
    }
    else
    {
      v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v5.n128_f32[0] = (float)*((int *)a2 + 60);
    v6.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
    return 0;
  }
}

uint64_t HgcSMAABlend::Bind(HgcSMAABlend *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HgcSMAABlend *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcSMAABlend::RenderTile(HgcSMAABlend *this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  int v8;
  float32x4_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  float32x4_t v21;
  int32x4_t v22;
  float32x2_t v23;
  float32x4_t *v24;
  float32x4_t v25;
  uint64_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  float32x4_t *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int32x4_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t *v38;
  int8x16_t v39;
  uint64_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  float32x4_t v48;
  int8x8_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int8x8_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v58;
  float32x4_t v59;
  int8x16_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  uint64_t v77;
  uint64_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  uint64_t v86;
  int32x4_t v87;
  float32x2_t v88;
  float32x4_t *v89;
  float32x4_t v90;
  uint64_t v91;
  uint64_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t v95;
  float32x4_t v96;
  int8x16_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  float32x4_t v101;
  uint64_t v102;
  uint64_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int32x4_t v106;

  v4 = HGTile::Renderer(a2);
  v5 = (*(uint64_t (**)(HgcSMAABlend *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *(int32x2_t *)a2;
  v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v7 >= 1)
  {
    v8 = 0;
    *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v9.i64[1] = 0x3F80000000000000;
    v10 = *((_DWORD *)a2 + 2) - v6.i32[0];
    v11 = *((_QWORD *)a2 + 2);
    v12 = *((_QWORD *)a2 + 12);
    v13 = 16 * *((int *)a2 + 6);
    v14 = 16 * *((int *)a2 + 26);
    v15 = v12 + v14;
    v16.i64[0] = 0x3F0000003F000000;
    v16.i64[1] = 0x3F0000003F000000;
    v17 = v9;
    do
    {
      if (v10 < 3)
      {
        LODWORD(v86) = 0;
        v21 = v17;
        if (v10 > 0)
          goto LABEL_13;
      }
      else
      {
        v18 = 0;
        v19 = 0;
        v20 = v12 + v14;
        v21 = v17;
        do
        {
          v39 = *(int8x16_t *)(v12 + v18 + 16);
          v40 = *((_QWORD *)this + 51);
          v41 = *(int8x16_t *)(v40 + 16);
          v42 = vbslq_s8(*(int8x16_t *)v40, *(int8x16_t *)(v20 + v18 + 16), v39);
          v43 = *(int8x16_t *)(v12 + v18 + 32);
          v44 = vbslq_s8(v41, v39, vbslq_s8(*(int8x16_t *)v40, *(int8x16_t *)(v20 + v18), *(int8x16_t *)(v12 + v18)));
          v45 = vbslq_s8(v41, v43, v42);
          v46 = *(int8x16_t *)(v40 + 32);
          v47 = *(int8x16_t *)(v40 + 48);
          *(int8x8_t *)v48.f32 = vqtbl1_s8(v44, *(int8x8_t *)v46.i8);
          v49 = (int8x8_t)vextq_s8(v46, v46, 8uLL).u64[0];
          *(int8x8_t *)&v48.u32[2] = vqtbl1_s8(v44, v49);
          v50 = vbslq_s8(v41, *(int8x16_t *)(v12 + v18 + 48), vbslq_s8(*(int8x16_t *)v40, *(int8x16_t *)(v20 + v18 + 32), v43));
          *(int8x8_t *)v51.f32 = vqtbl1_s8(v45, *(int8x8_t *)v46.i8);
          *(int8x8_t *)&v51.u32[2] = vqtbl1_s8(v45, v49);
          *(int8x8_t *)v52.f32 = vqtbl1_s8(v50, *(int8x8_t *)v46.i8);
          *(int8x8_t *)&v52.u32[2] = vqtbl1_s8(v50, v49);
          *(int8x8_t *)v41.i8 = vqtbl1_s8(v44, *(int8x8_t *)v47.i8);
          v53 = (int8x8_t)vextq_s8(v47, v47, 8uLL).u64[0];
          v41.u64[1] = (unint64_t)vqtbl1_s8(v44, v53);
          *(int8x8_t *)v46.i8 = vqtbl1_s8(v45, *(int8x8_t *)v47.i8);
          v46.u64[1] = (unint64_t)vqtbl1_s8(v45, v53);
          *(int8x8_t *)v47.i8 = vqtbl1_s8(v50, *(int8x8_t *)v47.i8);
          v47.u64[1] = (unint64_t)vqtbl1_s8(v50, v53);
          v54 = vsubq_f32(v51, (float32x4_t)v46);
          v55 = vsubq_f32(v52, (float32x4_t)v47);
          v56 = (int8x16_t)vnegq_f32((float32x4_t)v44);
          v57 = (int8x16_t)vnegq_f32((float32x4_t)v45);
          v58 = (int8x16_t)vnegq_f32((float32x4_t)v50);
          v59 = *(float32x4_t *)(v40 + 64);
          v60 = *(int8x16_t *)(v40 + 80);
          v61 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vsubq_f32(v48, (float32x4_t)v41), v59), (int8x16_t)v48, (int8x16_t)vzip1q_s32((int32x4_t)vextq_s8(v56, v56, 8uLL), (int32x4_t)v56));
          v62 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v54, v59), (int8x16_t)v51, (int8x16_t)vzip1q_s32((int32x4_t)vextq_s8(v57, v57, 8uLL), (int32x4_t)v57));
          *(float32x2_t *)v48.f32 = vabs_f32(*(float32x2_t *)v61.f32);
          *(float32x2_t *)v56.i8 = vabs_f32(*(float32x2_t *)v62.f32);
          v63 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v55, v59), (int8x16_t)v52, (int8x16_t)vzip1q_s32((int32x4_t)vextq_s8(v58, v58, 8uLL), (int32x4_t)v58));
          *(float32x2_t *)v55.f32 = vabs_f32(*(float32x2_t *)v63.f32);
          v64 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
          v65 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 0));
          v66 = vaddq_f32(v64, (float32x4_t)xmmword_1B304F230);
          v67 = *(int8x16_t *)(v40 + 96);
          v68 = *(float32x4_t *)(v40 + 112);
          v69 = vmulq_f32(v61, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v59, v65), v67, v60));
          v70 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v44, v44, 4uLL), (float32x4_t)v44);
          v71 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v45, v45, 4uLL), (float32x4_t)v45);
          v72 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v50, v50, 4uLL), (float32x4_t)v50);
          v73 = *(int8x16_t *)(v40 + 128);
          v74 = vaddq_f32(v21, vmulq_f32((float32x4_t)vandq_s8(v73, (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)v70, (float32x4_t)vextq_s8(v70, v70, 8uLL)), v68)), v69));
          v75 = vaddq_f32(v64, vmulq_f32((float32x4_t)vandq_s8(v73, (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)v71, (float32x4_t)vextq_s8(v71, v71, 8uLL)), v68)), vmulq_f32(v62, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v59, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.i8, 1), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.i8, 0))), v67, v60))));
          v76 = vaddq_f32(v66, vmulq_f32((float32x4_t)vandq_s8(v73, (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)v72, (float32x4_t)vextq_s8(v72, v72, 8uLL)), v68)), vmulq_f32(v63, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v59, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0))), v67, v60))));
          v77 = *((_QWORD *)a2 + 10);
          v78 = *((int *)a2 + 22);
          v79 = vsubq_f32(v74, v9);
          if (v5)
          {
            v22 = vaddq_s32(vcvtq_s32_f32(v79), vcltzq_f32(v79));
            v23 = (float32x2_t)vsubq_f32(v79, vcvtq_f32_s32(v22)).u64[0];
            v24 = (float32x4_t *)(v77 + 16 * (v22.i32[0] + v22.i32[1] * (int)v78));
            v25 = vaddq_f32(*v24, vmulq_n_f32(vsubq_f32(v24[1], *v24), v23.f32[0]));
            v26 = (int)v78 + 1;
            v27 = vaddq_f32(v25, vmulq_lane_f32(vsubq_f32(vaddq_f32(v24[v78], vmulq_n_f32(vsubq_f32(v24[v26], v24[v78]), v23.f32[0])), v25), v23, 1));
            v28 = vsubq_f32(v75, v9);
            v29 = vaddq_s32(vcvtq_s32_f32(v28), vcltzq_f32(v28));
            v28.i64[0] = vsubq_f32(v28, vcvtq_f32_s32(v29)).u64[0];
            v30 = (float32x4_t *)(v77 + 16 * (v29.i32[0] + v29.i32[1] * (int)v78));
            v31 = vaddq_f32(*v30, vmulq_n_f32(vsubq_f32(v30[1], *v30), v28.f32[0]));
            v32 = vaddq_f32(v31, vmulq_lane_f32(vsubq_f32(vaddq_f32(v30[v78], vmulq_n_f32(vsubq_f32(v30[v26], v30[v78]), v28.f32[0])), v31), *(float32x2_t *)v28.f32, 1));
            v33 = vsubq_f32(v76, v9);
            v34 = vaddq_s32(vcvtq_s32_f32(v33), vcltzq_f32(v33));
            v33.i64[0] = vsubq_f32(v33, vcvtq_f32_s32(v34)).u64[0];
            v35 = (float32x4_t *)(v77 + 16 * (v34.i32[0] + v34.i32[1] * (int)v78));
            v36 = vaddq_f32(*v35, vmulq_n_f32(vsubq_f32(v35[1], *v35), v33.f32[0]));
            v37 = vaddq_f32(v36, vmulq_lane_f32(vsubq_f32(vaddq_f32(v35[v78], vmulq_n_f32(vsubq_f32(v35[v26], v35[v78]), v33.f32[0])), v36), *(float32x2_t *)v33.f32, 1));
          }
          else
          {
            v80 = vaddq_f32(v79, v16);
            v81 = vcvtq_s32_f32(v80);
            v80.i64[0] = vaddq_s32(v81, vcgtq_f32(vcvtq_f32_s32(v81), v80)).u64[0];
            v27 = *(float32x4_t *)(v77 + 16 * (v80.i32[0] + v80.i32[1] * (int)v78));
            v82 = vaddq_f32(vsubq_f32(v75, v9), v16);
            v83 = vcvtq_s32_f32(v82);
            v82.i64[0] = vaddq_s32(v83, vcgtq_f32(vcvtq_f32_s32(v83), v82)).u64[0];
            v32 = *(float32x4_t *)(v77 + 16 * (v82.i32[0] + v82.i32[1] * (int)v78));
            v84 = vaddq_f32(vsubq_f32(v76, v9), v16);
            v85 = vcvtq_s32_f32(v84);
            v84.i64[0] = vaddq_s32(v85, vcgtq_f32(vcvtq_f32_s32(v85), v84)).u64[0];
            v37 = *(float32x4_t *)(v77 + 16 * (v84.i32[0] + v84.i32[1] * (int)v78));
          }
          v38 = (float32x4_t *)(v11 + v18);
          *v38 = v27;
          v38[1] = v32;
          v38[2] = v37;
          v21 = vaddq_f32(v66, (float32x4_t)xmmword_1B304F230);
          v19 -= 3;
          v18 += 48;
        }
        while (v10 + v19 > 2);
        LODWORD(v86) = -v19;
        if ((int)v86 < v10)
        {
LABEL_13:
          v86 = v86;
          do
          {
            while (1)
            {
              v91 = *((_QWORD *)this + 51);
              v92 = v86 + 1;
              v93 = vbslq_s8(*(int8x16_t *)(v91 + 16), *(int8x16_t *)(v12 + 16 * (v86 + 1)), vbslq_s8(*(int8x16_t *)v91, *(int8x16_t *)(v15 + 16 * v86), *(int8x16_t *)(v12 + 16 * v86)));
              v94 = *(int8x16_t *)(v91 + 32);
              v95 = *(int8x16_t *)(v91 + 48);
              *(int8x8_t *)v96.f32 = vqtbl1_s8(v93, *(int8x8_t *)v94.i8);
              *(int8x8_t *)&v96.u32[2] = vqtbl1_s8(v93, (int8x8_t)*(_OWORD *)&vextq_s8(v94, v94, 8uLL));
              *(int8x8_t *)v94.i8 = vqtbl1_s8(v93, *(int8x8_t *)v95.i8);
              v94.u64[1] = (unint64_t)vqtbl1_s8(v93, (int8x8_t)*(_OWORD *)&vextq_s8(v95, v95, 8uLL));
              v97 = (int8x16_t)vnegq_f32((float32x4_t)v93);
              v98 = *(float32x4_t *)(v91 + 64);
              v99 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vsubq_f32(v96, (float32x4_t)v94), v98), (int8x16_t)v96, (int8x16_t)vzip1q_s32((int32x4_t)vextq_s8(v97, v97, 8uLL), (int32x4_t)v97));
              *(float32x2_t *)v97.i8 = vabs_f32(*(float32x2_t *)v99.f32);
              v100 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v93, v93, 4uLL), (float32x4_t)v93);
              v101 = vaddq_f32(v21, vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)(v91 + 128), (int8x16_t)vcgtq_f32(vaddq_f32((float32x4_t)v100, (float32x4_t)vextq_s8(v100, v100, 8uLL)), *(float32x4_t *)(v91 + 112))), vmulq_f32(v99, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v98, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v97.i8, 1), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v97.i8, 0))), *(int8x16_t *)(v91 + 96), *(int8x16_t *)(v91 + 80)))));
              v102 = *((_QWORD *)a2 + 10);
              v103 = *((int *)a2 + 22);
              v104 = vsubq_f32(v101, v9);
              if (!v5)
                break;
              v87 = vaddq_s32(vcvtq_s32_f32(v104), vcltzq_f32(v104));
              v88 = (float32x2_t)vsubq_f32(v104, vcvtq_f32_s32(v87)).u64[0];
              v89 = (float32x4_t *)(v102 + 16 * (v87.i32[0] + v87.i32[1] * (int)v103));
              v90 = vaddq_f32(*v89, vmulq_n_f32(vsubq_f32(v89[1], *v89), v88.f32[0]));
              *(float32x4_t *)(v11 + 16 * v86) = vaddq_f32(v90, vmulq_lane_f32(vsubq_f32(vaddq_f32(v89[v103], vmulq_n_f32(vsubq_f32(v89[(int)v103 + 1], v89[v103]), v88.f32[0])), v90), v88, 1));
              v21 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
              ++v86;
              if (v92 >= v10)
                goto LABEL_3;
            }
            v105 = vaddq_f32(v104, v16);
            v106 = vcvtq_s32_f32(v105);
            v105.i64[0] = vaddq_s32(v106, vcgtq_f32(vcvtq_f32_s32(v106), v105)).u64[0];
            *(_OWORD *)(v11 + 16 * v86) = *(_OWORD *)(v102 + 16 * (v105.i32[0] + v105.i32[1] * (int)v103));
            v21 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
            ++v86;
          }
          while (v92 < v10);
        }
      }
LABEL_3:
      v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F240);
      v12 += v14;
      ++v8;
      v11 += v13;
      v15 += v14;
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcSMAABlend::GetDOD(HgcSMAABlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v6 = HGRectMake4i(0, 0, 1u, 1u);
      return HGRectGrow(v5, v4, v6);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ((*(int (**)(HgcSMAABlend *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
    {
      v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      HGRectGrow(v5, v4, v8);
    }
    return 0x8000000080000000;
  }
}

uint64_t HgcSMAABlend::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  HGNode *Input;
  uint64_t DOD;
  uint64_t v13;
  uint64_t v14;

  if (!a3)
  {
    Input = HGRenderer::GetInput(a2, this, 0);
    DOD = HGRenderer::GetDOD(a2, Input);
    v14 = v13;
    if ((*(int (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) < 1)
      return DOD;
    v6 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v7 = DOD;
    v8 = v14;
    return HGRectGrow(v7, v8, v6);
  }
  if (a3 == 1)
  {
    v4 = *(_QWORD *)&a4.var2;
    v5 = *(_QWORD *)&a4.var0;
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = v5;
    v8 = v4;
    return HGRectGrow(v7, v8, v6);
  }
  return 0;
}

void HgcSMAABlend::~HgcSMAABlend(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65357F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65357F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcSMAABlend::SetParameter(HgcSMAABlend *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcSMAABlend::GetParameter(HgcSMAABlend *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

void HGAntiAlias::HGAntiAlias(HGNode *a1, int a2)
{
  uint64_t v3;

  HGNode::HGNode(a1);
  *(_QWORD *)v3 = off_1E6535A40;
  *(_QWORD *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 416) = 1028443341;
  *(_DWORD *)(v3 + 420) = a2;
}

void HGAntiAlias::~HGAntiAlias(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6535A40;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6535A40;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGAntiAlias::SetParameter(HGAntiAlias *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 || *((float *)this + 104) == a3)
    return 0;
  *((float *)this + 104) = a3;
  return 1;
}

HGNode *HGAntiAlias::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGColorConform *v5;
  int v6;
  int v7;
  HGNode *v8;
  uint64_t v9;
  HGNode *v10;
  unsigned __int8 v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t LUTCache;
  uint64_t NewLUT;
  uint64_t v16;
  HGBitmapLoader *v17;
  HGBitmapLoader *v18;
  HGSMAAPatternSearch *v19;
  HGSMAAPatternSearch *v20;
  HGNode *v21;
  uint64_t v22;
  HGNode *v23;
  HGNode *v24;

  Input = HGRenderer::GetInput(a2, this, 0);
  v5 = (HGColorConform *)HGObject::operator new(0x320uLL);
  HGColorConform::HGColorConform(v5);
  (*(void (**)(HGColorConform *, _QWORD, HGNode *))(*(_QWORD *)v5 + 120))(v5, 0, Input);
  if (*((_DWORD *)this + 105) == 1)
    v6 = 3;
  else
    v6 = 0;
  if (*((_DWORD *)this + 105) == 1)
    v7 = 3;
  else
    v7 = 1;
  HGColorConform::SetConversion((uint64_t)v5, v6, 8, 0, v6, 1, v7);
  v8 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v8);
  *(_QWORD *)v8 = off_1E6535350;
  v9 = operator new();
  *(_QWORD *)v9 = 0;
  *(_QWORD *)(v9 + 8) = 0;
  *(_OWORD *)(v9 + 16) = xmmword_1B3050E20;
  *(_OWORD *)(v9 + 32) = xmmword_1B3050F70;
  *(_OWORD *)(v9 + 48) = xmmword_1B30520F0;
  *(_OWORD *)(v9 + 64) = xmmword_1B3523CF0;
  *(_OWORD *)(v9 + 80) = xmmword_1B3050F80;
  *((_QWORD *)v8 + 51) = v9;
  (*(void (**)(HGNode *, _QWORD, uint64_t))(*(_QWORD *)v8 + 136))(v8, 0, 1);
  *((_DWORD *)v8 + 4) |= 0x601u;
  (*(void (**)(HGNode *, _QWORD, HGColorConform *))(*(_QWORD *)v8 + 120))(v8, 0, v5);
  (*(void (**)(HGNode *, _QWORD, float, float, float, float))(*(_QWORD *)v8 + 96))(v8, 0, *((float *)this + 104), *((float *)this + 104), *((float *)this + 104), *((float *)this + 104));
  v10 = (HGNode *)*((_QWORD *)this + 51);
  if (v10 != v8)
  {
    if (v10)
      (*(void (**)(HGNode *))(*(_QWORD *)v10 + 24))(v10);
    *((_QWORD *)this + 51) = v8;
    (*(void (**)(HGNode *))(*(_QWORD *)v8 + 16))(v8);
  }
  v12 = (_DWORD *)operator new();
  *(_QWORD *)v12 = &off_1E6535D30;
  v12[2] = 0;
  v13 = (_DWORD *)operator new();
  *(_QWORD *)v13 = &off_1E6535D30;
  v13[2] = 1;
  LUTCache = HGLUTCacheManager::getLUTCache(*((_QWORD *)a2 + 69), (unint64_t)&HGAntiAlias::GetOutput(HGRenderer *)::lutFactory);
  NewLUT = HGLUTCache::getNewLUT(LUTCache, (uint64_t)v12);
  v16 = HGLUTCache::getNewLUT(LUTCache, (uint64_t)v13);
  (*(void (**)(_DWORD *))(*(_QWORD *)v12 + 8))(v12);
  (*(void (**)(_DWORD *))(*(_QWORD *)v13 + 8))(v13);
  v17 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v17, (HGBitmap *)NewLUT);
  v18 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v18, (HGBitmap *)v16);
  v19 = (HGSMAAPatternSearch *)HGObject::operator new(0x1C0uLL);
  HGSMAAPatternSearch::HGSMAAPatternSearch(v19);
  (*(void (**)(HGSMAAPatternSearch *, _QWORD, HGNode *))(*(_QWORD *)v19 + 120))(v19, 0, v8);
  (*(void (**)(HGSMAAPatternSearch *, uint64_t, HGBitmapLoader *))(*(_QWORD *)v19 + 120))(v19, 1, v17);
  (*(void (**)(HGSMAAPatternSearch *, uint64_t, HGBitmapLoader *))(*(_QWORD *)v19 + 120))(v19, 2, v18);
  *((_OWORD *)v19 + 26) = *(_OWORD *)(NewLUT + 20);
  *((_OWORD *)v19 + 27) = *(_OWORD *)(v16 + 20);
  v20 = (HGSMAAPatternSearch *)*((_QWORD *)this + 51);
  if (v20 != v19)
  {
    if (v20)
      (*(void (**)(HGSMAAPatternSearch *))(*(_QWORD *)v20 + 24))(v20);
    *((_QWORD *)this + 51) = v19;
    (*(void (**)(HGSMAAPatternSearch *))(*(_QWORD *)v19 + 16))(v19);
  }
  v21 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v21);
  *(_QWORD *)v21 = off_1E65357F0;
  v22 = operator new();
  *(_OWORD *)v22 = xmmword_1B3050FF0;
  *(_OWORD *)(v22 + 16) = xmmword_1B3050F70;
  *(_OWORD *)(v22 + 32) = xmmword_1B30537E0;
  *(_OWORD *)(v22 + 48) = xmmword_1B30537D0;
  *(_QWORD *)(v22 + 64) = 0;
  *(_QWORD *)(v22 + 72) = 0;
  *(_OWORD *)(v22 + 80) = xmmword_1B304F240;
  *(_OWORD *)(v22 + 96) = xmmword_1B304F230;
  *(_OWORD *)(v22 + 112) = xmmword_1B3525F00;
  *(_OWORD *)(v22 + 128) = xmmword_1B30520F0;
  *((_QWORD *)v21 + 51) = v22;
  (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v21 + 136))(v21, 1, 1);
  (*(void (**)(HGNode *, _QWORD, uint64_t))(*(_QWORD *)v21 + 136))(v21, 0, 1);
  *((_DWORD *)v21 + 4) |= 0x601u;
  *(_QWORD *)v21 = off_1E6535FE0;
  HGNode::SetInput(v21, 0, Input);
  (*(void (**)(HGNode *, uint64_t, HGSMAAPatternSearch *))(*(_QWORD *)v21 + 120))(v21, 1, v19);
  v23 = (HGNode *)*((_QWORD *)this + 51);
  v24 = v21;
  if (v23 != v21)
  {
    if (v23)
      (*(void (**)(HGNode *))(*(_QWORD *)v23 + 24))(v23);
    *((_QWORD *)this + 51) = v21;
    (*(void (**)(HGNode *))(*(_QWORD *)v21 + 16))(v21);
    v24 = (HGNode *)*((_QWORD *)this + 51);
  }
  (*(void (**)(HGNode *))(*(_QWORD *)v21 + 24))(v21);
  (*(void (**)(HGSMAAPatternSearch *))(*(_QWORD *)v19 + 24))(v19);
  if (v18)
    (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v18 + 24))(v18);
  if (v17)
    (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v17 + 24))(v17);
  (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  (*(void (**)(uint64_t))(*(_QWORD *)NewLUT + 24))(NewLUT);
  (*(void (**)(HGNode *))(*(_QWORD *)v8 + 24))(v8);
  (*(void (**)(HGColorConform *))(*(_QWORD *)v5 + 24))(v5);
  return v24;
}

void sub_1B2B8BEFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  HGObject::operator delete(v8);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGAntiAliasLUTEntryFactory::~HGAntiAliasLUTEntryFactory(HGAntiAliasLUTEntryFactory *this)
{
  JUMPOUT(0x1B5E29170);
}

_QWORD *HGAntiAliasLUTEntryFactory::createLUTEntry(uint64_t a1, const void *a2, uint64_t a3)
{
  _QWORD *v5;

  v5 = (_QWORD *)operator new();
  HGAntiAliasLUTEntry::HGAntiAliasLUTEntry(v5, a2, a3);
  return v5;
}

void sub_1B2B8C0F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0xA1C40987D6AD5);
  _Unwind_Resume(a1);
}

double HgcSMAAPatternSearch::State::State(HgcSMAAPatternSearch::State *this)
{
  double result;

  *(_OWORD *)this = xmmword_1B3052100;
  *((_OWORD *)this + 1) = xmmword_1B3525F10;
  *((_OWORD *)this + 2) = xmmword_1B3525F20;
  *((_OWORD *)this + 3) = xmmword_1B3525F30;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_OWORD *)this + 5) = xmmword_1B3525F40;
  *((_OWORD *)this + 6) = xmmword_1B3524190;
  *((_OWORD *)this + 7) = xmmword_1B3525F50;
  *((_OWORD *)this + 8) = xmmword_1B3525F60;
  *((_OWORD *)this + 9) = xmmword_1B3525F70;
  *((_OWORD *)this + 10) = xmmword_1B3052980;
  *((_OWORD *)this + 11) = xmmword_1B304F230;
  *((_OWORD *)this + 12) = xmmword_1B3050E20;
  *((_OWORD *)this + 13) = xmmword_1B304F240;
  *((_OWORD *)this + 14) = xmmword_1B3050F70;
  *((_OWORD *)this + 15) = xmmword_1B30510C0;
  *((_OWORD *)this + 16) = xmmword_1B3053870;
  *((_OWORD *)this + 17) = xmmword_1B3525F80;
  *((_OWORD *)this + 18) = xmmword_1B30520F0;
  *((_OWORD *)this + 19) = xmmword_1B3525F90;
  *((_OWORD *)this + 20) = xmmword_1B3525FA0;
  *((_OWORD *)this + 21) = xmmword_1B3525FB0;
  *((_OWORD *)this + 22) = xmmword_1B3525FC0;
  *((_OWORD *)this + 23) = xmmword_1B3053860;
  *((_OWORD *)this + 24) = xmmword_1B3525FD0;
  *((_OWORD *)this + 25) = xmmword_1B3052990;
  *((_OWORD *)this + 26) = xmmword_1B3525FE0;
  *((_OWORD *)this + 27) = xmmword_1B3525FF0;
  *((_OWORD *)this + 28) = xmmword_1B3526000;
  *((_OWORD *)this + 29) = xmmword_1B3526010;
  *((_OWORD *)this + 30) = xmmword_1B3526020;
  *((_OWORD *)this + 31) = xmmword_1B3526030;
  *((_OWORD *)this + 32) = xmmword_1B3526040;
  *((_OWORD *)this + 33) = xmmword_1B3526050;
  *((_OWORD *)this + 34) = xmmword_1B3526060;
  *((_OWORD *)this + 35) = xmmword_1B3526070;
  *((_OWORD *)this + 36) = xmmword_1B3526080;
  *((_OWORD *)this + 37) = xmmword_1B3526090;
  *((_OWORD *)this + 38) = xmmword_1B35260A0;
  *((_OWORD *)this + 39) = xmmword_1B35260B0;
  *((_OWORD *)this + 40) = xmmword_1B35260C0;
  *((_OWORD *)this + 41) = xmmword_1B35260D0;
  *((_OWORD *)this + 42) = xmmword_1B35260E0;
  *((_OWORD *)this + 43) = xmmword_1B3052B10;
  *((_OWORD *)this + 44) = xmmword_1B35260F0;
  *((_OWORD *)this + 45) = xmmword_1B3526100;
  *((_OWORD *)this + 46) = xmmword_1B3526110;
  *((_OWORD *)this + 47) = xmmword_1B3526120;
  *((_OWORD *)this + 48) = xmmword_1B3526130;
  *((_OWORD *)this + 49) = xmmword_1B3526140;
  *((_OWORD *)this + 50) = xmmword_1B3526150;
  *((_OWORD *)this + 51) = xmmword_1B3526160;
  *((_OWORD *)this + 52) = xmmword_1B3526170;
  *((_OWORD *)this + 53) = xmmword_1B3526180;
  *((_OWORD *)this + 54) = xmmword_1B3526190;
  *((_OWORD *)this + 55) = xmmword_1B35261A0;
  *((_OWORD *)this + 56) = xmmword_1B35261B0;
  *((_OWORD *)this + 57) = xmmword_1B3052ED0;
  *((_OWORD *)this + 58) = xmmword_1B3052D60;
  *((_OWORD *)this + 59) = xmmword_1B35261C0;
  *((_OWORD *)this + 60) = xmmword_1B35261D0;
  *((_OWORD *)this + 61) = xmmword_1B35261E0;
  *((_OWORD *)this + 62) = xmmword_1B35261F0;
  *((_OWORD *)this + 63) = xmmword_1B3526200;
  *((_OWORD *)this + 64) = xmmword_1B3526210;
  *((_OWORD *)this + 65) = xmmword_1B3526220;
  *((_OWORD *)this + 66) = xmmword_1B3526230;
  *((_OWORD *)this + 67) = xmmword_1B3526240;
  *((_OWORD *)this + 68) = xmmword_1B3526250;
  *((_OWORD *)this + 69) = xmmword_1B3526260;
  *((_OWORD *)this + 70) = xmmword_1B3526270;
  *((_OWORD *)this + 71) = xmmword_1B3526280;
  *((_OWORD *)this + 72) = xmmword_1B3526290;
  *((_OWORD *)this + 73) = xmmword_1B35262A0;
  *((_OWORD *)this + 74) = xmmword_1B35262B0;
  *((_OWORD *)this + 75) = xmmword_1B35262C0;
  *((_OWORD *)this + 76) = xmmword_1B35262D0;
  *((_OWORD *)this + 77) = xmmword_1B35262E0;
  *((_OWORD *)this + 78) = xmmword_1B35262F0;
  *((_OWORD *)this + 79) = xmmword_1B3526300;
  *((_OWORD *)this + 80) = xmmword_1B3526310;
  *((_OWORD *)this + 81) = xmmword_1B3526320;
  *((_OWORD *)this + 82) = xmmword_1B3526330;
  *((_OWORD *)this + 83) = xmmword_1B3526340;
  *((_OWORD *)this + 84) = xmmword_1B3526350;
  *(_QWORD *)&result = 3196059648;
  *((_OWORD *)this + 85) = xmmword_1B3053160;
  return result;
}

void HGAntiAliasLUTInfo::~HGAntiAliasLUTInfo(HGAntiAliasLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t HGAntiAliasLUTInfo::duplicate(HGAntiAliasLUTInfo *this)
{
  uint64_t result;
  int v3;

  result = operator new();
  v3 = *((_DWORD *)this + 2);
  *(_QWORD *)result = &off_1E6535D30;
  *(_DWORD *)(result + 8) = v3;
  return result;
}

_DWORD *HGAntiAliasLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  _DWORD *result;

  if (!lpsrc)
    return 0;
  if (result)
    return (_DWORD *)(*(_DWORD *)(a1 + 8) == result[2]);
  return result;
}

void HGSMAAPatternSearch::HGSMAAPatternSearch(HGSMAAPatternSearch *this)
{
  _QWORD *v2;
  HgcSMAAPatternSearch::State *v3;
  double v4;
  uint64_t v5;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65355A0;
  v3 = (HgcSMAAPatternSearch::State *)operator new();
  v4 = HgcSMAAPatternSearch::State::State(v3);
  *((_QWORD *)this + 51) = v5;
  (*(void (**)(HGSMAAPatternSearch *, _QWORD, uint64_t, double))(*(_QWORD *)this + 136))(this, 0, 1, v4);
  (*(void (**)(HGSMAAPatternSearch *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 5);
  (*(void (**)(HGSMAAPatternSearch *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 2, 5);
  *((_DWORD *)this + 4) |= 0x601u;
  *(_QWORD *)this = off_1E6535D78;
  HGNode::SetFlags((HGNode *)this, 1, 4);
  (*(void (**)(HGSMAAPatternSearch *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 2, 4);
}

void sub_1B2B8C638(_Unwind_Exception *a1)
{
  HGNode *v1;

  HgcSMAAPatternSearch::~HgcSMAAPatternSearch(v1);
  _Unwind_Resume(a1);
}

void sub_1B2B8C64C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSMAAPatternSearch::~HGSMAAPatternSearch(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65355A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4040DFEAD7);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65355A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4040DFEAD7);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGSMAAPatternSearch::GetDOD(HGSMAAPatternSearch *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HGSMAAPatternSearch::GetROI(HGSMAAPatternSearch *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a3 == 2)
    return *((_QWORD *)this + 54);
  if (a3 == 1)
    return *((_QWORD *)this + 52);
  if (a3)
    return 0;
  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  v6 = HGRectMake4i(0xFFFFFFF5, 0xFFFFFFF5, 0xCu, 0xCu);
  return HGRectGrow(v5, v4, v6);
}

void HGSMAABlend::~HGSMAABlend(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65357F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65357F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGSMAABlend::GetDOD(HGSMAABlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HGSMAABlend::GetROI(HGSMAABlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3 == 1)
  {
    v6 = 1;
    v7 = 1;
    v8 = 0;
    v9 = 0;
    goto LABEL_5;
  }
  if (!a3)
  {
    v6 = -1;
    v7 = -1;
    v8 = 1;
    v9 = 1;
LABEL_5:
    v10 = HGRectMake4i(v6, v7, v8, v9);
    return HGRectGrow(v5, v4, v10);
  }
  return 0;
}

_QWORD *HGAntiAliasLUTEntry::HGAntiAliasLUTEntry(_QWORD *a1, const void *a2, uint64_t a3)
{
  _QWORD *v5;
  HGBitmap **v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  HGBitmap *v15;
  __n128 v16;
  HGBitmap *v17;
  HGBitmap *v18;
  dispatch_group_t *v20;

  v5 = HGLUTCache::LUTEntry::LUTEntry(a1, (uint64_t)a2, a3);
  *v5 = &off_1E6536248;
  v5[3] = 0;
  v6 = (HGBitmap **)(v5 + 3);
  v5[4] = 0;
  if (a2)
  {
    if (v7)
    {
      v8 = v7[2];
      if (v8 == 1)
      {
        v9 = HGRectMake4f(1107558400, 0.0, 0.0, 66.0, 33.0);
        v11 = v14;
        v12 = &searchTexBytes;
        v13 = 1;
      }
      else if (v8)
      {
        v13 = 0;
        v12 = 0;
        v9 = 0;
        v11 = 0;
      }
      else
      {
        v9 = HGRectMake4f(1141637120, 0.0, 0.0, 160.0, 560.0);
        v11 = v10;
        v12 = &areaTexBytes;
        v13 = 10;
      }
      v15 = (HGBitmap *)HGObject::operator new(0x80uLL);
      v16 = HGBitmap::HGBitmap(v15, v9, v11, v13);
      v17 = *v6;
      if (*v6 == v15)
      {
        if (v15)
          (*(void (**)(HGBitmap *, __n128))(*(_QWORD *)v15 + 24))(v15, v16);
      }
      else
      {
        if (v17)
          (*(void (**)(HGBitmap *, __n128))(*(_QWORD *)v17 + 24))(v17, v16);
        *v6 = v15;
      }
      v18 = (HGBitmap *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap((uint64_t)v18, v9, v11, v13, (uint64_t)v12);
      HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)&v20);
      HGRenderUtils::BufferCopier::execute(&v20, *v6, v18);
      HGRenderUtils::BufferCopier::~BufferCopier((HGRenderUtils::BufferCopier *)&v20);
      if (v18)
        (*(void (**)(HGBitmap *))(*(_QWORD *)v18 + 24))(v18);
    }
  }
  return a1;
}

void sub_1B2B8CA94(_Unwind_Exception *a1)
{
  HGLUTCache::LUTEntry *v1;
  _QWORD *v2;
  uint64_t v4;

  v4 = *((_QWORD *)v1 + 4);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  if (*v2)
    (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 24))(*v2);
  HGLUTCache::LUTEntry::~LUTEntry(v1);
  _Unwind_Resume(a1);
}

void HGAntiAliasLUTEntry::~HGAntiAliasLUTEntry(HGAntiAliasLUTEntry *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6536248;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGLUTCache::LUTEntry::~LUTEntry(this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6536248;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGLUTCache::LUTEntry::~LUTEntry(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t HGAntiAliasLUTEntry::GetBitmap(HGAntiAliasLUTEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  HGGPURenderer *v4;
  HGMetalTexture *v5;
  char *v6;
  uint64_t MetalContext;
  HGMetalTexture *v8;
  HGMetalTexture *v10;

  v2 = *((_QWORD *)this + 2);
  if (!v2
    || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 304))(v2) & 1) != 0
    || ((v3 = *((_QWORD *)this + 2)) == 0
      ? (v4 = 0)
  {
    v5 = (HGMetalTexture *)*((_QWORD *)this + 3);
    v6 = (char *)this + 24;
    if (!v5)
      return *(_QWORD *)v6;
    goto LABEL_14;
  }
  v6 = (char *)this + 32;
  v5 = (HGMetalTexture *)*((_QWORD *)this + 4);
  if (v5)
    goto LABEL_14;
  MetalContext = HGGPURenderer::GetMetalContext(v4);
  HGMetalTexture::createWithCopy(*(void **)(*(_QWORD *)(MetalContext + 16) + 16), 0, *((_QWORD *)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 20), *(_QWORD *)(*((_QWORD *)this + 3) + 28), 0, 0, &v10);
  v8 = (HGMetalTexture *)*((_QWORD *)this + 4);
  v5 = v10;
  if (v8 == v10)
  {
    if (!v8)
      return *(_QWORD *)v6;
    (*(void (**)(_QWORD))(*(_QWORD *)v8 + 24))(*((_QWORD *)this + 4));
    v5 = *(HGMetalTexture **)v6;
    if (!*(_QWORD *)v6)
      return *(_QWORD *)v6;
LABEL_14:
    (*(void (**)(HGMetalTexture *))(*(_QWORD *)v5 + 16))(v5);
    return *(_QWORD *)v6;
  }
  if (v8)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v8 + 24))(*((_QWORD *)this + 4));
    v5 = v10;
  }
  *(_QWORD *)v6 = v5;
  if (v5)
    goto LABEL_14;
  return *(_QWORD *)v6;
}

void sub_1B2B8CD58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

const char *MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::label_A()
{
  return "MinMax<MIN,X>";
}

const char *MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::label_A()
{
  return "MinMax<MIN,Y>";
}

const char *MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::label_A()
{
  return "MinMax<MAX,X>";
}

const char *MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::label_A()
{
  return "MinMax<MAX,Y>";
}

void HGMinMax::HGMinMax(HGMinMax *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E6536288;
  *(_QWORD *)(v1 + 416) = 0;
  *(_QWORD *)(v1 + 424) = 0;
  *(_QWORD *)(v1 + 408) = 0;
  *(_DWORD *)(v1 + 432) = 0;
}

void HGMinMax::~HGMinMax(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6536288;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E6536288;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGMinMax::SetParameter(HGMinMax *this, int a2, float a3, float a4, float a5, float a6)
{
  unsigned int v6;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;

  if (a2 == 1)
  {
    v8 = vcvtms_s32_f32(a3);
    v9 = 0xFFFFFFFFLL;
    if ((v8 & 0x80000000) != 0)
      return v9;
    v10 = vcvtms_s32_f32(a4);
    if ((v10 & 0x80000000) != 0)
      return v9;
    if (*((_DWORD *)this + 107) == v8 && *((_DWORD *)this + 108) == v10)
      return 0;
    *((_DWORD *)this + 107) = v8;
    *((_DWORD *)this + 108) = v10;
  }
  else
  {
    if (a2)
      return 0xFFFFFFFFLL;
    v6 = vcvtms_u32_f32(a3);
    if (*((_DWORD *)this + 106) == v6)
      return 0;
    *((_DWORD *)this + 106) = v6;
  }
  return 1;
}

uint64_t HGMinMax::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGNode *v5;
  HGNode **v6;
  HGNode *v7;
  HGNode *v8;

  Input = HGRenderer::GetInput(a2, this, 0);
  v5 = Input;
  if (Input)
  {
    (*(void (**)(HGNode *))(*(_QWORD *)Input + 16))(Input);
    v6 = (HGNode **)((char *)this + 408);
    v7 = (HGNode *)*((_QWORD *)this + 51);
    if (v7 == v5)
    {
      (*(void (**)(HGNode *))(*(_QWORD *)v5 + 24))(v5);
      v5 = *v6;
      v8 = (HGNode *)*((_QWORD *)this + 52);
      if (v8 == *v6)
        goto LABEL_13;
      goto LABEL_9;
    }
  }
  else
  {
    v6 = (HGNode **)((char *)this + 408);
    v7 = (HGNode *)*((_QWORD *)this + 51);
    if (!v7)
    {
      v5 = 0;
      v8 = (HGNode *)*((_QWORD *)this + 52);
      if (!v8)
        goto LABEL_13;
      goto LABEL_9;
    }
  }
  if (v7)
    (*(void (**)(HGNode *))(*(_QWORD *)v7 + 24))(v7);
  *v6 = v5;
  v8 = (HGNode *)*((_QWORD *)this + 52);
  if (v8 != v5)
  {
LABEL_9:
    if (v8)
    {
      (*(void (**)(HGNode *))(*(_QWORD *)v8 + 24))(v8);
      v5 = *v6;
    }
    *((_QWORD *)this + 52) = v5;
    if (v5)
      (*(void (**)(HGNode *))(*(_QWORD *)v5 + 16))(v5);
  }
LABEL_13:
  if (*((_DWORD *)this + 107) || *((_DWORD *)this + 108))
    HGMinMax::_buildGraph((HGMinMax *)this, a2);
  return *((_QWORD *)this + 52);
}

void sub_1B2B8D028(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGMinMax::_buildGraph(HGMinMax *this, HGRenderer *a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  HGNode *v8;
  uint64_t (**v9)();
  HGNode *v10;
  int v11;
  HGNode *v12;
  uint64_t (**v13)();
  uint64_t (**v14)();
  HGXForm *v15;
  HGTransform *v16;
  HGXForm *v17;
  HGNode *v18;
  HGXForm *v19;
  HGTransform *v20;
  HGXForm *v21;

  (*(void (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 1);
  result = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 2);
  if (*((_DWORD *)this + 107))
  {
    result = (*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2);
    v5 = result;
    if (*((_DWORD *)this + 108))
      goto LABEL_3;
LABEL_7:
    v6 = 0;
    if (*((_DWORD *)this + 107))
      goto LABEL_4;
LABEL_8:
    v8 = 0;
    goto LABEL_15;
  }
  v5 = 0;
  if (!*((_DWORD *)this + 108))
    goto LABEL_7;
LABEL_3:
  result = (*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2);
  v6 = result;
  if (!*((_DWORD *)this + 107))
    goto LABEL_8;
LABEL_4:
  v7 = *((_DWORD *)this + 106);
  v8 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v8);
  if (v7)
    v9 = off_1E6536758;
  else
    v9 = off_1E65364F0;
  *(_QWORD *)v8 = v9;
  *((_DWORD *)v8 + 4) = *((_DWORD *)v8 + 4) & 0xFFFFF9FF | 0x400;
  ((void (*)(uint64_t, int, float))v9[12])((uint64_t)v8, 0, (float)*((unsigned int *)this + 107));
  (*(void (**)(HGNode *))(*(_QWORD *)v8 + 16))(v8);
  (*(void (**)(HGNode *, _QWORD, _QWORD))(*(_QWORD *)v8 + 120))(v8, 0, *((_QWORD *)this + 52));
  v10 = (HGNode *)*((_QWORD *)this + 52);
  if (v10 != v8)
  {
    if (v10)
      (*(void (**)(HGNode *))(*(_QWORD *)v10 + 24))(v10);
    *((_QWORD *)this + 52) = v8;
    (*(void (**)(HGNode *))(*(_QWORD *)v8 + 16))(v8);
  }
  result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v8 + 24))(v8);
LABEL_15:
  if (*((_DWORD *)this + 108))
  {
    v11 = *((_DWORD *)this + 106);
    if (v6)
    {
      if (v11)
      {
        v12 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v12);
        v13 = off_1E6536758;
      }
      else
      {
        v12 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v12);
        v13 = off_1E65364F0;
      }
      *(_QWORD *)v12 = v13;
      *((_DWORD *)v12 + 4) = *((_DWORD *)v12 + 4) & 0xFFFFF9FF | 0x400;
      v15 = (HGXForm *)HGObject::operator new(0x210uLL);
      HGXForm::HGXForm(v15);
      v16 = (HGTransform *)HGObject::operator new(0x90uLL);
      HGTransform::HGTransform(v16);
      (*(void (**)(HGTransform *, double, double, double, double))(*(_QWORD *)v16 + 128))(v16, 90.0, 0.0, 0.0, 1.0);
      (*(void (**)(HGXForm *, HGTransform *))(*(_QWORD *)v15 + 576))(v15, v16);
      (*(void (**)(HGXForm *))(*(_QWORD *)v15 + 16))(v15);
      (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v15 + 120))(v15, 0, *((_QWORD *)this + 52));
      v17 = (HGXForm *)*((_QWORD *)this + 52);
      if (v17 != v15)
      {
        if (v17)
          (*(void (**)(HGXForm *))(*(_QWORD *)v17 + 24))(v17);
        *((_QWORD *)this + 52) = v15;
        (*(void (**)(HGXForm *))(*(_QWORD *)v15 + 16))(v15);
      }
      (*(void (**)(HGXForm *))(*(_QWORD *)v15 + 24))(v15);
      (*(void (**)(HGTransform *))(*(_QWORD *)v16 + 24))(v16);
      (*(void (**)(HGXForm *))(*(_QWORD *)v15 + 24))(v15);
      v14 = *(uint64_t (***)())v12;
    }
    else
    {
      if (v11)
      {
        v12 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v12);
        v14 = off_1E6536C28;
      }
      else
      {
        v12 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v12);
        v14 = off_1E65369C0;
      }
      *(_QWORD *)v12 = v14;
      *((_DWORD *)v12 + 4) = *((_DWORD *)v12 + 4) & 0xFFFFF9FF | 0x400;
    }
    ((void (*)(HGNode *, _QWORD, float, float, float, float))v14[12])(v12, 0, (float)*((unsigned int *)this + 108), 0.0, 0.0, 0.0);
    (*(void (**)(HGNode *))(*(_QWORD *)v12 + 16))(v12);
    (*(void (**)(HGNode *, _QWORD, _QWORD))(*(_QWORD *)v12 + 120))(v12, 0, *((_QWORD *)this + 52));
    v18 = (HGNode *)*((_QWORD *)this + 52);
    if (v18 != v12)
    {
      if (v18)
        (*(void (**)(HGNode *))(*(_QWORD *)v18 + 24))(v18);
      *((_QWORD *)this + 52) = v12;
      (*(void (**)(HGNode *))(*(_QWORD *)v12 + 16))(v12);
    }
    result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v12 + 24))(v12);
    if (v6)
    {
      v19 = (HGXForm *)HGObject::operator new(0x210uLL);
      HGXForm::HGXForm(v19);
      v20 = (HGTransform *)HGObject::operator new(0x90uLL);
      HGTransform::HGTransform(v20);
      (*(void (**)(HGTransform *, double, double, double, double))(*(_QWORD *)v20 + 128))(v20, -90.0, 0.0, 0.0, 1.0);
      (*(void (**)(HGXForm *, HGTransform *))(*(_QWORD *)v19 + 576))(v19, v20);
      (*(void (**)(HGXForm *))(*(_QWORD *)v19 + 16))(v19);
      (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v19 + 120))(v19, 0, *((_QWORD *)this + 52));
      v21 = (HGXForm *)*((_QWORD *)this + 52);
      if (v21 != v19)
      {
        if (v21)
          (*(void (**)(HGXForm *))(*(_QWORD *)v21 + 24))(v21);
        *((_QWORD *)this + 52) = v19;
        (*(void (**)(HGXForm *))(*(_QWORD *)v19 + 16))(v19);
      }
      (*(void (**)(HGXForm *))(*(_QWORD *)v19 + 24))(v19);
      (*(void (**)(HGTransform *))(*(_QWORD *)v20 + 24))(v20);
      result = (*(uint64_t (**)(HGXForm *))(*(_QWORD *)v19 + 24))(v19);
    }
  }
  else
  {
    v12 = 0;
  }
  if (v5)
    result = (*(uint64_t (**)(HGNode *, _QWORD, uint64_t))(*(_QWORD *)v8 + 136))(v8, 0, 2);
  if (v6)
  {
    (*(void (**)(HGNode *, _QWORD, uint64_t))(*(_QWORD *)v12 + 136))(v12, 0, 2);
  }
  else if (!v12)
  {
    goto LABEL_46;
  }
  result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v12 + 24))(v12);
LABEL_46:
  if (v8)
    return (*(uint64_t (**)(HGNode *))(*(_QWORD *)v8 + 24))(v8);
  return result;
}

void sub_1B2B8D558(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::~MMNode(HGNode *a1)
{
  void *v1;

  HGNode::~HGNode(a1);
  HGObject::operator delete(v1);
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::SetParameter(uint64_t a1, int a2, float a3)
{
  unsigned int v4;

  if (a2)
    return 0xFFFFFFFFLL;
  v4 = vcvtms_s32_f32(a3);
  if ((v4 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 408) == v4)
    return 0;
  *(_DWORD *)(a1 + 408) = v4;
  return 1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t *v7;
  uint64_t v8;
  float32x4_t *v9;
  uint64_t v10;
  float32x4_t *v11;
  uint64_t v12;
  float32x4_t *v13;
  float32x4_t *v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;

  v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2);
    if ((int)v3 >= 1)
    {
      v4 = 0;
      v5 = *(int *)(a2 + 24);
      v6 = *(int *)(a2 + 88);
      v7 = *(float32x4_t **)(a2 + 80);
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v7 - 1;
      v10 = 16 * v6;
      v11 = v7 + 1;
      do
      {
        v12 = 0;
        v13 = v11;
        v14 = v9;
        do
        {
          v15 = v7[v12];
          v16 = *(unsigned int *)(a1 + 408);
          if ((int)v16 >= 1)
          {
            v17 = v13;
            v18 = v14;
            do
            {
              v19 = *v17++;
              v20 = v19;
              v21 = *v18--;
              v15 = vminq_f32(vminq_f32(v15, v20), v21);
              --v16;
            }
            while (v16);
          }
          *(float32x4_t *)(v8 + 16 * v12++) = v15;
          ++v14;
          ++v13;
        }
        while (v12 != v3);
        v7 += v6;
        v8 += 16 * v5;
        ++v4;
        v9 = (float32x4_t *)((char *)v9 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
      }
      while (v4 != v2);
    }
  }
  return 0;
}

const char *MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::GetProgram(int a1, HGRenderer *this)
{
  unsigned int Target;
  int v4;
  const char *v5;

  Target = HGRenderer::GetTarget(this, 393216);
  v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)this + 128))(this, 19);
  v5 = "//Metal1.0     \n"
       "//LEN=00000004e7\n"
       "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
       "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
       "                                  texture2d< float >      hg_Texture0 [[ texture(0) ]],\n"
       "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
       "{\n"
       "    // convolution radius\n"
       "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
       "    \n"
       "    // Accumulator\n"
       "    float4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
       "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
       "    \n"
       "    for (int16_t k {1}; k <= radius; ++k)\n"
       "    {\n"
       "        const float uPos {frag._texCoord0.x + k};\n"
       "        const float uNeg {frag._texCoord0.x - k};\n"
       "        const float v {frag._texCoord0.y};\n"
       "        \n"
       "        float4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(uPos, v))};\n"
       "        float4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(uNeg, v))};\n"
       "            \n"
       "        R0 = min(R0,R1);\n"
       "        R0 = min(R0,R2);\n"
       "    }\n"
       "    \n"
       "    FragmentOut out {static_cast<float4>(R0)};\n"
       "    return out;\n"
       "}\n"
       "//MD5=2a507d29:fd0172ea:c65d89d1:7ab9dcdb\n"
       "//SIG=00000000:00000000:00000000:00000000:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (v4 == 27)
    v5 = "//Metal1.0     \n"
         "//LEN=000000054e\n"
         "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
         "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< half >       hg_Texture0 [[ texture(0) ]],\n"
         "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
         "{\n"
         "    // convolution radius\n"
         "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
         "    \n"
         "    // Accumulator\n"
         "    half4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
         "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
         "    \n"
         "    for (int16_t k {1}; k <= radius; ++k)\n"
         "    {\n"
         "        const float uPos {frag._texCoord0.x + k};\n"
         "        const float uNeg {frag._texCoord0.x - k};\n"
         "        const float v {frag._texCoord0.y};\n"
         "        \n"
         "        half4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(uPos, v))};\n"
         "        half4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(uNeg, v))};\n"
         "\n"
         "        R0 = half4(min(R0.x,R1.x), min(R0.y,R1.y), min(R0.z,R1.z), min(R0.a,R1.a));\n"
         "        R0 = half4(min(R0.x,R2.x), min(R0.y,R2.y), min(R0.z,R2.z), min(R0.a,R2.a));\n"
         "    }\n"
         "    \n"
         "    FragmentOut out {static_cast<float4>(R0)};\n"
         "    return out;\n"
         "}\n"
         "//MD5=45a3d5e6:b2dbfac3:d747b97d:f2fc53a8\n"
         "//SIG=00000000:00000000:00000000:00000001:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (Target <= 0x60B0F)
    return 0;
  else
    return v5;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::BindTexture(int a1, HGHandler *this, uint64_t a3)
{
  HGHandler::TexCoord(this, a3, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)this + 72))(this, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)this + 56))(this, 0);
  return 0;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::GetOutput(uint64_t a1, uint64_t a2, char *a3)
{
  HGNode::SetParameter((HGNode *)a1, 0, (float)*(unsigned int *)(a1 + 408), 0.0, 0.0, 0.0, a3);
  return a1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(-*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408), 0);
  return HGRectGrow(a4, a5, v8);
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)0>::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(-*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408), 0);
  return HGRectGrow(a4, a5, v8);
}

void MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::~MMNode(HGNode *a1)
{
  void *v1;

  HGNode::~HGNode(a1);
  HGObject::operator delete(v1);
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::SetParameter(uint64_t a1, int a2, float a3)
{
  unsigned int v4;

  if (a2)
    return 0xFFFFFFFFLL;
  v4 = vcvtms_s32_f32(a3);
  if ((v4 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 408) == v4)
    return 0;
  *(_DWORD *)(a1 + 408) = v4;
  return 1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t *v7;
  uint64_t v8;
  float32x4_t *v9;
  uint64_t v10;
  float32x4_t *v11;
  uint64_t v12;
  float32x4_t *v13;
  float32x4_t *v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;

  v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2);
    if ((int)v3 >= 1)
    {
      v4 = 0;
      v5 = *(int *)(a2 + 24);
      v6 = *(int *)(a2 + 88);
      v7 = *(float32x4_t **)(a2 + 80);
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v7 - 1;
      v10 = 16 * v6;
      v11 = v7 + 1;
      do
      {
        v12 = 0;
        v13 = v11;
        v14 = v9;
        do
        {
          v15 = v7[v12];
          v16 = *(unsigned int *)(a1 + 408);
          if ((int)v16 >= 1)
          {
            v17 = v13;
            v18 = v14;
            do
            {
              v19 = *v17++;
              v20 = v19;
              v21 = *v18--;
              v15 = vmaxq_f32(vmaxq_f32(v15, v20), v21);
              --v16;
            }
            while (v16);
          }
          *(float32x4_t *)(v8 + 16 * v12++) = v15;
          ++v14;
          ++v13;
        }
        while (v12 != v3);
        v7 += v6;
        v8 += 16 * v5;
        ++v4;
        v9 = (float32x4_t *)((char *)v9 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
      }
      while (v4 != v2);
    }
  }
  return 0;
}

const char *MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::GetProgram(int a1, HGRenderer *this)
{
  unsigned int Target;
  int v4;
  const char *v5;

  Target = HGRenderer::GetTarget(this, 393216);
  v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)this + 128))(this, 19);
  v5 = "//Metal1.0     \n"
       "//LEN=00000004e7\n"
       "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
       "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
       "                                  texture2d< float >      hg_Texture0 [[ texture(0) ]],\n"
       "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
       "{\n"
       "    // convolution radius\n"
       "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
       "    \n"
       "    // Accumulator\n"
       "    float4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
       "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
       "    \n"
       "    for (int16_t k {1}; k <= radius; ++k)\n"
       "    {\n"
       "        const float uPos {frag._texCoord0.x + k};\n"
       "        const float uNeg {frag._texCoord0.x - k};\n"
       "        const float v {frag._texCoord0.y};\n"
       "        \n"
       "        float4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(uPos, v))};\n"
       "        float4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(uNeg, v))};\n"
       "            \n"
       "        R0 = max(R0,R1);\n"
       "        R0 = max(R0,R2);\n"
       "    }\n"
       "    \n"
       "    FragmentOut out {static_cast<float4>(R0)};\n"
       "    return out;\n"
       "}\n"
       "//MD5=057d1bde:ee1f0d66:240beb34:b82edddc\n"
       "//SIG=00000000:00000000:00000000:00000000:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (v4 == 27)
    v5 = "//Metal1.0     \n"
         "//LEN=000000054d\n"
         "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
         "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< half >       hg_Texture0 [[ texture(0) ]],\n"
         "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
         "{\n"
         "    // convolution radius\n"
         "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
         "    \n"
         "    // Accumulator\n"
         "    half4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
         "              float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
         "    \n"
         "    for (int16_t k {1}; k <= radius; ++k)\n"
         "    {\n"
         "        const float uPos {frag._texCoord0.x + k};\n"
         "        const float uNeg {frag._texCoord0.x - k};\n"
         "        const float v {frag._texCoord0.y};\n"
         "        \n"
         "        half4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(uPos, v))};\n"
         "        half4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(uNeg, v))};\n"
         "\n"
         "        R0 = half4(max(R0.x,R1.x), max(R0.y,R1.y), max(R0.z,R1.z), max(R0.a,R1.a));\n"
         "        R0 = half4(max(R0.x,R2.x), max(R0.y,R2.y), max(R0.z,R2.z), max(R0.a,R2.a));\n"
         "    }\n"
         "    \n"
         "    FragmentOut out {static_cast<float4>(R0)};\n"
         "    return out;\n"
         "}\n"
         "//MD5=cfa1a81a:a28a7961:458c8d2d:93677577\n"
         "//SIG=00000000:00000000:00000000:00000001:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (Target <= 0x60B0F)
    return 0;
  else
    return v5;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::BindTexture(int a1, HGHandler *this, uint64_t a3)
{
  HGHandler::TexCoord(this, a3, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)this + 72))(this, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)this + 56))(this, 0);
  return 0;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::GetOutput(uint64_t a1, uint64_t a2, char *a3)
{
  HGNode::SetParameter((HGNode *)a1, 0, (float)*(unsigned int *)(a1 + 408), 0.0, 0.0, 0.0, a3);
  return a1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(-*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408), 0);
  return HGRectGrow(a4, a5, v8);
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)0>::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(-*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408), 0);
  return HGRectGrow(a4, a5, v8);
}

void MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::~MMNode(HGNode *a1)
{
  void *v1;

  HGNode::~HGNode(a1);
  HGObject::operator delete(v1);
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::SetParameter(uint64_t a1, int a2, float a3)
{
  unsigned int v4;

  if (a2)
    return 0xFFFFFFFFLL;
  v4 = vcvtms_s32_f32(a3);
  if ((v4 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 408) == v4)
    return 0;
  *(_DWORD *)(a1 + 408) = v4;
  return 1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t *v10;
  float32x4_t *v11;
  uint64_t v12;
  float32x4_t *v13;
  float32x4_t *v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;

  v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2);
    if ((int)v3 >= 1)
    {
      v4 = 0;
      v5 = *(int *)(a2 + 88);
      v6 = *(int *)(a2 + 24);
      v7 = *(_QWORD *)(a2 + 80);
      v8 = *(_QWORD *)(a2 + 16);
      v9 = 16 * v5;
      v10 = (float32x4_t *)(v7 - 16 * v5);
      v11 = (float32x4_t *)(v7 + 16 * v5);
      do
      {
        v12 = 0;
        v13 = v11;
        v14 = v10;
        do
        {
          v15 = *(float32x4_t *)(v7 + 16 * v12);
          v16 = *(unsigned int *)(a1 + 408);
          if ((int)v16 >= 1)
          {
            v17 = v13;
            v18 = v14;
            do
            {
              v15 = vminq_f32(vminq_f32(v15, *v17), *v18);
              v18 -= v5;
              v17 = (float32x4_t *)((char *)v17 + v9);
              --v16;
            }
            while (v16);
          }
          *(float32x4_t *)(v8 + 16 * v12++) = v15;
          ++v14;
          ++v13;
        }
        while (v12 != v3);
        v7 += 16 * v5;
        v8 += 16 * v6;
        ++v4;
        v10 = (float32x4_t *)((char *)v10 + v9);
        v11 = (float32x4_t *)((char *)v11 + v9);
      }
      while (v4 != v2);
    }
  }
  return 0;
}

const char *MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::GetProgram(int a1, HGRenderer *this)
{
  unsigned int Target;
  int v4;
  const char *v5;

  Target = HGRenderer::GetTarget(this, 393216);
  v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)this + 128))(this, 19);
  v5 = "//Metal1.0     \n"
       "//LEN=00000004e7\n"
       "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
       "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
       "                                  texture2d< float >      hg_Texture0 [[ texture(0) ]],\n"
       "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
       "{\n"
       "    // convolution radius\n"
       "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
       "    \n"
       "    // Accumulator\n"
       "    float4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
       "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
       "    \n"
       "    for (int16_t k {1}; k <= radius; ++k)\n"
       "    {\n"
       "        const float uPos {frag._texCoord0.y + k};\n"
       "        const float uNeg {frag._texCoord0.y - k};\n"
       "        const float v {frag._texCoord0.x};\n"
       "        \n"
       "        float4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(v, uPos))};\n"
       "        float4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(v, uNeg))};\n"
       "            \n"
       "        R0 = min(R0,R1);\n"
       "        R0 = min(R0,R2);\n"
       "    }\n"
       "    \n"
       "    FragmentOut out {static_cast<float4>(R0)};\n"
       "    return out;\n"
       "}\n"
       "//MD5=3726e26e:551a7f4a:f371f4cb:58ef313b\n"
       "//SIG=00000000:00000000:00000000:00000000:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (v4 == 27)
    v5 = "//Metal1.0     \n"
         "//LEN=000000054e\n"
         "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
         "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< half >       hg_Texture0 [[ texture(0) ]],\n"
         "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
         "{\n"
         "    // convolution radius\n"
         "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
         "    \n"
         "    // Accumulator\n"
         "    half4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
         "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
         "    \n"
         "    for (int16_t k {1}; k <= radius; ++k)\n"
         "    {\n"
         "        const float uPos {frag._texCoord0.y + k};\n"
         "        const float uNeg {frag._texCoord0.y - k};\n"
         "        const float v {frag._texCoord0.x};\n"
         "        \n"
         "        half4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(v, uPos))};\n"
         "        half4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(v, uNeg))};\n"
         "\n"
         "        R0 = half4(min(R0.x,R1.x), min(R0.y,R1.y), min(R0.z,R1.z), min(R0.a,R1.a));\n"
         "        R0 = half4(min(R0.x,R2.x), min(R0.y,R2.y), min(R0.z,R2.z), min(R0.a,R2.a));\n"
         "    }\n"
         "    \n"
         "    FragmentOut out {static_cast<float4>(R0)};\n"
         "    return out;\n"
         "}\n"
         "//MD5=3bf26023:798dc819:7b701366:6a323336\n"
         "//SIG=00000000:00000000:00000000:00000001:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (Target <= 0x60B0F)
    return 0;
  else
    return v5;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::BindTexture(int a1, HGHandler *this, uint64_t a3)
{
  HGHandler::TexCoord(this, a3, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)this + 72))(this, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)this + 56))(this, 0);
  return 0;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::GetOutput(uint64_t a1, uint64_t a2, char *a3)
{
  HGNode::SetParameter((HGNode *)a1, 0, (float)*(unsigned int *)(a1 + 408), 0.0, 0.0, 0.0, a3);
  return a1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(0, -*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408));
  return HGRectGrow(a4, a5, v8);
}

uint64_t MinMax::MMNode<(MinMax::Mode)0,(MinMax::Axis)1>::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(0, -*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408));
  return HGRectGrow(a4, a5, v8);
}

void MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::~MMNode(HGNode *a1)
{
  void *v1;

  HGNode::~HGNode(a1);
  HGObject::operator delete(v1);
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::SetParameter(uint64_t a1, int a2, float a3)
{
  unsigned int v4;

  if (a2)
    return 0xFFFFFFFFLL;
  v4 = vcvtms_s32_f32(a3);
  if ((v4 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 408) == v4)
    return 0;
  *(_DWORD *)(a1 + 408) = v4;
  return 1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t *v10;
  float32x4_t *v11;
  uint64_t v12;
  float32x4_t *v13;
  float32x4_t *v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;

  v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    v3 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2);
    if ((int)v3 >= 1)
    {
      v4 = 0;
      v5 = *(int *)(a2 + 88);
      v6 = *(int *)(a2 + 24);
      v7 = *(_QWORD *)(a2 + 80);
      v8 = *(_QWORD *)(a2 + 16);
      v9 = 16 * v5;
      v10 = (float32x4_t *)(v7 - 16 * v5);
      v11 = (float32x4_t *)(v7 + 16 * v5);
      do
      {
        v12 = 0;
        v13 = v11;
        v14 = v10;
        do
        {
          v15 = *(float32x4_t *)(v7 + 16 * v12);
          v16 = *(unsigned int *)(a1 + 408);
          if ((int)v16 >= 1)
          {
            v17 = v13;
            v18 = v14;
            do
            {
              v15 = vmaxq_f32(vmaxq_f32(v15, *v17), *v18);
              v18 -= v5;
              v17 = (float32x4_t *)((char *)v17 + v9);
              --v16;
            }
            while (v16);
          }
          *(float32x4_t *)(v8 + 16 * v12++) = v15;
          ++v14;
          ++v13;
        }
        while (v12 != v3);
        v7 += 16 * v5;
        v8 += 16 * v6;
        ++v4;
        v10 = (float32x4_t *)((char *)v10 + v9);
        v11 = (float32x4_t *)((char *)v11 + v9);
      }
      while (v4 != v2);
    }
  }
  return 0;
}

const char *MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::GetProgram(int a1, HGRenderer *this)
{
  unsigned int Target;
  int v4;
  const char *v5;

  Target = HGRenderer::GetTarget(this, 393216);
  v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)this + 128))(this, 19);
  v5 = "//Metal1.0     \n"
       "//LEN=00000004e7\n"
       "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
       "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
       "                                  texture2d< float >      hg_Texture0 [[ texture(0) ]],\n"
       "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
       "{\n"
       "    // convolution radius\n"
       "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
       "    \n"
       "    // Accumulator\n"
       "    float4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
       "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
       "    \n"
       "    for (int16_t k {1}; k <= radius; ++k)\n"
       "    {\n"
       "        const float uPos {frag._texCoord0.y + k};\n"
       "        const float uNeg {frag._texCoord0.y - k};\n"
       "        const float v {frag._texCoord0.x};\n"
       "        \n"
       "        float4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(v, uPos))};\n"
       "        float4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
       "            float2(v, uNeg))};\n"
       "            \n"
       "        R0 = max(R0,R1);\n"
       "        R0 = max(R0,R2);\n"
       "    }\n"
       "    \n"
       "    FragmentOut out {static_cast<float4>(R0)};\n"
       "    return out;\n"
       "}\n"
       "//MD5=34c81472:306e105f:9f48d6d1:aef98b68\n"
       "//SIG=00000000:00000000:00000000:00000000:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (v4 == 27)
    v5 = "//Metal1.0     \n"
         "//LEN=000000054e\n"
         "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
         "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< half >       hg_Texture0 [[ texture(0) ]],\n"
         "                                  sampler                 hg_Sampler0 [[ sampler(0) ]])\n"
         "{\n"
         "    // convolution radius\n"
         "    const int16_t radius {static_cast<int16_t>(hg_Params[0].x)};\n"
         "    \n"
         "    // Accumulator\n"
         "    half4 R0 {hg_Texture0.sample(hg_Sampler0,\n"
         "               float2(frag._texCoord0.x, frag._texCoord0.y))};\n"
         "    \n"
         "    for (int16_t k {1}; k <= radius; ++k)\n"
         "    {\n"
         "        const float uPos {frag._texCoord0.y + k};\n"
         "        const float uNeg {frag._texCoord0.y - k};\n"
         "        const float v {frag._texCoord0.x};\n"
         "        \n"
         "        half4 R1 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(v, uPos))};\n"
         "        half4 R2 {hg_Texture0.sample(hg_Sampler0,\n"
         "            float2(v, uNeg))};\n"
         "\n"
         "        R0 = half4(max(R0.x,R1.x), max(R0.y,R1.y), max(R0.z,R1.z), max(R0.a,R1.a));\n"
         "        R0 = half4(max(R0.x,R2.x), max(R0.y,R2.y), max(R0.z,R2.z), max(R0.a,R2.a));\n"
         "    }\n"
         "    \n"
         "    FragmentOut out {static_cast<float4>(R0)};\n"
         "    return out;\n"
         "}\n"
         "//MD5=244a8df3:77093f9d:67a0f5ac:f9949def\n"
         "//SIG=00000000:00000000:00000000:00000001:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:0:0\n";
  if (Target <= 0x60B0F)
    return 0;
  else
    return v5;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::BindTexture(int a1, HGHandler *this, uint64_t a3)
{
  HGHandler::TexCoord(this, a3, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)this + 72))(this, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)this + 56))(this, 0);
  return 0;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::GetOutput(uint64_t a1, uint64_t a2, char *a3)
{
  HGNode::SetParameter((HGNode *)a1, 0, (float)*(unsigned int *)(a1 + 408), 0.0, 0.0, 0.0, a3);
  return a1;
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(0, -*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408));
  return HGRectGrow(a4, a5, v8);
}

uint64_t MinMax::MMNode<(MinMax::Mode)1,(MinMax::Axis)1>::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a3)
    return 0;
  v8 = HGRectMake4i(0, -*(_DWORD *)(a1 + 408), 0, *(_DWORD *)(a1 + 408));
  return HGRectGrow(a4, a5, v8);
}

const char *HgcBlendBlur_2::GetProgram(HgcBlendBlur_2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000048d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*half(hg_Params[0].x) + half(hg_Params[1].x);\n"
             "    r0.x = clamp(r0.x*half(hg_Params[2].x), 0.00000h, 1.00000h);\n"
             "    output.color0 = mix(float4(r1), float4(r2), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa767a30:43e6c19d:194499ff:c7dbf93e\n"
             "//SIG=00400000:00000007:00000007:00000007:0001:0003:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000452\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*hg_Params[0].x + hg_Params[1].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
             "    output.color0 = mix(r1, r2, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e6a820fd:1bf2525f:b73f4bfa:536e503b\n"
             "//SIG=00000000:00000007:00000007:00000000:0001:0003:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000432\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r0.x = max(r0.x, c0.x);\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x + hg_ProgramLocal1.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal2.x, 0.00000, 1.00000);\n"
           "    gl_FragColor = mix(r1, r2, r0.xxxx);\n"
           "}\n"
           "//MD5=ad430f94:4dc630c7:b0e05cdb:f026c832\n"
           "//SIG=00000000:00000007:00000007:00000000:0001:0003:0003:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcBlendBlur_2::InitProgramDescriptor(HgcBlendBlur_2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlendBlur_2_hgc_visible", "//Metal1.0     \n//LEN=0000000234\n[[ visible ]] FragmentOut HgcBlendBlur_2_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r0.x = fmax(r0.x, c0.x);\n"
    "    r0.x = r0.x*hg_Params[0].x + hg_Params[1].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
    "    output.color0 = mix(r1, r2, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B8E6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B8E704(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B8E6FCLL);
}

void HgcBlendBlur_2::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcBlendBlur_2 [hgc1]");
}

uint64_t HgcBlendBlur_2::BindTexture(HgcBlendBlur_2 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 2;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    if (a3)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBlendBlur_2::Bind(HgcBlendBlur_2 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcBlendBlur_2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlendBlur_2::RenderTile(HgcBlendBlur_2 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  float32x4_t *v19;
  float32x4_t *v20;
  unint64_t v21;
  unint64_t v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t *v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  float32x4_t *v57;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 30);
    v10 = *((int *)a2 + 26);
    v11 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v50 = 0;
        v51 = 16 * v11;
        v52 = 16 * v10;
        v53 = 16 * v9;
        v54 = 16 * v8;
        v55 = 16 * v3;
        do
        {
          v56 = 0;
          do
          {
            v57 = (float32x4_t *)*((_QWORD *)this + 51);
            v7[v56 / 0x10] = vaddq_f32(v5[v56 / 0x10], vmulq_n_f32(vsubq_f32(v6[v56 / 0x10], v5[v56 / 0x10]), vminq_f32(vmaxq_f32(vmulq_f32(v57[2], vaddq_f32(v57[1], vmulq_f32(vmaxq_f32(v4[v56 / 0x10], v57[3]), *v57))), v57[3]), v57[4]).f32[0]));
            v56 += 16;
          }
          while (v55 != v56);
          ++v50;
          v4 = (float32x4_t *)((char *)v4 + v51);
          v5 = (float32x4_t *)((char *)v5 + v52);
          v6 = (float32x4_t *)((char *)v6 + v53);
          v7 = (float32x4_t *)((char *)v7 + v54);
        }
        while (v50 != v2);
      }
    }
    else
    {
      v12 = 0;
      v13 = 16 * v10;
      v14 = 16 * v9;
      v15 = 16 * v8;
      v16 = v4 + 4;
      v17 = 16 * v11;
      v18 = v5 + 4;
      v19 = v6 + 4;
      v20 = v7 + 4;
      do
      {
        v21 = 0;
        v22 = 0;
        v23 = v20;
        v24 = v19;
        v25 = v18;
        v26 = v16;
        do
        {
          v27 = v26;
          v28 = v25;
          v29 = v24;
          v30 = v23;
          v31 = (float32x4_t *)*((_QWORD *)this + 51);
          v33 = v31[2];
          v32 = v31[3];
          v34 = v31[1];
          v35 = vmaxq_f32(vmulq_f32(v33, vaddq_f32(v34, vmulq_f32(vmaxq_f32(v4[v21], v32), *v31))), v32);
          v36 = vmaxq_f32(vmulq_f32(v33, vaddq_f32(v34, vmulq_f32(vmaxq_f32(v4[v21 + 1], v32), *v31))), v32);
          v37 = vmaxq_f32(vmulq_f32(v33, vaddq_f32(v34, vmulq_f32(vmaxq_f32(v4[v21 + 2], v32), *v31))), v32);
          v38 = vmaxq_f32(vmulq_f32(v33, vaddq_f32(v34, vmulq_f32(vmaxq_f32(v4[v21 + 3], v32), *v31))), v32);
          v39 = v31[4];
          v40 = vaddq_f32(v5[v21 + 1], vmulq_n_f32(vsubq_f32(v6[v21 + 1], v5[v21 + 1]), vminq_f32(v36, v39).f32[0]));
          v41 = vaddq_f32(v5[v21 + 2], vmulq_n_f32(vsubq_f32(v6[v21 + 2], v5[v21 + 2]), vminq_f32(v37, v39).f32[0]));
          v42 = vaddq_f32(v5[v21 + 3], vmulq_n_f32(vsubq_f32(v6[v21 + 3], v5[v21 + 3]), vminq_f32(v38, v39).f32[0]));
          v43 = &v7[v21];
          *v43 = vaddq_f32(v5[v21], vmulq_n_f32(vsubq_f32(v6[v21], v5[v21]), vminq_f32(v35, v39).f32[0]));
          v43[1] = v40;
          v22 += 4;
          v21 += 4;
          v26 += 4;
          v43[2] = v41;
          v43[3] = v42;
          v25 += 4;
          v24 = v29 + 4;
          v23 = v30 + 4;
        }
        while ((uint64_t)v22 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v22)
        {
          do
          {
            v44 = *v27++;
            v45 = v44;
            v46 = *v28++;
            v47 = v46;
            v48 = (float32x4_t *)*((_QWORD *)this + 51);
            v49 = *v29++;
            *v30++ = vaddq_f32(v47, vmulq_n_f32(vsubq_f32(v49, v47), vminq_f32(vmaxq_f32(vmulq_f32(v48[2], vaddq_f32(v48[1], vmulq_f32(vmaxq_f32(v45, v48[3]), *v48))), v48[3]), v48[4]).f32[0]));
            ++v22;
          }
          while (v22 < v3);
        }
        ++v12;
        v5 = (float32x4_t *)((char *)v5 + v13);
        v6 = (float32x4_t *)((char *)v6 + v14);
        v7 = (float32x4_t *)((char *)v7 + v15);
        v4 = (float32x4_t *)((char *)v4 + v17);
        v16 = (float32x4_t *)((char *)v16 + v17);
        v18 = (float32x4_t *)((char *)v18 + v13);
        v19 = (float32x4_t *)((char *)v19 + v14);
        v20 = (float32x4_t *)((char *)v20 + v15);
      }
      while (v12 != v2);
    }
  }
  return 0;
}

uint64_t HgcBlendBlur_2::GetDOD(HgcBlendBlur_2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBlendBlur_2::GetROI(HgcBlendBlur_2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBlendBlur_2::~HgcBlendBlur_2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6536E90;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6536E90;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlendBlur_2::SetParameter(HgcBlendBlur_2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlendBlur_2::GetParameter(HgcBlendBlur_2 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlendBlur_3::GetProgram(HgcBlendBlur_3 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005d4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*half(hg_Params[0].x);\n"
             "    r4.x = r0.x + half(hg_Params[1].x);\n"
             "    r4.x = clamp(r4.x*half(hg_Params[2].x), 0.00000h, 1.00000h);\n"
             "    r4 = mix(r1, r2, r4.xxxx);\n"
             "    r0.x = r0.x + half(hg_Params[3].x);\n"
             "    r0.x = clamp(r0.x*half(hg_Params[4].x), 0.00000h, 1.00000h);\n"
             "    output.color0 = mix(float4(r4), float4(r3), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=4d97c1a1:51645ce4:7fcb49ff:f74049af\n"
             "//SIG=00400000:0000000f:0000000f:0000000f:0001:0005:0005:0000:0000:0000:001e:0000:0004:04:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000586\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r4.x = r0.x + hg_Params[1].x;\n"
             "    r4.x = clamp(r4.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
             "    r4 = mix(r1, r2, r4.xxxx);\n"
             "    r0.x = r0.x + hg_Params[3].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
             "    output.color0 = mix(r4, r3, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1a704606:298fad20:53f42e0b:42d4cdc2\n"
             "//SIG=00000000:0000000f:0000000f:00000000:0001:0005:0005:0000:0000:0000:001e:0000:0004:04:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000598\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r0.x = max(r0.x, c0.x);\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r4.x = r0.x + hg_ProgramLocal1.x;\n"
           "    r4.x = clamp(r4.x*hg_ProgramLocal2.x, 0.00000, 1.00000);\n"
           "    r4 = mix(r1, r2, r4.xxxx);\n"
           "    r0.x = r0.x + hg_ProgramLocal3.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal4.x, 0.00000, 1.00000);\n"
           "    gl_FragColor = mix(r4, r3, r0.xxxx);\n"
           "}\n"
           "//MD5=fe2d5407:e86404d7:349ecd54:74bb66cc\n"
           "//SIG=00000000:0000000f:0000000f:00000000:0001:0005:0005:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
  }
}

void HgcBlendBlur_3::InitProgramDescriptor(HgcBlendBlur_3 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlendBlur_3_hgc_visible", "//Metal1.0     \n//LEN=00000002ed\n[[ visible ]] FragmentOut HgcBlendBlur_3_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r0.x = fmax(r0.x, c0.x);\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r4.x = r0.x + hg_Params[1].x;\n"
    "    r4.x = clamp(r4.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
    "    r4 = mix(r1, r2, r4.xxxx);\n"
    "    r0.x = r0.x + hg_Params[3].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
    "    output.color0 = mix(r4, r3, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B8F1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B8F228(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B8F220);
}

void HgcBlendBlur_3::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcBlendBlur_3 [hgc1]");
}

uint64_t HgcBlendBlur_3::BindTexture(HgcBlendBlur_3 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_7;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_7;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_7;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
LABEL_7:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcBlendBlur_3::Bind(HgcBlendBlur_3 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcBlendBlur_3 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlendBlur_3::RenderTile(HgcBlendBlur_3 *this, HGTile *a2)
{
  uint64_t v2;
  float32x4_t *v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t *v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  float32x4_t *v32;
  int v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t *v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t *v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  float32x4_t *v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;

  v85 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v85 >= 1)
  {
    v2 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v3 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 34);
    v10 = *((int *)a2 + 30);
    v11 = *((int *)a2 + 26);
    v12 = *((int *)a2 + 22);
    if ((int)v2 < 3)
    {
      if ((int)v2 >= 1)
      {
        v67 = 0;
        v68 = 16 * v12;
        v69 = 16 * v11;
        v70 = 16 * v10;
        v71 = 16 * v9;
        v72 = 16 * v8;
        v73 = 16 * v2;
        do
        {
          v74 = 0;
          do
          {
            v75 = (float32x4_t *)*((_QWORD *)this + 51);
            v76 = v75[5];
            v77 = vmulq_f32(vmaxq_f32(v3[v74 / 0x10], v76), *v75);
            v78 = v75[6];
            v79 = vaddq_f32(v4[v74 / 0x10], vmulq_n_f32(vsubq_f32(v5[v74 / 0x10], v4[v74 / 0x10]), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v77, v75[1]), v75[2]), v76), v78).f32[0]));
            v7[v74 / 0x10] = vaddq_f32(v79, vmulq_n_f32(vsubq_f32(v6[v74 / 0x10], v79), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v77, v75[3]), v75[4]), v76), v78).f32[0]));
            v74 += 16;
          }
          while (v73 != v74);
          ++v67;
          v3 = (float32x4_t *)((char *)v3 + v68);
          v4 = (float32x4_t *)((char *)v4 + v69);
          v5 = (float32x4_t *)((char *)v5 + v70);
          v6 = (float32x4_t *)((char *)v6 + v71);
          v7 = (float32x4_t *)((char *)v7 + v72);
        }
        while (v67 != v85);
      }
    }
    else
    {
      v13 = 0;
      v83 = 16 * v10;
      v84 = 16 * v11;
      v14 = v3 + 3;
      v81 = 16 * v8;
      v82 = 16 * v9;
      v15 = v4 + 3;
      v16 = 16 * v12;
      v17 = v5 + 3;
      v18 = v6 + 3;
      v19 = v7 + 3;
      do
      {
        v20 = 0;
        v21 = 0;
        v22 = 3;
        v23 = v19;
        v24 = v18;
        v25 = v17;
        v26 = v15;
        v27 = v14;
        do
        {
          v28 = v27;
          v29 = v26;
          v30 = v25;
          v31 = v24;
          v32 = v23;
          v33 = v22;
          v34 = (float32x4_t *)*((_QWORD *)this + 51);
          v36 = v34[4];
          v35 = v34[5];
          v37 = v34[1];
          v38 = vmulq_f32(vmaxq_f32(v3[v20], v35), *v34);
          v39 = vmulq_f32(vmaxq_f32(v3[v20 + 1], v35), *v34);
          v40 = vmulq_f32(vmaxq_f32(v3[v20 + 2], v35), *v34);
          v41 = vaddq_f32(v38, v37);
          v42 = v34[2];
          v43 = v34[3];
          v44 = vmulq_f32(vaddq_f32(v39, v37), v42);
          v45 = vmulq_f32(vaddq_f32(v40, v37), v42);
          v46 = vmaxq_f32(vmulq_f32(v41, v42), v35);
          v47 = v34[6];
          v48 = vaddq_f32(v4[v20], vmulq_n_f32(vsubq_f32(v5[v20], v4[v20]), vminq_f32(v46, v47).f32[0]));
          v49 = vaddq_f32(v4[v20 + 1], vmulq_n_f32(vsubq_f32(v5[v20 + 1], v4[v20 + 1]), vminq_f32(vmaxq_f32(v44, v35), v47).f32[0]));
          v50 = vaddq_f32(v4[v20 + 2], vmulq_n_f32(vsubq_f32(v5[v20 + 2], v4[v20 + 2]), vminq_f32(vmaxq_f32(v45, v35), v47).f32[0]));
          v51 = vaddq_f32(v48, vmulq_n_f32(vsubq_f32(v6[v20], v48), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v38, v43), v36), v35), v47).f32[0]));
          v52 = &v7[v20];
          v21 += 3;
          v53 = vaddq_f32(v49, vmulq_n_f32(vsubq_f32(v6[v20 + 1], v49), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v39, v43), v36), v35), v47).f32[0]));
          v54 = vaddq_f32(v50, vmulq_n_f32(vsubq_f32(v6[v20 + 2], v50), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v40, v43), v36), v35), v47).f32[0]));
          v20 += 3;
          v27 = v28 + 3;
          v26 += 3;
          v25 += 3;
          *v52 = v51;
          v52[1] = v53;
          v52[2] = v54;
          v24 = v31 + 3;
          v23 += 3;
          v22 += 3;
        }
        while (v21 < v2 - 2);
        if ((int)v2 > (int)v21)
        {
          do
          {
            v55 = *v28++;
            v56 = v55;
            v57 = *v29++;
            v58 = v57;
            v59 = *v30++;
            v60 = v59;
            v61 = *v31++;
            v62 = (float32x4_t *)*((_QWORD *)this + 51);
            v63 = v62[5];
            v64 = vmulq_f32(vmaxq_f32(v56, v63), *v62);
            v65 = v62[6];
            v66 = vaddq_f32(v58, vmulq_n_f32(vsubq_f32(v60, v58), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v64, v62[1]), v62[2]), v63), v65).f32[0]));
            *v32++ = vaddq_f32(v66, vmulq_n_f32(vsubq_f32(v61, v66), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v64, v62[3]), v62[4]), v63), v65).f32[0]));
            ++v33;
          }
          while ((int)v2 > v33);
        }
        ++v13;
        v4 = (float32x4_t *)((char *)v4 + v84);
        v5 = (float32x4_t *)((char *)v5 + v83);
        v6 = (float32x4_t *)((char *)v6 + v82);
        v7 = (float32x4_t *)((char *)v7 + v81);
        v3 = (float32x4_t *)((char *)v3 + v16);
        v14 = (float32x4_t *)((char *)v14 + v16);
        v15 = (float32x4_t *)((char *)v15 + v84);
        v17 = (float32x4_t *)((char *)v17 + v83);
        v18 = (float32x4_t *)((char *)v18 + v82);
        v19 = (float32x4_t *)((char *)v19 + v81);
      }
      while (v13 != v85);
    }
  }
  return 0;
}

uint64_t HgcBlendBlur_3::GetDOD(HgcBlendBlur_3 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 4)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBlendBlur_3::GetROI(HgcBlendBlur_3 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 4)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBlendBlur_3::~HgcBlendBlur_3(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65370E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65370E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlendBlur_3::SetParameter(HgcBlendBlur_3 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlendBlur_3::GetParameter(HgcBlendBlur_3 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlendBlur_4::GetProgram(HgcBlendBlur_4 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000706\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*half(hg_Params[0].x);\n"
             "    r5.x = r0.x + half(hg_Params[1].x);\n"
             "    r5.x = clamp(r5.x*half(hg_Params[2].x), 0.00000h, 1.00000h);\n"
             "    r5 = mix(r1, r2, r5.xxxx);\n"
             "    r2.x = r0.x + half(hg_Params[3].x);\n"
             "    r2.x = clamp(r2.x*half(hg_Params[4].x), 0.00000h, 1.00000h);\n"
             "    r5 = mix(r5, r3, r2.xxxx);\n"
             "    r0.x = r0.x + half(hg_Params[5].x);\n"
             "    r0.x = clamp(r0.x*half(hg_Params[6].x), 0.00000h, 1.00000h);\n"
             "    output.color0 = mix(float4(r5), float4(r4), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=627e420d:ac3f65df:3d6a2763:e2f8e48d\n"
             "//SIG=00400000:0000001f:0000001f:0000001f:0001:0007:0006:0000:0000:0000:003e:0000:0005:05:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006a5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r5.x = r0.x + hg_Params[1].x;\n"
             "    r5.x = clamp(r5.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
             "    r5 = mix(r1, r2, r5.xxxx);\n"
             "    r2.x = r0.x + hg_Params[3].x;\n"
             "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
             "    r5 = mix(r5, r3, r2.xxxx);\n"
             "    r0.x = r0.x + hg_Params[5].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
             "    output.color0 = mix(r5, r4, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=80d6b672:6abcf68f:93b3ec5c:4ec43f78\n"
             "//SIG=00000000:0000001f:0000001f:00000000:0001:0007:0006:0000:0000:0000:003e:0000:0005:05:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006e9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "uniform defaultp vec4 hg_ProgramLocal5;\n"
           "uniform defaultp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r0.x = max(r0.x, c0.x);\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r5.x = r0.x + hg_ProgramLocal1.x;\n"
           "    r5.x = clamp(r5.x*hg_ProgramLocal2.x, 0.00000, 1.00000);\n"
           "    r5 = mix(r1, r2, r5.xxxx);\n"
           "    r2.x = r0.x + hg_ProgramLocal3.x;\n"
           "    r2.x = clamp(r2.x*hg_ProgramLocal4.x, 0.00000, 1.00000);\n"
           "    r5 = mix(r5, r3, r2.xxxx);\n"
           "    r0.x = r0.x + hg_ProgramLocal5.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal6.x, 0.00000, 1.00000);\n"
           "    gl_FragColor = mix(r5, r4, r0.xxxx);\n"
           "}\n"
           "//MD5=66a338c1:c5285239:914c20c7:2234eca0\n"
           "//SIG=00000000:0000001f:0000001f:00000000:0001:0007:0006:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
  }
}

void HgcBlendBlur_4::InitProgramDescriptor(HgcBlendBlur_4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlendBlur_4_hgc_visible", "//Metal1.0     \n//LEN=0000000391\n[[ visible ]] FragmentOut HgcBlendBlur_4_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r0.x = fmax(r0.x, c0.x);\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r5.x = r0.x + hg_Params[1].x;\n"
    "    r5.x = clamp(r5.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
    "    r5 = mix(r1, r2, r5.xxxx);\n"
    "    r2.x = r0.x + hg_Params[3].x;\n"
    "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
    "    r5 = mix(r5, r3, r2.xxxx);\n"
    "    r0.x = r0.x + hg_Params[5].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
    "    output.color0 = mix(r5, r4, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B8FF1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B8FF5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B8FF54);
}

void HgcBlendBlur_4::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcBlendBlur_4 [hgc1]");
}

uint64_t HgcBlendBlur_4::BindTexture(HgcBlendBlur_4 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_8;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_8;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_8;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_8;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
LABEL_8:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcBlendBlur_4::Bind(HgcBlendBlur_4 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HgcBlendBlur_4 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlendBlur_4::RenderTile(HgcBlendBlur_4 *this, HGTile *a2)
{
  int v2;
  int v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  float32x4_t *v8;
  float32x4_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  float32x4_t v25;
  float32x4_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t *v46;
  float32x4_t *v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  float32x4_t *v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v8 = (float32x4_t *)*((_QWORD *)a2 + 18);
    v9 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v10 = *((int *)a2 + 6);
    v11 = *((int *)a2 + 38);
    v12 = *((int *)a2 + 34);
    v13 = *((int *)a2 + 30);
    v14 = *((int *)a2 + 26);
    v15 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        v53 = 16 * v13;
        v54 = 16 * v12;
        v55 = 16 * v11;
        v56 = 16 * v10;
        do
        {
          v57 = (float32x4_t *)*((_QWORD *)this + 51);
          v58 = v57[7];
          v59 = vmulq_f32(vmaxq_f32(*v4, v58), *v57);
          v60 = v57[8];
          v61 = vaddq_f32(*v5, vmulq_n_f32(vsubq_f32(*v6, *v5), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v59, v57[1]), v57[2]), v58), v60).f32[0]));
          v62 = vaddq_f32(v61, vmulq_n_f32(vsubq_f32(*v7, v61), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v59, v57[3]), v57[4]), v58), v60).f32[0]));
          v4 += v15;
          v5 += v14;
          v6 = (float32x4_t *)((char *)v6 + v53);
          *v9 = vaddq_f32(v62, vmulq_n_f32(vsubq_f32(*v8, v62), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v59, v57[5]), v57[6]), v58), v60).f32[0]));
          v7 = (float32x4_t *)((char *)v7 + v54);
          v8 = (float32x4_t *)((char *)v8 + v55);
          v9 = (float32x4_t *)((char *)v9 + v56);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      v16 = 0;
      v17 = 16 * v13;
      v18 = 16 * v12;
      v19 = 16 * v11;
      v20 = 16 * v10;
      v21 = 16 * v15;
      v22 = 16 * v14;
      do
      {
        v23 = 0;
        v24 = 0;
        do
        {
          v25 = v5[v23];
          v26 = (float32x4_t *)*((_QWORD *)this + 51);
          v28 = v26[6];
          v27 = v26[7];
          v29 = v26[1];
          v30 = vmulq_f32(vmaxq_f32(v4[v23], v27), *v26);
          v31 = vmulq_f32(vmaxq_f32(v4[v23 + 1], v27), *v26);
          v32 = vaddq_f32(v30, v29);
          v33 = v26[2];
          v34 = v26[3];
          v35 = vmulq_f32(vaddq_f32(v31, v29), v33);
          v36 = vmaxq_f32(vmulq_f32(v32, v33), v27);
          v37 = v26[8];
          v38 = vmulq_n_f32(vsubq_f32(v6[v23], v25), vminq_f32(v36, v37).f32[0]);
          v39 = v26[4];
          v40 = v26[5];
          v41 = vaddq_f32(v25, v38);
          v42 = vaddq_f32(v5[v23 + 1], vmulq_n_f32(vsubq_f32(v6[v23 + 1], v5[v23 + 1]), vminq_f32(vmaxq_f32(v35, v27), v37).f32[0]));
          v43 = vaddq_f32(v41, vmulq_n_f32(vsubq_f32(v7[v23], v41), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v30, v34), v39), v27), v37).f32[0]));
          v44 = vaddq_f32(v42, vmulq_n_f32(vsubq_f32(v7[v23 + 1], v42), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v31, v34), v39), v27), v37).f32[0]));
          v45 = vaddq_f32(v44, vmulq_n_f32(vsubq_f32(v8[v23 + 1], v44), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v31, v40), v28), v27), v37).f32[0]));
          v46 = &v9[v23];
          *v46 = vaddq_f32(v43, vmulq_n_f32(vsubq_f32(v8[v23], v43), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v30, v40), v28), v27), v37).f32[0]));
          v46[1] = v45;
          v24 -= 2;
          v23 += 2;
        }
        while (v3 + v24 > 1);
        if (v3 > -v24)
        {
          v47 = (float32x4_t *)*((_QWORD *)this + 51);
          v48 = v47[7];
          v49 = vmulq_f32(vmaxq_f32(v4[v23], v48), *v47);
          v50 = v47[8];
          v51 = vaddq_f32(v5[v23], vmulq_n_f32(vsubq_f32(v6[v23], v5[v23]), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v49, v47[1]), v47[2]), v48), v50).f32[0]));
          v52 = vaddq_f32(v51, vmulq_n_f32(vsubq_f32(v7[v23], v51), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v49, v47[3]), v47[4]), v48), v50).f32[0]));
          v9[v23] = vaddq_f32(v52, vmulq_n_f32(vsubq_f32(v8[v23], v52), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v49, v47[5]), v47[6]), v48), v50).f32[0]));
        }
        ++v16;
        v6 = (float32x4_t *)((char *)v6 + v17);
        v7 = (float32x4_t *)((char *)v7 + v18);
        v8 = (float32x4_t *)((char *)v8 + v19);
        v9 = (float32x4_t *)((char *)v9 + v20);
        v4 = (float32x4_t *)((char *)v4 + v21);
        v5 = (float32x4_t *)((char *)v5 + v22);
      }
      while (v16 != v2);
    }
  }
  return 0;
}

uint64_t HgcBlendBlur_4::GetDOD(HgcBlendBlur_4 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 5)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBlendBlur_4::GetROI(HgcBlendBlur_4 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 5)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBlendBlur_4::~HgcBlendBlur_4(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6537330;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6537330;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlendBlur_4::SetParameter(HgcBlendBlur_4 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlendBlur_4::GetParameter(HgcBlendBlur_4 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlendBlur_5::GetProgram(HgcBlendBlur_5 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000838\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*half(hg_Params[0].x);\n"
             "    r6.x = r0.x + half(hg_Params[1].x);\n"
             "    r6.x = clamp(r6.x*half(hg_Params[2].x), 0.00000h, 1.00000h);\n"
             "    r6 = mix(r1, r2, r6.xxxx);\n"
             "    r2.x = r0.x + half(hg_Params[3].x);\n"
             "    r2.x = clamp(r2.x*half(hg_Params[4].x), 0.00000h, 1.00000h);\n"
             "    r6 = mix(r6, r3, r2.xxxx);\n"
             "    r1.x = r0.x + half(hg_Params[5].x);\n"
             "    r1.x = clamp(r1.x*half(hg_Params[6].x), 0.00000h, 1.00000h);\n"
             "    r6 = mix(r6, r4, r1.xxxx);\n"
             "    r0.x = r0.x + half(hg_Params[7].x);\n"
             "    r0.x = clamp(r0.x*half(hg_Params[8].x), 0.00000h, 1.00000h);\n"
             "    output.color0 = mix(float4(r6), float4(r5), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=1f819f5b:a3841d5a:cbe2d3a5:bdaf89e4\n"
             "//SIG=00400000:0000003f:0000003f:0000003f:0001:0009:0007:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000007c4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r6.x = r0.x + hg_Params[1].x;\n"
             "    r6.x = clamp(r6.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
             "    r6 = mix(r1, r2, r6.xxxx);\n"
             "    r2.x = r0.x + hg_Params[3].x;\n"
             "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
             "    r6 = mix(r6, r3, r2.xxxx);\n"
             "    r1.x = r0.x + hg_Params[5].x;\n"
             "    r1.x = clamp(r1.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
             "    r6 = mix(r6, r4, r1.xxxx);\n"
             "    r0.x = r0.x + hg_Params[7].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[8].x, 0.00000f, 1.00000f);\n"
             "    output.color0 = mix(r6, r5, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9de98d5c:330bb5b9:d2d07cff:4179144b\n"
             "//SIG=00000000:0000003f:0000003f:00000000:0001:0009:0007:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000083a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "uniform defaultp vec4 hg_ProgramLocal5;\n"
           "uniform defaultp vec4 hg_ProgramLocal6;\n"
           "uniform defaultp vec4 hg_ProgramLocal7;\n"
           "uniform defaultp vec4 hg_ProgramLocal8;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r0.x = max(r0.x, c0.x);\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r6.x = r0.x + hg_ProgramLocal1.x;\n"
           "    r6.x = clamp(r6.x*hg_ProgramLocal2.x, 0.00000, 1.00000);\n"
           "    r6 = mix(r1, r2, r6.xxxx);\n"
           "    r2.x = r0.x + hg_ProgramLocal3.x;\n"
           "    r2.x = clamp(r2.x*hg_ProgramLocal4.x, 0.00000, 1.00000);\n"
           "    r6 = mix(r6, r3, r2.xxxx);\n"
           "    r1.x = r0.x + hg_ProgramLocal5.x;\n"
           "    r1.x = clamp(r1.x*hg_ProgramLocal6.x, 0.00000, 1.00000);\n"
           "    r6 = mix(r6, r4, r1.xxxx);\n"
           "    r0.x = r0.x + hg_ProgramLocal7.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal8.x, 0.00000, 1.00000);\n"
           "    gl_FragColor = mix(r6, r5, r0.xxxx);\n"
           "}\n"
           "//MD5=47fbfc85:922bffb2:16d6ac3a:3532e4be\n"
           "//SIG=00000000:0000003f:0000003f:00000000:0001:0009:0007:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
  }
}

void HgcBlendBlur_5::InitProgramDescriptor(HgcBlendBlur_5 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlendBlur_5_hgc_visible", "//Metal1.0     \n//LEN=0000000435\n[[ visible ]] FragmentOut HgcBlendBlur_5_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r0.x = fmax(r0.x, c0.x);\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r6.x = r0.x + hg_Params[1].x;\n"
    "    r6.x = clamp(r6.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
    "    r6 = mix(r1, r2, r6.xxxx);\n"
    "    r2.x = r0.x + hg_Params[3].x;\n"
    "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
    "    r6 = mix(r6, r3, r2.xxxx);\n"
    "    r1.x = r0.x + hg_Params[5].x;\n"
    "    r1.x = clamp(r1.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
    "    r6 = mix(r6, r4, r1.xxxx);\n"
    "    r0.x = r0.x + hg_Params[7].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[8].x, 0.00000f, 1.00000f);\n"
    "    output.color0 = mix(r6, r5, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B90CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B90D20(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B90D18);
}

void HgcBlendBlur_5::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcBlendBlur_5 [hgc1]");
}

uint64_t HgcBlendBlur_5::BindTexture(HgcBlendBlur_5 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_9;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_9;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_9;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_9;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
      goto LABEL_9;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 5;
LABEL_9:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcBlendBlur_5::Bind(HgcBlendBlur_5 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 8, *((_QWORD *)this + 51) + 128, 1);
  (*(void (**)(HgcBlendBlur_5 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlendBlur_5::RenderTile(HgcBlendBlur_5 *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float32x4_t *v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t *v42;
  int v43;
  uint64_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 20);
    v7 = *((_QWORD *)a2 + 18);
    v8 = *((_QWORD *)a2 + 16);
    v9 = 16 * *((int *)a2 + 38);
    v10 = 16 * *((int *)a2 + 34);
    v11 = 16 * *((int *)a2 + 30);
    v12 = 16 * *((int *)a2 + 26);
    v13 = 16 * *((int *)a2 + 22);
    v14 = *((_QWORD *)a2 + 14);
    v15 = *((_QWORD *)a2 + 12);
    v16 = 16 * *((int *)a2 + 6);
    v17 = 16 * *((int *)a2 + 42);
    v18 = *((_QWORD *)a2 + 10);
    while (v4 < 2)
    {
      v43 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v18 += v13;
      v15 += v12;
      v14 += v11;
      v8 += v10;
      v7 += v9;
      v6 += v17;
      v5 += v16;
      if (++v3 == v2)
        return 0;
    }
    v19 = 0;
    v20 = 0;
    do
    {
      v21 = (float32x4_t *)*((_QWORD *)this + 51);
      v23 = v21[8];
      v22 = v21[9];
      v24 = v21[1];
      v25 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v18 + v19), v22), *v21);
      v26 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v18 + v19 + 16), v22), *v21);
      v27 = v21[2];
      v28 = v21[3];
      v29 = v21[10];
      v30 = vaddq_f32(*(float32x4_t *)(v15 + v19), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v14 + v19), *(float32x4_t *)(v15 + v19)), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v25, v24), v27), v22), v29).f32[0]));
      v31 = vaddq_f32(*(float32x4_t *)(v15 + v19 + 16), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v14 + v19 + 16), *(float32x4_t *)(v15 + v19 + 16)), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24), v27), v22), v29).f32[0]));
      v32 = v21[4];
      v33 = v21[5];
      v34 = vaddq_f32(v30, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v8 + v19), v30), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v25, v28), v32), v22), v29).f32[0]));
      v35 = vaddq_f32(v31, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v8 + v19 + 16), v31), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v28), v32), v22), v29).f32[0]));
      v36 = v21[6];
      v37 = v21[7];
      v38 = vaddq_f32(v34, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v19), v34), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v25, v33), v36), v22), v29).f32[0]));
      v39 = vaddq_f32(v35, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v19 + 16), v35), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v33), v36), v22), v29).f32[0]));
      v40 = vmaxq_f32(vmulq_f32(vaddq_f32(v25, v37), v23), v22);
      v41 = vaddq_f32(v39, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v19 + 16), v39), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v37), v23), v22), v29).f32[0]));
      v42 = (float32x4_t *)(v5 + v19);
      *v42 = vaddq_f32(v38, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v19), v38), vminq_f32(v40, v29).f32[0]));
      v42[1] = v41;
      v20 -= 2;
      v19 += 32;
    }
    while (v4 + v20 > 1);
    v43 = -v20;
    if (v43 >= v4)
      goto LABEL_3;
LABEL_10:
    v44 = 16 * v43;
    v45 = (float32x4_t *)*((_QWORD *)this + 51);
    v46 = v45[9];
    v47 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v18 + v44), v46), *v45);
    v48 = v45[10];
    v49 = vaddq_f32(*(float32x4_t *)(v15 + v44), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v14 + v44), *(float32x4_t *)(v15 + v44)), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v47, v45[1]), v45[2]), v46), v48).f32[0]));
    v50 = vaddq_f32(v49, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v8 + v44), v49), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v47, v45[3]), v45[4]), v46), v48).f32[0]));
    v51 = vaddq_f32(v50, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v44), v50), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v47, v45[5]), v45[6]), v46), v48).f32[0]));
    *(float32x4_t *)(v5 + v44) = vaddq_f32(v51, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v44), v51), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v47, v45[7]), v45[8]), v46), v48).f32[0]));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBlendBlur_5::GetDOD(HgcBlendBlur_5 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBlendBlur_5::GetROI(HgcBlendBlur_5 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBlendBlur_5::~HgcBlendBlur_5(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6537580;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6537580;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlendBlur_5::SetParameter(HgcBlendBlur_5 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 8)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlendBlur_5::GetParameter(HgcBlendBlur_5 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 8)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlendBlur_6::GetProgram(HgcBlendBlur_6 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000096b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*half(hg_Params[0].x);\n"
             "    r7.x = r0.x + half(hg_Params[1].x);\n"
             "    r7.x = clamp(r7.x*half(hg_Params[2].x), 0.00000h, 1.00000h);\n"
             "    r7 = mix(r1, r2, r7.xxxx);\n"
             "    r2.x = r0.x + half(hg_Params[3].x);\n"
             "    r2.x = clamp(r2.x*half(hg_Params[4].x), 0.00000h, 1.00000h);\n"
             "    r7 = mix(r7, r3, r2.xxxx);\n"
             "    r1.x = r0.x + half(hg_Params[5].x);\n"
             "    r1.x = clamp(r1.x*half(hg_Params[6].x), 0.00000h, 1.00000h);\n"
             "    r7 = mix(r7, r4, r1.xxxx);\n"
             "    r2.x = r0.x + half(hg_Params[7].x);\n"
             "    r2.x = clamp(r2.x*half(hg_Params[8].x), 0.00000h, 1.00000h);\n"
             "    r7 = mix(r7, r5, r2.xxxx);\n"
             "    r0.x = r0.x + half(hg_Params[9].x);\n"
             "    r0.x = clamp(r0.x*half(hg_Params[10].x), 0.00000h, 1.00000h);\n"
             "    output.color0 = mix(float4(r7), float4(r6), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=623268ba:866116ad:d3b9f927:5f12c758\n"
             "//SIG=00400000:0000007f:0000007f:0000007f:0001:000b:0008:0000:0000:0000:00fe:0000:0007:07:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000008e4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r7.x = r0.x + hg_Params[1].x;\n"
             "    r7.x = clamp(r7.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
             "    r7 = mix(r1, r2, r7.xxxx);\n"
             "    r2.x = r0.x + hg_Params[3].x;\n"
             "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
             "    r7 = mix(r7, r3, r2.xxxx);\n"
             "    r1.x = r0.x + hg_Params[5].x;\n"
             "    r1.x = clamp(r1.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
             "    r7 = mix(r7, r4, r1.xxxx);\n"
             "    r2.x = r0.x + hg_Params[7].x;\n"
             "    r2.x = clamp(r2.x*hg_Params[8].x, 0.00000f, 1.00000f);\n"
             "    r7 = mix(r7, r5, r2.xxxx);\n"
             "    r0.x = r0.x + hg_Params[9].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[10].x, 0.00000f, 1.00000f);\n"
             "    output.color0 = mix(r7, r6, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=95acf123:9baa8dfd:20ef2a98:1f1b8416\n"
             "//SIG=00000000:0000007f:0000007f:00000000:0001:000b:0008:0000:0000:0000:00fe:0000:0007:07:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000098d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp sampler2D hg_Texture6;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "uniform defaultp vec4 hg_ProgramLocal5;\n"
           "uniform defaultp vec4 hg_ProgramLocal6;\n"
           "uniform defaultp vec4 hg_ProgramLocal7;\n"
           "uniform defaultp vec4 hg_ProgramLocal8;\n"
           "uniform defaultp vec4 hg_ProgramLocal9;\n"
           "uniform defaultp vec4 hg_ProgramLocal10;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
           "    r0.x = max(r0.x, c0.x);\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r7.x = r0.x + hg_ProgramLocal1.x;\n"
           "    r7.x = clamp(r7.x*hg_ProgramLocal2.x, 0.00000, 1.00000);\n"
           "    r7 = mix(r1, r2, r7.xxxx);\n"
           "    r2.x = r0.x + hg_ProgramLocal3.x;\n"
           "    r2.x = clamp(r2.x*hg_ProgramLocal4.x, 0.00000, 1.00000);\n"
           "    r7 = mix(r7, r3, r2.xxxx);\n"
           "    r1.x = r0.x + hg_ProgramLocal5.x;\n"
           "    r1.x = clamp(r1.x*hg_ProgramLocal6.x, 0.00000, 1.00000);\n"
           "    r7 = mix(r7, r4, r1.xxxx);\n"
           "    r2.x = r0.x + hg_ProgramLocal7.x;\n"
           "    r2.x = clamp(r2.x*hg_ProgramLocal8.x, 0.00000, 1.00000);\n"
           "    r7 = mix(r7, r5, r2.xxxx);\n"
           "    r0.x = r0.x + hg_ProgramLocal9.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal10.x, 0.00000, 1.00000);\n"
           "    gl_FragColor = mix(r7, r6, r0.xxxx);\n"
           "}\n"
           "//MD5=345256d6:7773697d:9580f084:324af0ce\n"
           "//SIG=00000000:0000007f:0000007f:00000000:0001:000b:0008:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
  }
}

void HgcBlendBlur_6::InitProgramDescriptor(HgcBlendBlur_6 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlendBlur_6_hgc_visible", "//Metal1.0     \n//LEN=00000004da\n[[ visible ]] FragmentOut HgcBlendBlur_6_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5,\n    float4 color6)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r6 = color6;\n"
    "    r0.x = fmax(r0.x, c0.x);\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r7.x = r0.x + hg_Params[1].x;\n"
    "    r7.x = clamp(r7.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
    "    r7 = mix(r1, r2, r7.xxxx);\n"
    "    r2.x = r0.x + hg_Params[3].x;\n"
    "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
    "    r7 = mix(r7, r3, r2.xxxx);\n"
    "    r1.x = r0.x + hg_Params[5].x;\n"
    "    r1.x = clamp(r1.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
    "    r7 = mix(r7, r4, r1.xxxx);\n"
    "    r2.x = r0.x + hg_Params[7].x;\n"
    "    r2.x = clamp(r2.x*hg_Params[8].x, 0.00000f, 1.00000f);\n"
    "    r7 = mix(r7, r5, r2.xxxx);\n"
    "    r0.x = r0.x + hg_Params[9].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[10].x, 0.00000f, 1.00000f);\n"
    "    output.color0 = mix(r7, r6, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B91B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B91BC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B91BBCLL);
}

void HgcBlendBlur_6::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcBlendBlur_6 [hgc1]");
}

uint64_t HgcBlendBlur_6::BindTexture(HgcBlendBlur_6 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_10;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_10;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_10;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_10;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
      goto LABEL_10;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 5;
      goto LABEL_10;
    case 6:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 6, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 6;
LABEL_10:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcBlendBlur_6::Bind(HgcBlendBlur_6 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 8, *((_QWORD *)this + 51) + 128, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 9, *((_QWORD *)this + 51) + 144, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 10, *((_QWORD *)this + 51) + 160, 1);
  (*(void (**)(HgcBlendBlur_6 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlendBlur_6::RenderTile(HgcBlendBlur_6 *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  float32x4_t v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t *v56;
  int v57;
  uint64_t v58;
  float32x4_t *v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 22);
    v7 = *((_QWORD *)a2 + 20);
    v8 = *((_QWORD *)a2 + 18);
    v9 = *((_QWORD *)a2 + 16);
    v10 = 16 * *((int *)a2 + 42);
    v11 = 16 * *((int *)a2 + 38);
    v12 = 16 * *((int *)a2 + 34);
    v13 = 16 * *((int *)a2 + 30);
    v14 = 16 * *((int *)a2 + 26);
    v15 = 16 * *((int *)a2 + 22);
    v16 = *((_QWORD *)a2 + 14);
    v17 = *((_QWORD *)a2 + 12);
    v18 = 16 * *((int *)a2 + 6);
    v19 = 16 * *((int *)a2 + 46);
    v20 = *((_QWORD *)a2 + 10);
    while (v4 < 2)
    {
      v57 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v20 += v15;
      v17 += v14;
      v16 += v13;
      v9 += v12;
      v8 += v11;
      v7 += v10;
      v6 += v19;
      v5 += v18;
      if (++v3 == v2)
        return 0;
    }
    v21 = 0;
    v22 = 0;
    do
    {
      v23 = *(float32x4_t *)(v17 + v21 + 16);
      v24 = (float32x4_t *)*((_QWORD *)this + 51);
      v26 = v24[10];
      v25 = v24[11];
      v27 = v24[1];
      v28 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v20 + v21), v25), *v24);
      v29 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v20 + v21 + 16), v25), *v24);
      v30 = v24[2];
      v31 = v24[3];
      v32 = vmaxq_f32(vmulq_f32(vaddq_f32(v28, v27), v30), v25);
      v33 = vmaxq_f32(vmulq_f32(vaddq_f32(v29, v27), v30), v25);
      v34 = v24[12];
      v35 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v16 + v21 + 16), v23), vminq_f32(v33, v34).f32[0]);
      v36 = vaddq_f32(*(float32x4_t *)(v17 + v21), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v16 + v21), *(float32x4_t *)(v17 + v21)), vminq_f32(v32, v34).f32[0]));
      v37 = vaddq_f32(v28, v31);
      v38 = vaddq_f32(v29, v31);
      v39 = v24[4];
      v40 = v24[5];
      v41 = vaddq_f32(v23, v35);
      v42 = vaddq_f32(v36, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v9 + v21), v36), vminq_f32(vmaxq_f32(vmulq_f32(v37, v39), v25), v34).f32[0]));
      v43 = vaddq_f32(v28, v40);
      v44 = vaddq_f32(v29, v40);
      v45 = v24[6];
      v46 = v24[7];
      v47 = vaddq_f32(v41, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v9 + v21 + 16), v41), vminq_f32(vmaxq_f32(vmulq_f32(v38, v39), v25), v34).f32[0]));
      v48 = vaddq_f32(v42, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v8 + v21), v42), vminq_f32(vmaxq_f32(vmulq_f32(v43, v45), v25), v34).f32[0]));
      v49 = vaddq_f32(v47, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v8 + v21 + 16), v47), vminq_f32(vmaxq_f32(vmulq_f32(v44, v45), v25), v34).f32[0]));
      v50 = v24[8];
      v51 = v24[9];
      v52 = vaddq_f32(v48, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v21), v48), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v28, v46), v50), v25), v34).f32[0]));
      v53 = vaddq_f32(v49, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v21 + 16), v49), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v29, v46), v50), v25), v34).f32[0]));
      v54 = vmaxq_f32(vmulq_f32(vaddq_f32(v28, v51), v26), v25);
      v55 = vaddq_f32(v53, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v21 + 16), v53), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v29, v51), v26), v25), v34).f32[0]));
      v56 = (float32x4_t *)(v5 + v21);
      *v56 = vaddq_f32(v52, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v21), v52), vminq_f32(v54, v34).f32[0]));
      v56[1] = v55;
      v22 -= 2;
      v21 += 32;
    }
    while (v4 + v22 > 1);
    v57 = -v22;
    if (v57 >= v4)
      goto LABEL_3;
LABEL_10:
    v58 = 16 * v57;
    v59 = (float32x4_t *)*((_QWORD *)this + 51);
    v60 = v59[11];
    v61 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v20 + v58), v60), *v59);
    v62 = v59[12];
    v63 = vaddq_f32(*(float32x4_t *)(v17 + v58), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v16 + v58), *(float32x4_t *)(v17 + v58)), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v61, v59[1]), v59[2]), v60), v62).f32[0]));
    v64 = vaddq_f32(v63, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v9 + v58), v63), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v61, v59[3]), v59[4]), v60), v62).f32[0]));
    v65 = vaddq_f32(v64, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v8 + v58), v64), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v61, v59[5]), v59[6]), v60), v62).f32[0]));
    v66 = vaddq_f32(v65, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v58), v65), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v61, v59[7]), v59[8]), v60), v62).f32[0]));
    *(float32x4_t *)(v5 + v58) = vaddq_f32(v66, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v58), v66), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v61, v59[9]), v59[10]), v60), v62).f32[0]));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBlendBlur_6::GetDOD(HgcBlendBlur_6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 7)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBlendBlur_6::GetROI(HgcBlendBlur_6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 7)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBlendBlur_6::~HgcBlendBlur_6(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65377D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F93440CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65377D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F93440CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlendBlur_6::SetParameter(HgcBlendBlur_6 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 0xA)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlendBlur_6::GetParameter(HgcBlendBlur_6 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 0xA)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlendBlur_7::GetProgram(HgcBlendBlur_7 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000a9f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]], \n"
             "    texture2d< half > hg_Texture7 [[ texture(7) ]], \n"
             "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r7 = (half4) hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*half(hg_Params[0].x);\n"
             "    r8.x = r0.x + half(hg_Params[1].x);\n"
             "    r8.x = clamp(r8.x*half(hg_Params[2].x), 0.00000h, 1.00000h);\n"
             "    r8 = mix(r1, r2, r8.xxxx);\n"
             "    r2.x = r0.x + half(hg_Params[3].x);\n"
             "    r2.x = clamp(r2.x*half(hg_Params[4].x), 0.00000h, 1.00000h);\n"
             "    r8 = mix(r8, r3, r2.xxxx);\n"
             "    r1.x = r0.x + half(hg_Params[5].x);\n"
             "    r1.x = clamp(r1.x*half(hg_Params[6].x), 0.00000h, 1.00000h);\n"
             "    r8 = mix(r8, r4, r1.xxxx);\n"
             "    r2.x = r0.x + half(hg_Params[7].x);\n"
             "    r2.x = clamp(r2.x*half(hg_Params[8].x), 0.00000h, 1.00000h);\n"
             "    r8 = mix(r8, r5, r2.xxxx);\n"
             "    r3.x = r0.x + half(hg_Params[9].x);\n"
             "    r3.x = clamp(r3.x*half(hg_Params[10].x), 0.00000h, 1.00000h);\n"
             "    r8 = mix(r8, r6, r3.xxxx);\n"
             "    r0.x = r0.x + half(hg_Params[11].x);\n"
             "    r0.x = clamp(r0.x*half(hg_Params[12].x), 0.00000h, 1.00000h);\n"
             "    output.color0 = mix(float4(r8), float4(r7), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=51e82de0:83cef4b8:dbcd9194:23d36838\n"
             "//SIG=00400000:000000ff:000000ff:000000ff:0001:000d:0009:0000:0000:0000:01fe:0000:0008:08:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000a05\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]], \n"
             "    texture2d< float > hg_Texture7 [[ texture(7) ]], \n"
             "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r7 = hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
             "    r0.x = fmax(r0.x, c0.x);\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r8.x = r0.x + hg_Params[1].x;\n"
             "    r8.x = clamp(r8.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
             "    r8 = mix(r1, r2, r8.xxxx);\n"
             "    r2.x = r0.x + hg_Params[3].x;\n"
             "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
             "    r8 = mix(r8, r3, r2.xxxx);\n"
             "    r1.x = r0.x + hg_Params[5].x;\n"
             "    r1.x = clamp(r1.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
             "    r8 = mix(r8, r4, r1.xxxx);\n"
             "    r2.x = r0.x + hg_Params[7].x;\n"
             "    r2.x = clamp(r2.x*hg_Params[8].x, 0.00000f, 1.00000f);\n"
             "    r8 = mix(r8, r5, r2.xxxx);\n"
             "    r3.x = r0.x + hg_Params[9].x;\n"
             "    r3.x = clamp(r3.x*hg_Params[10].x, 0.00000f, 1.00000f);\n"
             "    r8 = mix(r8, r6, r3.xxxx);\n"
             "    r0.x = r0.x + hg_Params[11].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[12].x, 0.00000f, 1.00000f);\n"
             "    output.color0 = mix(r8, r7, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aefb9964:b413e645:3f06c610:528cb829\n"
             "//SIG=00000000:000000ff:000000ff:00000000:0001:000d:0009:0000:0000:0000:01fe:0000:0008:08:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000ae2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp sampler2D hg_Texture6;\n"
           "uniform defaultp sampler2D hg_Texture7;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "uniform defaultp vec4 hg_ProgramLocal5;\n"
           "uniform defaultp vec4 hg_ProgramLocal6;\n"
           "uniform defaultp vec4 hg_ProgramLocal7;\n"
           "uniform defaultp vec4 hg_ProgramLocal8;\n"
           "uniform defaultp vec4 hg_ProgramLocal9;\n"
           "uniform defaultp vec4 hg_ProgramLocal10;\n"
           "uniform defaultp vec4 hg_ProgramLocal11;\n"
           "uniform defaultp vec4 hg_ProgramLocal12;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "varying highp vec4 hg_TexCoord7;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
           "    r7 = texture2D(hg_Texture7, hg_TexCoord7.xy);\n"
           "    r0.x = max(r0.x, c0.x);\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r8.x = r0.x + hg_ProgramLocal1.x;\n"
           "    r8.x = clamp(r8.x*hg_ProgramLocal2.x, 0.00000, 1.00000);\n"
           "    r8 = mix(r1, r2, r8.xxxx);\n"
           "    r2.x = r0.x + hg_ProgramLocal3.x;\n"
           "    r2.x = clamp(r2.x*hg_ProgramLocal4.x, 0.00000, 1.00000);\n"
           "    r8 = mix(r8, r3, r2.xxxx);\n"
           "    r1.x = r0.x + hg_ProgramLocal5.x;\n"
           "    r1.x = clamp(r1.x*hg_ProgramLocal6.x, 0.00000, 1.00000);\n"
           "    r8 = mix(r8, r4, r1.xxxx);\n"
           "    r2.x = r0.x + hg_ProgramLocal7.x;\n"
           "    r2.x = clamp(r2.x*hg_ProgramLocal8.x, 0.00000, 1.00000);\n"
           "    r8 = mix(r8, r5, r2.xxxx);\n"
           "    r3.x = r0.x + hg_ProgramLocal9.x;\n"
           "    r3.x = clamp(r3.x*hg_ProgramLocal10.x, 0.00000, 1.00000);\n"
           "    r8 = mix(r8, r6, r3.xxxx);\n"
           "    r0.x = r0.x + hg_ProgramLocal11.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal12.x, 0.00000, 1.00000);\n"
           "    gl_FragColor = mix(r8, r7, r0.xxxx);\n"
           "}\n"
           "//MD5=a4232dfd:d5009303:f8b376c4:de0134f6\n"
           "//SIG=00000000:000000ff:000000ff:00000000:0001:000d:0009:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
  }
}

void HgcBlendBlur_7::InitProgramDescriptor(HgcBlendBlur_7 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlendBlur_7_hgc_visible", "//Metal1.0     \n//LEN=0000000580\n[[ visible ]] FragmentOut HgcBlendBlur_7_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5,\n    float4 color6,\n    float4 color7)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r6 = color6;\n"
    "    r7 = color7;\n"
    "    r0.x = fmax(r0.x, c0.x);\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r8.x = r0.x + hg_Params[1].x;\n"
    "    r8.x = clamp(r8.x*hg_Params[2].x, 0.00000f, 1.00000f);\n"
    "    r8 = mix(r1, r2, r8.xxxx);\n"
    "    r2.x = r0.x + hg_Params[3].x;\n"
    "    r2.x = clamp(r2.x*hg_Params[4].x, 0.00000f, 1.00000f);\n"
    "    r8 = mix(r8, r3, r2.xxxx);\n"
    "    r1.x = r0.x + hg_Params[5].x;\n"
    "    r1.x = clamp(r1.x*hg_Params[6].x, 0.00000f, 1.00000f);\n"
    "    r8 = mix(r8, r4, r1.xxxx);\n"
    "    r2.x = r0.x + hg_Params[7].x;\n"
    "    r2.x = clamp(r2.x*hg_Params[8].x, 0.00000f, 1.00000f);\n"
    "    r8 = mix(r8, r5, r2.xxxx);\n"
    "    r3.x = r0.x + hg_Params[9].x;\n"
    "    r3.x = clamp(r3.x*hg_Params[10].x, 0.00000f, 1.00000f);\n"
    "    r8 = mix(r8, r6, r3.xxxx);\n"
    "    r0.x = r0.x + hg_Params[11].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[12].x, 0.00000f, 1.00000f);\n"
    "    output.color0 = mix(r8, r7, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B92BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B92C00(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B92BF8);
}

void HgcBlendBlur_7::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcBlendBlur_7 [hgc1]");
}

uint64_t HgcBlendBlur_7::BindTexture(HgcBlendBlur_7 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_11;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_11;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_11;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_11;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
      goto LABEL_11;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 5;
      goto LABEL_11;
    case 6:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 6, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 6;
      goto LABEL_11;
    case 7:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 7, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 7;
LABEL_11:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcBlendBlur_7::Bind(HgcBlendBlur_7 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 8, *((_QWORD *)this + 51) + 128, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 9, *((_QWORD *)this + 51) + 144, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 10, *((_QWORD *)this + 51) + 160, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 11, *((_QWORD *)this + 51) + 176, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 12, *((_QWORD *)this + 51) + 192, 1);
  (*(void (**)(HgcBlendBlur_7 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlendBlur_7::RenderTile(HgcBlendBlur_7 *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = 16 * *((int *)a2 + 22);
    v5 = 16 * *((int *)a2 + 26);
    v6 = *((_QWORD *)a2 + 10);
    v7 = *((_QWORD *)a2 + 12);
    v8 = 16 * *((int *)a2 + 30);
    v9 = 16 * *((int *)a2 + 34);
    v10 = *((_QWORD *)a2 + 14);
    v11 = *((_QWORD *)a2 + 16);
    v12 = 16 * *((int *)a2 + 38);
    v13 = 16 * *((int *)a2 + 42);
    v14 = *((_QWORD *)a2 + 18);
    v15 = *((_QWORD *)a2 + 20);
    v16 = 16 * *((int *)a2 + 46);
    v17 = 16 * *((int *)a2 + 50);
    v18 = *((_QWORD *)a2 + 22);
    v19 = *((_QWORD *)a2 + 24);
    v20 = 16 * *((int *)a2 + 6);
    v21 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v22 = *((_QWORD *)a2 + 2);
    do
    {
      v23 = 0;
      do
      {
        v24 = (float32x4_t *)*((_QWORD *)this + 51);
        v25 = v24[13];
        v26 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v23), v25), *v24);
        v27 = v24[14];
        v28 = vaddq_f32(*(float32x4_t *)(v7 + v23), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v10 + v23), *(float32x4_t *)(v7 + v23)), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24[1]), v24[2]), v25), v27).f32[0]));
        v29 = vaddq_f32(v28, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v11 + v23), v28), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24[3]), v24[4]), v25), v27).f32[0]));
        v30 = vaddq_f32(v29, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v14 + v23), v29), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24[5]), v24[6]), v25), v27).f32[0]));
        v31 = vaddq_f32(v30, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v15 + v23), v30), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24[7]), v24[8]), v25), v27).f32[0]));
        v32 = vaddq_f32(v31, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v18 + v23), v31), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24[9]), v24[10]), v25), v27).f32[0]));
        *(float32x4_t *)(v22 + v23) = vaddq_f32(v32, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v19 + v23), v32), vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32(v26, v24[11]), v24[12]), v25), v27).f32[0]));
        v23 += 16;
      }
      while (v21 != v23);
      ++v3;
      v6 += v4;
      v7 += v5;
      v10 += v8;
      v11 += v9;
      v14 += v12;
      v15 += v13;
      v18 += v16;
      v19 += v17;
      v22 += v20;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBlendBlur_7::GetDOD(HgcBlendBlur_7 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBlendBlur_7::GetROI(HgcBlendBlur_7 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBlendBlur_7::~HgcBlendBlur_7(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6537A20;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6537A20;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019FCA701);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlendBlur_7::SetParameter(HgcBlendBlur_7 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 0xC)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlendBlur_7::GetParameter(HgcBlendBlur_7 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 0xC)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

void HGModulatedBlur::HGModulatedBlur(HGModulatedBlur *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E6537C70;
  *(_QWORD *)(v1 + 416) = 0;
  *(_QWORD *)(v1 + 424) = 0;
  *(_QWORD *)(v1 + 408) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(v1 + 432) = _D0;
  *(_DWORD *)(v1 + 440) = 1065353216;
  *(_QWORD *)(v1 + 448) = 0;
  *(_BYTE *)(v1 + 456) = 1;
  HGModulatedBlur::setBlurValues((HGModulatedBlur *)v1, HGModulatedBlur::HGModulatedBlur(void)::defaultBlurValues, 9);
}

void sub_1B2B9348C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v4;
  void *v5;

  v4 = *(_QWORD *)(v1 + 448);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 416) = v5;
    operator delete(v5);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGModulatedBlur::setBlurValues(HGModulatedBlur *this, const float *a2, uint64_t a3)
{
  float *v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _BYTE *v16;
  float *v17;
  unint64_t v18;
  float *v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  float *v23;
  uint64_t v24;
  __int128 v25;
  int v26;
  void **v27;

  v4 = (float *)*((_QWORD *)this + 51);
  *((_QWORD *)this + 52) = v4;
  if (a3)
  {
    v7 = 0;
    v27 = (void **)((char *)this + 408);
    while (1)
    {
      v9 = *((_QWORD *)this + 53);
      if ((unint64_t)v4 >= v9)
        break;
      *v4 = a2[v7];
      v8 = (uint64_t)(v4 + 1);
LABEL_4:
      *((_QWORD *)this + 52) = v8;
      ++v7;
      v4 = (float *)v8;
      if (v7 == a3)
        goto LABEL_31;
    }
    v10 = (float *)*v27;
    v11 = (char *)v4 - (_BYTE *)*v27;
    v12 = v11 >> 2;
    v13 = (v11 >> 2) + 1;
    if (v13 >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v14 = v9 - (_QWORD)v10;
    if (v14 >> 1 > v13)
      v13 = v14 >> 1;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL)
      v15 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
    {
      if (v15 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v16 = operator new(4 * v15);
      v17 = (float *)&v16[4 * v12];
      *v17 = a2[v7];
      v8 = (uint64_t)(v17 + 1);
      if (v4 == v10)
        goto LABEL_29;
    }
    else
    {
      v16 = 0;
      v17 = (float *)(4 * v12);
      *(float *)(4 * v12) = a2[v7];
      v8 = 4 * v12 + 4;
      if (v4 == v10)
        goto LABEL_29;
    }
    v18 = (char *)(v4 - 1) - (char *)v10;
    if (v18 >= 0xBC)
    {
      if (&v16[v11 - 4 - (v18 & 0xFFFFFFFFFFFFFFFCLL)] > &v16[v11 - 4])
      {
        v19 = v4;
      }
      else if ((float *)((char *)v4 - (v18 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v4 - 1)
      {
        v19 = v4;
      }
      else if ((unint64_t)((char *)v4 - &v16[v11]) >= 0x20)
      {
        v20 = (v18 >> 2) + 1;
        v21 = 4 * (v20 & 0x7FFFFFFFFFFFFFF8);
        v19 = &v4[v21 / 0xFFFFFFFFFFFFFFFCLL];
        v17 = (float *)((char *)v17 - v21);
        v22 = &v16[4 * v12 - 16];
        v23 = v4 - 4;
        v24 = v20 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v25 = *(_OWORD *)v23;
          *(v22 - 1) = *((_OWORD *)v23 - 1);
          *v22 = v25;
          v22 -= 2;
          v23 -= 8;
          v24 -= 8;
        }
        while (v24);
        if (v20 == (v20 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_29:
          *((_QWORD *)this + 51) = v17;
          *((_QWORD *)this + 52) = v8;
          *((_QWORD *)this + 53) = &v16[4 * v15];
          if (v10)
            operator delete(v10);
          goto LABEL_4;
        }
      }
      else
      {
        v19 = v4;
      }
    }
    else
    {
      v19 = v4;
    }
    do
    {
      v26 = *((_DWORD *)v19-- - 1);
      *((_DWORD *)v17-- - 1) = v26;
    }
    while (v19 != v10);
    goto LABEL_29;
  }
LABEL_31:
  *((_BYTE *)this + 456) = 1;
}

void HGModulatedBlur::~HGModulatedBlur(HGNode *this)
{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6537C70;
  v2 = *((_QWORD *)this + 56);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = (void *)*((_QWORD *)this + 51);
  if (v3)
  {
    *((_QWORD *)this + 52) = v3;
    operator delete(v3);
  }
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6537C70;
  v2 = *((_QWORD *)this + 56);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = (void *)*((_QWORD *)this + 51);
  if (v3)
  {
    *((_QWORD *)this + 52) = v3;
    operator delete(v3);
  }
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_1E6537C70;
  v2 = *((_QWORD *)this + 56);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = (void *)*((_QWORD *)this + 51);
  if (v3)
  {
    *((_QWORD *)this + 52) = v3;
    operator delete(v3);
  }
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGModulatedBlur::SetParameter(HGModulatedBlur *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;

  if ((_DWORD)a2 == 1)
  {
    if (*((float *)this + 109) != a3 || *((float *)this + 110) != a4)
    {
      v7 = 0xFFFFFFFFLL;
      if (a3 < 0.0 || a4 < 0.0)
        return v7;
      *((float *)this + 109) = a3;
      *((float *)this + 110) = a4;
LABEL_10:
      v7 = 1;
      *((_BYTE *)this + 456) = 1;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return v7;
    }
  }
  else
  {
    if ((_DWORD)a2)
      return 0xFFFFFFFFLL;
    if (*((float *)this + 108) != a3)
    {
      *((float *)this + 108) = a3;
      goto LABEL_10;
    }
  }
  return 0;
}

uint64_t HGModulatedBlur::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *v2;
  HGNode *Input;
  float *v5;
  float *v6;
  float *v7;
  float *v8;
  uint64_t v9;
  unsigned int v10;
  float *v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _BYTE *v22;
  float *v23;
  uint64_t v24;
  unint64_t v25;
  float *v26;
  int v27;
  float *v28;
  float *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _BYTE *v34;
  float *v35;
  uint64_t v36;
  unint64_t v37;
  float *v38;
  int v39;
  float *v40;
  uint64_t v41;
  uint64_t v42;
  _OWORD *v43;
  float *v44;
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  _OWORD *v49;
  float *v50;
  uint64_t v51;
  __int128 v52;
  signed int v53;
  uint64_t v54;
  HGNode *v55;
  unint64_t v56;
  uint64_t v57;
  HGNode *v58;
  _OWORD *v59;
  float *v60;
  float v61;
  float v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  float v67;
  float v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  float v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  float v77;
  float v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  float v87;
  float v88;
  uint64_t v89;
  uint64_t v90;
  HGNode *v91;
  float *v92;
  HGNode *v94;
  unsigned int v95;
  unint64_t v96;
  HGNode *v97;
  HGBlurGroup *v98;
  float *v99;
  float *__p;
  float *v101;

  v2 = this;
  if (!*((_BYTE *)this + 456))
    return *((_QWORD *)v2 + 56);
  Input = HGRenderer::GetInput(a2, this, 0);
  v94 = HGRenderer::GetInput(a2, v2, 1u);
  v98 = (HGBlurGroup *)HGObject::operator new(0x70uLL);
  HGBlurGroup::HGBlurGroup(v98, Input, 0);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = *((_QWORD *)v2 + 51);
  v97 = v2;
  do
  {
    v15 = *((float *)v2 + 109) * *(float *)(v13 + 4 * v9);
    if (v6 < v8)
    {
      *v6++ = v15;
      v16 = *((float *)v2 + 110) * *(float *)(v13 + 4 * v9);
      if (v5 < v7)
        goto LABEL_3;
      goto LABEL_26;
    }
    v17 = v6 - v11;
    v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    if (((char *)v8 - (char *)v11) >> 1 > v18)
      v18 = ((char *)v8 - (char *)v11) >> 1;
    if ((unint64_t)((char *)v8 - (char *)v11) >= 0x7FFFFFFFFFFFFFFCLL)
      v19 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v19 = v18;
    v95 = v10;
    v96 = (unint64_t)v7;
    if (v19)
    {
      if (v19 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v20 = v13;
      v21 = v19;
      v22 = operator new(4 * v19);
      v13 = v20;
      v19 = v21;
      v23 = (float *)&v22[4 * v17];
      *v23 = v15;
      v24 = (uint64_t)(v23 + 1);
      if (v6 == v11)
        goto LABEL_22;
    }
    else
    {
      v22 = 0;
      v23 = (float *)(4 * v17);
      *(float *)(4 * v17) = v15;
      v24 = 4 * v17 + 4;
      if (v6 == v11)
        goto LABEL_22;
    }
    v25 = (char *)(v6 - 1) - (char *)v11;
    if (v25 >= 0xBC)
    {
      if (&v22[(char *)v6 - (char *)v11 - 4 - (v25 & 0xFFFFFFFFFFFFFFFCLL)] > &v22[(char *)v6 - (char *)v11 - 4])
      {
        v26 = v6;
      }
      else if ((float *)((char *)v6 - (v25 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v6 - 1)
      {
        v26 = v6;
      }
      else if ((unint64_t)((char *)v11 - v22) >= 0x20)
      {
        v41 = (v25 >> 2) + 1;
        v42 = 4 * (v41 & 0x7FFFFFFFFFFFFFF8);
        v26 = &v6[v42 / 0xFFFFFFFFFFFFFFFCLL];
        v23 = (float *)((char *)v23 - v42);
        v43 = &v22[4 * v17 - 16];
        v44 = v6 - 4;
        v45 = v41 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v46 = *(_OWORD *)v44;
          *(v43 - 1) = *((_OWORD *)v44 - 1);
          *v43 = v46;
          v43 -= 2;
          v44 -= 8;
          v45 -= 8;
        }
        while (v45);
        if (v41 == (v41 & 0x7FFFFFFFFFFFFFF8))
          goto LABEL_22;
      }
      else
      {
        v26 = v6;
      }
    }
    else
    {
      v26 = v6;
    }
    do
    {
      v27 = *((_DWORD *)v26-- - 1);
      *((_DWORD *)v23-- - 1) = v27;
    }
    while (v26 != v11);
LABEL_22:
    v8 = (float *)&v22[4 * v19];
    if (v11)
    {
      v28 = v5;
      v29 = (float *)&v22[4 * v19];
      operator delete(v11);
      v8 = v29;
      v5 = v28;
      v2 = v97;
      v13 = *((_QWORD *)v97 + 51);
      v11 = v23;
      v6 = (float *)v24;
    }
    else
    {
      v11 = v23;
      v6 = (float *)v24;
      v2 = v97;
    }
    v10 = v95;
    v7 = (float *)v96;
    v16 = *((float *)v2 + 110) * *(float *)(v13 + 4 * v9);
    if ((unint64_t)v5 < v96)
    {
LABEL_3:
      *v5++ = v16;
      goto LABEL_4;
    }
LABEL_26:
    v30 = v5 - v12;
    v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    if (((char *)v7 - (char *)v12) >> 1 > v31)
      v31 = ((char *)v7 - (char *)v12) >> 1;
    if ((unint64_t)((char *)v7 - (char *)v12) >= 0x7FFFFFFFFFFFFFFCLL)
      v32 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v32 = v31;
    v99 = v8;
    if (v32)
    {
      if (v32 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v33 = v13;
      v34 = operator new(4 * v32);
      v13 = v33;
      v35 = (float *)&v34[4 * v30];
      *v35 = v16;
      v36 = (uint64_t)(v35 + 1);
      if (v5 == v12)
        goto LABEL_40;
    }
    else
    {
      v34 = 0;
      v35 = (float *)(4 * v30);
      *(float *)(4 * v30) = v16;
      v36 = 4 * v30 + 4;
      if (v5 == v12)
        goto LABEL_40;
    }
    v37 = (char *)(v5 - 1) - (char *)v12;
    if (v37 < 0xBC)
    {
      v38 = v5;
      goto LABEL_39;
    }
    if (&v34[(char *)v5 - (char *)v12 - 4 - (v37 & 0xFFFFFFFFFFFFFFFCLL)] > &v34[(char *)v5 - (char *)v12 - 4])
    {
      v38 = v5;
      do
      {
LABEL_39:
        v39 = *((_DWORD *)v38-- - 1);
        *((_DWORD *)v35-- - 1) = v39;
      }
      while (v38 != v12);
      goto LABEL_40;
    }
    if ((float *)((char *)v5 - (v37 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v5 - 1)
    {
      v38 = v5;
      goto LABEL_39;
    }
    if ((unint64_t)((char *)v12 - v34) < 0x20)
    {
      v38 = v5;
      goto LABEL_39;
    }
    v47 = (v37 >> 2) + 1;
    v48 = 4 * (v47 & 0x7FFFFFFFFFFFFFF8);
    v38 = &v5[v48 / 0xFFFFFFFFFFFFFFFCLL];
    v35 = (float *)((char *)v35 - v48);
    v49 = &v34[4 * v30 - 16];
    v50 = v5 - 4;
    v51 = v47 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v52 = *(_OWORD *)v50;
      *(v49 - 1) = *((_OWORD *)v50 - 1);
      *v49 = v52;
      v49 -= 2;
      v50 -= 8;
      v51 -= 8;
    }
    while (v51);
    if (v47 != (v47 & 0x7FFFFFFFFFFFFFF8))
      goto LABEL_39;
LABEL_40:
    v7 = (float *)&v34[4 * v32];
    if (v12)
    {
      v40 = (float *)&v34[4 * v32];
      operator delete(v12);
      v7 = v40;
      v2 = v97;
      v13 = *((_QWORD *)v97 + 51);
      v12 = v35;
      v5 = (float *)v36;
    }
    else
    {
      v12 = v35;
      v5 = (float *)v36;
      v2 = v97;
    }
    v8 = v99;
LABEL_4:
    v14 = (*((_QWORD *)v2 + 52) - v13) >> 2;
    v9 = ++v10;
  }
  while (v14 > v10);
  v101 = v11;
  __p = v12;
  HGBlurGroup::setBlurValues(v98, v11, v12, v14);
  v53 = ((*((_QWORD *)v2 + 52) - *((_QWORD *)v2 + 51)) >> 2) - 1;
  v54 = HGBlurGroup::level(v98, v53);
  v55 = (HGNode *)v54;
  if (v54)
    (*(void (**)(uint64_t))(*(_QWORD *)v54 + 16))(v54);
  v56 = *((_QWORD *)v2 + 52) - *((_QWORD *)v2 + 51);
  while (v53)
  {
    if ((v53 + 1) < 7)
      v57 = (v53 + 1);
    else
      v57 = 7;
    switch((int)v57)
    {
      case 2:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        *(_QWORD *)v58 = off_1E6536E90;
        v59 = (_OWORD *)operator new();
        v59[2] = 0u;
        v59[3] = 0u;
        *v59 = 0u;
        v59[1] = 0u;
        v59[4] = xmmword_1B304F230;
        goto LABEL_80;
      case 3:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        *(_QWORD *)v58 = off_1E65370E0;
        v59 = (_OWORD *)operator new();
        v59[4] = 0u;
        v59[5] = 0u;
        v59[2] = 0u;
        v59[3] = 0u;
        *v59 = 0u;
        v59[1] = 0u;
        v59[6] = xmmword_1B304F230;
        goto LABEL_80;
      case 4:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        *(_QWORD *)v58 = off_1E6537330;
        v59 = (_OWORD *)operator new();
        v59[6] = 0u;
        v59[7] = 0u;
        v59[4] = 0u;
        v59[5] = 0u;
        v59[2] = 0u;
        v59[3] = 0u;
        *v59 = 0u;
        v59[1] = 0u;
        v59[8] = xmmword_1B304F230;
        goto LABEL_80;
      case 5:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        *(_QWORD *)v58 = off_1E6537580;
        v59 = (_OWORD *)operator new();
        v59[8] = 0u;
        v59[9] = 0u;
        v59[6] = 0u;
        v59[7] = 0u;
        v59[4] = 0u;
        v59[5] = 0u;
        v59[2] = 0u;
        v59[3] = 0u;
        *v59 = 0u;
        v59[1] = 0u;
        v59[10] = xmmword_1B304F230;
        goto LABEL_80;
      case 6:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        *(_QWORD *)v58 = off_1E65377D0;
        v59 = (_OWORD *)operator new();
        v59[10] = 0u;
        v59[11] = 0u;
        v59[8] = 0u;
        v59[9] = 0u;
        v59[6] = 0u;
        v59[7] = 0u;
        v59[4] = 0u;
        v59[5] = 0u;
        v59[2] = 0u;
        v59[3] = 0u;
        *v59 = 0u;
        v59[1] = 0u;
        v59[12] = xmmword_1B304F230;
        goto LABEL_80;
      case 7:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        *(_QWORD *)v58 = off_1E6537A20;
        v59 = (_OWORD *)operator new();
        v59[12] = 0u;
        v59[13] = 0u;
        v59[10] = 0u;
        v59[11] = 0u;
        v59[8] = 0u;
        v59[9] = 0u;
        v59[6] = 0u;
        v59[7] = 0u;
        v59[4] = 0u;
        v59[5] = 0u;
        v59[2] = 0u;
        v59[3] = 0u;
        *v59 = 0u;
        v59[1] = 0u;
        v59[14] = xmmword_1B304F230;
LABEL_80:
        *((_QWORD *)v58 + 51) = v59;
        *((_DWORD *)v58 + 4) |= 0x600u;
        break;
      default:
        v58 = (HGNode *)HGObject::operator new(0x1A0uLL);
        HGNode::HGNode(v58);
        break;
    }
    (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v58 + 120))(v58, 0, v94);
    (*(void (**)(HGNode *, _QWORD, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 0, *((float *)v2 + 108), 0.0, 0.0, 0.0);
    if (v56 >= 0x1D)
      (*(void (**)(HGNode *, _QWORD, uint64_t))(*(_QWORD *)v58 + 136))(v58, 0, 2);
    v53 -= v57 - 1;
    if (v57 >= 2)
    {
      v60 = (float *)(*((_QWORD *)v2 + 51) + 4 * v53);
      v61 = *v60;
      v62 = v60[1];
      v63 = HGBlurGroup::level(v98, v53);
      v64 = v63;
      if (v63)
        (*(void (**)(uint64_t))(*(_QWORD *)v63 + 16))(v63);
      (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v58 + 120))(v58, 1, v64);
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 1, -v61, 0.0, 0.0, 0.0);
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 2, 1.0 / (float)(v62 - v61), 0.0, 0.0, 0.0);
      if (v64)
        (*(void (**)(uint64_t))(*(_QWORD *)v64 + 24))(v64);
      if ((_DWORD)v57 != 2)
      {
        v65 = v53 + 1;
        v66 = *((_QWORD *)v2 + 51);
        v67 = *(float *)(v66 + 4 * v65);
        v68 = *(float *)(v66 + 4 * v53 + 8);
        v69 = HGBlurGroup::level(v98, v65);
        v70 = v69;
        if (v69)
          (*(void (**)(uint64_t))(*(_QWORD *)v69 + 16))(v69);
        (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v58 + 120))(v58, 2, v70);
        (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 3, -v67, 0.0, 0.0, 0.0);
        (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 4, 1.0 / (float)(v68 - v67), 0.0, 0.0, 0.0);
        if (v70)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 24))(v70);
        if ((_DWORD)v57 != 3)
        {
          v71 = *((_QWORD *)v2 + 51);
          v72 = *(float *)(v71 + 4 * (v53 + 2));
          v73 = *(float *)(v71 + 4 * v53 + 12);
          v74 = HGBlurGroup::level(v98, v53 + 2);
          v75 = v74;
          if (v74)
            (*(void (**)(uint64_t))(*(_QWORD *)v74 + 16))(v74);
          (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v58 + 120))(v58, 3, v75);
          (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 5, -v72, 0.0, 0.0, 0.0);
          (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 6, 1.0 / (float)(v73 - v72), 0.0, 0.0, 0.0);
          if (v75)
            (*(void (**)(uint64_t))(*(_QWORD *)v75 + 24))(v75);
          if ((_DWORD)v57 != 4)
          {
            v76 = *((_QWORD *)v2 + 51);
            v77 = *(float *)(v76 + 4 * (v53 + 3));
            v78 = *(float *)(v76 + 4 * v53 + 16);
            v79 = HGBlurGroup::level(v98, v53 + 3);
            v80 = v79;
            if (v79)
              (*(void (**)(uint64_t))(*(_QWORD *)v79 + 16))(v79);
            (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v58 + 120))(v58, 4, v80);
            (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 7, -v77, 0.0, 0.0, 0.0);
            (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 8, 1.0 / (float)(v78 - v77), 0.0, 0.0, 0.0);
            if (v80)
              (*(void (**)(uint64_t))(*(_QWORD *)v80 + 24))(v80);
            if ((_DWORD)v57 != 5)
            {
              v81 = *((_QWORD *)v2 + 51);
              v82 = *(float *)(v81 + 4 * (v53 + 4));
              v83 = *(float *)(v81 + 4 * v53 + 20);
              v84 = HGBlurGroup::level(v98, v53 + 4);
              v85 = v84;
              if (v84)
                (*(void (**)(uint64_t))(*(_QWORD *)v84 + 16))(v84);
              (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v58 + 120))(v58, 5, v85);
              (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 9, -v82, 0.0, 0.0, 0.0);
              (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 10, 1.0 / (float)(v83 - v82), 0.0, 0.0, 0.0);
              if (v85)
                (*(void (**)(uint64_t))(*(_QWORD *)v85 + 24))(v85);
              if ((_DWORD)v57 != 6)
              {
                v86 = *((_QWORD *)v2 + 51);
                v87 = *(float *)(v86 + 4 * (v53 + 5));
                v88 = *(float *)(v86 + 4 * v53 + 24);
                v89 = HGBlurGroup::level(v98, v53 + 5);
                v90 = v89;
                if (v89)
                  (*(void (**)(uint64_t))(*(_QWORD *)v89 + 16))(v89);
                (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v58 + 120))(v58, 6, v90);
                (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 11, -v87, 0.0, 0.0, 0.0);
                (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v58 + 96))(v58, 12, 1.0 / (float)(v88 - v87), 0.0, 0.0, 0.0);
                if (v90)
                  (*(void (**)(uint64_t))(*(_QWORD *)v90 + 24))(v90);
              }
            }
          }
        }
      }
    }
    (*(void (**)(HGNode *, uint64_t, HGNode *))(*(_QWORD *)v58 + 120))(v58, v57, v55);
    if (v55 != v58)
    {
      if (v55)
        (*(void (**)(HGNode *))(*(_QWORD *)v55 + 24))(v55);
      v55 = v58;
      (*(void (**)(HGNode *))(*(_QWORD *)v58 + 16))(v58);
    }
    (*(void (**)(HGNode *))(*(_QWORD *)v58 + 24))(v58);
  }
  v91 = (HGNode *)*((_QWORD *)v2 + 56);
  if (v91 != v55)
  {
    if (v91)
      (*(void (**)(HGNode *))(*(_QWORD *)v91 + 24))(v91);
    *((_QWORD *)v2 + 56) = v55;
    if (v55)
    {
      (*(void (**)(HGNode *))(*(_QWORD *)v55 + 16))(v55);
      *((_BYTE *)v2 + 456) = 0;
      goto LABEL_123;
    }
    *((_BYTE *)v2 + 456) = 0;
    v92 = __p;
    if (!__p)
      goto LABEL_126;
LABEL_125:
    operator delete(v92);
    goto LABEL_126;
  }
  *((_BYTE *)v2 + 456) = 0;
  if (v55)
LABEL_123:
    (*(void (**)(HGNode *))(*(_QWORD *)v55 + 24))(v55);
  v92 = __p;
  if (__p)
    goto LABEL_125;
LABEL_126:
  if (v101)
    operator delete(v101);
  if (v98)
    (*(void (**)(HGBlurGroup *))(*(_QWORD *)v98 + 24))(v98);
  return *((_QWORD *)v2 + 56);
}

void sub_1B2B945DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22)
{
  uint64_t v22;
  void *v24;
  void *v25;

  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  if (__p)
  {
    operator delete(__p);
    v24 = a20;
    if (!a20)
    {
LABEL_5:
      v25 = a14;
      if (!a14)
LABEL_10:
        _Unwind_Resume(exception_object);
LABEL_9:
      (*(void (**)(void *))(*(_QWORD *)v25 + 24))(v25);
      goto LABEL_10;
    }
  }
  else
  {
    v24 = a20;
    if (!a20)
      goto LABEL_5;
  }
  operator delete(v24);
  v25 = a14;
  if (!a14)
    goto LABEL_10;
  goto LABEL_9;
}

void sub_1B2B94724()
{
  char v0;
  uint64_t v1;

  if ((v0 & 1) == 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  JUMPOUT(0x1B2B946A4);
}

const char *HgcYUV444BiPlanar_chroma_pack2::GetProgram(HgcYUV444BiPlanar_chroma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    output.color0.zw = float2(r1.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce6ee523:9a7b8c67:08d8a35c:044b1494\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    output.color0.zw = r1.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd23e448:1f27c2f2:089c40e5:1564cc7f\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    r1.yz = texture2D(hg_Texture0, hg_TexCoord1.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "    gl_FragColor.zw = r1.yz;\n"
           "}\n"
           "//MD5=7da700af:7eb22f7e:dd24a356:2070ab44\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_chroma_pack2::InitProgramDescriptor(HgcYUV444BiPlanar_chroma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_chroma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001ee\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_chroma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    output.color0.zw = r1.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B94BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B94BE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B94BE0);
}

char *HgcYUV444BiPlanar_chroma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcYUV444BiPlanar_chroma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::BindTexture(HgcYUV444BiPlanar_chroma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 1.0, 1.0, 0.0);
  return 0;
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::Bind(HgcYUV444BiPlanar_chroma_pack2 *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV444BiPlanar_chroma_pack2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::RenderTile(HgcYUV444BiPlanar_chroma_pack2 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int8x16_t *v12;
  _OWORD *v13;
  uint64_t v14;
  unint64_t v15;
  int8x16_t *v16;
  _OWORD *v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t *v27;
  _OWORD *v28;
  int8x16_t *v29;
  int8x16_t v30;
  int8x16_t v31;
  __int128 v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t i;
  int8x16_t v38;
  int8x16_t v39;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 22);
    v7 = *((int *)a2 + 6);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v33 = 0;
        v34 = v6 + 1;
        v35 = 16 * v6;
        v36 = 16 * v7;
        do
        {
          for (i = 0; i != v3; ++i)
          {
            v38 = v4[i];
            v39 = vextq_s8(v38, v4[v34 + (int)i], 0xCuLL);
            *(int8x8_t *)v38.i8 = vext_s8(*(int8x8_t *)v38.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), 4uLL);
            v38.i64[1] = vextq_s8(v39, v39, 8uLL).u64[0];
            *(int8x16_t *)(v5 + 16 * i) = v38;
          }
          v4 = (int8x16_t *)((char *)v4 + v35);
          ++v33;
          v5 += v36;
        }
        while (v33 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v6 + 1;
      v12 = v4 + 4;
      v13 = (_OWORD *)(v5 + 64);
      do
      {
        v14 = 0;
        v15 = 0;
        v16 = &v4[(unint64_t)v9 / 0x10];
        v17 = v13;
        v18 = v12;
        do
        {
          v19 = v4[v14];
          v20 = vextq_s8(v19, v16[v14 + 1], 0xCuLL);
          *(int8x8_t *)v19.i8 = vext_s8(*(int8x8_t *)v19.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), 4uLL);
          v19.i64[1] = vextq_s8(v20, v20, 8uLL).u64[0];
          v21 = vextq_s8(v19, v16[v14 + 2], 0xCuLL);
          *(int8x8_t *)v22.i8 = vext_s8(*(int8x8_t *)v4[v14 + 1].i8, (int8x8_t)*(_OWORD *)&vextq_s8(v4[v14 + 1], v4[v14 + 1], 8uLL), 4uLL);
          v22.i64[1] = vextq_s8(v21, v21, 8uLL).u64[0];
          v23 = vextq_s8(v19, v16[v14 + 3], 0xCuLL);
          *(int8x8_t *)v24.i8 = vext_s8(*(int8x8_t *)v4[v14 + 2].i8, (int8x8_t)*(_OWORD *)&vextq_s8(v4[v14 + 2], v4[v14 + 2], 8uLL), 4uLL);
          v24.i64[1] = vextq_s8(v23, v23, 8uLL).u64[0];
          v25 = vextq_s8(v19, v16[v14 + 4], 0xCuLL);
          *(int8x8_t *)v26.i8 = vext_s8(*(int8x8_t *)v4[v14 + 3].i8, (int8x8_t)*(_OWORD *)&vextq_s8(v4[v14 + 3], v4[v14 + 3], 8uLL), 4uLL);
          v26.i64[1] = vextq_s8(v25, v25, 8uLL).u64[0];
          v27 = v18;
          v28 = v17;
          v29 = (int8x16_t *)(v5 + v14 * 16);
          *v29 = v19;
          v29[1] = v22;
          v15 += 4;
          v29[2] = v24;
          v29[3] = v26;
          v14 += 4;
          v18 = v27 + 4;
          v17 += 4;
        }
        while ((uint64_t)v15 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v15)
        {
          do
          {
            v30 = *v27++;
            v31 = vextq_s8(v30, v4[v11 + (int)v15], 0xCuLL);
            *(int8x8_t *)&v32 = vext_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), 4uLL);
            *((_QWORD *)&v32 + 1) = vextq_s8(v31, v31, 8uLL).u64[0];
            *v28++ = v32;
            ++v15;
          }
          while (v15 < v3);
        }
        v4 = (int8x16_t *)((char *)v4 + v9);
        ++v8;
        v5 += v10;
        v12 = (int8x16_t *)((char *)v12 + v9);
        v13 = (_OWORD *)((char *)v13 + v10);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::GetDOD(HgcYUV444BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::GetROI(HgcYUV444BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

void HgcYUV444BiPlanar_chroma_pack2::HgcYUV444BiPlanar_chroma_pack2(HgcYUV444BiPlanar_chroma_pack2 *this)
{
  _QWORD *v2;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6537F68;
  *((_QWORD *)this + 51) = operator new();
  (*(void (**)(HgcYUV444BiPlanar_chroma_pack2 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2B95064(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_chroma_pack2::~HgcYUV444BiPlanar_chroma_pack2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6537F68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6537F68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::SetParameter(HgcYUV444BiPlanar_chroma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV444BiPlanar_chroma_pack2::GetParameter(HgcYUV444BiPlanar_chroma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV444BiPlanar_chroma::GetProgram(HgcYUV444BiPlanar_chroma *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000235\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5ceef05:898edb99:9f947171:98dbaa5b\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000227\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=513314b2:face81c8:9010d868:78fd2bc7\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "}\n"
           "//MD5=6e8f9b59:fe470076:deb0cf55:8a2a4614\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_chroma::InitProgramDescriptor(HgcYUV444BiPlanar_chroma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_chroma_hgc_visible", "//Metal1.0     \n//LEN=0000000109\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_chroma_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = color0.yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B953B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B953E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B953DCLL);
}

double HgcYUV444BiPlanar_chroma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcYUV444BiPlanar_chroma [hgc1]");
  return *(double *)"ar_chroma [hgc1]";
}

uint64_t HgcYUV444BiPlanar_chroma::BindTexture(HgcYUV444BiPlanar_chroma *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_chroma::Bind(HgcYUV444BiPlanar_chroma *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV444BiPlanar_chroma *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444BiPlanar_chroma::RenderTile(HgcYUV444BiPlanar_chroma *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t *v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t *v25;
  int8x16_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v27 = 0;
        v28 = 16 * v7;
        v29 = 16 * v6;
        v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v31 = 0;
          do
          {
            v5[v31 / 0x10] = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 62) + 128), vextq_s8(v4[v31 / 0x10], v4[v31 / 0x10], 4uLL), *(int8x16_t *)(*((_QWORD *)this + 62) + 112));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          v4 = (int8x16_t *)((char *)v4 + v28);
          v5 = (int8x16_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = (int8x16_t *)*((_QWORD *)this + 62);
          v21 = v19[7];
          v20 = v19[8];
          v22 = vbslq_s8(v20, vextq_s8(v4[v16 - 1], v4[v16 - 1], 4uLL), v21);
          v23 = vbslq_s8(v20, vextq_s8(v4[v16], v4[v16], 4uLL), v21);
          v24 = vbslq_s8(v20, vextq_s8(v4[v16 + 1], v4[v16 + 1], 4uLL), v21);
          v25 = &v5[v16];
          v25[-2] = vbslq_s8(v20, vextq_s8(v4[v16 - 2], v4[v16 - 2], 4uLL), v21);
          v25[-1] = v22;
          v13 += 4;
          *v25 = v23;
          v25[1] = v24;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v26 = *v17++;
            *v18++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 62) + 128), vextq_s8(v26, v26, 4uLL), *(int8x16_t *)(*((_QWORD *)this + 62) + 112));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (int8x16_t *)((char *)v4 + v10);
        v11 = (int8x16_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_chroma::GetDOD(HgcYUV444BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444BiPlanar_chroma::GetROI(HgcYUV444BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444BiPlanar_chroma::HgcYUV444BiPlanar_chroma(HgcYUV444BiPlanar_chroma *this)
{
  uint64_t v2;
  _OWORD *v3;

  HGColorMatrix::HGColorMatrix(this);
  *(_QWORD *)v2 = off_1E65381D0;
  *(_DWORD *)(v2 + 504) = 1;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304F230;
  v3[1] = xmmword_1B304F240;
  v3[2] = xmmword_1B304F250;
  v3[3] = xmmword_1B304EFF0;
  v3[4] = xmmword_1B304F230;
  v3[5] = xmmword_1B304F240;
  v3[6] = xmmword_1B304F250;
  v3[7] = xmmword_1B304EFF0;
  v3[8] = xmmword_1B3050F80;
  *((_QWORD *)this + 62) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9575C(_Unwind_Exception *a1)
{
  HGColorMatrix *v1;

  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_chroma::~HgcYUV444BiPlanar_chroma(HgcYUV444BiPlanar_chroma *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65381D0;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65381D0;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGColorMatrix::~HGColorMatrix(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_chroma::SetParameter(HgcYUV444BiPlanar_chroma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV444BiPlanar_chroma::GetParameter(HgcYUV444BiPlanar_chroma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcYUV444BiPlanar_chroma::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, int32x2_t a5)
{
  unint64_t v5;
  int8x16_t v6;
  __n128 *v7;

  if (this[31].n128_u32[2])
  {
    v5 = this[31].n128_u64[0];
    v6 = vextq_s8(*(int8x16_t *)(v5 + 80), *(int8x16_t *)(v5 + 80), 4uLL);
    a4 = (__n128)vextq_s8(*(int8x16_t *)(v5 + 96), *(int8x16_t *)(v5 + 96), 4uLL);
    *(double *)&a5 = 0.0;
    *(_OWORD *)v5 = 0u;
    *(int8x16_t *)(this[31].n128_u64[0] + 16) = v6;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a4;
    *(_OWORD *)(this[31].n128_u64[0] + 48) = 0u;
    v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], a5);
}

const char *HgcYUV420TriPlanar_601ToRGB::GetProgram(HgcYUV420TriPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c0cd9a4:962f63d5:0783359b:49528c86\n"
             "//SIG=00400000:00000005:00000005:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=24010ee7:6e1cd76d:c31b9c85:b9fbda97\n"
             "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=6448df2f:b4b78b65:3a0dc9a8:4e1d16fb\n"
           "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV420TriPlanar_601ToRGB::InitProgramDescriptor(HgcYUV420TriPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420TriPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut HgcYUV420TriPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B95D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B95DB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B95DACLL);
}

char *HgcYUV420TriPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV420TriPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420TriPlanar_601ToRGB::BindTexture(HgcYUV420TriPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  HGHandler *v5;
  int v6;
  int v7;

  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV420TriPlanar_601ToRGB::Bind(HgcYUV420TriPlanar_601ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV420TriPlanar_601ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420TriPlanar_601ToRGB::RenderTile(HgcYUV420TriPlanar_601ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v20;
  float32x4_t v21;
  int v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x2_t v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  float32x4_t v35;
  int32x4_t v36;
  int8x16_t v37;
  __int32 v38;
  __int32 v39;
  float32x4_t v40;
  int32x4_t v41;
  int8x16_t v42;
  __int32 v43;
  __int32 v44;
  float32x4_t v45;
  int32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  uint64_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t *v67;
  uint64_t v68;
  float32x4_t v70;
  int32x4_t v71;
  int8x16_t v72;
  uint64_t v73;
  float32x4_t v74;
  int8x16_t v75;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B30532D0);
    v8 = a2[2];
    v9 = a2[14];
    v10 = a2[10];
    v11 = 16 * a2[11].i32[0];
    v12 = 16 * a2[15].i32[0];
    v13 = 16 * a2[3].i32[0];
    v14 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v20.i64[0] = 0x3F0000003F000000;
    v20.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v21 = vaddq_f32(v7, vmulq_f32(v14, (float32x4_t)xmmword_1B30512C0));
      if (v6 >= 4)
        break;
      LODWORD(v68) = 0;
      v23 = 0uLL;
      __asm { FMOV            V17.4S, #1.0 }
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v14 = vaddq_f32(v14, _Q17);
      *(_QWORD *)&v10 += v11;
      *(_QWORD *)&v9 += v12;
      *(_QWORD *)&v8 += v13;
      if (v4 == v3)
        return 0;
    }
    v22 = 0;
    v23 = 0uLL;
    v24 = 32;
    do
    {
      v25 = vaddq_f32(v21, vmulq_f32(v23, (float32x4_t)xmmword_1B3051880));
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = vaddq_f32(v26, (float32x4_t)xmmword_1B3051880);
      v28 = vaddq_f32(v27, (float32x4_t)xmmword_1B3051880);
      v29 = a2[12];
      v30 = a2[13].i32[0];
      v31 = vaddq_f32(vsubq_f32(v25, v5), v20);
      v32 = vcvtq_s32_f32(v31);
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v33 = v31.i32[1];
      v34 = v31.i32[0];
      v35 = vaddq_f32(vsubq_f32(v26, v5), v20);
      v36 = vcvtq_s32_f32(v35);
      v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
      v37 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v34 + v33 * v30));
      v38 = v35.i32[1];
      v39 = v35.i32[0];
      v40 = vaddq_f32(vsubq_f32(v27, v5), v20);
      v41 = vcvtq_s32_f32(v40);
      v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
      v42 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v39 + v38 * v30));
      v43 = v40.i32[1];
      v44 = v40.i32[0];
      v45 = vaddq_f32(vsubq_f32(v28, v5), v20);
      v46 = vcvtq_s32_f32(v45);
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      v47 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v44 + v43 * v30));
      v48 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v45.i32[0] + v45.i32[1] * v30));
      v49 = *((_QWORD *)this + 51);
      v50 = *(int8x16_t *)(v49 + 32);
      v51 = *(float32x4_t *)(v49 + 48);
      v52 = *(float32x4_t *)(v49 + 16);
      v53 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 - 32), vextq_s8(v37, v37, 0xCuLL))));
      v54 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 - 16), vextq_s8(v42, v42, 0xCuLL))));
      v55 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24), vextq_s8(v47, v47, 0xCuLL))));
      v56 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 + 16), vextq_s8(v48, v48, 0xCuLL))));
      v57 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v53.f32, 1));
      v58 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v54.f32, 1));
      v59 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 - 32);
      v60 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 - 16);
      v59.i64[1] = v53.i64[1];
      v61 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v55.f32, 1));
      v63 = *(int8x16_t *)(*(_QWORD *)&v9 + v24);
      v62 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 + 16);
      v60.i64[1] = v54.i64[1];
      v63.i64[1] = v55.i64[1];
      v64 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v56.f32, 1));
      v62.i64[1] = v56.i64[1];
      v65 = *(float32x4_t *)(v49 + 64);
      v66 = *(int8x16_t *)(v49 + 80);
      v23 = vaddq_f32(v23, _Q5);
      v67 = (int8x16_t *)(*(_QWORD *)&v8 + v24);
      v67[-2] = vbslq_s8(v66, vextq_s8(v59, v59, 4uLL), (int8x16_t)vaddq_f32(v57, vmulq_laneq_f32(v65, v53, 2)));
      v67[-1] = vbslq_s8(v66, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v58, vmulq_laneq_f32(v65, v54, 2)));
      *v67 = vbslq_s8(v66, vextq_s8(v63, v63, 4uLL), (int8x16_t)vaddq_f32(v61, vmulq_laneq_f32(v65, v55, 2)));
      v67[1] = vbslq_s8(v66, vextq_s8(v62, v62, 4uLL), (int8x16_t)vaddq_f32(v64, vmulq_laneq_f32(v65, v56, 2)));
      v22 -= 4;
      v24 += 64;
    }
    while (v6 + v22 > 3);
    LODWORD(v68) = -v22;
    __asm { FMOV            V17.4S, #1.0 }
    if ((int)v68 >= v6)
      goto LABEL_3;
LABEL_10:
    v68 = v68;
    do
    {
      v70 = vaddq_f32(vsubq_f32(vaddq_f32(v21, vmulq_f32(v23, (float32x4_t)xmmword_1B3051880)), v5), v20);
      v71 = vcvtq_s32_f32(v70);
      v70.i64[0] = vaddq_s32(v71, vcgtq_f32(vcvtq_f32_s32(v71), v70)).u64[0];
      v72 = *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v70.i32[0] + v70.i32[1] * a2[13].i32[0]));
      v73 = *((_QWORD *)this + 51);
      v74 = vaddq_f32(*(float32x4_t *)(v73 + 16), vmulq_f32(*(float32x4_t *)v73, (float32x4_t)vbslq_s8(*(int8x16_t *)(v73 + 32), *(int8x16_t *)(*(_QWORD *)&v10 + 16 * v68), vextq_s8(v72, v72, 0xCuLL))));
      v75 = *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v68);
      v75.i64[1] = v74.i64[1];
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v68) = vbslq_s8(*(int8x16_t *)(v73 + 80), vextq_s8(v75, v75, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v73 + 64), v74, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v74.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v73 + 48), *(float32x2_t *)v74.f32, 1))));
      v23 = vaddq_f32(v23, _Q17);
      ++v68;
    }
    while (v68 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420TriPlanar_601ToRGB::GetDOD(HgcYUV420TriPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3 || a3 == 2)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420TriPlanar_601ToRGB::GetROI(HgcYUV420TriPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420TriPlanar_601ToRGB::HgcYUV420TriPlanar_601ToRGB(HgcYUV420TriPlanar_601ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6538448;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AB0;
  v3[4] = xmmword_1B3552AC0;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420TriPlanar_601ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9659C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420TriPlanar_601ToRGB::~HgcYUV420TriPlanar_601ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538448;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538448;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6538448;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420TriPlanar_601ToRGB::SetParameter(HgcYUV420TriPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420TriPlanar_601ToRGB::GetParameter(HgcYUV420TriPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420TriPlanar_709ToRGB::GetProgram(HgcYUV420TriPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cdf2c357:0e58722b:1e4f6b69:f6729461\n"
             "//SIG=00400000:00000005:00000005:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=05c81fc8:e3feb89a:8a806bcd:71aa8c88\n"
             "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=d2915400:9b8d3537:638e9298:f328421c\n"
           "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV420TriPlanar_709ToRGB::InitProgramDescriptor(HgcYUV420TriPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420TriPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut HgcYUV420TriPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B96C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B96C98(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B96C90);
}

char *HgcYUV420TriPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV420TriPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420TriPlanar_709ToRGB::BindTexture(HgcYUV420TriPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  HGHandler *v5;
  int v6;
  int v7;

  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV420TriPlanar_709ToRGB::Bind(HgcYUV420TriPlanar_709ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV420TriPlanar_709ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420TriPlanar_709ToRGB::RenderTile(HgcYUV420TriPlanar_709ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v20;
  float32x4_t v21;
  int v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x2_t v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  float32x4_t v35;
  int32x4_t v36;
  int8x16_t v37;
  __int32 v38;
  __int32 v39;
  float32x4_t v40;
  int32x4_t v41;
  int8x16_t v42;
  __int32 v43;
  __int32 v44;
  float32x4_t v45;
  int32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  uint64_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t *v67;
  uint64_t v68;
  float32x4_t v70;
  int32x4_t v71;
  int8x16_t v72;
  uint64_t v73;
  float32x4_t v74;
  int8x16_t v75;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B30532D0);
    v8 = a2[2];
    v9 = a2[14];
    v10 = a2[10];
    v11 = 16 * a2[11].i32[0];
    v12 = 16 * a2[15].i32[0];
    v13 = 16 * a2[3].i32[0];
    v14 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v20.i64[0] = 0x3F0000003F000000;
    v20.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v21 = vaddq_f32(v7, vmulq_f32(v14, (float32x4_t)xmmword_1B30512C0));
      if (v6 >= 4)
        break;
      LODWORD(v68) = 0;
      v23 = 0uLL;
      __asm { FMOV            V17.4S, #1.0 }
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v14 = vaddq_f32(v14, _Q17);
      *(_QWORD *)&v10 += v11;
      *(_QWORD *)&v9 += v12;
      *(_QWORD *)&v8 += v13;
      if (v4 == v3)
        return 0;
    }
    v22 = 0;
    v23 = 0uLL;
    v24 = 32;
    do
    {
      v25 = vaddq_f32(v21, vmulq_f32(v23, (float32x4_t)xmmword_1B3051880));
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = vaddq_f32(v26, (float32x4_t)xmmword_1B3051880);
      v28 = vaddq_f32(v27, (float32x4_t)xmmword_1B3051880);
      v29 = a2[12];
      v30 = a2[13].i32[0];
      v31 = vaddq_f32(vsubq_f32(v25, v5), v20);
      v32 = vcvtq_s32_f32(v31);
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v33 = v31.i32[1];
      v34 = v31.i32[0];
      v35 = vaddq_f32(vsubq_f32(v26, v5), v20);
      v36 = vcvtq_s32_f32(v35);
      v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
      v37 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v34 + v33 * v30));
      v38 = v35.i32[1];
      v39 = v35.i32[0];
      v40 = vaddq_f32(vsubq_f32(v27, v5), v20);
      v41 = vcvtq_s32_f32(v40);
      v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
      v42 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v39 + v38 * v30));
      v43 = v40.i32[1];
      v44 = v40.i32[0];
      v45 = vaddq_f32(vsubq_f32(v28, v5), v20);
      v46 = vcvtq_s32_f32(v45);
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      v47 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v44 + v43 * v30));
      v48 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v45.i32[0] + v45.i32[1] * v30));
      v49 = *((_QWORD *)this + 51);
      v50 = *(int8x16_t *)(v49 + 32);
      v51 = *(float32x4_t *)(v49 + 48);
      v52 = *(float32x4_t *)(v49 + 16);
      v53 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 - 32), vextq_s8(v37, v37, 0xCuLL))));
      v54 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 - 16), vextq_s8(v42, v42, 0xCuLL))));
      v55 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24), vextq_s8(v47, v47, 0xCuLL))));
      v56 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 + 16), vextq_s8(v48, v48, 0xCuLL))));
      v57 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v53.f32, 1));
      v58 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v54.f32, 1));
      v59 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 - 32);
      v60 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 - 16);
      v59.i64[1] = v53.i64[1];
      v61 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v55.f32, 1));
      v63 = *(int8x16_t *)(*(_QWORD *)&v9 + v24);
      v62 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 + 16);
      v60.i64[1] = v54.i64[1];
      v63.i64[1] = v55.i64[1];
      v64 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v56.f32, 1));
      v62.i64[1] = v56.i64[1];
      v65 = *(float32x4_t *)(v49 + 64);
      v66 = *(int8x16_t *)(v49 + 80);
      v23 = vaddq_f32(v23, _Q5);
      v67 = (int8x16_t *)(*(_QWORD *)&v8 + v24);
      v67[-2] = vbslq_s8(v66, vextq_s8(v59, v59, 4uLL), (int8x16_t)vaddq_f32(v57, vmulq_laneq_f32(v65, v53, 2)));
      v67[-1] = vbslq_s8(v66, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v58, vmulq_laneq_f32(v65, v54, 2)));
      *v67 = vbslq_s8(v66, vextq_s8(v63, v63, 4uLL), (int8x16_t)vaddq_f32(v61, vmulq_laneq_f32(v65, v55, 2)));
      v67[1] = vbslq_s8(v66, vextq_s8(v62, v62, 4uLL), (int8x16_t)vaddq_f32(v64, vmulq_laneq_f32(v65, v56, 2)));
      v22 -= 4;
      v24 += 64;
    }
    while (v6 + v22 > 3);
    LODWORD(v68) = -v22;
    __asm { FMOV            V17.4S, #1.0 }
    if ((int)v68 >= v6)
      goto LABEL_3;
LABEL_10:
    v68 = v68;
    do
    {
      v70 = vaddq_f32(vsubq_f32(vaddq_f32(v21, vmulq_f32(v23, (float32x4_t)xmmword_1B3051880)), v5), v20);
      v71 = vcvtq_s32_f32(v70);
      v70.i64[0] = vaddq_s32(v71, vcgtq_f32(vcvtq_f32_s32(v71), v70)).u64[0];
      v72 = *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v70.i32[0] + v70.i32[1] * a2[13].i32[0]));
      v73 = *((_QWORD *)this + 51);
      v74 = vaddq_f32(*(float32x4_t *)(v73 + 16), vmulq_f32(*(float32x4_t *)v73, (float32x4_t)vbslq_s8(*(int8x16_t *)(v73 + 32), *(int8x16_t *)(*(_QWORD *)&v10 + 16 * v68), vextq_s8(v72, v72, 0xCuLL))));
      v75 = *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v68);
      v75.i64[1] = v74.i64[1];
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v68) = vbslq_s8(*(int8x16_t *)(v73 + 80), vextq_s8(v75, v75, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v73 + 64), v74, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v74.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v73 + 48), *(float32x2_t *)v74.f32, 1))));
      v23 = vaddq_f32(v23, _Q17);
      ++v68;
    }
    while (v68 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420TriPlanar_709ToRGB::GetDOD(HgcYUV420TriPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3 || a3 == 2)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420TriPlanar_709ToRGB::GetROI(HgcYUV420TriPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420TriPlanar_709ToRGB::HgcYUV420TriPlanar_709ToRGB(HgcYUV420TriPlanar_709ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65386B0;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AF0;
  v3[4] = xmmword_1B3552B00;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420TriPlanar_709ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B97480(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420TriPlanar_709ToRGB::~HgcYUV420TriPlanar_709ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65386B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65386B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65386B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420TriPlanar_709ToRGB::SetParameter(HgcYUV420TriPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420TriPlanar_709ToRGB::GetParameter(HgcYUV420TriPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420TriPlanar_2020ToRGB::GetProgram(HgcYUV420TriPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f79a664b:38284d73:72f9ca6b:398dd0ca\n"
             "//SIG=00400000:00000005:00000005:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7637b7ca:94e18948:9249a20f:2be63cfc\n"
             "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=a3e884d8:41b7c32f:d6ccb16b:fb255cb1\n"
           "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV420TriPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV420TriPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420TriPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000311\n[[ visible ]] FragmentOut HgcYUV420TriPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B97B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B97B7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B97B74);
}

char *HgcYUV420TriPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcYUV420TriPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::BindTexture(HgcYUV420TriPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  HGHandler *v5;
  int v6;
  int v7;

  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::Bind(HgcYUV420TriPlanar_2020ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV420TriPlanar_2020ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::RenderTile(HgcYUV420TriPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v20;
  float32x4_t v21;
  int v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x2_t v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  float32x4_t v35;
  int32x4_t v36;
  int8x16_t v37;
  __int32 v38;
  __int32 v39;
  float32x4_t v40;
  int32x4_t v41;
  int8x16_t v42;
  __int32 v43;
  __int32 v44;
  float32x4_t v45;
  int32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  uint64_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t *v67;
  uint64_t v68;
  float32x4_t v70;
  int32x4_t v71;
  int8x16_t v72;
  uint64_t v73;
  float32x4_t v74;
  int8x16_t v75;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B30532D0);
    v8 = a2[2];
    v9 = a2[14];
    v10 = a2[10];
    v11 = 16 * a2[11].i32[0];
    v12 = 16 * a2[15].i32[0];
    v13 = 16 * a2[3].i32[0];
    v14 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v20.i64[0] = 0x3F0000003F000000;
    v20.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v21 = vaddq_f32(v7, vmulq_f32(v14, (float32x4_t)xmmword_1B30512C0));
      if (v6 >= 4)
        break;
      LODWORD(v68) = 0;
      v23 = 0uLL;
      __asm { FMOV            V17.4S, #1.0 }
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v14 = vaddq_f32(v14, _Q17);
      *(_QWORD *)&v10 += v11;
      *(_QWORD *)&v9 += v12;
      *(_QWORD *)&v8 += v13;
      if (v4 == v3)
        return 0;
    }
    v22 = 0;
    v23 = 0uLL;
    v24 = 32;
    do
    {
      v25 = vaddq_f32(v21, vmulq_f32(v23, (float32x4_t)xmmword_1B3051880));
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = vaddq_f32(v26, (float32x4_t)xmmword_1B3051880);
      v28 = vaddq_f32(v27, (float32x4_t)xmmword_1B3051880);
      v29 = a2[12];
      v30 = a2[13].i32[0];
      v31 = vaddq_f32(vsubq_f32(v25, v5), v20);
      v32 = vcvtq_s32_f32(v31);
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v33 = v31.i32[1];
      v34 = v31.i32[0];
      v35 = vaddq_f32(vsubq_f32(v26, v5), v20);
      v36 = vcvtq_s32_f32(v35);
      v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
      v37 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v34 + v33 * v30));
      v38 = v35.i32[1];
      v39 = v35.i32[0];
      v40 = vaddq_f32(vsubq_f32(v27, v5), v20);
      v41 = vcvtq_s32_f32(v40);
      v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
      v42 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v39 + v38 * v30));
      v43 = v40.i32[1];
      v44 = v40.i32[0];
      v45 = vaddq_f32(vsubq_f32(v28, v5), v20);
      v46 = vcvtq_s32_f32(v45);
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      v47 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v44 + v43 * v30));
      v48 = *(int8x16_t *)(*(_QWORD *)&v29 + 16 * (v45.i32[0] + v45.i32[1] * v30));
      v49 = *((_QWORD *)this + 51);
      v50 = *(int8x16_t *)(v49 + 32);
      v51 = *(float32x4_t *)(v49 + 48);
      v52 = *(float32x4_t *)(v49 + 16);
      v53 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 - 32), vextq_s8(v37, v37, 0xCuLL))));
      v54 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 - 16), vextq_s8(v42, v42, 0xCuLL))));
      v55 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24), vextq_s8(v47, v47, 0xCuLL))));
      v56 = vaddq_f32(v52, vmulq_f32(*(float32x4_t *)v49, (float32x4_t)vbslq_s8(v50, *(int8x16_t *)(*(_QWORD *)&v10 + v24 + 16), vextq_s8(v48, v48, 0xCuLL))));
      v57 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v53.f32, 1));
      v58 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v54.f32, 1));
      v59 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 - 32);
      v60 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 - 16);
      v59.i64[1] = v53.i64[1];
      v61 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v55.f32, 1));
      v63 = *(int8x16_t *)(*(_QWORD *)&v9 + v24);
      v62 = *(int8x16_t *)(*(_QWORD *)&v9 + v24 + 16);
      v60.i64[1] = v54.i64[1];
      v63.i64[1] = v55.i64[1];
      v64 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v51, *(float32x2_t *)v56.f32, 1));
      v62.i64[1] = v56.i64[1];
      v65 = *(float32x4_t *)(v49 + 64);
      v66 = *(int8x16_t *)(v49 + 80);
      v23 = vaddq_f32(v23, _Q5);
      v67 = (int8x16_t *)(*(_QWORD *)&v8 + v24);
      v67[-2] = vbslq_s8(v66, vextq_s8(v59, v59, 4uLL), (int8x16_t)vaddq_f32(v57, vmulq_laneq_f32(v65, v53, 2)));
      v67[-1] = vbslq_s8(v66, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v58, vmulq_laneq_f32(v65, v54, 2)));
      *v67 = vbslq_s8(v66, vextq_s8(v63, v63, 4uLL), (int8x16_t)vaddq_f32(v61, vmulq_laneq_f32(v65, v55, 2)));
      v67[1] = vbslq_s8(v66, vextq_s8(v62, v62, 4uLL), (int8x16_t)vaddq_f32(v64, vmulq_laneq_f32(v65, v56, 2)));
      v22 -= 4;
      v24 += 64;
    }
    while (v6 + v22 > 3);
    LODWORD(v68) = -v22;
    __asm { FMOV            V17.4S, #1.0 }
    if ((int)v68 >= v6)
      goto LABEL_3;
LABEL_10:
    v68 = v68;
    do
    {
      v70 = vaddq_f32(vsubq_f32(vaddq_f32(v21, vmulq_f32(v23, (float32x4_t)xmmword_1B3051880)), v5), v20);
      v71 = vcvtq_s32_f32(v70);
      v70.i64[0] = vaddq_s32(v71, vcgtq_f32(vcvtq_f32_s32(v71), v70)).u64[0];
      v72 = *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v70.i32[0] + v70.i32[1] * a2[13].i32[0]));
      v73 = *((_QWORD *)this + 51);
      v74 = vaddq_f32(*(float32x4_t *)(v73 + 16), vmulq_f32(*(float32x4_t *)v73, (float32x4_t)vbslq_s8(*(int8x16_t *)(v73 + 32), *(int8x16_t *)(*(_QWORD *)&v10 + 16 * v68), vextq_s8(v72, v72, 0xCuLL))));
      v75 = *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v68);
      v75.i64[1] = v74.i64[1];
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v68) = vbslq_s8(*(int8x16_t *)(v73 + 80), vextq_s8(v75, v75, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v73 + 64), v74, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v74.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v73 + 48), *(float32x2_t *)v74.f32, 1))));
      v23 = vaddq_f32(v23, _Q17);
      ++v68;
    }
    while (v68 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::GetDOD(HgcYUV420TriPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3 || a3 == 2)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::GetROI(HgcYUV420TriPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420TriPlanar_2020ToRGB::HgcYUV420TriPlanar_2020ToRGB(HgcYUV420TriPlanar_2020ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6538918;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3058F00;
  v3[4] = xmmword_1B3058F10;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420TriPlanar_2020ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B98368(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420TriPlanar_2020ToRGB::~HgcYUV420TriPlanar_2020ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538918;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538918;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6538918;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::SetParameter(HgcYUV420TriPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420TriPlanar_2020ToRGB::GetParameter(HgcYUV420TriPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422TriPlanar_601ToRGB::GetProgram(HgcYUV422TriPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c0cd9a4:962f63d5:0783359b:49528c86\n"
             "//SIG=00400000:00000005:00000005:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=24010ee7:6e1cd76d:c31b9c85:b9fbda97\n"
             "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=6448df2f:b4b78b65:3a0dc9a8:4e1d16fb\n"
           "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV422TriPlanar_601ToRGB::InitProgramDescriptor(HgcYUV422TriPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422TriPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut HgcYUV422TriPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B98A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B98A64(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B98A5CLL);
}

char *HgcYUV422TriPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV422TriPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422TriPlanar_601ToRGB::BindTexture(HgcYUV422TriPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  HGHandler *v5;
  int v6;
  int v7;

  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV422TriPlanar_601ToRGB::Bind(HgcYUV422TriPlanar_601ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV422TriPlanar_601ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422TriPlanar_601ToRGB::RenderTile(HgcYUV422TriPlanar_601ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v19;
  int v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  __int32 v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  int8x16_t v35;
  __int32 v36;
  __int32 v37;
  float32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  __int32 v41;
  __int32 v42;
  float32x4_t v43;
  int32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint64_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  int8x16_t *v65;
  uint64_t v66;
  float32x4_t v67;
  int32x4_t v68;
  int8x16_t v69;
  uint64_t v70;
  float32x4_t v71;
  int8x16_t v72;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    v8 = a2[2];
    v9 = a2[14];
    v10 = a2[10];
    v11 = 16 * a2[11].i32[0];
    v12 = 16 * a2[15].i32[0];
    v13 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v19.i64[0] = 0x3F0000003F000000;
    v19.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v66) = 0;
      v21 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      *(_QWORD *)&v10 += v11;
      *(_QWORD *)&v9 += v12;
      *(_QWORD *)&v8 += v13;
      if (v4 == v3)
        return 0;
    }
    v20 = 0;
    v21 = 0uLL;
    v22 = 32;
    do
    {
      v23 = vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[12];
      v28 = a2[13].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v19);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = v29.i32[1];
      v32 = v29.i32[0];
      v33 = vaddq_f32(vsubq_f32(v24, v5), v19);
      v34 = vcvtq_s32_f32(v33);
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v35 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v32 + v31 * v28));
      v36 = v33.i32[1];
      v37 = v33.i32[0];
      v38 = vaddq_f32(vsubq_f32(v25, v5), v19);
      v39 = vcvtq_s32_f32(v38);
      v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
      v40 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v37 + v36 * v28));
      v41 = v38.i32[1];
      v42 = v38.i32[0];
      v43 = vaddq_f32(vsubq_f32(v26, v5), v19);
      v44 = vcvtq_s32_f32(v43);
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      v45 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v42 + v41 * v28));
      v46 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v43.i32[0] + v43.i32[1] * v28));
      v47 = *((_QWORD *)this + 51);
      v48 = *(int8x16_t *)(v47 + 32);
      v49 = *(float32x4_t *)(v47 + 48);
      v50 = *(float32x4_t *)(v47 + 16);
      v51 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 - 32), vextq_s8(v35, v35, 0xCuLL))));
      v52 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 - 16), vextq_s8(v40, v40, 0xCuLL))));
      v53 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22), vextq_s8(v45, v45, 0xCuLL))));
      v54 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 + 16), vextq_s8(v46, v46, 0xCuLL))));
      v55 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v51.f32, 1));
      v56 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v52.f32, 1));
      v57 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 32);
      v58 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 16);
      v57.i64[1] = v51.i64[1];
      v59 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v53.f32, 1));
      v61 = *(int8x16_t *)(*(_QWORD *)&v9 + v22);
      v60 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 + 16);
      v58.i64[1] = v52.i64[1];
      v61.i64[1] = v53.i64[1];
      v62 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v54.f32, 1));
      v60.i64[1] = v54.i64[1];
      v63 = *(float32x4_t *)(v47 + 64);
      v64 = *(int8x16_t *)(v47 + 80);
      v21 = vaddq_f32(v21, _Q4);
      v65 = (int8x16_t *)(*(_QWORD *)&v8 + v22);
      v65[-2] = vbslq_s8(v64, vextq_s8(v57, v57, 4uLL), (int8x16_t)vaddq_f32(v55, vmulq_laneq_f32(v63, v51, 2)));
      v65[-1] = vbslq_s8(v64, vextq_s8(v58, v58, 4uLL), (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(v63, v52, 2)));
      *v65 = vbslq_s8(v64, vextq_s8(v61, v61, 4uLL), (int8x16_t)vaddq_f32(v59, vmulq_laneq_f32(v63, v53, 2)));
      v65[1] = vbslq_s8(v64, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v63, v54, 2)));
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    if ((int)v66 >= v6)
      goto LABEL_3;
LABEL_10:
    v66 = v66;
    do
    {
      v67 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v19);
      v68 = vcvtq_s32_f32(v67);
      v67.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v67)).u64[0];
      v69 = *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v67.i32[0] + v67.i32[1] * a2[13].i32[0]));
      v70 = *((_QWORD *)this + 51);
      v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(_QWORD *)&v10 + 16 * v66), vextq_s8(v69, v69, 0xCuLL))));
      v72 = *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v66);
      v72.i64[1] = v71.i64[1];
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v66) = vbslq_s8(*(int8x16_t *)(v70 + 80), vextq_s8(v72, v72, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1))));
      __asm { FMOV            V7.4S, #1.0 }
      v21 = vaddq_f32(v21, _Q7);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_601ToRGB::GetDOD(HgcYUV422TriPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3 || a3 == 2)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 0);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_601ToRGB::GetROI(HgcYUV422TriPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422TriPlanar_601ToRGB::HgcYUV422TriPlanar_601ToRGB(HgcYUV422TriPlanar_601ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6538B80;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AB0;
  v3[4] = xmmword_1B3552AC0;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422TriPlanar_601ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9923C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422TriPlanar_601ToRGB::~HgcYUV422TriPlanar_601ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538B80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538B80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6538B80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422TriPlanar_601ToRGB::SetParameter(HgcYUV422TriPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422TriPlanar_601ToRGB::GetParameter(HgcYUV422TriPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422TriPlanar_709ToRGB::GetProgram(HgcYUV422TriPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cdf2c357:0e58722b:1e4f6b69:f6729461\n"
             "//SIG=00400000:00000005:00000005:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=05c81fc8:e3feb89a:8a806bcd:71aa8c88\n"
             "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=d2915400:9b8d3537:638e9298:f328421c\n"
           "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV422TriPlanar_709ToRGB::InitProgramDescriptor(HgcYUV422TriPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422TriPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000310\n[[ visible ]] FragmentOut HgcYUV422TriPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B998F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B99938(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B99930);
}

char *HgcYUV422TriPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV422TriPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422TriPlanar_709ToRGB::BindTexture(HgcYUV422TriPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  HGHandler *v5;
  int v6;
  int v7;

  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV422TriPlanar_709ToRGB::Bind(HgcYUV422TriPlanar_709ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV422TriPlanar_709ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422TriPlanar_709ToRGB::RenderTile(HgcYUV422TriPlanar_709ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v19;
  int v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  __int32 v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  int8x16_t v35;
  __int32 v36;
  __int32 v37;
  float32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  __int32 v41;
  __int32 v42;
  float32x4_t v43;
  int32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint64_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  int8x16_t *v65;
  uint64_t v66;
  float32x4_t v67;
  int32x4_t v68;
  int8x16_t v69;
  uint64_t v70;
  float32x4_t v71;
  int8x16_t v72;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    v8 = a2[2];
    v9 = a2[14];
    v10 = a2[10];
    v11 = 16 * a2[11].i32[0];
    v12 = 16 * a2[15].i32[0];
    v13 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v19.i64[0] = 0x3F0000003F000000;
    v19.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v66) = 0;
      v21 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      *(_QWORD *)&v10 += v11;
      *(_QWORD *)&v9 += v12;
      *(_QWORD *)&v8 += v13;
      if (v4 == v3)
        return 0;
    }
    v20 = 0;
    v21 = 0uLL;
    v22 = 32;
    do
    {
      v23 = vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[12];
      v28 = a2[13].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v19);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = v29.i32[1];
      v32 = v29.i32[0];
      v33 = vaddq_f32(vsubq_f32(v24, v5), v19);
      v34 = vcvtq_s32_f32(v33);
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v35 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v32 + v31 * v28));
      v36 = v33.i32[1];
      v37 = v33.i32[0];
      v38 = vaddq_f32(vsubq_f32(v25, v5), v19);
      v39 = vcvtq_s32_f32(v38);
      v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
      v40 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v37 + v36 * v28));
      v41 = v38.i32[1];
      v42 = v38.i32[0];
      v43 = vaddq_f32(vsubq_f32(v26, v5), v19);
      v44 = vcvtq_s32_f32(v43);
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      v45 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v42 + v41 * v28));
      v46 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v43.i32[0] + v43.i32[1] * v28));
      v47 = *((_QWORD *)this + 51);
      v48 = *(int8x16_t *)(v47 + 32);
      v49 = *(float32x4_t *)(v47 + 48);
      v50 = *(float32x4_t *)(v47 + 16);
      v51 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 - 32), vextq_s8(v35, v35, 0xCuLL))));
      v52 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 - 16), vextq_s8(v40, v40, 0xCuLL))));
      v53 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22), vextq_s8(v45, v45, 0xCuLL))));
      v54 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 + 16), vextq_s8(v46, v46, 0xCuLL))));
      v55 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v51.f32, 1));
      v56 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v52.f32, 1));
      v57 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 32);
      v58 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 16);
      v57.i64[1] = v51.i64[1];
      v59 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v53.f32, 1));
      v61 = *(int8x16_t *)(*(_QWORD *)&v9 + v22);
      v60 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 + 16);
      v58.i64[1] = v52.i64[1];
      v61.i64[1] = v53.i64[1];
      v62 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v54.f32, 1));
      v60.i64[1] = v54.i64[1];
      v63 = *(float32x4_t *)(v47 + 64);
      v64 = *(int8x16_t *)(v47 + 80);
      v21 = vaddq_f32(v21, _Q4);
      v65 = (int8x16_t *)(*(_QWORD *)&v8 + v22);
      v65[-2] = vbslq_s8(v64, vextq_s8(v57, v57, 4uLL), (int8x16_t)vaddq_f32(v55, vmulq_laneq_f32(v63, v51, 2)));
      v65[-1] = vbslq_s8(v64, vextq_s8(v58, v58, 4uLL), (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(v63, v52, 2)));
      *v65 = vbslq_s8(v64, vextq_s8(v61, v61, 4uLL), (int8x16_t)vaddq_f32(v59, vmulq_laneq_f32(v63, v53, 2)));
      v65[1] = vbslq_s8(v64, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v63, v54, 2)));
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    if ((int)v66 >= v6)
      goto LABEL_3;
LABEL_10:
    v66 = v66;
    do
    {
      v67 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v19);
      v68 = vcvtq_s32_f32(v67);
      v67.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v67)).u64[0];
      v69 = *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v67.i32[0] + v67.i32[1] * a2[13].i32[0]));
      v70 = *((_QWORD *)this + 51);
      v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(_QWORD *)&v10 + 16 * v66), vextq_s8(v69, v69, 0xCuLL))));
      v72 = *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v66);
      v72.i64[1] = v71.i64[1];
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v66) = vbslq_s8(*(int8x16_t *)(v70 + 80), vextq_s8(v72, v72, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1))));
      __asm { FMOV            V7.4S, #1.0 }
      v21 = vaddq_f32(v21, _Q7);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_709ToRGB::GetDOD(HgcYUV422TriPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3 || a3 == 2)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 0);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_709ToRGB::GetROI(HgcYUV422TriPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422TriPlanar_709ToRGB::HgcYUV422TriPlanar_709ToRGB(HgcYUV422TriPlanar_709ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6538DE8;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AF0;
  v3[4] = xmmword_1B3552B00;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422TriPlanar_709ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9A110(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422TriPlanar_709ToRGB::~HgcYUV422TriPlanar_709ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538DE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6538DE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6538DE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422TriPlanar_709ToRGB::SetParameter(HgcYUV422TriPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422TriPlanar_709ToRGB::GetParameter(HgcYUV422TriPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422TriPlanar_2020ToRGB::GetProgram(HgcYUV422TriPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f79a664b:38284d73:72f9ca6b:398dd0ca\n"
             "//SIG=00400000:00000005:00000005:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7637b7ca:94e18948:9249a20f:2be63cfc\n"
             "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=a3e884d8:41b7c32f:d6ccb16b:fb255cb1\n"
           "//SIG=00000000:00000005:00000005:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV422TriPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV422TriPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422TriPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000311\n[[ visible ]] FragmentOut HgcYUV422TriPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9A7CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9A80C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9A804);
}

char *HgcYUV422TriPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcYUV422TriPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::BindTexture(HgcYUV422TriPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  HGHandler *v5;
  int v6;
  int v7;

  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::Bind(HgcYUV422TriPlanar_2020ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV422TriPlanar_2020ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::RenderTile(HgcYUV422TriPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v19;
  int v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  __int32 v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  int8x16_t v35;
  __int32 v36;
  __int32 v37;
  float32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  __int32 v41;
  __int32 v42;
  float32x4_t v43;
  int32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint64_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  int8x16_t *v65;
  uint64_t v66;
  float32x4_t v67;
  int32x4_t v68;
  int8x16_t v69;
  uint64_t v70;
  float32x4_t v71;
  int8x16_t v72;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    v8 = a2[2];
    v9 = a2[14];
    v10 = a2[10];
    v11 = 16 * a2[11].i32[0];
    v12 = 16 * a2[15].i32[0];
    v13 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v19.i64[0] = 0x3F0000003F000000;
    v19.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v66) = 0;
      v21 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      ++v4;
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      *(_QWORD *)&v10 += v11;
      *(_QWORD *)&v9 += v12;
      *(_QWORD *)&v8 += v13;
      if (v4 == v3)
        return 0;
    }
    v20 = 0;
    v21 = 0uLL;
    v22 = 32;
    do
    {
      v23 = vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[12];
      v28 = a2[13].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v19);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = v29.i32[1];
      v32 = v29.i32[0];
      v33 = vaddq_f32(vsubq_f32(v24, v5), v19);
      v34 = vcvtq_s32_f32(v33);
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v35 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v32 + v31 * v28));
      v36 = v33.i32[1];
      v37 = v33.i32[0];
      v38 = vaddq_f32(vsubq_f32(v25, v5), v19);
      v39 = vcvtq_s32_f32(v38);
      v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
      v40 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v37 + v36 * v28));
      v41 = v38.i32[1];
      v42 = v38.i32[0];
      v43 = vaddq_f32(vsubq_f32(v26, v5), v19);
      v44 = vcvtq_s32_f32(v43);
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      v45 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v42 + v41 * v28));
      v46 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v43.i32[0] + v43.i32[1] * v28));
      v47 = *((_QWORD *)this + 51);
      v48 = *(int8x16_t *)(v47 + 32);
      v49 = *(float32x4_t *)(v47 + 48);
      v50 = *(float32x4_t *)(v47 + 16);
      v51 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 - 32), vextq_s8(v35, v35, 0xCuLL))));
      v52 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 - 16), vextq_s8(v40, v40, 0xCuLL))));
      v53 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22), vextq_s8(v45, v45, 0xCuLL))));
      v54 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(_QWORD *)&v10 + v22 + 16), vextq_s8(v46, v46, 0xCuLL))));
      v55 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v51.f32, 1));
      v56 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v52.f32, 1));
      v57 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 32);
      v58 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 16);
      v57.i64[1] = v51.i64[1];
      v59 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v53.f32, 1));
      v61 = *(int8x16_t *)(*(_QWORD *)&v9 + v22);
      v60 = *(int8x16_t *)(*(_QWORD *)&v9 + v22 + 16);
      v58.i64[1] = v52.i64[1];
      v61.i64[1] = v53.i64[1];
      v62 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v54.f32, 1));
      v60.i64[1] = v54.i64[1];
      v63 = *(float32x4_t *)(v47 + 64);
      v64 = *(int8x16_t *)(v47 + 80);
      v21 = vaddq_f32(v21, _Q4);
      v65 = (int8x16_t *)(*(_QWORD *)&v8 + v22);
      v65[-2] = vbslq_s8(v64, vextq_s8(v57, v57, 4uLL), (int8x16_t)vaddq_f32(v55, vmulq_laneq_f32(v63, v51, 2)));
      v65[-1] = vbslq_s8(v64, vextq_s8(v58, v58, 4uLL), (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(v63, v52, 2)));
      *v65 = vbslq_s8(v64, vextq_s8(v61, v61, 4uLL), (int8x16_t)vaddq_f32(v59, vmulq_laneq_f32(v63, v53, 2)));
      v65[1] = vbslq_s8(v64, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v63, v54, 2)));
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    if ((int)v66 >= v6)
      goto LABEL_3;
LABEL_10:
    v66 = v66;
    do
    {
      v67 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v19);
      v68 = vcvtq_s32_f32(v67);
      v67.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v67)).u64[0];
      v69 = *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v67.i32[0] + v67.i32[1] * a2[13].i32[0]));
      v70 = *((_QWORD *)this + 51);
      v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(_QWORD *)&v10 + 16 * v66), vextq_s8(v69, v69, 0xCuLL))));
      v72 = *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v66);
      v72.i64[1] = v71.i64[1];
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v66) = vbslq_s8(*(int8x16_t *)(v70 + 80), vextq_s8(v72, v72, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1))));
      __asm { FMOV            V7.4S, #1.0 }
      v21 = vaddq_f32(v21, _Q7);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::GetDOD(HgcYUV422TriPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3 || a3 == 2)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 0);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::GetROI(HgcYUV422TriPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422TriPlanar_2020ToRGB::HgcYUV422TriPlanar_2020ToRGB(HgcYUV422TriPlanar_2020ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6539050;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3058F00;
  v3[4] = xmmword_1B3058F10;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422TriPlanar_2020ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9AFE8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422TriPlanar_2020ToRGB::~HgcYUV422TriPlanar_2020ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539050;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539050;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6539050;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::SetParameter(HgcYUV422TriPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::GetParameter(HgcYUV422TriPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444TriPlanar_601ToRGB::GetProgram(HgcYUV444TriPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c0cd9a4:962f63d5:0783359b:49528c86\n"
             "//SIG=00400000:00000007:00000007:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=24010ee7:6e1cd76d:c31b9c85:b9fbda97\n"
             "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=6448df2f:b4b78b65:3a0dc9a8:4e1d16fb\n"
           "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV444TriPlanar_601ToRGB::InitProgramDescriptor(HgcYUV444TriPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444TriPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002a7\n[[ visible ]] FragmentOut HgcYUV444TriPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9B574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9B5AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9B5A4);
}

char *HgcYUV444TriPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV444TriPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::BindTexture(HgcYUV444TriPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 == 2)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
    }
    else
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::Bind(HgcYUV444TriPlanar_601ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV444TriPlanar_601ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::RenderTile(HgcYUV444TriPlanar_601ToRGB *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t *v34;
  uint64_t v35;
  uint64_t v36;
  float32x4_t v37;
  int8x16_t v38;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((int *)a2 + 6);
    v6 = *((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 14);
    v8 = *((_QWORD *)a2 + 10);
    v9 = 16 * *((int *)a2 + 22);
    v10 = 16 * *((int *)a2 + 26);
    v11 = *((_QWORD *)a2 + 12);
    v12 = 16 * *((int *)a2 + 30);
    v13 = 16 * v5;
    while (v4 < 4)
    {
      LODWORD(v35) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      ++v3;
      v8 += v9;
      v11 += v10;
      v7 += v12;
      v6 += v13;
      if (v3 == v2)
        return 0;
    }
    v14 = 0;
    v15 = 0;
    do
    {
      v16 = *((_QWORD *)this + 51);
      v17 = *(int8x16_t *)(v16 + 32);
      v18 = *(float32x4_t *)(v16 + 48);
      v19 = *(float32x4_t *)(v16 + 16);
      v20 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14), vextq_s8(*(int8x16_t *)(v11 + v14), *(int8x16_t *)(v11 + v14), 0xCuLL))));
      v21 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 16), vextq_s8(*(int8x16_t *)(v11 + v14 + 16), *(int8x16_t *)(v11 + v14 + 16), 0xCuLL))));
      v22 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 32), vextq_s8(*(int8x16_t *)(v11 + v14 + 32), *(int8x16_t *)(v11 + v14 + 32), 0xCuLL))));
      v23 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 48), vextq_s8(*(int8x16_t *)(v11 + v14 + 48), *(int8x16_t *)(v11 + v14 + 48), 0xCuLL))));
      v24 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1));
      v25 = *(int8x16_t *)(v7 + v14);
      v26 = *(int8x16_t *)(v7 + v14 + 16);
      v25.i64[1] = v20.i64[1];
      v27 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v21.f32, 1));
      v29 = *(int8x16_t *)(v7 + v14 + 32);
      v28 = *(int8x16_t *)(v7 + v14 + 48);
      v26.i64[1] = v21.i64[1];
      v29.i64[1] = v22.i64[1];
      v30 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v22.f32, 1));
      v31 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v23.f32, 1));
      v28.i64[1] = v23.i64[1];
      v32 = *(float32x4_t *)(v16 + 64);
      v33 = *(int8x16_t *)(v16 + 80);
      v34 = (int8x16_t *)(v6 + v14);
      *v34 = vbslq_s8(v33, vextq_s8(v25, v25, 4uLL), (int8x16_t)vaddq_f32(v24, vmulq_laneq_f32(v32, v20, 2)));
      v34[1] = vbslq_s8(v33, vextq_s8(v26, v26, 4uLL), (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(v32, v21, 2)));
      v34[2] = vbslq_s8(v33, vextq_s8(v29, v29, 4uLL), (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(v32, v22, 2)));
      v34[3] = vbslq_s8(v33, vextq_s8(v28, v28, 4uLL), (int8x16_t)vaddq_f32(v31, vmulq_laneq_f32(v32, v23, 2)));
      v15 -= 4;
      v14 += 64;
    }
    while (v4 + v15 > 3);
    LODWORD(v35) = -v15;
    if ((int)v35 >= v4)
      goto LABEL_3;
LABEL_10:
    v35 = v35;
    do
    {
      v36 = *((_QWORD *)this + 51);
      v37 = vaddq_f32(*(float32x4_t *)(v36 + 16), vmulq_f32(*(float32x4_t *)v36, (float32x4_t)vbslq_s8(*(int8x16_t *)(v36 + 32), *(int8x16_t *)(v8 + 16 * v35), vextq_s8(*(int8x16_t *)(v11 + 16 * v35), *(int8x16_t *)(v11 + 16 * v35), 0xCuLL))));
      v38 = *(int8x16_t *)(v7 + 16 * v35);
      v38.i64[1] = v37.i64[1];
      *(int8x16_t *)(v6 + 16 * v35++) = vbslq_s8(*(int8x16_t *)(v36 + 80), vextq_s8(v38, v38, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v36 + 64), v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v36 + 48), *(float32x2_t *)v37.f32, 1))));
    }
    while (v35 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::GetDOD(HgcYUV444TriPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::GetROI(HgcYUV444TriPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444TriPlanar_601ToRGB::HgcYUV444TriPlanar_601ToRGB(HgcYUV444TriPlanar_601ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65392B8;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AB0;
  v3[4] = xmmword_1B3552AC0;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9BAB0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444TriPlanar_601ToRGB::~HgcYUV444TriPlanar_601ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65392B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65392B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65392B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444TriPlanar_601ToRGB::SetParameter(HgcYUV444TriPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::GetParameter(HgcYUV444TriPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444TriPlanar_709ToRGB::GetProgram(HgcYUV444TriPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cdf2c357:0e58722b:1e4f6b69:f6729461\n"
             "//SIG=00400000:00000007:00000007:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=05c81fc8:e3feb89a:8a806bcd:71aa8c88\n"
             "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=d2915400:9b8d3537:638e9298:f328421c\n"
           "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV444TriPlanar_709ToRGB::InitProgramDescriptor(HgcYUV444TriPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444TriPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002a7\n[[ visible ]] FragmentOut HgcYUV444TriPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9C03C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9C074(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9C06CLL);
}

char *HgcYUV444TriPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV444TriPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::BindTexture(HgcYUV444TriPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 == 2)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
    }
    else
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::Bind(HgcYUV444TriPlanar_709ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV444TriPlanar_709ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::RenderTile(HgcYUV444TriPlanar_709ToRGB *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t *v34;
  uint64_t v35;
  uint64_t v36;
  float32x4_t v37;
  int8x16_t v38;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((int *)a2 + 6);
    v6 = *((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 14);
    v8 = *((_QWORD *)a2 + 10);
    v9 = 16 * *((int *)a2 + 22);
    v10 = 16 * *((int *)a2 + 26);
    v11 = *((_QWORD *)a2 + 12);
    v12 = 16 * *((int *)a2 + 30);
    v13 = 16 * v5;
    while (v4 < 4)
    {
      LODWORD(v35) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      ++v3;
      v8 += v9;
      v11 += v10;
      v7 += v12;
      v6 += v13;
      if (v3 == v2)
        return 0;
    }
    v14 = 0;
    v15 = 0;
    do
    {
      v16 = *((_QWORD *)this + 51);
      v17 = *(int8x16_t *)(v16 + 32);
      v18 = *(float32x4_t *)(v16 + 48);
      v19 = *(float32x4_t *)(v16 + 16);
      v20 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14), vextq_s8(*(int8x16_t *)(v11 + v14), *(int8x16_t *)(v11 + v14), 0xCuLL))));
      v21 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 16), vextq_s8(*(int8x16_t *)(v11 + v14 + 16), *(int8x16_t *)(v11 + v14 + 16), 0xCuLL))));
      v22 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 32), vextq_s8(*(int8x16_t *)(v11 + v14 + 32), *(int8x16_t *)(v11 + v14 + 32), 0xCuLL))));
      v23 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 48), vextq_s8(*(int8x16_t *)(v11 + v14 + 48), *(int8x16_t *)(v11 + v14 + 48), 0xCuLL))));
      v24 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1));
      v25 = *(int8x16_t *)(v7 + v14);
      v26 = *(int8x16_t *)(v7 + v14 + 16);
      v25.i64[1] = v20.i64[1];
      v27 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v21.f32, 1));
      v29 = *(int8x16_t *)(v7 + v14 + 32);
      v28 = *(int8x16_t *)(v7 + v14 + 48);
      v26.i64[1] = v21.i64[1];
      v29.i64[1] = v22.i64[1];
      v30 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v22.f32, 1));
      v31 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v23.f32, 1));
      v28.i64[1] = v23.i64[1];
      v32 = *(float32x4_t *)(v16 + 64);
      v33 = *(int8x16_t *)(v16 + 80);
      v34 = (int8x16_t *)(v6 + v14);
      *v34 = vbslq_s8(v33, vextq_s8(v25, v25, 4uLL), (int8x16_t)vaddq_f32(v24, vmulq_laneq_f32(v32, v20, 2)));
      v34[1] = vbslq_s8(v33, vextq_s8(v26, v26, 4uLL), (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(v32, v21, 2)));
      v34[2] = vbslq_s8(v33, vextq_s8(v29, v29, 4uLL), (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(v32, v22, 2)));
      v34[3] = vbslq_s8(v33, vextq_s8(v28, v28, 4uLL), (int8x16_t)vaddq_f32(v31, vmulq_laneq_f32(v32, v23, 2)));
      v15 -= 4;
      v14 += 64;
    }
    while (v4 + v15 > 3);
    LODWORD(v35) = -v15;
    if ((int)v35 >= v4)
      goto LABEL_3;
LABEL_10:
    v35 = v35;
    do
    {
      v36 = *((_QWORD *)this + 51);
      v37 = vaddq_f32(*(float32x4_t *)(v36 + 16), vmulq_f32(*(float32x4_t *)v36, (float32x4_t)vbslq_s8(*(int8x16_t *)(v36 + 32), *(int8x16_t *)(v8 + 16 * v35), vextq_s8(*(int8x16_t *)(v11 + 16 * v35), *(int8x16_t *)(v11 + 16 * v35), 0xCuLL))));
      v38 = *(int8x16_t *)(v7 + 16 * v35);
      v38.i64[1] = v37.i64[1];
      *(int8x16_t *)(v6 + 16 * v35++) = vbslq_s8(*(int8x16_t *)(v36 + 80), vextq_s8(v38, v38, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v36 + 64), v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v36 + 48), *(float32x2_t *)v37.f32, 1))));
    }
    while (v35 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::GetDOD(HgcYUV444TriPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::GetROI(HgcYUV444TriPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444TriPlanar_709ToRGB::HgcYUV444TriPlanar_709ToRGB(HgcYUV444TriPlanar_709ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6539520;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AF0;
  v3[4] = xmmword_1B3552B00;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9C578(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444TriPlanar_709ToRGB::~HgcYUV444TriPlanar_709ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539520;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539520;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6539520;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444TriPlanar_709ToRGB::SetParameter(HgcYUV444TriPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::GetParameter(HgcYUV444TriPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444TriPlanar_2020ToRGB::GetProgram(HgcYUV444TriPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f79a664b:38284d73:72f9ca6b:398dd0ca\n"
             "//SIG=00400000:00000007:00000007:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7637b7ca:94e18948:9249a20f:2be63cfc\n"
             "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=a3e884d8:41b7c32f:d6ccb16b:fb255cb1\n"
           "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV444TriPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV444TriPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444TriPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002a8\n[[ visible ]] FragmentOut HgcYUV444TriPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9CB04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9CB3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9CB34);
}

char *HgcYUV444TriPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcYUV444TriPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::BindTexture(HgcYUV444TriPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 == 2)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
    }
    else
    {
      if (a3 != 1)
        return 0xFFFFFFFFLL;
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::Bind(HgcYUV444TriPlanar_2020ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV444TriPlanar_2020ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::RenderTile(HgcYUV444TriPlanar_2020ToRGB *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int8x16_t *v34;
  uint64_t v35;
  uint64_t v36;
  float32x4_t v37;
  int8x16_t v38;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((int *)a2 + 6);
    v6 = *((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 14);
    v8 = *((_QWORD *)a2 + 10);
    v9 = 16 * *((int *)a2 + 22);
    v10 = 16 * *((int *)a2 + 26);
    v11 = *((_QWORD *)a2 + 12);
    v12 = 16 * *((int *)a2 + 30);
    v13 = 16 * v5;
    while (v4 < 4)
    {
      LODWORD(v35) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      ++v3;
      v8 += v9;
      v11 += v10;
      v7 += v12;
      v6 += v13;
      if (v3 == v2)
        return 0;
    }
    v14 = 0;
    v15 = 0;
    do
    {
      v16 = *((_QWORD *)this + 51);
      v17 = *(int8x16_t *)(v16 + 32);
      v18 = *(float32x4_t *)(v16 + 48);
      v19 = *(float32x4_t *)(v16 + 16);
      v20 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14), vextq_s8(*(int8x16_t *)(v11 + v14), *(int8x16_t *)(v11 + v14), 0xCuLL))));
      v21 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 16), vextq_s8(*(int8x16_t *)(v11 + v14 + 16), *(int8x16_t *)(v11 + v14 + 16), 0xCuLL))));
      v22 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 32), vextq_s8(*(int8x16_t *)(v11 + v14 + 32), *(int8x16_t *)(v11 + v14 + 32), 0xCuLL))));
      v23 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 48), vextq_s8(*(int8x16_t *)(v11 + v14 + 48), *(int8x16_t *)(v11 + v14 + 48), 0xCuLL))));
      v24 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1));
      v25 = *(int8x16_t *)(v7 + v14);
      v26 = *(int8x16_t *)(v7 + v14 + 16);
      v25.i64[1] = v20.i64[1];
      v27 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v21.f32, 1));
      v29 = *(int8x16_t *)(v7 + v14 + 32);
      v28 = *(int8x16_t *)(v7 + v14 + 48);
      v26.i64[1] = v21.i64[1];
      v29.i64[1] = v22.i64[1];
      v30 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v22.f32, 1));
      v31 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v23.f32, 1));
      v28.i64[1] = v23.i64[1];
      v32 = *(float32x4_t *)(v16 + 64);
      v33 = *(int8x16_t *)(v16 + 80);
      v34 = (int8x16_t *)(v6 + v14);
      *v34 = vbslq_s8(v33, vextq_s8(v25, v25, 4uLL), (int8x16_t)vaddq_f32(v24, vmulq_laneq_f32(v32, v20, 2)));
      v34[1] = vbslq_s8(v33, vextq_s8(v26, v26, 4uLL), (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(v32, v21, 2)));
      v34[2] = vbslq_s8(v33, vextq_s8(v29, v29, 4uLL), (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(v32, v22, 2)));
      v34[3] = vbslq_s8(v33, vextq_s8(v28, v28, 4uLL), (int8x16_t)vaddq_f32(v31, vmulq_laneq_f32(v32, v23, 2)));
      v15 -= 4;
      v14 += 64;
    }
    while (v4 + v15 > 3);
    LODWORD(v35) = -v15;
    if ((int)v35 >= v4)
      goto LABEL_3;
LABEL_10:
    v35 = v35;
    do
    {
      v36 = *((_QWORD *)this + 51);
      v37 = vaddq_f32(*(float32x4_t *)(v36 + 16), vmulq_f32(*(float32x4_t *)v36, (float32x4_t)vbslq_s8(*(int8x16_t *)(v36 + 32), *(int8x16_t *)(v8 + 16 * v35), vextq_s8(*(int8x16_t *)(v11 + 16 * v35), *(int8x16_t *)(v11 + 16 * v35), 0xCuLL))));
      v38 = *(int8x16_t *)(v7 + 16 * v35);
      v38.i64[1] = v37.i64[1];
      *(int8x16_t *)(v6 + 16 * v35++) = vbslq_s8(*(int8x16_t *)(v36 + 80), vextq_s8(v38, v38, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v36 + 64), v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v36 + 48), *(float32x2_t *)v37.f32, 1))));
    }
    while (v35 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::GetDOD(HgcYUV444TriPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::GetROI(HgcYUV444TriPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444TriPlanar_2020ToRGB::HgcYUV444TriPlanar_2020ToRGB(HgcYUV444TriPlanar_2020ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6539788;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3058F00;
  v3[4] = xmmword_1B3058F10;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9D044(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444TriPlanar_2020ToRGB::~HgcYUV444TriPlanar_2020ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539788;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539788;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6539788;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::SetParameter(HgcYUV444TriPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::GetParameter(HgcYUV444TriPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_luma::GetProgram(HgcYUV420BiPlanar_luma *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000020a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=362a17a2:e54929ff:e041de3e:e21b3210\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000203\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2456f903:b3470d55:359ed246:2c083ec0\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000019e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "}\n"
           "//MD5=df35ce51:fa3c22ab:4af7cc35:bf3b1e9a\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_luma::InitProgramDescriptor(HgcYUV420BiPlanar_luma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_luma_hgc_visible", "//Metal1.0     \n//LEN=00000000e3\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_luma_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    FragmentOut output;\n"
    "\n"
    "    output.color0.x = color0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9D4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9D4D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9D4C8);
}

double HgcYUV420BiPlanar_luma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552C30;
  strcpy(v3, "HgcYUV420BiPlanar_luma [hgc1]");
  return *(double *)"anar_luma [hgc1]";
}

uint64_t HgcYUV420BiPlanar_luma::BindTexture(HgcYUV420BiPlanar_luma *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_luma::Bind(HgcYUV420BiPlanar_luma *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV420BiPlanar_luma *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma::RenderTile(HgcYUV420BiPlanar_luma *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t *v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t *v25;
  int8x16_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v27 = 0;
        v28 = 16 * v7;
        v29 = 16 * v6;
        v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v31 = 0;
          do
          {
            v5[v31 / 0x10] = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), v4[v31 / 0x10], *(int8x16_t *)*((_QWORD *)this + 51));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          v4 = (int8x16_t *)((char *)v4 + v28);
          v5 = (int8x16_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v15;
          v18 = v14;
          v19 = (int8x16_t *)*((_QWORD *)this + 51);
          v20 = v19[1];
          v21 = vbslq_s8(v20, v4[v16 - 2], *v19);
          v22 = vbslq_s8(v20, v4[v16 - 1], *v19);
          v23 = vbslq_s8(v20, v4[v16], *v19);
          v24 = vbslq_s8(v20, v4[v16 + 1], *v19);
          v25 = &v5[v16];
          v25[-2] = v21;
          v25[-1] = v22;
          v13 += 4;
          *v25 = v23;
          v25[1] = v24;
          v16 += 4;
          v15 += 4;
          v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v26 = *v17++;
            *v18++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), v26, *(int8x16_t *)*((_QWORD *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (int8x16_t *)((char *)v4 + v10);
        v11 = (int8x16_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma::GetDOD(HgcYUV420BiPlanar_luma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV420BiPlanar_luma::GetROI(HgcYUV420BiPlanar_luma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV420BiPlanar_luma::HgcYUV420BiPlanar_luma(HgcYUV420BiPlanar_luma *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65399F0;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304EFF0;
  v3[1] = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2B9D800(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_luma::~HgcYUV420BiPlanar_luma(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65399F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65399F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_luma::SetParameter(HgcYUV420BiPlanar_luma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_luma::GetParameter(HgcYUV420BiPlanar_luma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_luma_pack2::GetProgram(HgcYUV420BiPlanar_luma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000284\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.y = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4456c075:b6d6ba4d:38e99e92:436ff40d\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000270\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.y = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b0085e2f:e0f56ad7:4e83395a:f54f2528\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000226\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    gl_FragColor.y = r0.x;\n"
           "}\n"
           "//MD5=eaeac9e2:ac28c509:f186b78a:7563dbf5\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_luma_pack2::InitProgramDescriptor(HgcYUV420BiPlanar_luma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_luma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001cf\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_luma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).x;\n"
    "    output.color0.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    output.color0.y = r0.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9DD20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9DD5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9DD54);
}

char *HgcYUV420BiPlanar_luma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcYUV420BiPlanar_luma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::BindTexture(HgcYUV420BiPlanar_luma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::Bind(HgcYUV420BiPlanar_luma_pack2 *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV420BiPlanar_luma_pack2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::RenderTile(HgcYUV420BiPlanar_luma_pack2 *this, HGTile *a2)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int8x16_t *v12;
  uint64_t v13;
  int8x16_t *v14;
  unint64_t v15;
  int v16;
  int8x16_t *v17;
  int8x16_t *v18;
  uint64_t v19;
  unsigned int v20;
  int8x16_t *v21;
  int8x16_t *v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int32x4_t *v38;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = *(int *)a2;
    v4 = (*((_DWORD *)a2 + 2) - v3);
    v5 = *((_QWORD *)a2 + 10);
    v6 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v33 = 0;
        v34 = v5 + 16 * v3 + 16;
        v35 = 16 * v8;
        v36 = 16 * v4;
        do
        {
          v37 = 0;
          v38 = (int32x4_t *)v34;
          do
          {
            v6[v37 / 0x10] = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 32), (int8x16_t)vrev64q_s32(*v38), vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), (int8x16_t)v38[-1], *(int8x16_t *)*((_QWORD *)this + 51)));
            v37 += 16;
            v38 += 2;
          }
          while (v36 != v37);
          ++v33;
          v6 += v7;
          v34 += v35;
        }
        while (v33 != v2);
      }
    }
    else
    {
      v9 = 0;
      v10 = v5 + 16 * v3;
      v11 = v10 + 64;
      v12 = v6 + 2;
      v13 = 16 * v7;
      v14 = v6 + 4;
      do
      {
        v15 = 0;
        v16 = 8;
        v17 = v14;
        v18 = v12;
        v19 = v11;
        do
        {
          v20 = v16;
          v21 = v17;
          v22 = (int8x16_t *)*((_QWORD *)this + 51);
          v23 = v22[1];
          v24 = vbslq_s8(v23, *(int8x16_t *)(v19 - 64), *v22);
          v25 = vbslq_s8(v23, *(int8x16_t *)(v19 - 32), *v22);
          v26 = vbslq_s8(v23, *(int8x16_t *)v19, *v22);
          v27 = vbslq_s8(v23, *(int8x16_t *)(v19 + 32), *v22);
          v28 = v22[2];
          v29 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 - 48)), v24);
          v30 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 - 16)), v25);
          v31 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 + 16)), v26);
          v32 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 + 48)), v27);
          v18[-2] = v29;
          v18[-1] = v30;
          v15 += 4;
          v19 += 128;
          *v18 = v31;
          v18[1] = v32;
          v18 += 4;
          v16 = v20 + 8;
          v17 += 4;
        }
        while ((uint64_t)v15 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v15)
        {
          do
          {
            *v21++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 32), (int8x16_t)vrev64q_s32(*(int32x4_t *)(v10 + 16 * (v20 + 1))), vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), *(int8x16_t *)(v10 + 16 * v20), *(int8x16_t *)*((_QWORD *)this + 51)));
            ++v15;
            v20 += 2;
          }
          while (v15 < v4);
        }
        v10 += 16 * v8;
        ++v9;
        v11 += 16 * v8;
        v12 = (int8x16_t *)((char *)v12 + v13);
        v14 = (int8x16_t *)((char *)v14 + v13);
      }
      while (v9 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::GetDOD(HgcYUV420BiPlanar_luma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV420BiPlanar_luma_pack2::GetROI(HgcYUV420BiPlanar_luma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 1u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV420BiPlanar_luma_pack2::HgcYUV420BiPlanar_luma_pack2(HgcYUV420BiPlanar_luma_pack2 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6539C58;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304EFF0;
  v3[1] = xmmword_1B3050E20;
  v3[2] = xmmword_1B3050FF0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420BiPlanar_luma_pack2 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2B9E2D4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_luma_pack2::~HgcYUV420BiPlanar_luma_pack2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539C58;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6539C58;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_luma_pack2::SetParameter(HgcYUV420BiPlanar_luma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::GetParameter(HgcYUV420BiPlanar_luma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_luma_pack4::GetProgram(HgcYUV420BiPlanar_luma_pack4 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000364\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    r2.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).x;\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy).x;\n"
             "    output.color0.y = float(r0.x);\n"
             "    output.color0.z = float(r1.x);\n"
             "    output.color0.w = float(r2.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8b57dc08:a504f16a:c8e16446:44c11f04\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0003:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000334\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    r2.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).x;\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy).x;\n"
             "    output.color0.y = r0.x;\n"
             "    output.color0.z = r1.x;\n"
             "    output.color0.w = r2.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2e819e4d:f08f0348:7d03619e:883413bd\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0003:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    r2.x = texture2D(hg_Texture0, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord3.xy).x;\n"
           "    gl_FragColor.y = r0.x;\n"
           "    gl_FragColor.z = r1.x;\n"
           "    gl_FragColor.w = r2.x;\n"
           "}\n"
           "//MD5=c72d106c:41629b4d:88d61728:329143b3\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0003:0000:0000:0000:0000:0000:0004:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_luma_pack4::InitProgramDescriptor(HgcYUV420BiPlanar_luma_pack4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_luma_pack4_hgc_visible", "//Metal1.0     \n//LEN=00000002b3\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_luma_pack4_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2,\n    float4 texCoord3)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).x;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    r2.x = hg_Texture0.sample(hg_Sampler0, texCoord2.xy).x;\n"
    "    output.color0.x = hg_Texture0.sample(hg_Sampler0, texCoord3.xy).x;\n"
    "    output.color0.y = r0.x;\n"
    "    output.color0.z = r1.x;\n"
    "    output.color0.w = r2.x;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9E924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9E968(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9E960);
}

char *HgcYUV420BiPlanar_luma_pack4::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcYUV420BiPlanar_luma_pack4 [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::BindTexture(HgcYUV420BiPlanar_luma_pack4 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 1.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -1.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::Bind(HgcYUV420BiPlanar_luma_pack4 *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV420BiPlanar_luma_pack4 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::RenderTile(HgcYUV420BiPlanar_luma_pack4 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int8x16_t *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int8x16_t *v13;
  uint64_t v14;
  int8x16_t *v15;
  unint64_t v16;
  int v17;
  int8x16_t *v18;
  int8x16_t *v19;
  uint64_t v20;
  unsigned int v21;
  int8x16_t *v22;
  int8x16_t *v23;
  int8x16_t v24;
  int8x8_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  uint64_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  _OWORD *v41;
  uint64_t v42;
  int8x16_t v43;
  int32x4_t v44;
  int8x16_t v45;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = *((_QWORD *)a2 + 10);
    v5 = 3 * *(_DWORD *)a2;
    v6 = v5;
    v7 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v36 = 0;
        v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v38 = v4 + 16 * v5 + 32;
        v39 = 16 * v9;
        do
        {
          v40 = 0;
          v41 = (_OWORD *)v38;
          do
          {
            v42 = *((_QWORD *)this + 51);
            *(int8x8_t *)v43.i8 = vbsl_s8(*(int8x8_t *)v42, *(int8x8_t *)(v41 - 2), (int8x8_t)*(_OWORD *)&vrev64q_s32(*((int32x4_t *)v41 - 1)));
            v44 = *(int32x4_t *)v41;
            v45 = *((int8x16_t *)v41 + 1);
            v41 += 4;
            v43.i64[1] = v44.i64[0];
            v7[v40 / 0x10] = vbslq_s8(*(int8x16_t *)(v42 + 16), vextq_s8(v45, v45, 4uLL), v43);
            v40 += 16;
          }
          while (v37 != v40);
          ++v36;
          v7 += v8;
          v38 += v39;
        }
        while (v36 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = v4 + 16 * v5;
      v12 = v4 + 16 * v6 + 128;
      v13 = v7 + 2;
      v14 = 16 * v8;
      v15 = v7 + 4;
      do
      {
        v16 = 0;
        v17 = 16;
        v18 = v15;
        v19 = v13;
        v20 = v12;
        do
        {
          v21 = v17;
          v22 = v18;
          v23 = (int8x16_t *)*((_QWORD *)this + 51);
          v24 = v23[1];
          v25 = (int8x8_t)vmvnq_s8(*v23).u64[0];
          *(int8x8_t *)v26.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)(v20 - 128)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 - 112)), v25));
          v26.i64[1] = *(_QWORD *)(v20 - 96);
          *(int8x8_t *)v27.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)(v20 - 64)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 - 48)), v25));
          v27.i64[1] = *(_QWORD *)(v20 - 32);
          *(int8x8_t *)v28.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)v20), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 + 16)), v25));
          v28.i64[1] = *(_QWORD *)(v20 + 32);
          *(int8x8_t *)v29.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)(v20 + 64)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 + 80)), v25));
          v29.i64[1] = *(_QWORD *)(v20 + 96);
          v30 = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 - 16), *(int8x16_t *)(v20 - 16), 4uLL), v27);
          v31 = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 + 48), *(int8x16_t *)(v20 + 48), 4uLL), v28);
          v32 = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 + 112), *(int8x16_t *)(v20 + 112), 4uLL), v29);
          v19[-2] = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 - 80), *(int8x16_t *)(v20 - 80), 4uLL), v26);
          v19[-1] = v30;
          v16 += 4;
          v20 += 256;
          *v19 = v31;
          v19[1] = v32;
          v19 += 4;
          v17 = v21 + 16;
          v18 += 4;
        }
        while ((uint64_t)v16 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v16)
        {
          do
          {
            v33 = *((_QWORD *)this + 51);
            *(int8x8_t *)v34.i8 = vbsl_s8(*(int8x8_t *)v33, *(int8x8_t *)(v11 + 16 * v21), (int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v11 + 16 * (v21 + 1))));
            v35 = *(int8x16_t *)(v11 + 16 * (v21 + 3));
            v34.i64[1] = *(_QWORD *)(v11 + 16 * (v21 + 2));
            *v22++ = vbslq_s8(*(int8x16_t *)(v33 + 16), vextq_s8(v35, v35, 4uLL), v34);
            ++v16;
            v21 += 4;
          }
          while (v16 < v3);
        }
        v11 += 16 * v9;
        ++v10;
        v12 += 16 * v9;
        v13 = (int8x16_t *)((char *)v13 + v14);
        v15 = (int8x16_t *)((char *)v15 + v14);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::GetDOD(HgcYUV420BiPlanar_luma_pack4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFD, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.25);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV420BiPlanar_luma_pack4::GetROI(HgcYUV420BiPlanar_luma_pack4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 4.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 3u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV420BiPlanar_luma_pack4::HgcYUV420BiPlanar_luma_pack4(HgcYUV420BiPlanar_luma_pack4 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6539EC0;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3050E20;
  v3[1] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420BiPlanar_luma_pack4 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2B9F034(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_luma_pack4::~HgcYUV420BiPlanar_luma_pack4(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6539EC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6539EC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_luma_pack4::SetParameter(HgcYUV420BiPlanar_luma_pack4 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::GetParameter(HgcYUV420BiPlanar_luma_pack4 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_chroma_pack2::GetProgram(HgcYUV420BiPlanar_chroma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    output.color0.zw = float2(r1.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=33bdb345:2758fc0c:d30c75e2:ea65b96f\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    output.color0.zw = r1.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6888e40f:7ebf1f5f:d902b6ad:5e066264\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord1.xy).yz;\n"
           "    r1.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "    gl_FragColor.zw = r1.yz;\n"
           "}\n"
           "//MD5=0c7412c0:8a79fbe3:17780697:6248caac\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_chroma_pack2::InitProgramDescriptor(HgcYUV420BiPlanar_chroma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_chroma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001ee\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_chroma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).yz;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    output.color0.zw = r1.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9F554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9F590(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9F588);
}

char *HgcYUV420BiPlanar_chroma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcYUV420BiPlanar_chroma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::BindTexture(HgcYUV420BiPlanar_chroma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -1.5, -0.5, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 2.0, 1.0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, -0.5, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 2.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::Bind(HgcYUV420BiPlanar_chroma_pack2 *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV420BiPlanar_chroma_pack2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::RenderTile(HgcYUV420BiPlanar_chroma_pack2 *this, HGTile *a2)
{
  int v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  uint64_t v17;
  int8x16_t *v18;
  unint64_t v19;
  int v20;
  int8x16_t *v21;
  _OWORD *v22;
  uint64_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  __int128 v27;
  int8x16_t v28;
  __int128 v29;
  int8x16_t v30;
  __int128 v31;
  unsigned int v32;
  int8x16_t *v33;
  int8x16_t v34;
  int8x16_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int8x16_t *v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;

  v2 = *((_DWORD *)a2 + 1);
  v3 = *((_DWORD *)a2 + 3) - v2;
  if (v3 >= 1)
  {
    v4 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v5 = *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 10);
    v7 = v5 * v2;
    v8 = (int)v5 * v2;
    v9 = 3 * *(_DWORD *)a2;
    v10 = *((_QWORD *)a2 + 2);
    v11 = *((int *)a2 + 6);
    v12 = 2 * v5;
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v36 = 0;
        v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v38 = 16 * v7 + 16 * v9 + v6 + 32;
        do
        {
          v39 = 0;
          v40 = (int8x16_t *)v38;
          do
          {
            v41 = v40[-2];
            v42 = *v40;
            v40 += 4;
            v43 = vextq_s8(v41, v42, 0xCuLL);
            *(int8x8_t *)v41.i8 = vext_s8(*(int8x8_t *)v41.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL), 4uLL);
            v41.i64[1] = vextq_s8(v43, v43, 8uLL).u64[0];
            *(int8x16_t *)(v10 + v39) = v41;
            v39 += 16;
          }
          while (v37 != v39);
          ++v36;
          v10 += 16 * v11;
          v38 += 32 * v5;
        }
        while (v36 != v3);
      }
    }
    else
    {
      v13 = 0;
      v14 = v6 + 16 * v7 + 16 * v9;
      v15 = 16 * v8 + 16 * v9 + v6 + 128;
      v16 = (_OWORD *)(v10 + 32);
      v17 = 16 * v11;
      v18 = (int8x16_t *)(v10 + 64);
      do
      {
        v19 = 0;
        v20 = 18;
        v21 = v18;
        v22 = v16;
        v23 = v15;
        do
        {
          v24 = *(int8x16_t *)(v23 - 128);
          v25 = vextq_s8(v24, *(int8x16_t *)(v23 - 96), 0xCuLL);
          *(int8x8_t *)v24.i8 = vext_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), 4uLL);
          v24.i64[1] = vextq_s8(v25, v25, 8uLL).u64[0];
          v26 = vextq_s8(v24, *(int8x16_t *)(v23 - 32), 0xCuLL);
          *(int8x8_t *)&v27 = vext_s8(*(int8x8_t *)(v23 - 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v23 - 64), *(int8x16_t *)(v23 - 64), 8uLL), 4uLL);
          *((_QWORD *)&v27 + 1) = vextq_s8(v26, v26, 8uLL).u64[0];
          v28 = vextq_s8(v24, *(int8x16_t *)(v23 + 32), 0xCuLL);
          *(int8x8_t *)&v29 = vext_s8(*(int8x8_t *)v23, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v23, *(int8x16_t *)v23, 8uLL), 4uLL);
          *((_QWORD *)&v29 + 1) = vextq_s8(v28, v28, 8uLL).u64[0];
          v30 = vextq_s8(v24, *(int8x16_t *)(v23 + 96), 0xCuLL);
          *(int8x8_t *)&v31 = vext_s8(*(int8x8_t *)(v23 + 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v23 + 64), *(int8x16_t *)(v23 + 64), 8uLL), 4uLL);
          *((_QWORD *)&v31 + 1) = vextq_s8(v30, v30, 8uLL).u64[0];
          v32 = v20;
          v33 = v21;
          *(v22 - 2) = v24;
          *(v22 - 1) = v27;
          v19 += 4;
          v23 += 256;
          *v22 = v29;
          v22[1] = v31;
          v22 += 4;
          v20 += 16;
          v21 += 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            v34 = *(int8x16_t *)(v14 + 16 * (v32 - 2));
            v35 = vextq_s8(v34, *(int8x16_t *)(v14 + 16 * v32), 0xCuLL);
            *(int8x8_t *)v34.i8 = vext_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), 4uLL);
            v34.i64[1] = vextq_s8(v35, v35, 8uLL).u64[0];
            *v33++ = v34;
            ++v19;
            v32 += 4;
          }
          while (v19 < v4);
        }
        v14 += 16 * v12;
        ++v13;
        v15 += 16 * v12;
        v16 = (_OWORD *)((char *)v16 + v17);
        v18 = (int8x16_t *)((char *)v18 + v17);
      }
      while (v13 != v3);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::GetDOD(HgcYUV420BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFE, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.25);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::GetROI(HgcYUV420BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 4.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 2u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV420BiPlanar_chroma_pack2::HgcYUV420BiPlanar_chroma_pack2(HgcYUV420BiPlanar_chroma_pack2 *this)
{
  _QWORD *v2;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653A128;
  *((_QWORD *)this + 51) = operator new();
  (*(void (**)(HgcYUV420BiPlanar_chroma_pack2 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2B9FB1C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_chroma_pack2::~HgcYUV420BiPlanar_chroma_pack2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653A128;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653A128;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::SetParameter(HgcYUV420BiPlanar_chroma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::GetParameter(HgcYUV420BiPlanar_chroma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_chroma::GetProgram(HgcYUV420BiPlanar_chroma *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000235\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5ceef05:898edb99:9f947171:98dbaa5b\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000227\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=513314b2:face81c8:9010d868:78fd2bc7\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "}\n"
           "//MD5=6e8f9b59:fe470076:deb0cf55:8a2a4614\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_chroma::InitProgramDescriptor(HgcYUV420BiPlanar_chroma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_chroma_hgc_visible", "//Metal1.0     \n//LEN=0000000172\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_chroma_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2B9FF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2B9FFD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2B9FFCCLL);
}

double HgcYUV420BiPlanar_chroma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcYUV420BiPlanar_chroma [hgc1]");
  return *(double *)"ar_chroma [hgc1]";
}

uint64_t HgcYUV420BiPlanar_chroma::BindTexture(HgcYUV420BiPlanar_chroma *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, -0.5, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 2.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma::Bind(HgcYUV420BiPlanar_chroma *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV420BiPlanar_chroma *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma::RenderTile(HgcYUV420BiPlanar_chroma *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int8x16_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int8x16_t *v15;
  uint64_t v16;
  int8x16_t *v17;
  unint64_t v18;
  int8x16_t *v19;
  uint64_t v20;
  int8x16_t *v21;
  int8x16_t *v22;
  uint64_t v23;
  int8x16_t *v24;
  int8x16_t *v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int8x16_t *v34;

  v2 = *((_DWORD *)a2 + 1);
  v3 = *((_DWORD *)a2 + 3) - v2;
  if (v3 >= 1)
  {
    v4 = *(int *)a2;
    v5 = (*((_DWORD *)a2 + 2) - v4);
    v6 = *((int *)a2 + 22);
    v7 = *((_QWORD *)a2 + 10);
    v8 = v6 * v2;
    v9 = v7 + 16 * (int)v6 * v2 + 16 * v4;
    v10 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v11 = *((int *)a2 + 6);
    v12 = 2 * v6;
    if ((int)v5 < 4)
    {
      if ((int)v5 >= 1)
      {
        v30 = 0;
        v31 = 16 * v12;
        v32 = 32 * (*((_DWORD *)a2 + 2) - v4);
        do
        {
          v33 = 0;
          v34 = v10;
          do
          {
            *v34++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v9 + v33), *(int8x16_t *)(v9 + v33), 4uLL), *(int8x16_t *)*((_QWORD *)this + 51));
            v33 += 32;
          }
          while (v32 != v33);
          ++v30;
          v10 += v11;
          v9 += v31;
        }
        while (v30 != v3);
      }
    }
    else
    {
      v13 = 0;
      v14 = 16 * v4 + 16 * v8 + v7 + 64;
      v15 = v10 + 2;
      v16 = 16 * v11;
      v17 = v10 + 4;
      do
      {
        v18 = 0;
        v19 = v17;
        v20 = 8;
        v21 = v15;
        v22 = (int8x16_t *)v14;
        do
        {
          v23 = v20;
          v24 = v19;
          v25 = (int8x16_t *)*((_QWORD *)this + 51);
          v26 = v25[1];
          v27 = vbslq_s8(v26, vextq_s8(v22[-2], v22[-2], 4uLL), *v25);
          v28 = vbslq_s8(v26, vextq_s8(*v22, *v22, 4uLL), *v25);
          v29 = vbslq_s8(v26, vextq_s8(v22[2], v22[2], 4uLL), *v25);
          v21[-2] = vbslq_s8(v26, vextq_s8(v22[-4], v22[-4], 4uLL), *v25);
          v21[-1] = v27;
          v18 += 4;
          v22 += 8;
          *v21 = v28;
          v21[1] = v29;
          v21 += 4;
          v20 += 8;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v5 - 3));
        if ((int)v5 > (int)v18)
        {
          do
          {
            *v24++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v9 + 16 * (v23 & 0xFFFFFFFE)), *(int8x16_t *)(v9 + 16 * (v23 & 0xFFFFFFFE)), 4uLL), *(int8x16_t *)*((_QWORD *)this + 51));
            ++v18;
            v23 += 2;
          }
          while (v18 < v5);
        }
        v9 += 16 * v12;
        ++v13;
        v14 += 16 * v12;
        v15 = (int8x16_t *)((char *)v15 + v16);
        v17 = (int8x16_t *)((char *)v17 + v16);
      }
      while (v13 != v3);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma::GetDOD(HgcYUV420BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

uint64_t HgcYUV420BiPlanar_chroma::GetROI(HgcYUV420BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

void HgcYUV420BiPlanar_chroma::HgcYUV420BiPlanar_chroma(HgcYUV420BiPlanar_chroma *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653A390;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304EFF0;
  v3[1] = xmmword_1B3050F80;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420BiPlanar_chroma *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BA0438(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_chroma::~HgcYUV420BiPlanar_chroma(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653A390;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653A390;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_chroma::SetParameter(HgcYUV420BiPlanar_chroma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_chroma::GetParameter(HgcYUV420BiPlanar_chroma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV422BiPlanar_chroma::GetProgram(HgcYUV422BiPlanar_chroma *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000235\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5ceef05:898edb99:9f947171:98dbaa5b\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000227\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=513314b2:face81c8:9010d868:78fd2bc7\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "}\n"
           "//MD5=6e8f9b59:fe470076:deb0cf55:8a2a4614\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_chroma::InitProgramDescriptor(HgcYUV422BiPlanar_chroma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_chroma_hgc_visible", "//Metal1.0     \n//LEN=0000000172\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_chroma_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA08C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA08F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA08F0);
}

double HgcYUV422BiPlanar_chroma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A60;
  strcpy(v3, "HgcYUV422BiPlanar_chroma [hgc1]");
  return *(double *)"ar_chroma [hgc1]";
}

uint64_t HgcYUV422BiPlanar_chroma::BindTexture(HgcYUV422BiPlanar_chroma *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma::Bind(HgcYUV422BiPlanar_chroma *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV422BiPlanar_chroma *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma::RenderTile(HgcYUV422BiPlanar_chroma *this, HGTile *a2)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int8x16_t *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int8x16_t *v12;
  uint64_t v13;
  int8x16_t *v14;
  unint64_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int8x16_t *v18;
  int8x16_t *v19;
  uint64_t v20;
  int8x16_t *v21;
  int8x16_t *v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int8x16_t *v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = *(int *)a2;
    v4 = (*((_DWORD *)a2 + 2) - v3);
    v5 = *((_QWORD *)a2 + 10);
    v6 = v5 + 16 * v3;
    v7 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        v27 = 0;
        v28 = 16 * v9;
        v29 = 32 * (*((_DWORD *)a2 + 2) - v3);
        do
        {
          v30 = 0;
          v31 = v7;
          do
          {
            *v31++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v6 + v30), *(int8x16_t *)(v6 + v30), 4uLL), *(int8x16_t *)*((_QWORD *)this + 51));
            v30 += 32;
          }
          while (v29 != v30);
          ++v27;
          v7 += v8;
          v6 += v28;
        }
        while (v27 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = v5 + 16 * v3 + 64;
      v12 = v7 + 2;
      v13 = 16 * v8;
      v14 = v7 + 4;
      do
      {
        v15 = 0;
        v16 = v14;
        v17 = 8;
        v18 = v12;
        v19 = (int8x16_t *)v11;
        do
        {
          v20 = v17;
          v21 = v16;
          v22 = (int8x16_t *)*((_QWORD *)this + 51);
          v23 = v22[1];
          v24 = vbslq_s8(v23, vextq_s8(v19[-2], v19[-2], 4uLL), *v22);
          v25 = vbslq_s8(v23, vextq_s8(*v19, *v19, 4uLL), *v22);
          v26 = vbslq_s8(v23, vextq_s8(v19[2], v19[2], 4uLL), *v22);
          v18[-2] = vbslq_s8(v23, vextq_s8(v19[-4], v19[-4], 4uLL), *v22);
          v18[-1] = v24;
          v15 += 4;
          v19 += 8;
          *v18 = v25;
          v18[1] = v26;
          v18 += 4;
          v17 += 8;
          v16 = v21 + 4;
        }
        while ((uint64_t)v15 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v15)
        {
          do
          {
            *v21++ = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v6 + 16 * (v20 & 0xFFFFFFFE)), *(int8x16_t *)(v6 + 16 * (v20 & 0xFFFFFFFE)), 4uLL), *(int8x16_t *)*((_QWORD *)this + 51));
            ++v15;
            v20 += 2;
          }
          while (v15 < v4);
        }
        v6 += 16 * v9;
        ++v10;
        v11 += 16 * v9;
        v12 = (int8x16_t *)((char *)v12 + v13);
        v14 = (int8x16_t *)((char *)v14 + v13);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma::GetDOD(HgcYUV422BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

uint64_t HgcYUV422BiPlanar_chroma::GetROI(HgcYUV422BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

void HgcYUV422BiPlanar_chroma::HgcYUV422BiPlanar_chroma(HgcYUV422BiPlanar_chroma *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653A5F8;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B304EFF0;
  v3[1] = xmmword_1B3050F80;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422BiPlanar_chroma *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BA0D44(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_chroma::~HgcYUV422BiPlanar_chroma(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653A5F8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653A5F8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_chroma::SetParameter(HgcYUV422BiPlanar_chroma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV422BiPlanar_chroma::GetParameter(HgcYUV422BiPlanar_chroma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV422BiPlanar_chroma_pack2::GetProgram(HgcYUV422BiPlanar_chroma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    output.color0.zw = float2(r1.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=33bdb345:2758fc0c:d30c75e2:ea65b96f\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    output.color0.zw = r1.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6888e40f:7ebf1f5f:d902b6ad:5e066264\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord1.xy).yz;\n"
           "    r1.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "    gl_FragColor.zw = r1.yz;\n"
           "}\n"
           "//MD5=0c7412c0:8a79fbe3:17780697:6248caac\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_chroma_pack2::InitProgramDescriptor(HgcYUV422BiPlanar_chroma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_chroma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001ee\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_chroma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).yz;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    output.color0.zw = r1.yz;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA1264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA12A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA1298);
}

char *HgcYUV422BiPlanar_chroma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552A20;
  strcpy(result, "HgcYUV422BiPlanar_chroma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::BindTexture(HgcYUV422BiPlanar_chroma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -1.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::Bind(HgcYUV422BiPlanar_chroma_pack2 *this, HGHandler *a2)
{
  (*(void (**)(HgcYUV422BiPlanar_chroma_pack2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::RenderTile(HgcYUV422BiPlanar_chroma_pack2 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  uint64_t v14;
  int8x16_t *v15;
  unint64_t v16;
  int v17;
  int8x16_t *v18;
  _OWORD *v19;
  uint64_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  __int128 v24;
  int8x16_t v25;
  __int128 v26;
  int8x16_t v27;
  __int128 v28;
  unsigned int v29;
  int8x16_t *v30;
  int8x16_t v31;
  int8x16_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int8x16_t *v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = *((_QWORD *)a2 + 10);
    v5 = 3 * *(_DWORD *)a2;
    v6 = v5;
    v7 = *((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v33 = 0;
        v34 = v4 + 16 * v5 + 32;
        v35 = 16 * v9;
        v36 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v37 = 0;
          v38 = (int8x16_t *)v34;
          do
          {
            v39 = v38[-2];
            v40 = *v38;
            v38 += 4;
            v41 = vextq_s8(v39, v40, 0xCuLL);
            *(int8x8_t *)v39.i8 = vext_s8(*(int8x8_t *)v39.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL), 4uLL);
            v39.i64[1] = vextq_s8(v41, v41, 8uLL).u64[0];
            *(int8x16_t *)(v7 + v37) = v39;
            v37 += 16;
          }
          while (v36 != v37);
          ++v33;
          v7 += 16 * v8;
          v34 += v35;
        }
        while (v33 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = v4 + 16 * v5;
      v12 = v4 + 16 * v6 + 128;
      v13 = (_OWORD *)(v7 + 32);
      v14 = 16 * v8;
      v15 = (int8x16_t *)(v7 + 64);
      do
      {
        v16 = 0;
        v17 = 18;
        v18 = v15;
        v19 = v13;
        v20 = v12;
        do
        {
          v21 = *(int8x16_t *)(v20 - 128);
          v22 = vextq_s8(v21, *(int8x16_t *)(v20 - 96), 0xCuLL);
          *(int8x8_t *)v21.i8 = vext_s8(*(int8x8_t *)v21.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL), 4uLL);
          v21.i64[1] = vextq_s8(v22, v22, 8uLL).u64[0];
          v23 = vextq_s8(v21, *(int8x16_t *)(v20 - 32), 0xCuLL);
          *(int8x8_t *)&v24 = vext_s8(*(int8x8_t *)(v20 - 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v20 - 64), *(int8x16_t *)(v20 - 64), 8uLL), 4uLL);
          *((_QWORD *)&v24 + 1) = vextq_s8(v23, v23, 8uLL).u64[0];
          v25 = vextq_s8(v21, *(int8x16_t *)(v20 + 32), 0xCuLL);
          *(int8x8_t *)&v26 = vext_s8(*(int8x8_t *)v20, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v20, *(int8x16_t *)v20, 8uLL), 4uLL);
          *((_QWORD *)&v26 + 1) = vextq_s8(v25, v25, 8uLL).u64[0];
          v27 = vextq_s8(v21, *(int8x16_t *)(v20 + 96), 0xCuLL);
          *(int8x8_t *)&v28 = vext_s8(*(int8x8_t *)(v20 + 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v20 + 64), *(int8x16_t *)(v20 + 64), 8uLL), 4uLL);
          *((_QWORD *)&v28 + 1) = vextq_s8(v27, v27, 8uLL).u64[0];
          v29 = v17;
          v30 = v18;
          *(v19 - 2) = v21;
          *(v19 - 1) = v24;
          v16 += 4;
          v20 += 256;
          *v19 = v26;
          v19[1] = v28;
          v19 += 4;
          v17 += 16;
          v18 += 4;
        }
        while ((uint64_t)v16 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v16)
        {
          do
          {
            v31 = *(int8x16_t *)(v11 + 16 * (v29 - 2));
            v32 = vextq_s8(v31, *(int8x16_t *)(v11 + 16 * v29), 0xCuLL);
            *(int8x8_t *)v31.i8 = vext_s8(*(int8x8_t *)v31.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), 4uLL);
            v31.i64[1] = vextq_s8(v32, v32, 8uLL).u64[0];
            *v30++ = v31;
            ++v16;
            v29 += 4;
          }
          while (v16 < v3);
        }
        v11 += 16 * v9;
        ++v10;
        v12 += 16 * v9;
        v13 = (_OWORD *)((char *)v13 + v14);
        v15 = (int8x16_t *)((char *)v15 + v14);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::GetDOD(HgcYUV422BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0, 0, 0xFFFFFFFE, 0);
  v8 = HGRectGrow(v6, v5, v7);
  v9 = HGRectFloat(v8);
  v13 = HGRectScale(v9, v10, v11, v12, 0.25);
  v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::GetROI(HgcYUV422BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3)
    return 0;
  v5 = HGRectFloat(a4.var0);
  v9 = HGRectScale(v5, v6, v7, v8, 4.0);
  v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  v16 = v15;
  v17 = HGRectMake4i(0, 0, 2u, 0);
  v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV422BiPlanar_chroma_pack2::HgcYUV422BiPlanar_chroma_pack2(HgcYUV422BiPlanar_chroma_pack2 *this)
{
  _QWORD *v2;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653A860;
  *((_QWORD *)this + 51) = operator new();
  (*(void (**)(HgcYUV422BiPlanar_chroma_pack2 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BA180C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_chroma_pack2::~HgcYUV422BiPlanar_chroma_pack2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653A860;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653A860;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::SetParameter(HgcYUV422BiPlanar_chroma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::GetParameter(HgcYUV422BiPlanar_chroma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV422BiPlanar_601ToRGB::GetProgram(HgcYUV422BiPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e00be48:1d4c1030:c845256d:4f625dda\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e920bf17:693c75e5:4f148dce:a2580259\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=b28b84a9:65d97aa9:3bf19568:b311251d\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_601ToRGB::InitProgramDescriptor(HgcYUV422BiPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA1D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA1D60(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA1D58);
}

char *HgcYUV422BiPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcYUV422BiPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::BindTexture(HgcYUV422BiPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::Bind(HgcYUV422BiPlanar_601ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV422BiPlanar_601ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::RenderTile(HgcYUV422BiPlanar_601ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v17;
  int v18;
  float32x4_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x2_t v25;
  __int32 v26;
  float32x4_t v27;
  int32x4_t v28;
  __int32 v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  __int32 v35;
  int8x16_t v36;
  float32x4_t v37;
  int32x4_t v38;
  __int32 v39;
  __int32 v40;
  __int32 v41;
  int8x16_t v42;
  float32x4_t v43;
  int32x4_t v44;
  __int32 v45;
  __int32 v46;
  __int32 v47;
  int8x16_t v48;
  int8x16_t v49;
  uint64_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t *v63;
  uint64_t v64;
  float32x4_t v65;
  int32x4_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    v8 = a2[2];
    v9 = a2[10];
    v10 = 16 * a2[11].i32[0];
    v11 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v64) = 0;
      v19 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v9 += v10;
      *(_QWORD *)&v8 += v11;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = 0uLL;
    v20 = 32;
    do
    {
      v21 = vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B3051880));
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B3051880);
      v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B3051880);
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = a2[12];
      v26 = a2[13].i32[0];
      v27 = vaddq_f32(vsubq_f32(v21, v5), v17);
      v28 = vcvtq_s32_f32(v27);
      v27.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
      v29 = v27.i32[1];
      v30 = v27.i32[0];
      v31 = vaddq_f32(vsubq_f32(v22, v5), v17);
      v32 = vcvtq_s32_f32(v31);
      v33 = v30 + v29 * v26;
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v34 = v31.i32[1];
      v35 = v31.i32[0];
      v36 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v33);
      v37 = vaddq_f32(vsubq_f32(v23, v5), v17);
      v38 = vcvtq_s32_f32(v37);
      v39 = v35 + v34 * v26;
      v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
      v40 = v37.i32[1];
      v41 = v37.i32[0];
      v42 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v39);
      v43 = vaddq_f32(vsubq_f32(v24, v5), v17);
      v44 = vcvtq_s32_f32(v43);
      v45 = v41 + v40 * v26;
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      v46 = v43.i32[1];
      v47 = v43.i32[0];
      v48 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v45);
      v49 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * (v47 + v46 * v26));
      v50 = *((_QWORD *)this + 51);
      v51 = *(int8x16_t *)(v50 + 32);
      v52 = *(float32x4_t *)(v50 + 48);
      v53 = *(float32x4_t *)(v50 + 16);
      v54 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 - 32), vextq_s8(v36, v36, 0xCuLL))));
      v55 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 - 16), vextq_s8(v42, v42, 0xCuLL))));
      v56 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20), vextq_s8(v48, v48, 0xCuLL))));
      v57 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 + 16), vextq_s8(v49, v49, 0xCuLL))));
      v19 = vaddq_f32(v19, _Q4);
      v58 = *(float32x4_t *)(v50 + 64);
      v59 = vaddq_f32(vmulq_laneq_f32(v58, v54, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v54.f32, 1)));
      v60 = vaddq_f32(vmulq_laneq_f32(v58, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v55.f32, 1)));
      v61 = vaddq_f32(vmulq_laneq_f32(v58, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v56.f32, 1)));
      v59.i32[3] = 1.0;
      v60.i32[3] = 1.0;
      v61.i32[3] = 1.0;
      v62 = vaddq_f32(vmulq_laneq_f32(v58, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v57.f32, 1)));
      v62.i32[3] = 1.0;
      v63 = (float32x4_t *)(*(_QWORD *)&v8 + v20);
      v63[-2] = v59;
      v63[-1] = v60;
      *v63 = v61;
      v63[1] = v62;
      v18 -= 4;
      v20 += 64;
    }
    while (v6 + v18 > 3);
    LODWORD(v64) = -v18;
    if ((int)v64 >= v6)
      goto LABEL_3;
LABEL_10:
    v64 = v64;
    do
    {
      v65 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B3051880)), v5), v17);
      v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      v67 = *((_QWORD *)this + 51);
      v68 = vaddq_f32(*(float32x4_t *)(v67 + 16), vmulq_f32(*(float32x4_t *)v67, (float32x4_t)vbslq_s8(*(int8x16_t *)(v67 + 32), *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v64), vextq_s8(*(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), 0xCuLL))));
      v69 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v67 + 64), v68, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v67 + 48), *(float32x2_t *)v68.f32, 1)));
      v69.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v64) = v69;
      __asm { FMOV            V16.4S, #1.0 }
      v19 = vaddq_f32(v19, _Q16);
      ++v64;
    }
    while (v64 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::GetDOD(HgcYUV422BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 0);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::GetROI(HgcYUV422BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422BiPlanar_601ToRGB::HgcYUV422BiPlanar_601ToRGB(HgcYUV422BiPlanar_601ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653AAC8;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AB0;
  v3[4] = xmmword_1B3552AC0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422BiPlanar_601ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA2494(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_601ToRGB::~HgcYUV422BiPlanar_601ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653AAC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653AAC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653AAC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_601ToRGB::SetParameter(HgcYUV422BiPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::GetParameter(HgcYUV422BiPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422BiPlanar_709ToRGB::GetProgram(HgcYUV422BiPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1048caae:387a44ef:fc83ffd8:52b73979\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2408e641:b05fbd09:a6279793:e6b41496\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=50acfb20:dc59fe91:195acf38:f03e2245\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_709ToRGB::InitProgramDescriptor(HgcYUV422BiPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA2AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA2AF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA2AECLL);
}

char *HgcYUV422BiPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcYUV422BiPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::BindTexture(HgcYUV422BiPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::Bind(HgcYUV422BiPlanar_709ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV422BiPlanar_709ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::RenderTile(HgcYUV422BiPlanar_709ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v17;
  int v18;
  float32x4_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x2_t v25;
  __int32 v26;
  float32x4_t v27;
  int32x4_t v28;
  __int32 v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  __int32 v35;
  int8x16_t v36;
  float32x4_t v37;
  int32x4_t v38;
  __int32 v39;
  __int32 v40;
  __int32 v41;
  int8x16_t v42;
  float32x4_t v43;
  int32x4_t v44;
  __int32 v45;
  __int32 v46;
  __int32 v47;
  int8x16_t v48;
  int8x16_t v49;
  uint64_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t *v63;
  uint64_t v64;
  float32x4_t v65;
  int32x4_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    v8 = a2[2];
    v9 = a2[10];
    v10 = 16 * a2[11].i32[0];
    v11 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v64) = 0;
      v19 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v9 += v10;
      *(_QWORD *)&v8 += v11;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = 0uLL;
    v20 = 32;
    do
    {
      v21 = vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B3051880));
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B3051880);
      v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B3051880);
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = a2[12];
      v26 = a2[13].i32[0];
      v27 = vaddq_f32(vsubq_f32(v21, v5), v17);
      v28 = vcvtq_s32_f32(v27);
      v27.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
      v29 = v27.i32[1];
      v30 = v27.i32[0];
      v31 = vaddq_f32(vsubq_f32(v22, v5), v17);
      v32 = vcvtq_s32_f32(v31);
      v33 = v30 + v29 * v26;
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v34 = v31.i32[1];
      v35 = v31.i32[0];
      v36 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v33);
      v37 = vaddq_f32(vsubq_f32(v23, v5), v17);
      v38 = vcvtq_s32_f32(v37);
      v39 = v35 + v34 * v26;
      v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
      v40 = v37.i32[1];
      v41 = v37.i32[0];
      v42 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v39);
      v43 = vaddq_f32(vsubq_f32(v24, v5), v17);
      v44 = vcvtq_s32_f32(v43);
      v45 = v41 + v40 * v26;
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      v46 = v43.i32[1];
      v47 = v43.i32[0];
      v48 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v45);
      v49 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * (v47 + v46 * v26));
      v50 = *((_QWORD *)this + 51);
      v51 = *(int8x16_t *)(v50 + 32);
      v52 = *(float32x4_t *)(v50 + 48);
      v53 = *(float32x4_t *)(v50 + 16);
      v54 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 - 32), vextq_s8(v36, v36, 0xCuLL))));
      v55 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 - 16), vextq_s8(v42, v42, 0xCuLL))));
      v56 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20), vextq_s8(v48, v48, 0xCuLL))));
      v57 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 + 16), vextq_s8(v49, v49, 0xCuLL))));
      v19 = vaddq_f32(v19, _Q4);
      v58 = *(float32x4_t *)(v50 + 64);
      v59 = vaddq_f32(vmulq_laneq_f32(v58, v54, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v54.f32, 1)));
      v60 = vaddq_f32(vmulq_laneq_f32(v58, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v55.f32, 1)));
      v61 = vaddq_f32(vmulq_laneq_f32(v58, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v56.f32, 1)));
      v59.i32[3] = 1.0;
      v60.i32[3] = 1.0;
      v61.i32[3] = 1.0;
      v62 = vaddq_f32(vmulq_laneq_f32(v58, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v57.f32, 1)));
      v62.i32[3] = 1.0;
      v63 = (float32x4_t *)(*(_QWORD *)&v8 + v20);
      v63[-2] = v59;
      v63[-1] = v60;
      *v63 = v61;
      v63[1] = v62;
      v18 -= 4;
      v20 += 64;
    }
    while (v6 + v18 > 3);
    LODWORD(v64) = -v18;
    if ((int)v64 >= v6)
      goto LABEL_3;
LABEL_10:
    v64 = v64;
    do
    {
      v65 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B3051880)), v5), v17);
      v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      v67 = *((_QWORD *)this + 51);
      v68 = vaddq_f32(*(float32x4_t *)(v67 + 16), vmulq_f32(*(float32x4_t *)v67, (float32x4_t)vbslq_s8(*(int8x16_t *)(v67 + 32), *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v64), vextq_s8(*(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), 0xCuLL))));
      v69 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v67 + 64), v68, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v67 + 48), *(float32x2_t *)v68.f32, 1)));
      v69.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v64) = v69;
      __asm { FMOV            V16.4S, #1.0 }
      v19 = vaddq_f32(v19, _Q16);
      ++v64;
    }
    while (v64 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::GetDOD(HgcYUV422BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 0);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::GetROI(HgcYUV422BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422BiPlanar_709ToRGB::HgcYUV422BiPlanar_709ToRGB(HgcYUV422BiPlanar_709ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653AD30;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AF0;
  v3[4] = xmmword_1B3552B00;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422BiPlanar_709ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA3228(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_709ToRGB::~HgcYUV422BiPlanar_709ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653AD30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653AD30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653AD30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_709ToRGB::SetParameter(HgcYUV422BiPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::GetParameter(HgcYUV422BiPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422BiPlanar_2020ToRGB::GetProgram(HgcYUV422BiPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b2c3b8c:71d74731:f5cd4f36:083b9890\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=76c81ece:94c5249f:ae40b588:a20d303a\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=39ba3a76:86163c26:2e7e27c5:49379347\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV422BiPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e8\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA384C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA3888(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA3880);
}

char *HgcYUV422BiPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV422BiPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::BindTexture(HgcYUV422BiPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::Bind(HgcYUV422BiPlanar_2020ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV422BiPlanar_2020ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::RenderTile(HgcYUV422BiPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v17;
  int v18;
  float32x4_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x2_t v25;
  __int32 v26;
  float32x4_t v27;
  int32x4_t v28;
  __int32 v29;
  __int32 v30;
  float32x4_t v31;
  int32x4_t v32;
  __int32 v33;
  __int32 v34;
  __int32 v35;
  int8x16_t v36;
  float32x4_t v37;
  int32x4_t v38;
  __int32 v39;
  __int32 v40;
  __int32 v41;
  int8x16_t v42;
  float32x4_t v43;
  int32x4_t v44;
  __int32 v45;
  __int32 v46;
  __int32 v47;
  int8x16_t v48;
  int8x16_t v49;
  uint64_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t *v63;
  uint64_t v64;
  float32x4_t v65;
  int32x4_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B3552B60);
    v8 = a2[2];
    v9 = a2[10];
    v10 = 16 * a2[11].i32[0];
    v11 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v64) = 0;
      v19 = 0uLL;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v9 += v10;
      *(_QWORD *)&v8 += v11;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = 0uLL;
    v20 = 32;
    do
    {
      v21 = vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B3051880));
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B3051880);
      v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B3051880);
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = a2[12];
      v26 = a2[13].i32[0];
      v27 = vaddq_f32(vsubq_f32(v21, v5), v17);
      v28 = vcvtq_s32_f32(v27);
      v27.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
      v29 = v27.i32[1];
      v30 = v27.i32[0];
      v31 = vaddq_f32(vsubq_f32(v22, v5), v17);
      v32 = vcvtq_s32_f32(v31);
      v33 = v30 + v29 * v26;
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      v34 = v31.i32[1];
      v35 = v31.i32[0];
      v36 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v33);
      v37 = vaddq_f32(vsubq_f32(v23, v5), v17);
      v38 = vcvtq_s32_f32(v37);
      v39 = v35 + v34 * v26;
      v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
      v40 = v37.i32[1];
      v41 = v37.i32[0];
      v42 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v39);
      v43 = vaddq_f32(vsubq_f32(v24, v5), v17);
      v44 = vcvtq_s32_f32(v43);
      v45 = v41 + v40 * v26;
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      v46 = v43.i32[1];
      v47 = v43.i32[0];
      v48 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * v45);
      v49 = *(int8x16_t *)(*(_QWORD *)&v25 + 16 * (v47 + v46 * v26));
      v50 = *((_QWORD *)this + 51);
      v51 = *(int8x16_t *)(v50 + 32);
      v52 = *(float32x4_t *)(v50 + 48);
      v53 = *(float32x4_t *)(v50 + 16);
      v54 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 - 32), vextq_s8(v36, v36, 0xCuLL))));
      v55 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 - 16), vextq_s8(v42, v42, 0xCuLL))));
      v56 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20), vextq_s8(v48, v48, 0xCuLL))));
      v57 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(_QWORD *)&v9 + v20 + 16), vextq_s8(v49, v49, 0xCuLL))));
      v19 = vaddq_f32(v19, _Q4);
      v58 = *(float32x4_t *)(v50 + 64);
      v59 = vaddq_f32(vmulq_laneq_f32(v58, v54, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v54.f32, 1)));
      v60 = vaddq_f32(vmulq_laneq_f32(v58, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v55.f32, 1)));
      v61 = vaddq_f32(vmulq_laneq_f32(v58, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v56.f32, 1)));
      v59.i32[3] = 1.0;
      v60.i32[3] = 1.0;
      v61.i32[3] = 1.0;
      v62 = vaddq_f32(vmulq_laneq_f32(v58, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v57.f32, 1)));
      v62.i32[3] = 1.0;
      v63 = (float32x4_t *)(*(_QWORD *)&v8 + v20);
      v63[-2] = v59;
      v63[-1] = v60;
      *v63 = v61;
      v63[1] = v62;
      v18 -= 4;
      v20 += 64;
    }
    while (v6 + v18 > 3);
    LODWORD(v64) = -v18;
    if ((int)v64 >= v6)
      goto LABEL_3;
LABEL_10:
    v64 = v64;
    do
    {
      v65 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B3051880)), v5), v17);
      v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      v67 = *((_QWORD *)this + 51);
      v68 = vaddq_f32(*(float32x4_t *)(v67 + 16), vmulq_f32(*(float32x4_t *)v67, (float32x4_t)vbslq_s8(*(int8x16_t *)(v67 + 32), *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v64), vextq_s8(*(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), 0xCuLL))));
      v69 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v67 + 64), v68, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v67 + 48), *(float32x2_t *)v68.f32, 1)));
      v69.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v64) = v69;
      __asm { FMOV            V16.4S, #1.0 }
      v19 = vaddq_f32(v19, _Q16);
      ++v64;
    }
    while (v64 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::GetDOD(HgcYUV422BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 0);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::GetROI(HgcYUV422BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422BiPlanar_2020ToRGB::HgcYUV422BiPlanar_2020ToRGB(HgcYUV422BiPlanar_2020ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653AF98;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3058F00;
  v3[4] = xmmword_1B3058F10;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV422BiPlanar_2020ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA3FC0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_2020ToRGB::~HgcYUV422BiPlanar_2020ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653AF98;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653AF98;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653AF98;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::SetParameter(HgcYUV422BiPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::GetParameter(HgcYUV422BiPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_2020ToRGB::GetProgram(HgcYUV420BiPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b2c3b8c:71d74731:f5cd4f36:083b9890\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=76c81ece:94c5249f:ae40b588:a20d303a\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=39ba3a76:86163c26:2e7e27c5:49379347\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV420BiPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e8\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA45E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA4620(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA4618);
}

char *HgcYUV420BiPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV420BiPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::BindTexture(HgcYUV420BiPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::Bind(HgcYUV420BiPlanar_2020ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV420BiPlanar_2020ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::RenderTile(HgcYUV420BiPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v18;
  float32x4_t v19;
  int v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  __int32 v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  __int32 v35;
  __int32 v36;
  __int32 v37;
  int8x16_t v38;
  float32x4_t v39;
  int32x4_t v40;
  __int32 v41;
  __int32 v42;
  __int32 v43;
  int8x16_t v44;
  float32x4_t v45;
  int32x4_t v46;
  __int32 v47;
  __int32 v48;
  __int32 v49;
  int8x16_t v50;
  int8x16_t v51;
  uint64_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t *v65;
  uint64_t v66;
  float32x4_t v68;
  int32x4_t v69;
  uint64_t v70;
  float32x4_t v71;
  float32x4_t v72;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B30532D0);
    v8 = a2[2];
    v9 = a2[10];
    v10 = 16 * a2[11].i32[0];
    v11 = 16 * a2[3].i32[0];
    v12 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v19 = vaddq_f32(v7, vmulq_f32(v12, (float32x4_t)xmmword_1B30512C0));
      if (v6 >= 4)
        break;
      LODWORD(v66) = 0;
      v21 = 0uLL;
      __asm { FMOV            V18.4S, #1.0 }
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v12 = vaddq_f32(v12, _Q18);
      ++v4;
      *(_QWORD *)&v9 += v10;
      *(_QWORD *)&v8 += v11;
      if (v4 == v3)
        return 0;
    }
    v20 = 0;
    v21 = 0uLL;
    v22 = 32;
    do
    {
      v23 = vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[12];
      v28 = a2[13].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = v29.i32[1];
      v32 = v29.i32[0];
      v33 = vaddq_f32(vsubq_f32(v24, v5), v18);
      v34 = vcvtq_s32_f32(v33);
      v35 = v32 + v31 * v28;
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v36 = v33.i32[1];
      v37 = v33.i32[0];
      v38 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v35);
      v39 = vaddq_f32(vsubq_f32(v25, v5), v18);
      v40 = vcvtq_s32_f32(v39);
      v41 = v37 + v36 * v28;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      v42 = v39.i32[1];
      v43 = v39.i32[0];
      v44 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v41);
      v45 = vaddq_f32(vsubq_f32(v26, v5), v18);
      v46 = vcvtq_s32_f32(v45);
      v47 = v43 + v42 * v28;
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      v48 = v45.i32[1];
      v49 = v45.i32[0];
      v50 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v47);
      v51 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v49 + v48 * v28));
      v52 = *((_QWORD *)this + 51);
      v53 = *(int8x16_t *)(v52 + 32);
      v54 = *(float32x4_t *)(v52 + 48);
      v55 = *(float32x4_t *)(v52 + 16);
      v56 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 32), vextq_s8(v38, v38, 0xCuLL))));
      v57 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 16), vextq_s8(v44, v44, 0xCuLL))));
      v58 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22), vextq_s8(v50, v50, 0xCuLL))));
      v59 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 + 16), vextq_s8(v51, v51, 0xCuLL))));
      v21 = vaddq_f32(v21, _Q5);
      v60 = *(float32x4_t *)(v52 + 64);
      v61 = vaddq_f32(vmulq_laneq_f32(v60, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v56.f32, 1)));
      v62 = vaddq_f32(vmulq_laneq_f32(v60, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v57.f32, 1)));
      v63 = vaddq_f32(vmulq_laneq_f32(v60, v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v58.f32, 1)));
      v61.i32[3] = 1.0;
      v62.i32[3] = 1.0;
      v63.i32[3] = 1.0;
      v64 = vaddq_f32(vmulq_laneq_f32(v60, v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v59.f32, 1)));
      v64.i32[3] = 1.0;
      v65 = (float32x4_t *)(*(_QWORD *)&v8 + v22);
      v65[-2] = v61;
      v65[-1] = v62;
      *v65 = v63;
      v65[1] = v64;
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    __asm { FMOV            V18.4S, #1.0 }
    if ((int)v66 >= v6)
      goto LABEL_3;
LABEL_10:
    v66 = v66;
    do
    {
      v68 = vaddq_f32(vsubq_f32(vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v18);
      v69 = vcvtq_s32_f32(v68);
      v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
      v70 = *((_QWORD *)this + 51);
      v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v66), vextq_s8(*(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), 0xCuLL))));
      v72 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1)));
      v72.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v66) = v72;
      v21 = vaddq_f32(v21, _Q18);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::GetDOD(HgcYUV420BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::GetROI(HgcYUV420BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420BiPlanar_2020ToRGB::HgcYUV420BiPlanar_2020ToRGB(HgcYUV420BiPlanar_2020ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653B200;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3058F00;
  v3[4] = xmmword_1B3058F10;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420BiPlanar_2020ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA4D68(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_2020ToRGB::~HgcYUV420BiPlanar_2020ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653B200;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653B200;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653B200;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::SetParameter(HgcYUV420BiPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::GetParameter(HgcYUV420BiPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444BiPlanar_2020ToRGB::GetProgram(HgcYUV444BiPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b2c3b8c:71d74731:f5cd4f36:083b9890\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=76c81ece:94c5249f:ae40b588:a20d303a\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=39ba3a76:86163c26:2e7e27c5:49379347\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV444BiPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=000000027f\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA525C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA5290(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA5288);
}

char *HgcYUV444BiPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcYUV444BiPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::BindTexture(HgcYUV444BiPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::Bind(HgcYUV444BiPlanar_2020ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV444BiPlanar_2020ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::RenderTile(HgcYUV444BiPlanar_2020ToRGB *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  int8x16_t *v20;
  int8x16_t *v21;
  uint64_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t *v36;
  float32x4_t *v37;
  float32x4_t *v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  uint64_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t v53;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 12);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 22);
    v9 = *((int *)a2 + 26);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v45 = 0;
        v46 = 16 * v9;
        v47 = 16 * v8;
        v48 = 16 * v7;
        v49 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v50 = 0;
          do
          {
            v51 = *((_QWORD *)this + 51);
            v52 = vaddq_f32(*(float32x4_t *)(v51 + 16), vmulq_f32(*(float32x4_t *)v51, (float32x4_t)vbslq_s8(*(int8x16_t *)(v51 + 32), v5[v50 / 0x10], vextq_s8(v4[v50 / 0x10], v4[v50 / 0x10], 0xCuLL))));
            v53 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v51 + 64), v52, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v51 + 48), *(float32x2_t *)v52.f32, 1)));
            v53.i32[3] = 1.0;
            v6[v50 / 0x10] = v53;
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          v4 = (int8x16_t *)((char *)v4 + v46);
          v5 = (int8x16_t *)((char *)v5 + v47);
          v6 = (float32x4_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = *((_QWORD *)this + 51);
          v23 = *(int8x16_t *)(v22 + 32);
          v24 = *(float32x4_t *)(v22 + 48);
          v25 = *(float32x4_t *)(v22 + 16);
          v26 = v21;
          v27 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17], vextq_s8(v4[v17], v4[v17], 0xCuLL))));
          v28 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 1], vextq_s8(v4[v17 + 1], v4[v17 + 1], 0xCuLL))));
          v29 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 2], vextq_s8(v4[v17 + 2], v4[v17 + 2], 0xCuLL))));
          v30 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 3], vextq_s8(v4[v17 + 3], v4[v17 + 3], 0xCuLL))));
          v31 = *(float32x4_t *)(v22 + 64);
          v32 = vaddq_f32(vmulq_laneq_f32(v31, v27, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v27.f32, 1)));
          v33 = vaddq_f32(vmulq_laneq_f32(v31, v28, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v28.f32, 1)));
          v34 = vaddq_f32(vmulq_laneq_f32(v31, v29, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v29.f32, 1)));
          v32.i32[3] = 1.0;
          v33.i32[3] = 1.0;
          v35 = vaddq_f32(vmulq_laneq_f32(v31, v30, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v30.f32, 1)));
          v34.i32[3] = 1.0;
          v35.i32[3] = 1.0;
          v36 = v20;
          v37 = v19;
          v38 = &v6[v17];
          v18 += 4;
          v17 += 4;
          *v38 = v32;
          v38[1] = v33;
          v38[2] = v34;
          v38[3] = v35;
          v21 += 4;
          v20 = v36 + 4;
          v19 += 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v39 = *v26++;
            v40 = vextq_s8(v39, v39, 0xCuLL);
            v41 = *v36++;
            v42 = *((_QWORD *)this + 51);
            v43 = vaddq_f32(*(float32x4_t *)(v42 + 16), vmulq_f32(*(float32x4_t *)v42, (float32x4_t)vbslq_s8(*(int8x16_t *)(v42 + 32), v41, v40)));
            v44 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v42 + 64), v43, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v42 + 48), *(float32x2_t *)v43.f32, 1)));
            v44.i32[3] = 1.0;
            *v37++ = v44;
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (int8x16_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (int8x16_t *)((char *)v4 + v13);
        v14 = (int8x16_t *)((char *)v14 + v13);
        v15 = (int8x16_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::GetDOD(HgcYUV444BiPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::GetROI(HgcYUV444BiPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444BiPlanar_2020ToRGB::HgcYUV444BiPlanar_2020ToRGB(HgcYUV444BiPlanar_2020ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653B468;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3058F00;
  v3[4] = xmmword_1B3058F10;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA57BC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_2020ToRGB::~HgcYUV444BiPlanar_2020ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653B468;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653B468;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653B468;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::SetParameter(HgcYUV444BiPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::GetParameter(HgcYUV444BiPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HgcDither_CPU_NoClamp::RenderTile(HgcDither_CPU_NoClamp *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 26);
    v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v33 = 0;
        v34 = 16 * v9;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(v4[v38 / 0x10], vmulq_f32(v5[v38 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51)));
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          v4 = (float32x4_t *)((char *)v4 + v34);
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = *(float32x4_t *)*((_QWORD *)this + 51);
          v26 = vaddq_f32(v4[v17 + 1], vmulq_f32(v5[v17 + 1], v25));
          v27 = vaddq_f32(v4[v17 + 2], vmulq_f32(v5[v17 + 2], v25));
          v28 = vaddq_f32(v4[v17 + 3], vmulq_f32(v5[v17 + 3], v25));
          v29 = &v6[v17];
          *v29 = vaddq_f32(v4[v17], vmulq_f32(v5[v17], v25));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v30 = *v22++;
            v31 = v30;
            v32 = *v23++;
            *v24++ = vaddq_f32(v31, vmulq_f32(v32, *(float32x4_t *)*((_QWORD *)this + 51)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcDither_CPU_NoClamp::GetDOD(HgcDither_CPU_NoClamp *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcDither_CPU_NoClamp::GetROI(HgcDither_CPU_NoClamp *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcDither_CPU_NoClamp::HgcDither_CPU_NoClamp(HgcDither_CPU_NoClamp *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653B6D0;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3552DD0;
  *((_QWORD *)this + 51) = v3;
}

void sub_1B2BA5BC8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_CPU_NoClamp::~HgcDither_CPU_NoClamp(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653B6D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653B6D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcDither_CPU_NoClamp::SetParameter(HgcDither_CPU_NoClamp *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_CPU_NoClamp::GetParameter(HgcDither_CPU_NoClamp *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_CPU::RenderTile(HgcDither_CPU *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 26);
    v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v35 = 0;
        v36 = 16 * v9;
        v37 = 16 * v8;
        v38 = 16 * v7;
        v39 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v40 = 0;
          do
          {
            v6[v40 / 0x10] = vminq_f32(vmaxq_f32(vaddq_f32(v4[v40 / 0x10], vmulq_f32(v5[v40 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51))), *(float32x4_t *)(*((_QWORD *)this + 51) + 16)), *(float32x4_t *)(*((_QWORD *)this + 51) + 32));
            v40 += 16;
          }
          while (v39 != v40);
          ++v35;
          v4 = (float32x4_t *)((char *)v4 + v36);
          v5 = (float32x4_t *)((char *)v5 + v37);
          v6 = (float32x4_t *)((char *)v6 + v38);
        }
        while (v35 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = (float32x4_t *)*((_QWORD *)this + 51);
          v26 = v25[1];
          v27 = v25[2];
          v28 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17 + 1], vmulq_f32(v5[v17 + 1], *v25)), v26), v27);
          v29 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17 + 2], vmulq_f32(v5[v17 + 2], *v25)), v26), v27);
          v30 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17 + 3], vmulq_f32(v5[v17 + 3], *v25)), v26), v27);
          v31 = &v6[v17];
          *v31 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17], vmulq_f32(v5[v17], *v25)), v26), v27);
          v31[1] = v28;
          v18 += 4;
          v17 += 4;
          v31[2] = v29;
          v31[3] = v30;
          v21 += 4;
          v20 = v23 + 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v32 = *v22++;
            v33 = v32;
            v34 = *v23++;
            *v24++ = vminq_f32(vmaxq_f32(vaddq_f32(v33, vmulq_f32(v34, *(float32x4_t *)*((_QWORD *)this + 51))), *(float32x4_t *)(*((_QWORD *)this + 51) + 16)), *(float32x4_t *)(*((_QWORD *)this + 51) + 32));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcDither_CPU::GetDOD(HgcDither_CPU *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcDither_CPU::GetROI(HgcDither_CPU *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcDither_CPU::HgcDither_CPU(HgcDither_CPU *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653B938;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3552DD0;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 32) = _Q0;
  *((_QWORD *)this + 51) = v3;
}

void sub_1B2BA5F18(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_CPU::~HgcDither_CPU(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653B938;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653B938;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcDither_CPU::SetParameter(HgcDither_CPU *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_CPU::GetParameter(HgcDither_CPU *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcDither_GPU_NoClamp::GetProgram(HgcDither_GPU_NoClamp *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = hg_Params[1].xy;\n"
             "    s0.xy = frag._texCoord1.xy - s0.xy*floor(frag._texCoord1.xy/s0.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, s0.xy);\n"
             "    output.color0 = float4(r1)*float4(c0.xxxw) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fecfdea2:4af1a003:559b7893:a59f823d\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0002:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003c0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Params[1].xy;\n"
             "    r0.xy = frag._texCoord1.xy - r0.xy*floor(frag._texCoord1.xy/r0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
             "    output.color0 = r0*c0.xxxw + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6b1be8b7:ff006c96:12e0fa22:9998b3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000377\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = hg_ProgramLocal1.xy;\n"
           "    r0.xy = mod(hg_TexCoord1.xy, r0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture1, r0.xy);\n"
           "    gl_FragColor = r0*c0.xxxw + r1;\n"
           "}\n"
           "//MD5=93fb8dbc:091fea70:eb857dc2:db227491\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcDither_GPU_NoClamp::InitProgramDescriptor(HgcDither_GPU_NoClamp *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcDither_GPU_NoClamp_hgc_visible", "//Metal1.0     \n//LEN=0000000287\n[[ visible ]] FragmentOut HgcDither_GPU_NoClamp_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Params[1].xy;\n"
    "    r0.xy = texCoord1.xy - r0.xy*floor(texCoord1.xy/r0.xy);\n"
    "    r1 = color0;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
    "    output.color0 = r0*c0.xxxw + r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA6438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA6474(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA646CLL);
}

double HgcDither_GPU_NoClamp::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E10;
  strcpy(v3, "HgcDither_GPU_NoClamp [hgc1]");
  return *(double *)"U_NoClamp [hgc1]";
}

uint64_t HgcDither_GPU_NoClamp::BindTexture(HgcDither_GPU_NoClamp *this, HGHandler *a2, int a3)
{
  __n128 v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  int v8;
  uint64_t result;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
      {
        v6.n128_u32[0] = 1.0;
        v7.n128_u32[0] = 1.0;
      }
      else
      {
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      v4.n128_f32[0] = (float)*((int *)a2 + 60);
      v5.n128_f32[0] = (float)*((int *)a2 + 61);
      (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v4, v5, v6, v7);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v8 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v8)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcDither_GPU_NoClamp::Bind(HgcDither_GPU_NoClamp *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HgcDither_GPU_NoClamp *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcDither_GPU_NoClamp::GetDOD(HgcDither_GPU_NoClamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (!a3)
    return *(_QWORD *)&a4.var0;
  if (a3 == 1)
    return 0x8000000080000000;
  return 0;
}

uint64_t HgcDither_GPU_NoClamp::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
  {
    if (a3 == 1)
    {
      Input = HGRenderer::GetInput(a2, this, 1u);
      *(_QWORD *)&a4.var0 = HGRenderer::GetDOD(a2, Input);
    }
    else
    {
      *(_QWORD *)&a4.var0 = 0;
    }
  }
  return *(_QWORD *)&a4.var0;
}

void HgcDither_GPU_NoClamp::HgcDither_GPU_NoClamp(HgcDither_GPU_NoClamp *this)
{
  _QWORD *v2;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653BBA0;
  *((_QWORD *)this + 51) = operator new();
  (*(void (**)(HgcDither_GPU_NoClamp *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA67D4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_GPU_NoClamp::~HgcDither_GPU_NoClamp(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653BBA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653BBA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcDither_GPU_NoClamp::SetParameter(HgcDither_GPU_NoClamp *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_GPU_NoClamp::GetParameter(HgcDither_GPU_NoClamp *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcDither_GPU::GetProgram(HgcDither_GPU *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000040d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = hg_Params[1].xy;\n"
             "    s0.xy = frag._texCoord1.xy - s0.xy*floor(frag._texCoord1.xy/s0.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, s0.xy);\n"
             "    output.color0 = clamp(float4(r1)*float4(c0.xxxw) + float4(r0), 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=73956a5f:71c66c21:a7e6c42e:944d9b9b\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0002:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003db\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Params[1].xy;\n"
             "    r0.xy = frag._texCoord1.xy - r0.xy*floor(frag._texCoord1.xy/r0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
             "    output.color0 = clamp(r0*c0.xxxw + r1, 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b0267f22:5a359f19:1b29b0a6:fbd2585f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000039c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = hg_ProgramLocal1.xy;\n"
           "    r0.xy = mod(hg_TexCoord1.xy, r0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture1, r0.xy);\n"
           "    gl_FragColor = clamp(r0*c0.xxxw + r1, vec4(0.00000), vec4(1.00000));\n"
           "}\n"
           "//MD5=09402855:043f81c6:ab992516:1920d05e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcDither_GPU::InitProgramDescriptor(HgcDither_GPU *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcDither_GPU_hgc_visible", "//Metal1.0     \n//LEN=000000029a\n[[ visible ]] FragmentOut HgcDither_GPU_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Params[1].xy;\n"
    "    r0.xy = texCoord1.xy - r0.xy*floor(texCoord1.xy/r0.xy);\n"
    "    r1 = color0;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
    "    output.color0 = clamp(r0*c0.xxxw + r1, 0.00000f, 1.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA6CEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA6D28(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA6D20);
}

void HgcDither_GPU::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcDither_GPU [hgc1]");
}

uint64_t HgcDither_GPU::BindTexture(HgcDither_GPU *this, HGHandler *a2, int a3)
{
  __n128 v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  int v8;
  uint64_t result;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
      {
        v6.n128_u32[0] = 1.0;
        v7.n128_u32[0] = 1.0;
      }
      else
      {
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      v4.n128_f32[0] = (float)*((int *)a2 + 60);
      v5.n128_f32[0] = (float)*((int *)a2 + 61);
      (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v4, v5, v6, v7);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v8 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v8)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcDither_GPU::Bind(HgcDither_GPU *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HgcDither_GPU *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcDither_GPU::GetDOD(HgcDither_GPU *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (!a3)
    return *(_QWORD *)&a4.var0;
  if (a3 == 1)
    return 0x8000000080000000;
  return 0;
}

uint64_t HgcDither_GPU::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
  {
    if (a3 == 1)
    {
      Input = HGRenderer::GetInput(a2, this, 1u);
      *(_QWORD *)&a4.var0 = HGRenderer::GetDOD(a2, Input);
    }
    else
    {
      *(_QWORD *)&a4.var0 = 0;
    }
  }
  return *(_QWORD *)&a4.var0;
}

void HgcDither_GPU::HgcDither_GPU(HgcDither_GPU *this)
{
  _QWORD *v2;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653BE08;
  *((_QWORD *)this + 51) = operator new();
  (*(void (**)(HgcDither_GPU *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BA7064(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_GPU::~HgcDither_GPU(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653BE08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653BE08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcDither_GPU::SetParameter(HgcDither_GPU *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_GPU::GetParameter(HgcDither_GPU *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcGradientLinearTranslate::GetProgram(HgcGradientLinearTranslate *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.x);\n"
             "    s0.xy = s0.xy*hg_Params[6].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.xx));\n"
             "    s1.xy = hg_Params[6].xy - float2(c0.xx);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r1 = r0;\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    output.color0 = float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=46452133:57680ffc:173d5a39:c04c88c5\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000447\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.x;\n"
             "    r0.xy = r0.xy*hg_Params[6].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.xx);\n"
             "    r1.xy = hg_Params[6].xy - c0.xx;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=3e663d75:e0a55e8b:34c412a8:0286977f\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0007:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004a5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal5.x + hg_ProgramLocal5.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.x;\n"
           "    r0.xy = hg_ProgramLocal6.xy*c0.zz + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b8811881:1a7c8d4d:3ce9ee81:ce3624a3\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0007:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearTranslate::InitProgramDescriptor(HgcGradientLinearTranslate *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearTranslate_hgc_visible", "//Metal1.0     \n//LEN=000000038e\n[[ visible ]] FragmentOut HgcGradientLinearTranslate_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.x;\n"
    "    r0.xy = r0.xy*hg_Params[6].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.xx);\n"
    "    r1.xy = hg_Params[6].xy - c0.xx;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA74E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA751C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA7514);
}

char *HgcGradientLinearTranslate::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcGradientLinearTranslate [hgc1]");
  return result;
}

uint64_t HgcGradientLinearTranslate::BindTexture(HgcGradientLinearTranslate *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 6, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearTranslate::Bind(HgcGradientLinearTranslate *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HgcGradientLinearTranslate *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientLinearTranslate::RenderTile(HgcGradientLinearTranslate *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  int32x2_t v7;
  float32x4_t v8;
  float32x2_t v14;
  float32x2_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int32x2_t v64;
  uint64_t v65;
  int v66;
  float32x4_t *v67;
  uint64_t v68;
  float32x4_t *v69;
  float32x4_t v70;
  int32x2_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t *v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  uint64_t v82;
  uint64_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  int32x2_t v90;
  uint64_t v91;
  float32x4_t *v92;
  float32x4_t v93;
  float32x4_t v94;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = (int8x16_t *)(*(_QWORD *)&v7 + 32);
    v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v82) = 0;
      v20 = v8;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B304F240);
      ++v4;
      v16 = (int8x16_t *)((char *)v16 + v17);
      *(_QWORD *)&v7 += v17;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = v16;
    v20 = v8;
    do
    {
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F230);
      v24 = *((_QWORD *)this + 51);
      v26 = *(float32x4_t *)(v24 + 32);
      v25 = *(float32x4_t *)(v24 + 48);
      v27 = vmulq_f32(v20, v25);
      v28 = vmulq_f32(v21, v25);
      v29 = vmulq_f32(v22, v25);
      v30 = vmulq_f32(v23, v25);
      v31 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      v32 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 4uLL));
      v33 = (int8x16_t)vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 4uLL));
      v34 = (int8x16_t)vaddq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 4uLL));
      *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      v35 = *(float32x4_t *)(v24 + 64);
      v36 = *(float32x4_t *)(v24 + 80);
      v37 = vmulq_f32(v20, v35);
      v38 = vmulq_f32(v21, v35);
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
      v39 = vmulq_f32(v22, v35);
      v40 = vmulq_f32(v23, v35);
      *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      v41 = vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
      v42 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
      v43 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      v44 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      v45 = *(int8x16_t *)(v24 + 96);
      v46 = *(float32x4_t *)(v24 + 112);
      v47 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL)), v32);
      v48 = *(float32x4_t *)(v24 + 16);
      v49 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)), v31), *(float32x4_t *)v24));
      v50 = vmulq_f32(v48, vsubq_f32(v47, *(float32x4_t *)v24));
      v51 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)), v33), *(float32x4_t *)v24));
      v52 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v44, (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL)), v34), *(float32x4_t *)v24));
      v53 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), vaddq_f32(v49, (float32x4_t)vrev64q_s32((int32x4_t)v49))));
      v54 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), vaddq_f32(v50, (float32x4_t)vrev64q_s32((int32x4_t)v50))));
      v55 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL), vaddq_f32(v51, (float32x4_t)vrev64q_s32((int32x4_t)v51))));
      v56 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL), vaddq_f32(v52, (float32x4_t)vrev64q_s32((int32x4_t)v52))));
      v57 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
      v58 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v53)), v46);
      v59 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v54)), v46);
      v60 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v55)), v46);
      v61 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v56)), v46);
      v62 = *(float32x4_t *)(v24 + 128);
      v63 = *(int8x16_t *)(v24 + 144);
      v58.i32[0] = vminq_f32(v58, v62).u32[0];
      v59.i32[0] = vminq_f32(v59, v62).u32[0];
      v60.i32[0] = vminq_f32(v60, v62).u32[0];
      v61.i32[0] = vminq_f32(v61, v62).u32[0];
      v58.i32[1] = 0.5;
      v59.i32[1] = 0.5;
      v60.i32[1] = 0.5;
      v61.i32[1] = 0.5;
      v64 = a2[10];
      v65 = a2[11].i32[0];
      *(float32x2_t *)v58.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v58.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v62.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v58.f32, v15));
      v66 = v65 + 1;
      *(float32x2_t *)v59.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v59.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v33.i8 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v59.f32, v15));
      *(float32x2_t *)v58.f32 = vsub_f32(*(float32x2_t *)v58.f32, vcvt_f32_s32(*(int32x2_t *)v62.f32));
      *(float32x2_t *)v59.f32 = vsub_f32(*(float32x2_t *)v59.f32, vcvt_f32_s32(*(int32x2_t *)v33.i8));
      *(int32x2_t *)v44.f32 = vdup_n_s32(v65);
      *(int32x2_t *)v62.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), vzip2_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), *(int32x2_t *)v44.f32);
      v67 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v62.i32[0]);
      v65 *= 16;
      v68 = v66;
      v69 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v62.i32[1]);
      v70 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v58.f32[0]));
      *(float32x2_t *)v60.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v60.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v71 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v60.f32, v15));
      *(float32x2_t *)v60.f32 = vsub_f32(*(float32x2_t *)v60.f32, vcvt_f32_s32(v71));
      *(float32x2_t *)v61.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v61.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v72 = vaddq_f32(*v69, vmulq_n_f32(vsubq_f32(v69[1], *v69), v59.f32[0]));
      *(int32x2_t *)v46.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v61.f32, v15));
      *(float32x2_t *)v61.f32 = vsub_f32(*(float32x2_t *)v61.f32, vcvt_f32_s32(*(int32x2_t *)v46.f32));
      *(int32x2_t *)v46.f32 = vmla_s32(vzip1_s32(v71, *(int32x2_t *)v46.f32), vzip2_s32(v71, *(int32x2_t *)v46.f32), *(int32x2_t *)v44.f32);
      v73 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v67 + v65), vmulq_n_f32(vsubq_f32(v67[v68], *(float32x4_t *)((char *)v67 + v65)), v58.f32[0])), v70), *(float32x2_t *)v58.f32, 1);
      v74 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v46.i32[0]);
      v75 = vaddq_f32(v70, v73);
      v76 = vaddq_f32(*v74, vmulq_n_f32(vsubq_f32(v74[1], *v74), v60.f32[0]));
      v77 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v46.i32[1]);
      v78 = vaddq_f32(*v77, vmulq_n_f32(vsubq_f32(v77[1], *v77), v61.f32[0]));
      v79 = vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v69 + v65), vmulq_n_f32(vsubq_f32(v69[v68], *(float32x4_t *)((char *)v69 + v65)), v59.f32[0])), v72), *(float32x2_t *)v59.f32, 1));
      v80 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v74 + v65), vmulq_n_f32(vsubq_f32(v74[v68], *(float32x4_t *)((char *)v74 + v65)), v60.f32[0])), v76), *(float32x2_t *)v60.f32, 1));
      v81 = vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v77 + v65), vmulq_n_f32(vsubq_f32(v77[v68], *(float32x4_t *)((char *)v77 + v65)), v61.f32[0])), v78), *(float32x2_t *)v61.f32, 1));
      v19[-2] = vbslq_s8(v63, (int8x16_t)v75, (int8x16_t)vmulq_laneq_f32(v75, v75, 3));
      v19[-1] = vbslq_s8(v63, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      *v19 = vbslq_s8(v63, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v19[1] = vbslq_s8(v63, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v19 += 4;
      v20 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F230);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v82) = -v18;
    if ((int)v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = v82;
    do
    {
      v83 = *((_QWORD *)this + 51);
      v84 = vmulq_f32(v20, *(float32x4_t *)(v83 + 48));
      v85 = (int8x16_t)vaddq_f32(v84, (float32x4_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 4uLL));
      v86 = vmulq_f32(v20, *(float32x4_t *)(v83 + 64));
      v87 = vaddq_f32(v86, (float32x4_t)vextq_s8((int8x16_t)v86, (int8x16_t)v86, 4uLL));
      *(float32x2_t *)v85.i8 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
      v88 = vmulq_f32(*(float32x4_t *)(v83 + 16), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v83 + 96), (int8x16_t)vaddq_f32(v87, (float32x4_t)vextq_s8((int8x16_t)v87, (int8x16_t)v87, 8uLL)), v85), *(float32x4_t *)v83));
      v89 = *(int8x16_t *)(v83 + 144);
      v88.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v83 + 80)), vmulq_f32(*(float32x4_t *)(v83 + 80), vmulq_f32(*(float32x4_t *)(v83 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v88, (int8x16_t)v88, 8uLL), vaddq_f32(v88, (float32x4_t)vrev64q_s32((int32x4_t)v88)))))), *(float32x4_t *)(v83 + 112)), *(float32x4_t *)(v83 + 128)).u32[0];
      v88.i32[1] = 0.5;
      *(float32x2_t *)v88.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v88.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v90 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v88.f32, v15));
      v91 = a2[11].i32[0];
      *(float32x2_t *)v88.f32 = vsub_f32(*(float32x2_t *)v88.f32, vcvt_f32_s32(v90));
      v92 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v90.i32[0] + v90.i32[1] * (int)v91));
      v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v88.f32[0]));
      v94 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v91], vmulq_n_f32(vsubq_f32(v92[(int)v91 + 1], v92[v91]), v88.f32[0])), v93), *(float32x2_t *)v88.f32, 1));
      *(int8x16_t *)(*(_QWORD *)&v7 + 16 * v82) = vbslq_s8(v89, (int8x16_t)v94, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      ++v82;
    }
    while (v82 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearTranslate::GetDOD(HgcGradientLinearTranslate *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientLinearTranslate::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearTranslate::HgcGradientLinearTranslate(HgcGradientLinearTranslate *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653C070;
  v3 = operator new();
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050FF0;
  *(_QWORD *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 120) = 0;
  *(_OWORD *)(v3 + 128) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 144) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientLinearTranslate *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BA7DAC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearTranslate::~HgcGradientLinearTranslate(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653C070;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653C070;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearTranslate::SetParameter(HgcGradientLinearTranslate *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 5)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearTranslate::GetParameter(HgcGradientLinearTranslate *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 5)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientLinearAffine::GetProgram(HgcGradientLinearAffine *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.x);\n"
             "    s0.xy = s0.xy*hg_Params[6].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.xx));\n"
             "    s1.xy = hg_Params[6].xy - float2(c0.xx);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r1 = r0;\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    output.color0 = float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=46452133:57680ffc:173d5a39:c04c88c5\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000447\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.x;\n"
             "    r0.xy = r0.xy*hg_Params[6].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.xx);\n"
             "    r1.xy = hg_Params[6].xy - c0.xx;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=3e663d75:e0a55e8b:34c412a8:0286977f\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0007:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004a5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal5.x + hg_ProgramLocal5.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.x;\n"
           "    r0.xy = hg_ProgramLocal6.xy*c0.zz + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b8811881:1a7c8d4d:3ce9ee81:ce3624a3\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0007:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearAffine::InitProgramDescriptor(HgcGradientLinearAffine *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearAffine_hgc_visible", "//Metal1.0     \n//LEN=000000038b\n[[ visible ]] FragmentOut HgcGradientLinearAffine_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.x;\n"
    "    r0.xy = r0.xy*hg_Params[6].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.xx);\n"
    "    r1.xy = hg_Params[6].xy - c0.xx;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA82F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA8328(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA8320);
}

double HgcGradientLinearAffine::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E70;
  strcpy(v3, "HgcGradientLinearAffine [hgc1]");
  return *(double *)"earAffine [hgc1]";
}

uint64_t HgcGradientLinearAffine::BindTexture(HgcGradientLinearAffine *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 6, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearAffine::Bind(HgcGradientLinearAffine *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HgcGradientLinearAffine *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientLinearAffine::RenderTile(HgcGradientLinearAffine *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  int32x2_t v7;
  float32x4_t v8;
  float32x2_t v14;
  float32x2_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  int32x2_t v64;
  uint64_t v65;
  int v66;
  float32x4_t *v67;
  uint64_t v68;
  float32x4_t *v69;
  float32x4_t v70;
  int32x2_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t *v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  uint64_t v82;
  uint64_t v83;
  float32x4_t v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  int32x2_t v90;
  uint64_t v91;
  float32x4_t *v92;
  float32x4_t v93;
  float32x4_t v94;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = (int8x16_t *)(*(_QWORD *)&v7 + 32);
    v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v82) = 0;
      v20 = v8;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B304F240);
      ++v4;
      v16 = (int8x16_t *)((char *)v16 + v17);
      *(_QWORD *)&v7 += v17;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = v16;
    v20 = v8;
    do
    {
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F230);
      v24 = *((_QWORD *)this + 51);
      v26 = *(float32x4_t *)(v24 + 32);
      v25 = *(float32x4_t *)(v24 + 48);
      v27 = vmulq_f32(v20, v25);
      v28 = vmulq_f32(v21, v25);
      v29 = vmulq_f32(v22, v25);
      v30 = vmulq_f32(v23, v25);
      v31 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      v32 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 4uLL));
      v33 = (int8x16_t)vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 4uLL));
      v34 = (int8x16_t)vaddq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 4uLL));
      *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      v35 = *(float32x4_t *)(v24 + 64);
      v36 = *(float32x4_t *)(v24 + 80);
      v37 = vmulq_f32(v20, v35);
      v38 = vmulq_f32(v21, v35);
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
      v39 = vmulq_f32(v22, v35);
      v40 = vmulq_f32(v23, v35);
      *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      v41 = vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
      v42 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
      v43 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      v44 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      v45 = *(int8x16_t *)(v24 + 96);
      v46 = *(float32x4_t *)(v24 + 112);
      v47 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL)), v32);
      v48 = *(float32x4_t *)(v24 + 16);
      v49 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)), v31), *(float32x4_t *)v24));
      v50 = vmulq_f32(v48, vsubq_f32(v47, *(float32x4_t *)v24));
      v51 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)), v33), *(float32x4_t *)v24));
      v52 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v44, (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL)), v34), *(float32x4_t *)v24));
      v53 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), vaddq_f32(v49, (float32x4_t)vrev64q_s32((int32x4_t)v49))));
      v54 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), vaddq_f32(v50, (float32x4_t)vrev64q_s32((int32x4_t)v50))));
      v55 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL), vaddq_f32(v51, (float32x4_t)vrev64q_s32((int32x4_t)v51))));
      v56 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL), vaddq_f32(v52, (float32x4_t)vrev64q_s32((int32x4_t)v52))));
      v57 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
      v58 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v53)), v46);
      v59 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v54)), v46);
      v60 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v55)), v46);
      v61 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v56)), v46);
      v62 = *(float32x4_t *)(v24 + 128);
      v63 = *(int8x16_t *)(v24 + 144);
      v58.i32[0] = vminq_f32(v58, v62).u32[0];
      v59.i32[0] = vminq_f32(v59, v62).u32[0];
      v60.i32[0] = vminq_f32(v60, v62).u32[0];
      v61.i32[0] = vminq_f32(v61, v62).u32[0];
      v58.i32[1] = 0.5;
      v59.i32[1] = 0.5;
      v60.i32[1] = 0.5;
      v61.i32[1] = 0.5;
      v64 = a2[10];
      v65 = a2[11].i32[0];
      *(float32x2_t *)v58.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v58.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v62.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v58.f32, v15));
      v66 = v65 + 1;
      *(float32x2_t *)v59.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v59.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v33.i8 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v59.f32, v15));
      *(float32x2_t *)v58.f32 = vsub_f32(*(float32x2_t *)v58.f32, vcvt_f32_s32(*(int32x2_t *)v62.f32));
      *(float32x2_t *)v59.f32 = vsub_f32(*(float32x2_t *)v59.f32, vcvt_f32_s32(*(int32x2_t *)v33.i8));
      *(int32x2_t *)v44.f32 = vdup_n_s32(v65);
      *(int32x2_t *)v62.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), vzip2_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), *(int32x2_t *)v44.f32);
      v67 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v62.i32[0]);
      v65 *= 16;
      v68 = v66;
      v69 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v62.i32[1]);
      v70 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v58.f32[0]));
      *(float32x2_t *)v60.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v60.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v71 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v60.f32, v15));
      *(float32x2_t *)v60.f32 = vsub_f32(*(float32x2_t *)v60.f32, vcvt_f32_s32(v71));
      *(float32x2_t *)v61.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v61.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v72 = vaddq_f32(*v69, vmulq_n_f32(vsubq_f32(v69[1], *v69), v59.f32[0]));
      *(int32x2_t *)v46.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v61.f32, v15));
      *(float32x2_t *)v61.f32 = vsub_f32(*(float32x2_t *)v61.f32, vcvt_f32_s32(*(int32x2_t *)v46.f32));
      *(int32x2_t *)v46.f32 = vmla_s32(vzip1_s32(v71, *(int32x2_t *)v46.f32), vzip2_s32(v71, *(int32x2_t *)v46.f32), *(int32x2_t *)v44.f32);
      v73 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v67 + v65), vmulq_n_f32(vsubq_f32(v67[v68], *(float32x4_t *)((char *)v67 + v65)), v58.f32[0])), v70), *(float32x2_t *)v58.f32, 1);
      v74 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v46.i32[0]);
      v75 = vaddq_f32(v70, v73);
      v76 = vaddq_f32(*v74, vmulq_n_f32(vsubq_f32(v74[1], *v74), v60.f32[0]));
      v77 = (float32x4_t *)(*(_QWORD *)&v64 + 16 * v46.i32[1]);
      v78 = vaddq_f32(*v77, vmulq_n_f32(vsubq_f32(v77[1], *v77), v61.f32[0]));
      v79 = vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v69 + v65), vmulq_n_f32(vsubq_f32(v69[v68], *(float32x4_t *)((char *)v69 + v65)), v59.f32[0])), v72), *(float32x2_t *)v59.f32, 1));
      v80 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v74 + v65), vmulq_n_f32(vsubq_f32(v74[v68], *(float32x4_t *)((char *)v74 + v65)), v60.f32[0])), v76), *(float32x2_t *)v60.f32, 1));
      v81 = vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v77 + v65), vmulq_n_f32(vsubq_f32(v77[v68], *(float32x4_t *)((char *)v77 + v65)), v61.f32[0])), v78), *(float32x2_t *)v61.f32, 1));
      v19[-2] = vbslq_s8(v63, (int8x16_t)v75, (int8x16_t)vmulq_laneq_f32(v75, v75, 3));
      v19[-1] = vbslq_s8(v63, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      *v19 = vbslq_s8(v63, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v19[1] = vbslq_s8(v63, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v19 += 4;
      v20 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F230);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v82) = -v18;
    if ((int)v82 >= v5)
      goto LABEL_3;
LABEL_10:
    v82 = v82;
    do
    {
      v83 = *((_QWORD *)this + 51);
      v84 = vmulq_f32(v20, *(float32x4_t *)(v83 + 48));
      v85 = (int8x16_t)vaddq_f32(v84, (float32x4_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 4uLL));
      v86 = vmulq_f32(v20, *(float32x4_t *)(v83 + 64));
      v87 = vaddq_f32(v86, (float32x4_t)vextq_s8((int8x16_t)v86, (int8x16_t)v86, 4uLL));
      *(float32x2_t *)v85.i8 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
      v88 = vmulq_f32(*(float32x4_t *)(v83 + 16), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v83 + 96), (int8x16_t)vaddq_f32(v87, (float32x4_t)vextq_s8((int8x16_t)v87, (int8x16_t)v87, 8uLL)), v85), *(float32x4_t *)v83));
      v89 = *(int8x16_t *)(v83 + 144);
      v88.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v83 + 80)), vmulq_f32(*(float32x4_t *)(v83 + 80), vmulq_f32(*(float32x4_t *)(v83 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v88, (int8x16_t)v88, 8uLL), vaddq_f32(v88, (float32x4_t)vrev64q_s32((int32x4_t)v88)))))), *(float32x4_t *)(v83 + 112)), *(float32x4_t *)(v83 + 128)).u32[0];
      v88.i32[1] = 0.5;
      *(float32x2_t *)v88.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v88.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v90 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v88.f32, v15));
      v91 = a2[11].i32[0];
      *(float32x2_t *)v88.f32 = vsub_f32(*(float32x2_t *)v88.f32, vcvt_f32_s32(v90));
      v92 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v90.i32[0] + v90.i32[1] * (int)v91));
      v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v88.f32[0]));
      v94 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v91], vmulq_n_f32(vsubq_f32(v92[(int)v91 + 1], v92[v91]), v88.f32[0])), v93), *(float32x2_t *)v88.f32, 1));
      *(int8x16_t *)(*(_QWORD *)&v7 + 16 * v82) = vbslq_s8(v89, (int8x16_t)v94, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      ++v82;
    }
    while (v82 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearAffine::GetDOD(HgcGradientLinearAffine *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientLinearAffine::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearAffine::HgcGradientLinearAffine(HgcGradientLinearAffine *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653C2D8;
  v3 = operator new();
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050FF0;
  *(_QWORD *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 120) = 0;
  *(_OWORD *)(v3 + 128) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 144) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientLinearAffine *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BA8BBC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearAffine::~HgcGradientLinearAffine(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653C2D8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653C2D8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearAffine::SetParameter(HgcGradientLinearAffine *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 5)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearAffine::GetParameter(HgcGradientLinearAffine *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 5)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientLinearPerspective::GetProgram(HgcGradientLinearPerspective *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000504\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    r0.w = dot(half4(hg_Params[5]), half4(frag._texCoord0));\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[6].x + hg_Params[6].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.x);\n"
             "    s0.xy = s0.xy*hg_Params[7].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.xx));\n"
             "    s1.xy = hg_Params[7].xy - float2(c0.xx);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r1 = r0;\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    output.color0 = float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2e08a5bb:aa373144:fd65e842:17accea7\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0008:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000048f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.w = dot(hg_Params[5], frag._texCoord0);\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[6].x + hg_Params[6].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.x;\n"
             "    r0.xy = r0.xy*hg_Params[7].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.xx);\n"
             "    r1.xy = hg_Params[7].xy - c0.xx;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=55ccf5f9:4165b0cb:ef29e9dd:cc6692a4\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0008:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000513\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.w = dot(hg_ProgramLocal5, hg_TexCoord0);\n"
           "    r0.xy = r0.xy/r0.ww;\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal6.x + hg_ProgramLocal6.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.x;\n"
           "    r0.xy = hg_ProgramLocal7.xy*c0.zz + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c492827a:59585925:8987f7c8:7cfbe231\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0008:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearPerspective::InitProgramDescriptor(HgcGradientLinearPerspective *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearPerspective_hgc_visible", "//Metal1.0     \n//LEN=00000003d2\n[[ visible ]] FragmentOut HgcGradientLinearPerspective_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.w = dot(hg_Params[5], texCoord0);\n"
    "    r0.xy = r0.xy/r0.ww;\n"
    "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[6].x + hg_Params[6].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.x;\n"
    "    r0.xy = r0.xy*hg_Params[7].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.xx);\n"
    "    r1.xy = hg_Params[7].xy - c0.xx;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA9100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA9138(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA9130);
}

char *HgcGradientLinearPerspective::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcGradientLinearPerspective [hgc1]");
  return result;
}

uint64_t HgcGradientLinearPerspective::BindTexture(HgcGradientLinearPerspective *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 7, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearPerspective::Bind(HgcGradientLinearPerspective *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HgcGradientLinearPerspective *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientLinearPerspective::RenderTile(HgcGradientLinearPerspective *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  float32x4_t v7;
  int32x2_t v8;
  float32x2_t v14;
  float32x2_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int32x2_t v80;
  uint64_t v81;
  __int32 v82;
  float32x4_t *v83;
  uint64_t v84;
  float32x4_t v85;
  float32x4_t *v86;
  float32x4_t v87;
  float32x4_t *v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t *v93;
  uint64_t v94;
  float32x4_t v95;
  int8x16_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  int32x2_t v111;
  uint64_t v112;
  float32x4_t *v113;
  float32x4_t v114;
  float32x4_t v115;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v7.i64[1] = 0x3F80000000000000;
    v8 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = 16 * a2[3].i32[0];
    while (v5 < 3)
    {
      v17 = 0;
      v19 = v7;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v8 += v16;
      if (v4 == v3)
        return 0;
    }
    v17 = 0;
    v18 = v5;
    v19 = v7;
    do
    {
      v20 = vaddq_f32(v19, (float32x4_t)xmmword_1B304F230);
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = *((_QWORD *)this + 51);
      v24 = *(float32x4_t *)(v22 + 32);
      v23 = *(float32x4_t *)(v22 + 48);
      v25 = vmulq_f32(v19, v23);
      v26 = vmulq_f32(v20, v23);
      v27 = vmulq_f32(v21, v23);
      v28 = (int8x16_t)vaddq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL));
      v29 = (int8x16_t)vaddq_f32(v26, (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL));
      v30 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      *(float32x2_t *)v28.i8 = vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
      v31 = *(float32x4_t *)(v22 + 64);
      v32 = *(float32x4_t *)(v22 + 80);
      v33 = vmulq_f32(v19, v31);
      v34 = vmulq_f32(v20, v31);
      v35 = vmulq_f32(v21, v31);
      *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      v36 = vaddq_f32(v33, (float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL));
      v37 = vaddq_f32(v34, (float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 4uLL));
      *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v38 = vaddq_f32(v35, (float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 4uLL));
      v39 = (int8x16_t)vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL));
      v40 = vmulq_f32(v19, v32);
      v41 = vmulq_f32(v20, v32);
      v43 = *(float32x4_t *)(v22 + 96);
      v42 = *(int8x16_t *)(v22 + 112);
      v44 = vbslq_s8(v42, (int8x16_t)vaddq_f32(v36, (float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL)), v28);
      v45 = vmulq_f32(v21, v32);
      v46 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      v47 = vbslq_s8(v42, v39, v29);
      v48 = vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL));
      v49 = vaddq_f32(v45, (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 4uLL));
      v50 = vbslq_s8(v42, (int8x16_t)vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL)), v30);
      v51 = (int8x16_t)vaddq_f32(v46, (float32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 8uLL));
      v52 = *(int8x16_t *)(v22 + 128);
      v53 = *(float32x4_t *)(v22 + 144);
      v54 = (float32x4_t)vbslq_s8(v52, v51, v44);
      v55 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32(v48, (float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL)), v47);
      v56 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32(v49, (float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL)), v50);
      v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
      v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
      v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3);
      v61 = *(float32x4_t *)(v22 + 160);
      v60 = *(float32x4_t *)(v22 + 176);
      v62 = vminq_f32(vmaxq_f32(vrecpeq_f32(v57), v53), v61);
      v63 = vminq_f32(vmaxq_f32(vrecpeq_f32(v58), v53), v61);
      v64 = vminq_f32(vmaxq_f32(vrecpeq_f32(v59), v53), v61);
      v65 = vminq_f32(vmaxq_f32(vmulq_f32(v62, vrecpsq_f32(v57, v62)), v53), v61);
      v66 = vminq_f32(vmaxq_f32(vmulq_f32(v63, vrecpsq_f32(v58, v63)), v53), v61);
      v67 = vminq_f32(vmaxq_f32(vmulq_f32(v64, vrecpsq_f32(v59, v64)), v53), v61);
      v57.i64[0] = vmulq_f32(vmulq_f32(v65, vrecpsq_f32(v57, v65)), v54).u64[0];
      v58.i64[0] = vmulq_f32(vmulq_f32(v66, vrecpsq_f32(v58, v66)), v55).u64[0];
      v59.i64[0] = vmulq_f32(vmulq_f32(v67, vrecpsq_f32(v59, v67)), v56).u64[0];
      v57.i64[1] = v54.i64[1];
      v58.i64[1] = v55.i64[1];
      v59.i64[1] = v56.i64[1];
      v68 = *(float32x4_t *)(v22 + 16);
      v69 = vmulq_f32(v68, vsubq_f32(v57, *(float32x4_t *)v22));
      v70 = vmulq_f32(v68, vsubq_f32(v58, *(float32x4_t *)v22));
      v71 = vmulq_f32(v68, vsubq_f32(v59, *(float32x4_t *)v22));
      v72 = vmulq_f32(v24, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v69, (int8x16_t)v69, 8uLL), vaddq_f32(v69, (float32x4_t)vrev64q_s32((int32x4_t)v69))));
      v73 = vmulq_f32(v24, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v70, (int8x16_t)v70, 8uLL), vaddq_f32(v70, (float32x4_t)vrev64q_s32((int32x4_t)v70))));
      v74 = vmulq_f32(v24, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v71, (int8x16_t)v71, 8uLL), vaddq_f32(v71, (float32x4_t)vrev64q_s32((int32x4_t)v71))));
      v75 = (float32x4_t)vrev64q_s32((int32x4_t)v43);
      v76 = vaddq_f32(v75, vmulq_f32(v43, v74));
      v77 = vmaxq_f32(vaddq_f32(v75, vmulq_f32(v43, v72)), v60);
      v78 = vmaxq_f32(vaddq_f32(v75, vmulq_f32(v43, v73)), v60);
      v79 = *(float32x4_t *)(v22 + 192);
      v77.i32[0] = vminq_f32(v77, v79).u32[0];
      v78.i32[0] = vminq_f32(v78, v79).u32[0];
      v77.i32[1] = 0.5;
      v76.i32[0] = vminq_f32(vmaxq_f32(v76, v60), v79).u32[0];
      v78.i32[1] = 0.5;
      v76.i32[1] = 0.5;
      v80 = a2[10];
      v81 = a2[11].i32[0];
      *(float32x2_t *)v77.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v77.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v79.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v77.f32, v15));
      *(float32x2_t *)v78.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v78.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v58.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v78.f32, v15));
      *(float32x2_t *)v77.f32 = vsub_f32(*(float32x2_t *)v77.f32, vcvt_f32_s32(*(int32x2_t *)v79.f32));
      *(int32x2_t *)v79.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v79.f32, *(int32x2_t *)v58.f32), vzip2_s32(*(int32x2_t *)v79.f32, *(int32x2_t *)v58.f32), vdup_n_s32(v81));
      v82 = v79.i32[1];
      *(float32x2_t *)v78.f32 = vsub_f32(*(float32x2_t *)v78.f32, vcvt_f32_s32(*(int32x2_t *)v58.f32));
      v83 = (float32x4_t *)(*(_QWORD *)&v80 + 16 * v79.i32[0]);
      v84 = (int)v81 + 1;
      v85 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v77.f32[0]));
      v86 = (float32x4_t *)(*(_QWORD *)&v80 + 16 * v82);
      v87 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v78.f32[0]));
      *(float32x2_t *)v76.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v76.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v70.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v76.f32, v15));
      *(float32x2_t *)v76.f32 = vsub_f32(*(float32x2_t *)v76.f32, vcvt_f32_s32(*(int32x2_t *)v70.f32));
      v88 = (float32x4_t *)(*(_QWORD *)&v80 + 16 * (v70.i32[0] + v70.i32[1] * (int)v81));
      v89 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(v83[v81], vmulq_n_f32(vsubq_f32(v83[v84], v83[v81]), v77.f32[0])), v85), *(float32x2_t *)v77.f32, 1));
      v90 = vaddq_f32(*v88, vmulq_n_f32(vsubq_f32(v88[1], *v88), v76.f32[0]));
      v91 = vaddq_f32(v87, vmulq_lane_f32(vsubq_f32(vaddq_f32(v86[v81], vmulq_n_f32(vsubq_f32(v86[v84], v86[v81]), v78.f32[0])), v87), *(float32x2_t *)v78.f32, 1));
      v92 = vaddq_f32(v90, vmulq_lane_f32(vsubq_f32(vaddq_f32(v88[v81], vmulq_n_f32(vsubq_f32(v88[v84], v88[v81]), v76.f32[0])), v90), *(float32x2_t *)v76.f32, 1));
      v93 = (int8x16_t *)(*(_QWORD *)&v8 + 16 * v17);
      *v93 = vbslq_s8(v52, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      v93[1] = vbslq_s8(v52, (int8x16_t)v91, (int8x16_t)vmulq_laneq_f32(v91, v91, 3));
      v93[2] = vbslq_s8(v52, (int8x16_t)v92, (int8x16_t)vmulq_laneq_f32(v92, v92, 3));
      v19 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v17 += 3;
      v18 -= 3;
    }
    while (v18 > 2);
    v17 = v17;
    if ((int)v17 >= v5)
      goto LABEL_3;
    do
    {
LABEL_10:
      v94 = *((_QWORD *)this + 51);
      v95 = vmulq_f32(v19, *(float32x4_t *)(v94 + 48));
      v96 = (int8x16_t)vaddq_f32(v95, (float32x4_t)vextq_s8((int8x16_t)v95, (int8x16_t)v95, 4uLL));
      v97 = vmulq_f32(v19, *(float32x4_t *)(v94 + 64));
      v98 = vaddq_f32(v97, (float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 4uLL));
      *(float32x2_t *)v96.i8 = vadd_f32(*(float32x2_t *)v96.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v96, v96, 8uLL));
      v99 = (int8x16_t)vaddq_f32(v98, (float32x4_t)vextq_s8((int8x16_t)v98, (int8x16_t)v98, 8uLL));
      v100 = vmulq_f32(v19, *(float32x4_t *)(v94 + 80));
      v101 = vbslq_s8(*(int8x16_t *)(v94 + 112), v99, v96);
      v102 = vaddq_f32(v100, (float32x4_t)vextq_s8((int8x16_t)v100, (int8x16_t)v100, 4uLL));
      v103 = *(int8x16_t *)(v94 + 128);
      v104 = *(float32x4_t *)(v94 + 144);
      v105 = (float32x4_t)vbslq_s8(v103, (int8x16_t)vaddq_f32(v102, (float32x4_t)vextq_s8((int8x16_t)v102, (int8x16_t)v102, 8uLL)), v101);
      v106 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3);
      v107 = *(float32x4_t *)(v94 + 160);
      v108 = vminq_f32(vmaxq_f32(vrecpeq_f32(v106), v104), v107);
      v109 = vminq_f32(vmaxq_f32(vmulq_f32(v108, vrecpsq_f32(v106, v108)), v104), v107);
      v106.i64[0] = vmulq_f32(vmulq_f32(v109, vrecpsq_f32(v106, v109)), v105).u64[0];
      v106.i64[1] = v105.i64[1];
      v110 = vmulq_f32(*(float32x4_t *)(v94 + 16), vsubq_f32(v106, *(float32x4_t *)v94));
      v110.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v94 + 96)), vmulq_f32(*(float32x4_t *)(v94 + 96), vmulq_f32(*(float32x4_t *)(v94 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v110, (int8x16_t)v110, 8uLL), vaddq_f32(v110, (float32x4_t)vrev64q_s32((int32x4_t)v110)))))), *(float32x4_t *)(v94 + 176)), *(float32x4_t *)(v94 + 192)).u32[0];
      v110.i32[1] = 0.5;
      *(float32x2_t *)v110.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v110.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v111 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v110.f32, v15));
      v112 = a2[11].i32[0];
      *(float32x2_t *)v110.f32 = vsub_f32(*(float32x2_t *)v110.f32, vcvt_f32_s32(v111));
      v113 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v111.i32[0] + v111.i32[1] * (int)v112));
      v114 = vaddq_f32(*v113, vmulq_n_f32(vsubq_f32(v113[1], *v113), v110.f32[0]));
      v115 = vaddq_f32(v114, vmulq_lane_f32(vsubq_f32(vaddq_f32(v113[v112], vmulq_n_f32(vsubq_f32(v113[(int)v112 + 1], v113[v112]), v110.f32[0])), v114), *(float32x2_t *)v110.f32, 1));
      *(int8x16_t *)(*(_QWORD *)&v8 + 16 * v17) = vbslq_s8(v103, (int8x16_t)v115, (int8x16_t)vmulq_laneq_f32(v115, v115, 3));
      v19 = vaddq_f32(v19, (float32x4_t)xmmword_1B304F230);
      ++v17;
    }
    while (v17 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearPerspective::GetDOD(HgcGradientLinearPerspective *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientLinearPerspective::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearPerspective::HgcGradientLinearPerspective(HgcGradientLinearPerspective *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653C540;
  v3 = operator new();
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 128) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 144) = xmmword_1B30527A0;
  *(int32x4_t *)(v3 + 160) = vdupq_n_s32(0x7F7FFFFFu);
  *(_QWORD *)(v3 + 176) = 0;
  *(_QWORD *)(v3 + 184) = 0;
  *(_OWORD *)(v3 + 192) = xmmword_1B304F230;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientLinearPerspective *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BA9A7C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearPerspective::~HgcGradientLinearPerspective(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653C540;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F93440CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653C540;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F93440CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearPerspective::SetParameter(HgcGradientLinearPerspective *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearPerspective::GetParameter(HgcGradientLinearPerspective *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientLinearIdentity::GetProgram(HgcGradientLinearIdentity *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000417\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xyz = frag._texCoord0.xyz - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[3].x + hg_Params[3].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.y);\n"
             "    s0.xy = s0.xy*hg_Params[4].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.yy));\n"
             "    s1.xy = hg_Params[4].xy - float2(c0.yy);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=90469e23:e8a58590:544d7d30:1a3cbdd3\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = frag._texCoord0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[3].x + hg_Params[3].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.y;\n"
             "    r0.xy = r0.xy*hg_Params[4].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.yy);\n"
             "    r1.xy = hg_Params[4].xy - c0.yy;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f0cefc8b:5dc30f52:2b0338bb:b15223e3\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0005:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xyz = hg_TexCoord0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal3.x + hg_ProgramLocal3.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.y;\n"
           "    r0.xy = hg_ProgramLocal4.xy*c0.xx + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=25a463cb:436ff83f:4101e589:fcdc7897\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0005:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearIdentity::InitProgramDescriptor(HgcGradientLinearIdentity *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearIdentity_hgc_visible", "//Metal1.0     \n//LEN=0000000331\n[[ visible ]] FragmentOut HgcGradientLinearIdentity_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = texCoord0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[3].x + hg_Params[3].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.y;\n"
    "    r0.xy = r0.xy*hg_Params[4].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.yy);\n"
    "    r1.xy = hg_Params[4].xy - c0.yy;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BA9FC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BA9FF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BA9FF0);
}

char *HgcGradientLinearIdentity::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552EC0;
  strcpy(result, "HgcGradientLinearIdentity [hgc1]");
  return result;
}

uint64_t HgcGradientLinearIdentity::BindTexture(HgcGradientLinearIdentity *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 4, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearIdentity::Bind(HgcGradientLinearIdentity *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcGradientLinearIdentity *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientLinearIdentity::RenderTile(HgcGradientLinearIdentity *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  int32x2_t v7;
  float32x4_t v8;
  float32x2_t v14;
  float32x2_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x2_t v46;
  uint64_t v47;
  int v48;
  float32x2_t v49;
  int32x2_t v50;
  float32x4_t *v51;
  uint64_t v52;
  float32x4_t *v53;
  float32x4_t v54;
  int32x2_t v55;
  int32x2_t v56;
  int32x2_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t *v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t *v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  uint64_t v70;
  uint64_t v71;
  float32x4_t v72;
  uint64_t v73;
  int32x2_t v74;
  float32x4_t *v75;
  float32x4_t v76;
  float32x4_t v77;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = (int8x16_t *)(*(_QWORD *)&v7 + 32);
    v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v70) = 0;
      v20 = v8;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B304F240);
      ++v4;
      v16 = (int8x16_t *)((char *)v16 + v17);
      *(_QWORD *)&v7 += v17;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = v16;
    v20 = v8;
    do
    {
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v23 = *((_QWORD *)this + 51);
      v24 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F230);
      v25 = *(float32x4_t *)(v23 + 16);
      v26 = vmulq_f32(v25, vsubq_f32(v20, *(float32x4_t *)v23));
      v27 = vmulq_f32(v25, vsubq_f32(v21, *(float32x4_t *)v23));
      v28 = vmulq_f32(v25, vsubq_f32(v22, *(float32x4_t *)v23));
      v29 = vmulq_f32(v25, vsubq_f32(v24, *(float32x4_t *)v23));
      v30 = *(float32x4_t *)(v23 + 32);
      v31 = *(float32x4_t *)(v23 + 48);
      v32 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL), vaddq_f32(v26, (float32x4_t)vrev64q_s32((int32x4_t)v26))));
      v33 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL), vaddq_f32(v27, (float32x4_t)vrev64q_s32((int32x4_t)v27))));
      v34 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL), vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28))));
      v35 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), vaddq_f32(v29, (float32x4_t)vrev64q_s32((int32x4_t)v29))));
      v36 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
      v37 = vaddq_f32(v36, vmulq_f32(v31, v32));
      v38 = vaddq_f32(v36, vmulq_f32(v31, v33));
      v39 = vaddq_f32(v36, vmulq_f32(v31, v34));
      v40 = vaddq_f32(v36, vmulq_f32(v31, v35));
      v42 = *(float32x4_t *)(v23 + 64);
      v41 = *(float32x4_t *)(v23 + 80);
      v43 = vmaxq_f32(v38, v42);
      v44 = vmaxq_f32(v39, v42);
      v45 = vmaxq_f32(v40, v42);
      v42.i32[0] = vminq_f32(vmaxq_f32(v37, v42), v41).u32[0];
      v43.i32[0] = vminq_f32(v43, v41).u32[0];
      v44.i32[0] = vminq_f32(v44, v41).u32[0];
      v42.i32[1] = 0.5;
      v43.i32[1] = 0.5;
      v37.i32[0] = vminq_f32(v45, v41).u32[0];
      v44.i32[1] = 0.5;
      v37.i32[1] = 0.5;
      v46 = a2[10];
      v47 = a2[11].i32[0];
      *(float32x2_t *)v45.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v42.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v41.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v45.f32, v15));
      v48 = v47 + 1;
      v49 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v43.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v50 = vcvt_s32_f32(vmin_f32(v49, v15));
      *(float32x2_t *)v43.f32 = vsub_f32(*(float32x2_t *)v45.f32, vcvt_f32_s32(*(int32x2_t *)v41.f32));
      *(int32x2_t *)v45.f32 = vdup_n_s32(v47);
      *(int32x2_t *)v41.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v41.f32, v50), vzip2_s32(*(int32x2_t *)v41.f32, v50), *(int32x2_t *)v45.f32);
      *(float32x2_t *)v42.f32 = vsub_f32(v49, vcvt_f32_s32(v50));
      v51 = (float32x4_t *)(*(_QWORD *)&v46 + 16 * v41.i32[0]);
      v47 *= 16;
      v52 = v48;
      v53 = (float32x4_t *)(*(_QWORD *)&v46 + 16 * v41.i32[1]);
      *(float32x2_t *)v44.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v44.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v54 = vaddq_f32(*v51, vmulq_n_f32(vsubq_f32(v51[1], *v51), v43.f32[0]));
      v55 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v44.f32, v15));
      *(float32x2_t *)v37.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v37.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v56 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v37.f32, v15));
      v57 = vmla_s32(vzip1_s32(v55, v56), vzip2_s32(v55, v56), *(int32x2_t *)v45.f32);
      v58 = vaddq_f32(*v53, vmulq_n_f32(vsubq_f32(v53[1], *v53), v42.f32[0]));
      *(float32x2_t *)v44.f32 = vsub_f32(*(float32x2_t *)v44.f32, vcvt_f32_s32(v55));
      *(float32x2_t *)v37.f32 = vsub_f32(*(float32x2_t *)v37.f32, vcvt_f32_s32(v56));
      v59 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v51 + v47), vmulq_n_f32(vsubq_f32(v51[v52], *(float32x4_t *)((char *)v51 + v47)), v43.f32[0])), v54), *(float32x2_t *)v43.f32, 1);
      v60 = (float32x4_t *)(*(_QWORD *)&v46 + 16 * v57.i32[0]);
      v61 = vaddq_f32(v54, v59);
      v62 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v53 + v47), vmulq_n_f32(vsubq_f32(v53[v52], *(float32x4_t *)((char *)v53 + v47)), v42.f32[0])), v58), *(float32x2_t *)v42.f32, 1);
      v63 = vaddq_f32(*v60, vmulq_n_f32(vsubq_f32(v60[1], *v60), v44.f32[0]));
      v64 = (float32x4_t *)(*(_QWORD *)&v46 + 16 * v57.i32[1]);
      v65 = vaddq_f32(v58, v62);
      v66 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v37.f32[0]));
      v67 = vaddq_f32(v63, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v60 + v47), vmulq_n_f32(vsubq_f32(v60[v52], *(float32x4_t *)((char *)v60 + v47)), v44.f32[0])), v63), *(float32x2_t *)v44.f32, 1));
      v68 = vaddq_f32(v66, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v64 + v47), vmulq_n_f32(vsubq_f32(v64[v52], *(float32x4_t *)((char *)v64 + v47)), v37.f32[0])), v66), *(float32x2_t *)v37.f32, 1));
      v69 = *(int8x16_t *)(v23 + 96);
      v19[-2] = vbslq_s8(v69, (int8x16_t)v61, (int8x16_t)vmulq_laneq_f32(v61, v61, 3));
      v19[-1] = vbslq_s8(v69, (int8x16_t)v65, (int8x16_t)vmulq_laneq_f32(v65, v65, 3));
      *v19 = vbslq_s8(v69, (int8x16_t)v67, (int8x16_t)vmulq_laneq_f32(v67, v67, 3));
      v19[1] = vbslq_s8(v69, (int8x16_t)v68, (int8x16_t)vmulq_laneq_f32(v68, v68, 3));
      v19 += 4;
      v20 = vaddq_f32(v24, (float32x4_t)xmmword_1B304F230);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v70) = -v18;
    if ((int)v70 >= v5)
      goto LABEL_3;
LABEL_10:
    v70 = v70;
    do
    {
      v71 = *((_QWORD *)this + 51);
      v72 = vmulq_f32(*(float32x4_t *)(v71 + 16), vsubq_f32(v20, *(float32x4_t *)v71));
      v72.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v71 + 48)), vmulq_f32(*(float32x4_t *)(v71 + 48), vmulq_f32(*(float32x4_t *)(v71 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 8uLL), vaddq_f32(v72, (float32x4_t)vrev64q_s32((int32x4_t)v72)))))), *(float32x4_t *)(v71 + 64)), *(float32x4_t *)(v71 + 80)).u32[0];
      v72.i32[1] = 0.5;
      v73 = a2[11].i32[0];
      *(float32x2_t *)v72.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v72.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      v74 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v72.f32, v15));
      *(float32x2_t *)v72.f32 = vsub_f32(*(float32x2_t *)v72.f32, vcvt_f32_s32(v74));
      v75 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v74.i32[0] + v74.i32[1] * (int)v73));
      v76 = vaddq_f32(*v75, vmulq_n_f32(vsubq_f32(v75[1], *v75), v72.f32[0]));
      v77 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(v75[v73], vmulq_n_f32(vsubq_f32(v75[(int)v73 + 1], v75[v73]), v72.f32[0])), v76), *(float32x2_t *)v72.f32, 1));
      *(int8x16_t *)(*(_QWORD *)&v7 + 16 * v70) = vbslq_s8(*(int8x16_t *)(v71 + 96), (int8x16_t)v77, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      ++v70;
    }
    while (v70 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearIdentity::GetDOD(HgcGradientLinearIdentity *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientLinearIdentity::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearIdentity::HgcGradientLinearIdentity(HgcGradientLinearIdentity *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653C7A8;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[4] = 0u;
  v3[5] = xmmword_1B304F230;
  v3[6] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientLinearIdentity *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BAA750(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearIdentity::~HgcGradientLinearIdentity(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653C7A8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653C7A8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearIdentity::SetParameter(HgcGradientLinearIdentity *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearIdentity::GetParameter(HgcGradientLinearIdentity *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialAffine::GetProgram(HgcGradientRadialAffine *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000579\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[5].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[5].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=686d5007:b53467b8:2344a822:939db735\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0006:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000501\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[5].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[5].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d5e6b64b:323bc96d:e3898f43:70f17049\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal5.xy*c0.zz + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.y;\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=c9df8185:4b2e9f5c:f34b2e0b:0cf74b2f\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialAffine::InitProgramDescriptor(HgcGradientRadialAffine *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialAffine_hgc_visible", "//Metal1.0     \n//LEN=0000000445\n[[ visible ]] FragmentOut HgcGradientRadialAffine_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[5].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[5].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BAAC94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BAACCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BAACC4);
}

double HgcGradientRadialAffine::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E70;
  strcpy(v3, "HgcGradientRadialAffine [hgc1]");
  return *(double *)"ialAffine [hgc1]";
}

uint64_t HgcGradientRadialAffine::BindTexture(HgcGradientRadialAffine *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 5, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialAffine::Bind(HgcGradientRadialAffine *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcGradientRadialAffine *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientRadialAffine::RenderTile(HgcGradientRadialAffine *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  float32x4_t v7;
  int32x2_t v8;
  float32x2_t v14;
  float32x2_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int32x2_t v76;
  float32x4_t v77;
  uint64_t v78;
  float32x4_t v79;
  int8x16_t v80;
  int v81;
  int32x2_t v82;
  float32x4_t *v83;
  uint64_t v84;
  float32x4_t *v85;
  float32x2_t v86;
  int32x2_t v87;
  float32x4_t v88;
  float32x2_t v89;
  int32x2_t v90;
  int32x2_t v91;
  float32x4_t v92;
  float32x2_t v93;
  float32x4_t v94;
  float32x2_t v95;
  float32x4_t *v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t *v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  int8x16_t v110;
  int8x16_t v111;
  int8x16_t v112;
  int8x16_t v113;
  uint64_t v114;
  uint64_t v115;
  float32x4_t v116;
  float32x4_t v117;
  int8x16_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  uint64_t v130;
  int32x2_t v131;
  float32x4_t *v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v7.i64[1] = 0x3F80000000000000;
    v8 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = (int8x16_t *)(*(_QWORD *)&v8 + 32);
    v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v114) = 0;
      v20 = v7;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      ++v4;
      v16 = (int8x16_t *)((char *)v16 + v17);
      *(_QWORD *)&v8 += v17;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = v16;
    v20 = v7;
    do
    {
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v23 = *((_QWORD *)this + 51);
      v24 = *(float32x4_t *)(v23 + 32);
      v25 = *(float32x4_t *)(v23 + 48);
      v26 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F230);
      v27 = vmulq_f32(v20, v25);
      v28 = vmulq_f32(v21, v25);
      v29 = vmulq_f32(v22, v25);
      v30 = vmulq_f32(v26, v25);
      v31 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      v32 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 4uLL));
      v33 = (int8x16_t)vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 4uLL));
      v34 = (int8x16_t)vaddq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 4uLL));
      *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
      v36 = *(float32x4_t *)(v23 + 64);
      v35 = *(int8x16_t *)(v23 + 80);
      v37 = vmulq_f32(v20, v36);
      v38 = vmulq_f32(v21, v36);
      v39 = vmulq_f32(v22, v36);
      v40 = vmulq_f32(v26, v36);
      *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      v41 = vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
      v42 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
      v43 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      v44 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      v45 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)), v31);
      v46 = *(float32x4_t *)(v23 + 16);
      v47 = vsubq_f32(v45, v46);
      v48 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL)), v32), v46);
      v49 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)), v33), v46);
      v50 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v44, (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL)), v34), v46);
      v51 = *(int8x16_t *)(v23 + 96);
      v52 = *(float32x4_t *)(v23 + 112);
      v53 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v47), (int8x16_t)v47);
      v54 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v48), (int8x16_t)v48);
      v55 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v49), (int8x16_t)v49);
      v56 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v50), (int8x16_t)v50);
      v57 = (int32x4_t)vmulq_f32(v53, v53);
      v58 = (int32x4_t)vmulq_f32(v54, v54);
      v59 = (int32x4_t)vmulq_f32(v55, v55);
      v60 = (int32x4_t)vmulq_f32(v56, v56);
      v61 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.i8, 1)));
      v62 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.i8, 1)));
      v63 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.i8, 1)));
      v64 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v60, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.i8, 1)));
      v65 = vminq_f32(vrsqrteq_f32(v61), v52);
      v66 = vminq_f32(vrsqrteq_f32(v62), v52);
      v67 = vminq_f32(vrsqrteq_f32(v63), v52);
      v68 = vminq_f32(vrsqrteq_f32(v64), v52);
      v69 = vminq_f32(vmulq_f32(v65, vrsqrtsq_f32(vmulq_f32(v65, v61), v65)), v52);
      v70 = vminq_f32(vmulq_f32(v66, vrsqrtsq_f32(vmulq_f32(v66, v62), v66)), v52);
      v71 = vminq_f32(vmulq_f32(v67, vrsqrtsq_f32(vmulq_f32(v67, v63), v67)), v52);
      v72 = vminq_f32(vmulq_f32(v68, vrsqrtsq_f32(vmulq_f32(v68, v64), v68)), v52);
      v73 = vmulq_f32(v61, vminq_f32(vmulq_f32(v69, vrsqrtsq_f32(vmulq_f32(v69, v61), v69)), v52));
      v74 = vmulq_f32(v62, vminq_f32(vmulq_f32(v70, vrsqrtsq_f32(vmulq_f32(v70, v62), v70)), v52));
      v75 = vmulq_f32(v63, vminq_f32(vmulq_f32(v71, vrsqrtsq_f32(vmulq_f32(v71, v63), v71)), v52));
      v76 = a2[10];
      v77 = vmulq_f32(v64, vminq_f32(vmulq_f32(v72, vrsqrtsq_f32(vmulq_f32(v64, v72), v72)), v52));
      v78 = a2[11].i32[0];
      v79 = *(float32x4_t *)(v23 + 128);
      v80 = *(int8x16_t *)(v23 + 144);
      *(float32x2_t *)v64.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v73.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v81 = v78 + 1;
      *(int32x2_t *)v72.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v64.f32, v15));
      *(float32x2_t *)v51.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v74.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v82 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v51.i8, v15));
      *(float32x2_t *)v64.f32 = vsub_f32(*(float32x2_t *)v64.f32, vcvt_f32_s32(*(int32x2_t *)v72.f32));
      *(int32x2_t *)v52.f32 = vdup_n_s32(v78);
      *(int32x2_t *)v72.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v72.f32, v82), vzip2_s32(*(int32x2_t *)v72.f32, v82), *(int32x2_t *)v52.f32);
      *(float32x2_t *)v51.i8 = vsub_f32(*(float32x2_t *)v51.i8, vcvt_f32_s32(v82));
      v83 = (float32x4_t *)(*(_QWORD *)&v76 + 16 * v72.i32[0]);
      v78 *= 16;
      v84 = v81;
      v85 = (float32x4_t *)(*(_QWORD *)&v76 + 16 * v72.i32[1]);
      v86 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v75.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v87 = vcvt_s32_f32(vmin_f32(v86, v15));
      v88 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v64.f32[0]));
      v89 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v77.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v90 = vcvt_s32_f32(vmin_f32(v89, v15));
      v91 = vmla_s32(vzip1_s32(v87, v90), vzip2_s32(v87, v90), *(int32x2_t *)v52.f32);
      v92 = vaddq_f32(*v85, vmulq_n_f32(vsubq_f32(v85[1], *v85), *(float *)v51.i32));
      v93 = vsub_f32(v86, vcvt_f32_s32(v87));
      v94 = vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v83 + v78), vmulq_n_f32(vsubq_f32(v83[v84], *(float32x4_t *)((char *)v83 + v78)), v64.f32[0])), v88);
      v95 = vsub_f32(v89, vcvt_f32_s32(v90));
      v96 = (float32x4_t *)(*(_QWORD *)&v76 + 16 * v91.i32[0]);
      v97 = vaddq_f32(v88, vmulq_lane_f32(v94, *(float32x2_t *)v64.f32, 1));
      v98 = vaddq_f32(*v96, vmulq_n_f32(vsubq_f32(v96[1], *v96), v93.f32[0]));
      v99 = (float32x4_t *)(*(_QWORD *)&v76 + 16 * v91.i32[1]);
      v100 = vaddq_f32(v92, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v85 + v78), vmulq_n_f32(vsubq_f32(v85[v84], *(float32x4_t *)((char *)v85 + v78)), *(float *)v51.i32)), v92), *(float32x2_t *)v51.i8, 1));
      v101 = vaddq_f32(*v99, vmulq_n_f32(vsubq_f32(v99[1], *v99), v95.f32[0]));
      v102 = vaddq_f32(v98, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v96 + v78), vmulq_n_f32(vsubq_f32(v96[v84], *(float32x4_t *)((char *)v96 + v78)), v93.f32[0])), v98), v93, 1));
      v103 = vaddq_f32(v101, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v99 + v78), vmulq_n_f32(vsubq_f32(v99[v84], *(float32x4_t *)((char *)v99 + v78)), v95.f32[0])), v101), v95, 1));
      v104 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v97, (int8x16_t)vmulq_laneq_f32(v97, v97, 3));
      v105 = *(float32x4_t *)(v23 + 176);
      v106 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v100, (int8x16_t)vmulq_laneq_f32(v100, v100, 3));
      v107 = vmaxq_f32(vsubq_f32(v24, *(float32x4_t *)(v23 + 160)), v105);
      v108 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v102, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      v73.i32[0] = vminq_f32(vmaxq_f32(vsubq_f32(v73, v107), v105), v79).u32[0];
      v109 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v103, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
      v110 = (int8x16_t)vsubq_f32(v106, vmulq_n_f32(v106, vminq_f32(vmaxq_f32(vsubq_f32(v74, v107), v105), v79).f32[0]));
      v111 = (int8x16_t)vsubq_f32(v108, vmulq_n_f32(v108, vminq_f32(vmaxq_f32(vsubq_f32(v75, v107), v105), v79).f32[0]));
      v112 = (int8x16_t)vsubq_f32(v109, vmulq_n_f32(v109, vminq_f32(vmaxq_f32(vsubq_f32(v77, v107), v105), v79).f32[0]));
      v113 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v79, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1), v105)), v105);
      v19[-2] = vbslq_s8(v113, (int8x16_t)v104, (int8x16_t)vsubq_f32(v104, vmulq_n_f32(v104, v73.f32[0])));
      v19[-1] = vbslq_s8(v113, (int8x16_t)v106, v110);
      *v19 = vbslq_s8(v113, (int8x16_t)v108, v111);
      v19[1] = vbslq_s8(v113, (int8x16_t)v109, v112);
      v19 += 4;
      v20 = vaddq_f32(v26, (float32x4_t)xmmword_1B304F230);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v114) = -v18;
    if ((int)v114 >= v5)
      goto LABEL_3;
LABEL_10:
    v114 = v114;
    do
    {
      v115 = *((_QWORD *)this + 51);
      v116 = *(float32x4_t *)(v115 + 32);
      v117 = vmulq_f32(v20, *(float32x4_t *)(v115 + 48));
      v118 = (int8x16_t)vaddq_f32(v117, (float32x4_t)vextq_s8((int8x16_t)v117, (int8x16_t)v117, 4uLL));
      *(float32x2_t *)v118.i8 = vadd_f32(*(float32x2_t *)v118.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v118, v118, 8uLL));
      v119 = vmulq_f32(v20, *(float32x4_t *)(v115 + 64));
      v120 = vaddq_f32(v119, (float32x4_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 4uLL));
      v121 = vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v115 + 80), (int8x16_t)vaddq_f32(v120, (float32x4_t)vextq_s8((int8x16_t)v120, (int8x16_t)v120, 8uLL)), v118), *(float32x4_t *)(v115 + 16));
      v122 = *(float32x4_t *)(v115 + 112);
      v123 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v115 + 96), (int8x16_t)vmulq_f32(*(float32x4_t *)v115, v121), (int8x16_t)v121);
      v124 = (int32x4_t)vmulq_f32(v123, v123);
      v125 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v124, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v124.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v124.i8, 1)));
      v126 = vminq_f32(vrsqrteq_f32(v125), v122);
      v127 = vminq_f32(vmulq_f32(v126, vrsqrtsq_f32(vmulq_f32(v126, v125), v126)), v122);
      v128 = vmulq_f32(vminq_f32(vmulq_f32(v127, vrsqrtsq_f32(vmulq_f32(v127, v125), v127)), v122), v125);
      v129 = *(float32x4_t *)(v115 + 128);
      v130 = a2[11].i32[0];
      *(float32x2_t *)v127.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v128.f32, v116, 3), *(float32x2_t *)v129.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v131 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v127.f32, v15));
      *(float32x2_t *)v127.f32 = vsub_f32(*(float32x2_t *)v127.f32, vcvt_f32_s32(v131));
      v132 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v131.i32[0] + v131.i32[1] * (int)v130));
      v133 = vaddq_f32(*v132, vmulq_n_f32(vsubq_f32(v132[1], *v132), v127.f32[0]));
      v134 = vaddq_f32(v133, vmulq_lane_f32(vsubq_f32(vaddq_f32(v132[v130], vmulq_n_f32(vsubq_f32(v132[(int)v130 + 1], v132[v130]), v127.f32[0])), v133), *(float32x2_t *)v127.f32, 1));
      v135 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v115 + 144), (int8x16_t)v134, (int8x16_t)vmulq_laneq_f32(v134, v134, 3));
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v114) = vsubq_f32(v135, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v135, vminq_f32(vmaxq_f32(vsubq_f32(v128, vmaxq_f32(vsubq_f32(v116, *(float32x4_t *)(v115 + 160)), *(float32x4_t *)(v115 + 176))), *(float32x4_t *)(v115 + 176)), v129).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v129, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v116.f32, 1), *(float32x4_t *)(v115 + 176))),
                                                                                   *(float32x4_t *)(v115 + 176))));
      v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      ++v114;
    }
    while (v114 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialAffine::GetDOD(HgcGradientRadialAffine *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientRadialAffine::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialAffine::HgcGradientRadialAffine(HgcGradientRadialAffine *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653CA10;
  v3 = operator new();
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 112) = xmmword_1B3052D60;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 128) = _Q0;
  *(_OWORD *)(v3 + 144) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051880;
  *(_QWORD *)(v3 + 176) = 0;
  *(_QWORD *)(v3 + 184) = 0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientRadialAffine *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BAB6E0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialAffine::~HgcGradientRadialAffine(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653CA10;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653CA10;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialAffine::SetParameter(HgcGradientRadialAffine *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientRadialAffine::GetParameter(HgcGradientRadialAffine *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialIdentity::GetProgram(HgcGradientRadialIdentity *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xyz = frag._texCoord0.xyz - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[3].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[3].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c95cbf95:9c3091f5:7f2eee20:db8d59e4\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0004:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000049f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = frag._texCoord0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[3].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[3].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fbc4a517:d5b8985a:eb4412b3:5f5c023b\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000510\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xyz = hg_TexCoord0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal3.xy*c0.yy + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.z;\n"
           "    r2.x = max(r2.x, c0.y);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=a69acbca:061caa14:e70c4662:94856247\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialIdentity::InitProgramDescriptor(HgcGradientRadialIdentity *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialIdentity_hgc_visible", "//Metal1.0     \n//LEN=00000003eb\n[[ visible ]] FragmentOut HgcGradientRadialIdentity_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = texCoord0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[3].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[3].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BABC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BABC5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BABC54);
}

char *HgcGradientRadialIdentity::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552EC0;
  strcpy(result, "HgcGradientRadialIdentity [hgc1]");
  return result;
}

uint64_t HgcGradientRadialIdentity::BindTexture(HgcGradientRadialIdentity *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 3, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialIdentity::Bind(HgcGradientRadialIdentity *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcGradientRadialIdentity *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientRadialIdentity::RenderTile(HgcGradientRadialIdentity *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  float32x4_t v7;
  int32x2_t v8;
  float32x2_t v14;
  float32x2_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int v18;
  int8x16_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x2_t v59;
  uint64_t v60;
  int v61;
  float32x4_t *v62;
  uint64_t v63;
  float32x4_t *v64;
  float32x2_t v65;
  int32x2_t v66;
  float32x2_t v67;
  float32x4_t v68;
  int32x2_t v69;
  float32x4_t v70;
  float32x2_t v71;
  float32x4_t v72;
  float32x4_t *v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  uint64_t v90;
  uint64_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  uint64_t v102;
  float32x4_t *v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v7.i64[1] = 0x3F80000000000000;
    v8 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = (int8x16_t *)(*(_QWORD *)&v8 + 32);
    v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v90) = 0;
      v20 = v7;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B304F240);
      ++v4;
      v16 = (int8x16_t *)((char *)v16 + v17);
      *(_QWORD *)&v8 += v17;
      if (v4 == v3)
        return 0;
    }
    v18 = 0;
    v19 = v16;
    v20 = v7;
    do
    {
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F230);
      v24 = *((_QWORD *)this + 51);
      v25 = *(float32x4_t *)(v24 + 16);
      v26 = vsubq_f32(v20, v25);
      v27 = vsubq_f32(v21, v25);
      v28 = vsubq_f32(v22, v25);
      v29 = vsubq_f32(v23, v25);
      v30 = *(float32x4_t *)(v24 + 32);
      v31 = *(int8x16_t *)(v24 + 48);
      v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v26, *(float32x4_t *)v24), (int8x16_t)v26);
      v33 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v27, *(float32x4_t *)v24), (int8x16_t)v27);
      v34 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v28, *(float32x4_t *)v24), (int8x16_t)v28);
      v35 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v29, *(float32x4_t *)v24), (int8x16_t)v29);
      v36 = (int32x4_t)vmulq_f32(v32, v32);
      v37 = (int32x4_t)vmulq_f32(v33, v33);
      v38 = (int32x4_t)vmulq_f32(v34, v34);
      v39 = (int32x4_t)vmulq_f32(v35, v35);
      v40 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v36, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.i8, 1)));
      v41 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1)));
      v42 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v38, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.i8, 1)));
      v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v39, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.i8, 1)));
      v45 = *(float32x4_t *)(v24 + 64);
      v44 = *(float32x4_t *)(v24 + 80);
      v46 = vminq_f32(vrsqrteq_f32(v40), v45);
      v47 = vminq_f32(vrsqrteq_f32(v41), v45);
      v48 = vminq_f32(vrsqrteq_f32(v42), v45);
      v49 = vminq_f32(vrsqrteq_f32(v43), v45);
      v50 = vminq_f32(vmulq_f32(v46, vrsqrtsq_f32(vmulq_f32(v46, v40), v46)), v45);
      v51 = vminq_f32(vmulq_f32(v47, vrsqrtsq_f32(vmulq_f32(v47, v41), v47)), v45);
      v52 = vminq_f32(vmulq_f32(v48, vrsqrtsq_f32(vmulq_f32(v48, v42), v48)), v45);
      v53 = vminq_f32(vmulq_f32(v49, vrsqrtsq_f32(vmulq_f32(v43, v49), v49)), v45);
      v54 = vminq_f32(vmulq_f32(v51, vrsqrtsq_f32(vmulq_f32(v41, v51), v51)), v45);
      v55 = vmulq_f32(v40, vminq_f32(vmulq_f32(v50, vrsqrtsq_f32(vmulq_f32(v40, v50), v50)), v45));
      v56 = vmulq_f32(v41, v54);
      v57 = vmulq_f32(v42, vminq_f32(vmulq_f32(v52, vrsqrtsq_f32(vmulq_f32(v42, v52), v52)), v45));
      v58 = vmulq_f32(v43, vminq_f32(vmulq_f32(v53, vrsqrtsq_f32(vmulq_f32(v43, v53), v53)), v45));
      v59 = a2[10];
      v60 = a2[11].i32[0];
      *(float32x2_t *)v41.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v55.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v52.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v41.f32, v15));
      v61 = v60 + 1;
      *(float32x2_t *)v43.f32 = vsub_f32(*(float32x2_t *)v41.f32, vcvt_f32_s32(*(int32x2_t *)v52.f32));
      *(float32x2_t *)v41.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v56.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v53.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v41.f32, v15));
      *(float32x2_t *)v41.f32 = vsub_f32(*(float32x2_t *)v41.f32, vcvt_f32_s32(*(int32x2_t *)v53.f32));
      *(int32x2_t *)v45.f32 = vdup_n_s32(v60);
      *(int32x2_t *)v52.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v52.f32, *(int32x2_t *)v53.f32), vzip2_s32(*(int32x2_t *)v52.f32, *(int32x2_t *)v53.f32), *(int32x2_t *)v45.f32);
      v62 = (float32x4_t *)(*(_QWORD *)&v59 + 16 * v52.i32[0]);
      v60 *= 16;
      v63 = v61;
      v64 = (float32x4_t *)(*(_QWORD *)&v59 + 16 * v52.i32[1]);
      v65 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v57.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v66 = vcvt_s32_f32(vmin_f32(v65, v15));
      v67 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v58.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v68 = vaddq_f32(*v62, vmulq_n_f32(vsubq_f32(v62[1], *v62), v43.f32[0]));
      *(int32x2_t *)v53.f32 = vcvt_s32_f32(vmin_f32(v67, v15));
      v69 = vmla_s32(vzip1_s32(v66, *(int32x2_t *)v53.f32), vzip2_s32(v66, *(int32x2_t *)v53.f32), *(int32x2_t *)v45.f32);
      v70 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v41.f32[0]));
      v71 = vsub_f32(v65, vcvt_f32_s32(v66));
      v72 = vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v62 + v60), vmulq_n_f32(vsubq_f32(v62[v63], *(float32x4_t *)((char *)v62 + v60)), v43.f32[0])), v68);
      *(float32x2_t *)v53.f32 = vsub_f32(v67, vcvt_f32_s32(*(int32x2_t *)v53.f32));
      v73 = (float32x4_t *)(*(_QWORD *)&v59 + 16 * v69.i32[0]);
      v74 = vmulq_lane_f32(v72, *(float32x2_t *)v43.f32, 1);
      v75 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v71.f32[0]));
      v76 = vaddq_f32(v68, v74);
      v77 = (float32x4_t *)(*(_QWORD *)&v59 + 16 * v69.i32[1]);
      v78 = vaddq_f32(*v77, vmulq_n_f32(vsubq_f32(v77[1], *v77), v53.f32[0]));
      v79 = vaddq_f32(v70, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v64 + v60), vmulq_n_f32(vsubq_f32(v64[v63], *(float32x4_t *)((char *)v64 + v60)), v41.f32[0])), v70), *(float32x2_t *)v41.f32, 1));
      v80 = vaddq_f32(v75, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v73 + v60), vmulq_n_f32(vsubq_f32(v73[v63], *(float32x4_t *)((char *)v73 + v60)), v71.f32[0])), v75), v71, 1));
      v81 = vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v77 + v60), vmulq_n_f32(vsubq_f32(v77[v63], *(float32x4_t *)((char *)v77 + v60)), v53.f32[0])), v78), *(float32x2_t *)v53.f32, 1));
      v82 = *(int8x16_t *)(v24 + 96);
      v83 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v76, (int8x16_t)vmulq_laneq_f32(v76, v76, 3));
      v84 = *(float32x4_t *)(v24 + 128);
      v85 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      v86 = vmaxq_f32(vsubq_f32(v30, *(float32x4_t *)(v24 + 112)), v84);
      v87 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v88 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v89 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v44, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1), v84)), v84);
      v19[-2] = vbslq_s8(v89, (int8x16_t)v83, (int8x16_t)vsubq_f32(v83, vmulq_n_f32(v83, vminq_f32(vmaxq_f32(vsubq_f32(v55, v86), v84), v44).f32[0])));
      v19[-1] = vbslq_s8(v89, (int8x16_t)v85, (int8x16_t)vsubq_f32(v85, vmulq_n_f32(v85, vminq_f32(vmaxq_f32(vsubq_f32(v56, v86), v84), v44).f32[0])));
      *v19 = vbslq_s8(v89, (int8x16_t)v87, (int8x16_t)vsubq_f32(v87, vmulq_n_f32(v87, vminq_f32(vmaxq_f32(vsubq_f32(v57, v86), v84), v44).f32[0])));
      v19[1] = vbslq_s8(v89, (int8x16_t)v88, (int8x16_t)vsubq_f32(v88, vmulq_n_f32(v88, vminq_f32(vmaxq_f32(vsubq_f32(v58, v86), v84), v44).f32[0])));
      v19 += 4;
      v20 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F230);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v90) = -v18;
    if ((int)v90 >= v5)
      goto LABEL_3;
LABEL_10:
    v90 = v90;
    do
    {
      v91 = *((_QWORD *)this + 51);
      v92 = vsubq_f32(v20, *(float32x4_t *)(v91 + 16));
      v93 = *(float32x4_t *)(v91 + 32);
      v94 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v91 + 48), (int8x16_t)vmulq_f32(v92, *(float32x4_t *)v91), (int8x16_t)v92);
      v95 = (int32x4_t)vmulq_f32(v94, v94);
      v96 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v95, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.i8, 1)));
      v97 = *(float32x4_t *)(v91 + 64);
      v98 = *(float32x4_t *)(v91 + 80);
      v99 = vminq_f32(vrsqrteq_f32(v96), v97);
      v100 = vminq_f32(vmulq_f32(v99, vrsqrtsq_f32(vmulq_f32(v99, v96), v99)), v97);
      v101 = vmulq_f32(vminq_f32(vmulq_f32(v100, vrsqrtsq_f32(vmulq_f32(v100, v96), v100)), v97), v96);
      *(float32x2_t *)v100.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v101.f32, v93, 3), *(float32x2_t *)v98.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v102 = a2[11].i32[0];
      *(int32x2_t *)v97.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v100.f32, v15));
      *(float32x2_t *)v100.f32 = vsub_f32(*(float32x2_t *)v100.f32, vcvt_f32_s32(*(int32x2_t *)v97.f32));
      v103 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v97.i32[0] + v97.i32[1] * (int)v102));
      v104 = vaddq_f32(*v103, vmulq_n_f32(vsubq_f32(v103[1], *v103), v100.f32[0]));
      v105 = vaddq_f32(v104, vmulq_lane_f32(vsubq_f32(vaddq_f32(v103[v102], vmulq_n_f32(vsubq_f32(v103[(int)v102 + 1], v103[v102]), v100.f32[0])), v104), *(float32x2_t *)v100.f32, 1));
      v106 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v91 + 96), (int8x16_t)v105, (int8x16_t)vmulq_laneq_f32(v105, v105, 3));
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v90) = vsubq_f32(v106, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v106, vminq_f32(vmaxq_f32(vsubq_f32(v101, vmaxq_f32(vsubq_f32(v93, *(float32x4_t *)(v91 + 112)), *(float32x4_t *)(v91 + 128))), *(float32x4_t *)(v91 + 128)), v98).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v93.f32, 1), *(float32x4_t *)(v91 + 128))),
                                                                                  *(float32x4_t *)(v91 + 128))));
      v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      ++v90;
    }
    while (v90 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialIdentity::GetDOD(HgcGradientRadialIdentity *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientRadialIdentity::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialIdentity::HgcGradientRadialIdentity(HgcGradientRadialIdentity *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653CC78;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050E20;
  __asm { FMOV            V1.4S, #1.0 }
  *(_OWORD *)(v3 + 64) = xmmword_1B3052D60;
  *(_OWORD *)(v3 + 80) = _Q1;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051880;
  *(_QWORD *)(v3 + 128) = 0;
  *(_QWORD *)(v3 + 136) = 0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientRadialIdentity *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BAC52C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialIdentity::~HgcGradientRadialIdentity(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653CC78;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653CC78;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialIdentity::SetParameter(HgcGradientRadialIdentity *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientRadialIdentity::GetParameter(HgcGradientRadialIdentity *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialPerspective::GetProgram(HgcGradientRadialPerspective *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000005cf\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    r0.w = dot(half4(hg_Params[5]), half4(frag._texCoord0));\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[6].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[6].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4fc58a1d:f2a56d04:45f3c20f:c91b4cbb\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0007:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000549\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.w = dot(hg_Params[5], frag._texCoord0);\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[6].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[6].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5122a7df:2cdb5da5:cb8625a9:cbdcfae0\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0007:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000062f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.w = dot(hg_ProgramLocal5, hg_TexCoord0);\n"
           "    r0.xy = r0.xy/r0.ww;\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal6.xy*c0.zz + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.y;\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=7d877a02:a9145601:4fed2dba:0c2241bf\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0007:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialPerspective::InitProgramDescriptor(HgcGradientRadialPerspective *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialPerspective_hgc_visible", "//Metal1.0     \n//LEN=000000048c\n[[ visible ]] FragmentOut HgcGradientRadialPerspective_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.w = dot(hg_Params[5], texCoord0);\n"
    "    r0.xy = r0.xy/r0.ww;\n"
    "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[6].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[6].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BACA70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BACAA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BACAA0);
}

char *HgcGradientRadialPerspective::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcGradientRadialPerspective [hgc1]");
  return result;
}

uint64_t HgcGradientRadialPerspective::BindTexture(HgcGradientRadialPerspective *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 6, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialPerspective::Bind(HgcGradientRadialPerspective *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HgcGradientRadialPerspective *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientRadialPerspective::RenderTile(HgcGradientRadialPerspective *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  int v5;
  float32x2_t v6;
  int32x2_t v7;
  float32x4_t v8;
  float32x2_t v14;
  float32x2_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int32x2_t v86;
  uint64_t v87;
  __int32 v88;
  float32x4_t *v89;
  float32x4_t v90;
  uint64_t v91;
  float32x4_t *v92;
  float32x4_t v93;
  int32x2_t v94;
  float32x4_t *v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  float32x4_t v106;
  int8x16_t v107;
  int8x16_t v108;
  int8x16_t *v109;
  uint64_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  int8x16_t v117;
  int8x16_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  int32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  uint64_t v134;
  float32x4_t *v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = a2[1].i32[0] - v2.i32[0];
    v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    v14 = vadd_f32(v6, _D4);
    v15 = vadd_f32(v14, _D4);
    v16 = 16 * a2[3].i32[0];
    while (v5 < 3)
    {
      v17 = 0;
      v19 = v8;
      if (v5 > 0)
        goto LABEL_10;
LABEL_3:
      v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v7 += v16;
      if (v4 == v3)
        return 0;
    }
    v17 = 0;
    v18 = v5;
    v19 = v8;
    do
    {
      v20 = vaddq_f32(v19, (float32x4_t)xmmword_1B304F230);
      v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v22 = *((_QWORD *)this + 51);
      v24 = *(float32x4_t *)(v22 + 32);
      v23 = *(float32x4_t *)(v22 + 48);
      v25 = vmulq_f32(v19, v23);
      v26 = vmulq_f32(v20, v23);
      v27 = vmulq_f32(v21, v23);
      v28 = (int8x16_t)vaddq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL));
      v29 = (int8x16_t)vaddq_f32(v26, (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL));
      v30 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      v31 = *(float32x4_t *)(v22 + 64);
      v32 = *(float32x4_t *)(v22 + 80);
      *(float32x2_t *)v28.i8 = vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
      v33 = vmulq_f32(v19, v31);
      v34 = vmulq_f32(v20, v31);
      v35 = vmulq_f32(v21, v31);
      *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      v36 = vaddq_f32(v33, (float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL));
      v37 = vaddq_f32(v34, (float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 4uLL));
      v38 = vaddq_f32(v35, (float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 4uLL));
      *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v39 = vmulq_f32(v19, v32);
      v40 = vmulq_f32(v20, v32);
      v41 = vmulq_f32(v21, v32);
      v43 = *(int8x16_t *)(v22 + 96);
      v42 = *(int8x16_t *)(v22 + 112);
      v44 = vbslq_s8(v43, (int8x16_t)vaddq_f32(v36, (float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL)), v28);
      v45 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      v46 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      v47 = vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL));
      v48 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vaddq_f32(v45, (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL)), v44);
      v49 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vaddq_f32(v46, (float32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 8uLL)), vbslq_s8(v43, (int8x16_t)vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL)), v29));
      v50 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vaddq_f32(v47, (float32x4_t)vextq_s8((int8x16_t)v47, (int8x16_t)v47, 8uLL)), vbslq_s8(v43, (int8x16_t)vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL)), v30));
      v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3);
      v52 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 3);
      v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
      v54 = *(float32x4_t *)(v22 + 128);
      v55 = *(float32x4_t *)(v22 + 144);
      v56 = vminq_f32(vmaxq_f32(vrecpeq_f32(v51), v54), v55);
      v57 = vminq_f32(vmaxq_f32(vrecpeq_f32(v52), v54), v55);
      v58 = vminq_f32(vmaxq_f32(vrecpeq_f32(v53), v54), v55);
      v59 = vminq_f32(vmaxq_f32(vmulq_f32(v56, vrecpsq_f32(v51, v56)), v54), v55);
      v60 = vminq_f32(vmaxq_f32(vmulq_f32(v57, vrecpsq_f32(v52, v57)), v54), v55);
      v61 = vminq_f32(vmaxq_f32(vmulq_f32(v58, vrecpsq_f32(v53, v58)), v54), v55);
      v51.i64[0] = vmulq_f32(vmulq_f32(v59, vrecpsq_f32(v51, v59)), v48).u64[0];
      v52.i64[0] = vmulq_f32(vmulq_f32(v60, vrecpsq_f32(v52, v60)), v49).u64[0];
      v53.i64[0] = vmulq_f32(vmulq_f32(v61, vrecpsq_f32(v53, v61)), v50).u64[0];
      v51.i64[1] = v48.i64[1];
      v52.i64[1] = v49.i64[1];
      v53.i64[1] = v50.i64[1];
      v62 = *(float32x4_t *)(v22 + 16);
      v63 = vsubq_f32(v51, v62);
      v64 = vsubq_f32(v52, v62);
      v65 = vsubq_f32(v53, v62);
      v67 = *(int8x16_t *)(v22 + 160);
      v66 = *(float32x4_t *)(v22 + 176);
      v68 = (float32x4_t)vbslq_s8(v67, (int8x16_t)vmulq_f32(*(float32x4_t *)v22, v63), (int8x16_t)v63);
      v69 = (float32x4_t)vbslq_s8(v67, (int8x16_t)vmulq_f32(*(float32x4_t *)v22, v64), (int8x16_t)v64);
      v70 = (float32x4_t)vbslq_s8(v67, (int8x16_t)vmulq_f32(*(float32x4_t *)v22, v65), (int8x16_t)v65);
      v71 = (int32x4_t)vmulq_f32(v68, v68);
      v72 = (int32x4_t)vmulq_f32(v69, v69);
      v73 = (int32x4_t)vmulq_f32(v70, v70);
      v74 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.i8, 1)));
      v75 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v72, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.i8, 1)));
      v76 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v73, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.i8, 1)));
      v77 = vminq_f32(vrsqrteq_f32(v74), v55);
      v78 = vminq_f32(vrsqrteq_f32(v75), v55);
      v79 = vminq_f32(vrsqrteq_f32(v76), v55);
      v80 = vminq_f32(vmulq_f32(v77, vrsqrtsq_f32(vmulq_f32(v77, v74), v77)), v55);
      v81 = vminq_f32(vmulq_f32(v78, vrsqrtsq_f32(vmulq_f32(v78, v75), v78)), v55);
      v82 = vminq_f32(vmulq_f32(v79, vrsqrtsq_f32(vmulq_f32(v79, v76), v79)), v55);
      v83 = vmulq_f32(v74, vminq_f32(vmulq_f32(v80, vrsqrtsq_f32(vmulq_f32(v74, v80), v80)), v55));
      v84 = vmulq_f32(v75, vminq_f32(vmulq_f32(v81, vrsqrtsq_f32(vmulq_f32(v75, v81), v81)), v55));
      v85 = vmulq_f32(v76, vminq_f32(vmulq_f32(v82, vrsqrtsq_f32(vmulq_f32(v76, v82), v82)), v55));
      v86 = a2[10];
      v87 = a2[11].i32[0];
      *(float32x2_t *)v80.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v83.f32, v24, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v81.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v80.f32, v15));
      *(float32x2_t *)v82.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v84.f32, v24, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v61.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v82.f32, v15));
      *(float32x2_t *)v80.f32 = vsub_f32(*(float32x2_t *)v80.f32, vcvt_f32_s32(*(int32x2_t *)v81.f32));
      *(float32x2_t *)v82.f32 = vsub_f32(*(float32x2_t *)v82.f32, vcvt_f32_s32(*(int32x2_t *)v61.f32));
      *(int32x2_t *)v81.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v81.f32, *(int32x2_t *)v61.f32), vzip2_s32(*(int32x2_t *)v81.f32, *(int32x2_t *)v61.f32), vdup_n_s32(v87));
      v88 = v81.i32[1];
      v89 = (float32x4_t *)(*(_QWORD *)&v86 + 16 * v81.i32[0]);
      v90 = vaddq_f32(*v89, vmulq_n_f32(vsubq_f32(v89[1], *v89), v80.f32[0]));
      v91 = (int)v87 + 1;
      v92 = (float32x4_t *)(*(_QWORD *)&v86 + 16 * v88);
      v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v82.f32[0]));
      *(float32x2_t *)v55.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v85.f32, v24, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      v94 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v55.f32, v15));
      *(float32x2_t *)v67.i8 = vsub_f32(*(float32x2_t *)v55.f32, vcvt_f32_s32(v94));
      v95 = (float32x4_t *)(*(_QWORD *)&v86 + 16 * (v94.i32[0] + v94.i32[1] * (int)v87));
      v96 = vaddq_f32(v90, vmulq_lane_f32(vsubq_f32(vaddq_f32(v89[v87], vmulq_n_f32(vsubq_f32(v89[v91], v89[v87]), v80.f32[0])), v90), *(float32x2_t *)v80.f32, 1));
      v97 = vaddq_f32(*v95, vmulq_n_f32(vsubq_f32(v95[1], *v95), *(float *)v67.i32));
      v98 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v87], vmulq_n_f32(vsubq_f32(v92[v91], v92[v87]), v82.f32[0])), v93), *(float32x2_t *)v82.f32, 1));
      v99 = vaddq_f32(v97, vmulq_lane_f32(vsubq_f32(vaddq_f32(v95[v87], vmulq_n_f32(vsubq_f32(v95[v91], v95[v87]), *(float *)v67.i32)), v97), *(float32x2_t *)v67.i8, 1));
      v100 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v96, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
      v101 = *(float32x4_t *)(v22 + 208);
      v102 = vmaxq_f32(vsubq_f32(v24, *(float32x4_t *)(v22 + 192)), v101);
      v103 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v99, (int8x16_t)vmulq_laneq_f32(v99, v99, 3));
      v104 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v98, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
      v105 = (int8x16_t)vsubq_f32(v100, vmulq_n_f32(v100, vminq_f32(vmaxq_f32(vsubq_f32(v83, v102), v101), v66).f32[0]));
      v106 = vmulq_n_f32(v104, vminq_f32(vmaxq_f32(vsubq_f32(v84, v102), v101), v66).f32[0]);
      v107 = (int8x16_t)vsubq_f32(v103, vmulq_n_f32(v103, vminq_f32(vmaxq_f32(vsubq_f32(v85, v102), v101), v66).f32[0]));
      v108 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v66, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1), v101)), v101);
      v109 = (int8x16_t *)(*(_QWORD *)&v7 + 16 * v17);
      *v109 = vbslq_s8(v108, (int8x16_t)v100, v105);
      v109[1] = vbslq_s8(v108, (int8x16_t)v104, (int8x16_t)vsubq_f32(v104, v106));
      v109[2] = vbslq_s8(v108, (int8x16_t)v103, v107);
      v19 = vaddq_f32(v21, (float32x4_t)xmmword_1B304F230);
      v17 += 3;
      v18 -= 3;
    }
    while (v18 > 2);
    v17 = v17;
    if ((int)v17 >= v5)
      goto LABEL_3;
    do
    {
LABEL_10:
      v110 = *((_QWORD *)this + 51);
      v111 = *(float32x4_t *)(v110 + 32);
      v112 = vmulq_f32(v19, *(float32x4_t *)(v110 + 48));
      v113 = (int8x16_t)vaddq_f32(v112, (float32x4_t)vextq_s8((int8x16_t)v112, (int8x16_t)v112, 4uLL));
      v114 = vmulq_f32(v19, *(float32x4_t *)(v110 + 64));
      v115 = vaddq_f32(v114, (float32x4_t)vextq_s8((int8x16_t)v114, (int8x16_t)v114, 4uLL));
      *(float32x2_t *)v113.i8 = vadd_f32(*(float32x2_t *)v113.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL));
      v116 = vmulq_f32(v19, *(float32x4_t *)(v110 + 80));
      v117 = *(int8x16_t *)(v110 + 112);
      v118 = vbslq_s8(*(int8x16_t *)(v110 + 96), (int8x16_t)vaddq_f32(v115, (float32x4_t)vextq_s8((int8x16_t)v115, (int8x16_t)v115, 8uLL)), v113);
      v119 = vaddq_f32(v116, (float32x4_t)vextq_s8((int8x16_t)v116, (int8x16_t)v116, 4uLL));
      v120 = (float32x4_t)vbslq_s8(v117, (int8x16_t)vaddq_f32(v119, (float32x4_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL)), v118);
      v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v120, 3);
      v122 = *(float32x4_t *)(v110 + 128);
      v123 = *(float32x4_t *)(v110 + 144);
      v124 = vminq_f32(vmaxq_f32(vrecpeq_f32(v121), v122), v123);
      v125 = vminq_f32(vmaxq_f32(vmulq_f32(v124, vrecpsq_f32(v121, v124)), v122), v123);
      v121.i64[0] = vmulq_f32(vmulq_f32(v125, vrecpsq_f32(v121, v125)), v120).u64[0];
      v121.i64[1] = v120.i64[1];
      v126 = vsubq_f32(v121, *(float32x4_t *)(v110 + 16));
      v127 = *(float32x4_t *)(v110 + 176);
      v128 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v110 + 160), (int8x16_t)vmulq_f32(*(float32x4_t *)v110, v126), (int8x16_t)v126);
      v129 = (int32x4_t)vmulq_f32(v128, v128);
      v130 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v129, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.i8, 1)));
      v131 = vminq_f32(vrsqrteq_f32(v130), v123);
      v132 = vminq_f32(vmulq_f32(v131, vrsqrtsq_f32(vmulq_f32(v131, v130), v131)), v123);
      v133 = vmulq_f32(vminq_f32(vmulq_f32(v132, vrsqrtsq_f32(vmulq_f32(v132, v130), v132)), v123), v130);
      v134 = a2[11].i32[0];
      *(float32x2_t *)v132.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v133.f32, v111, 3), *(float32x2_t *)v127.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v125.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v132.f32, v15));
      *(float32x2_t *)v132.f32 = vsub_f32(*(float32x2_t *)v132.f32, vcvt_f32_s32(*(int32x2_t *)v125.f32));
      v135 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v125.i32[0] + v125.i32[1] * (int)v134));
      v136 = vaddq_f32(*v135, vmulq_n_f32(vsubq_f32(v135[1], *v135), v132.f32[0]));
      v137 = vaddq_f32(v136, vmulq_lane_f32(vsubq_f32(vaddq_f32(v135[v134], vmulq_n_f32(vsubq_f32(v135[(int)v134 + 1], v135[v134]), v132.f32[0])), v136), *(float32x2_t *)v132.f32, 1));
      v138 = (float32x4_t)vbslq_s8(v117, (int8x16_t)v137, (int8x16_t)vmulq_laneq_f32(v137, v137, 3));
      *(float32x4_t *)(*(_QWORD *)&v7 + 16 * v17) = vsubq_f32(v138, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v138, vminq_f32(vmaxq_f32(vsubq_f32(v133, vmaxq_f32(vsubq_f32(v111, *(float32x4_t *)(v110 + 192)), *(float32x4_t *)(v110 + 208))), *(float32x4_t *)(v110 + 208)), v127).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v127, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v111.f32, 1), *(float32x4_t *)(v110 + 208))),
                                                                                  *(float32x4_t *)(v110 + 208))));
      v19 = vaddq_f32(v19, (float32x4_t)xmmword_1B304F230);
      ++v17;
    }
    while (v17 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialPerspective::GetDOD(HgcGradientRadialPerspective *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientRadialPerspective::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialPerspective::HgcGradientRadialPerspective(HgcGradientRadialPerspective *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653CEE0;
  v3 = operator new();
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 112) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 128) = xmmword_1B30527A0;
  *(int32x4_t *)(v3 + 144) = vdupq_n_s32(0x7F7FFFFFu);
  __asm { FMOV            V1.4S, #1.0 }
  *(_OWORD *)(v3 + 160) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 176) = _Q1;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051880;
  *(_QWORD *)(v3 + 208) = 0;
  *(_QWORD *)(v3 + 216) = 0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientRadialPerspective *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BAD4EC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialPerspective::~HgcGradientRadialPerspective(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653CEE0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653CEE0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialPerspective::SetParameter(HgcGradientRadialPerspective *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 5)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientRadialPerspective::GetParameter(HgcGradientRadialPerspective *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 5)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialTranslate::GetProgram(HgcGradientRadialTranslate *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000575\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = half(hg_Params[3].x) + half(frag._texCoord0.x);\n"
             "    r0.y = half(hg_Params[4].y) + half(frag._texCoord0.y);\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[5].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[5].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1ea05cb7:c3dd4787:6609f856:de1f9da5\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0006:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000501\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = hg_Params[3].x + frag._texCoord0.x;\n"
             "    r0.y = hg_Params[4].y + frag._texCoord0.y;\n"
             "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[5].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[5].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c8bbc548:4c65dde8:81c7f077:a13a6c08\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = hg_ProgramLocal3.x + hg_TexCoord0.x;\n"
           "    r0.y = hg_ProgramLocal4.y + hg_TexCoord0.y;\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal5.xy*c0.zz + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.y;\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=97dca451:648d32c1:c6253b89:39206e01\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialTranslate::InitProgramDescriptor(HgcGradientRadialTranslate *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialTranslate_hgc_visible", "//Metal1.0     \n//LEN=0000000448\n[[ visible ]] FragmentOut HgcGradientRadialTranslate_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = hg_Params[3].x + texCoord0.x;\n"
    "    r0.y = hg_Params[4].y + texCoord0.y;\n"
    "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[5].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[5].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BADA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BADA68(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BADA60);
}

char *HgcGradientRadialTranslate::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcGradientRadialTranslate [hgc1]");
  return result;
}

uint64_t HgcGradientRadialTranslate::BindTexture(HgcGradientRadialTranslate *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 5, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialTranslate::Bind(HgcGradientRadialTranslate *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcGradientRadialTranslate *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGradientRadialTranslate::RenderTile(HgcGradientRadialTranslate *this, int32x2_t *a2)
{
  int8x16_t v2;
  float32x4_t v3;
  float32x4_t v4;
  int32x2_t v5;
  int v6;
  int v7;
  int v8;
  float32x2_t v9;
  float32x4_t v10;
  int32x2_t v11;
  float32x2_t v17;
  float32x2_t v18;
  int8x16_t *v19;
  uint64_t v20;
  int v21;
  int8x16_t *v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  uint64_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x2_t v63;
  float32x4_t v64;
  uint64_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int v68;
  int32x2_t v69;
  float32x4_t *v70;
  uint64_t v71;
  float32x4_t *v72;
  float32x2_t v73;
  int32x2_t v74;
  float32x4_t v75;
  float32x2_t v76;
  int32x2_t v77;
  int32x2_t v78;
  float32x4_t v79;
  float32x2_t v80;
  float32x4_t v81;
  float32x2_t v82;
  float32x4_t *v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t *v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  int8x16_t v96;
  int8x16_t v97;
  uint64_t v98;
  uint64_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  uint64_t v111;
  int32x2_t v112;
  float32x4_t *v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;

  v5 = *a2;
  v6 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v6 >= 1)
  {
    v7 = 0;
    v8 = a2[1].i32[0] - v5.i32[0];
    v9 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v10.f32 = vadd_f32(vcvt_f32_s32(v5), (float32x2_t)0x3F0000003F000000);
    v10.i64[1] = 0x3F80000000000000;
    v11 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    v17 = vadd_f32(v9, _D4);
    v18 = vadd_f32(v17, _D4);
    v19 = (int8x16_t *)(*(_QWORD *)&v11 + 32);
    v20 = 16 * a2[3].i32[0];
    while (v8 < 4)
    {
      LODWORD(v98) = 0;
      v23 = v10;
      if (v8 > 0)
        goto LABEL_10;
LABEL_3:
      v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B304F240);
      ++v7;
      v19 = (int8x16_t *)((char *)v19 + v20);
      *(_QWORD *)&v11 += v20;
      if (v7 == v6)
        return 0;
    }
    v21 = 0;
    v22 = v19;
    v23 = v10;
    do
    {
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F230);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B304F230);
      v26 = *((_QWORD *)this + 51);
      v27 = vaddq_f32(v25, (float32x4_t)xmmword_1B304F230);
      v28 = *(float32x4_t *)(v26 + 32);
      v29 = *(int8x16_t *)(v26 + 48);
      *(float32x2_t *)v2.i8 = vadd_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v29.i8);
      *(float32x2_t *)v3.f32 = vadd_f32(*(float32x2_t *)v24.f32, *(float32x2_t *)v29.i8);
      *(float32x2_t *)v4.f32 = vadd_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v29.i8);
      *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v29.i8);
      v30 = *(float32x4_t *)(v26 + 64);
      v31 = *(int8x16_t *)(v26 + 80);
      v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v23, v30), v2);
      v33 = *(float32x4_t *)(v26 + 16);
      v34 = vsubq_f32(v32, v33);
      v35 = vsubq_f32((float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v24, v30), (int8x16_t)v3), v33);
      v36 = vsubq_f32((float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v25, v30), (int8x16_t)v4), v33);
      v37 = vsubq_f32((float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v27, v30), v29), v33);
      v38 = *(int8x16_t *)(v26 + 96);
      v39 = *(float32x4_t *)(v26 + 112);
      v40 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v34), (int8x16_t)v34);
      v41 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v35), (int8x16_t)v35);
      v42 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v36), (int8x16_t)v36);
      v43 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v37), (int8x16_t)v37);
      v44 = (int32x4_t)vmulq_f32(v40, v40);
      v45 = (int32x4_t)vmulq_f32(v41, v41);
      v46 = (int32x4_t)vmulq_f32(v42, v42);
      v47 = (int32x4_t)vmulq_f32(v43, v43);
      v48 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v44, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 1)));
      v49 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v45, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.i8, 1)));
      v50 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v46, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.i8, 1)));
      v51 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v47, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 1)));
      v52 = vminq_f32(vrsqrteq_f32(v48), v39);
      v53 = vminq_f32(vrsqrteq_f32(v49), v39);
      v54 = vminq_f32(vrsqrteq_f32(v50), v39);
      v55 = vminq_f32(vrsqrteq_f32(v51), v39);
      v56 = vminq_f32(vmulq_f32(v52, vrsqrtsq_f32(vmulq_f32(v52, v48), v52)), v39);
      v57 = vminq_f32(vmulq_f32(v53, vrsqrtsq_f32(vmulq_f32(v53, v49), v53)), v39);
      v58 = vminq_f32(vmulq_f32(v54, vrsqrtsq_f32(vmulq_f32(v54, v50), v54)), v39);
      v59 = vminq_f32(vmulq_f32(v55, vrsqrtsq_f32(vmulq_f32(v55, v51), v55)), v39);
      v60 = vmulq_f32(v48, vminq_f32(vmulq_f32(v56, vrsqrtsq_f32(vmulq_f32(v48, v56), v56)), v39));
      v61 = vmulq_f32(v49, vminq_f32(vmulq_f32(v57, vrsqrtsq_f32(vmulq_f32(v49, v57), v57)), v39));
      v62 = vmulq_f32(v50, vminq_f32(vmulq_f32(v58, vrsqrtsq_f32(vmulq_f32(v50, v58), v58)), v39));
      v63 = a2[10];
      v64 = vmulq_f32(v51, vminq_f32(vmulq_f32(v59, vrsqrtsq_f32(vmulq_f32(v51, v59), v59)), v39));
      v65 = a2[11].i32[0];
      v66 = *(float32x4_t *)(v26 + 128);
      v67 = *(int8x16_t *)(v26 + 144);
      *(float32x2_t *)v50.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v60.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      v68 = v65 + 1;
      *(int32x2_t *)v59.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v50.f32, v18));
      *(float32x2_t *)v38.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v61.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      v69 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v38.i8, v18));
      *(float32x2_t *)v50.f32 = vsub_f32(*(float32x2_t *)v50.f32, vcvt_f32_s32(*(int32x2_t *)v59.f32));
      *(int32x2_t *)v39.f32 = vdup_n_s32(v65);
      *(int32x2_t *)v59.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v59.f32, v69), vzip2_s32(*(int32x2_t *)v59.f32, v69), *(int32x2_t *)v39.f32);
      *(float32x2_t *)v38.i8 = vsub_f32(*(float32x2_t *)v38.i8, vcvt_f32_s32(v69));
      v70 = (float32x4_t *)(*(_QWORD *)&v63 + 16 * v59.i32[0]);
      v65 *= 16;
      v71 = v68;
      v72 = (float32x4_t *)(*(_QWORD *)&v63 + 16 * v59.i32[1]);
      v73 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v62.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      v74 = vcvt_s32_f32(vmin_f32(v73, v18));
      v75 = vaddq_f32(*v70, vmulq_n_f32(vsubq_f32(v70[1], *v70), v50.f32[0]));
      v76 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v64.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      v77 = vcvt_s32_f32(vmin_f32(v76, v18));
      v78 = vmla_s32(vzip1_s32(v74, v77), vzip2_s32(v74, v77), *(int32x2_t *)v39.f32);
      v79 = vaddq_f32(*v72, vmulq_n_f32(vsubq_f32(v72[1], *v72), *(float *)v38.i32));
      v80 = vsub_f32(v73, vcvt_f32_s32(v74));
      v81 = vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v70 + v65), vmulq_n_f32(vsubq_f32(v70[v71], *(float32x4_t *)((char *)v70 + v65)), v50.f32[0])), v75);
      v82 = vsub_f32(v76, vcvt_f32_s32(v77));
      v83 = (float32x4_t *)(*(_QWORD *)&v63 + 16 * v78.i32[0]);
      v84 = vaddq_f32(v75, vmulq_lane_f32(v81, *(float32x2_t *)v50.f32, 1));
      v85 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v80.f32[0]));
      v86 = (float32x4_t *)(*(_QWORD *)&v63 + 16 * v78.i32[1]);
      v87 = vaddq_f32(v79, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v72 + v65), vmulq_n_f32(vsubq_f32(v72[v71], *(float32x4_t *)((char *)v72 + v65)), *(float *)v38.i32)), v79), *(float32x2_t *)v38.i8, 1));
      v88 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v82.f32[0]));
      v89 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v83 + v65), vmulq_n_f32(vsubq_f32(v83[v71], *(float32x4_t *)((char *)v83 + v65)), v80.f32[0])), v85), v80, 1));
      v90 = vaddq_f32(v88, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v86 + v65), vmulq_n_f32(vsubq_f32(v86[v71], *(float32x4_t *)((char *)v86 + v65)), v82.f32[0])), v88), v82, 1));
      v3 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v84, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      v91 = *(float32x4_t *)(v26 + 176);
      v92 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v87, (int8x16_t)vmulq_laneq_f32(v87, v87, 3));
      v93 = vmaxq_f32(vsubq_f32(v28, *(float32x4_t *)(v26 + 160)), v91);
      v94 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      v60.i32[0] = vminq_f32(vmaxq_f32(vsubq_f32(v60, v93), v91), v66).u32[0];
      v4 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
      v95 = (int8x16_t)vsubq_f32(v92, vmulq_n_f32(v92, vminq_f32(vmaxq_f32(vsubq_f32(v61, v93), v91), v66).f32[0]));
      v96 = (int8x16_t)vsubq_f32(v94, vmulq_n_f32(v94, vminq_f32(vmaxq_f32(vsubq_f32(v62, v93), v91), v66).f32[0]));
      v2 = (int8x16_t)vsubq_f32(v4, vmulq_n_f32(v4, vminq_f32(vmaxq_f32(vsubq_f32(v64, v93), v91), v66).f32[0]));
      v97 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v66, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1), v91)), v91);
      v22[-2] = vbslq_s8(v97, (int8x16_t)v3, (int8x16_t)vsubq_f32(v3, vmulq_n_f32(v3, v60.f32[0])));
      v22[-1] = vbslq_s8(v97, (int8x16_t)v92, v95);
      *v22 = vbslq_s8(v97, (int8x16_t)v94, v96);
      v22[1] = vbslq_s8(v97, (int8x16_t)v4, v2);
      v22 += 4;
      v23 = vaddq_f32(v27, (float32x4_t)xmmword_1B304F230);
      v21 -= 4;
    }
    while (v8 + v21 > 3);
    LODWORD(v98) = -v21;
    if ((int)v98 >= v8)
      goto LABEL_3;
LABEL_10:
    v98 = v98;
    do
    {
      v99 = *((_QWORD *)this + 51);
      v101 = *(float32x4_t *)(v99 + 32);
      v100 = *(int8x16_t *)(v99 + 48);
      *(float32x2_t *)v100.i8 = vadd_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v100.i8);
      v102 = vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v99 + 80), (int8x16_t)vaddq_f32(v23, *(float32x4_t *)(v99 + 64)), v100), *(float32x4_t *)(v99 + 16));
      v103 = *(float32x4_t *)(v99 + 112);
      v104 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v99 + 96), (int8x16_t)vmulq_f32(*(float32x4_t *)v99, v102), (int8x16_t)v102);
      v105 = (int32x4_t)vmulq_f32(v104, v104);
      v106 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v105, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 1)));
      v107 = vminq_f32(vrsqrteq_f32(v106), v103);
      v108 = vminq_f32(vmulq_f32(v107, vrsqrtsq_f32(vmulq_f32(v107, v106), v107)), v103);
      v109 = vmulq_f32(vminq_f32(vmulq_f32(v108, vrsqrtsq_f32(vmulq_f32(v108, v106), v108)), v103), v106);
      v110 = *(float32x4_t *)(v99 + 128);
      v111 = a2[11].i32[0];
      *(float32x2_t *)v108.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v109.f32, v101, 3), *(float32x2_t *)v110.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      v112 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v108.f32, v18));
      *(float32x2_t *)v108.f32 = vsub_f32(*(float32x2_t *)v108.f32, vcvt_f32_s32(v112));
      v113 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v112.i32[0] + v112.i32[1] * (int)v111));
      v114 = vaddq_f32(*v113, vmulq_n_f32(vsubq_f32(v113[1], *v113), v108.f32[0]));
      v115 = vaddq_f32(v114, vmulq_lane_f32(vsubq_f32(vaddq_f32(v113[v111], vmulq_n_f32(vsubq_f32(v113[(int)v111 + 1], v113[v111]), v108.f32[0])), v114), *(float32x2_t *)v108.f32, 1));
      v2 = (int8x16_t)vmulq_laneq_f32(v115, v115, 3);
      v3 = *(float32x4_t *)(v99 + 160);
      v4 = *(float32x4_t *)(v99 + 176);
      v116 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v99 + 144), (int8x16_t)v115, v2);
      *(float32x4_t *)(*(_QWORD *)&v11 + 16 * v98) = vsubq_f32(v116, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v116, vminq_f32(vmaxq_f32(vsubq_f32(v109, vmaxq_f32(vsubq_f32(v101, v3), v4)), v4), v110).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v110, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.f32, 1), v4)), v4)));
      v23 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F230);
      ++v98;
    }
    while (v98 < v8);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialTranslate::GetDOD(HgcGradientRadialTranslate *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcGradientRadialTranslate::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialTranslate::HgcGradientRadialTranslate(HgcGradientRadialTranslate *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653D148;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[4] = 0u;
  v3[5] = xmmword_1B3050FF0;
  v3[6] = xmmword_1B3050E20;
  v3[7] = xmmword_1B3052D60;
  __asm { FMOV            V1.4S, #1.0 }
  v3[8] = _Q1;
  v3[9] = xmmword_1B3050F70;
  v3[10] = xmmword_1B3051880;
  v3[11] = 0u;
  v3[12] = 0u;
  v3[13] = 0u;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcGradientRadialTranslate *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BAE3D8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialTranslate::~HgcGradientRadialTranslate(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653D148;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653D148;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialTranslate::SetParameter(HgcGradientRadialTranslate *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  float *v7;
  uint64_t result;
  float *v9;
  float *v10;
  __n128 *v11;
  __n128 *v12;

  switch((int)a2)
  {
    case 0:
      v7 = (float *)*((_QWORD *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6)
        goto LABEL_28;
      *v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 1:
      v9 = (float *)*((_QWORD *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6)
        goto LABEL_28;
      v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 2:
      v10 = (float *)*((_QWORD *)this + 51);
      if (v10[8] == a3.n128_f32[0] && v10[9] == a4 && v10[10] == a5 && v10[11] == a6)
        goto LABEL_28;
      v10[8] = a3.n128_f32[0];
      v10[9] = a4;
      v10[10] = a5;
      v10[11] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 3:
      v11 = (__n128 *)*((_QWORD *)this + 51);
      if (v11[3].n128_f32[0] == a6
        && v11[3].n128_f32[1] == 0.0
        && v11[3].n128_f32[2] == 0.0
        && v11[3].n128_f32[3] == 0.0)
      {
        goto LABEL_28;
      }
      v11[3].n128_f32[0] = a6;
      v11[3].n128_u64[1] = 0;
      v11[3].n128_u32[1] = 0;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v11[12] = a3;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      result = 1;
      break;
    case 4:
      v12 = (__n128 *)*((_QWORD *)this + 51);
      if (v12[4].n128_f32[0] == 0.0
        && v12[4].n128_f32[1] == a6
        && v12[4].n128_f32[2] == 0.0
        && v12[4].n128_f32[3] == 0.0)
      {
LABEL_28:
        result = 0;
      }
      else
      {
        v12[4].n128_u32[0] = 0;
        v12[4].n128_f32[1] = a6;
        a3.n128_f32[1] = a4;
        v12[4].n128_u64[1] = 0;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        v12[13] = a3;
        HGNode::ClearBits((HGNode *)this, a2, a7);
        result = 1;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

float HgcGradientRadialTranslate::GetParameter(HgcGradientRadialTranslate *this, int a2, float *a3)
{
  float *v3;
  float result;
  float *v5;
  float *v6;
  float *v7;
  float *v8;

  switch(a2)
  {
    case 0:
      v3 = (float *)*((_QWORD *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      result = v3[3];
      a3[3] = result;
      break;
    case 1:
      v5 = (float *)*((_QWORD *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      result = v5[7];
      a3[3] = result;
      break;
    case 2:
      v6 = (float *)*((_QWORD *)this + 51);
      *a3 = v6[8];
      a3[1] = v6[9];
      a3[2] = v6[10];
      result = v6[11];
      a3[3] = result;
      break;
    case 3:
      v7 = (float *)*((_QWORD *)this + 51);
      *a3 = v7[48];
      a3[1] = v7[49];
      a3[2] = v7[50];
      result = v7[51];
      a3[3] = result;
      break;
    case 4:
      v8 = (float *)*((_QWORD *)this + 51);
      *a3 = v8[52];
      a3[1] = v8[53];
      a3[2] = v8[54];
      result = v8[55];
      a3[3] = result;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcYUV444BiPlanar_601ToRGB::GetProgram(HgcYUV444BiPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e00be48:1d4c1030:c845256d:4f625dda\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e920bf17:693c75e5:4f148dce:a2580259\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=b28b84a9:65d97aa9:3bf19568:b311251d\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_601ToRGB::InitProgramDescriptor(HgcYUV444BiPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=000000027e\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BAEAA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BAEAD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BAEAD0);
}

char *HgcYUV444BiPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcYUV444BiPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::BindTexture(HgcYUV444BiPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::Bind(HgcYUV444BiPlanar_601ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV444BiPlanar_601ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::RenderTile(HgcYUV444BiPlanar_601ToRGB *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  int8x16_t *v20;
  int8x16_t *v21;
  uint64_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t *v36;
  float32x4_t *v37;
  float32x4_t *v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  uint64_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t v53;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 12);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 22);
    v9 = *((int *)a2 + 26);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v45 = 0;
        v46 = 16 * v9;
        v47 = 16 * v8;
        v48 = 16 * v7;
        v49 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v50 = 0;
          do
          {
            v51 = *((_QWORD *)this + 51);
            v52 = vaddq_f32(*(float32x4_t *)(v51 + 16), vmulq_f32(*(float32x4_t *)v51, (float32x4_t)vbslq_s8(*(int8x16_t *)(v51 + 32), v5[v50 / 0x10], vextq_s8(v4[v50 / 0x10], v4[v50 / 0x10], 0xCuLL))));
            v53 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v51 + 64), v52, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v51 + 48), *(float32x2_t *)v52.f32, 1)));
            v53.i32[3] = 1.0;
            v6[v50 / 0x10] = v53;
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          v4 = (int8x16_t *)((char *)v4 + v46);
          v5 = (int8x16_t *)((char *)v5 + v47);
          v6 = (float32x4_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = *((_QWORD *)this + 51);
          v23 = *(int8x16_t *)(v22 + 32);
          v24 = *(float32x4_t *)(v22 + 48);
          v25 = *(float32x4_t *)(v22 + 16);
          v26 = v21;
          v27 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17], vextq_s8(v4[v17], v4[v17], 0xCuLL))));
          v28 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 1], vextq_s8(v4[v17 + 1], v4[v17 + 1], 0xCuLL))));
          v29 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 2], vextq_s8(v4[v17 + 2], v4[v17 + 2], 0xCuLL))));
          v30 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 3], vextq_s8(v4[v17 + 3], v4[v17 + 3], 0xCuLL))));
          v31 = *(float32x4_t *)(v22 + 64);
          v32 = vaddq_f32(vmulq_laneq_f32(v31, v27, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v27.f32, 1)));
          v33 = vaddq_f32(vmulq_laneq_f32(v31, v28, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v28.f32, 1)));
          v34 = vaddq_f32(vmulq_laneq_f32(v31, v29, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v29.f32, 1)));
          v32.i32[3] = 1.0;
          v33.i32[3] = 1.0;
          v35 = vaddq_f32(vmulq_laneq_f32(v31, v30, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v30.f32, 1)));
          v34.i32[3] = 1.0;
          v35.i32[3] = 1.0;
          v36 = v20;
          v37 = v19;
          v38 = &v6[v17];
          v18 += 4;
          v17 += 4;
          *v38 = v32;
          v38[1] = v33;
          v38[2] = v34;
          v38[3] = v35;
          v21 += 4;
          v20 = v36 + 4;
          v19 += 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v39 = *v26++;
            v40 = vextq_s8(v39, v39, 0xCuLL);
            v41 = *v36++;
            v42 = *((_QWORD *)this + 51);
            v43 = vaddq_f32(*(float32x4_t *)(v42 + 16), vmulq_f32(*(float32x4_t *)v42, (float32x4_t)vbslq_s8(*(int8x16_t *)(v42 + 32), v41, v40)));
            v44 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v42 + 64), v43, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v42 + 48), *(float32x2_t *)v43.f32, 1)));
            v44.i32[3] = 1.0;
            *v37++ = v44;
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (int8x16_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (int8x16_t *)((char *)v4 + v13);
        v14 = (int8x16_t *)((char *)v14 + v13);
        v15 = (int8x16_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::GetDOD(HgcYUV444BiPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::GetROI(HgcYUV444BiPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444BiPlanar_601ToRGB::HgcYUV444BiPlanar_601ToRGB(HgcYUV444BiPlanar_601ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653D3B0;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AB0;
  v3[4] = xmmword_1B3552AC0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BAF000(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_601ToRGB::~HgcYUV444BiPlanar_601ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653D3B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653D3B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653D3B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_601ToRGB::SetParameter(HgcYUV444BiPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::GetParameter(HgcYUV444BiPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_709ToRGB::GetProgram(HgcYUV420BiPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1048caae:387a44ef:fc83ffd8:52b73979\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2408e641:b05fbd09:a6279793:e6b41496\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=50acfb20:dc59fe91:195acf38:f03e2245\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_709ToRGB::InitProgramDescriptor(HgcYUV420BiPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BAF624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BAF660(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BAF658);
}

char *HgcYUV420BiPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcYUV420BiPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::BindTexture(HgcYUV420BiPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::Bind(HgcYUV420BiPlanar_709ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV420BiPlanar_709ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::RenderTile(HgcYUV420BiPlanar_709ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v18;
  float32x4_t v19;
  int v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  __int32 v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  __int32 v35;
  __int32 v36;
  __int32 v37;
  int8x16_t v38;
  float32x4_t v39;
  int32x4_t v40;
  __int32 v41;
  __int32 v42;
  __int32 v43;
  int8x16_t v44;
  float32x4_t v45;
  int32x4_t v46;
  __int32 v47;
  __int32 v48;
  __int32 v49;
  int8x16_t v50;
  int8x16_t v51;
  uint64_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t *v65;
  uint64_t v66;
  float32x4_t v68;
  int32x4_t v69;
  uint64_t v70;
  float32x4_t v71;
  float32x4_t v72;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B30532D0);
    v8 = a2[2];
    v9 = a2[10];
    v10 = 16 * a2[11].i32[0];
    v11 = 16 * a2[3].i32[0];
    v12 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v19 = vaddq_f32(v7, vmulq_f32(v12, (float32x4_t)xmmword_1B30512C0));
      if (v6 >= 4)
        break;
      LODWORD(v66) = 0;
      v21 = 0uLL;
      __asm { FMOV            V18.4S, #1.0 }
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v12 = vaddq_f32(v12, _Q18);
      ++v4;
      *(_QWORD *)&v9 += v10;
      *(_QWORD *)&v8 += v11;
      if (v4 == v3)
        return 0;
    }
    v20 = 0;
    v21 = 0uLL;
    v22 = 32;
    do
    {
      v23 = vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[12];
      v28 = a2[13].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = v29.i32[1];
      v32 = v29.i32[0];
      v33 = vaddq_f32(vsubq_f32(v24, v5), v18);
      v34 = vcvtq_s32_f32(v33);
      v35 = v32 + v31 * v28;
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v36 = v33.i32[1];
      v37 = v33.i32[0];
      v38 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v35);
      v39 = vaddq_f32(vsubq_f32(v25, v5), v18);
      v40 = vcvtq_s32_f32(v39);
      v41 = v37 + v36 * v28;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      v42 = v39.i32[1];
      v43 = v39.i32[0];
      v44 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v41);
      v45 = vaddq_f32(vsubq_f32(v26, v5), v18);
      v46 = vcvtq_s32_f32(v45);
      v47 = v43 + v42 * v28;
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      v48 = v45.i32[1];
      v49 = v45.i32[0];
      v50 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v47);
      v51 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v49 + v48 * v28));
      v52 = *((_QWORD *)this + 51);
      v53 = *(int8x16_t *)(v52 + 32);
      v54 = *(float32x4_t *)(v52 + 48);
      v55 = *(float32x4_t *)(v52 + 16);
      v56 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 32), vextq_s8(v38, v38, 0xCuLL))));
      v57 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 16), vextq_s8(v44, v44, 0xCuLL))));
      v58 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22), vextq_s8(v50, v50, 0xCuLL))));
      v59 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 + 16), vextq_s8(v51, v51, 0xCuLL))));
      v21 = vaddq_f32(v21, _Q5);
      v60 = *(float32x4_t *)(v52 + 64);
      v61 = vaddq_f32(vmulq_laneq_f32(v60, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v56.f32, 1)));
      v62 = vaddq_f32(vmulq_laneq_f32(v60, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v57.f32, 1)));
      v63 = vaddq_f32(vmulq_laneq_f32(v60, v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v58.f32, 1)));
      v61.i32[3] = 1.0;
      v62.i32[3] = 1.0;
      v63.i32[3] = 1.0;
      v64 = vaddq_f32(vmulq_laneq_f32(v60, v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v59.f32, 1)));
      v64.i32[3] = 1.0;
      v65 = (float32x4_t *)(*(_QWORD *)&v8 + v22);
      v65[-2] = v61;
      v65[-1] = v62;
      *v65 = v63;
      v65[1] = v64;
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    __asm { FMOV            V18.4S, #1.0 }
    if ((int)v66 >= v6)
      goto LABEL_3;
LABEL_10:
    v66 = v66;
    do
    {
      v68 = vaddq_f32(vsubq_f32(vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v18);
      v69 = vcvtq_s32_f32(v68);
      v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
      v70 = *((_QWORD *)this + 51);
      v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v66), vextq_s8(*(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), 0xCuLL))));
      v72 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1)));
      v72.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v66) = v72;
      v21 = vaddq_f32(v21, _Q18);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::GetDOD(HgcYUV420BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::GetROI(HgcYUV420BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420BiPlanar_709ToRGB::HgcYUV420BiPlanar_709ToRGB(HgcYUV420BiPlanar_709ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653D618;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AF0;
  v3[4] = xmmword_1B3552B00;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420BiPlanar_709ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BAFDA4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_709ToRGB::~HgcYUV420BiPlanar_709ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653D618;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653D618;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653D618;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_709ToRGB::SetParameter(HgcYUV420BiPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::GetParameter(HgcYUV420BiPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_8::GetProgram(HgcMultiTexBlend_8 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000816\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]], \n"
             "    texture2d< half > hg_Texture7 [[ texture(7) ]], \n"
             "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r7 = (half4) hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    r0 = half4(hg_Params[1].xxxx)*r4 + r0;\n"
             "    r0 = half4(hg_Params[1].yyyy)*r5 + r0;\n"
             "    r0 = half4(hg_Params[1].zzzz)*r6 + r0;\n"
             "    output.color0 = hg_Params[1].wwww*float4(r7) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ba77e172:499d5e50:ba48f7a9:fb1ede91\n"
             "//SIG=00400000:000000ff:000000ff:000000ff:0000:0002:0008:0000:0000:0000:01fe:0000:0008:08:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000079e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]], \n"
             "    texture2d< float > hg_Texture7 [[ texture(7) ]], \n"
             "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r7 = hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
             "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
             "    r0 = hg_Params[1].zzzz*r6 + r0;\n"
             "    output.color0 = hg_Params[1].wwww*r7 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2d0b895:1047a73b:cf113545:5f20f4cb\n"
             "//SIG=00000000:000000ff:000000ff:00000000:0000:0002:0008:0000:0000:0000:01fe:0000:0008:08:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006b4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp sampler2D hg_Texture6;\n"
           "uniform defaultp sampler2D hg_Texture7;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "varying highp vec4 hg_TexCoord7;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
           "    r7 = texture2D(hg_Texture7, hg_TexCoord7.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    r0 = hg_ProgramLocal1.xxxx*r4 + r0;\n"
           "    r0 = hg_ProgramLocal1.yyyy*r5 + r0;\n"
           "    r0 = hg_ProgramLocal1.zzzz*r6 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1.wwww*r7 + r0;\n"
           "}\n"
           "//MD5=037c2ec9:d4a3ecf1:f512314e:ade30c08\n"
           "//SIG=00000000:000000ff:000000ff:00000000:0000:0002:0008:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
  }
}

void HgcMultiTexBlend_8::InitProgramDescriptor(HgcMultiTexBlend_8 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_8_hgc_visible", "//Metal1.0     \n//LEN=000000031d\n[[ visible ]] FragmentOut HgcMultiTexBlend_8_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5,\n    float4 color6,\n    float4 color7)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r6 = color6;\n"
    "    r7 = color7;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
    "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
    "    r0 = hg_Params[1].zzzz*r6 + r0;\n"
    "    output.color0 = hg_Params[1].wwww*r7 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB0628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB0674(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB066CLL);
}

double HgcMultiTexBlend_8::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_8 [hgc1]");
  return *(double *)"exBlend_8 [hgc1]";
}

uint64_t HgcMultiTexBlend_8::BindTexture(HgcMultiTexBlend_8 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_11;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_11;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_11;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_11;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
      goto LABEL_11;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 5;
      goto LABEL_11;
    case 6:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 6, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 6;
      goto LABEL_11;
    case 7:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 7, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 7;
LABEL_11:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_8::Bind(HgcMultiTexBlend_8 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcMultiTexBlend_8 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_8::RenderTile(HgcMultiTexBlend_8 *this, HGTile *a2)
{
  int v2;
  int v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  float32x4_t *v11;
  float32x4_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t *v37;
  float32x4_t *v38;
  float32x4_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  float32x4_t v50;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v8 = (float32x4_t *)*((_QWORD *)a2 + 18);
    v9 = (float32x4_t *)*((_QWORD *)a2 + 20);
    v10 = (float32x4_t *)*((_QWORD *)a2 + 22);
    v11 = (float32x4_t *)*((_QWORD *)a2 + 24);
    v12 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v13 = *((int *)a2 + 6);
    v14 = *((int *)a2 + 50);
    v15 = *((int *)a2 + 46);
    v16 = *((int *)a2 + 42);
    v17 = *((int *)a2 + 38);
    v18 = *((int *)a2 + 34);
    v19 = *((int *)a2 + 30);
    v20 = *((int *)a2 + 26);
    v21 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        v40 = 16 * v21;
        v41 = 16 * v19;
        v42 = 16 * v18;
        v43 = 16 * v17;
        v44 = 16 * v16;
        v45 = 16 * v15;
        v46 = 16 * v14;
        v47 = 16 * v13;
        do
        {
          v48 = (float32x4_t *)*((_QWORD *)this + 51);
          v49 = v48[1];
          v50 = vaddq_f32(vmulq_laneq_f32(*v10, v49, 2), vaddq_f32(vmulq_lane_f32(*v9, *(float32x2_t *)v49.f32, 1), vaddq_f32(vmulq_n_f32(*v8, v49.f32[0]), vaddq_f32(vmulq_laneq_f32(*v7, *v48, 3), vaddq_f32(vmulq_laneq_f32(*v6, *v48, 2), vaddq_f32(vmulq_n_f32(*v4, COERCE_FLOAT(*v48)), vmulq_lane_f32(*v5, *(float32x2_t *)v48->f32, 1)))))));
          v4 = (float32x4_t *)((char *)v4 + v40);
          v5 += v20;
          v6 = (float32x4_t *)((char *)v6 + v41);
          v7 = (float32x4_t *)((char *)v7 + v42);
          v8 = (float32x4_t *)((char *)v8 + v43);
          v9 = (float32x4_t *)((char *)v9 + v44);
          *v12 = vaddq_f32(vmulq_laneq_f32(*v11, v49, 3), v50);
          v10 = (float32x4_t *)((char *)v10 + v45);
          v11 = (float32x4_t *)((char *)v11 + v46);
          v12 = (float32x4_t *)((char *)v12 + v47);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      v22 = 0;
      v23 = 16 * v19;
      v24 = 16 * v18;
      v25 = 16 * v17;
      v26 = 16 * v16;
      v27 = 16 * v15;
      v28 = 16 * v14;
      v29 = 16 * v13;
      v30 = 16 * v21;
      v31 = 16 * v20;
      do
      {
        v32 = 0;
        v33 = 0;
        do
        {
          v34 = (float32x4_t *)*((_QWORD *)this + 51);
          v35 = v34[1];
          v36 = vaddq_f32(vmulq_laneq_f32(v11[v32 + 1], v35, 3), vaddq_f32(vmulq_laneq_f32(v10[v32 + 1], v35, 2), vaddq_f32(vmulq_lane_f32(v9[v32 + 1], *(float32x2_t *)v35.f32, 1), vaddq_f32(vmulq_n_f32(v8[v32 + 1], v35.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v32 + 1], *v34, 3), vaddq_f32(vmulq_laneq_f32(v6[v32 + 1], *v34, 2), vaddq_f32(vmulq_n_f32(v4[v32 + 1], COERCE_FLOAT(*v34)), vmulq_lane_f32(v5[v32 + 1], *(float32x2_t *)v34->f32, 1))))))));
          v37 = &v12[v32];
          *v37 = vaddq_f32(vmulq_laneq_f32(v11[v32], v35, 3), vaddq_f32(vmulq_laneq_f32(v10[v32], v35, 2), vaddq_f32(vmulq_lane_f32(v9[v32], *(float32x2_t *)v35.f32, 1), vaddq_f32(vmulq_n_f32(v8[v32], v35.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v32], *v34, 3), vaddq_f32(vmulq_laneq_f32(v6[v32], *v34, 2), vaddq_f32(vmulq_n_f32(v4[v32], COERCE_FLOAT(*v34)), vmulq_lane_f32(v5[v32], *(float32x2_t *)v34->f32, 1))))))));
          v37[1] = v36;
          v33 -= 2;
          v32 += 2;
        }
        while (v3 + v33 > 1);
        if (v3 > -v33)
        {
          v38 = (float32x4_t *)*((_QWORD *)this + 51);
          v39 = v38[1];
          v12[v32] = vaddq_f32(vmulq_laneq_f32(v11[v32], v39, 3), vaddq_f32(vmulq_laneq_f32(v10[v32], v39, 2), vaddq_f32(vmulq_lane_f32(v9[v32], *(float32x2_t *)v39.f32, 1), vaddq_f32(vmulq_n_f32(v8[v32], v39.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v32], *v38, 3), vaddq_f32(vmulq_laneq_f32(v6[v32], *v38, 2), vaddq_f32(vmulq_n_f32(v4[v32], COERCE_FLOAT(*v38)), vmulq_lane_f32(v5[v32], *(float32x2_t *)v38->f32, 1))))))));
        }
        ++v22;
        v6 = (float32x4_t *)((char *)v6 + v23);
        v7 = (float32x4_t *)((char *)v7 + v24);
        v8 = (float32x4_t *)((char *)v8 + v25);
        v9 = (float32x4_t *)((char *)v9 + v26);
        v10 = (float32x4_t *)((char *)v10 + v27);
        v11 = (float32x4_t *)((char *)v11 + v28);
        v12 = (float32x4_t *)((char *)v12 + v29);
        v4 = (float32x4_t *)((char *)v4 + v30);
        v5 = (float32x4_t *)((char *)v5 + v31);
      }
      while (v22 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_8::GetDOD(HgcMultiTexBlend_8 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_8::GetROI(HgcMultiTexBlend_8 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_8::HgcMultiTexBlend_8(HgcMultiTexBlend_8 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653D880;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB0D70(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_8::~HgcMultiTexBlend_8(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653D880;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653D880;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_8::SetParameter(HgcMultiTexBlend_8 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcMultiTexBlend_8::GetParameter(HgcMultiTexBlend_8 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_2::GetProgram(HgcMultiTexBlend_2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000318\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    output.color0 = hg_Params[0].yyyy*float4(r1) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6a73d4da:17adb56f:e7bd03ff:96b24d50\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002f4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    output.color0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e913d9e:9986742c:dfcf17ed:4ab82079\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002a2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    gl_FragColor = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "}\n"
           "//MD5=e2a4ad3f:8093be2a:11c9162f:b54ec260\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcMultiTexBlend_2::InitProgramDescriptor(HgcMultiTexBlend_2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_2_hgc_visible", "//Metal1.0     \n//LEN=0000000155\n[[ visible ]] FragmentOut HgcMultiTexBlend_2_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    output.color0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB121C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB1250(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB1248);
}

double HgcMultiTexBlend_2::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_2 [hgc1]");
  return *(double *)"exBlend_2 [hgc1]";
}

uint64_t HgcMultiTexBlend_2::BindTexture(HgcMultiTexBlend_2 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    if (a3)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcMultiTexBlend_2::Bind(HgcMultiTexBlend_2 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcMultiTexBlend_2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_2::RenderTile(HgcMultiTexBlend_2 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  float32x4_t *v16;
  unint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t *v24;
  __int128 v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 26);
    v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v33 = 0;
        v34 = 16 * v9;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(vmulq_n_f32(v4[v38 / 0x10], COERCE_FLOAT(*(_OWORD *)*((_QWORD *)this + 51))), vmulq_lane_f32(v5[v38 / 0x10], **((float32x2_t **)this + 51), 1));
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          v4 = (float32x4_t *)((char *)v4 + v34);
          v5 = (float32x4_t *)((char *)v5 + v35);
          v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = *(_OWORD *)*((_QWORD *)this + 51);
          v26 = vaddq_f32(vmulq_n_f32(v4[v17 + 1], *(float *)&v25), vmulq_lane_f32(v5[v17 + 1], *(float32x2_t *)&v25, 1));
          v27 = vaddq_f32(vmulq_n_f32(v4[v17 + 2], *(float *)&v25), vmulq_lane_f32(v5[v17 + 2], *(float32x2_t *)&v25, 1));
          v28 = vaddq_f32(vmulq_n_f32(v4[v17 + 3], *(float *)&v25), vmulq_lane_f32(v5[v17 + 3], *(float32x2_t *)&v25, 1));
          v29 = &v6[v17];
          *v29 = vaddq_f32(vmulq_n_f32(v4[v17], *(float *)&v25), vmulq_lane_f32(v5[v17], *(float32x2_t *)&v25, 1));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v30 = *v22++;
            v31 = v30;
            v32 = *v23++;
            *v24++ = vaddq_f32(vmulq_n_f32(v31, COERCE_FLOAT(*(_OWORD *)*((_QWORD *)this + 51))), vmulq_lane_f32(v32, **((float32x2_t **)this + 51), 1));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (float32x4_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (float32x4_t *)((char *)v4 + v13);
        v14 = (float32x4_t *)((char *)v14 + v13);
        v15 = (float32x4_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_2::GetDOD(HgcMultiTexBlend_2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_2::GetROI(HgcMultiTexBlend_2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_2::HgcMultiTexBlend_2(HgcMultiTexBlend_2 *this)
{
  _QWORD *v2;
  _QWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653DAE8;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB1670(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_2::~HgcMultiTexBlend_2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653DAE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653DAE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_2::SetParameter(HgcMultiTexBlend_2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcMultiTexBlend_2::GetParameter(HgcMultiTexBlend_2 *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcMultiTexBlend_5::GetProgram(HgcMultiTexBlend_5 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000592\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    output.color0 = hg_Params[1]*float4(r4) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ebe55f7:cd345d72:633071a4:844930c7\n"
             "//SIG=00400000:0000001f:0000001f:0000001f:0000:0002:0005:0000:0000:0000:003e:0000:0005:05:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000544\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    output.color0 = hg_Params[1]*r4 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4d49c78f:1cb5eac2:32689adf:f7a27f9e\n"
             "//SIG=00000000:0000001f:0000001f:00000000:0000:0002:0005:0000:0000:0000:003e:0000:0005:05:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ba\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1*r4 + r0;\n"
           "}\n"
           "//MD5=ae575d71:1ffff228:b9e973a0:e48fa370\n"
           "//SIG=00000000:0000001f:0000001f:00000000:0000:0002:0005:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
  }
}

void HgcMultiTexBlend_5::InitProgramDescriptor(HgcMultiTexBlend_5 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_5_hgc_visible", "//Metal1.0     \n//LEN=0000000234\n[[ visible ]] FragmentOut HgcMultiTexBlend_5_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    output.color0 = hg_Params[1]*r4 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB1CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB1D00(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB1CF8);
}

double HgcMultiTexBlend_5::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_5 [hgc1]");
  return *(double *)"exBlend_5 [hgc1]";
}

uint64_t HgcMultiTexBlend_5::BindTexture(HgcMultiTexBlend_5 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_8;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_8;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_8;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_8;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
LABEL_8:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_5::Bind(HgcMultiTexBlend_5 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcMultiTexBlend_5 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_5::RenderTile(HgcMultiTexBlend_5 *this, HGTile *a2)
{
  uint64_t v2;
  float32x4_t *v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  float32x4_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  float32x4_t *v16;
  float32x4_t *v17;
  float32x4_t *v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  float32x4_t *v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  float32x4_t *v32;
  float32x4_t *v33;
  float32x4_t *v34;
  int v35;
  float32x4_t *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t *v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t *v51;
  float32x4_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  float32x4_t *v62;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  float32x4_t *v71;
  float32x4_t *v72;
  int v73;

  v70 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v70 >= 1)
  {
    v2 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v3 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 18);
    v8 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v9 = *((int *)a2 + 6);
    v10 = *((int *)a2 + 38);
    v11 = *((int *)a2 + 34);
    v12 = *((int *)a2 + 30);
    v13 = *((int *)a2 + 26);
    v14 = *((int *)a2 + 22);
    if ((int)v2 < 3)
    {
      if ((int)v2 >= 1)
      {
        v53 = 0;
        v54 = 16 * v14;
        v55 = 16 * v13;
        v56 = 16 * v12;
        v57 = 16 * v11;
        v58 = 16 * v10;
        v59 = 16 * v9;
        v60 = 16 * v2;
        do
        {
          v61 = 0;
          do
          {
            v62 = (float32x4_t *)*((_QWORD *)this + 51);
            v8[v61 / 0x10] = vaddq_f32(vmulq_f32(v7[v61 / 0x10], v62[1]), vaddq_f32(vmulq_laneq_f32(v6[v61 / 0x10], *v62, 3), vaddq_f32(vmulq_laneq_f32(v5[v61 / 0x10], *v62, 2), vaddq_f32(vmulq_n_f32(v3[v61 / 0x10], COERCE_FLOAT(*v62)), vmulq_lane_f32(v4[v61 / 0x10], *(float32x2_t *)v62->f32, 1)))));
            v61 += 16;
          }
          while (v60 != v61);
          ++v53;
          v3 = (float32x4_t *)((char *)v3 + v54);
          v4 = (float32x4_t *)((char *)v4 + v55);
          v5 = (float32x4_t *)((char *)v5 + v56);
          v6 = (float32x4_t *)((char *)v6 + v57);
          v7 = (float32x4_t *)((char *)v7 + v58);
          v8 = (float32x4_t *)((char *)v8 + v59);
        }
        while (v53 != v70);
      }
    }
    else
    {
      v15 = 0;
      v69 = v13;
      v68 = 16 * v12;
      v67 = 16 * v11;
      v16 = v3 + 3;
      v66 = 16 * v10;
      v17 = v4 + 3;
      v65 = 16 * v9;
      v18 = v5 + 3;
      v64 = v14;
      v19 = v6 + 3;
      v20 = v7 + 3;
      v21 = v8 + 3;
      do
      {
        v73 = v15;
        v22 = 0;
        v23 = 0;
        v24 = 3;
        v25 = v21;
        v26 = v20;
        v27 = v19;
        v28 = v18;
        v71 = v17;
        v72 = v16;
        do
        {
          v29 = v16;
          v30 = v17;
          v31 = v28;
          v32 = v27;
          v33 = v26;
          v34 = v25;
          v35 = v24;
          v36 = (float32x4_t *)*((_QWORD *)this + 51);
          v37 = v36[1];
          v38 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 2], *v36, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 2], *v36, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 2], COERCE_FLOAT(*v36)), vmulq_lane_f32(v4[v22 + 2], *(float32x2_t *)v36->f32, 1))));
          v39 = vaddq_f32(vmulq_f32(v7[v22], v37), vaddq_f32(vmulq_laneq_f32(v6[v22], *v36, 3), vaddq_f32(vmulq_laneq_f32(v5[v22], *v36, 2), vaddq_f32(vmulq_n_f32(v3[v22], COERCE_FLOAT(*v36)), vmulq_lane_f32(v4[v22], *(float32x2_t *)v36->f32, 1)))));
          v40 = vaddq_f32(vmulq_f32(v7[v22 + 1], v37), vaddq_f32(vmulq_laneq_f32(v6[v22 + 1], *v36, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 1], *v36, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 1], COERCE_FLOAT(*v36)), vmulq_lane_f32(v4[v22 + 1], *(float32x2_t *)v36->f32, 1)))));
          v41 = vmulq_f32(v7[v22 + 2], v37);
          v42 = &v8[v22];
          v23 += 3;
          v22 += 3;
          v16 = v29 + 3;
          v17 += 3;
          v28 += 3;
          v27 += 3;
          *v42 = v39;
          v42[1] = v40;
          v42[2] = vaddq_f32(v41, v38);
          v26 += 3;
          v25 += 3;
          v24 = v35 + 3;
        }
        while (v23 < v2 - 2);
        if ((int)v2 > (int)v23)
        {
          do
          {
            v43 = *v29++;
            v44 = v43;
            v45 = *v30++;
            v46 = v45;
            v47 = *v31++;
            v48 = v47;
            v49 = *v32++;
            v50 = v49;
            v51 = (float32x4_t *)*((_QWORD *)this + 51);
            v52 = *v33++;
            *v34++ = vaddq_f32(vmulq_f32(v52, v51[1]), vaddq_f32(vmulq_laneq_f32(v50, *v51, 3), vaddq_f32(vmulq_laneq_f32(v48, *v51, 2), vaddq_f32(vmulq_n_f32(v44, COERCE_FLOAT(*v51)), vmulq_lane_f32(v46, *(float32x2_t *)v51->f32, 1)))));
            ++v35;
          }
          while ((int)v2 > v35);
        }
        v15 = v73 + 1;
        v4 = (float32x4_t *)((char *)v4 + v69 * 16);
        v5 = (float32x4_t *)((char *)v5 + v68);
        v6 = (float32x4_t *)((char *)v6 + v67);
        v7 = (float32x4_t *)((char *)v7 + v66);
        v8 = (float32x4_t *)((char *)v8 + v65);
        v3 = (float32x4_t *)((char *)v3 + v64 * 16);
        v16 = &v72[v64];
        v17 = &v71[v69];
        v18 = (float32x4_t *)((char *)v18 + v68);
        v19 = (float32x4_t *)((char *)v19 + v67);
        v20 = (float32x4_t *)((char *)v20 + v66);
        v21 = (float32x4_t *)((char *)v21 + v65);
      }
      while (v73 + 1 != v70);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_5::GetDOD(HgcMultiTexBlend_5 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 5)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_5::GetROI(HgcMultiTexBlend_5 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 5)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_5::HgcMultiTexBlend_5(HgcMultiTexBlend_5 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653DD50;
  v3 = (_OWORD *)operator new();
  v3[1] = 0u;
  v3[2] = 0u;
  *v3 = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB23A8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_5::~HgcMultiTexBlend_5(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653DD50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653DD50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_5::SetParameter(HgcMultiTexBlend_5 *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  uint64_t v9;
  int32x4_t v10;

  if ((_DWORD)a2 == 1)
  {
    v9 = *((_QWORD *)this + 51);
    if (*(float *)(v9 + 16) != a3.n128_f32[0]
      || *(float *)(v9 + 20) != a3.n128_f32[0]
      || *(float *)(v9 + 24) != a3.n128_f32[0]
      || *(float *)(v9 + 28) != a3.n128_f32[0])
    {
      v10 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(int32x4_t *)(v9 + 16) = v10;
      *(__n128 *)(v9 + 32) = a3;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
  }
  else
  {
    if ((_DWORD)a2)
      return 0xFFFFFFFFLL;
    v7 = *((_QWORD *)this + 51);
    if (*(float *)v7 != a3.n128_f32[0]
      || *(float *)(v7 + 4) != a4
      || *(float *)(v7 + 8) != a5
      || *(float *)(v7 + 12) != a6)
    {
      *(_DWORD *)v7 = a3.n128_u32[0];
      *(float *)(v7 + 4) = a4;
      *(float *)(v7 + 8) = a5;
      *(float *)(v7 + 12) = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_5::GetParameter(HgcMultiTexBlend_5 *this, int a2, float *a3)
{
  float *v3;
  uint64_t result;
  float *v5;

  if (a2 == 1)
  {
    v5 = (float *)*((_QWORD *)this + 51);
    *a3 = v5[8];
    a3[1] = v5[9];
    a3[2] = v5[10];
    result = 0;
    a3[3] = v5[11];
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = 0;
    a3[3] = v3[3];
  }
  return result;
}

const char *HgcYUV444BiPlanar_709ToRGB::GetProgram(HgcYUV444BiPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1048caae:387a44ef:fc83ffd8:52b73979\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2408e641:b05fbd09:a6279793:e6b41496\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=50acfb20:dc59fe91:195acf38:f03e2245\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_709ToRGB::InitProgramDescriptor(HgcYUV444BiPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=000000027e\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB28C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB28F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB28F0);
}

char *HgcYUV444BiPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcYUV444BiPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::BindTexture(HgcYUV444BiPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::Bind(HgcYUV444BiPlanar_709ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV444BiPlanar_709ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::RenderTile(HgcYUV444BiPlanar_709ToRGB *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  int8x16_t *v4;
  int8x16_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  float32x4_t *v16;
  uint64_t v17;
  unint64_t v18;
  float32x4_t *v19;
  int8x16_t *v20;
  int8x16_t *v21;
  uint64_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t *v36;
  float32x4_t *v37;
  float32x4_t *v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  uint64_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  float32x4_t v52;
  float32x4_t v53;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (int8x16_t *)*((_QWORD *)a2 + 12);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 10);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v7 = *((int *)a2 + 6);
    v8 = *((int *)a2 + 22);
    v9 = *((int *)a2 + 26);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v45 = 0;
        v46 = 16 * v9;
        v47 = 16 * v8;
        v48 = 16 * v7;
        v49 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v50 = 0;
          do
          {
            v51 = *((_QWORD *)this + 51);
            v52 = vaddq_f32(*(float32x4_t *)(v51 + 16), vmulq_f32(*(float32x4_t *)v51, (float32x4_t)vbslq_s8(*(int8x16_t *)(v51 + 32), v5[v50 / 0x10], vextq_s8(v4[v50 / 0x10], v4[v50 / 0x10], 0xCuLL))));
            v53 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v51 + 64), v52, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v51 + 48), *(float32x2_t *)v52.f32, 1)));
            v53.i32[3] = 1.0;
            v6[v50 / 0x10] = v53;
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          v4 = (int8x16_t *)((char *)v4 + v46);
          v5 = (int8x16_t *)((char *)v5 + v47);
          v6 = (float32x4_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = *((_QWORD *)this + 51);
          v23 = *(int8x16_t *)(v22 + 32);
          v24 = *(float32x4_t *)(v22 + 48);
          v25 = *(float32x4_t *)(v22 + 16);
          v26 = v21;
          v27 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17], vextq_s8(v4[v17], v4[v17], 0xCuLL))));
          v28 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 1], vextq_s8(v4[v17 + 1], v4[v17 + 1], 0xCuLL))));
          v29 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 2], vextq_s8(v4[v17 + 2], v4[v17 + 2], 0xCuLL))));
          v30 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 3], vextq_s8(v4[v17 + 3], v4[v17 + 3], 0xCuLL))));
          v31 = *(float32x4_t *)(v22 + 64);
          v32 = vaddq_f32(vmulq_laneq_f32(v31, v27, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v27.f32, 1)));
          v33 = vaddq_f32(vmulq_laneq_f32(v31, v28, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v28.f32, 1)));
          v34 = vaddq_f32(vmulq_laneq_f32(v31, v29, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v29.f32, 1)));
          v32.i32[3] = 1.0;
          v33.i32[3] = 1.0;
          v35 = vaddq_f32(vmulq_laneq_f32(v31, v30, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v30.f32, 1)));
          v34.i32[3] = 1.0;
          v35.i32[3] = 1.0;
          v36 = v20;
          v37 = v19;
          v38 = &v6[v17];
          v18 += 4;
          v17 += 4;
          *v38 = v32;
          v38[1] = v33;
          v38[2] = v34;
          v38[3] = v35;
          v21 += 4;
          v20 = v36 + 4;
          v19 += 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            v39 = *v26++;
            v40 = vextq_s8(v39, v39, 0xCuLL);
            v41 = *v36++;
            v42 = *((_QWORD *)this + 51);
            v43 = vaddq_f32(*(float32x4_t *)(v42 + 16), vmulq_f32(*(float32x4_t *)v42, (float32x4_t)vbslq_s8(*(int8x16_t *)(v42 + 32), v41, v40)));
            v44 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v42 + 64), v43, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v42 + 48), *(float32x2_t *)v43.f32, 1)));
            v44.i32[3] = 1.0;
            *v37++ = v44;
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        v5 = (int8x16_t *)((char *)v5 + v11);
        v6 = (float32x4_t *)((char *)v6 + v12);
        v4 = (int8x16_t *)((char *)v4 + v13);
        v14 = (int8x16_t *)((char *)v14 + v13);
        v15 = (int8x16_t *)((char *)v15 + v11);
        v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::GetDOD(HgcYUV444BiPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::GetROI(HgcYUV444BiPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcYUV444BiPlanar_709ToRGB::HgcYUV444BiPlanar_709ToRGB(HgcYUV444BiPlanar_709ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653DFB8;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AF0;
  v3[4] = xmmword_1B3552B00;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB2E20(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_709ToRGB::~HgcYUV444BiPlanar_709ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653DFB8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653DFB8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653DFB8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_709ToRGB::SetParameter(HgcYUV444BiPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::GetParameter(HgcYUV444BiPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorClamp::GetProgram(HgcColorClamp *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000265\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmin(r0, half4(hg_Params[0]));\n"
             "    output.color0 = fmax(float4(r0), hg_Params[1]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1fa9eff4:6b098975:051c3a71:ce7e3a5d\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000250\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmin(r0, hg_Params[0]);\n"
             "    output.color0 = fmax(r0, hg_Params[1]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8bd8f6b7:d61ba1b5:de97aeb6:868bcdb1\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000248\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = min(r0, hg_ProgramLocal0);\n"
           "    gl_FragColor = max(r0, hg_ProgramLocal1);\n"
           "}\n"
           "//MD5=b29813de:3fb28b2e:1d30ba03:4d6a0c54\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorClamp::InitProgramDescriptor(HgcColorClamp *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorClamp_hgc_visible", "//Metal1.0     \n//LEN=0000000127\n[[ visible ]] FragmentOut HgcColorClamp_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmin(r0, hg_Params[0]);\n"
    "    output.color0 = fmax(r0, hg_Params[1]);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB327C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB32AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB32A4);
}

void HgcColorClamp::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcColorClamp [hgc1]");
}

uint64_t HgcColorClamp::BindTexture(HgcColorClamp *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorClamp::Bind(HgcColorClamp *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcColorClamp *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorClamp::RenderTile(HgcColorClamp *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t *v12;
  unint64_t v13;
  float32x4_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v27 = 0;
        v28 = 16 * v7;
        v29 = 16 * v6;
        v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v31 = 0;
          do
          {
            v5[v31 / 0x10] = vmaxq_f32(vminq_f32(v4[v31 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51)), *(float32x4_t *)(*((_QWORD *)this + 51) + 16));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          v4 = (float32x4_t *)((char *)v4 + v28);
          v5 = (float32x4_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = (float32x4_t *)*((_QWORD *)this + 51);
          v18 = v17[1];
          v19 = vminq_f32(v4[v16 - 2], *v17);
          v20 = vminq_f32(v4[v16 - 1], *v17);
          v21 = vminq_f32(v4[v16], *v17);
          v22 = vminq_f32(v4[v16 + 1], *v17);
          v23 = v15;
          v24 = v14;
          v25 = &v5[v16];
          v25[-2] = vmaxq_f32(v19, v18);
          v25[-1] = vmaxq_f32(v20, v18);
          v13 += 4;
          *v25 = vmaxq_f32(v21, v18);
          v25[1] = vmaxq_f32(v22, v18);
          v16 += 4;
          v15 = v23 + 4;
          v14 += 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v26 = *v23++;
            *v24++ = vmaxq_f32(vminq_f32(v26, *(float32x4_t *)*((_QWORD *)this + 51)), *(float32x4_t *)(*((_QWORD *)this + 51) + 16));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (float32x4_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorClamp::GetDOD(HgcColorClamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcColorClamp::GetROI(HgcColorClamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcColorClamp::HgcColorClamp(HgcColorClamp *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653E220;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB3618(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorClamp::~HgcColorClamp(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653E220;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653E220;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorClamp::SetParameter(HgcColorClamp *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcColorClamp::GetParameter(HgcColorClamp *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_4::GetProgram(HgcMultiTexBlend_4 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000004c2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    output.color0 = hg_Params[0].wwww*float4(r3) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1a6c17cb:31f0a26b:ade5145e:0414ab15\n"
             "//SIG=00400000:0000000f:0000000f:0000000f:0000:0001:0004:0000:0000:0000:001e:0000:0004:04:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000482\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    output.color0 = hg_Params[0].wwww*r3 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5298a64d:65565521:895e2114:65f6560f\n"
             "//SIG=00000000:0000000f:0000000f:00000000:0000:0001:0004:0000:0000:0000:001e:0000:0004:04:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "}\n"
           "//MD5=57e6a43b:2edcb015:005cc30e:7898f273\n"
           "//SIG=00000000:0000000f:0000000f:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
  }
}

void HgcMultiTexBlend_4::InitProgramDescriptor(HgcMultiTexBlend_4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_4_hgc_visible", "//Metal1.0     \n//LEN=00000001ed\n[[ visible ]] FragmentOut HgcMultiTexBlend_4_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    output.color0 = hg_Params[0].wwww*r3 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB3BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB3C30(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB3C28);
}

double HgcMultiTexBlend_4::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_4 [hgc1]");
  return *(double *)"exBlend_4 [hgc1]";
}

uint64_t HgcMultiTexBlend_4::BindTexture(HgcMultiTexBlend_4 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_7;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_7;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_7;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
LABEL_7:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_4::Bind(HgcMultiTexBlend_4 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcMultiTexBlend_4 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_4::RenderTile(HgcMultiTexBlend_4 *this, HGTile *a2)
{
  unint64_t v2;
  float32x4_t *v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t *v17;
  uint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  float32x4_t *v21;
  unint64_t v22;
  unint64_t v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  float32x4_t *v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t *v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v53;
  uint64_t v54;
  int v55;

  v55 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v55 >= 1)
  {
    v2 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v3 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 34);
    v10 = *((int *)a2 + 30);
    v11 = *((int *)a2 + 26);
    v12 = *((int *)a2 + 22);
    if ((int)v2 < 4)
    {
      if ((int)v2 >= 1)
      {
        v46 = 0;
        v47 = 16 * v10;
        v48 = 16 * v9;
        v49 = 16 * v8;
        v50 = 16 * v2;
        do
        {
          v51 = 0;
          do
          {
            v7[v51 / 0x10] = vaddq_f32(vmulq_laneq_f32(v6[v51 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51), 3), vaddq_f32(vmulq_laneq_f32(v5[v51 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51), 2), vaddq_f32(vmulq_n_f32(v3[v51 / 0x10], COERCE_FLOAT(*(_OWORD *)*((_QWORD *)this + 51))), vmulq_lane_f32(v4[v51 / 0x10], **((float32x2_t **)this + 51), 1))));
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          v3 += v12;
          v4 += v11;
          v5 = (float32x4_t *)((char *)v5 + v47);
          v6 = (float32x4_t *)((char *)v6 + v48);
          v7 = (float32x4_t *)((char *)v7 + v49);
        }
        while (v46 != v55);
      }
    }
    else
    {
      v13 = 0;
      v53 = 16 * v10;
      v54 = 16 * v11;
      v14 = 16 * v9;
      v15 = v3 + 4;
      v16 = 16 * v8;
      v17 = v4 + 4;
      v18 = 16 * v12;
      v19 = v5 + 4;
      v20 = v6 + 4;
      v21 = v7 + 4;
      do
      {
        v22 = 0;
        v23 = 0;
        v24 = v21;
        v25 = v20;
        v26 = v19;
        v27 = v17;
        v28 = v15;
        do
        {
          v29 = v28;
          v30 = v27;
          v31 = v26;
          v32 = v25;
          v33 = v24;
          v34 = *(float32x4_t *)*((_QWORD *)this + 51);
          v35 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 1], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 1], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 1], v34.f32[0]), vmulq_lane_f32(v4[v22 + 1], *(float32x2_t *)v34.f32, 1))));
          v36 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 2], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 2], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 2], v34.f32[0]), vmulq_lane_f32(v4[v22 + 2], *(float32x2_t *)v34.f32, 1))));
          v37 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 3], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 3], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 3], v34.f32[0]), vmulq_lane_f32(v4[v22 + 3], *(float32x2_t *)v34.f32, 1))));
          v38 = &v7[v22];
          *v38 = vaddq_f32(vmulq_laneq_f32(v6[v22], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22], v34.f32[0]), vmulq_lane_f32(v4[v22], *(float32x2_t *)v34.f32, 1))));
          v38[1] = v35;
          v23 += 4;
          v22 += 4;
          v28 += 4;
          v27 += 4;
          v38[2] = v36;
          v38[3] = v37;
          v26 = v31 + 4;
          v25 += 4;
          v24 += 4;
        }
        while ((uint64_t)v23 < (uint64_t)(v2 - 3));
        if ((int)v2 > (int)v23)
        {
          do
          {
            v39 = *v29++;
            v40 = v39;
            v41 = *v30++;
            v42 = v41;
            v43 = *v31++;
            v44 = v43;
            v45 = *v32++;
            *v33++ = vaddq_f32(vmulq_laneq_f32(v45, *(float32x4_t *)*((_QWORD *)this + 51), 3), vaddq_f32(vmulq_laneq_f32(v44, *(float32x4_t *)*((_QWORD *)this + 51), 2), vaddq_f32(vmulq_n_f32(v40, COERCE_FLOAT(*(_OWORD *)*((_QWORD *)this + 51))), vmulq_lane_f32(v42, **((float32x2_t **)this + 51), 1))));
            ++v23;
          }
          while (v23 < v2);
        }
        ++v13;
        v4 = (float32x4_t *)((char *)v4 + v54);
        v5 = (float32x4_t *)((char *)v5 + v53);
        v6 = (float32x4_t *)((char *)v6 + v14);
        v7 = (float32x4_t *)((char *)v7 + v16);
        v3 = (float32x4_t *)((char *)v3 + v18);
        v15 = (float32x4_t *)((char *)v15 + v18);
        v17 = (float32x4_t *)((char *)v17 + v54);
        v19 = (float32x4_t *)((char *)v19 + v53);
        v20 = (float32x4_t *)((char *)v20 + v14);
        v21 = (float32x4_t *)((char *)v21 + v16);
      }
      while (v13 != v55);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_4::GetDOD(HgcMultiTexBlend_4 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 4)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_4::GetROI(HgcMultiTexBlend_4 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 4)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_4::HgcMultiTexBlend_4(HgcMultiTexBlend_4 *this)
{
  _QWORD *v2;
  _QWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653E488;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB41F8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_4::~HgcMultiTexBlend_4(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653E488;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653E488;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_4::SetParameter(HgcMultiTexBlend_4 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcMultiTexBlend_4::GetParameter(HgcMultiTexBlend_4 *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcMultiTexBlend_7::GetProgram(HgcMultiTexBlend_7 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000741\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    r0 = half4(hg_Params[1].xxxx)*r4 + r0;\n"
             "    r0 = half4(hg_Params[1].yyyy)*r5 + r0;\n"
             "    output.color0 = hg_Params[1].zzzz*float4(r6) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0919c6bd:8f8b1602:660b36e3:90776682\n"
             "//SIG=00400000:0000007f:0000007f:0000007f:0000:0002:0007:0000:0000:0000:00fe:0000:0007:07:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000006d7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
             "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
             "    output.color0 = hg_Params[1].zzzz*r6 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91d90a23:e17307a0:56e74a97:fbca53d8\n"
             "//SIG=00000000:0000007f:0000007f:00000000:0000:0002:0007:0000:0000:0000:00fe:0000:0007:07:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000060d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp sampler2D hg_Texture6;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    r0 = hg_ProgramLocal1.xxxx*r4 + r0;\n"
           "    r0 = hg_ProgramLocal1.yyyy*r5 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1.zzzz*r6 + r0;\n"
           "}\n"
           "//MD5=f1f5c9f2:cb3caeb2:b31a6ebb:ceea2000\n"
           "//SIG=00000000:0000007f:0000007f:00000000:0000:0002:0007:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
  }
}

void HgcMultiTexBlend_7::InitProgramDescriptor(HgcMultiTexBlend_7 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_7_hgc_visible", "//Metal1.0     \n//LEN=00000002d1\n[[ visible ]] FragmentOut HgcMultiTexBlend_7_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5,\n    float4 color6)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r6 = color6;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
    "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
    "    output.color0 = hg_Params[1].zzzz*r6 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB4978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB49C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB49B8);
}

double HgcMultiTexBlend_7::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_7 [hgc1]");
  return *(double *)"exBlend_7 [hgc1]";
}

uint64_t HgcMultiTexBlend_7::BindTexture(HgcMultiTexBlend_7 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_10;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_10;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_10;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_10;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
      goto LABEL_10;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 5;
      goto LABEL_10;
    case 6:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 6, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 6;
LABEL_10:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_7::Bind(HgcMultiTexBlend_7 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcMultiTexBlend_7 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_7::RenderTile(HgcMultiTexBlend_7 *this, HGTile *a2)
{
  int v2;
  int v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  float32x4_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t *v35;
  float32x4_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float32x4_t *v44;
  float32x4_t v45;
  float32x4_t v46;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v8 = (float32x4_t *)*((_QWORD *)a2 + 18);
    v9 = (float32x4_t *)*((_QWORD *)a2 + 20);
    v10 = (float32x4_t *)*((_QWORD *)a2 + 22);
    v11 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v12 = *((int *)a2 + 6);
    v13 = *((int *)a2 + 46);
    v14 = *((int *)a2 + 42);
    v15 = *((int *)a2 + 38);
    v16 = *((int *)a2 + 34);
    v17 = *((int *)a2 + 30);
    v18 = *((int *)a2 + 26);
    v19 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        v37 = 16 * v19;
        v38 = 16 * v17;
        v39 = 16 * v16;
        v40 = 16 * v15;
        v41 = 16 * v14;
        v42 = 16 * v13;
        v43 = 16 * v12;
        do
        {
          v44 = (float32x4_t *)*((_QWORD *)this + 51);
          v45 = v44[1];
          v46 = vaddq_f32(vmulq_lane_f32(*v9, *(float32x2_t *)v45.f32, 1), vaddq_f32(vmulq_n_f32(*v8, v45.f32[0]), vaddq_f32(vmulq_laneq_f32(*v7, *v44, 3), vaddq_f32(vmulq_laneq_f32(*v6, *v44, 2), vaddq_f32(vmulq_n_f32(*v4, COERCE_FLOAT(*v44)), vmulq_lane_f32(*v5, *(float32x2_t *)v44->f32, 1))))));
          v4 = (float32x4_t *)((char *)v4 + v37);
          v5 += v18;
          v6 = (float32x4_t *)((char *)v6 + v38);
          v7 = (float32x4_t *)((char *)v7 + v39);
          v8 = (float32x4_t *)((char *)v8 + v40);
          *v11 = vaddq_f32(vmulq_laneq_f32(*v10, v45, 2), v46);
          v9 = (float32x4_t *)((char *)v9 + v41);
          v10 = (float32x4_t *)((char *)v10 + v42);
          v11 = (float32x4_t *)((char *)v11 + v43);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      v20 = 0;
      v21 = 16 * v17;
      v22 = 16 * v16;
      v23 = 16 * v15;
      v24 = 16 * v14;
      v25 = 16 * v13;
      v26 = 16 * v12;
      v27 = 16 * v19;
      v28 = 16 * v18;
      do
      {
        v29 = 0;
        v30 = 0;
        do
        {
          v31 = (float32x4_t *)*((_QWORD *)this + 51);
          v32 = v31[1];
          v33 = vaddq_f32(vmulq_laneq_f32(v10[v29], v32, 2), vaddq_f32(vmulq_lane_f32(v9[v29], *(float32x2_t *)v32.f32, 1), vaddq_f32(vmulq_n_f32(v8[v29], v32.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v29], *v31, 3), vaddq_f32(vmulq_laneq_f32(v6[v29], *v31, 2), vaddq_f32(vmulq_n_f32(v4[v29], COERCE_FLOAT(*v31)), vmulq_lane_f32(v5[v29], *(float32x2_t *)v31->f32, 1)))))));
          v34 = vaddq_f32(vmulq_laneq_f32(v10[v29 + 1], v32, 2), vaddq_f32(vmulq_lane_f32(v9[v29 + 1], *(float32x2_t *)v32.f32, 1), vaddq_f32(vmulq_n_f32(v8[v29 + 1], v32.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v29 + 1], *v31, 3), vaddq_f32(vmulq_laneq_f32(v6[v29 + 1], *v31, 2), vaddq_f32(vmulq_n_f32(v4[v29 + 1], COERCE_FLOAT(*v31)), vmulq_lane_f32(v5[v29 + 1], *(float32x2_t *)v31->f32, 1)))))));
          v35 = &v11[v29];
          *v35 = v33;
          v35[1] = v34;
          v30 -= 2;
          v29 += 2;
        }
        while (v3 + v30 > 1);
        if (v3 > -v30)
        {
          v36 = (float32x4_t *)*((_QWORD *)this + 51);
          v11[v29] = vaddq_f32(vmulq_laneq_f32(v10[v29], v36[1], 2), vaddq_f32(vmulq_lane_f32(v9[v29], *(float32x2_t *)v36[1].f32, 1), vaddq_f32(vmulq_n_f32(v8[v29], COERCE_FLOAT(*(_OWORD *)&v36[1])), vaddq_f32(vmulq_laneq_f32(v7[v29], *v36, 3), vaddq_f32(vmulq_laneq_f32(v6[v29], *v36, 2), vaddq_f32(vmulq_n_f32(v4[v29], COERCE_FLOAT(*v36)), vmulq_lane_f32(v5[v29], *(float32x2_t *)v36->f32, 1)))))));
        }
        ++v20;
        v6 = (float32x4_t *)((char *)v6 + v21);
        v7 = (float32x4_t *)((char *)v7 + v22);
        v8 = (float32x4_t *)((char *)v8 + v23);
        v9 = (float32x4_t *)((char *)v9 + v24);
        v10 = (float32x4_t *)((char *)v10 + v25);
        v11 = (float32x4_t *)((char *)v11 + v26);
        v4 = (float32x4_t *)((char *)v4 + v27);
        v5 = (float32x4_t *)((char *)v5 + v28);
      }
      while (v20 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_7::GetDOD(HgcMultiTexBlend_7 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 7)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_7::GetROI(HgcMultiTexBlend_7 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 7)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_7::HgcMultiTexBlend_7(HgcMultiTexBlend_7 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653E6F0;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB5030(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_7::~HgcMultiTexBlend_7(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653E6F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653E6F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_7::SetParameter(HgcMultiTexBlend_7 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcMultiTexBlend_7::GetParameter(HgcMultiTexBlend_7 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_601ToRGB::GetProgram(HgcYUV420BiPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e00be48:1d4c1030:c845256d:4f625dda\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e920bf17:693c75e5:4f148dce:a2580259\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=b28b84a9:65d97aa9:3bf19568:b311251d\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_601ToRGB::InitProgramDescriptor(HgcYUV420BiPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB560C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB5648(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB5640);
}

char *HgcYUV420BiPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcYUV420BiPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::BindTexture(HgcYUV420BiPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
    result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::Bind(HgcYUV420BiPlanar_601ToRGB *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcYUV420BiPlanar_601ToRGB *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::RenderTile(HgcYUV420BiPlanar_601ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  float32x4_t v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v18;
  float32x4_t v19;
  int v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x2_t v27;
  __int32 v28;
  float32x4_t v29;
  int32x4_t v30;
  __int32 v31;
  __int32 v32;
  float32x4_t v33;
  int32x4_t v34;
  __int32 v35;
  __int32 v36;
  __int32 v37;
  int8x16_t v38;
  float32x4_t v39;
  int32x4_t v40;
  __int32 v41;
  __int32 v42;
  __int32 v43;
  int8x16_t v44;
  float32x4_t v45;
  int32x4_t v46;
  __int32 v47;
  __int32 v48;
  __int32 v49;
  int8x16_t v50;
  int8x16_t v51;
  uint64_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t *v65;
  uint64_t v66;
  float32x4_t v68;
  int32x4_t v69;
  uint64_t v70;
  float32x4_t v71;
  float32x4_t v72;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B30532D0);
    v8 = a2[2];
    v9 = a2[10];
    v10 = 16 * a2[11].i32[0];
    v11 = 16 * a2[3].i32[0];
    v12 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v19 = vaddq_f32(v7, vmulq_f32(v12, (float32x4_t)xmmword_1B30512C0));
      if (v6 >= 4)
        break;
      LODWORD(v66) = 0;
      v21 = 0uLL;
      __asm { FMOV            V18.4S, #1.0 }
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v12 = vaddq_f32(v12, _Q18);
      ++v4;
      *(_QWORD *)&v9 += v10;
      *(_QWORD *)&v8 += v11;
      if (v4 == v3)
        return 0;
    }
    v20 = 0;
    v21 = 0uLL;
    v22 = 32;
    do
    {
      v23 = vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880));
      v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B3051880);
      v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B3051880);
      v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B3051880);
      v27 = a2[12];
      v28 = a2[13].i32[0];
      v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      v31 = v29.i32[1];
      v32 = v29.i32[0];
      v33 = vaddq_f32(vsubq_f32(v24, v5), v18);
      v34 = vcvtq_s32_f32(v33);
      v35 = v32 + v31 * v28;
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      v36 = v33.i32[1];
      v37 = v33.i32[0];
      v38 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v35);
      v39 = vaddq_f32(vsubq_f32(v25, v5), v18);
      v40 = vcvtq_s32_f32(v39);
      v41 = v37 + v36 * v28;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      v42 = v39.i32[1];
      v43 = v39.i32[0];
      v44 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v41);
      v45 = vaddq_f32(vsubq_f32(v26, v5), v18);
      v46 = vcvtq_s32_f32(v45);
      v47 = v43 + v42 * v28;
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      v48 = v45.i32[1];
      v49 = v45.i32[0];
      v50 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * v47);
      v51 = *(int8x16_t *)(*(_QWORD *)&v27 + 16 * (v49 + v48 * v28));
      v52 = *((_QWORD *)this + 51);
      v53 = *(int8x16_t *)(v52 + 32);
      v54 = *(float32x4_t *)(v52 + 48);
      v55 = *(float32x4_t *)(v52 + 16);
      v56 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 32), vextq_s8(v38, v38, 0xCuLL))));
      v57 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 - 16), vextq_s8(v44, v44, 0xCuLL))));
      v58 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22), vextq_s8(v50, v50, 0xCuLL))));
      v59 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(_QWORD *)&v9 + v22 + 16), vextq_s8(v51, v51, 0xCuLL))));
      v21 = vaddq_f32(v21, _Q5);
      v60 = *(float32x4_t *)(v52 + 64);
      v61 = vaddq_f32(vmulq_laneq_f32(v60, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v56.f32, 1)));
      v62 = vaddq_f32(vmulq_laneq_f32(v60, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v57.f32, 1)));
      v63 = vaddq_f32(vmulq_laneq_f32(v60, v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v58.f32, 1)));
      v61.i32[3] = 1.0;
      v62.i32[3] = 1.0;
      v63.i32[3] = 1.0;
      v64 = vaddq_f32(vmulq_laneq_f32(v60, v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v59.f32, 1)));
      v64.i32[3] = 1.0;
      v65 = (float32x4_t *)(*(_QWORD *)&v8 + v22);
      v65[-2] = v61;
      v65[-1] = v62;
      *v65 = v63;
      v65[1] = v64;
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    __asm { FMOV            V18.4S, #1.0 }
    if ((int)v66 >= v6)
      goto LABEL_3;
LABEL_10:
    v66 = v66;
    do
    {
      v68 = vaddq_f32(vsubq_f32(vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B3051880)), v5), v18);
      v69 = vcvtq_s32_f32(v68);
      v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
      v70 = *((_QWORD *)this + 51);
      v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v66), vextq_s8(*(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(_QWORD *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), 0xCuLL))));
      v72 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1)));
      v72.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v8 + 16 * v66) = v72;
      v21 = vaddq_f32(v21, _Q18);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::GetDOD(HgcYUV420BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  double v9;
  float v10;
  double v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (!a3)
    return v5;
  if (a3 == 1)
  {
    v6 = HGRectMake4i(0, 0, 1u, 1u);
    v7 = HGRectGrow(v5, v4, v6);
    v8 = HGRectFloat(v7);
    v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::GetROI(HgcYUV420BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(_QWORD *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      v5 = HGRectFloat(a4.var0);
      v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      v16 = v15;
      v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420BiPlanar_601ToRGB::HgcYUV420BiPlanar_601ToRGB(HgcYUV420BiPlanar_601ToRGB *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653E958;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3552AB0;
  v3[4] = xmmword_1B3552AC0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcYUV420BiPlanar_601ToRGB *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB5D8C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_601ToRGB::~HgcYUV420BiPlanar_601ToRGB(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653E958;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653E958;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653E958;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_601ToRGB::SetParameter(HgcYUV420BiPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::GetParameter(HgcYUV420BiPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_3::GetProgram(HgcMultiTexBlend_3 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003ed\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    output.color0 = hg_Params[0].zzzz*float4(r2) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cc766481:a53c051c:4e34c2a5:82be33cf\n"
             "//SIG=00400000:00000007:00000007:00000007:0000:0001:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003bb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    output.color0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f558b7ce:73db4aed:13eb5976:1ab74be0\n"
             "//SIG=00000000:00000007:00000007:00000000:0000:0001:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000349\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "}\n"
           "//MD5=08d99f4b:8e68f2aa:db8b3680:60eeb43c\n"
           "//SIG=00000000:00000007:00000007:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcMultiTexBlend_3::InitProgramDescriptor(HgcMultiTexBlend_3 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_3_hgc_visible", "//Metal1.0     \n//LEN=00000001a1\n[[ visible ]] FragmentOut HgcMultiTexBlend_3_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    output.color0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB6318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB6350(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB6348);
}

double HgcMultiTexBlend_3::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_3 [hgc1]");
  return *(double *)"exBlend_3 [hgc1]";
}

uint64_t HgcMultiTexBlend_3::BindTexture(HgcMultiTexBlend_3 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 2;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    if (a3)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcMultiTexBlend_3::Bind(HgcMultiTexBlend_3 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcMultiTexBlend_3 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_3::RenderTile(HgcMultiTexBlend_3 *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  uint64_t v17;
  float32x4_t *v18;
  float32x4_t *v19;
  float32x4_t *v20;
  unint64_t v21;
  unint64_t v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t *v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v8 = *((int *)a2 + 6);
    v9 = *((int *)a2 + 30);
    v10 = *((int *)a2 + 26);
    v11 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v41 = 0;
        v42 = 16 * v10;
        v43 = 16 * v9;
        v44 = 16 * v8;
        v45 = 16 * v3;
        do
        {
          v46 = 0;
          do
          {
            v7[v46 / 0x10] = vaddq_f32(vmulq_laneq_f32(v6[v46 / 0x10], *(float32x4_t *)*((_QWORD *)this + 51), 2), vaddq_f32(vmulq_n_f32(v4[v46 / 0x10], COERCE_FLOAT(*(_OWORD *)*((_QWORD *)this + 51))), vmulq_lane_f32(v5[v46 / 0x10], **((float32x2_t **)this + 51), 1)));
            v46 += 16;
          }
          while (v45 != v46);
          ++v41;
          v4 += v11;
          v5 = (float32x4_t *)((char *)v5 + v42);
          v6 = (float32x4_t *)((char *)v6 + v43);
          v7 = (float32x4_t *)((char *)v7 + v44);
        }
        while (v41 != v2);
      }
    }
    else
    {
      v12 = 0;
      v13 = 16 * v10;
      v14 = 16 * v9;
      v15 = 16 * v8;
      v16 = v4 + 4;
      v17 = 16 * v11;
      v18 = v5 + 4;
      v19 = v6 + 4;
      v20 = v7 + 4;
      do
      {
        v21 = 0;
        v22 = 0;
        v23 = v20;
        v24 = v19;
        v25 = v18;
        v26 = v16;
        do
        {
          v27 = v26;
          v28 = v25;
          v29 = v24;
          v30 = v23;
          v31 = *(float32x4_t *)*((_QWORD *)this + 51);
          v32 = vaddq_f32(vmulq_laneq_f32(v6[v21 + 1], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21 + 1], v31.f32[0]), vmulq_lane_f32(v5[v21 + 1], *(float32x2_t *)v31.f32, 1)));
          v33 = vaddq_f32(vmulq_laneq_f32(v6[v21 + 2], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21 + 2], v31.f32[0]), vmulq_lane_f32(v5[v21 + 2], *(float32x2_t *)v31.f32, 1)));
          v34 = vaddq_f32(vmulq_laneq_f32(v6[v21 + 3], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21 + 3], v31.f32[0]), vmulq_lane_f32(v5[v21 + 3], *(float32x2_t *)v31.f32, 1)));
          v35 = &v7[v21];
          *v35 = vaddq_f32(vmulq_laneq_f32(v6[v21], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21], v31.f32[0]), vmulq_lane_f32(v5[v21], *(float32x2_t *)v31.f32, 1)));
          v35[1] = v32;
          v22 += 4;
          v21 += 4;
          v26 += 4;
          v35[2] = v33;
          v35[3] = v34;
          v25 += 4;
          v24 += 4;
          v23 = v30 + 4;
        }
        while ((uint64_t)v22 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v22)
        {
          do
          {
            v36 = *v27++;
            v37 = v36;
            v38 = *v28++;
            v39 = v38;
            v40 = *v29++;
            *v30++ = vaddq_f32(vmulq_laneq_f32(v40, *(float32x4_t *)*((_QWORD *)this + 51), 2), vaddq_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)*((_QWORD *)this + 51))), vmulq_lane_f32(v39, **((float32x2_t **)this + 51), 1)));
            ++v22;
          }
          while (v22 < v3);
        }
        ++v12;
        v5 = (float32x4_t *)((char *)v5 + v13);
        v6 = (float32x4_t *)((char *)v6 + v14);
        v7 = (float32x4_t *)((char *)v7 + v15);
        v4 = (float32x4_t *)((char *)v4 + v17);
        v16 = (float32x4_t *)((char *)v16 + v17);
        v18 = (float32x4_t *)((char *)v18 + v13);
        v19 = (float32x4_t *)((char *)v19 + v14);
        v20 = (float32x4_t *)((char *)v20 + v15);
      }
      while (v12 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_3::GetDOD(HgcMultiTexBlend_3 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_3::GetROI(HgcMultiTexBlend_3 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_3::HgcMultiTexBlend_3(HgcMultiTexBlend_3 *this)
{
  _QWORD *v2;
  _QWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653EBC0;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB683C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_3::~HgcMultiTexBlend_3(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653EBC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653EBC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_3::SetParameter(HgcMultiTexBlend_3 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcMultiTexBlend_3::GetParameter(HgcMultiTexBlend_3 *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcMultiTexBlend_6::GetProgram(HgcMultiTexBlend_6 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000066c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    r0 = half4(hg_Params[1].xxxx)*r4 + r0;\n"
             "    output.color0 = hg_Params[1].yyyy*float4(r5) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=552ccccb:a1de3632:dbe40462:70e09c4d\n"
             "//SIG=00400000:0000003f:0000003f:0000003f:0000:0002:0006:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000610\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
             "    output.color0 = hg_Params[1].yyyy*r5 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=69605aab:03823b9c:4ce0d041:98b9bc19\n"
             "//SIG=00000000:0000003f:0000003f:00000000:0000:0002:0006:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000566\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    r0 = hg_ProgramLocal1.xxxx*r4 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1.yyyy*r5 + r0;\n"
           "}\n"
           "//MD5=6976d0bc:7777c38e:336b9450:9480e558\n"
           "//SIG=00000000:0000003f:0000003f:00000000:0000:0002:0006:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
  }
}

void HgcMultiTexBlend_6::InitProgramDescriptor(HgcMultiTexBlend_6 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_6_hgc_visible", "//Metal1.0     \n//LEN=0000000285\n[[ visible ]] FragmentOut HgcMultiTexBlend_6_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5)\n{\n    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
    "    output.color0 = hg_Params[1].yyyy*r5 + r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB6F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB6F68(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB6F60);
}

double HgcMultiTexBlend_6::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcMultiTexBlend_6 [hgc1]");
  return *(double *)"exBlend_6 [hgc1]";
}

uint64_t HgcMultiTexBlend_6::BindTexture(HgcMultiTexBlend_6 *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  uint64_t result;
  int v7;

  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 0;
      goto LABEL_9;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 1;
      goto LABEL_9;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 2;
      goto LABEL_9;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 3;
      goto LABEL_9;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 4;
      goto LABEL_9;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
      v4 = a2;
      v5 = 5;
LABEL_9:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
      result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
        result = 0;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_6::Bind(HgcMultiTexBlend_6 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HgcMultiTexBlend_6 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcMultiTexBlend_6::RenderTile(HgcMultiTexBlend_6 *this, HGTile *a2)
{
  int v2;
  int v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  float32x4_t *v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t *v32;
  float32x4_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  float32x4_t v41;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (float32x4_t *)*((_QWORD *)a2 + 12);
    v6 = (float32x4_t *)*((_QWORD *)a2 + 14);
    v7 = (float32x4_t *)*((_QWORD *)a2 + 16);
    v8 = (float32x4_t *)*((_QWORD *)a2 + 18);
    v9 = (float32x4_t *)*((_QWORD *)a2 + 20);
    v10 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v11 = *((int *)a2 + 6);
    v12 = *((int *)a2 + 42);
    v13 = *((int *)a2 + 38);
    v14 = *((int *)a2 + 34);
    v15 = *((int *)a2 + 30);
    v16 = *((int *)a2 + 26);
    v17 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        v34 = 16 * v17;
        v35 = 16 * v14;
        v36 = 16 * v13;
        v37 = 16 * v12;
        v38 = 16 * v11;
        do
        {
          v39 = (float32x4_t *)*((_QWORD *)this + 51);
          v40 = v39[1];
          v41 = vaddq_f32(vmulq_n_f32(*v8, v40.f32[0]), vaddq_f32(vmulq_laneq_f32(*v7, *v39, 3), vaddq_f32(vmulq_laneq_f32(*v6, *v39, 2), vaddq_f32(vmulq_n_f32(*v4, COERCE_FLOAT(*v39)), vmulq_lane_f32(*v5, *(float32x2_t *)v39->f32, 1)))));
          v4 = (float32x4_t *)((char *)v4 + v34);
          v5 += v16;
          v6 += v15;
          v7 = (float32x4_t *)((char *)v7 + v35);
          *v10 = vaddq_f32(vmulq_lane_f32(*v9, *(float32x2_t *)v40.f32, 1), v41);
          v8 = (float32x4_t *)((char *)v8 + v36);
          v9 = (float32x4_t *)((char *)v9 + v37);
          v10 = (float32x4_t *)((char *)v10 + v38);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      v18 = 0;
      v19 = 16 * v15;
      v20 = 16 * v14;
      v21 = 16 * v13;
      v22 = 16 * v12;
      v23 = 16 * v11;
      v24 = 16 * v17;
      v25 = 16 * v16;
      do
      {
        v26 = 0;
        v27 = 0;
        do
        {
          v28 = (float32x4_t *)*((_QWORD *)this + 51);
          v29 = v28[1];
          v30 = vaddq_f32(vmulq_lane_f32(v9[v26], *(float32x2_t *)v29.f32, 1), vaddq_f32(vmulq_n_f32(v8[v26], v29.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v26], *v28, 3), vaddq_f32(vmulq_laneq_f32(v6[v26], *v28, 2), vaddq_f32(vmulq_n_f32(v4[v26], COERCE_FLOAT(*v28)), vmulq_lane_f32(v5[v26], *(float32x2_t *)v28->f32, 1))))));
          v31 = vaddq_f32(vmulq_lane_f32(v9[v26 + 1], *(float32x2_t *)v29.f32, 1), vaddq_f32(vmulq_n_f32(v8[v26 + 1], v29.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v26 + 1], *v28, 3), vaddq_f32(vmulq_laneq_f32(v6[v26 + 1], *v28, 2), vaddq_f32(vmulq_n_f32(v4[v26 + 1], COERCE_FLOAT(*v28)), vmulq_lane_f32(v5[v26 + 1], *(float32x2_t *)v28->f32, 1))))));
          v32 = &v10[v26];
          *v32 = v30;
          v32[1] = v31;
          v27 -= 2;
          v26 += 2;
        }
        while (v3 + v27 > 1);
        if (v3 > -v27)
        {
          v33 = (float32x4_t *)*((_QWORD *)this + 51);
          v10[v26] = vaddq_f32(vmulq_lane_f32(v9[v26], *(float32x2_t *)v33[1].f32, 1), vaddq_f32(vmulq_n_f32(v8[v26], COERCE_FLOAT(*(_OWORD *)&v33[1])), vaddq_f32(vmulq_laneq_f32(v7[v26], *v33, 3), vaddq_f32(vmulq_laneq_f32(v6[v26], *v33, 2), vaddq_f32(vmulq_n_f32(v4[v26], COERCE_FLOAT(*v33)), vmulq_lane_f32(v5[v26], *(float32x2_t *)v33->f32, 1))))));
        }
        ++v18;
        v6 = (float32x4_t *)((char *)v6 + v19);
        v7 = (float32x4_t *)((char *)v7 + v20);
        v8 = (float32x4_t *)((char *)v8 + v21);
        v9 = (float32x4_t *)((char *)v9 + v22);
        v10 = (float32x4_t *)((char *)v10 + v23);
        v4 = (float32x4_t *)((char *)v4 + v24);
        v5 = (float32x4_t *)((char *)v5 + v25);
      }
      while (v18 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_6::GetDOD(HgcMultiTexBlend_6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcMultiTexBlend_6::GetROI(HgcMultiTexBlend_6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcMultiTexBlend_6::HgcMultiTexBlend_6(HgcMultiTexBlend_6 *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653EE28;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB754C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_6::~HgcMultiTexBlend_6(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653EE28;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653EE28;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_6::SetParameter(HgcMultiTexBlend_6 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcMultiTexBlend_6::GetParameter(HgcMultiTexBlend_6 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGamutMap::GetProgram(HgcGamutMap *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000573\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = fmin(r0.x, c0.x);\n"
             "    r1.z = c0.x - r1.x;\n"
             "    r2.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r1.xy = c0.yy;\n"
             "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
             "    r2.w = dot(r1.xyz, r1.xyz);\n"
             "    r2.w = sqrt(r2.w);\n"
             "    r1.x = r2.w + c0.y;\n"
             "    r1.y = 1.00000h / r1.x;\n"
             "    r1.x = r2.w*r2.w + c0.y;\n"
             "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000h, 1.00000h);\n"
             "    r0.x = 1.00000h / r1.x;\n"
             "    r0.y = r2.w*r2.w + -r2.w;\n"
             "    r2.w = r2.w*r0.y + r2.w;\n"
             "    r2.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = mix(r0.xxx, r1.yyy, half3(hg_Params[0].xyz));\n"
             "    output.color0.xyz = mix(float3(r2.www), float3(r2.xyz), float3(r0.xyz));\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9fd12417:c540b2a9:193700f8:2013b2a7\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000542\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = fmin(r0.x, c0.x);\n"
             "    r1.z = c0.x - r1.x;\n"
             "    r2.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r1.xy = c0.yy;\n"
             "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
             "    r2.w = dot(r1.xyz, r1.xyz);\n"
             "    r2.w = sqrt(r2.w);\n"
             "    r1.x = r2.w + c0.y;\n"
             "    r1.y = 1.00000f / r1.x;\n"
             "    r1.x = r2.w*r2.w + c0.y;\n"
             "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000f, 1.00000f);\n"
             "    r0.x = 1.00000f / r1.x;\n"
             "    r0.y = r2.w*r2.w + -r2.w;\n"
             "    r2.w = r2.w*r0.y + r2.w;\n"
             "    r2.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = mix(r0.xxx, r1.yyy, hg_Params[0].xyz);\n"
             "    output.color0.xyz = mix(r2.www, r2.xyz, r0.xyz);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7c8a7355:917bfc5f:f837ebc6:4b23a8cd\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004f2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = min(r0.x, c0.x);\n"
           "    r1.z = c0.x - r1.x;\n"
           "    r2.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r1.xy = c0.yy;\n"
           "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
           "    r2.w = dot(r1.xyz, r1.xyz);\n"
           "    r2.w = sqrt(r2.w);\n"
           "    r1.x = r2.w + c0.y;\n"
           "    r1.y = 1.00000 / r1.x;\n"
           "    r1.x = r2.w*r2.w + c0.y;\n"
           "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000, 1.00000);\n"
           "    r0.x = 1.00000 / r1.x;\n"
           "    r0.y = r2.w*r2.w + -r2.w;\n"
           "    r2.w = r2.w*r0.y + r2.w;\n"
           "    r2.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = mix(r0.xxx, r1.yyy, hg_ProgramLocal0.xyz);\n"
           "    gl_FragColor.xyz = mix(r2.www, r2.xyz, r0.xyz);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=37364881:eadfc1fa:492b9576:fb1eb981\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcGamutMap::InitProgramDescriptor(HgcGamutMap *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGamutMap_hgc_visible", "//Metal1.0     \n//LEN=000000039c\n[[ visible ]] FragmentOut HgcGamutMap_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = fmin(r0.x, c0.x);\n"
    "    r1.z = c0.x - r1.x;\n"
    "    r2.xyz = color1.xyz;\n"
    "    r1.xy = c0.yy;\n"
    "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
    "    r2.w = dot(r1.xyz, r1.xyz);\n"
    "    r2.w = sqrt(r2.w);\n"
    "    r1.x = r2.w + c0.y;\n"
    "    r1.y = 1.00000f / r1.x;\n"
    "    r1.x = r2.w*r2.w + c0.y;\n"
    "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000f, 1.00000f);\n"
    "    r0.x = 1.00000f / r1.x;\n"
    "    r0.y = r2.w*r2.w + -r2.w;\n"
    "    r2.w = r2.w*r0.y + r2.w;\n"
    "    r2.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = mix(r0.xxx, r1.yyy, hg_Params[0].xyz);\n"
    "    output.color0.xyz = mix(r2.www, r2.xyz, r0.xyz);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB79F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB7A2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB7A24);
}

void HgcGamutMap::shaderDescription(char *a1@<X8>)
{
  a1[23] = 18;
  strcpy(a1, "HgcGamutMap [hgc1]");
}

uint64_t HgcGamutMap::BindTexture(HgcGamutMap *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    if (a3)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGamutMap::Bind(HgcGamutMap *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcGamutMap *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGamutMap::RenderTile(HgcGamutMap *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int8x16_t v50;
  int8x16_t v51;
  float32x4_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  int v76;
  uint64_t v77;
  float32x4_t v78;
  uint64_t v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 12);
    v7 = 16 * *((int *)a2 + 22);
    v8 = *((_QWORD *)a2 + 10);
    v9 = 16 * *((int *)a2 + 6);
    v10 = 16 * *((int *)a2 + 26);
    while (v4 < 2)
    {
      v76 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v8 += v7;
      v6 += v10;
      v5 += v9;
      if (++v3 == v2)
        return 0;
    }
    v11 = 0;
    v12 = 16;
    do
    {
      v13 = *(float32x4_t *)(v8 + v12 - 16);
      v14 = *(float32x4_t *)(v8 + v12);
      v15 = *((_QWORD *)this + 51);
      v16 = *(float32x4_t *)(v15 + 16);
      v17 = (int8x16_t)vminq_f32(v13, v16);
      v18 = (int8x16_t)vminq_f32(v14, v16);
      v19 = *(float32x4_t *)(v6 + v12 - 16);
      v20 = *(float32x4_t *)(v6 + v12);
      v22 = *(float32x4_t *)(v15 + 32);
      v21 = *(int8x16_t *)(v15 + 48);
      v23 = vsubq_f32(v13, vmulq_f32(v19, (float32x4_t)vbslq_s8(v21, (int8x16_t)vsubq_f32(v16, (float32x4_t)vextq_s8(v17, v17, 8uLL)), (int8x16_t)v22)));
      v24 = vsubq_f32(v14, vmulq_f32(v20, (float32x4_t)vbslq_s8(v21, (int8x16_t)vsubq_f32(v16, (float32x4_t)vextq_s8(v18, v18, 8uLL)), (int8x16_t)v22)));
      v25 = (int32x4_t)vmulq_f32(v23, v23);
      v26 = (int32x4_t)vmulq_f32(v24, v24);
      v27 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v25), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL)));
      v28 = *(int8x16_t *)(v15 + 64);
      v29 = *(float32x4_t *)(v15 + 80);
      v30 = (float32x4_t)vbslq_s8(v28, v27, (int8x16_t)v19);
      v31 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v26), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL))), (int8x16_t)v20);
      v32 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v30)), v16);
      v33 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v31)), v16);
      v34 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v32, vrsqrtsq_f32(vmulq_f32(v32, v30), v32)), v16), v30), (int8x16_t)v19);
      v35 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v33, vrsqrtsq_f32(vmulq_f32(v33, v31), v33)), v16), v31), (int8x16_t)v20);
      v36 = (float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL);
      v37 = (float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 0xCuLL);
      v38 = (float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v22, v36));
      v39 = (float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v22, v37));
      v40 = *(float32x4_t *)(v15 + 96);
      v41 = *(int8x16_t *)(v15 + 112);
      v42 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpeq_f32(v38)), v29), v40);
      v43 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpeq_f32(v39)), v29), v40);
      v44 = (float32x4_t)vbslq_s8(v41, (int8x16_t)vaddq_f32(v29, vmulq_laneq_f32(v36, v34, 3)), (int8x16_t)vmulq_f32(v42, vrecpsq_f32(v38, v42)));
      v45 = (float32x4_t)vbslq_s8(v41, (int8x16_t)vaddq_f32(v29, vmulq_laneq_f32(v37, v35, 3)), (int8x16_t)vmulq_f32(v43, vrecpsq_f32(v39, v43)));
      v47 = *(float32x4_t *)(v15 + 128);
      v46 = *(float32x4_t *)(v15 + 144);
      v48 = (int32x4_t)vmulq_f32(v13, v47);
      v49 = (int32x4_t)vmulq_f32(v14, v47);
      v50 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(v48), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL))), v47), v29);
      v51 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(v49), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL))), v47), v29);
      v52 = *(float32x4_t *)(v15 + 160);
      v53 = *(int8x16_t *)(v15 + 176);
      v54 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v44), v46), v52), v40);
      v55 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v45), v46), v52), v40);
      v56 = (float32x4_t)vbslq_s8(v28, v50, (int8x16_t)v19);
      v54.i64[0] = vmulq_f32(v54, vrecpsq_f32(v44, v54)).u64[0];
      v55.i64[0] = vmulq_f32(v55, vrecpsq_f32(v45, v55)).u64[0];
      v54.i64[1] = *(_QWORD *)(v8 + v12 - 8);
      v55.i64[1] = *(_QWORD *)(v8 + v12 + 8);
      v57 = (float32x4_t)vbslq_s8(v28, v51, (int8x16_t)v20);
      v58 = (int8x16_t)vnegq_f32(v56);
      v59 = (int8x16_t)vnegq_f32(v57);
      v60 = vbslq_s8(v53, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v58, v58, 8uLL), vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL), v56, 3)), (int8x16_t)v54);
      v61 = vbslq_s8(v53, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v59, v59, 8uLL), vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v57, (int8x16_t)v57, 8uLL), v57, 3)), (int8x16_t)v55);
      v62 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32(vmulq_lane_f32(v57, *(float32x2_t *)v61.i8, 1), v57), (int8x16_t)v20);
      v63 = *(float32x4_t *)(v15 + 192);
      v64 = *(float32x4_t *)(v15 + 208);
      v65 = vmaxq_f32((float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32(vmulq_lane_f32(v56, *(float32x2_t *)v60.i8, 1), v56), (int8x16_t)v19), v63);
      v66 = vmaxq_f32(v62, v63);
      v67 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.i8, 0);
      v68 = vminq_f32(v65, v64);
      v69 = vminq_f32(v66, v64);
      v70 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.i8, 0);
      v71 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3);
      v72 = (float32x4_t)vbslq_s8(v28, v60, (int8x16_t)vaddq_f32(v67, vmulq_f32(*(float32x4_t *)v15, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1), v67))));
      v73 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3);
      v74 = (int8x16_t)vaddq_f32(v73, vmulq_f32(vsubq_f32(v69, v73), (float32x4_t)vbslq_s8(v28, v61, (int8x16_t)vaddq_f32(v70, vmulq_f32(*(float32x4_t *)v15, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1), v70))))));
      v75 = (int8x16_t *)(v5 + v12);
      v75[-1] = vbslq_s8(v28, v60, (int8x16_t)vaddq_f32(v71, vmulq_f32(vsubq_f32(v68, v71), v72)));
      *v75 = vbslq_s8(v28, v61, v74);
      v11 -= 2;
      v12 += 32;
    }
    while (v4 + v11 > 1);
    v76 = -v11;
    if (v76 >= v4)
      goto LABEL_3;
LABEL_10:
    v77 = 16 * v76;
    v78 = *(float32x4_t *)(v8 + v77);
    v79 = *((_QWORD *)this + 51);
    v80 = *(float32x4_t *)(v79 + 16);
    v81 = (int8x16_t)vminq_f32(v78, v80);
    v82 = *(float32x4_t *)(v6 + v77);
    v83 = *(float32x4_t *)(v79 + 32);
    v84 = vsubq_f32(v78, vmulq_f32(v82, (float32x4_t)vbslq_s8(*(int8x16_t *)(v79 + 48), (int8x16_t)vsubq_f32(v80, (float32x4_t)vextq_s8(v81, v81, 8uLL)), (int8x16_t)v83)));
    v85 = (int32x4_t)vmulq_f32(v84, v84);
    v86 = *(int8x16_t *)(v79 + 64);
    v87 = *(float32x4_t *)(v79 + 80);
    v88 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v85), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v85, (int8x16_t)v85, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v85, (int8x16_t)v85, 8uLL))), (int8x16_t)v82);
    v89 = vminq_f32(vmulq_f32(v83, vrsqrteq_f32(v88)), v80);
    v90 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v89, vrsqrtsq_f32(vmulq_f32(v89, v88), v89)), v80), v88), (int8x16_t)v82);
    v91 = (float32x4_t)vextq_s8((int8x16_t)v90, (int8x16_t)v90, 0xCuLL);
    v92 = (float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v83, v91));
    v93 = *(float32x4_t *)(v79 + 96);
    v94 = vminq_f32(vmaxq_f32(vmulq_f32(v80, vrecpeq_f32(v92)), v87), v93);
    v95 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v79 + 112), (int8x16_t)vaddq_f32(v87, vmulq_laneq_f32(v91, v90, 3)), (int8x16_t)vmulq_f32(v94, vrecpsq_f32(v92, v94)));
    v96 = *(float32x4_t *)(v79 + 128);
    v97 = (int32x4_t)vmulq_f32(v78, v96);
    v98 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v95), *(float32x4_t *)(v79 + 144)), *(float32x4_t *)(v79 + 160)), v93);
    v98.i64[0] = vmulq_f32(v98, vrecpsq_f32(v95, v98)).u64[0];
    v98.i64[1] = *(_QWORD *)(v8 + v77 + 8);
    v99 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(v97), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 8uLL))), v96), v87), (int8x16_t)v82);
    v100 = (int8x16_t)vnegq_f32(v99);
    v101 = vbslq_s8(*(int8x16_t *)(v79 + 176), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v100, v100, 8uLL), vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v99, (int8x16_t)v99, 8uLL), v99, 3)), (int8x16_t)v98);
    v102 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vaddq_f32(vmulq_lane_f32(v99, *(float32x2_t *)v101.i8, 1), v99), (int8x16_t)v82), *(float32x4_t *)(v79 + 192)), *(float32x4_t *)(v79 + 208));
    v103 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.i8, 0);
    v104 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 3);
    *(int8x16_t *)(v5 + v77) = vbslq_s8(v86, v101, (int8x16_t)vaddq_f32(v104, vmulq_f32(vsubq_f32(v102, v104), (float32x4_t)vbslq_s8(v86, v101, (int8x16_t)vaddq_f32(v103, vmulq_f32(*(float32x4_t *)v79, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.f32, 1), v103)))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGamutMap::GetDOD(HgcGamutMap *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcGamutMap::GetROI(HgcGamutMap *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcGamutMap::HgcGamutMap(HgcGamutMap *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653F090;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B35530A0;
  *(_OWORD *)(v3 + 32) = xmmword_1B35530B0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050FE0;
  *(_OWORD *)(v3 + 64) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051350;
  *(int32x4_t *)(v3 + 96) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 112) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 128) = xmmword_1B35530C0;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051540;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051200;
  *(_OWORD *)(v3 + 176) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 192) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 208) = xmmword_1B3525D80;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB8154(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGamutMap::~HgcGamutMap(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653F090;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653F090;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C405DF52C91);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGamutMap::SetParameter(HgcGamutMap *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcGamutMap::GetParameter(HgcGamutMap *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcGamutDebug::GetProgram(HgcGamutDebug *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000315\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(r0.xyz < c0.xxx);\n"
             "    r1.x = clamp(dot(r1.xyz, 1.00000h), 0.00000h, 1.00000h);\n"
             "    output.color0 = select(float4(r0), float4(c0.yyyy), -float4(r1.xxxx) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2d0afb17:dab469cd:798741a4:58cd198f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = float3(r0.xyz < c0.xxx);\n"
             "    r1.x = clamp(dot(r1.xyz, 1.00000f), 0.00000f, 1.00000f);\n"
             "    output.color0 = select(r0, c0.yyyy, -r1.xxxx < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71fe4496:7156453e:b7d65510:ea5aafa6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000303\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(lessThan(r0.xyz, c0.xxx));\n"
           "    r1.x = clamp(dot(r1.xyz, vec3(1.00000)), 0.00000, 1.00000);\n"
           "    gl_FragColor = vec4(-r1.x < 0.00000 ? c0.y : r0.x, -r1.x < 0.00000 ? c0.y : r0.y, -r1.x < 0.00000 ? c0.y "
           ": r0.z, -r1.x < 0.00000 ? c0.y : r0.w);\n"
           "}\n"
           "//MD5=a7127b0a:d9e000dc:3c8303cb:b3e5bf56\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGamutDebug::InitProgramDescriptor(HgcGamutDebug *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGamutDebug_hgc_visible", "//Metal1.0     \n//LEN=00000001d1\n[[ visible ]] FragmentOut HgcGamutDebug_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = float3(r0.xyz < c0.xxx);\n"
    "    r1.x = clamp(dot(r1.xyz, 1.00000f), 0.00000f, 1.00000f);\n"
    "    output.color0 = select(r0, c0.yyyy, -r1.xxxx < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB8544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB8574(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB856CLL);
}

void HgcGamutDebug::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcGamutDebug [hgc1]");
}

uint64_t HgcGamutDebug::BindTexture(HgcGamutDebug *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGamutDebug::Bind(HgcGamutDebug *this, HGHandler *a2)
{
  (*(void (**)(HgcGamutDebug *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGamutDebug::RenderTile(HgcGamutDebug *this, HGTile *a2)
{
  int v2;
  unint64_t v3;
  float32x4_t *v4;
  int8x16_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t *v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t *v33;
  int8x16_t *v34;
  float32x4_t *v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  float32x4_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v4 = (float32x4_t *)*((_QWORD *)a2 + 10);
    v5 = (int8x16_t *)*((_QWORD *)a2 + 2);
    v6 = *((int *)a2 + 6);
    v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        v39 = 0;
        v40 = 16 * v7;
        v41 = 16 * v6;
        v42 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          v43 = 0;
          do
          {
            v44 = v4[v43 / 0x10];
            v45 = (float32x4_t *)*((_QWORD *)this + 51);
            v46 = v45[1];
            v47 = (float32x4_t)vandq_s8((int8x16_t)v46, (int8x16_t)vcgtq_f32(*v45, v44));
            v5[v43 / 0x10] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v47, (int8x16_t)v47, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v47), v47)), *v45), v46), 0), *v45), (int8x16_t)v46, (int8x16_t)v44);
            v43 += 16;
          }
          while (v42 != v43);
          ++v39;
          v4 = (float32x4_t *)((char *)v4 + v40);
          v5 = (int8x16_t *)((char *)v5 + v41);
        }
        while (v39 != v2);
      }
    }
    else
    {
      v8 = 0;
      v9 = 16 * v6;
      v10 = 16 * v7;
      v11 = v4 + 4;
      v12 = v5 + 4;
      do
      {
        v13 = 0;
        v14 = v12;
        v15 = v11;
        v16 = 2;
        do
        {
          v17 = v4[v16 - 2];
          v18 = v4[v16 - 1];
          v19 = v4[v16];
          v20 = v4[v16 + 1];
          v21 = (float32x4_t *)*((_QWORD *)this + 51);
          v22 = *v21;
          v23 = v21[1];
          v24 = v15;
          v25 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v17));
          v26 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v18));
          v27 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v19));
          v28 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v20));
          v29 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v25), v25)), *v21), v23), 0);
          v30 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v26), v26)), *v21), v23), 0);
          v31 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v27), v27)), *v21), v23), 0);
          v32 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v28), v28)), *v21), v23), 0);
          v33 = v14;
          v34 = &v5[v16];
          v13 += 4;
          v34[-2] = vbslq_s8((int8x16_t)vcgtq_f32(v29, v22), (int8x16_t)v23, (int8x16_t)v17);
          v34[-1] = vbslq_s8((int8x16_t)vcgtq_f32(v30, v22), (int8x16_t)v23, (int8x16_t)v18);
          *v34 = vbslq_s8((int8x16_t)vcgtq_f32(v31, v22), (int8x16_t)v23, (int8x16_t)v19);
          v34[1] = vbslq_s8((int8x16_t)vcgtq_f32(v32, v22), (int8x16_t)v23, (int8x16_t)v20);
          v16 += 4;
          v15 += 4;
          v14 = v33 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            v35 = (float32x4_t *)*((_QWORD *)this + 51);
            v36 = *v24++;
            v37 = v35[1];
            v38 = (float32x4_t)vandq_s8((int8x16_t)v37, (int8x16_t)vcgtq_f32(*v35, v36));
            *v33++ = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v38), v38)), *v35), v37), 0), *v35), (int8x16_t)v37, (int8x16_t)v36);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        v5 = (int8x16_t *)((char *)v5 + v9);
        v4 = (float32x4_t *)((char *)v4 + v10);
        v11 = (float32x4_t *)((char *)v11 + v10);
        v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcGamutDebug::GetDOD(HgcGamutDebug *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcGamutDebug::GetROI(HgcGamutDebug *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcGamutDebug::HgcGamutDebug(HgcGamutDebug *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653F2F8;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 16) = _Q0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB8968(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGamutDebug::~HgcGamutDebug(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653F2F8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653F2F8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGamutDebug::SetParameter(HgcGamutDebug *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcGamutDebug::GetParameter(HgcGamutDebug *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcCinematicDepthFX_ColorPop::GetProgram(HgcCinematicDepthFX_ColorPop *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000435\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.x - half(hg_Params[0].x);\n"
             "    r1.y = abs(r1.x);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r1.x = half(r1.x < r1.y);\n"
             "    r1.z = r0.y*c0.y;\n"
             "    r1.y = r0.x*c0.z + r1.z;\n"
             "    r1.y = r0.z*c0.w + r1.y;\n"
             "    output.color0.xyz = select(float3(r0.xyz), float3(r1.yyy), -float3(r1.xxx) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1298defe:3711e2e2:cd1e08c0:d5f1acf3\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000407\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.x - hg_Params[0].x;\n"
             "    r1.y = abs(r1.x);\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r1.x = float(r1.x < r1.y);\n"
             "    r1.z = r0.y*c0.y;\n"
             "    r1.y = r0.x*c0.z + r1.z;\n"
             "    r1.y = r0.z*c0.w + r1.y;\n"
             "    output.color0.xyz = select(r0.xyz, r1.yyy, -r1.xxx < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=55869529:89b21dce:60251d5d:c1ca7ed8\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.x - hg_ProgramLocal0.x;\n"
           "    r1.y = abs(r1.x);\n"
           "    r1.x = texture2D(hg_Texture1, hg_TexCoord1.xy).x;\n"
           "    r1.x = float(r1.x < r1.y);\n"
           "    r1.z = r0.y*c0.y;\n"
           "    r1.y = r0.x*c0.z + r1.z;\n"
           "    r1.y = r0.z*c0.w + r1.y;\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r1.y : r0.x, -r1.x < 0.00000 ? r1.y : r0.y, -r1.x < 0.00000 ? r"
           "1.y : r0.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=b5739cb7:e2f53a23:ffaea585:6fd6d74e\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcCinematicDepthFX_ColorPop::InitProgramDescriptor(HgcCinematicDepthFX_ColorPop *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCinematicDepthFX_ColorPop_hgc_visible", "//Metal1.0     \n//LEN=0000000272\n[[ visible ]] FragmentOut HgcCinematicDepthFX_ColorPop_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.x - hg_Params[0].x;\n"
    "    r1.y = abs(r1.x);\n"
    "    r1.x = color1.x;\n"
    "    r1.x = float(r1.x < r1.y);\n"
    "    r1.z = r0.y*c0.y;\n"
    "    r1.y = r0.x*c0.z + r1.z;\n"
    "    r1.y = r0.z*c0.w + r1.y;\n"
    "    output.color0.xyz = select(r0.xyz, r1.yyy, -r1.xxx < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB8D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB8D8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB8D84);
}

char *HgcCinematicDepthFX_ColorPop::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552B30;
  strcpy(result, "HgcCinematicDepthFX_ColorPop [hgc1]");
  return result;
}

uint64_t HgcCinematicDepthFX_ColorPop::BindTexture(HgcCinematicDepthFX_ColorPop *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    if (a3)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCinematicDepthFX_ColorPop::Bind(HgcCinematicDepthFX_ColorPop *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcCinematicDepthFX_ColorPop *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcCinematicDepthFX_ColorPop::RenderTile(HgcCinematicDepthFX_ColorPop *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  float32x4_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int8x16_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t *v42;
  uint64_t v43;
  float32x4_t v44;
  uint64_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  int8x16_t v49;
  int8x16_t v50;
  float32x4_t v51;
  uint64_t v52;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 12);
    v7 = 16 * *((int *)a2 + 22);
    v8 = *((_QWORD *)a2 + 10);
    v9 = 16 * *((int *)a2 + 26);
    v10 = 16 * *((int *)a2 + 6);
    while (v4 < 4)
    {
      LODWORD(v43) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
      if (v3 == v2)
        return 0;
    }
    v11 = 0;
    v12 = 32;
    do
    {
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = *(float32x4_t *)(v8 + v12 - 32);
      v16 = *(float32x4_t *)(v8 + v12 - 16);
      v17 = (int8x16_t)vabsq_f32((float32x4_t)vrev64q_s32((int32x4_t)vsubq_f32(v14, *(float32x4_t *)v13)));
      v18 = *(int8x16_t *)(v13 + 32);
      v19 = *(float32x4_t *)(v13 + 48);
      v20 = *(float32x4_t *)(v8 + v12);
      v21 = *(float32x4_t *)(v8 + v12 + 16);
      v22 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12 - 32), v17);
      v23 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12 - 16), v17);
      v24 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12), v17);
      v25 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12 + 16), v17);
      v26 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v22), v22));
      v27 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v23), v23));
      v28 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v24), v24));
      v29 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 0xCuLL), v14);
      v30 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v16, 0xCuLL), v14);
      v31 = (int8x16_t)vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v20, 0xCuLL), v14);
      v32 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v25), v25));
      *(int8x8_t *)v33.f32 = vext_s8(*(int8x8_t *)v26.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), 4uLL);
      v34 = vextq_s8((int8x16_t)v29, v26, 0xCuLL).u64[0];
      v26.i64[1] = v29.i64[1];
      *(int8x8_t *)v29.f32 = vext_s8(*(int8x8_t *)v27.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL), 4uLL);
      v35 = vextq_s8((int8x16_t)v30, v27, 0xCuLL).u64[0];
      v27.i64[1] = v30.i64[1];
      *(int8x8_t *)v30.f32 = vext_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), 4uLL);
      v36 = vextq_s8(v31, v28, 0xCuLL).u64[0];
      v28.i64[1] = v31.i64[1];
      v37 = (int8x16_t)vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v21, 0xCuLL), v14);
      *(int8x8_t *)v38.f32 = vext_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), 4uLL);
      v39.i64[0] = v32.i64[0];
      v39.i64[1] = v37.i64[1];
      v33.i64[1] = v34;
      v29.i64[1] = v35;
      v30.i64[1] = v36;
      v38.i64[1] = vextq_s8(v37, v32, 0xCuLL).u64[0];
      v26.i64[0] = vbslq_s8(v18, v26, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v15, 2), (float32x4_t)vbslq_s8(v18, v26, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v15.f32[0]), v33)))).u64[0];
      v27.i64[0] = vbslq_s8(v18, v27, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v16, 2), (float32x4_t)vbslq_s8(v18, v27, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v16.f32[0]), v29)))).u64[0];
      v28.i64[0] = vbslq_s8(v18, v28, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v20, 2), (float32x4_t)vbslq_s8(v18, v28, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v20.f32[0]), v30)))).u64[0];
      v18.i64[0] = vbslq_s8(v18, v39, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v21, 2), (float32x4_t)vbslq_s8(v18, v39, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v21.f32[0]), v38)))).u64[0];
      v40 = *(float32x4_t *)(v13 + 64);
      v41 = *(int8x16_t *)(v13 + 80);
      v42 = (int8x16_t *)(v5 + v12);
      v42[-2] = vbslq_s8(v41, (int8x16_t)v15, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 1), (int8x16_t)v15));
      v42[-1] = vbslq_s8(v41, (int8x16_t)v16, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 1), (int8x16_t)v16));
      *v42 = vbslq_s8(v41, (int8x16_t)v20, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v28.i8, 1), (int8x16_t)v20));
      v42[1] = vbslq_s8(v41, (int8x16_t)v21, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v18.i8, 1), (int8x16_t)v21));
      v11 -= 4;
      v12 += 64;
    }
    while (v4 + v11 > 3);
    LODWORD(v43) = -v11;
    if ((int)v43 >= v4)
      goto LABEL_3;
LABEL_10:
    v43 = v43;
    do
    {
      v44 = *(float32x4_t *)(v8 + 16 * v43);
      v45 = *((_QWORD *)this + 51);
      v46 = *(float32x4_t *)(v45 + 16);
      v47 = *(int8x16_t *)(v45 + 32);
      v48 = (float32x4_t)vbslq_s8(v47, *(int8x16_t *)(v6 + 16 * v43), (int8x16_t)vabsq_f32((float32x4_t)vrev64q_s32((int32x4_t)vsubq_f32(v46, *(float32x4_t *)v45))));
      v49 = vandq_s8((int8x16_t)v46, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v48), v48));
      v50 = (int8x16_t)vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 0xCuLL), v46);
      *(int8x8_t *)v51.f32 = vext_s8(*(int8x8_t *)v49.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL), 4uLL);
      v52 = vextq_s8(v50, v49, 0xCuLL).u64[0];
      v49.i64[1] = v50.i64[1];
      v51.i64[1] = v52;
      v46.i64[0] = vbslq_s8(v47, v49, (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v45 + 48), v44, 2), (float32x4_t)vbslq_s8(v47, v49, (int8x16_t)vaddq_f32(vmulq_n_f32(v46, v44.f32[0]), v51)))).u64[0];
      *(int8x16_t *)(v5 + 16 * v43++) = vbslq_s8(*(int8x16_t *)(v45 + 80), (int8x16_t)v44, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 0), *(float32x4_t *)(v45 + 64)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 1), (int8x16_t)v44));
    }
    while (v43 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCinematicDepthFX_ColorPop::GetDOD(HgcCinematicDepthFX_ColorPop *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcCinematicDepthFX_ColorPop::GetROI(HgcCinematicDepthFX_ColorPop *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcCinematicDepthFX_ColorPop::HgcCinematicDepthFX_ColorPop(HgcCinematicDepthFX_ColorPop *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653F560;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = xmmword_1B35530F0;
  v3[2] = xmmword_1B3050E20;
  v3[3] = xmmword_1B3553100;
  v3[4] = 0u;
  v3[5] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB92F4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCinematicDepthFX_ColorPop::~HgcCinematicDepthFX_ColorPop(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653F560;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653F560;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40565EDBD2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcCinematicDepthFX_ColorPop::SetParameter(HgcCinematicDepthFX_ColorPop *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCinematicDepthFX_ColorPop::GetParameter(HgcCinematicDepthFX_ColorPop *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcCinematicDepthFX_FadeOut::GetProgram(HgcCinematicDepthFX_FadeOut *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000033c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r0.x = pow(r0.x, half(hg_Params[0].x));\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.xyz = float3(r1.xyz)*float3(r0.xxx);\n"
             "    output.color0.w = float(r1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5d72101a:0d1ba2d4:a3186824:d7a1b699\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000313\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r0.x = pow(r0.x, hg_Params[0].x);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.xyz = r1.xyz*r0.xxx;\n"
             "    output.color0.w = r1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c08c65b8:bcd4ef5b:1ac91bee:f607030c\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002ba\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture1, hg_TexCoord1.xy).x;\n"
           "    r0.x = pow(r0.x, hg_ProgramLocal0.x);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor.xyz = r1.xyz*r0.xxx;\n"
           "    gl_FragColor.w = r1.w;\n"
           "}\n"
           "//MD5=4fc1596e:38c41ba7:94ce35ad:ee78ae36\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcCinematicDepthFX_FadeOut::InitProgramDescriptor(HgcCinematicDepthFX_FadeOut *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCinematicDepthFX_FadeOut_hgc_visible", "//Metal1.0     \n//LEN=000000017d\n[[ visible ]] FragmentOut HgcCinematicDepthFX_FadeOut_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color1.x;\n"
    "    r0.x = pow(r0.x, hg_Params[0].x);\n"
    "    r1 = color0;\n"
    "    output.color0.xyz = r1.xyz*r0.xxx;\n"
    "    output.color0.w = r1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BB977C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BB97B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BB97A8);
}

char *HgcCinematicDepthFX_FadeOut::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcCinematicDepthFX_FadeOut [hgc1]");
  return result;
}

uint64_t HgcCinematicDepthFX_FadeOut::BindTexture(HgcCinematicDepthFX_FadeOut *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCinematicDepthFX_FadeOut::Bind(HgcCinematicDepthFX_FadeOut *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcCinematicDepthFX_FadeOut *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcCinematicDepthFX_FadeOut::RenderTile(HgcCinematicDepthFX_FadeOut *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int32x4_t v66;
  int32x4_t v67;
  int32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t *v72;
  uint64_t v73;
  float32x4_t v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 26);
    v8 = *((_QWORD *)a2 + 12);
    v9 = 16 * *((int *)a2 + 6);
    v10 = 16 * *((int *)a2 + 22);
    while (v4 < 3)
    {
      LODWORD(v73) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      ++v3;
      v8 += v7;
      v5 += v9;
      v6 += v10;
      if (v3 == v2)
        return 0;
    }
    v11 = 0;
    v12 = 32;
    do
    {
      v13 = *(float32x4_t *)(v8 + v12 - 32);
      v14 = *(float32x4_t *)(v8 + v12 - 16);
      v15 = *((_QWORD *)this + 51);
      v16 = *(float32x4_t *)(v8 + v12);
      v17 = *(int8x16_t *)(v15 + 16);
      v18 = *(float32x4_t *)(v15 + 32);
      v19 = *(float32x4_t *)(v15 + 48);
      v20 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v13), (int8x16_t)v18);
      v21 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v14), (int8x16_t)v18);
      v22 = (int8x16_t)vcgtq_f32(v19, v14);
      v23 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v16), (int8x16_t)v18);
      v24 = *(int8x16_t *)(v15 + 64);
      v25 = *(float32x4_t *)(v15 + 80);
      v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v19, v16)));
      v27 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v13, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v19, v13))), v25);
      v28 = *(float32x4_t *)(v15 + 96);
      v29 = *(float32x4_t *)(v15 + 112);
      v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v14, 0x17uLL)), (float32x4_t)vandq_s8(v24, v22)), v25);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v28));
      v32 = vsubq_f32(v26, v25);
      v33 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v21, v28));
      v34 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v23, v28));
      v35 = vaddq_f32(v30, v33);
      v36 = vsubq_f32(vsubq_f32(v20, v18), vmulq_f32(vmulq_f32(v29, v31), v20));
      v37 = vsubq_f32(vsubq_f32(v21, v18), vmulq_f32(vmulq_f32(v29, v33), v21));
      v38 = vsubq_f32(vsubq_f32(v23, v18), vmulq_f32(vmulq_f32(v29, v34), v23));
      v39 = *(float32x4_t *)(v15 + 128);
      v40 = *(float32x4_t *)(v15 + 144);
      v41 = vaddq_f32(v39, vmulq_f32(v40, v36));
      v42 = vaddq_f32(v39, vmulq_f32(v40, v37));
      v43 = vaddq_f32(v39, vmulq_f32(v40, v38));
      v44 = *(float32x4_t *)(v15 + 160);
      v45 = *(float32x4_t *)(v15 + 176);
      v46 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v38, vaddq_f32(vaddq_f32(v44, vmulq_f32(v38, v45)), vmulq_f32(vmulq_f32(v38, v38), v43)))));
      v47 = *(float32x4_t *)(v15 + 192);
      v48 = *(float32x4_t *)(v15 + 208);
      v49 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v27, v31), vmulq_f32(v36, vaddq_f32(vaddq_f32(v44, vmulq_f32(v36, v45)), vmulq_f32(vmulq_f32(v36, v36), v41))))), v47);
      v50 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v44, vmulq_f32(v37, v45)), vmulq_f32(vmulq_f32(v37, v37), v42))))), v47);
      v51 = vmaxq_f32(v46, v47);
      v52 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v53 = vcvtq_f32_s32(vcvtq_s32_f32(v50));
      v54 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      v55 = vsubq_f32(v52, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v52, v49)));
      v56 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v53, v50)));
      v57 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v54, v51)));
      v58 = vsubq_f32(v49, v55);
      v59 = vsubq_f32(v50, v56);
      v60 = vsubq_f32(v51, v57);
      v61 = *(float32x4_t *)(v15 + 224);
      v62 = *(float32x4_t *)(v15 + 240);
      v63 = vaddq_f32(v48, vmulq_f32(v61, v59));
      v64 = vmulq_f32(v60, vaddq_f32(v62, vmulq_f32(v60, vaddq_f32(v48, vmulq_f32(v61, v60)))));
      v65 = vaddq_f32(v18, vmulq_f32(v58, vaddq_f32(v62, vmulq_f32(v58, vaddq_f32(v48, vmulq_f32(v61, v58))))));
      v66 = vcvtq_s32_f32(v56);
      v67 = vcvtq_s32_f32(v57);
      v68 = *(int32x4_t *)(v15 + 256);
      v69 = *(int8x16_t *)(v15 + 272);
      v70 = vbslq_s8(v69, *(int8x16_t *)(v6 + v12 - 16), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + v12 - 16), vmulq_f32(vaddq_f32(v18, vmulq_f32(v59, vaddq_f32(v62, vmulq_f32(v59, v63)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v68, v66), 0x17uLL)).f32[0]));
      v71 = vbslq_s8(v69, *(int8x16_t *)(v6 + v12), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + v12), vmulq_f32(vaddq_f32(v18, v64), (float32x4_t)vshlq_n_s32(vaddq_s32(v68, v67), 0x17uLL)).f32[0]));
      v72 = (int8x16_t *)(v5 + v12);
      v72[-2] = vbslq_s8(v69, *(int8x16_t *)(v6 + v12 - 32), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + v12 - 32), vmulq_f32(v65, (float32x4_t)vshlq_n_s32(vaddq_s32(v68, vcvtq_s32_f32(v55)), 0x17uLL)).f32[0]));
      v72[-1] = v70;
      *v72 = v71;
      v11 -= 3;
      v12 += 48;
    }
    while (v4 + v11 > 2);
    LODWORD(v73) = -v11;
    if ((int)v73 >= v4)
      goto LABEL_3;
LABEL_10:
    v73 = v73;
    do
    {
      v74 = *(float32x4_t *)(v8 + 16 * v73);
      v75 = *((_QWORD *)this + 51);
      v76 = *(float32x4_t *)(v75 + 32);
      v77 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v75 + 16), (int8x16_t)v74), (int8x16_t)v76);
      v78 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v77, *(float32x4_t *)(v75 + 96)));
      v79 = vsubq_f32(vsubq_f32(v77, v76), vmulq_f32(vmulq_f32(*(float32x4_t *)(v75 + 112), v78), v77));
      v80 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v75, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v74, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v75 + 64), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v75 + 48), v74))), *(float32x4_t *)(v75 + 80)), v78), vmulq_f32(v79, vaddq_f32(vaddq_f32(*(float32x4_t *)(v75 + 160), vmulq_f32(v79, *(float32x4_t *)(v75 + 176))), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(*(float32x4_t *)(v75 + 128), vmulq_f32(*(float32x4_t *)(v75 + 144), v79))))))),
              *(float32x4_t *)(v75 + 192));
      v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      v82 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v81, v80)));
      v83 = vsubq_f32(v80, v82);
      *(int8x16_t *)(v5 + 16 * v73) = vbslq_s8(*(int8x16_t *)(v75 + 272), *(int8x16_t *)(v6 + 16 * v73), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + 16 * v73), vmulq_f32(vaddq_f32(v76, vmulq_f32(v83, vaddq_f32(*(float32x4_t *)(v75 + 240), vmulq_f32(v83, vaddq_f32(*(float32x4_t *)(v75 + 208), vmulq_f32(*(float32x4_t *)(v75 + 224), v83)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v75 + 256),
                                                                        vcvtq_s32_f32(v82)),
                                                                      0x17uLL)).f32[0]));
      ++v73;
    }
    while (v73 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCinematicDepthFX_FadeOut::GetDOD(HgcCinematicDepthFX_FadeOut *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcCinematicDepthFX_FadeOut::GetROI(HgcCinematicDepthFX_FadeOut *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcCinematicDepthFX_FadeOut::HgcCinematicDepthFX_FadeOut(HgcCinematicDepthFX_FadeOut *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653F7C8;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B3051830;
  *(_OWORD *)(v3 + 32) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051840;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051850;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051860;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051870;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051880;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051890;
  *(_OWORD *)(v3 + 144) = xmmword_1B30518A0;
  *(_OWORD *)(v3 + 160) = xmmword_1B30518B0;
  *(_OWORD *)(v3 + 176) = xmmword_1B30518C0;
  *(_OWORD *)(v3 + 192) = xmmword_1B30518D0;
  *(_OWORD *)(v3 + 208) = xmmword_1B30518E0;
  *(_OWORD *)(v3 + 224) = xmmword_1B30518F0;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051900;
  *(_OWORD *)(v3 + 256) = xmmword_1B3051910;
  *(_OWORD *)(v3 + 272) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BB9EB0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCinematicDepthFX_FadeOut::~HgcCinematicDepthFX_FadeOut(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653F7C8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40A8CFB95ELL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653F7C8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40A8CFB95ELL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcCinematicDepthFX_FadeOut::SetParameter(HgcCinematicDepthFX_FadeOut *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCinematicDepthFX_FadeOut::GetParameter(HgcCinematicDepthFX_FadeOut *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcCinematicDepthFX_Fog::GetProgram(HgcCinematicDepthFX_Fog *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000400\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = c0.xxx - r0.xyz;\n"
             "    r0.xyz = fabs(r0.xyz)*half3(hg_Params[0].xyz);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
             "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
             "    output.color0.xyz = float3(r1.xyz) + float3(c0.xxx);\n"
             "    output.color0.w = float(r1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=95cd50d6:e7470ad6:0a32471f:84c275c9\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003d7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = c0.xxx - r0.xyz;\n"
             "    r0.xyz = fabs(r0.xyz)*hg_Params[0].xyz;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
             "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
             "    output.color0.xyz = r1.xyz + c0.xxx;\n"
             "    output.color0.w = r1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91a66ef9:927addd3:c7b26079:fd8ccfc6\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000381\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r0.xyz = c0.xxx - r0.xyz;\n"
           "    r0.xyz = abs(r0.xyz)*hg_ProgramLocal0.xyz;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
           "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
           "    gl_FragColor.xyz = r1.xyz + c0.xxx;\n"
           "    gl_FragColor.w = r1.w;\n"
           "}\n"
           "//MD5=4a441193:7bfac871:d695a5d5:1d33ddce\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcCinematicDepthFX_Fog::InitProgramDescriptor(HgcCinematicDepthFX_Fog *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCinematicDepthFX_Fog_hgc_visible", "//Metal1.0     \n//LEN=000000023d\n[[ visible ]] FragmentOut HgcCinematicDepthFX_Fog_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = color1.xyz;\n"
    "    r0.xyz = c0.xxx - r0.xyz;\n"
    "    r0.xyz = fabs(r0.xyz)*hg_Params[0].xyz;\n"
    "    r1 = color0;\n"
    "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
    "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
    "    output.color0.xyz = r1.xyz + c0.xxx;\n"
    "    output.color0.w = r1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBA338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBA36C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBA364);
}

double HgcCinematicDepthFX_Fog::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E70;
  strcpy(v3, "HgcCinematicDepthFX_Fog [hgc1]");
  return *(double *)"pthFX_Fog [hgc1]";
}

uint64_t HgcCinematicDepthFX_Fog::BindTexture(HgcCinematicDepthFX_Fog *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCinematicDepthFX_Fog::Bind(HgcCinematicDepthFX_Fog *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcCinematicDepthFX_Fog *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcCinematicDepthFX_Fog::RenderTile(HgcCinematicDepthFX_Fog *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t *v45;
  uint64_t v46;
  uint64_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 26);
    v8 = *((_QWORD *)a2 + 12);
    v9 = 16 * *((int *)a2 + 6);
    v10 = 16 * *((int *)a2 + 22);
    while (v4 < 3)
    {
      LODWORD(v46) = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      ++v3;
      v8 += v7;
      v5 += v9;
      v6 += v10;
      if (v3 == v2)
        return 0;
    }
    v11 = 0;
    v12 = 32;
    do
    {
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = *(float32x4_t *)(v6 + v12 - 32);
      v16 = *(float32x4_t *)(v6 + v12 - 16);
      v18 = *(float32x4_t *)(v13 + 32);
      v17 = *(float32x4_t *)(v13 + 48);
      v19 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v13, vabdq_f32(v14, *(float32x4_t *)(v8 + v12 - 32))), v18), v17);
      v20 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v13, vabdq_f32(v14, *(float32x4_t *)(v8 + v12 - 16))), v18), v17);
      v21 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v13, vabdq_f32(v14, *(float32x4_t *)(v8 + v12))), v18), v17);
      v22 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      v23 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      v24 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      v25 = vsubq_f32(v22, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v22, v19)));
      v26 = vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v23, v20)));
      v27 = vsubq_f32(v24, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v24, v21)));
      v28 = vsubq_f32(v19, v25);
      v29 = vsubq_f32(v20, v26);
      v30 = vsubq_f32(v21, v27);
      v31 = *(float32x4_t *)(v13 + 64);
      v32 = *(float32x4_t *)(v13 + 80);
      v33 = vaddq_f32(v31, vmulq_f32(v32, v28));
      v34 = vaddq_f32(v31, vmulq_f32(v32, v29));
      v35 = vaddq_f32(v31, vmulq_f32(v32, v30));
      v36 = *(float32x4_t *)(v13 + 96);
      v37 = *(int32x4_t *)(v13 + 112);
      v38 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v28, vaddq_f32(v36, vmulq_f32(v28, v33)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v37, vcvtq_s32_f32(v25)), 0x17uLL));
      v39 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v29, vaddq_f32(v36, vmulq_f32(v29, v34)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v37, vcvtq_s32_f32(v26)), 0x17uLL));
      v40 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v30, vaddq_f32(v36, vmulq_f32(v30, v35)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v37, vcvtq_s32_f32(v27)), 0x17uLL));
      v41 = *(int8x16_t *)(v13 + 128);
      v42 = (int8x16_t)vaddq_f32(v14, (float32x4_t)vbslq_s8(v41, (int8x16_t)v15, (int8x16_t)vsubq_f32(vmulq_f32(v15, v38), v38)));
      v43 = (int8x16_t)vaddq_f32(v14, (float32x4_t)vbslq_s8(v41, (int8x16_t)v16, (int8x16_t)vsubq_f32(vmulq_f32(v16, v39), v39)));
      v44 = vbslq_s8(v41, *(int8x16_t *)(v6 + v12), (int8x16_t)vaddq_f32(v14, (float32x4_t)vbslq_s8(v41, *(int8x16_t *)(v6 + v12), (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)(v6 + v12), v40), v40))));
      v45 = (int8x16_t *)(v5 + v12);
      v45[-2] = vbslq_s8(v41, (int8x16_t)v15, v42);
      v45[-1] = vbslq_s8(v41, (int8x16_t)v16, v43);
      *v45 = v44;
      v11 -= 3;
      v12 += 48;
    }
    while (v4 + v11 > 2);
    LODWORD(v46) = -v11;
    if ((int)v46 >= v4)
      goto LABEL_3;
LABEL_10:
    v46 = v46;
    do
    {
      v47 = *((_QWORD *)this + 51);
      v48 = *(float32x4_t *)(v47 + 16);
      v49 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v47, vabdq_f32(v48, *(float32x4_t *)(v8 + 16 * v46))), *(float32x4_t *)(v47 + 32)), *(float32x4_t *)(v47 + 48));
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v51 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v48, (int8x16_t)vcgtq_f32(v50, v49)));
      v52 = vsubq_f32(v49, v51);
      v53 = vmulq_f32(vaddq_f32(v48, vmulq_f32(v52, vaddq_f32(*(float32x4_t *)(v47 + 96), vmulq_f32(v52, vaddq_f32(*(float32x4_t *)(v47 + 64), vmulq_f32(*(float32x4_t *)(v47 + 80), v52)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v47 + 112), vcvtq_s32_f32(v51)), 0x17uLL));
      *(int8x16_t *)(v5 + 16 * v46) = vbslq_s8(*(int8x16_t *)(v47 + 128), *(int8x16_t *)(v6 + 16 * v46), (int8x16_t)vaddq_f32(v48, (float32x4_t)vbslq_s8(*(int8x16_t *)(v47 + 128), *(int8x16_t *)(v6 + 16 * v46), (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)(v6 + 16 * v46), v53), v53))));
      ++v46;
    }
    while (v46 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCinematicDepthFX_Fog::GetDOD(HgcCinematicDepthFX_Fog *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcCinematicDepthFX_Fog::GetROI(HgcCinematicDepthFX_Fog *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcCinematicDepthFX_Fog::HgcCinematicDepthFX_Fog(HgcCinematicDepthFX_Fog *this)
{
  _QWORD *v2;
  uint64_t v3;
  __int128 v4;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653FA30;
  v3 = operator new();
  *(_QWORD *)&v4 = 0x8000000080000000;
  *((_QWORD *)&v4 + 1) = 0x8000000080000000;
  *(_OWORD *)v3 = v4;
  *(_OWORD *)(v3 + 16) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 32) = xmmword_1B35259C0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 64) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 80) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 96) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 112) = xmmword_1B30516D0;
  *(_OWORD *)(v3 + 128) = xmmword_1B3050F70;
  *(_QWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 152) = 0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBA8C8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCinematicDepthFX_Fog::~HgcCinematicDepthFX_Fog(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653FA30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653FA30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B8406A4ELL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcCinematicDepthFX_Fog::SetParameter(HgcCinematicDepthFX_Fog *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  float v8;
  __n128 *v9;
  int32x4_t v10;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = -a3.n128_f32[0];
  v9 = (__n128 *)*((_QWORD *)this + 51);
  if (v9->n128_f32[0] == (float)-a3.n128_f32[0]
    && v9->n128_f32[1] == v8
    && v9->n128_f32[2] == v8
    && v9->n128_f32[3] == 0.0)
  {
    return 0;
  }
  v10 = vzip1q_s32((int32x4_t)LODWORD(v8), (int32x4_t)LODWORD(v8));
  *(float *)&v10.i32[2] = -a3.n128_f32[0];
  a3.n128_f32[1] = a4;
  *v9 = (__n128)v10;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v9[9] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCinematicDepthFX_Fog::GetParameter(HgcCinematicDepthFX_Fog *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = v3[36];
    a3[1] = v3[37];
    a3[2] = v3[38];
    result = v3[39];
    a3[3] = result;
  }
  return result;
}

const char *HgcGammaNoPremult::GetProgram(HgcGammaNoPremult *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002b3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = abs(r0);\n"
             "    r2.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = select(float4(r2), -float4(r2), float4(r0) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=07195965:b14d782f:2455a915:5205ce07\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000028e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = abs(r0);\n"
             "    r2.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = select(r2, -r2, r0 < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5bc0a167:957bca21:4fe89d3a:884daf25\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002b5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = abs(r0);\n"
           "    r2.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.w = r1.w;\n"
           "    gl_FragColor = vec4(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z "
           ": r2.z, r0.w < 0.00000 ? -r2.w : r2.w);\n"
           "}\n"
           "//MD5=9548e277:2e546086:10e1df88:2981f6f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGammaNoPremult::InitProgramDescriptor(HgcGammaNoPremult *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGammaNoPremult_hgc_visible", "//Metal1.0     \n//LEN=0000000169\n[[ visible ]] FragmentOut HgcGammaNoPremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = abs(r0);\n"
    "    r2.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r2.w = r1.w;\n"
    "    output.color0 = select(r2, -r2, r0 < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBACD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBAD08(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBAD00);
}

char *HgcGammaNoPremult::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EE0;
  strcpy(result, "HgcGammaNoPremult [hgc1]");
  return result;
}

uint64_t HgcGammaNoPremult::BindTexture(HgcGammaNoPremult *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGammaNoPremult::Bind(HgcGammaNoPremult *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcGammaNoPremult *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcGammaNoPremult::RenderTile(HgcGammaNoPremult *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v10;
  int8x16_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = *((_QWORD *)a2 + 10);
    v5 = 16 * *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 2);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      v9 = 0;
      do
      {
        v10 = *(float32x4_t *)(v4 + v9);
        v11 = (int8x16_t)vabsq_f32(v10);
        v12 = *((_QWORD *)this + 51);
        v13 = *(float32x4_t *)(v12 + 16);
        v14 = *(float32x4_t *)(v12 + 32);
        v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32(*(float32x4_t *)v12, v13)), v13), (int8x16_t)v14, v11);
        v16 = (int8x16_t)vcgtq_f32(*(float32x4_t *)(v12 + 48), v15);
        v17 = (int8x16_t)vmulq_f32(v15, vaddq_f32(v14, (float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 64), v16)));
        v18 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v12 + 80), v17), (int8x16_t)v14);
        v19 = *(int8x16_t *)(v12 + 128);
        v20 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 96), (int8x16_t)vceqq_f32(v15, *(float32x4_t *)(v12 + 96))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v15, v13), *(int8x16_t *)(v12 + 112)), (float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 96), (int8x16_t)vceqq_f32(v15, v13))), (float32x4_t)vandq_s8(v19, v16))), *(float32x4_t *)(v12 + 144)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)));
        v21 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v18, *(float32x4_t *)(v12 + 160)));
        v22 = vaddq_f32(v20, v21);
        v23 = vsubq_f32(vsubq_f32(v18, v14), vmulq_f32(vmulq_f32(*(float32x4_t *)(v12 + 176), v21), v18));
        v24 = vmulq_f32(v23, v23);
        v25 = vmulq_f32(*(float32x4_t *)v12, vaddq_f32(v22, vmulq_f32(v23, vaddq_f32(*(float32x4_t *)(v12 + 320), vmulq_f32(v23, vaddq_f32(vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 288), vmulq_f32(*(float32x4_t *)(v12 + 304), v23)), vmulq_f32(v24, vaddq_f32(*(float32x4_t *)(v12 + 256), vmulq_f32(*(float32x4_t *)(v12 + 272), v23)))), vmulq_f32(vmulq_f32(v24, v24), vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 224), vmulq_f32(*(float32x4_t *)(v12 + 240), v23)),
                              vmulq_f32(v24, vaddq_f32(*(float32x4_t *)(v12 + 192), vmulq_f32(*(float32x4_t *)(v12 + 208), v23)))))))))));
        v26 = vminq_f32(vmaxq_f32(v25, *(float32x4_t *)(v12 + 336)), *(float32x4_t *)(v12 + 352));
        v27 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
        v28 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v27, v26)));
        v29 = vsubq_f32(v26, v28);
        v30 = vmulq_f32(v29, v29);
        v31 = (int8x16_t)vcgtq_f32(*(float32x4_t *)(v12 + 464), v28);
        *(int8x16_t *)(v6 + v9) = veorq_s8(vbslq_s8(*(int8x16_t *)(v12 + 512), v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25))), v13), (int8x16_t)vmulq_f32(vaddq_f32(v14, (float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 480), v31)), vmulq_f32(vaddq_f32(v14, vmulq_f32(
                                                           v29,
                                                           vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 432), vmulq_f32(v29, *(float32x4_t *)(v12 + 448))), vmulq_f32(v30, vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 400), vmulq_f32(*(float32x4_t *)(v12 + 416), v29)), vmulq_f32(v30, vaddq_f32(*(float32x4_t *)(v12 + 368), vmulq_f32(*(float32x4_t *)(v12 + 384), v29)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v12 + 496), vcvtq_s32_f32(vaddq_f32(
                                                                            v28,
                                                                            (float32x4_t)vandq_s8(v19, v31)))),
                                                                      0x17uLL))),
                                        (int8x16_t)v25)),
                                    vandq_s8(*(int8x16_t *)(v12 + 528), (int8x16_t)v10));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcGammaNoPremult::GetDOD(HgcGammaNoPremult *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcGammaNoPremult::GetROI(HgcGammaNoPremult *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcGammaNoPremult::HgcGammaNoPremult(HgcGammaNoPremult *this)
{
  _QWORD *v2;
  uint64_t v3;
  __int128 v4;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653FC98;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 48) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 64) = xmmword_1B3525920;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_QWORD *)&v4 = 0x3F0000003FLL;
  *((_QWORD *)&v4 + 1) = 0x3F0000003FLL;
  *(int32x4_t *)(v3 + 96) = vdupq_n_s32(0x7F800000u);
  *(_OWORD *)(v3 + 112) = v4;
  *(_OWORD *)(v3 + 128) = xmmword_1B3525930;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 192) = xmmword_1B3525940;
  *(_OWORD *)(v3 + 208) = xmmword_1B3525950;
  *(_OWORD *)(v3 + 224) = xmmword_1B3525960;
  *(_OWORD *)(v3 + 240) = xmmword_1B3525970;
  *(_OWORD *)(v3 + 256) = xmmword_1B3525980;
  *(_OWORD *)(v3 + 272) = xmmword_1B3525990;
  *(_OWORD *)(v3 + 288) = xmmword_1B35259A0;
  *(_OWORD *)(v3 + 304) = xmmword_1B35259B0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35259C0;
  *(_OWORD *)(v3 + 336) = xmmword_1B35259D0;
  *(_OWORD *)(v3 + 352) = xmmword_1B35259E0;
  *(_OWORD *)(v3 + 368) = xmmword_1B35259F0;
  *(_OWORD *)(v3 + 384) = xmmword_1B3525A00;
  *(_OWORD *)(v3 + 400) = xmmword_1B3525A10;
  *(_OWORD *)(v3 + 416) = xmmword_1B3525A20;
  *(_OWORD *)(v3 + 432) = xmmword_1B3525A30;
  *(_OWORD *)(v3 + 448) = xmmword_1B3525A40;
  *(_OWORD *)(v3 + 464) = xmmword_1B3525A50;
  *(_OWORD *)(v3 + 480) = xmmword_1B3553170;
  *(_OWORD *)(v3 + 496) = xmmword_1B30516D0;
  *(_QWORD *)&v4 = 0x8000000080000000;
  *((_QWORD *)&v4 + 1) = 0x8000000080000000;
  *(_OWORD *)(v3 + 512) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 528) = v4;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBB280(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGammaNoPremult::~HgcGammaNoPremult(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653FC98;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4027AB4E27);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E653FC98;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4027AB4E27);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653FC98;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4027AB4E27);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcGammaNoPremult::SetParameter(HgcGammaNoPremult *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcGammaNoPremult::GetParameter(HgcGammaNoPremult *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcToneParamCurve1AntiSymmetric::GetProgram(HgcToneParamCurve1AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000051c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[3].xyz);\n"
             "    r1.w = pow(r2.z, half(hg_Params[0].z));\n"
             "    r1.z = select(r1.w, c0.z, r1.z < 0.00000h);\n"
             "    output.color0.z = select(float(r1.z), -float(r1.z), float(r0.z) < 0.00000h);\n"
             "    r0.z = pow(r2.y, half(hg_Params[0].y));\n"
             "    r1.z = pow(r2.x, half(hg_Params[0].x));\n"
             "    r0.z = select(r0.z, c0.z, r1.y < 0.00000h);\n"
             "    r1.x = select(r1.z, c0.z, r1.x < 0.00000h);\n"
             "    output.color0.y = select(float(r0.z), -float(r0.z), float(r0.y) < 0.00000h);\n"
             "    output.color0.x = select(float(r1.x), -float(r1.x), float(r0.x) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d718f972:caaf58f4:2a79117f:c79f3bd7\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = r1.xyz - hg_Params[3].xyz;\n"
             "    r1.w = pow(r2.z, hg_Params[0].z);\n"
             "    r1.z = select(r1.w, c0.z, r1.z < 0.00000f);\n"
             "    output.color0.z = select(r1.z, -r1.z, r0.z < 0.00000f);\n"
             "    r0.z = pow(r2.y, hg_Params[0].y);\n"
             "    r1.z = pow(r2.x, hg_Params[0].x);\n"
             "    r0.z = select(r0.z, c0.z, r1.y < 0.00000f);\n"
             "    r1.x = select(r1.z, c0.z, r1.x < 0.00000f);\n"
             "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
             "    output.color0.x = select(r1.x, -r1.x, r0.x < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=8bd267df:aff60290:d6b8443b:3a9c691b\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal3.xyz;\n"
           "    r1.w = pow(r2.z, hg_ProgramLocal0.z);\n"
           "    r1.z = r1.z < 0.00000 ? c0.z : r1.w;\n"
           "    gl_FragColor.z = r0.z < 0.00000 ? -r1.z : r1.z;\n"
           "    r0.z = pow(r2.y, hg_ProgramLocal0.y);\n"
           "    r1.z = pow(r2.x, hg_ProgramLocal0.x);\n"
           "    r0.z = r1.y < 0.00000 ? c0.z : r0.z;\n"
           "    r1.x = r1.x < 0.00000 ? c0.z : r1.z;\n"
           "    gl_FragColor.y = r0.y < 0.00000 ? -r0.z : r0.z;\n"
           "    gl_FragColor.x = r0.x < 0.00000 ? -r1.x : r1.x;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=0e82e012:3c12addf:abe4b0a7:1bdc9d8c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve1AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve1AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve1AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=0000000394\n[[ visible ]] FragmentOut HgcToneParamCurve1AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = r1.xyz - hg_Params[3].xyz;\n"
    "    r1.w = pow(r2.z, hg_Params[0].z);\n"
    "    r1.z = select(r1.w, c0.z, r1.z < 0.00000f);\n"
    "    output.color0.z = select(r1.z, -r1.z, r0.z < 0.00000f);\n"
    "    r0.z = pow(r2.y, hg_Params[0].y);\n"
    "    r1.z = pow(r2.x, hg_Params[0].x);\n"
    "    r0.z = select(r0.z, c0.z, r1.y < 0.00000f);\n"
    "    r1.x = select(r1.z, c0.z, r1.x < 0.00000f);\n"
    "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
    "    output.color0.x = select(r1.x, -r1.x, r0.x < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBB6B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBB6E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBB6E0);
}

char *HgcToneParamCurve1AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B35531A0;
  strcpy(result, "HgcToneParamCurve1AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve1AntiSymmetric::BindTexture(HgcToneParamCurve1AntiSymmetric *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve1AntiSymmetric::Bind(HgcToneParamCurve1AntiSymmetric *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcToneParamCurve1AntiSymmetric *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve1AntiSymmetric::RenderTile(HgcToneParamCurve1AntiSymmetric *this, HGTile *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v10;
  _OWORD *v11;
  int8x16_t v12;
  int32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  float32x4_t v79;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = *((_QWORD *)a2 + 10);
    v5 = 16 * *((int *)a2 + 22);
    v6 = *((_QWORD *)a2 + 2);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      v9 = 0;
      do
      {
        v79 = *(float32x4_t *)(v4 + v9);
        v10 = vabsq_f32(v79);
        v11 = (_OWORD *)*((_QWORD *)this + 51);
        v12 = *(int8x16_t *)v11;
        v13 = (int32x4_t)vaddq_f32(*((float32x4_t *)v11 + 2), vmulq_f32(v10, *((float32x4_t *)v11 + 1)));
        v14 = *((float32x4_t *)v11 + 4);
        v15 = *((float32x4_t *)v11 + 5);
        v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)v11), v14)), v14), (int8x16_t)v15, (int8x16_t)vrev64q_s32(v13));
        v18 = *((int8x16_t *)v11 + 6);
        v17 = *((float32x4_t *)v11 + 7);
        v19 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v16, v18), (int8x16_t)v15);
        v20 = *((float32x4_t *)v11 + 8);
        v21 = *((float32x4_t *)v11 + 9);
        v22 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v17, v16))), v21);
        v23 = *((float32x4_t *)v11 + 10);
        v24 = *((float32x4_t *)v11 + 11);
        v25 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v19, v23));
        v26 = vaddq_f32(v22, v25);
        v27 = vsubq_f32(vsubq_f32(v19, v15), vmulq_f32(vmulq_f32(v24, v25), v19));
        v28 = *((float32x4_t *)v11 + 12);
        v29 = *((float32x4_t *)v11 + 13);
        v30 = vmulq_f32(v27, v27);
        v31 = *((float32x4_t *)v11 + 14);
        v32 = *((float32x4_t *)v11 + 15);
        v33 = *((float32x4_t *)v11 + 16);
        v34 = *((float32x4_t *)v11 + 17);
        v35 = *((float32x4_t *)v11 + 18);
        v36 = *((float32x4_t *)v11 + 19);
        v38 = *((float32x4_t *)v11 + 20);
        v37 = *((float32x4_t *)v11 + 21);
        v39 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(v26, vmulq_f32(v27, vaddq_f32(v35, vmulq_f32(v27, vaddq_f32(vaddq_f32(v33, vmulq_f32(v27, v34)), vmulq_f32(v30, vaddq_f32(vaddq_f32(v28, vmulq_f32(v29, v27)), vmulq_f32(v30, vaddq_f32(v31, vmulq_f32(v32, v27)))))))))), *(float32x4_t *)v11, 2), v36);
        v40 = *((float32x4_t *)v11 + 22);
        v41 = *((float32x4_t *)v11 + 23);
        v42 = *((float32x4_t *)v11 + 24);
        v43 = *((int32x4_t *)v11 + 25);
        v44 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vceqq_f32((float32x4_t)vextq_s8(v12, v12, 0xCuLL), v42)), v42), (int8x16_t)v41, vextq_s8((int8x16_t)v13, (int8x16_t)v13, 0xCuLL));
        v45 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        v46 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v44, v18), (int8x16_t)v41);
        v47 = (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v46, v36));
        v48 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v44, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v37, (int8x16_t)vcgtq_f32(v40, v44))), v38), v47);
        v49 = vsubq_f32(vsubq_f32(v46, v41), vmulq_f32(vmulq_f32(v35, v47), v46));
        v50 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v45, v39)));
        v51 = vmulq_f32(v49, v49);
        v52 = vsubq_f32(v39, v50);
        v53 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v48, vmulq_f32(v49, vaddq_f32(v24, vmulq_f32(v49, vaddq_f32(vaddq_f32(v29, vmulq_f32(v28, v49)), vmulq_f32(v51, vaddq_f32(vaddq_f32(v34, vmulq_f32(v33, v49)), vmulq_f32(v51, vaddq_f32(v32, vmulq_f32(v31, v49)))))))))), *(float32x2_t *)v11, 1), v23);
        v54 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
        v55 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v54, v53)));
        v56 = vsubq_f32(v53, v55);
        v57 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vceqq_f32((float32x4_t)vextq_s8(v12, v12, 8uLL), v42)), v42), (int8x16_t)v41, vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL));
        v58 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v57, v18), (int8x16_t)v41);
        v59 = (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v58, v36));
        v60 = vsubq_f32(vsubq_f32(v58, v41), vmulq_f32(vmulq_f32(v35, v59), v58));
        v61 = vaddq_f32(v29, vmulq_f32(v28, v60));
        v62 = vmulq_f32(v60, v60);
        v63 = vmulq_f32(v60, vaddq_f32(v24, vmulq_f32(v60, vaddq_f32(v61, vmulq_f32(v62, vaddq_f32(vaddq_f32(v34, vmulq_f32(v33, v60)), vmulq_f32(v62, vaddq_f32(v32, vmulq_f32(v31, v60)))))))));
        v64 = (int8x16_t)vmulq_f32(vaddq_f32(v15, vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v52, vaddq_f32(vaddq_f32(v40, vmulq_f32(v41, v52)), vmulq_f32(vmulq_f32(v52, v52), vaddq_f32(v38, vmulq_f32(v37, v52)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v43, vcvtq_s32_f32(v50)), 0x17uLL));
        v65 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v57, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v37, (int8x16_t)vcgtq_f32(v40, v57))), v38), v59), v63), COERCE_FLOAT(*v11)), v23);
        v66 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
        v67 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v66, v65)));
        v68 = vsubq_f32(v65, v67);
        v69 = vaddq_f32(v41, vmulq_f32(v56, vaddq_f32(v14, vmulq_f32(v56, vaddq_f32(vaddq_f32(v17, vmulq_f32(v15, v56)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v21, vmulq_f32(v20, v56))))))));
        v70 = vaddq_f32(v14, vmulq_f32(v68, vaddq_f32(vaddq_f32(v17, vmulq_f32(v15, v68)), vmulq_f32(vmulq_f32(v68, v68), vaddq_f32(v21, vmulq_f32(v20, v68))))));
        v71 = *((int32x4_t *)v11 + 27);
        v72 = vmulq_f32(v68, v70);
        v73 = *((int8x16_t *)v11 + 26);
        v74 = (float32x4_t)vbslq_s8(v73, v64, (int8x16_t)vsubq_f32(v10, *((float32x4_t *)v11 + 3)));
        v75 = (int8x16_t)vmulq_f32(vaddq_f32(v41, v72), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v67), v71), 0x17uLL));
        v20.i64[0] = vextq_s8(v75, (int8x16_t)v74, 0xCuLL).u64[0];
        v21.i64[0] = v74.i64[0];
        v21.i64[1] = v75.i64[1];
        *(int8x8_t *)&v20.u32[2] = vext_s8(*(int8x8_t *)v74.f32, (int8x8_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL), 4uLL);
        v76 = vbslq_s8(*((int8x16_t *)v11 + 28), vbslq_s8((int8x16_t)vcgtq_f32(v42, v20), (int8x16_t)v42, vbslq_s8(*((int8x16_t *)v11 + 28), (int8x16_t)vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v71, vcvtq_s32_f32(v55)), 0x17uLL)), (int8x16_t)v79)), (int8x16_t)v79);
        v77 = vandq_s8(v76, (int8x16_t)v71);
        v75.i64[0] = veorq_s8(v77, vextq_s8(v76, v76, 4uLL)).u64[0];
        v75.i64[1] = veorq_s8(vandq_s8(*(int8x16_t *)&v43, *(int8x16_t *)&v79), vbslq_s8((int8x16_t)vcgtq_f32(v42, v74), *(int8x16_t *)&v42, (int8x16_t)vrev64q_s32(*(int32x4_t *)&v74))).i64[1];
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v73, v76, vbslq_s8(*((int8x16_t *)v11 + 29), veorq_s8(v77, vbslq_s8((int8x16_t)vcgtq_f32(v42, v21), (int8x16_t)v42, vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL))), v75));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcToneParamCurve1AntiSymmetric::GetDOD(HgcToneParamCurve1AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve1AntiSymmetric::GetROI(HgcToneParamCurve1AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(HgcToneParamCurve1AntiSymmetric *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E653FF00;
  v3 = (_OWORD *)operator new();
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[4] = xmmword_1B35531B0;
  v3[5] = xmmword_1B35531C0;
  v3[6] = xmmword_1B35531D0;
  v3[7] = xmmword_1B35531E0;
  v3[8] = xmmword_1B35531F0;
  v3[9] = xmmword_1B3553200;
  v3[10] = xmmword_1B3553210;
  v3[11] = xmmword_1B3553220;
  v3[12] = xmmword_1B3553230;
  v3[13] = xmmword_1B3553240;
  v3[14] = xmmword_1B3553250;
  v3[15] = xmmword_1B3553260;
  v3[16] = xmmword_1B3553270;
  v3[17] = xmmword_1B3553280;
  v3[18] = xmmword_1B3553290;
  v3[19] = xmmword_1B35532A0;
  v3[20] = xmmword_1B35532B0;
  v3[21] = xmmword_1B35532C0;
  v3[22] = xmmword_1B35532D0;
  v3[23] = xmmword_1B35532E0;
  v3[24] = xmmword_1B3050F50;
  v3[25] = xmmword_1B35532F0;
  v3[26] = xmmword_1B3050F70;
  v3[27] = xmmword_1B3553300;
  v3[28] = xmmword_1B3050FE0;
  v3[29] = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBBE84(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve1AntiSymmetric::~HgcToneParamCurve1AntiSymmetric(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E653FF00;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40048C4DA3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E653FF00;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40048C4DA3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve1AntiSymmetric::SetParameter(HgcToneParamCurve1AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve1AntiSymmetric::GetParameter(HgcToneParamCurve1AntiSymmetric *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve2AntiSymmetric::GetProgram(HgcToneParamCurve2AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[4].xyz);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r2.xyz + half3(hg_Params[3].xyz);\n"
             "    r2.xz = select(r2.xz, half2(hg_Params[3].xz), r1.xz < 0.00000h);\n"
             "    output.color0.xz = select(float2(r2.xz), -float2(r2.xz), float2(r0.xz) < 0.00000h);\n"
             "    r0.z = select(r2.y, half(hg_Params[3].y), r1.y < 0.00000h);\n"
             "    output.color0.y = select(float(r0.z), -float(r0.z), float(r0.y) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=058b8728:b732aed8:ceabb34a:625557cb\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003eb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r2.xyz + hg_Params[3].xyz;\n"
             "    r2.xz = select(r2.xz, hg_Params[3].xz, r1.xz < 0.00000f);\n"
             "    output.color0.xz = select(r2.xz, -r2.xz, r0.xz < 0.00000f);\n"
             "    r0.z = select(r2.y, hg_Params[3].y, r1.y < 0.00000f);\n"
             "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce2eeb4b:e2a50521:c7bd3e50:b5953cf0\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000048e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal4.xyz;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r2.xyz + hg_ProgramLocal3.xyz;\n"
           "    r2.xz = vec2(r1.x < 0.00000 ? hg_ProgramLocal3.x : r2.x, r1.z < 0.00000 ? hg_ProgramLocal3.z : r2.z);\n"
           "    gl_FragColor.xz = vec2(r0.x < 0.00000 ? -r2.x : r2.x, r0.z < 0.00000 ? -r2.z : r2.z);\n"
           "    r0.z = r1.y < 0.00000 ? hg_ProgramLocal3.y : r2.y;\n"
           "    gl_FragColor.y = r0.y < 0.00000 ? -r0.z : r0.z;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=56d606f4:e7adcee5:7dc2a713:12142499\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve2AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve2AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve2AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=00000002d4\n[[ visible ]] FragmentOut HgcToneParamCurve2AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r2.xyz + hg_Params[3].xyz;\n"
    "    r2.xz = select(r2.xz, hg_Params[3].xz, r1.xz < 0.00000f);\n"
    "    output.color0.xz = select(r2.xz, -r2.xz, r0.xz < 0.00000f);\n"
    "    r0.z = select(r2.y, hg_Params[3].y, r1.y < 0.00000f);\n"
    "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBC298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBC2C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBC2C0);
}

char *HgcToneParamCurve2AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B35531A0;
  strcpy(result, "HgcToneParamCurve2AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve2AntiSymmetric::BindTexture(HgcToneParamCurve2AntiSymmetric *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve2AntiSymmetric::Bind(HgcToneParamCurve2AntiSymmetric *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcToneParamCurve2AntiSymmetric *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve2AntiSymmetric::RenderTile(HgcToneParamCurve2AntiSymmetric *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int32x4_t v79;
  int32x4_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  int8x16_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t v95;
  int8x16_t v96;
  int8x16_t v97;
  int8x16_t *v98;
  int v99;
  uint64_t v100;
  float32x4_t v101;
  float32x4_t v102;
  uint64_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  int8x16_t v117;
  int8x16_t v118;
  int8x16_t v119;
  int8x16_t v120;
  int8x16_t v121;
  int8x16_t v122;
  int8x16_t v123;
  int8x16_t v124;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v99 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = vabsq_f32(v11);
      v14 = vabsq_f32(v12);
      v15 = *((_QWORD *)this + 51);
      v16 = *(float32x4_t *)(v15 + 16);
      v17 = *(float32x4_t *)(v15 + 32);
      v18 = *(float32x4_t *)(v15 + 48);
      v19 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v13, v16));
      v20 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v14, v16));
      v22 = *(float32x4_t *)(v15 + 64);
      v21 = *(float32x4_t *)(v15 + 80);
      v23 = *(float32x4_t *)(v15 + 96);
      v24 = *(int8x16_t *)(v15 + 112);
      v25 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vceqq_f32(*(float32x4_t *)v15, v21)), v21);
      v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v19);
      v27 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v20);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v26), (int8x16_t)v23);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v27), (int8x16_t)v23);
      v30 = *(float32x4_t *)(v15 + 128);
      v31 = *(int8x16_t *)(v15 + 144);
      v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v26)));
      v33 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v27)));
      v34 = *(float32x4_t *)(v15 + 160);
      v35 = *(float32x4_t *)(v15 + 176);
      v36 = vsubq_f32(v32, v34);
      v37 = vsubq_f32(v33, v34);
      v38 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, v35));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v29, v35));
      v40 = *(float32x4_t *)(v15 + 192);
      v41 = *(float32x4_t *)(v15 + 208);
      v42 = vaddq_f32(v36, v38);
      v43 = vsubq_f32(vsubq_f32(v28, v23), vmulq_f32(vmulq_f32(v40, v38), v28));
      v44 = vsubq_f32(vsubq_f32(v29, v23), vmulq_f32(vmulq_f32(v40, v39), v29));
      v45 = vmulq_f32(v43, v43);
      v46 = *(float32x4_t *)(v15 + 224);
      v47 = *(float32x4_t *)(v15 + 240);
      v48 = vaddq_f32(v41, vmulq_f32(v46, v43));
      v49 = vaddq_f32(v41, vmulq_f32(v46, v44));
      v50 = *(float32x4_t *)(v15 + 256);
      v51 = *(float32x4_t *)(v15 + 272);
      v52 = vaddq_f32(v47, vmulq_f32(v50, v43));
      v53 = vaddq_f32(v47, vmulq_f32(v50, v44));
      v54 = *(float32x4_t *)(v15 + 288);
      v55 = *(float32x4_t *)(v15 + 304);
      v56 = vaddq_f32(v51, vmulq_f32(v43, v54));
      v57 = vaddq_f32(v51, vmulq_f32(v44, v54));
      v58 = vmulq_f32(v44, v44);
      v59 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(v55, vmulq_f32(v43, vaddq_f32(v56, vmulq_f32(v45, vaddq_f32(v48, vmulq_f32(v45, v52)))))))));
      v60 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v37, v39), vmulq_f32(v44, vaddq_f32(v55, vmulq_f32(v44, vaddq_f32(v57, vmulq_f32(v58, vaddq_f32(v49, vmulq_f32(v58, v53)))))))));
      v61 = *(float32x4_t *)(v15 + 320);
      v62 = *(float32x4_t *)(v15 + 336);
      v63 = vmaxq_f32(v59, v61);
      v64 = vmaxq_f32(v60, v61);
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v65, v63)));
      v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v66, v64)));
      v69 = vsubq_f32(v63, v67);
      v70 = vsubq_f32(v64, v68);
      v71 = *(float32x4_t *)(v15 + 352);
      v72 = *(float32x4_t *)(v15 + 368);
      v73 = vaddq_f32(v62, vmulq_f32(v71, v69));
      v74 = vaddq_f32(v62, vmulq_f32(v71, v70));
      v76 = *(float32x4_t *)(v15 + 384);
      v75 = *(float32x4_t *)(v15 + 400);
      v77 = vaddq_f32(v23, vmulq_f32(v69, vaddq_f32(v75, vmulq_f32(v69, vaddq_f32(vaddq_f32(v72, vmulq_f32(v69, v76)), vmulq_f32(vmulq_f32(v69, v69), v73))))));
      v78 = vaddq_f32(v23, vmulq_f32(v70, vaddq_f32(v75, vmulq_f32(v70, vaddq_f32(vaddq_f32(v72, vmulq_f32(v76, v70)), vmulq_f32(vmulq_f32(v70, v70), v74))))));
      v79 = vcvtq_s32_f32(v68);
      v80 = *(int32x4_t *)(v15 + 416);
      v81 = *(int8x16_t *)(v15 + 432);
      v82 = (int8x16_t)vaddq_f32(v18, vmulq_f32(v77, (float32x4_t)vshlq_n_s32(vaddq_s32(v80, vcvtq_s32_f32(v67)), 0x17uLL)));
      v83 = (int8x16_t)vaddq_f32(v18, vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v80, v79), 0x17uLL)));
      v84 = (int8x16_t)vcgtq_f32(v21, vsubq_f32(v13, v22));
      v85 = (int8x16_t)vcgtq_f32(v21, vsubq_f32(v14, v22));
      v86 = vbslq_s8(v81, v82, vbslq_s8(v84, (int8x16_t)v18, v82));
      v87 = vbslq_s8(v81, v83, vbslq_s8(v85, (int8x16_t)v18, v83));
      v88 = *(int8x16_t *)(v15 + 448);
      v89 = *(int8x16_t *)(v15 + 464);
      v90 = vandq_s8(v88, (int8x16_t)v12);
      v91 = veorq_s8(v86, vandq_s8(v88, (int8x16_t)v11));
      v92 = vbslq_s8(v84, (int8x16_t)v18, v86);
      v93 = vbslq_s8(v85, (int8x16_t)v18, v87);
      v94 = vbslq_s8(v89, vextq_s8(v92, v92, 0xCuLL), (int8x16_t)v11);
      v95 = vbslq_s8(v89, vextq_s8(v93, v93, 0xCuLL), (int8x16_t)v12);
      v96 = vbslq_s8(v81, veorq_s8(vandq_s8(v95, v88), vextq_s8(v95, v95, 4uLL)), veorq_s8(v87, v90));
      v97 = *(int8x16_t *)(v15 + 480);
      v98 = (int8x16_t *)(v5 + v10);
      v98[-1] = vbslq_s8(v97, v94, vbslq_s8(v81, veorq_s8(vandq_s8(v94, v88), vextq_s8(v94, v94, 4uLL)), v91));
      *v98 = vbslq_s8(v97, v95, v96);
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v99 = -v9;
    if (v99 >= v4)
      goto LABEL_3;
LABEL_10:
    v100 = 16 * v99;
    v101 = *(float32x4_t *)(v6 + v100);
    v102 = vabsq_f32(v101);
    v103 = *((_QWORD *)this + 51);
    v104 = *(float32x4_t *)(v103 + 48);
    v105 = *(float32x4_t *)(v103 + 80);
    v106 = *(float32x4_t *)(v103 + 96);
    v107 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vceqq_f32(*(float32x4_t *)v103, v105)), v105), (int8x16_t)v106, (int8x16_t)vaddq_f32(*(float32x4_t *)(v103 + 32), vmulq_f32(v102, *(float32x4_t *)(v103 + 16))));
    v108 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v103 + 112), (int8x16_t)v107), (int8x16_t)v106);
    v109 = (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v108, *(float32x4_t *)(v103 + 176)));
    v110 = vsubq_f32(vsubq_f32(v108, v106), vmulq_f32(vmulq_f32(*(float32x4_t *)(v103 + 192), v109), v108));
    v111 = vmulq_f32(v110, v110);
    v112 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v103, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v107, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v103 + 144), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v103 + 128), v107))), *(float32x4_t *)(v103 + 160)), v109), vmulq_f32(v110, vaddq_f32(*(float32x4_t *)(v103 + 304), vmulq_f32(v110, vaddq_f32(
                         vaddq_f32(*(float32x4_t *)(v103 + 272), vmulq_f32(v110, *(float32x4_t *)(v103 + 288))),
                         vmulq_f32(v111, vaddq_f32(vaddq_f32(*(float32x4_t *)(v103 + 208), vmulq_f32(*(float32x4_t *)(v103 + 224), v110)), vmulq_f32(v111, vaddq_f32(*(float32x4_t *)(v103 + 240), vmulq_f32(*(float32x4_t *)(v103 + 256), v110))))))))))), *(float32x4_t *)(v103 + 320));
    v113 = vcvtq_f32_s32(vcvtq_s32_f32(v112));
    v114 = vsubq_f32(v113, (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v113, v112)));
    v115 = vsubq_f32(v112, v114);
    v116 = vaddq_f32(v106, vmulq_f32(v115, vaddq_f32(*(float32x4_t *)(v103 + 400), vmulq_f32(v115, vaddq_f32(vaddq_f32(*(float32x4_t *)(v103 + 368), vmulq_f32(*(float32x4_t *)(v103 + 384), v115)), vmulq_f32(vmulq_f32(v115, v115), vaddq_f32(*(float32x4_t *)(v103 + 336), vmulq_f32(*(float32x4_t *)(v103 + 352), v115))))))));
    v117 = *(int8x16_t *)(v103 + 432);
    v118 = (int8x16_t)vaddq_f32(v104, vmulq_f32(v116, (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v103 + 416), vcvtq_s32_f32(v114)), 0x17uLL)));
    v119 = (int8x16_t)vcgtq_f32(v105, vsubq_f32(v102, *(float32x4_t *)(v103 + 64)));
    v120 = vbslq_s8(v117, v118, vbslq_s8(v119, (int8x16_t)v104, v118));
    v121 = *(int8x16_t *)(v103 + 448);
    v122 = veorq_s8(v120, vandq_s8(v121, (int8x16_t)v101));
    v123 = vbslq_s8(v119, (int8x16_t)v104, v120);
    v124 = vbslq_s8(*(int8x16_t *)(v103 + 464), vextq_s8(v123, v123, 0xCuLL), (int8x16_t)v101);
    *(int8x16_t *)(v5 + v100) = vbslq_s8(*(int8x16_t *)(v103 + 480), v124, vbslq_s8(v117, veorq_s8(vandq_s8(v124, v121), vextq_s8(v124, v124, 4uLL)), v122));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve2AntiSymmetric::GetDOD(HgcToneParamCurve2AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve2AntiSymmetric::GetROI(HgcToneParamCurve2AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(HgcToneParamCurve2AntiSymmetric *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6540168;
  v3 = (_OWORD *)operator new();
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[6] = xmmword_1B3051560;
  v3[7] = xmmword_1B3051600;
  v3[8] = xmmword_1B3051610;
  v3[9] = xmmword_1B3051620;
  v3[10] = xmmword_1B3051630;
  v3[11] = xmmword_1B3051640;
  v3[12] = xmmword_1B3051510;
  v3[13] = xmmword_1B3525860;
  v3[14] = xmmword_1B3525870;
  v3[15] = xmmword_1B3525880;
  v3[16] = xmmword_1B3525890;
  v3[17] = xmmword_1B35258A0;
  v3[18] = xmmword_1B35258B0;
  v3[19] = xmmword_1B35258C0;
  v3[20] = xmmword_1B3051690;
  v3[21] = xmmword_1B35258D0;
  v3[22] = xmmword_1B35258E0;
  v3[23] = xmmword_1B35258F0;
  v3[24] = xmmword_1B3525900;
  v3[25] = xmmword_1B3525910;
  v3[26] = xmmword_1B30516D0;
  v3[27] = xmmword_1B3050FF0;
  v3[28] = xmmword_1B3053570;
  v3[29] = xmmword_1B3050FE0;
  v3[30] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBCB18(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve2AntiSymmetric::~HgcToneParamCurve2AntiSymmetric(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6540168;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4051E21E55);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6540168;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4051E21E55);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve2AntiSymmetric::SetParameter(HgcToneParamCurve2AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve2AntiSymmetric::GetParameter(HgcToneParamCurve2AntiSymmetric *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve3AntiSymmetric::GetProgram(HgcToneParamCurve3AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = abs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xyz));\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[3].xyz) + -r2.xyz;\n"
             "    r1.xyz = half3(r1.xyz < half3(hg_Params[4].xyz));\n"
             "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
             "    r1.xyz = r2.xyz*c0.xxx;\n"
             "    r0.xyz = half3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r1.xyz) + float3(r2.xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5899dcc:9555caf0:c3bcf81f:37a2c769\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000003f4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = abs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
             "    r3.xyz = r1.xyz*hg_Params[3].xyz + -r2.xyz;\n"
             "    r1.xyz = float3(r1.xyz < hg_Params[4].xyz);\n"
             "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
             "    r1.xyz = r2.xyz*c0.xxx;\n"
             "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = r0.xyz*r1.xyz + r2.xyz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=eef59206:cc43f70e:921111e4:957edf63\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000046c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xyz);\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal3.xyz + -r2.xyz;\n"
           "    r1.xyz = vec3(lessThan(r1.xyz, hg_ProgramLocal4.xyz));\n"
           "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
           "    r1.xyz = r2.xyz*c0.xxx;\n"
           "    r0.xyz = vec3(lessThan(r0.xyz, c0.yyy));\n"
           "    gl_FragColor.xyz = r0.xyz*r1.xyz + r2.xyz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=22cc40e9:55017b8d:7a25fcde:8c47c86f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0005:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve3AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve3AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve3AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=00000002dd\n[[ visible ]] FragmentOut HgcToneParamCurve3AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = abs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
    "    r3.xyz = r1.xyz*hg_Params[3].xyz + -r2.xyz;\n"
    "    r1.xyz = float3(r1.xyz < hg_Params[4].xyz);\n"
    "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
    "    r1.xyz = r2.xyz*c0.xxx;\n"
    "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
    "    output.color0.xyz = r0.xyz*r1.xyz + r2.xyz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBCF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBCF5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBCF54);
}

char *HgcToneParamCurve3AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B35531A0;
  strcpy(result, "HgcToneParamCurve3AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve3AntiSymmetric::BindTexture(HgcToneParamCurve3AntiSymmetric *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve3AntiSymmetric::Bind(HgcToneParamCurve3AntiSymmetric *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcToneParamCurve3AntiSymmetric *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve3AntiSymmetric::RenderTile(HgcToneParamCurve3AntiSymmetric *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int32x4_t v77;
  int32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  int8x16_t *v87;
  int v88;
  uint64_t v89;
  float32x4_t v90;
  float32x4_t v91;
  uint64_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v88 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = vabsq_f32(v12);
      v14 = vabsq_f32(v11);
      v15 = *((_QWORD *)this + 51);
      v16 = *(float32x4_t *)(v15 + 16);
      v17 = *(float32x4_t *)(v15 + 32);
      v18 = *(float32x4_t *)(v15 + 48);
      v19 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v13, v16));
      v20 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v14, v16));
      v22 = *(float32x4_t *)(v15 + 64);
      v21 = *(float32x4_t *)(v15 + 80);
      v23 = *(float32x4_t *)(v15 + 96);
      v24 = *(int8x16_t *)(v15 + 112);
      v25 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vceqq_f32(*(float32x4_t *)v15, v21)), v21);
      v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v19);
      v27 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v20);
      v28 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v26), (int8x16_t)v23);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v27), (int8x16_t)v23);
      v30 = *(float32x4_t *)(v15 + 128);
      v31 = *(int8x16_t *)(v15 + 144);
      v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v26)));
      v33 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v27)));
      v34 = *(float32x4_t *)(v15 + 160);
      v35 = *(float32x4_t *)(v15 + 176);
      v36 = vsubq_f32(v32, v34);
      v37 = vsubq_f32(v33, v34);
      v38 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, v35));
      v39 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v29, v35));
      v40 = *(float32x4_t *)(v15 + 192);
      v41 = *(float32x4_t *)(v15 + 208);
      v42 = vaddq_f32(v36, v38);
      v43 = vsubq_f32(vsubq_f32(v28, v23), vmulq_f32(vmulq_f32(v40, v38), v28));
      v44 = vsubq_f32(vsubq_f32(v29, v23), vmulq_f32(vmulq_f32(v40, v39), v29));
      v45 = vmulq_f32(v43, v43);
      v46 = *(float32x4_t *)(v15 + 224);
      v47 = *(float32x4_t *)(v15 + 240);
      v48 = vaddq_f32(v41, vmulq_f32(v46, v43));
      v49 = vaddq_f32(v41, vmulq_f32(v46, v44));
      v50 = *(float32x4_t *)(v15 + 256);
      v51 = *(float32x4_t *)(v15 + 272);
      v52 = vaddq_f32(v47, vmulq_f32(v50, v43));
      v53 = vaddq_f32(v47, vmulq_f32(v50, v44));
      v54 = *(float32x4_t *)(v15 + 288);
      v55 = *(float32x4_t *)(v15 + 304);
      v56 = vaddq_f32(v51, vmulq_f32(v43, v54));
      v57 = vaddq_f32(v51, vmulq_f32(v44, v54));
      v58 = vmulq_f32(v44, v44);
      v59 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(v55, vmulq_f32(v43, vaddq_f32(v56, vmulq_f32(v45, vaddq_f32(v48, vmulq_f32(v45, v52)))))))));
      v60 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v37, v39), vmulq_f32(v44, vaddq_f32(v55, vmulq_f32(v44, vaddq_f32(v57, vmulq_f32(v58, vaddq_f32(v49, vmulq_f32(v58, v53)))))))));
      v61 = *(float32x4_t *)(v15 + 320);
      v62 = *(float32x4_t *)(v15 + 336);
      v63 = vmaxq_f32(v59, v61);
      v64 = vmaxq_f32(v60, v61);
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v65, v63)));
      v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v66, v64)));
      v69 = vsubq_f32(v63, v67);
      v70 = vsubq_f32(v64, v68);
      v71 = *(float32x4_t *)(v15 + 352);
      v72 = *(float32x4_t *)(v15 + 368);
      v73 = *(float32x4_t *)(v15 + 384);
      v74 = *(float32x4_t *)(v15 + 400);
      v75 = vmulq_f32(v70, vaddq_f32(v74, vmulq_f32(v70, vaddq_f32(vaddq_f32(v72, vmulq_f32(v73, v70)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(v62, vmulq_f32(v71, v70)))))));
      v76 = vaddq_f32(v23, vmulq_f32(v69, vaddq_f32(v74, vmulq_f32(v69, vaddq_f32(vaddq_f32(v72, vmulq_f32(v69, v73)), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(v62, vmulq_f32(v71, v69))))))));
      v77 = vcvtq_s32_f32(v68);
      v78 = *(int32x4_t *)(v15 + 416);
      v79 = *(float32x4_t *)(v15 + 432);
      v80 = vmulq_f32(v76, (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v67)), 0x17uLL));
      v81 = vmulq_f32(vaddq_f32(v23, v75), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, v77), 0x17uLL));
      v82 = vaddq_f32(v80, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v22, v13)), vsubq_f32(vmulq_f32(v13, v18), v80)));
      v83 = vaddq_f32(v81, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v22, v14)), vsubq_f32(vmulq_f32(v14, v18), v81)));
      v84 = vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v21, v12));
      v85 = vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v21, v11));
      v86 = *(int8x16_t *)(v15 + 448);
      v87 = (int8x16_t *)(v5 + v10);
      v87[-1] = vbslq_s8(v86, (int8x16_t)v12, (int8x16_t)vaddq_f32(v82, vmulq_f32(vmulq_f32(v79, v82), (float32x4_t)vbslq_s8(v86, (int8x16_t)v12, v84))));
      *v87 = vbslq_s8(v86, (int8x16_t)v11, (int8x16_t)vaddq_f32(v83, vmulq_f32(vmulq_f32(v79, v83), (float32x4_t)vbslq_s8(v86, (int8x16_t)v11, v85))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v88 = -v9;
    if (v88 >= v4)
      goto LABEL_3;
LABEL_10:
    v89 = 16 * v88;
    v90 = *(float32x4_t *)(v6 + v89);
    v91 = vabsq_f32(v90);
    v92 = *((_QWORD *)this + 51);
    v93 = *(float32x4_t *)(v92 + 80);
    v94 = *(float32x4_t *)(v92 + 96);
    v95 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vceqq_f32(*(float32x4_t *)v92, v93)), v93), (int8x16_t)v94, (int8x16_t)vaddq_f32(*(float32x4_t *)(v92 + 32), vmulq_f32(v91, *(float32x4_t *)(v92 + 16))));
    v96 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v92 + 112), (int8x16_t)v95), (int8x16_t)v94);
    v97 = (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v96, *(float32x4_t *)(v92 + 176)));
    v98 = vsubq_f32(vsubq_f32(v96, v94), vmulq_f32(vmulq_f32(*(float32x4_t *)(v92 + 192), v97), v96));
    v99 = vmulq_f32(v98, v98);
    v100 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v92, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v95, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v92 + 144), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v92 + 128), v95))), *(float32x4_t *)(v92 + 160)), v97), vmulq_f32(v98, vaddq_f32(*(float32x4_t *)(v92 + 304), vmulq_f32(v98, vaddq_f32(
                         vaddq_f32(*(float32x4_t *)(v92 + 272), vmulq_f32(v98, *(float32x4_t *)(v92 + 288))),
                         vmulq_f32(v99, vaddq_f32(vaddq_f32(*(float32x4_t *)(v92 + 208), vmulq_f32(*(float32x4_t *)(v92 + 224), v98)), vmulq_f32(v99, vaddq_f32(*(float32x4_t *)(v92 + 240), vmulq_f32(*(float32x4_t *)(v92 + 256), v98))))))))))), *(float32x4_t *)(v92 + 320));
    v101 = vcvtq_f32_s32(vcvtq_s32_f32(v100));
    v102 = vsubq_f32(v101, (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v101, v100)));
    v103 = vsubq_f32(v100, v102);
    v104 = vmulq_f32(vaddq_f32(v94, vmulq_f32(v103, vaddq_f32(*(float32x4_t *)(v92 + 400), vmulq_f32(v103, vaddq_f32(vaddq_f32(*(float32x4_t *)(v92 + 368), vmulq_f32(*(float32x4_t *)(v92 + 384), v103)), vmulq_f32(vmulq_f32(v103, v103), vaddq_f32(*(float32x4_t *)(v92 + 336), vmulq_f32(*(float32x4_t *)(v92 + 352), v103)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v92 + 416), vcvtq_s32_f32(v102)), 0x17uLL));
    v105 = vaddq_f32(v104, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v92 + 64), v91)), vsubq_f32(vmulq_f32(v91, *(float32x4_t *)(v92 + 48)), v104)));
    *(int8x16_t *)(v5 + v89) = vbslq_s8(*(int8x16_t *)(v92 + 448), (int8x16_t)v90, (int8x16_t)vaddq_f32(v105, vmulq_f32(vmulq_f32(*(float32x4_t *)(v92 + 432), v105), (float32x4_t)vbslq_s8(*(int8x16_t *)(v92 + 448), (int8x16_t)v90, vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v93, v90))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve3AntiSymmetric::GetDOD(HgcToneParamCurve3AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve3AntiSymmetric::GetROI(HgcToneParamCurve3AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(HgcToneParamCurve3AntiSymmetric *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65403D0;
  v3 = (_OWORD *)operator new();
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[6] = xmmword_1B3051560;
  v3[7] = xmmword_1B3051600;
  v3[8] = xmmword_1B3051610;
  v3[9] = xmmword_1B3051620;
  v3[10] = xmmword_1B3051630;
  v3[11] = xmmword_1B3051640;
  v3[12] = xmmword_1B3051510;
  v3[13] = xmmword_1B3525860;
  v3[14] = xmmword_1B3525870;
  v3[15] = xmmword_1B3525880;
  v3[16] = xmmword_1B3525890;
  v3[17] = xmmword_1B35258A0;
  v3[18] = xmmword_1B35258B0;
  v3[19] = xmmword_1B35258C0;
  v3[20] = xmmword_1B3051690;
  v3[21] = xmmword_1B35258D0;
  v3[22] = xmmword_1B35258E0;
  v3[23] = xmmword_1B35258F0;
  v3[24] = xmmword_1B3525900;
  v3[25] = xmmword_1B3525910;
  v3[26] = xmmword_1B30516D0;
  v3[27] = xmmword_1B30534A0;
  v3[28] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBD76C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve3AntiSymmetric::~HgcToneParamCurve3AntiSymmetric(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65403D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019C028F0);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65403D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019C028F0);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve3AntiSymmetric::SetParameter(HgcToneParamCurve3AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve3AntiSymmetric::GetParameter(HgcToneParamCurve3AntiSymmetric *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve4AntiSymmetric::GetProgram(HgcToneParamCurve4AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000494\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r2.xyz + half3(hg_Params[5].xyz);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[3].xyz);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[4].xyz);\n"
             "    r3.xyz = r3.xyz + half3(hg_Params[6].xyz);\n"
             "    r1.xz = select(r2.xz, r3.xz, r1.xz < 0.00000h);\n"
             "    output.color0.xz = select(float2(r1.xz), -float2(r1.xz), float2(r0.xz) < 0.00000h);\n"
             "    r0.z = select(r2.y, r3.y, r1.y < 0.00000h);\n"
             "    output.color0.y = select(float(r0.z), -float(r0.z), float(r0.y) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6701f725:e5cd2a86:d8f2e6e4:94645d52\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000429\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r2.xyz + hg_Params[5].xyz;\n"
             "    r3.xyz = r1.xyz*hg_Params[3].xyz;\n"
             "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
             "    r3.xyz = r3.xyz + hg_Params[6].xyz;\n"
             "    r1.xz = select(r2.xz, r3.xz, r1.xz < 0.00000f);\n"
             "    output.color0.xz = select(r1.xz, -r1.xz, r0.xz < 0.00000f);\n"
             "    r0.z = select(r2.y, r3.y, r1.y < 0.00000f);\n"
             "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e8a9e9fa:346b61d9:9c01e056:7ecca853\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000508\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r2.xyz + hg_ProgramLocal5.xyz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal3.xyz;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal4.xyz;\n"
           "    r3.xyz = r3.xyz + hg_ProgramLocal6.xyz;\n"
           "    r1.xz = vec2(r1.x < 0.00000 ? r3.x : r2.x, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    gl_FragColor.xz = vec2(r0.x < 0.00000 ? -r1.x : r1.x, r0.z < 0.00000 ? -r1.z : r1.z);\n"
           "    r0.z = r1.y < 0.00000 ? r3.y : r2.y;\n"
           "    gl_FragColor.y = r0.y < 0.00000 ? -r0.z : r0.z;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=e8be88c2:c272e374:876071e8:50ed2741\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve4AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve4AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve4AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=0000000312\n[[ visible ]] FragmentOut HgcToneParamCurve4AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r2.xyz + hg_Params[5].xyz;\n"
    "    r3.xyz = r1.xyz*hg_Params[3].xyz;\n"
    "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
    "    r3.xyz = r3.xyz + hg_Params[6].xyz;\n"
    "    r1.xz = select(r2.xz, r3.xz, r1.xz < 0.00000f);\n"
    "    output.color0.xz = select(r1.xz, -r1.xz, r0.xz < 0.00000f);\n"
    "    r0.z = select(r2.y, r3.y, r1.y < 0.00000f);\n"
    "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBDB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBDBB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBDBA8);
}

char *HgcToneParamCurve4AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B35531A0;
  strcpy(result, "HgcToneParamCurve4AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve4AntiSymmetric::BindTexture(HgcToneParamCurve4AntiSymmetric *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve4AntiSymmetric::Bind(HgcToneParamCurve4AntiSymmetric *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HgcToneParamCurve4AntiSymmetric *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve4AntiSymmetric::RenderTile(HgcToneParamCurve4AntiSymmetric *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int32x4_t v81;
  int32x4_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  int8x16_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t v100;
  int8x16_t v101;
  int8x16_t v102;
  int8x16_t v103;
  int8x16_t v104;
  int8x16_t v105;
  int8x16_t v106;
  int8x16_t v107;
  int8x16_t *v108;
  int v109;
  uint64_t v110;
  float32x4_t v111;
  float32x4_t v112;
  uint64_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  int8x16_t v126;
  int8x16_t v127;
  float32x4_t v128;
  float32x4_t v129;
  int8x16_t v130;
  float32x4_t v131;
  int8x16_t v132;
  int8x16_t v133;
  int8x16_t v134;
  int8x16_t v135;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v109 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = vabsq_f32(v11);
      v14 = vabsq_f32(v12);
      v15 = *((_QWORD *)this + 51);
      v16 = *(float32x4_t *)(v15 + 16);
      v17 = *(float32x4_t *)(v15 + 32);
      v18 = *(float32x4_t *)(v15 + 48);
      v19 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v13, v16));
      v20 = vmulq_f32(v14, v16);
      v22 = *(float32x4_t *)(v15 + 96);
      v21 = *(float32x4_t *)(v15 + 112);
      v23 = (int8x16_t)vaddq_f32(v17, v20);
      v24 = *(float32x4_t *)(v15 + 128);
      v25 = *(int8x16_t *)(v15 + 144);
      v26 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vceqq_f32(*(float32x4_t *)v15, v21)), v21);
      v27 = (float32x4_t)vbslq_s8(v26, (int8x16_t)v24, v19);
      v28 = (float32x4_t)vbslq_s8(v26, (int8x16_t)v24, v23);
      v29 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v27), (int8x16_t)v24);
      v30 = *(float32x4_t *)(v15 + 160);
      v31 = *(int8x16_t *)(v15 + 176);
      v32 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v28), (int8x16_t)v24);
      v33 = (int8x16_t)vcgtq_f32(v30, v27);
      v34 = (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v28));
      v35 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, v33));
      v36 = *(float32x4_t *)(v15 + 192);
      v37 = *(float32x4_t *)(v15 + 208);
      v38 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), v34);
      v39 = vsubq_f32(v35, v36);
      v40 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v29, v37));
      v41 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v32, v37));
      v42 = vsubq_f32(v38, v36);
      v43 = *(float32x4_t *)(v15 + 224);
      v44 = *(float32x4_t *)(v15 + 240);
      v45 = vaddq_f32(v39, v40);
      v46 = vsubq_f32(vsubq_f32(v29, v24), vmulq_f32(vmulq_f32(v43, v40), v29));
      v47 = vsubq_f32(vsubq_f32(v32, v24), vmulq_f32(vmulq_f32(v43, v41), v32));
      v48 = vmulq_f32(v46, v46);
      v49 = *(float32x4_t *)(v15 + 256);
      v50 = *(float32x4_t *)(v15 + 272);
      v51 = *(float32x4_t *)(v15 + 288);
      v52 = *(float32x4_t *)(v15 + 304);
      v53 = vaddq_f32(v44, vmulq_f32(v49, v46));
      v54 = vaddq_f32(v50, vmulq_f32(v51, v46));
      v55 = vaddq_f32(v50, vmulq_f32(v51, v47));
      v56 = vaddq_f32(v44, vmulq_f32(v49, v47));
      v57 = *(float32x4_t *)(v15 + 320);
      v58 = *(float32x4_t *)(v15 + 336);
      v59 = vaddq_f32(v52, vmulq_f32(v46, v57));
      v60 = vaddq_f32(v52, vmulq_f32(v47, v57));
      v61 = vmulq_f32(v47, v47);
      v62 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v45, vmulq_f32(v46, vaddq_f32(v58, vmulq_f32(v46, vaddq_f32(v59, vmulq_f32(v48, vaddq_f32(v53, vmulq_f32(v48, v54)))))))));
      v63 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v42, v41), vmulq_f32(v47, vaddq_f32(v58, vmulq_f32(v47, vaddq_f32(v60, vmulq_f32(v61, vaddq_f32(v56, vmulq_f32(v61, v55)))))))));
      v64 = *(float32x4_t *)(v15 + 352);
      v65 = *(float32x4_t *)(v15 + 368);
      v66 = vmaxq_f32(v62, v64);
      v67 = vmaxq_f32(v63, v64);
      v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v68, v66)));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v66, v70);
      v73 = vsubq_f32(v67, v71);
      v74 = *(float32x4_t *)(v15 + 384);
      v75 = *(float32x4_t *)(v15 + 400);
      v76 = vaddq_f32(v65, vmulq_f32(v74, v72));
      v77 = vaddq_f32(v65, vmulq_f32(v74, v73));
      v78 = *(float32x4_t *)(v15 + 416);
      v79 = *(float32x4_t *)(v15 + 432);
      v80 = vmulq_f32(v73, vaddq_f32(v79, vmulq_f32(v73, vaddq_f32(vaddq_f32(v75, vmulq_f32(v78, v73)), vmulq_f32(vmulq_f32(v73, v73), v77)))));
      v81 = vcvtq_s32_f32(v71);
      v82 = *(int32x4_t *)(v15 + 448);
      v83 = *(int8x16_t *)(v15 + 464);
      v84 = vaddq_f32(v24, v80);
      v85 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v72, vaddq_f32(v79, vmulq_f32(v72, vaddq_f32(vaddq_f32(v75, vmulq_f32(v72, v78)), vmulq_f32(vmulq_f32(v72, v72), v76)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v82, vcvtq_s32_f32(v70)), 0x17uLL));
      v86 = vmulq_f32(v84, (float32x4_t)vshlq_n_s32(vaddq_s32(v82, v81), 0x17uLL));
      v88 = *(float32x4_t *)(v15 + 64);
      v87 = *(float32x4_t *)(v15 + 80);
      v89 = (int8x16_t)vaddq_f32(v87, v85);
      v90 = vmulq_f32(v13, v18);
      v91 = vmulq_f32(v14, v18);
      v92 = (int8x16_t)vaddq_f32(v87, v86);
      v93 = vsubq_f32(v13, v88);
      v94 = vsubq_f32(v14, v88);
      v95 = (int8x16_t)vaddq_f32(v90, v22);
      v96 = (int8x16_t)vaddq_f32(v91, v22);
      v97 = (float32x4_t)vbslq_s8(v83, (int8x16_t)v93, vbslq_s8((int8x16_t)vcgtq_f32(v21, v93), v95, v89));
      v98 = (float32x4_t)vbslq_s8(v83, (int8x16_t)v94, vbslq_s8((int8x16_t)vcgtq_f32(v21, v94), v96, v92));
      v99 = *(int8x16_t *)(v15 + 480);
      v100 = *(int8x16_t *)(v15 + 496);
      v101 = vandq_s8(v99, (int8x16_t)v12);
      v102 = veorq_s8((int8x16_t)v97, vandq_s8(v99, (int8x16_t)v11));
      v103 = vbslq_s8((int8x16_t)vcgtq_f32(v21, v97), v95, v89);
      v104 = vbslq_s8((int8x16_t)vcgtq_f32(v21, v98), v96, v92);
      v105 = vbslq_s8(v100, vextq_s8(v103, v103, 0xCuLL), (int8x16_t)v11);
      v106 = vbslq_s8(v100, vextq_s8(v104, v104, 0xCuLL), (int8x16_t)v12);
      v107 = *(int8x16_t *)(v15 + 512);
      v108 = (int8x16_t *)(v5 + v10);
      v108[-1] = vbslq_s8(v107, v105, vbslq_s8(v83, veorq_s8(vandq_s8(v105, v99), vextq_s8(v105, v105, 4uLL)), v102));
      *v108 = vbslq_s8(v107, v106, vbslq_s8(v83, veorq_s8(vandq_s8(v106, v99), vextq_s8(v106, v106, 4uLL)), veorq_s8((int8x16_t)v98, v101)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v109 = -v9;
    if (v109 >= v4)
      goto LABEL_3;
LABEL_10:
    v110 = 16 * v109;
    v111 = *(float32x4_t *)(v6 + v110);
    v112 = vabsq_f32(v111);
    v113 = *((_QWORD *)this + 51);
    v114 = *(float32x4_t *)(v113 + 112);
    v115 = *(float32x4_t *)(v113 + 128);
    v116 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v115, (int8x16_t)vceqq_f32(*(float32x4_t *)v113, v114)), v114), (int8x16_t)v115, (int8x16_t)vaddq_f32(*(float32x4_t *)(v113 + 32), vmulq_f32(v112, *(float32x4_t *)(v113 + 16))));
    v117 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v113 + 144), (int8x16_t)v116), (int8x16_t)v115);
    v118 = (float32x4_t)vandq_s8((int8x16_t)v115, (int8x16_t)vcgtq_f32(v117, *(float32x4_t *)(v113 + 208)));
    v119 = vsubq_f32(vsubq_f32(v117, v115), vmulq_f32(vmulq_f32(*(float32x4_t *)(v113 + 224), v118), v117));
    v120 = vmulq_f32(v119, v119);
    v121 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v113, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v113 + 176), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v113 + 160), v116))), *(float32x4_t *)(v113 + 192)), v118), vmulq_f32(v119, vaddq_f32(*(float32x4_t *)(v113 + 336), vmulq_f32(v119, vaddq_f32(
                         vaddq_f32(*(float32x4_t *)(v113 + 304), vmulq_f32(v119, *(float32x4_t *)(v113 + 320))),
                         vmulq_f32(v120, vaddq_f32(vaddq_f32(*(float32x4_t *)(v113 + 240), vmulq_f32(*(float32x4_t *)(v113 + 256), v119)), vmulq_f32(v120, vaddq_f32(*(float32x4_t *)(v113 + 272), vmulq_f32(*(float32x4_t *)(v113 + 288), v119))))))))))), *(float32x4_t *)(v113 + 352));
    v122 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
    v123 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v115, (int8x16_t)vcgtq_f32(v122, v121)));
    v124 = vsubq_f32(v121, v123);
    v125 = vaddq_f32(v115, vmulq_f32(v124, vaddq_f32(*(float32x4_t *)(v113 + 432), vmulq_f32(v124, vaddq_f32(vaddq_f32(*(float32x4_t *)(v113 + 400), vmulq_f32(*(float32x4_t *)(v113 + 416), v124)), vmulq_f32(vmulq_f32(v124, v124), vaddq_f32(*(float32x4_t *)(v113 + 368), vmulq_f32(*(float32x4_t *)(v113 + 384), v124))))))));
    v126 = *(int8x16_t *)(v113 + 464);
    v127 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v113 + 80), vmulq_f32(v125, (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v113 + 448), vcvtq_s32_f32(v123)), 0x17uLL)));
    v128 = vmulq_f32(v112, *(float32x4_t *)(v113 + 48));
    v129 = vsubq_f32(v112, *(float32x4_t *)(v113 + 64));
    v130 = (int8x16_t)vaddq_f32(v128, *(float32x4_t *)(v113 + 96));
    v131 = (float32x4_t)vbslq_s8(v126, (int8x16_t)v129, vbslq_s8((int8x16_t)vcgtq_f32(v114, v129), v130, v127));
    v132 = *(int8x16_t *)(v113 + 480);
    v133 = veorq_s8((int8x16_t)v131, vandq_s8(v132, (int8x16_t)v111));
    v134 = vbslq_s8((int8x16_t)vcgtq_f32(v114, v131), v130, v127);
    v135 = vbslq_s8(*(int8x16_t *)(v113 + 496), vextq_s8(v134, v134, 0xCuLL), (int8x16_t)v111);
    *(int8x16_t *)(v5 + v110) = vbslq_s8(*(int8x16_t *)(v113 + 512), v135, vbslq_s8(v126, veorq_s8(vandq_s8(v135, v132), vextq_s8(v135, v135, 4uLL)), v133));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve4AntiSymmetric::GetDOD(HgcToneParamCurve4AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve4AntiSymmetric::GetROI(HgcToneParamCurve4AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(HgcToneParamCurve4AntiSymmetric *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6540638;
  v3 = (_OWORD *)operator new();
  v3[6] = 0u;
  v3[7] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v3[8] = xmmword_1B3051560;
  v3[9] = xmmword_1B3051600;
  v3[10] = xmmword_1B3051610;
  v3[11] = xmmword_1B3051620;
  v3[12] = xmmword_1B3051630;
  v3[13] = xmmword_1B3051640;
  v3[14] = xmmword_1B3051510;
  v3[15] = xmmword_1B3525860;
  v3[16] = xmmword_1B3525870;
  v3[17] = xmmword_1B3525880;
  v3[18] = xmmword_1B3525890;
  v3[19] = xmmword_1B35258A0;
  v3[20] = xmmword_1B35258B0;
  v3[21] = xmmword_1B35258C0;
  v3[22] = xmmword_1B3051690;
  v3[23] = xmmword_1B35258D0;
  v3[24] = xmmword_1B35258E0;
  v3[25] = xmmword_1B35258F0;
  v3[26] = xmmword_1B3525900;
  v3[27] = xmmword_1B3525910;
  v3[28] = xmmword_1B30516D0;
  v3[29] = xmmword_1B3050FF0;
  v3[30] = xmmword_1B3053570;
  v3[31] = xmmword_1B3050FE0;
  v3[32] = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBE464(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve4AntiSymmetric::~HgcToneParamCurve4AntiSymmetric(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6540638;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409F0D1415);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6540638;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409F0D1415);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve4AntiSymmetric::SetParameter(HgcToneParamCurve4AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve4AntiSymmetric::GetParameter(HgcToneParamCurve4AntiSymmetric *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 6)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2446_Method_A_TMO::GetProgram(HgcBT2446_Method_A_TMO *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000007d4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    const half4 c1 = half4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
             "    const half4 c2 = half4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
             "    const half4 c3 = half4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const half4 c4 = half4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const half4 c5 = half4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = pow(r0.xy, c0.xx);\n"
             "    r0.y = r0.y*c0.y;\n"
             "    r1.x = r0.x*c0.z + r0.y;\n"
             "    r0.y = pow(r0.z, c0.x);\n"
             "    r0.z = r0.y*c0.w + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.z;\n"
             "    r1.z = half(r1.x < c1.w);\n"
             "    r1.y = half(c2.y < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = half(c2.y < r1.x);\n"
             "    r1.z = half(-r1.w >= c2.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000h);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000h);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = float(r1.x) - float(r0.z);\n"
             "    output.color0.y = float(r0.y)*float(c5.z);\n"
             "    output.color0.zw = float2(r0.xw);\n"
             "    return output;\n"
             "}\n"
             "//MD5=00594ba5:384afdf9:88664fca:8e0e4589\n"
             "//SIG=00400000:00000001:00000001:00000001:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000007ba\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    const float4 c1 = float4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
             "    const float4 c2 = float4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
             "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = pow(r0.xy, c0.xx);\n"
             "    r0.y = r0.y*c0.y;\n"
             "    r1.x = r0.x*c0.z + r0.y;\n"
             "    r0.y = pow(r0.z, c0.x);\n"
             "    r0.z = r0.y*c0.w + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.z;\n"
             "    r1.z = float(r1.x < c1.w);\n"
             "    r1.y = float(c2.y < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = float(c2.y < r1.x);\n"
             "    r1.z = float(-r1.w >= c2.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = r1.x - r0.z;\n"
             "    output.color0.y = r0.y*c5.z;\n"
             "    output.color0.zw = r0.xw;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ac33f7a0:aaa13e44:0e17b65d:b527b488\n"
             "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000075f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
           "    const mediump vec4 c1 = vec4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
           "    const mediump vec4 c2 = vec4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
           "    const mediump vec4 c3 = vec4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
           "    const mediump vec4 c4 = vec4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
           "    const mediump vec4 c5 = vec4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = pow(r0.xy, c0.xx);\n"
           "    r0.y = r0.y*c0.y;\n"
           "    r1.x = r0.x*c0.z + r0.y;\n"
           "    r0.y = pow(r0.z, c0.x);\n"
           "    r0.z = r0.y*c0.w + r1.x;\n"
           "    r1.x = r0.z*c1.x + c1.y;\n"
           "    r1.x = log2(r1.x);\n"
           "    r1.x = r1.x*c1.z;\n"
           "    r1.z = float(r1.x < c1.w);\n"
           "    r1.y = float(c2.y < r1.x);\n"
           "    r1.w = min(r1.y, r1.z);\n"
           "    r1.y = float(c2.y < r1.x);\n"
           "    r1.z = float(-r1.w >= c2.x);\n"
           "    r1.yw = min(r1.yy, r1.zw);\n"
           "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
           "    r2.x = r1.x*r2.x + c3.z;\n"
           "    r0.xy = r0.xy - r0.zz;\n"
           "    r1.w = -r1.w < 0.00000 ? r2.x : r2.y;\n"
           "    r1.x = r1.x*c3.w + c3.w;\n"
           "    r1.x = -r1.y < 0.00000 ? r1.x : r1.w;\n"
           "    r1.y = r0.z*c4.y;\n"
           "    r1.x = pow(c4.x, r1.x);\n"
           "    r1.y = max(r1.y, c4.z);\n"
           "    r1.x = r1.x*c4.w + -c4.w;\n"
           "    r1.y = r1.x/r1.y;\n"
           "    r0.xy = r0.xy*r1.yy;\n"
           "    r0.x = r0.x*c5.x;\n"
           "    r1.z = r0.x*c5.y;\n"
           "    r0.z = max(r1.z, c3.y);\n"
           "    gl_FragColor.x = r1.x - r0.z;\n"
           "    gl_FragColor.y = r0.y*c5.z;\n"
           "    gl_FragColor.zw = r0.xw;\n"
           "}\n"
           "//MD5=23dc2221:3ec35feb:ba705176:9ebe6741\n"
           "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2446_Method_A_TMO::InitProgramDescriptor(HgcBT2446_Method_A_TMO *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2446_Method_A_TMO_hgc_visible", "//Metal1.0     \n//LEN=000000069a\n[[ visible ]] FragmentOut HgcBT2446_Method_A_TMO_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
    "    const float4 c1 = float4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
    "    const float4 c2 = float4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
    "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
    "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
    "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xy = pow(r0.xy, c0.xx);\n"
    "    r0.y = r0.y*c0.y;\n"
    "    r1.x = r0.x*c0.z + r0.y;\n"
    "    r0.y = pow(r0.z, c0.x);\n"
    "    r0.z = r0.y*c0.w + r1.x;\n"
    "    r1.x = r0.z*c1.x + c1.y;\n"
    "    r1.x = log2(r1.x);\n"
    "    r1.x = r1.x*c1.z;\n"
    "    r1.z = float(r1.x < c1.w);\n"
    "    r1.y = float(c2.y < r1.x);\n"
    "    r1.w = fmin(r1.y, r1.z);\n"
    "    r1.y = float(c2.y < r1.x);\n"
    "    r1.z = float(-r1.w >= c2.x);\n"
    "    r1.yw = fmin(r1.yy, r1.zw);\n"
    "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
    "    r2.x = r1.x*r2.x + c3.z;\n"
    "    r0.xy = r0.xy - r0.zz;\n"
    "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
    "    r1.x = r1.x*c3.w + c3.w;\n"
    "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
    "    r1.y = r0.z*c4.y;\n"
    "    r1.x = pow(c4.x, r1.x);\n"
    "    r1.y = fmax(r1.y, c4.z);\n"
    "    r1.x = r1.x*c4.w + -c4.w;\n"
    "    r1.y = r1.x/r1.y;\n"
    "    r0.xy = r0.xy*r1.yy;\n"
    "    r0.x = r0.x*c5.x;\n"
    "    r1.z = r0.x*c5.y;\n"
    "    r0.z = fmax(r1.z, c3.y);\n"
    "    output.color0.x = r1.x - r0.z;\n"
    "    output.color0.y = r0.y*c5.z;\n"
    "    output.color0.zw = r0.xw;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBE878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBE8A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBE8A0);
}

double HgcBT2446_Method_A_TMO::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552C30;
  strcpy(v3, "HgcBT2446_Method_A_TMO [hgc1]");
  return *(double *)"hod_A_TMO [hgc1]";
}

uint64_t HgcBT2446_Method_A_TMO::BindTexture(HgcBT2446_Method_A_TMO *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2446_Method_A_TMO::Bind(HgcBT2446_Method_A_TMO *this, HGHandler *a2)
{
  (*(void (**)(HgcBT2446_Method_A_TMO *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO::RenderTile(HgcBT2446_Method_A_TMO *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  int32x4_t v48;
  float32x4_t v49;
  int32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int32x4_t v104;
  int32x4_t v105;
  int32x4_t v106;
  int64x2_t v107;
  int64x2_t v108;
  int32x4_t v109;
  int32x4_t v110;
  int64x2_t v111;
  float32x4_t v112;
  int32x4_t v113;
  int32x4_t v114;
  int8x16_t v115;
  int8x16_t v116;
  int8x16_t v117;
  int8x16_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int8x16_t v124;
  float32x4_t v125;
  float32x4_t v126;
  int8x16_t v127;
  int32x4_t v128;
  int32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  int8x16_t v132;
  int8x16_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  int8x16_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int8x16_t v147;
  int8x16_t v148;
  float32x4_t v149;
  float32x4_t v150;
  int8x16_t v151;
  int8x16_t v152;
  float32x4_t v153;
  float32x4_t v154;
  int8x16_t v155;
  int8x16_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  int8x16_t v162;
  int8x16_t v163;
  int8x16_t v164;
  int8x16_t v165;
  float32x4_t *v166;
  int v167;
  uint64_t v168;
  float32x4_t v169;
  uint64_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  int8x16_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  int32x4_t v196;
  int8x16_t v197;
  float32x4_t v198;
  float32x4_t v199;
  int8x16_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  int8x16_t v209;
  int8x16_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  int32x4_t v221;
  int32x4_t v222;
  int64x2_t v223;
  int32x4_t v224;
  float32x4_t v225;
  int32x4_t v226;
  int8x16_t v227;
  int8x16_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  int8x16_t v232;
  float32x4_t v233;
  int32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  int8x16_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  int8x16_t v242;
  float32x4_t v243;
  int8x16_t v244;
  float32x4_t v245;
  int8x16_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  int8x16_t v250;
  int8x16_t v251;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v167 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v11), (int8x16_t)v14);
      v16 = *(float32x4_t *)(v13 + 32);
      v17 = *(int8x16_t *)(v13 + 48);
      v18 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v12), (int8x16_t)v14);
      v19 = *(float32x4_t *)(v13 + 64);
      v20 = *(float32x4_t *)(v13 + 80);
      v21 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v15, v20));
      v22 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v18, v20));
      v23 = *(float32x4_t *)(v13 + 96);
      v24 = *(float32x4_t *)(v13 + 112);
      v25 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v11, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v11))), v19), v21);
      v26 = vsubq_f32(vsubq_f32(v15, v14), vmulq_f32(vmulq_f32(v23, v21), v15));
      v27 = vsubq_f32(vsubq_f32(v18, v14), vmulq_f32(vmulq_f32(v23, v22), v18));
      v29 = *(float32x4_t *)(v13 + 128);
      v28 = *(float32x4_t *)(v13 + 144);
      v31 = *(float32x4_t *)(v13 + 160);
      v30 = *(float32x4_t *)(v13 + 176);
      v32 = vmulq_f32(v30, vaddq_f32(v25, vmulq_f32(v26, vaddq_f32(vaddq_f32(v28, vmulq_f32(v26, v31)), vmulq_f32(vmulq_f32(v26, v26), vaddq_f32(v24, vmulq_f32(v29, v26)))))));
      v33 = vmulq_f32(v30, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v12, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v12))), v19), v22), vmulq_f32(v27, vaddq_f32(vaddq_f32(v28, vmulq_f32(v27, v31)), vmulq_f32(vmulq_f32(v27, v27), vaddq_f32(v24, vmulq_f32(v29, v27)))))));
      v34 = *(float32x4_t *)(v13 + 192);
      v35 = *(float32x4_t *)(v13 + 208);
      v36 = vmaxq_f32(v32, v34);
      v37 = vmaxq_f32(v33, v34);
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v39 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      v40 = vsubq_f32(v38, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v38, v36)));
      v41 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v39, v37)));
      v42 = vsubq_f32(v36, v40);
      v43 = vsubq_f32(v37, v41);
      v45 = *(float32x4_t *)(v13 + 224);
      v44 = *(float32x4_t *)(v13 + 240);
      v46 = vcvtq_s32_f32(v40);
      v47 = vaddq_f32(v14, vmulq_f32(v42, vaddq_f32(v44, vmulq_f32(v42, vaddq_f32(v35, vmulq_f32(v45, v42))))));
      v48 = vcvtq_s32_f32(v41);
      v50 = *(int32x4_t *)(v13 + 256);
      v49 = *(float32x4_t *)(v13 + 272);
      v51 = vaddq_f32(v14, vmulq_f32(v43, vaddq_f32(v44, vmulq_f32(v43, vaddq_f32(v35, vmulq_f32(v45, v43))))));
      v43.i64[0] = vmulq_f32(v47, (float32x4_t)vshlq_n_s32(vaddq_s32(v50, v46), 0x17uLL)).u64[0];
      v47.i64[0] = vmulq_f32(v51, (float32x4_t)vshlq_n_s32(vaddq_s32(v50, v48), 0x17uLL)).u64[0];
      v43.i64[1] = *(_QWORD *)(v6 + v10 - 8);
      v47.i64[1] = *(_QWORD *)(v6 + v10 + 8);
      v53 = *(int8x16_t *)(v13 + 288);
      v52 = *(float32x4_t *)(v13 + 304);
      v54 = (float32x4_t)vbslq_s8(v53, (int8x16_t)vmulq_f32(v49, v43), (int8x16_t)v43);
      v55 = (float32x4_t)vbslq_s8(v53, (int8x16_t)vmulq_f32(v49, v47), (int8x16_t)v47);
      v56 = (float32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 4uLL);
      v57 = (int8x16_t)vaddq_f32(vmulq_f32(v52, v54), (float32x4_t)vrev64q_s32((int32x4_t)v54));
      v58 = (float32x4_t)vextq_s8((int8x16_t)v55, (int8x16_t)v55, 4uLL);
      v59 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v56, *(int8x16_t *)v13), (int8x16_t)v52);
      v60 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v58, *(int8x16_t *)v13), (int8x16_t)v52);
      v61 = (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v59, v20));
      v62 = (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v60, v20));
      v63 = vsubq_f32(vsubq_f32(v59, v52), vmulq_f32(vmulq_f32(v23, v61), v59));
      v64 = vsubq_f32(vsubq_f32(v60, v52), vmulq_f32(vmulq_f32(v23, v62), v60));
      v65 = vmulq_f32(v30, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v56, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v56))), v19), v61), vmulq_f32(v63, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v63)), vmulq_f32(vmulq_f32(v63, v63), vaddq_f32(v24, vmulq_f32(v29, v63)))))));
      v66 = vmulq_f32(v30, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v58, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v58))), v19), v62), vmulq_f32(v64, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v64)), vmulq_f32(vmulq_f32(v64, v64), vaddq_f32(v24, vmulq_f32(v29, v64)))))));
      v67 = vmaxq_f32(v65, v34);
      v68 = vmaxq_f32(v66, v34);
      v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v69, v67)));
      v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v70, v68)));
      v73 = (int8x16_t)vaddq_f32(vmulq_f32(v52, v55), (float32x4_t)vrev64q_s32((int32x4_t)v55));
      v74 = vsubq_f32(v67, v71);
      v75 = vsubq_f32(v68, v72);
      v76 = (int8x16_t)vmulq_f32(vaddq_f32(v52, vmulq_f32(v75, vaddq_f32(v44, vmulq_f32(v75, vaddq_f32(v35, vmulq_f32(v45, v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v72), v50), 0x17uLL));
      v77 = vbslq_s8(v53, (int8x16_t)vmulq_f32(vaddq_f32(v52, vmulq_f32(v74, vaddq_f32(v44, vmulq_f32(v74, vaddq_f32(v35, vmulq_f32(v45, v74)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v71), v50), 0x17uLL)), (int8x16_t)v43);
      v78 = vbslq_s8(v53, v76, (int8x16_t)v47);
      v79 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v57, v57, 8uLL), vmulq_lane_f32(v52, *(float32x2_t *)v77.i8, 1));
      v80 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v73, v73, 8uLL), vmulq_lane_f32(v52, *(float32x2_t *)v78.i8, 1));
      v81 = *(int8x16_t *)(v13 + 320);
      v82 = *(float32x4_t *)(v13 + 336);
      v83 = (float32x4_t)vbslq_s8(v81, v79, v77);
      v84 = (float32x4_t)vbslq_s8(v81, v80, v78);
      v85 = (float32x4_t)vextq_s8((int8x16_t)v83, (int8x16_t)v83, 8uLL);
      v86 = (float32x4_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 8uLL);
      v87 = vaddq_f32(v49, vmulq_f32(v82, v85));
      v88 = vaddq_f32(v49, vmulq_f32(v82, v86));
      v89 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v87));
      v90 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v88));
      v91 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v87, 0x17uLL)), v89);
      v92 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v87), (int8x16_t)v49);
      v93 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v88), (int8x16_t)v49);
      v94 = vsubq_f32(v91, v19);
      v95 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v88, 0x17uLL)), v90), v19);
      v96 = (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v92, v20));
      v97 = (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v93, v20));
      v98 = vaddq_f32(v94, v96);
      v99 = vsubq_f32(vsubq_f32(v92, v49), vmulq_f32(vmulq_f32(v23, v96), v92));
      v100 = vsubq_f32(vsubq_f32(v93, v49), vmulq_f32(vmulq_f32(v23, v97), v93));
      v101 = vaddq_f32(v98, vmulq_f32(v99, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v99)), vmulq_f32(vmulq_f32(v99, v99), vaddq_f32(v24, vmulq_f32(v29, v99))))));
      v102 = vaddq_f32(vaddq_f32(v95, v97), vmulq_f32(v100, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v100)), vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(v24, vmulq_f32(v29, v100))))));
      v103 = *(float32x4_t *)(v13 + 352);
      v104 = *(int32x4_t *)(v13 + 368);
      v105 = (int32x4_t)vmulq_f32(v103, v101);
      v106 = (int32x4_t)vmulq_f32(v103, v102);
      v107 = (int64x2_t)vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32(v103, (float32x4_t)vextq_s8((int8x16_t)v105, (int8x16_t)v105, 8uLL)));
      v108 = (int64x2_t)vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32(v103, (float32x4_t)vextq_s8((int8x16_t)v106, (int8x16_t)v106, 8uLL)));
      v28.i64[0] = v105.i64[0];
      v29.i64[0] = v106.i64[0];
      v28.i64[1] = v107.i64[1];
      v29.i64[1] = v108.i64[1];
      v105.i64[1] = vdupq_laneq_s64(v107, 1).u64[0];
      v106.i64[1] = vdupq_laneq_s64(v108, 1).u64[0];
      v109 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v105), v103)), (int8x16_t)v28);
      v110 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v106), v103)), (int8x16_t)v29);
      v111 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v109, (int8x16_t)v109, 8uLL), (float32x4_t)vrev64q_s32(v109));
      v112 = vminq_f32((float32x4_t)vextq_s8((int8x16_t)v110, (int8x16_t)v110, 8uLL), (float32x4_t)vrev64q_s32(v110));
      v28.i64[0] = v109.i64[0];
      v28.i64[1] = v111.i64[1];
      v29.i64[0] = v110.i64[0];
      v29.i64[1] = v112.i64[1];
      v109.i64[1] = vdupq_laneq_s64(v111, 1).u64[0];
      v110.i64[1] = vdupq_laneq_s64((int64x2_t)v112, 1).u64[0];
      v113 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v109), v103)), (int8x16_t)v28);
      v114 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v110), v103)), (int8x16_t)v29);
      v115 = vbslq_s8(v81, vandq_s8((int8x16_t)v82, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v113)), v44)), (int8x16_t)v113);
      v116 = vbslq_s8(v81, vandq_s8((int8x16_t)v82, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v114)), v44)), (int8x16_t)v114);
      *(int8x8_t *)v112.f32 = vqtbl1_s8(v115, *(int8x8_t *)v104.i8);
      v114.i64[0] = vextq_s8((int8x16_t)v104, (int8x16_t)v104, 8uLL).u64[0];
      *(int8x8_t *)&v112.u32[2] = vqtbl1_s8(v115, *(int8x8_t *)v114.i8);
      v117 = (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v115.i64[0], 0), v112);
      v118 = *(int8x16_t *)(v13 + 384);
      v119 = *(float32x4_t *)(v13 + 400);
      v120 = (float32x4_t)vbslq_s8(v118, v115, v117);
      v121 = *(float32x4_t *)(v13 + 416);
      v122 = *(float32x4_t *)(v13 + 432);
      v123 = vaddq_f32(v119, vmulq_n_f32(v121, v120.f32[0]));
      v124 = vbslq_s8(v118, (int8x16_t)vaddq_f32(v122, vmulq_f32(v123, v120)), (int8x16_t)v123);
      *(int8x8_t *)v31.f32 = vqtbl1_s8(v116, *(int8x8_t *)v104.i8);
      *(int8x8_t *)&v31.u32[2] = vqtbl1_s8(v116, *(int8x8_t *)v114.i8);
      v125 = (float32x4_t)vbslq_s8(v118, v116, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v116.i64[0], 0), v31));
      v126 = vaddq_f32(v119, vmulq_n_f32(v121, v125.f32[0]));
      v127 = vbslq_s8(v118, (int8x16_t)vaddq_f32(v122, vmulq_f32(v126, v125)), (int8x16_t)v126);
      v120.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v120, v122), vextq_s8(v124, v124, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v124, 0)).i64[1];
      v125.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v125, v122), vextq_s8(v127, v127, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v127, 0)).i64[1];
      v128 = (int32x4_t)vbslq_s8(v118, (int8x16_t)vaddq_f32(v23, vmulq_f32(v23, v120)), (int8x16_t)v120);
      v129 = (int32x4_t)vbslq_s8(v118, (int8x16_t)vaddq_f32(v23, vmulq_f32(v23, v125)), (int8x16_t)v125);
      v131 = *(float32x4_t *)(v13 + 448);
      v130 = *(float32x4_t *)(v13 + 464);
      v132 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v128), v131), (int8x16_t)v128, vextq_s8((int8x16_t)v128, (int8x16_t)v128, 0xCuLL));
      v133 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v129), v131), (int8x16_t)v129, vextq_s8((int8x16_t)v129, (int8x16_t)v129, 0xCuLL));
      v134 = vsubq_f32(v83, (float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2));
      v135 = vsubq_f32(v84, (float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 2));
      *(int8x8_t *)v31.f32 = vext_s8(*(int8x8_t *)v134.f32, *(int8x8_t *)v85.f32, 4uLL);
      *(int8x8_t *)&v31.u32[2] = vext_s8(*(int8x8_t *)v85.f32, *(int8x8_t *)v134.f32, 4uLL);
      *(int8x8_t *)v119.f32 = vext_s8(*(int8x8_t *)v86.f32, *(int8x8_t *)v135.f32, 4uLL);
      *(int8x8_t *)v86.f32 = vext_s8(*(int8x8_t *)v135.f32, *(int8x8_t *)v86.f32, 4uLL);
      v86.i64[1] = v119.i64[0];
      v136 = (int8x16_t)vmulq_f32(v131, v31);
      v137 = (int8x16_t)vmulq_f32(v131, v86);
      v138 = vmaxq_f32(vmulq_f32(v130, (float32x4_t)vbslq_s8(v118, v132, v136)), v34);
      v139 = vmaxq_f32(vmulq_f32(v130, (float32x4_t)vbslq_s8(v118, v133, v137)), v34);
      v140 = vcvtq_f32_s32(vcvtq_s32_f32(v138));
      v141 = vcvtq_f32_s32(vcvtq_s32_f32(v139));
      v142 = vsubq_f32(v140, (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v140, v138)));
      v143 = vsubq_f32(v141, (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v141, v139)));
      v144 = vsubq_f32(v138, v142);
      v145 = vsubq_f32(v139, v143);
      v146 = vmulq_f32(v145, vaddq_f32(v44, vmulq_f32(v145, vaddq_f32(v35, vmulq_f32(v45, v145)))));
      v147 = (int8x16_t)vmulq_f32(vaddq_f32(v49, vmulq_f32(v144, vaddq_f32(v44, vmulq_f32(v144, vaddq_f32(v35, vmulq_f32(v45, v144)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v142), v104), 0x17uLL));
      v148 = (int8x16_t)vmulq_f32(vaddq_f32(v49, v146), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v143), v104), 0x17uLL));
      v149 = *(float32x4_t *)(v13 + 480);
      v150 = *(float32x4_t *)(v13 + 496);
      v151 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v118, v147, v136), v149);
      v152 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v118, v148, v137), v149);
      v153 = *(float32x4_t *)(v13 + 512);
      v154 = *(float32x4_t *)(v13 + 528);
      v155 = (int8x16_t)vaddq_f32(v150, vmulq_f32(v153, (float32x4_t)vbslq_s8(v118, v147, v151)));
      v156 = (int8x16_t)vaddq_f32(v150, vmulq_f32(v153, (float32x4_t)vbslq_s8(v118, v148, v152)));
      v157 = (float32x4_t)vbslq_s8(v118, v155, v151);
      v158 = (float32x4_t)vbslq_s8(v118, v156, v152);
      v159 = vminq_f32(vmaxq_f32(vmulq_f32(v153, vrecpeq_f32(v157)), v150), v154);
      v160 = vminq_f32(vmaxq_f32(vmulq_f32(v153, vrecpeq_f32(v158)), v150), v154);
      v155.i64[0] = vbslq_s8(v118, v155, (int8x16_t)vmulq_n_f32(vmulq_f32(v159, vrecpsq_f32(v157, v159)), v157.f32[0])).u64[0];
      v156.i64[0] = vbslq_s8(v118, v156, (int8x16_t)vmulq_n_f32(vmulq_f32(v160, vrecpsq_f32(v158, v160)), v158.f32[0])).u64[0];
      v157.i64[0] = vmulq_lane_f32(v134, *(float32x2_t *)v155.i8, 1).u64[0];
      v158.i64[0] = vmulq_lane_f32(v135, *(float32x2_t *)v156.i8, 1).u64[0];
      v157.i64[1] = v83.i64[1];
      v158.i64[1] = v84.i64[1];
      v161 = *(float32x4_t *)(v13 + 544);
      v162 = vbslq_s8(v118, (int8x16_t)vmulq_f32(v161, v157), (int8x16_t)v157);
      v163 = vbslq_s8(v118, (int8x16_t)vmulq_f32(v161, v158), (int8x16_t)v158);
      v160.i64[0] = v155.i64[0];
      v160.i64[1] = vmulq_f32(v161, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v162, 0)).i64[1];
      v83.i64[0] = v156.i64[0];
      v83.i64[1] = vmulq_f32(v161, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v163, 0)).i64[1];
      v164 = vbslq_s8(v81, (int8x16_t)vmaxq_f32(v160, v153), v162);
      v165 = vbslq_s8(v81, (int8x16_t)vmaxq_f32(v83, v153), v163);
      v153.i64[0] = vmvnq_s8(v118).u64[0];
      *(int8x8_t *)v155.i8 = vorr_s8(vand_s8(*(int8x8_t *)v118.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v155.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v164, v164, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v130.f32, *(float32x2_t *)v164.i8), *(int8x8_t *)v153.f32));
      v155.u64[1] = (unint64_t)vqtbl1_s8(v164, *(int8x8_t *)v114.i8);
      *(int8x8_t *)v130.f32 = vorr_s8(vand_s8(*(int8x8_t *)v118.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v156.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v165, v165, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v130.f32, *(float32x2_t *)v165.i8), *(int8x8_t *)v153.f32));
      *(int8x8_t *)&v130.u32[2] = vqtbl1_s8(v165, *(int8x8_t *)v114.i8);
      v166 = (float32x4_t *)(v5 + v10);
      v166[-1] = (float32x4_t)v155;
      *v166 = v130;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v167 = -v9;
    if (v167 >= v4)
      goto LABEL_3;
LABEL_10:
    v168 = 16 * v167;
    v169 = *(float32x4_t *)(v6 + v168);
    v170 = *((_QWORD *)this + 51);
    v171 = *(float32x4_t *)(v170 + 16);
    v172 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v170, (int8x16_t)v169), (int8x16_t)v171);
    v173 = *(float32x4_t *)(v170 + 32);
    v174 = *(int8x16_t *)(v170 + 48);
    v175 = *(float32x4_t *)(v170 + 64);
    v176 = *(float32x4_t *)(v170 + 80);
    v177 = (float32x4_t)vandq_s8((int8x16_t)v171, (int8x16_t)vcgtq_f32(v172, v176));
    v178 = *(float32x4_t *)(v170 + 96);
    v179 = *(float32x4_t *)(v170 + 112);
    v180 = vsubq_f32(vsubq_f32(v172, v171), vmulq_f32(vmulq_f32(v178, v177), v172));
    v182 = *(float32x4_t *)(v170 + 128);
    v181 = *(float32x4_t *)(v170 + 144);
    v184 = *(float32x4_t *)(v170 + 160);
    v183 = *(float32x4_t *)(v170 + 176);
    v185 = vmulq_f32(v183, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v169, 0x17uLL)), (float32x4_t)vandq_s8(v174, (int8x16_t)vcgtq_f32(v173, v169))), v175), v177), vmulq_f32(v180, vaddq_f32(vaddq_f32(v181, vmulq_f32(v180, v184)), vmulq_f32(vmulq_f32(v180, v180), vaddq_f32(v179, vmulq_f32(v182, v180)))))));
    v186 = *(float32x4_t *)(v170 + 192);
    v187 = *(float32x4_t *)(v170 + 208);
    v188 = vmaxq_f32(v185, v186);
    v189 = vcvtq_f32_s32(vcvtq_s32_f32(v188));
    v190 = vsubq_f32(v189, (float32x4_t)vandq_s8((int8x16_t)v171, (int8x16_t)vcgtq_f32(v189, v188)));
    v191 = vsubq_f32(v188, v190);
    v193 = *(float32x4_t *)(v170 + 224);
    v192 = *(float32x4_t *)(v170 + 240);
    v194 = vaddq_f32(v171, vmulq_f32(v191, vaddq_f32(v192, vmulq_f32(v191, vaddq_f32(v187, vmulq_f32(v193, v191))))));
    v196 = *(int32x4_t *)(v170 + 256);
    v195 = *(float32x4_t *)(v170 + 272);
    v194.i64[0] = vmulq_f32(v194, (float32x4_t)vshlq_n_s32(vaddq_s32(v196, vcvtq_s32_f32(v190)), 0x17uLL)).u64[0];
    v194.i64[1] = *(_QWORD *)(v6 + v168 + 8);
    v197 = *(int8x16_t *)(v170 + 288);
    v198 = *(float32x4_t *)(v170 + 304);
    v199 = (float32x4_t)vbslq_s8(v197, (int8x16_t)vmulq_f32(v195, v194), (int8x16_t)v194);
    v200 = (int8x16_t)vaddq_f32(vmulq_f32(v198, v199), (float32x4_t)vrev64q_s32((int32x4_t)v199));
    v201 = (float32x4_t)vextq_s8((int8x16_t)v199, (int8x16_t)v199, 4uLL);
    v202 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v201, *(int8x16_t *)v170), (int8x16_t)v198);
    v203 = (float32x4_t)vandq_s8((int8x16_t)v198, (int8x16_t)vcgtq_f32(v202, v176));
    v204 = vsubq_f32(vsubq_f32(v202, v198), vmulq_f32(vmulq_f32(v178, v203), v202));
    v205 = vmaxq_f32(vmulq_f32(v183, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v201, 0x17uLL)), (float32x4_t)vandq_s8(v174, (int8x16_t)vcgtq_f32(v173, v201))), v175), v203), vmulq_f32(v204, vaddq_f32(vaddq_f32(v181, vmulq_f32(v184, v204)), vmulq_f32(vmulq_f32(v204, v204), vaddq_f32(v179, vmulq_f32(v182, v204))))))), v186);
    v206 = vcvtq_f32_s32(vcvtq_s32_f32(v205));
    v207 = vsubq_f32(v206, (float32x4_t)vandq_s8((int8x16_t)v198, (int8x16_t)vcgtq_f32(v206, v205)));
    v208 = vsubq_f32(v205, v207);
    v209 = vbslq_s8(v197, (int8x16_t)vmulq_f32(vaddq_f32(v198, vmulq_f32(v208, vaddq_f32(v192, vmulq_f32(v208, vaddq_f32(v187, vmulq_f32(v193, v208)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v207), v196), 0x17uLL)), (int8x16_t)v194);
    v210 = *(int8x16_t *)(v170 + 320);
    v211 = *(float32x4_t *)(v170 + 336);
    v212 = (float32x4_t)vbslq_s8(v210, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v200, v200, 8uLL), vmulq_lane_f32(v198, *(float32x2_t *)v209.i8, 1)), v209);
    v213 = (float32x4_t)vextq_s8((int8x16_t)v212, (int8x16_t)v212, 8uLL);
    v214 = vaddq_f32(v195, vmulq_f32(v211, v213));
    v215 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v170, (int8x16_t)v214), (int8x16_t)v195);
    v216 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v214, 0x17uLL)), (float32x4_t)vandq_s8(v174, (int8x16_t)vcgtq_f32(v173, v214))), v175);
    v217 = (float32x4_t)vandq_s8((int8x16_t)v195, (int8x16_t)vcgtq_f32(v215, v176));
    v218 = vsubq_f32(vsubq_f32(v215, v195), vmulq_f32(vmulq_f32(v178, v217), v215));
    v219 = vaddq_f32(vaddq_f32(v216, v217), vmulq_f32(v218, vaddq_f32(vaddq_f32(v181, vmulq_f32(v184, v218)), vmulq_f32(vmulq_f32(v218, v218), vaddq_f32(v179, vmulq_f32(v182, v218))))));
    v220 = *(float32x4_t *)(v170 + 352);
    v221 = *(int32x4_t *)(v170 + 368);
    v222 = (int32x4_t)vmulq_f32(v220, v219);
    v223 = (int64x2_t)vandq_s8((int8x16_t)v211, (int8x16_t)vcgtq_f32(v220, (float32x4_t)vextq_s8((int8x16_t)v222, (int8x16_t)v222, 8uLL)));
    v176.i64[0] = v222.i64[0];
    v176.i64[1] = v223.i64[1];
    v222.i64[1] = vdupq_laneq_s64(v223, 1).u64[0];
    v224 = (int32x4_t)vbslq_s8(v197, vandq_s8((int8x16_t)v211, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v222), v220)), (int8x16_t)v176);
    v225 = vminq_f32((float32x4_t)vextq_s8((int8x16_t)v224, (int8x16_t)v224, 8uLL), (float32x4_t)vrev64q_s32(v224));
    v176.i64[0] = v224.i64[0];
    v176.i64[1] = v225.i64[1];
    v224.i64[1] = vdupq_laneq_s64((int64x2_t)v225, 1).u64[0];
    v226 = (int32x4_t)vbslq_s8(v197, vandq_s8((int8x16_t)v211, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v224), v220)), (int8x16_t)v176);
    v227 = vbslq_s8(v210, vandq_s8((int8x16_t)v211, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v226)), v192)), (int8x16_t)v226);
    *(int8x8_t *)v225.f32 = vqtbl1_s8(v227, *(int8x8_t *)v221.i8);
    v224.i64[0] = vextq_s8((int8x16_t)v221, (int8x16_t)v221, 8uLL).u64[0];
    *(int8x8_t *)&v225.u32[2] = vqtbl1_s8(v227, *(int8x8_t *)v224.i8);
    v228 = *(int8x16_t *)(v170 + 384);
    v229 = (float32x4_t)vbslq_s8(v228, v227, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v227.i64[0], 0), v225));
    v230 = *(float32x4_t *)(v170 + 432);
    v231 = vaddq_f32(*(float32x4_t *)(v170 + 400), vmulq_n_f32(*(float32x4_t *)(v170 + 416), v229.f32[0]));
    v232 = vbslq_s8(v228, (int8x16_t)vaddq_f32(v230, vmulq_f32(v231, v229)), (int8x16_t)v231);
    v233 = vsubq_f32(v212, (float32x4_t)vdupq_laneq_s32((int32x4_t)v212, 2));
    v229.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v229, v230), vextq_s8(v232, v232, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v232, 0)).i64[1];
    v234 = (int32x4_t)vbslq_s8(v228, (int8x16_t)vaddq_f32(v178, vmulq_f32(v178, v229)), (int8x16_t)v229);
    v235 = *(float32x4_t *)(v170 + 448);
    v236 = *(float32x4_t *)(v170 + 464);
    *(int8x8_t *)v184.f32 = vext_s8(*(int8x8_t *)v233.f32, *(int8x8_t *)v213.f32, 4uLL);
    *(int8x8_t *)&v184.u32[2] = vext_s8(*(int8x8_t *)v213.f32, *(int8x8_t *)v233.f32, 4uLL);
    v237 = (int8x16_t)vmulq_f32(v235, v184);
    v238 = vmaxq_f32(vmulq_f32(v236, (float32x4_t)vbslq_s8(v228, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v234), v235), (int8x16_t)v234, vextq_s8((int8x16_t)v234, (int8x16_t)v234, 0xCuLL)), v237)), v186);
    v239 = vcvtq_f32_s32(vcvtq_s32_f32(v238));
    v240 = vsubq_f32(v239, (float32x4_t)vandq_s8((int8x16_t)v195, (int8x16_t)vcgtq_f32(v239, v238)));
    v241 = vsubq_f32(v238, v240);
    v242 = (int8x16_t)vmulq_f32(vaddq_f32(v195, vmulq_f32(v241, vaddq_f32(v192, vmulq_f32(v241, vaddq_f32(v187, vmulq_f32(v193, v241)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v240), v221), 0x17uLL));
    v243 = *(float32x4_t *)(v170 + 496);
    v244 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v228, v242, v237), *(float32x4_t *)(v170 + 480));
    v245 = *(float32x4_t *)(v170 + 512);
    v246 = (int8x16_t)vaddq_f32(v243, vmulq_f32(v245, (float32x4_t)vbslq_s8(v228, v242, v244)));
    v247 = (float32x4_t)vbslq_s8(v228, v246, v244);
    v248 = vminq_f32(vmaxq_f32(vmulq_f32(v245, vrecpeq_f32(v247)), v243), *(float32x4_t *)(v170 + 528));
    v246.i64[0] = vbslq_s8(v228, v246, (int8x16_t)vmulq_n_f32(vmulq_f32(v248, vrecpsq_f32(v247, v248)), v247.f32[0])).u64[0];
    v247.i64[0] = vmulq_lane_f32(v233, *(float32x2_t *)v246.i8, 1).u64[0];
    v247.i64[1] = v212.i64[1];
    v249 = *(float32x4_t *)(v170 + 544);
    v250 = vbslq_s8(v228, (int8x16_t)vmulq_f32(v249, v247), (int8x16_t)v247);
    v193.i64[0] = v246.i64[0];
    v193.i64[1] = vmulq_f32(v249, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v250, 0)).i64[1];
    v251 = vbslq_s8(v210, (int8x16_t)vmaxq_f32(v193, v245), v250);
    *(int8x8_t *)v246.i8 = vorr_s8(vand_s8(*(int8x8_t *)v228.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v246.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v251, v251, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v236.f32, *(float32x2_t *)v251.i8), (int8x8_t)*(_OWORD *)&vmvnq_s8(v228)));
    v246.u64[1] = (unint64_t)vqtbl1_s8(v251, *(int8x8_t *)v224.i8);
    *(int8x16_t *)(v5 + v168) = v246;
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO::GetDOD(HgcBT2446_Method_A_TMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2446_Method_A_TMO::GetROI(HgcBT2446_Method_A_TMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2446_Method_A_TMO::HgcBT2446_Method_A_TMO(HgcBT2446_Method_A_TMO *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65408A0;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B35533A0;
  *(_OWORD *)(v3 + 16) = xmmword_1B30520F0;
  *(_OWORD *)(v3 + 32) = xmmword_1B35533B0;
  *(_OWORD *)(v3 + 48) = xmmword_1B35533C0;
  *(_OWORD *)(v3 + 64) = xmmword_1B35533D0;
  *(_OWORD *)(v3 + 80) = xmmword_1B35533E0;
  *(_OWORD *)(v3 + 96) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 112) = xmmword_1B35533F0;
  *(_OWORD *)(v3 + 128) = xmmword_1B3553400;
  *(_OWORD *)(v3 + 144) = xmmword_1B3553410;
  *(_OWORD *)(v3 + 160) = xmmword_1B3553420;
  *(_OWORD *)(v3 + 176) = xmmword_1B3553430;
  *(_OWORD *)(v3 + 192) = xmmword_1B3553440;
  *(_OWORD *)(v3 + 208) = xmmword_1B3553450;
  *(_OWORD *)(v3 + 224) = xmmword_1B3553460;
  *(_OWORD *)(v3 + 240) = xmmword_1B3553470;
  *(_OWORD *)(v3 + 256) = xmmword_1B3553480;
  *(_OWORD *)(v3 + 272) = xmmword_1B3553490;
  *(_OWORD *)(v3 + 288) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 304) = xmmword_1B35534A0;
  *(_OWORD *)(v3 + 320) = xmmword_1B3050FE0;
  *(_OWORD *)(v3 + 336) = xmmword_1B35534B0;
  *(_OWORD *)(v3 + 352) = xmmword_1B35534C0;
  *(_OWORD *)(v3 + 368) = xmmword_1B35534D0;
  *(_OWORD *)(v3 + 384) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 400) = xmmword_1B35534E0;
  *(_OWORD *)(v3 + 416) = xmmword_1B35534F0;
  *(_OWORD *)(v3 + 432) = xmmword_1B3553500;
  *(_OWORD *)(v3 + 448) = xmmword_1B3553510;
  *(_OWORD *)(v3 + 464) = xmmword_1B3553520;
  *(_OWORD *)(v3 + 480) = xmmword_1B3553530;
  *(_OWORD *)(v3 + 496) = xmmword_1B3553540;
  *(_OWORD *)(v3 + 512) = xmmword_1B3553550;
  *(int32x4_t *)(v3 + 528) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 544) = xmmword_1B3553560;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BBF840(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2446_Method_A_TMO::~HgcBT2446_Method_A_TMO(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65408A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40897A1F55);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65408A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40897A1F55);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2446_Method_A_TMO::SetParameter(HgcBT2446_Method_A_TMO *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2446_Method_A_TMO::GetParameter(HgcBT2446_Method_A_TMO *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBT2446_Method_A_TMO_Input_Clamped::GetProgram(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000007f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
             "    const half4 c1 = half4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
             "    const half4 c2 = half4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
             "    const half4 c3 = half4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const half4 c4 = half4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const half4 c5 = half4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r0.xy = pow(r0.xy, c0.yy);\n"
             "    r0.y = r0.y*c0.z;\n"
             "    r1.x = r0.x*c0.w + r0.y;\n"
             "    r0.y = pow(r0.z, c0.y);\n"
             "    r0.z = r0.y*c1.z + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.w;\n"
             "    r1.z = half(r1.x < c2.z);\n"
             "    r1.y = half(c2.x < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = half(c2.x < r1.x);\n"
             "    r1.z = half(-r1.w >= c0.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000h);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000h);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = float(r1.x) - float(r0.z);\n"
             "    output.color0.y = float(r0.y)*float(c5.z);\n"
             "    output.color0.zw = float2(r0.xw);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cc0a64d2:44602f95:51ae6a6f:b8abc699\n"
             "//SIG=00400000:00000001:00000001:00000001:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000007d6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
             "    const float4 c1 = float4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
             "    const float4 c2 = float4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
             "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r0.xy = pow(r0.xy, c0.yy);\n"
             "    r0.y = r0.y*c0.z;\n"
             "    r1.x = r0.x*c0.w + r0.y;\n"
             "    r0.y = pow(r0.z, c0.y);\n"
             "    r0.z = r0.y*c1.z + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.w;\n"
             "    r1.z = float(r1.x < c2.z);\n"
             "    r1.y = float(c2.x < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = float(c2.x < r1.x);\n"
             "    r1.z = float(-r1.w >= c0.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = r1.x - r0.z;\n"
             "    output.color0.y = r0.y*c5.z;\n"
             "    output.color0.zw = r0.xw;\n"
             "    return output;\n"
             "}\n"
             "//MD5=cfc8a029:e305a50f:078af61c:309e7d5a\n"
             "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000077a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
           "    const mediump vec4 c1 = vec4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
           "    const mediump vec4 c2 = vec4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
           "    const mediump vec4 c3 = vec4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
           "    const mediump vec4 c4 = vec4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
           "    const mediump vec4 c5 = vec4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = max(r0, c0.xxxx);\n"
           "    r0.xy = pow(r0.xy, c0.yy);\n"
           "    r0.y = r0.y*c0.z;\n"
           "    r1.x = r0.x*c0.w + r0.y;\n"
           "    r0.y = pow(r0.z, c0.y);\n"
           "    r0.z = r0.y*c1.z + r1.x;\n"
           "    r1.x = r0.z*c1.x + c1.y;\n"
           "    r1.x = log2(r1.x);\n"
           "    r1.x = r1.x*c1.w;\n"
           "    r1.z = float(r1.x < c2.z);\n"
           "    r1.y = float(c2.x < r1.x);\n"
           "    r1.w = min(r1.y, r1.z);\n"
           "    r1.y = float(c2.x < r1.x);\n"
           "    r1.z = float(-r1.w >= c0.x);\n"
           "    r1.yw = min(r1.yy, r1.zw);\n"
           "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
           "    r2.x = r1.x*r2.x + c3.z;\n"
           "    r0.xy = r0.xy - r0.zz;\n"
           "    r1.w = -r1.w < 0.00000 ? r2.x : r2.y;\n"
           "    r1.x = r1.x*c3.w + c3.w;\n"
           "    r1.x = -r1.y < 0.00000 ? r1.x : r1.w;\n"
           "    r1.y = r0.z*c4.y;\n"
           "    r1.x = pow(c4.x, r1.x);\n"
           "    r1.y = max(r1.y, c4.z);\n"
           "    r1.x = r1.x*c4.w + -c4.w;\n"
           "    r1.y = r1.x/r1.y;\n"
           "    r0.xy = r0.xy*r1.yy;\n"
           "    r0.x = r0.x*c5.x;\n"
           "    r1.z = r0.x*c5.y;\n"
           "    r0.z = max(r1.z, c3.y);\n"
           "    gl_FragColor.x = r1.x - r0.z;\n"
           "    gl_FragColor.y = r0.y*c5.z;\n"
           "    gl_FragColor.zw = r0.xw;\n"
           "}\n"
           "//MD5=714dff85:561e4c87:9a5079b2:1332a3ac\n"
           "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2446_Method_A_TMO_Input_Clamped::InitProgramDescriptor(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2446_Method_A_TMO_Input_Clamped_hgc_visible", "//Metal1.0     \n//LEN=00000006c4\n[[ visible ]] FragmentOut HgcBT2446_Method_A_TMO_Input_Clamped_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
    "    const float4 c1 = float4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
    "    const float4 c2 = float4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
    "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
    "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
    "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmax(r0, c0.xxxx);\n"
    "    r0.xy = pow(r0.xy, c0.yy);\n"
    "    r0.y = r0.y*c0.z;\n"
    "    r1.x = r0.x*c0.w + r0.y;\n"
    "    r0.y = pow(r0.z, c0.y);\n"
    "    r0.z = r0.y*c1.z + r1.x;\n"
    "    r1.x = r0.z*c1.x + c1.y;\n"
    "    r1.x = log2(r1.x);\n"
    "    r1.x = r1.x*c1.w;\n"
    "    r1.z = float(r1.x < c2.z);\n"
    "    r1.y = float(c2.x < r1.x);\n"
    "    r1.w = fmin(r1.y, r1.z);\n"
    "    r1.y = float(c2.x < r1.x);\n"
    "    r1.z = float(-r1.w >= c0.x);\n"
    "    r1.yw = fmin(r1.yy, r1.zw);\n"
    "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
    "    r2.x = r1.x*r2.x + c3.z;\n"
    "    r0.xy = r0.xy - r0.zz;\n"
    "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
    "    r1.x = r1.x*c3.w + c3.w;\n"
    "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
    "    r1.y = r0.z*c4.y;\n"
    "    r1.x = pow(c4.x, r1.x);\n"
    "    r1.y = fmax(r1.y, c4.z);\n"
    "    r1.x = r1.x*c4.w + -c4.w;\n"
    "    r1.y = r1.x/r1.y;\n"
    "    r0.xy = r0.xy*r1.yy;\n"
    "    r0.x = r0.x*c5.x;\n"
    "    r1.z = r0.x*c5.y;\n"
    "    r0.z = fmax(r1.z, c3.y);\n"
    "    output.color0.x = r1.x - r0.z;\n"
    "    output.color0.y = r0.y*c5.z;\n"
    "    output.color0.zw = r0.xw;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BBFB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BBFBCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BBFBC4);
}

double HgcBT2446_Method_A_TMO_Input_Clamped::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B309DA90;
  strcpy(v3, "HgcBT2446_Method_A_TMO_Input_Clamped [hgc1]");
  return *(double *)"t_Clamped [hgc1]";
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::BindTexture(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::Bind(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGHandler *a2)
{
  (*(void (**)(HgcBT2446_Method_A_TMO_Input_Clamped *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::RenderTile(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int8x16_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int32x4_t v96;
  int32x4_t v97;
  int64x2_t v98;
  int64x2_t v99;
  int32x4_t v100;
  int32x4_t v101;
  int64x2_t v102;
  int64x2_t v103;
  int32x4_t v104;
  int32x4_t v105;
  int8x16_t v106;
  int8x16_t v107;
  int8x16_t v108;
  int32x4_t v109;
  int8x16_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  int8x16_t v119;
  float32x4_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int8x16_t v123;
  float32x4_t v124;
  float32x4_t v125;
  int8x16_t v126;
  int8x16_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v136;
  int8x16_t v137;
  float32x4_t v138;
  float32x4_t v139;
  int8x16_t v140;
  int8x16_t v141;
  float32x4_t v142;
  float32x4_t v143;
  int8x16_t v144;
  int8x16_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  int8x16_t v151;
  int8x16_t v152;
  int8x16_t v153;
  int8x16_t v154;
  int8x16_t *v155;
  int v156;
  uint64_t v157;
  uint64_t v158;
  int8x16_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  int8x16_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  int32x4_t v184;
  float32x4_t v185;
  int8x16_t v186;
  float32x4_t v187;
  float32x4_t v188;
  int8x16_t v189;
  int8x16_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  int8x16_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  int32x4_t v209;
  int64x2_t v210;
  int32x4_t v211;
  int64x2_t v212;
  int32x4_t v213;
  int8x16_t v214;
  int8x16_t v215;
  int32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  int8x16_t v221;
  float32x4_t v222;
  int32x4_t v223;
  int8x16_t v224;
  int8x16_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  int8x16_t v230;
  float32x4_t v231;
  int8x16_t v232;
  float32x4_t v233;
  int8x16_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  int8x16_t v238;
  int8x16_t v239;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v156 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *((_QWORD *)this + 51);
      v12 = *(int8x16_t *)(v11 + 16);
      v13 = vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), *(float32x4_t *)v11);
      v14 = vmaxq_f32(*(float32x4_t *)(v6 + v10), *(float32x4_t *)v11);
      v16 = *(float32x4_t *)(v11 + 32);
      v15 = *(float32x4_t *)(v11 + 48);
      v17 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v13), (int8x16_t)v16);
      v18 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v14), (int8x16_t)v16);
      v19 = *(int8x16_t *)(v11 + 64);
      v20 = *(float32x4_t *)(v11 + 80);
      v22 = *(float32x4_t *)(v11 + 96);
      v21 = *(float32x4_t *)(v11 + 112);
      v23 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v17, v22));
      v24 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v18, v22));
      v25 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v13, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v13))), v20), v23);
      v26 = vsubq_f32(vsubq_f32(v17, v16), vmulq_f32(vmulq_f32(v21, v23), v17));
      v27 = vsubq_f32(vsubq_f32(v18, v16), vmulq_f32(vmulq_f32(v21, v24), v18));
      v28 = *(float32x4_t *)(v11 + 128);
      v29 = *(float32x4_t *)(v11 + 144);
      v30 = *(float32x4_t *)(v11 + 160);
      v31 = *(float32x4_t *)(v11 + 176);
      v32 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v14, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v14))), v20), v24), vmulq_f32(v27, vaddq_f32(vaddq_f32(v30, vmulq_f32(v27, v31)), vmulq_f32(vmulq_f32(v27, v27), vaddq_f32(v28, vmulq_f32(v29, v27))))));
      v34 = *(float32x4_t *)(v11 + 192);
      v33 = *(float32x4_t *)(v11 + 208);
      v35 = vmaxq_f32(vmulq_f32(v34, vaddq_f32(v25, vmulq_f32(v26, vaddq_f32(vaddq_f32(v30, vmulq_f32(v26, v31)), vmulq_f32(vmulq_f32(v26, v26), vaddq_f32(v28, vmulq_f32(v29, v26))))))), v33);
      v36 = vmaxq_f32(vmulq_f32(v34, v32), v33);
      v37 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      v38 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      v39 = vsubq_f32(v37, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v37, v35)));
      v40 = vsubq_f32(v38, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v38, v36)));
      v41 = vsubq_f32(v35, v39);
      v42 = *(float32x4_t *)(v11 + 224);
      v43 = *(float32x4_t *)(v11 + 240);
      v44 = vsubq_f32(v36, v40);
      v45 = *(float32x4_t *)(v11 + 256);
      v46 = *(int32x4_t *)(v11 + 272);
      v41.i64[0] = vmulq_f32(vaddq_f32(v16, vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v39)), 0x17uLL)).u64[0];
      v39.i64[0] = vmulq_f32(vaddq_f32(v16, vmulq_f32(v44, vaddq_f32(v45, vmulq_f32(v44, vaddq_f32(v42, vmulq_f32(v43, v44)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v40)), 0x17uLL)).u64[0];
      v41.i64[1] = v13.i64[1];
      v39.i64[1] = v14.i64[1];
      v47 = *(float32x4_t *)(v11 + 288);
      v48 = *(float32x4_t *)(v11 + 304);
      v49 = (float32x4_t)vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v47, v41), (int8x16_t)v41);
      v50 = (float32x4_t)vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v47, v39), (int8x16_t)v39);
      v51 = *(float32x4_t *)(v11 + 320);
      v52 = *(int8x16_t *)(v11 + 336);
      v53 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v49), vmulq_lane_f32(v49, *(float32x2_t *)v51.f32, 1));
      v54 = (float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 4uLL);
      v55 = (float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 4uLL);
      v56 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v54, v12), (int8x16_t)v16);
      v57 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v55, v12), (int8x16_t)v16);
      v58 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v56, v22));
      v59 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v57, v22));
      v60 = vsubq_f32(vsubq_f32(v56, v16), vmulq_f32(vmulq_f32(v21, v58), v56));
      v61 = vsubq_f32(vsubq_f32(v57, v16), vmulq_f32(vmulq_f32(v21, v59), v57));
      v62 = vmaxq_f32(vmulq_f32(v34, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v54, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v54))), v20), v58), vmulq_f32(v60, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v60)), vmulq_f32(vmulq_f32(v60, v60), vaddq_f32(v28, vmulq_f32(v29, v60))))))), v33);
      v63 = vmaxq_f32(vmulq_f32(v34, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v55, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v55))), v20), v59), vmulq_f32(v61, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v61)), vmulq_f32(vmulq_f32(v61, v61), vaddq_f32(v28, vmulq_f32(v29, v61))))))), v33);
      v64 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v50), vmulq_lane_f32(v50, *(float32x2_t *)v51.f32, 1));
      v65 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      v66 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v65, v62)));
      v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v66, v63)));
      v69 = vsubq_f32(v62, v67);
      v70 = vsubq_f32(v63, v68);
      v71 = vaddq_f32(v16, vmulq_f32(v69, vaddq_f32(v45, vmulq_f32(v69, vaddq_f32(v42, vmulq_f32(v43, v69))))));
      v72 = vaddq_f32(v16, vmulq_f32(v70, vaddq_f32(v45, vmulq_f32(v70, vaddq_f32(v42, vmulq_f32(v43, v70))))));
      v73 = vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v71, (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v67), v46), 0x17uLL)), (int8x16_t)v41);
      v74 = vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v68), v46), 0x17uLL)), (int8x16_t)v39);
      v75 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v53, v53, 8uLL), vmulq_lane_f32(v51, *(float32x2_t *)v73.i8, 1)), v73);
      v76 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v64, v64, 8uLL), vmulq_lane_f32(v51, *(float32x2_t *)v74.i8, 1)), v74);
      v77 = (float32x4_t)vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL);
      v78 = (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL);
      v79 = *(float32x4_t *)(v11 + 352);
      v80 = *(float32x4_t *)(v11 + 368);
      v81 = vaddq_f32(v51, vmulq_f32(v79, v77));
      v82 = vaddq_f32(v51, vmulq_f32(v79, v78));
      v83 = (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v81));
      v84 = (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v82));
      v85 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v81, 0x17uLL)), v83);
      v86 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v81), (int8x16_t)v51);
      v87 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v82), (int8x16_t)v51);
      v88 = vsubq_f32(v85, v20);
      v89 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), v84), v20);
      v90 = (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v86, v22));
      v91 = (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v87, v22));
      v92 = vaddq_f32(v88, v90);
      v93 = vsubq_f32(vsubq_f32(v86, v51), vmulq_f32(vmulq_f32(v21, v90), v86));
      v94 = vsubq_f32(vsubq_f32(v87, v51), vmulq_f32(vmulq_f32(v21, v91), v87));
      v95 = vaddq_f32(vaddq_f32(v89, v91), vmulq_f32(v94, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v94)), vmulq_f32(vmulq_f32(v94, v94), vaddq_f32(v28, vmulq_f32(v29, v94))))));
      v96 = (int32x4_t)vmulq_f32(v80, vaddq_f32(v92, vmulq_f32(v93, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v93)), vmulq_f32(vmulq_f32(v93, v93), vaddq_f32(v28, vmulq_f32(v29, v93)))))));
      v97 = (int32x4_t)vmulq_f32(v80, v95);
      v98 = (int64x2_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v80, (float32x4_t)vextq_s8((int8x16_t)v96, (int8x16_t)v96, 8uLL)));
      v99 = (int64x2_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v80, (float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 8uLL)));
      v91.i64[0] = v96.i64[0];
      v28.i64[0] = v97.i64[0];
      v91.i64[1] = v98.i64[1];
      v28.i64[1] = v99.i64[1];
      v96.i64[1] = vdupq_laneq_s64(v98, 1).u64[0];
      v97.i64[1] = vdupq_laneq_s64(v99, 1).u64[0];
      v100 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v96), v80)), (int8x16_t)v91);
      v101 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v97), v80)), (int8x16_t)v28);
      v102 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL), (float32x4_t)vrev64q_s32(v100));
      v103 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v101, (int8x16_t)v101, 8uLL), (float32x4_t)vrev64q_s32(v101));
      v91.i64[0] = v100.i64[0];
      v91.i64[1] = v102.i64[1];
      v28.i64[0] = v101.i64[0];
      v28.i64[1] = v103.i64[1];
      v100.i64[1] = vdupq_laneq_s64(v102, 1).u64[0];
      v101.i64[1] = vdupq_laneq_s64(v103, 1).u64[0];
      v104 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v100), v80)), (int8x16_t)v91);
      v105 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v101), v80)), (int8x16_t)v28);
      v106 = vbslq_s8(v52, vandq_s8((int8x16_t)v79, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v104)), v45)), (int8x16_t)v104);
      v107 = vbslq_s8(v52, vandq_s8((int8x16_t)v79, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v105)), v45)), (int8x16_t)v105);
      v109 = *(int32x4_t *)(v11 + 384);
      v108 = *(int8x16_t *)(v11 + 400);
      *(int8x8_t *)v30.f32 = vqtbl1_s8(v106, *(int8x8_t *)v109.i8);
      v104.i64[0] = vextq_s8((int8x16_t)v109, (int8x16_t)v109, 8uLL).u64[0];
      *(int8x8_t *)&v30.u32[2] = vqtbl1_s8(v106, *(int8x8_t *)v104.i8);
      *(int8x8_t *)v31.f32 = vqtbl1_s8(v107, *(int8x8_t *)v109.i8);
      *(int8x8_t *)&v31.u32[2] = vqtbl1_s8(v107, *(int8x8_t *)v104.i8);
      v110 = (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v107.i64[0], 0), v31);
      v111 = (float32x4_t)vbslq_s8(v108, v106, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v106.i64[0], 0), v30));
      v112 = *(float32x4_t *)(v11 + 416);
      v113 = *(float32x4_t *)(v11 + 432);
      v114 = (float32x4_t)vbslq_s8(v108, v107, v110);
      v115 = vaddq_f32(v112, vmulq_n_f32(v113, v111.f32[0]));
      v116 = vaddq_f32(v112, vmulq_n_f32(v113, v114.f32[0]));
      v118 = *(float32x4_t *)(v11 + 448);
      v117 = *(float32x4_t *)(v11 + 464);
      v119 = vbslq_s8(v108, (int8x16_t)vaddq_f32(v118, vmulq_f32(v115, v111)), (int8x16_t)v115);
      v120 = (float32x4_t)vbslq_s8(v108, (int8x16_t)vaddq_f32(v118, vmulq_f32(v116, v114)), (int8x16_t)v116);
      v111.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v111, v118), vextq_s8(v119, v119, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v119, 0)).i64[1];
      v121 = (int32x4_t)vbslq_s8(v108, (int8x16_t)vaddq_f32(v21, vmulq_f32(v21, v111)), (int8x16_t)v111);
      v114.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v114, v118), vextq_s8(*(int8x16_t *)&v120, *(int8x16_t *)&v120, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v120, 0)).i64[1];
      v122 = (int32x4_t)vbslq_s8(v108, (int8x16_t)vaddq_f32(v21, vmulq_f32(v21, v114)), (int8x16_t)v114);
      v123 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v122), *(float32x4_t *)v11), (int8x16_t)v122, vextq_s8((int8x16_t)v122, (int8x16_t)v122, 0xCuLL));
      v124 = vsubq_f32(v75, (float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 2));
      v125 = vsubq_f32(v76, (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 2));
      *(int8x8_t *)v120.f32 = vext_s8(*(int8x8_t *)v124.f32, *(int8x8_t *)v77.f32, 4uLL);
      *(int8x8_t *)&v120.u32[2] = vext_s8(*(int8x8_t *)v77.f32, *(int8x8_t *)v124.f32, 4uLL);
      *(int8x8_t *)v48.f32 = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v78.f32, 4uLL);
      *(int8x8_t *)&v48.u32[2] = vext_s8(*(int8x8_t *)v78.f32, *(int8x8_t *)v125.f32, 4uLL);
      v126 = (int8x16_t)vmulq_f32(v118, v120);
      v127 = (int8x16_t)vmulq_f32(v118, v48);
      v128 = vmaxq_f32(vmulq_f32(v117, (float32x4_t)vbslq_s8(v108, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v121), *(float32x4_t *)v11), (int8x16_t)v121, vextq_s8((int8x16_t)v121, (int8x16_t)v121, 0xCuLL)), v126)), v33);
      v129 = vmaxq_f32(vmulq_f32(v117, (float32x4_t)vbslq_s8(v108, v123, v127)), v33);
      v130 = vcvtq_f32_s32(vcvtq_s32_f32(v128));
      v131 = vcvtq_f32_s32(vcvtq_s32_f32(v129));
      v132 = vsubq_f32(v130, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v130, v128)));
      v133 = vsubq_f32(v131, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v131, v129)));
      v134 = vsubq_f32(v128, v132);
      v135 = vsubq_f32(v129, v133);
      v136 = (int8x16_t)vmulq_f32(vaddq_f32(v51, vmulq_f32(v134, vaddq_f32(v45, vmulq_f32(v134, vaddq_f32(v42, vmulq_f32(v43, v134)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v132), v109), 0x17uLL));
      v137 = (int8x16_t)vmulq_f32(vaddq_f32(v51, vmulq_f32(v135, vaddq_f32(v45, vmulq_f32(v135, vaddq_f32(v42, vmulq_f32(v43, v135)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v133), v109), 0x17uLL));
      v138 = *(float32x4_t *)(v11 + 480);
      v139 = *(float32x4_t *)(v11 + 496);
      v140 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v108, v136, v126), v138);
      v141 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v108, v137, v127), v138);
      v142 = *(float32x4_t *)(v11 + 512);
      v143 = *(float32x4_t *)(v11 + 528);
      v144 = (int8x16_t)vaddq_f32(v139, vmulq_f32(v142, (float32x4_t)vbslq_s8(v108, v136, v140)));
      v145 = (int8x16_t)vaddq_f32(v139, vmulq_f32(v142, (float32x4_t)vbslq_s8(v108, v137, v141)));
      v146 = (float32x4_t)vbslq_s8(v108, v144, v140);
      v147 = (float32x4_t)vbslq_s8(v108, v145, v141);
      v148 = vminq_f32(vmaxq_f32(vmulq_f32(v142, vrecpeq_f32(v146)), v139), v143);
      v149 = vminq_f32(vmaxq_f32(vmulq_f32(v142, vrecpeq_f32(v147)), v139), v143);
      v144.i64[0] = vbslq_s8(v108, v144, (int8x16_t)vmulq_n_f32(vmulq_f32(v148, vrecpsq_f32(v146, v148)), v146.f32[0])).u64[0];
      v145.i64[0] = vbslq_s8(v108, v145, (int8x16_t)vmulq_n_f32(vmulq_f32(v149, vrecpsq_f32(v147, v149)), v147.f32[0])).u64[0];
      v146.i64[0] = vmulq_lane_f32(v124, *(float32x2_t *)v144.i8, 1).u64[0];
      v125.i64[0] = vmulq_lane_f32(v125, *(float32x2_t *)v145.i8, 1).u64[0];
      v146.i64[1] = v75.i64[1];
      v125.i64[1] = v76.i64[1];
      v150 = *(float32x4_t *)(v11 + 544);
      v151 = vbslq_s8(v108, (int8x16_t)vmulq_f32(v150, v146), (int8x16_t)v146);
      v152 = vbslq_s8(v108, (int8x16_t)vmulq_f32(v150, v125), (int8x16_t)v125);
      v143.i64[0] = v144.i64[0];
      v143.i64[1] = vmulq_f32(v150, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v151, 0)).i64[1];
      v149.i64[0] = v145.i64[0];
      v149.i64[1] = vmulq_f32(v150, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v152, 0)).i64[1];
      v153 = vbslq_s8(v52, (int8x16_t)vmaxq_f32(v143, v142), v151);
      v154 = vbslq_s8(v52, (int8x16_t)vmaxq_f32(v149, v142), v152);
      v150.i64[0] = vmvnq_s8(v108).u64[0];
      *(int8x8_t *)v144.i8 = vorr_s8(vand_s8(*(int8x8_t *)v108.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v144.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v153, v153, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v117.f32, *(float32x2_t *)v153.i8), *(int8x8_t *)v150.f32));
      v144.u64[1] = (unint64_t)vqtbl1_s8(v153, *(int8x8_t *)v104.i8);
      *(int8x8_t *)v145.i8 = vorr_s8(vand_s8(*(int8x8_t *)v108.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v145.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v154, v154, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v117.f32, *(float32x2_t *)v154.i8), *(int8x8_t *)v150.f32));
      v145.u64[1] = (unint64_t)vqtbl1_s8(v154, *(int8x8_t *)v104.i8);
      v155 = (int8x16_t *)(v5 + v10);
      v155[-1] = v144;
      *v155 = v145;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v156 = -v9;
    if (v156 >= v4)
      goto LABEL_3;
LABEL_10:
    v157 = 16 * v156;
    v158 = *((_QWORD *)this + 51);
    v159 = *(int8x16_t *)(v158 + 16);
    v160 = vmaxq_f32(*(float32x4_t *)(v6 + v157), *(float32x4_t *)v158);
    v162 = *(float32x4_t *)(v158 + 32);
    v161 = *(float32x4_t *)(v158 + 48);
    v163 = (float32x4_t)vorrq_s8(vandq_s8(v159, (int8x16_t)v160), (int8x16_t)v162);
    v164 = *(int8x16_t *)(v158 + 64);
    v165 = *(float32x4_t *)(v158 + 80);
    v167 = *(float32x4_t *)(v158 + 96);
    v166 = *(float32x4_t *)(v158 + 112);
    v168 = (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v163, v167));
    v169 = vsubq_f32(vsubq_f32(v163, v162), vmulq_f32(vmulq_f32(v166, v168), v163));
    v170 = *(float32x4_t *)(v158 + 128);
    v171 = *(float32x4_t *)(v158 + 144);
    v172 = *(float32x4_t *)(v158 + 160);
    v173 = *(float32x4_t *)(v158 + 176);
    v174 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v160, 0x17uLL)), (float32x4_t)vandq_s8(v164, (int8x16_t)vcgtq_f32(v161, v160))), v165), v168), vmulq_f32(v169, vaddq_f32(vaddq_f32(v172, vmulq_f32(v169, v173)), vmulq_f32(vmulq_f32(v169, v169), vaddq_f32(v170, vmulq_f32(v171, v169))))));
    v176 = *(float32x4_t *)(v158 + 192);
    v175 = *(float32x4_t *)(v158 + 208);
    v177 = vmaxq_f32(vmulq_f32(v176, v174), v175);
    v178 = vcvtq_f32_s32(vcvtq_s32_f32(v177));
    v179 = vsubq_f32(v178, (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v178, v177)));
    v180 = vsubq_f32(v177, v179);
    v181 = *(float32x4_t *)(v158 + 224);
    v182 = *(float32x4_t *)(v158 + 240);
    v183 = *(float32x4_t *)(v158 + 256);
    v184 = *(int32x4_t *)(v158 + 272);
    v185.i64[0] = vmulq_f32(vaddq_f32(v162, vmulq_f32(v180, vaddq_f32(v183, vmulq_f32(v180, vaddq_f32(v181, vmulq_f32(v182, v180)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v184, vcvtq_s32_f32(v179)), 0x17uLL)).u64[0];
    v185.i64[1] = v160.i64[1];
    v186 = *(int8x16_t *)(v158 + 304);
    v187 = (float32x4_t)vbslq_s8(v186, (int8x16_t)vmulq_f32(*(float32x4_t *)(v158 + 288), v185), (int8x16_t)v185);
    v188 = *(float32x4_t *)(v158 + 320);
    v189 = *(int8x16_t *)(v158 + 336);
    v190 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v187), vmulq_lane_f32(v187, *(float32x2_t *)v188.f32, 1));
    v191 = (float32x4_t)vextq_s8((int8x16_t)v187, (int8x16_t)v187, 4uLL);
    v192 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v191, v159), (int8x16_t)v162);
    v193 = (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v192, v167));
    v194 = vsubq_f32(vsubq_f32(v192, v162), vmulq_f32(vmulq_f32(v166, v193), v192));
    v195 = vmaxq_f32(vmulq_f32(v176, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v191, 0x17uLL)), (float32x4_t)vandq_s8(v164, (int8x16_t)vcgtq_f32(v161, v191))), v165), v193), vmulq_f32(v194, vaddq_f32(vaddq_f32(v172, vmulq_f32(v173, v194)), vmulq_f32(vmulq_f32(v194, v194), vaddq_f32(v170, vmulq_f32(v171, v194))))))), v175);
    v196 = vcvtq_f32_s32(vcvtq_s32_f32(v195));
    v197 = vsubq_f32(v196, (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v196, v195)));
    v198 = vsubq_f32(v195, v197);
    v199 = vbslq_s8(v186, (int8x16_t)vmulq_f32(vaddq_f32(v162, vmulq_f32(v198, vaddq_f32(v183, vmulq_f32(v198, vaddq_f32(v181, vmulq_f32(v182, v198)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v197), v184), 0x17uLL)), (int8x16_t)v185);
    v200 = (float32x4_t)vbslq_s8(v189, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v190, v190, 8uLL), vmulq_lane_f32(v188, *(float32x2_t *)v199.i8, 1)), v199);
    v201 = (float32x4_t)vextq_s8((int8x16_t)v200, (int8x16_t)v200, 8uLL);
    v202 = *(float32x4_t *)(v158 + 352);
    v203 = *(float32x4_t *)(v158 + 368);
    v204 = vaddq_f32(v188, vmulq_f32(v202, v201));
    v205 = (float32x4_t)vorrq_s8(vandq_s8(v159, (int8x16_t)v204), (int8x16_t)v188);
    v206 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v204, 0x17uLL)), (float32x4_t)vandq_s8(v164, (int8x16_t)vcgtq_f32(v161, v204))), v165);
    v207 = (float32x4_t)vandq_s8((int8x16_t)v188, (int8x16_t)vcgtq_f32(v205, v167));
    v208 = vsubq_f32(vsubq_f32(v205, v188), vmulq_f32(vmulq_f32(v166, v207), v205));
    v209 = (int32x4_t)vmulq_f32(v203, vaddq_f32(vaddq_f32(v206, v207), vmulq_f32(v208, vaddq_f32(vaddq_f32(v172, vmulq_f32(v173, v208)), vmulq_f32(vmulq_f32(v208, v208), vaddq_f32(v170, vmulq_f32(v171, v208)))))));
    v210 = (int64x2_t)vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32(v203, (float32x4_t)vextq_s8((int8x16_t)v209, (int8x16_t)v209, 8uLL)));
    v207.i64[0] = v209.i64[0];
    v207.i64[1] = v210.i64[1];
    v209.i64[1] = vdupq_laneq_s64(v210, 1).u64[0];
    v211 = (int32x4_t)vbslq_s8(v186, vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v209), v203)), (int8x16_t)v207);
    v212 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v211, (int8x16_t)v211, 8uLL), (float32x4_t)vrev64q_s32(v211));
    v207.i64[0] = v211.i64[0];
    v207.i64[1] = v212.i64[1];
    v211.i64[1] = vdupq_laneq_s64(v212, 1).u64[0];
    v213 = (int32x4_t)vbslq_s8(v186, vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v211), v203)), (int8x16_t)v207);
    v214 = vbslq_s8(v189, vandq_s8((int8x16_t)v202, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v213)), v183)), (int8x16_t)v213);
    v216 = *(int32x4_t *)(v158 + 384);
    v215 = *(int8x16_t *)(v158 + 400);
    *(int8x8_t *)v170.f32 = vqtbl1_s8(v214, *(int8x8_t *)v216.i8);
    v212.i64[0] = vextq_s8((int8x16_t)v216, (int8x16_t)v216, 8uLL).u64[0];
    *(int8x8_t *)&v170.u32[2] = vqtbl1_s8(v214, *(int8x8_t *)v212.i8);
    v217 = (float32x4_t)vbslq_s8(v215, v214, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v214.i64[0], 0), v170));
    v218 = vaddq_f32(*(float32x4_t *)(v158 + 416), vmulq_n_f32(*(float32x4_t *)(v158 + 432), v217.f32[0]));
    v219 = *(float32x4_t *)(v158 + 448);
    v220 = *(float32x4_t *)(v158 + 464);
    v221 = vbslq_s8(v215, (int8x16_t)vaddq_f32(v219, vmulq_f32(v218, v217)), (int8x16_t)v218);
    v222 = vsubq_f32(v200, (float32x4_t)vdupq_laneq_s32((int32x4_t)v200, 2));
    v217.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v217, v219), vextq_s8(v221, v221, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v221, 0)).i64[1];
    v223 = (int32x4_t)vbslq_s8(v215, (int8x16_t)vaddq_f32(v166, vmulq_f32(v166, v217)), (int8x16_t)v217);
    *(int8x8_t *)v173.f32 = vext_s8(*(int8x8_t *)v222.f32, *(int8x8_t *)v201.f32, 4uLL);
    *(int8x8_t *)&v173.u32[2] = vext_s8(*(int8x8_t *)v201.f32, *(int8x8_t *)v222.f32, 4uLL);
    v224 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v223), *(float32x4_t *)v158), (int8x16_t)v223, vextq_s8((int8x16_t)v223, (int8x16_t)v223, 0xCuLL));
    v225 = (int8x16_t)vmulq_f32(v219, v173);
    v226 = vmaxq_f32(vmulq_f32(v220, (float32x4_t)vbslq_s8(v215, v224, v225)), v175);
    v227 = vcvtq_f32_s32(vcvtq_s32_f32(v226));
    v228 = vsubq_f32(v227, (float32x4_t)vandq_s8((int8x16_t)v188, (int8x16_t)vcgtq_f32(v227, v226)));
    v229 = vsubq_f32(v226, v228);
    v230 = (int8x16_t)vmulq_f32(vaddq_f32(v188, vmulq_f32(v229, vaddq_f32(v183, vmulq_f32(v229, vaddq_f32(v181, vmulq_f32(v182, v229)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v228), v216), 0x17uLL));
    v231 = *(float32x4_t *)(v158 + 496);
    v232 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v215, v230, v225), *(float32x4_t *)(v158 + 480));
    v233 = *(float32x4_t *)(v158 + 512);
    v234 = (int8x16_t)vaddq_f32(v231, vmulq_f32(v233, (float32x4_t)vbslq_s8(v215, v230, v232)));
    v235 = (float32x4_t)vbslq_s8(v215, v234, v232);
    v236 = vminq_f32(vmaxq_f32(vmulq_f32(v233, vrecpeq_f32(v235)), v231), *(float32x4_t *)(v158 + 528));
    v234.i64[0] = vbslq_s8(v215, v234, (int8x16_t)vmulq_n_f32(vmulq_f32(v236, vrecpsq_f32(v235, v236)), v235.f32[0])).u64[0];
    v235.i64[0] = vmulq_lane_f32(v222, *(float32x2_t *)v234.i8, 1).u64[0];
    v235.i64[1] = v200.i64[1];
    v237 = *(float32x4_t *)(v158 + 544);
    v238 = vbslq_s8(v215, (int8x16_t)vmulq_f32(v237, v235), (int8x16_t)v235);
    v182.i64[0] = v234.i64[0];
    v182.i64[1] = vmulq_f32(v237, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v238, 0)).i64[1];
    v239 = vbslq_s8(v189, (int8x16_t)vmaxq_f32(v182, v233), v238);
    *(int8x8_t *)v234.i8 = vorr_s8(vand_s8(*(int8x8_t *)v215.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v234.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v239, v239, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v220.f32, *(float32x2_t *)v239.i8), (int8x8_t)*(_OWORD *)&vmvnq_s8(v215)));
    v234.u64[1] = (unint64_t)vqtbl1_s8(v239, *(int8x8_t *)v212.i8);
    *(int8x16_t *)(v5 + v157) = v234;
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::GetDOD(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::GetROI(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2446_Method_A_TMO_Input_Clamped::HgcBT2446_Method_A_TMO_Input_Clamped(HgcBT2446_Method_A_TMO_Input_Clamped *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6540B08;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B35533A0;
  *(_OWORD *)(v3 + 32) = xmmword_1B30520F0;
  *(_OWORD *)(v3 + 48) = xmmword_1B35533B0;
  *(_OWORD *)(v3 + 64) = xmmword_1B35533C0;
  *(_OWORD *)(v3 + 80) = xmmword_1B35533D0;
  *(_OWORD *)(v3 + 96) = xmmword_1B35533E0;
  *(_OWORD *)(v3 + 112) = xmmword_1B3052100;
  *(_OWORD *)(v3 + 128) = xmmword_1B35533F0;
  *(_OWORD *)(v3 + 144) = xmmword_1B3553400;
  *(_OWORD *)(v3 + 160) = xmmword_1B3553410;
  *(_OWORD *)(v3 + 176) = xmmword_1B3553420;
  *(_OWORD *)(v3 + 192) = xmmword_1B3553430;
  *(_OWORD *)(v3 + 208) = xmmword_1B3553440;
  *(_OWORD *)(v3 + 224) = xmmword_1B3553450;
  *(_OWORD *)(v3 + 240) = xmmword_1B3553460;
  *(_OWORD *)(v3 + 256) = xmmword_1B3553470;
  *(_OWORD *)(v3 + 272) = xmmword_1B3553480;
  *(_OWORD *)(v3 + 288) = xmmword_1B3553490;
  *(_OWORD *)(v3 + 304) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 320) = xmmword_1B3553590;
  *(_OWORD *)(v3 + 336) = xmmword_1B3050FE0;
  *(_OWORD *)(v3 + 352) = xmmword_1B35534B0;
  *(_OWORD *)(v3 + 368) = xmmword_1B35534C0;
  *(_OWORD *)(v3 + 384) = xmmword_1B35534D0;
  *(_OWORD *)(v3 + 400) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 416) = xmmword_1B35534E0;
  *(_OWORD *)(v3 + 432) = xmmword_1B35534F0;
  *(_OWORD *)(v3 + 448) = xmmword_1B35535A0;
  *(_OWORD *)(v3 + 464) = xmmword_1B3553520;
  *(_OWORD *)(v3 + 480) = xmmword_1B3553530;
  *(_OWORD *)(v3 + 496) = xmmword_1B3553540;
  *(_OWORD *)(v3 + 512) = xmmword_1B3553550;
  *(int32x4_t *)(v3 + 528) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 544) = xmmword_1B3553560;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BC0B74(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2446_Method_A_TMO_Input_Clamped::~HgcBT2446_Method_A_TMO_Input_Clamped(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6540B08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40897A1F55);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6540B08;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40897A1F55);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::SetParameter(HgcBT2446_Method_A_TMO_Input_Clamped *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::GetParameter(HgcBT2446_Method_A_TMO_Input_Clamped *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBT2446_Method_A_ITMO::GetProgram(HgcBT2446_Method_A_ITMO *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000069a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
             "    const half4 c1 = half4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
             "    const half4 c2 = half4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
             "    const half4 c3 = half4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
             "    const half4 c4 = half4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = r0.x*c0.x;\n"
             "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
             "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
             "    r1.y = c0.w - r1.x;\n"
             "    r1.y = select(r1.w, r1.z, r1.y < 0.00000h);\n"
             "    r1.x = fmax(r1.x, c2.x);\n"
             "    r1.x = pow(r1.x, r1.y);\n"
             "    r1.y = r1.x/r0.x;\n"
             "    r1.y = r1.y*c2.y;\n"
             "    r0.x = select(c2.z, r1.y, -r0.x < 0.00000h);\n"
             "    r0.xz = r0.yz*r0.xx;\n"
             "    r1.y = r0.z*c2.w + r1.x;\n"
             "    r1.y = fmin(r1.y, c3.y);\n"
             "    r1.y = fmax(r1.y, c2.x);\n"
             "    r0.y = r1.y*c3.x;\n"
             "    r1.y = r0.x*c3.z + r1.x;\n"
             "    output.color0.x = pow(float(r0.y), float(c3.w));\n"
             "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
             "    r0.xy = fmin(r0.xy, c3.yy);\n"
             "    r0.xy = fmax(r0.xy, c2.xx);\n"
             "    r0.xy = r0.xy*c3.xx;\n"
             "    output.color0.yz = pow(float2(r0.yx), float2(c3.ww));\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=52cfe100:87057625:53164afc:07fec1d0\n"
             "//SIG=00400000:00000001:00000001:00000001:0005:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000679\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
             "    const float4 c1 = float4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
             "    const float4 c2 = float4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
             "    const float4 c3 = float4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
             "    const float4 c4 = float4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = r0.x*c0.x;\n"
             "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
             "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
             "    r1.y = c0.w - r1.x;\n"
             "    r1.y = select(r1.w, r1.z, r1.y < 0.00000f);\n"
             "    r1.x = fmax(r1.x, c2.x);\n"
             "    r1.x = pow(r1.x, r1.y);\n"
             "    r1.y = r1.x/r0.x;\n"
             "    r1.y = r1.y*c2.y;\n"
             "    r0.x = select(c2.z, r1.y, -r0.x < 0.00000f);\n"
             "    r0.xz = r0.yz*r0.xx;\n"
             "    r1.y = r0.z*c2.w + r1.x;\n"
             "    r1.y = fmin(r1.y, c3.y);\n"
             "    r1.y = fmax(r1.y, c2.x);\n"
             "    r0.y = r1.y*c3.x;\n"
             "    r1.y = r0.x*c3.z + r1.x;\n"
             "    output.color0.x = pow(r0.y, c3.w);\n"
             "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
             "    r0.xy = fmin(r0.xy, c3.yy);\n"
             "    r0.xy = fmax(r0.xy, c2.xx);\n"
             "    r0.xy = r0.xy*c3.xx;\n"
             "    output.color0.yz = pow(r0.yx, c3.ww);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5fd96646:90622500:0191c3b0:ef8ed030\n"
             "//SIG=00000000:00000001:00000001:00000000:0005:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000619\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
           "    const mediump vec4 c1 = vec4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
           "    const mediump vec4 c2 = vec4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
           "    const mediump vec4 c3 = vec4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
           "    const mediump vec4 c4 = vec4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = r0.x*c0.x;\n"
           "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
           "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
           "    r1.y = c0.w - r1.x;\n"
           "    r1.y = r1.y < 0.00000 ? r1.z : r1.w;\n"
           "    r1.x = max(r1.x, c2.x);\n"
           "    r1.x = pow(r1.x, r1.y);\n"
           "    r1.y = r1.x/r0.x;\n"
           "    r1.y = r1.y*c2.y;\n"
           "    r0.x = -r0.x < 0.00000 ? r1.y : c2.z;\n"
           "    r0.xz = r0.yz*r0.xx;\n"
           "    r1.y = r0.z*c2.w + r1.x;\n"
           "    r1.y = min(r1.y, c3.y);\n"
           "    r1.y = max(r1.y, c2.x);\n"
           "    r0.y = r1.y*c3.x;\n"
           "    r1.y = r0.x*c3.z + r1.x;\n"
           "    gl_FragColor.x = pow(r0.y, c3.w);\n"
           "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
           "    r0.xy = min(r0.xy, c3.yy);\n"
           "    r0.xy = max(r0.xy, c2.xx);\n"
           "    r0.xy = r0.xy*c3.xx;\n"
           "    gl_FragColor.yz = pow(r0.yx, c3.ww);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=4c3db6c5:8c56c001:502585ba:cb00e598\n"
           "//SIG=00000000:00000001:00000001:00000000:0005:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2446_Method_A_ITMO::InitProgramDescriptor(HgcBT2446_Method_A_ITMO *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2446_Method_A_ITMO_hgc_visible", "//Metal1.0     \n//LEN=000000055a\n[[ visible ]] FragmentOut HgcBT2446_Method_A_ITMO_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
    "    const float4 c1 = float4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
    "    const float4 c2 = float4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
    "    const float4 c3 = float4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
    "    const float4 c4 = float4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = r0.x*c0.x;\n"
    "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
    "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
    "    r1.y = c0.w - r1.x;\n"
    "    r1.y = select(r1.w, r1.z, r1.y < 0.00000f);\n"
    "    r1.x = fmax(r1.x, c2.x);\n"
    "    r1.x = pow(r1.x, r1.y);\n"
    "    r1.y = r1.x/r0.x;\n"
    "    r1.y = r1.y*c2.y;\n"
    "    r0.x = select(c2.z, r1.y, -r0.x < 0.00000f);\n"
    "    r0.xz = r0.yz*r0.xx;\n"
    "    r1.y = r0.z*c2.w + r1.x;\n"
    "    r1.y = fmin(r1.y, c3.y);\n"
    "    r1.y = fmax(r1.y, c2.x);\n"
    "    r0.y = r1.y*c3.x;\n"
    "    r1.y = r0.x*c3.z + r1.x;\n"
    "    output.color0.x = pow(r0.y, c3.w);\n"
    "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
    "    r0.xy = fmin(r0.xy, c3.yy);\n"
    "    r0.xy = fmax(r0.xy, c2.xx);\n"
    "    r0.xy = r0.xy*c3.xx;\n"
    "    output.color0.yz = pow(r0.yx, c3.ww);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC0ED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC0F00(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC0EF8);
}

double HgcBT2446_Method_A_ITMO::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552E70;
  strcpy(v3, "HgcBT2446_Method_A_ITMO [hgc1]");
  return *(double *)"od_A_ITMO [hgc1]";
}

uint64_t HgcBT2446_Method_A_ITMO::BindTexture(HgcBT2446_Method_A_ITMO *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2446_Method_A_ITMO::Bind(HgcBT2446_Method_A_ITMO *this, HGHandler *a2)
{
  (*(void (**)(HgcBT2446_Method_A_ITMO *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2446_Method_A_ITMO::RenderTile(HgcBT2446_Method_A_ITMO *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  int8x8_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  float32x4_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int32x4_t v88;
  int32x4_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int32x4_t v98;
  int32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  int32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  int8x16_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  int32x4_t v177;
  int8x16_t *v178;
  int v179;
  uint64_t v180;
  float32x4_t v181;
  uint64_t v182;
  float32x4_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int8x16_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  int8x16_t v190;
  float32x4_t v191;
  int8x16_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  int32x4_t v219;
  int8x16_t v220;
  float32x4_t v221;
  float32x4_t v222;
  float32x4_t v223;
  float32x4_t v224;
  int8x16_t v225;
  float32x4_t v226;
  int8x16_t v227;
  int8x16_t v228;
  int8x16_t v229;
  float32x4_t v230;
  float32x4_t v231;
  int32x4_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  int8x16_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  float32x4_t v254;
  float32x4_t v255;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v179 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *(float32x4_t *)(v6 + v10 - 16);
      v12 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = (int8x16_t)vmulq_f32(v11, *(float32x4_t *)v13);
      v16 = (int8x16_t)vmulq_f32(v12, *(float32x4_t *)v13);
      v17 = *(int8x16_t *)(v13 + 32);
      v18 = *(int8x16_t *)(v13 + 48);
      v19 = (float32x4_t)vbslq_s8(v17, v15, (int8x16_t)vaddq_f32(*(float32x4_t *)v13, vmulq_n_f32(v14, *(float *)v15.i32)));
      v20 = (int8x8_t)vextq_s8(v18, v18, 8uLL).u64[0];
      v21 = (float32x4_t)vbslq_s8(v17, v16, (int8x16_t)vaddq_f32(*(float32x4_t *)v13, vmulq_n_f32(v14, *(float *)v16.i32)));
      *(int8x8_t *)v22.f32 = vqtbl1_s8((int8x16_t)v19, v20);
      v22.i64[1] = v22.i64[0];
      *(int8x8_t *)v23.f32 = vqtbl1_s8((int8x16_t)v21, v20);
      v23.i64[1] = v23.i64[0];
      v24 = *(float32x4_t *)(v13 + 64);
      v25 = *(int8x16_t *)(v13 + 80);
      v19.i64[1] = vaddq_f32(v24, vmulq_n_f32(v22, *(float *)&v19)).i64[1];
      v21.i64[1] = vaddq_f32(v24, vmulq_n_f32(v23, *(float *)&v21)).i64[1];
      v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)vrev64q_s32((int32x4_t)vsubq_f32(v24, v19)), (int8x16_t)v19);
      v27 = (float32x4_t)vbslq_s8(v25, (int8x16_t)vrev64q_s32((int32x4_t)vsubq_f32(v24, v21)), (int8x16_t)v21);
      v28 = vbslq_s8((int8x16_t)vcgtq_f32(v24, v26), vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL));
      v29 = vbslq_s8((int8x16_t)vcgtq_f32(v24, v27), vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL), vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL));
      v30 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v26, v28);
      v32 = *(float32x4_t *)(v13 + 96);
      v31 = *(float32x4_t *)(v13 + 112);
      v33 = (float32x4_t)vbslq_s8(v17, (int8x16_t)vmaxq_f32(v30, v32), v28);
      v34 = (float32x4_t)vbslq_s8(v17, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v27, v29), v32), v29);
      v35 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v33, v18), (int8x16_t)v14);
      v36 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v34, v18), (int8x16_t)v14);
      v38 = *(float32x4_t *)(v13 + 128);
      v37 = *(float32x4_t *)(v13 + 144);
      v39 = *(float32x4_t *)(v13 + 160);
      v40 = *(float32x4_t *)(v13 + 176);
      v41 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v35, v39));
      v42 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v36, v39));
      v43 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v33))), v37), v41);
      v44 = vsubq_f32(vsubq_f32(v35, v14), vmulq_f32(vmulq_f32(v40, v41), v35));
      v45 = vsubq_f32(vsubq_f32(v36, v14), vmulq_f32(vmulq_f32(v40, v42), v36));
      v46 = *(float32x4_t *)(v13 + 192);
      v47 = *(float32x4_t *)(v13 + 208);
      v48 = *(float32x4_t *)(v13 + 224);
      v49 = *(float32x4_t *)(v13 + 240);
      v50 = vmulq_lane_f32(vaddq_f32(v43, vmulq_f32(v44, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v44)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v46, vmulq_f32(v47, v44)))))), *(float32x2_t *)v33.f32, 1);
      v51 = vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v34))), v37), v42), vmulq_f32(v45, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v45)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v46, vmulq_f32(v47, v45)))))), *(float32x2_t *)v34.f32, 1);
      v53 = *(float32x4_t *)(v13 + 256);
      v52 = *(float32x4_t *)(v13 + 272);
      v54 = vmaxq_f32(v50, v53);
      v55 = vmaxq_f32(v51, v53);
      v56 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      v58 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v56, v54)));
      v59 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v57, v55)));
      v60 = vsubq_f32(v54, v58);
      v62 = *(float32x4_t *)(v13 + 288);
      v61 = *(float32x4_t *)(v13 + 304);
      v63 = vsubq_f32(v55, v59);
      v64 = vmulq_f32(v63, vaddq_f32(v61, vmulq_f32(v63, vaddq_f32(v52, vmulq_f32(v62, v63)))));
      v66 = *(int32x4_t *)(v13 + 320);
      v65 = *(float32x4_t *)(v13 + 336);
      v67 = vaddq_f32(v14, vmulq_f32(v60, vaddq_f32(v61, vmulq_f32(v60, vaddq_f32(v52, vmulq_f32(v62, v60))))));
      v68 = (float32x4_t)vrev64q_s32((int32x4_t)v11);
      v69 = (float32x4_t)vrev64q_s32((int32x4_t)v12);
      v70 = vaddq_f32(v14, v64);
      v71 = vminq_f32(vmaxq_f32(vmulq_f32(v61, vrecpeq_f32(v68)), v62), v65);
      v72 = (int8x16_t)vmulq_f32(v67, (float32x4_t)vshlq_n_s32(vaddq_s32(v66, vcvtq_s32_f32(v58)), 0x17uLL));
      v73 = vminq_f32(vmaxq_f32(vmulq_f32(v61, vrecpeq_f32(v69)), v62), v65);
      v74 = (int8x16_t)vmulq_f32(v70, (float32x4_t)vshlq_n_s32(vaddq_s32(v66, vcvtq_s32_f32(v59)), 0x17uLL));
      v76 = *(float32x4_t *)(v13 + 352);
      v75 = *(float32x4_t *)(v13 + 368);
      v77 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v17, v72, (int8x16_t)vmulq_f32(v76, (float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vmulq_n_f32(vmulq_f32(v71, vrecpsq_f32(v68, v71)), *(float *)v72.i32)))));
      v78 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v17, v74, (int8x16_t)vmulq_f32(v76, (float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vmulq_n_f32(vmulq_f32(v73, vrecpsq_f32(v69, v73)), *(float *)v74.i32)))));
      v79 = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtq_f32(v11, v32), (int8x16_t)v77, (int8x16_t)v76), (int8x16_t)v11);
      v80 = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtq_f32(v12, v32), (int8x16_t)v78, (int8x16_t)v76), (int8x16_t)v12);
      *(int8x8_t *)v11.f32 = vqtbl1_s8(v79, *(int8x8_t *)v75.f32);
      v32.i64[0] = vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL).u64[0];
      *(int8x8_t *)v75.f32 = vqtbl1_s8(v80, *(int8x8_t *)v75.f32);
      *(int8x8_t *)&v11.u32[2] = vqtbl1_s8(v79, *(int8x8_t *)v32.f32);
      *(int8x8_t *)&v75.u32[2] = vqtbl1_s8(v80, *(int8x8_t *)v32.f32);
      v81 = (int8x16_t)vmulq_n_f32(v11, *(float *)v79.i32);
      v83 = *(int8x16_t *)(v13 + 384);
      v82 = *(float32x4_t *)(v13 + 400);
      v84 = (float32x4_t)vbslq_s8(v83, v79, v81);
      v85 = (float32x4_t)vbslq_s8(v83, v80, (int8x16_t)vmulq_n_f32(v75, *(float *)v80.i32));
      v86 = (float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vaddq_f32(v77, vmulq_laneq_f32(v52, v84, 2))), v38)), v82));
      v87 = (float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vaddq_f32(v78, vmulq_laneq_f32(v52, v85, 2))), v38)), v82));
      v88 = (int32x4_t)vbslq_s8(v25, (int8x16_t)vmulq_f32(v53, v86), (int8x16_t)v84);
      v89 = (int32x4_t)vbslq_s8(v25, (int8x16_t)vmulq_f32(v53, v87), (int8x16_t)v85);
      v90 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v86), vmulq_n_f32(v49, *(float *)v88.i32));
      v91 = (float32x4_t)vrev64q_s32(v88);
      v92 = (float32x4_t)vrev64q_s32(v89);
      v93 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v91, v18), (int8x16_t)v76);
      v94 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v92, v18), (int8x16_t)v76);
      v95 = (float32x4_t)vbslq_s8(v17, v72, v90);
      v96 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v91));
      v97 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v92));
      v98 = (int32x4_t)vshrq_n_u32((uint32x4_t)v91, 0x17uLL);
      v99 = (int32x4_t)vshrq_n_u32((uint32x4_t)v92, 0x17uLL);
      v100 = vcvtq_f32_s32(v98);
      v101 = (float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v87), vmulq_n_f32(v49, *(float *)v89.i32)));
      v102 = vsubq_f32(vsubq_f32(vcvtq_f32_s32(v99), v97), v37);
      v103 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v93, v39));
      v104 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v94, v39));
      v105 = vaddq_f32(vsubq_f32(vsubq_f32(v100, v96), v37), v103);
      v106 = vsubq_f32(vsubq_f32(v93, v76), vmulq_f32(vmulq_f32(v40, v103), v93));
      v107 = vsubq_f32(vsubq_f32(v94, v76), vmulq_f32(vmulq_f32(v40, v104), v94));
      v108 = vmulq_f32(v107, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(v46, vmulq_f32(v47, v107)))));
      v109 = vaddq_f32(v105, vmulq_f32(v106, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v106)), vmulq_f32(vmulq_f32(v106, v106), vaddq_f32(v46, vmulq_f32(v47, v106))))));
      v110 = vaddq_f32(vaddq_f32(v102, v104), v108);
      v111 = *(float32x4_t *)(v13 + 416);
      v112 = *(float32x4_t *)(v13 + 432);
      v113 = vmaxq_f32(vmulq_f32(v111, v109), v53);
      v114 = vmaxq_f32(vmulq_f32(v111, v110), v53);
      v115 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
      v116 = vcvtq_f32_s32(vcvtq_s32_f32(v114));
      v117 = vsubq_f32(v115, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v115, v113)));
      v118 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v116, v114)));
      v119 = vsubq_f32(v113, v117);
      v120 = vsubq_f32(v114, v118);
      v121 = vcvtq_s32_f32(v117);
      *(int8x8_t *)v117.f32 = vqtbl1_s8((int8x16_t)v88, *(int8x8_t *)v112.f32);
      *(int8x8_t *)v112.f32 = vqtbl1_s8((int8x16_t)v89, *(int8x8_t *)v112.f32);
      v122 = *(float32x4_t *)(v13 + 448);
      v123 = *(float32x4_t *)(v13 + 464);
      v95.i64[0] = vaddq_f32(vmulq_f32(v117, v122), v95).u64[0];
      v101.i64[0] = vaddq_f32(vmulq_f32(v122, v112), v101).u64[0];
      v95.i64[1] = v88.i64[1];
      v101.i64[1] = v89.i64[1];
      v95.i64[0] = vminq_f32(v95, v123).u64[0];
      v124 = vmulq_f32(v62, v119);
      v101.i64[0] = vminq_f32(v101, v123).u64[0];
      v95.i64[1] = v88.i64[1];
      v101.i64[1] = v89.i64[1];
      v125 = vmulq_f32(v62, v120);
      v127 = *(float32x4_t *)(v13 + 480);
      v126 = *(float32x4_t *)(v13 + 496);
      v128 = vmaxq_f32(v95, v127);
      v129 = vmaxq_f32(v101, v127);
      v130 = (float32x4_t)vshlq_n_s32(vaddq_s32(v121, v66), 0x17uLL);
      v121.i64[0] = vmulq_f32(v128, v126).u64[0];
      v131 = (float32x4_t)vdupq_lane_s64(v121.i64[0], 0);
      v121.i64[1] = v88.i64[1];
      v132 = vaddq_f32(v52, v124);
      v129.i64[0] = vmulq_f32(v129, v126).u64[0];
      v133 = (float32x4_t)vdupq_lane_s64(v129.i64[0], 0);
      v129.i64[1] = v89.i64[1];
      v134 = vaddq_f32(v52, v125);
      v135 = (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v118), v66), 0x17uLL);
      v136 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, (int8x16_t)v131), (int8x16_t)v111);
      v137 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, (int8x16_t)v133), (int8x16_t)v111);
      v138 = (float32x4_t)vandq_s8((int8x16_t)v47, (int8x16_t)vcgtq_f32(v48, v131));
      v139 = (float32x4_t)vandq_s8((int8x16_t)v47, (int8x16_t)vcgtq_f32(v48, v133));
      v140 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v131, 0x17uLL)), v138), v46);
      v141 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v133, 0x17uLL)), v139), v46);
      v142 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v136, v40));
      v143 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v137, v40));
      v144 = vaddq_f32(v140, v142);
      v145 = vaddq_f32(v141, v143);
      v146 = vmulq_f32(v39, v142);
      v147 = vmulq_f32(v39, v143);
      v148 = vmulq_f32(v119, vaddq_f32(v61, vmulq_f32(v119, v132)));
      v149 = vsubq_f32(vsubq_f32(v136, v111), vmulq_f32(v146, v136));
      v150 = vsubq_f32(vsubq_f32(v137, v111), vmulq_f32(v147, v137));
      v151 = vaddq_f32(v37, vmulq_f32(v31, v149));
      v152 = vaddq_f32(v76, v148);
      v153 = vaddq_f32(v37, vmulq_f32(v31, v150));
      v154 = *(float32x4_t *)(v13 + 512);
      v155 = *(float32x4_t *)(v13 + 528);
      v156 = vaddq_f32(vaddq_f32(v154, vmulq_f32(v155, v150)), vmulq_f32(vmulq_f32(v150, v150), v153));
      v157 = vaddq_f32(v144, vmulq_f32(v149, vaddq_f32(vaddq_f32(v154, vmulq_f32(v155, v149)), vmulq_f32(vmulq_f32(v149, v149), v151))));
      v158 = vmulq_f32(v150, v156);
      v159 = (int8x16_t)vmulq_f32(vaddq_f32(v76, vmulq_f32(v120, vaddq_f32(v61, vmulq_f32(v120, v134)))), v135);
      v160 = vaddq_f32(v145, v158);
      v161 = *(float32x4_t *)(v13 + 544);
      v162 = *(float32x4_t *)(v13 + 560);
      v163 = vmaxq_f32(vmulq_f32(v161, v157), v162);
      v164 = vmaxq_f32(vmulq_f32(v161, v160), v162);
      v165 = vcvtq_f32_s32(vcvtq_s32_f32(v163));
      v166 = vcvtq_f32_s32(vcvtq_s32_f32(v164));
      v167 = vsubq_f32(v165, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v165, v163)));
      v168 = vsubq_f32(v166, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v166, v164)));
      v169 = vsubq_f32(v163, v167);
      v170 = vsubq_f32(v164, v168);
      v171 = *(float32x4_t *)(v13 + 576);
      v172 = *(float32x4_t *)(v13 + 592);
      v173 = vaddq_f32(v171, vmulq_f32(v172, v169));
      v174 = vaddq_f32(v171, vmulq_f32(v172, v170));
      v175 = vmulq_f32(v169, v173);
      v176 = *(float32x4_t *)(v13 + 608);
      v177 = *(int32x4_t *)(v13 + 624);
      v178 = (int8x16_t *)(v5 + v10);
      v178[-1] = vbslq_s8(v83, (int8x16_t)v121, vbslq_s8(v17, (int8x16_t)vmulq_f32(v152, v130), (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v169, vaddq_f32(v176, v175))), (float32x4_t)vshlq_n_s32(vaddq_s32(v177, vcvtq_s32_f32(v167)), 0x17uLL))));
      *v178 = vbslq_s8(v83, (int8x16_t)v129, vbslq_s8(v17, v159, (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v170, vaddq_f32(v176, vmulq_f32(v170, v174)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v177, vcvtq_s32_f32(v168)), 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v179 = -v9;
    if (v179 >= v4)
      goto LABEL_3;
LABEL_10:
    v180 = 16 * v179;
    v181 = *(float32x4_t *)(v6 + v180);
    v182 = *((_QWORD *)this + 51);
    v183 = *(float32x4_t *)(v182 + 16);
    v184 = (int8x16_t)vmulq_f32(v181, *(float32x4_t *)v182);
    v185 = *(int8x16_t *)(v182 + 32);
    v186 = *(int8x16_t *)(v182 + 48);
    v187 = (float32x4_t)vbslq_s8(v185, v184, (int8x16_t)vaddq_f32(*(float32x4_t *)v182, vmulq_n_f32(v183, *(float *)v184.i32)));
    *(int8x8_t *)v188.f32 = vqtbl1_s8((int8x16_t)v187, (int8x8_t)*(_OWORD *)&vextq_s8(v186, v186, 8uLL));
    v188.i64[1] = v188.i64[0];
    v189 = *(float32x4_t *)(v182 + 64);
    v190 = *(int8x16_t *)(v182 + 80);
    v187.i64[1] = vaddq_f32(v189, vmulq_n_f32(v188, *(float *)&v187)).i64[1];
    v191 = (float32x4_t)vbslq_s8(v190, (int8x16_t)vrev64q_s32((int32x4_t)vsubq_f32(v189, v187)), (int8x16_t)v187);
    v192 = vbslq_s8((int8x16_t)vcgtq_f32(v189, v191), vextq_s8((int8x16_t)v191, (int8x16_t)v191, 4uLL), vextq_s8((int8x16_t)v191, (int8x16_t)v191, 8uLL));
    v193 = (float32x4_t)vbslq_s8(v185, (int8x16_t)v191, v192);
    v195 = *(float32x4_t *)(v182 + 96);
    v194 = *(float32x4_t *)(v182 + 112);
    v196 = (float32x4_t)vbslq_s8(v185, (int8x16_t)vmaxq_f32(v193, v195), v192);
    v197 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v196, v186), (int8x16_t)v183);
    v199 = *(float32x4_t *)(v182 + 128);
    v198 = *(float32x4_t *)(v182 + 144);
    v200 = *(float32x4_t *)(v182 + 160);
    v201 = *(float32x4_t *)(v182 + 176);
    v202 = (float32x4_t)vandq_s8((int8x16_t)v183, (int8x16_t)vcgtq_f32(v197, v200));
    v203 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v196, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v199, (int8x16_t)vcgtq_f32(v194, v196))), v198), v202);
    v204 = vsubq_f32(vsubq_f32(v197, v183), vmulq_f32(vmulq_f32(v201, v202), v197));
    v205 = *(float32x4_t *)(v182 + 192);
    v206 = *(float32x4_t *)(v182 + 208);
    v207 = *(float32x4_t *)(v182 + 224);
    v208 = *(float32x4_t *)(v182 + 240);
    v209 = vmulq_lane_f32(vaddq_f32(v203, vmulq_f32(v204, vaddq_f32(vaddq_f32(v207, vmulq_f32(v208, v204)), vmulq_f32(vmulq_f32(v204, v204), vaddq_f32(v205, vmulq_f32(v206, v204)))))), *(float32x2_t *)v196.f32, 1);
    v210 = *(float32x4_t *)(v182 + 256);
    v211 = *(float32x4_t *)(v182 + 272);
    v212 = vmaxq_f32(v209, v210);
    v213 = vcvtq_f32_s32(vcvtq_s32_f32(v212));
    v214 = vsubq_f32(v213, (float32x4_t)vandq_s8((int8x16_t)v183, (int8x16_t)vcgtq_f32(v213, v212)));
    v215 = vsubq_f32(v212, v214);
    v216 = *(float32x4_t *)(v182 + 288);
    v217 = *(float32x4_t *)(v182 + 304);
    v218 = vaddq_f32(v183, vmulq_f32(v215, vaddq_f32(v217, vmulq_f32(v215, vaddq_f32(v211, vmulq_f32(v216, v215))))));
    v219 = *(int32x4_t *)(v182 + 320);
    v220 = (int8x16_t)vmulq_f32(v218, (float32x4_t)vshlq_n_s32(vaddq_s32(v219, vcvtq_s32_f32(v214)), 0x17uLL));
    v221 = (float32x4_t)vrev64q_s32((int32x4_t)v181);
    v222 = vminq_f32(vmaxq_f32(vmulq_f32(v217, vrecpeq_f32(v221)), v216), *(float32x4_t *)(v182 + 336));
    v223 = (float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vmulq_n_f32(vmulq_f32(v222, vrecpsq_f32(v221, v222)), *(float *)v220.i32));
    v224 = *(float32x4_t *)(v182 + 352);
    v225 = *(int8x16_t *)(v182 + 368);
    v226 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v185, v220, (int8x16_t)vmulq_f32(v224, v223)));
    v227 = vbslq_s8(v185, vbslq_s8((int8x16_t)vcgtq_f32(v181, v195), (int8x16_t)v226, (int8x16_t)v224), (int8x16_t)v181);
    *(int8x8_t *)v181.f32 = vqtbl1_s8(v227, *(int8x8_t *)v225.i8);
    *(int8x8_t *)&v181.u32[2] = vqtbl1_s8(v227, (int8x8_t)*(_OWORD *)&vextq_s8(v225, v225, 8uLL));
    v228 = (int8x16_t)vmulq_n_f32(v181, *(float *)v227.i32);
    v229 = *(int8x16_t *)(v182 + 384);
    v230 = (float32x4_t)vbslq_s8(v229, v227, v228);
    v231 = (float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vaddq_f32(v226, vmulq_laneq_f32(v211, v230, 2))), v199)), *(float32x4_t *)(v182 + 400)));
    v232 = (int32x4_t)vbslq_s8(v190, (int8x16_t)vmulq_f32(v210, v231), (int8x16_t)v230);
    v233 = (float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v231), vmulq_n_f32(v208, *(float *)v232.i32)));
    v234 = (float32x4_t)vrev64q_s32(v232);
    v235 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v234, v186), (int8x16_t)v224);
    v236 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v234, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v199, (int8x16_t)vcgtq_f32(v194, v234))), v198);
    v237 = (float32x4_t)vandq_s8((int8x16_t)v224, (int8x16_t)vcgtq_f32(v235, v200));
    v238 = vsubq_f32(vsubq_f32(v235, v224), vmulq_f32(vmulq_f32(v201, v237), v235));
    v239 = vaddq_f32(vaddq_f32(v236, v237), vmulq_f32(v238, vaddq_f32(vaddq_f32(v207, vmulq_f32(v208, v238)), vmulq_f32(vmulq_f32(v238, v238), vaddq_f32(v205, vmulq_f32(v206, v238))))));
    v240 = *(float32x4_t *)(v182 + 416);
    v241 = vmaxq_f32(vmulq_f32(v240, v239), v210);
    v242 = vcvtq_f32_s32(vcvtq_s32_f32(v241));
    v243 = vsubq_f32(v242, (float32x4_t)vandq_s8((int8x16_t)v224, (int8x16_t)vcgtq_f32(v242, v241)));
    v244 = vsubq_f32(v241, v243);
    v245 = vmulq_f32(v216, v244);
    v246 = vaddq_f32(v224, vmulq_f32(v244, vaddq_f32(v217, vmulq_f32(v244, vaddq_f32(v211, v245)))));
    *(int8x8_t *)v245.f32 = vqtbl1_s8((int8x16_t)v232, *(int8x8_t *)(v182 + 432));
    v245.i64[0] = vaddq_f32(vmulq_f32(*(float32x4_t *)(v182 + 448), v245), v233).u64[0];
    v245.i64[1] = v232.i64[1];
    v247 = (int8x16_t)vmulq_f32(v246, (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v243), v219), 0x17uLL));
    v211.i64[0] = vminq_f32(v245, *(float32x4_t *)(v182 + 464)).u64[0];
    v211.i64[1] = v232.i64[1];
    v211.i64[0] = vmulq_f32(vmaxq_f32(v211, *(float32x4_t *)(v182 + 480)), *(float32x4_t *)(v182 + 496)).u64[0];
    v248 = (float32x4_t)vdupq_lane_s64(v211.i64[0], 0);
    v211.i64[1] = v232.i64[1];
    v249 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v219, (int8x16_t)v248), (int8x16_t)v240);
    v250 = (float32x4_t)vandq_s8((int8x16_t)v240, (int8x16_t)vcgtq_f32(v249, v201));
    v251 = vsubq_f32(vsubq_f32(v249, v240), vmulq_f32(vmulq_f32(v200, v250), v249));
    v252 = vmaxq_f32(vmulq_f32(*(float32x4_t *)(v182 + 544), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v248, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v206, (int8x16_t)vcgtq_f32(v207, v248))), v205), v250), vmulq_f32(v251, vaddq_f32(vaddq_f32(*(float32x4_t *)(v182 + 512), vmulq_f32(*(float32x4_t *)(v182 + 528), v251)), vmulq_f32(vmulq_f32(v251, v251), vaddq_f32(v198, vmulq_f32(v194, v251))))))), *(float32x4_t *)(v182 + 560));
    v253 = vcvtq_f32_s32(vcvtq_s32_f32(v252));
    v254 = vsubq_f32(v253, (float32x4_t)vandq_s8((int8x16_t)v240, (int8x16_t)vcgtq_f32(v253, v252)));
    v255 = vsubq_f32(v252, v254);
    *(int8x16_t *)(v5 + v180) = vbslq_s8(v229, (int8x16_t)v211, vbslq_s8(v185, v247, (int8x16_t)vmulq_f32(vaddq_f32(v240, vmulq_f32(v255, vaddq_f32(*(float32x4_t *)(v182 + 608), vmulq_f32(v255, vaddq_f32(*(float32x4_t *)(v182 + 576), vmulq_f32(*(float32x4_t *)(v182 + 592), v255)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(
                                                                  *(int32x4_t *)(v182 + 624),
                                                                  vcvtq_s32_f32(v254)),
                                                                0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2446_Method_A_ITMO::GetDOD(HgcBT2446_Method_A_ITMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2446_Method_A_ITMO::GetROI(HgcBT2446_Method_A_ITMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2446_Method_A_ITMO::HgcBT2446_Method_A_ITMO(HgcBT2446_Method_A_ITMO *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6540D70;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B35535E0;
  *(_OWORD *)(v3 + 16) = xmmword_1B35535F0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 48) = xmmword_1B3553600;
  *(_OWORD *)(v3 + 64) = xmmword_1B3553610;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 96) = xmmword_1B3052AF0;
  *(_OWORD *)(v3 + 112) = xmmword_1B3553620;
  *(_OWORD *)(v3 + 128) = xmmword_1B3553630;
  *(_OWORD *)(v3 + 144) = xmmword_1B3553640;
  *(_OWORD *)(v3 + 160) = xmmword_1B3553650;
  *(_OWORD *)(v3 + 176) = xmmword_1B3553660;
  *(_OWORD *)(v3 + 192) = xmmword_1B3553670;
  *(_OWORD *)(v3 + 208) = xmmword_1B3553680;
  *(_OWORD *)(v3 + 224) = xmmword_1B3553690;
  *(_OWORD *)(v3 + 240) = xmmword_1B35536A0;
  *(_OWORD *)(v3 + 256) = xmmword_1B35536B0;
  *(_OWORD *)(v3 + 272) = xmmword_1B35536C0;
  *(_OWORD *)(v3 + 288) = xmmword_1B35536D0;
  *(_OWORD *)(v3 + 304) = xmmword_1B35536E0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35536F0;
  *(int32x4_t *)(v3 + 336) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 352) = xmmword_1B3553700;
  *(_OWORD *)(v3 + 368) = xmmword_1B3553710;
  *(_OWORD *)(v3 + 384) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 400) = xmmword_1B3052AD0;
  *(_OWORD *)(v3 + 416) = xmmword_1B3553720;
  *(_OWORD *)(v3 + 432) = xmmword_1B30510C0;
  *(_OWORD *)(v3 + 448) = xmmword_1B3553730;
  *(_OWORD *)(v3 + 464) = xmmword_1B3553740;
  *(_OWORD *)(v3 + 480) = xmmword_1B30536D0;
  *(_OWORD *)(v3 + 496) = xmmword_1B3553750;
  *(_OWORD *)(v3 + 512) = xmmword_1B3553760;
  *(_OWORD *)(v3 + 528) = xmmword_1B3553770;
  *(_OWORD *)(v3 + 544) = xmmword_1B3553780;
  *(_OWORD *)(v3 + 560) = xmmword_1B3553790;
  *(_OWORD *)(v3 + 576) = xmmword_1B35537A0;
  *(_OWORD *)(v3 + 592) = xmmword_1B35537B0;
  *(_OWORD *)(v3 + 608) = xmmword_1B35537C0;
  *(_OWORD *)(v3 + 624) = xmmword_1B35537D0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BC1D00(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2446_Method_A_ITMO::~HgcBT2446_Method_A_ITMO(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6540D70;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B6D25C9CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6540D70;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40B6D25C9CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2446_Method_A_ITMO::SetParameter(HgcBT2446_Method_A_ITMO *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2446_Method_A_ITMO::GetParameter(HgcBT2446_Method_A_ITMO *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBT2390_Gain_Sat_ToneAdj::GetProgram(HgcBT2390_Gain_Sat_ToneAdj *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000482\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
             "    const half4 c1 = half4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r1.xyz = r0.xyz*c0.yyy;\n"
             "    r0.xy = pow(r1.xy, c0.zz);\n"
             "    r0.z = r0.y*c0.w;\n"
             "    r1.w = r0.x*c1.w + r0.z;\n"
             "    r1.y = r1.y*c0.w;\n"
             "    r1.x = r1.x*c1.w + r1.y;\n"
             "    r0.z = pow(r1.z, c0.z);\n"
             "    r1.w = r0.z*c1.x + r1.w;\n"
             "    r1.x = r1.z*c1.x + r1.x;\n"
             "    r1.x = r1.x/r1.w;\n"
             "    r1.x = select(c1.y, r1.x, -r1.w < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r1.xxx;\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(c1.zzz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c4ba51af:835a3309:a06f8f2a:0fe182e4\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
             "    const float4 c1 = float4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r1.xyz = r0.xyz*c0.yyy;\n"
             "    r0.xy = pow(r1.xy, c0.zz);\n"
             "    r0.z = r0.y*c0.w;\n"
             "    r1.w = r0.x*c1.w + r0.z;\n"
             "    r1.y = r1.y*c0.w;\n"
             "    r1.x = r1.x*c1.w + r1.y;\n"
             "    r0.z = pow(r1.z, c0.z);\n"
             "    r1.w = r0.z*c1.x + r1.w;\n"
             "    r1.x = r1.z*c1.x + r1.x;\n"
             "    r1.x = r1.x/r1.w;\n"
             "    r1.x = select(c1.y, r1.x, -r1.w < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r1.xxx;\n"
             "    output.color0.xyz = r0.xyz*c1.zzz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2c714e19:97ce859d:2d1a1eb0:61cf40b1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000409\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
           "    const mediump vec4 c1 = vec4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = max(r0, c0.xxxx);\n"
           "    r1.xyz = r0.xyz*c0.yyy;\n"
           "    r0.xy = pow(r1.xy, c0.zz);\n"
           "    r0.z = r0.y*c0.w;\n"
           "    r1.w = r0.x*c1.w + r0.z;\n"
           "    r1.y = r1.y*c0.w;\n"
           "    r1.x = r1.x*c1.w + r1.y;\n"
           "    r0.z = pow(r1.z, c0.z);\n"
           "    r1.w = r0.z*c1.x + r1.w;\n"
           "    r1.x = r1.z*c1.x + r1.x;\n"
           "    r1.x = r1.x/r1.w;\n"
           "    r1.x = -r1.w < 0.00000 ? r1.x : c1.y;\n"
           "    r0.xyz = r0.xyz*r1.xxx;\n"
           "    gl_FragColor.xyz = r0.xyz*c1.zzz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=2b807689:01e4ee76:eadbe047:2c27b0e4\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2390_Gain_Sat_ToneAdj::InitProgramDescriptor(HgcBT2390_Gain_Sat_ToneAdj *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2390_Gain_Sat_ToneAdj_hgc_visible", "//Metal1.0     \n//LEN=000000034d\n[[ visible ]] FragmentOut HgcBT2390_Gain_Sat_ToneAdj_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
    "    const float4 c1 = float4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmax(r0, c0.xxxx);\n"
    "    r1.xyz = r0.xyz*c0.yyy;\n"
    "    r0.xy = pow(r1.xy, c0.zz);\n"
    "    r0.z = r0.y*c0.w;\n"
    "    r1.w = r0.x*c1.w + r0.z;\n"
    "    r1.y = r1.y*c0.w;\n"
    "    r1.x = r1.x*c1.w + r1.y;\n"
    "    r0.z = pow(r1.z, c0.z);\n"
    "    r1.w = r0.z*c1.x + r1.w;\n"
    "    r1.x = r1.z*c1.x + r1.x;\n"
    "    r1.x = r1.x/r1.w;\n"
    "    r1.x = select(c1.y, r1.x, -r1.w < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r1.xxx;\n"
    "    output.color0.xyz = r0.xyz*c1.zzz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC205C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC208C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC2084);
}

char *HgcBT2390_Gain_Sat_ToneAdj::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D20;
  strcpy(result, "HgcBT2390_Gain_Sat_ToneAdj [hgc1]");
  return result;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::BindTexture(HgcBT2390_Gain_Sat_ToneAdj *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::Bind(HgcBT2390_Gain_Sat_ToneAdj *this, HGHandler *a2)
{
  (*(void (**)(HgcBT2390_Gain_Sat_ToneAdj *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::RenderTile(HgcBT2390_Gain_Sat_ToneAdj *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int32x4_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  int8x16_t v111;
  int8x16_t v112;
  float32x4_t v113;
  float32x4_t v114;
  int8x16_t v115;
  int8x16_t *v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  float32x4_t v120;
  float32x4_t v121;
  int32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int32x4_t v147;
  int8x16_t v148;
  int8x16_t v149;
  float32x4_t v150;
  int8x16_t v151;
  int32x4_t v152;
  float32x4_t v153;
  int8x16_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  int8x16_t v171;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v117 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v11 = *((_QWORD *)this + 51);
      v12 = *(float32x4_t *)(v11 + 16);
      v13 = vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), *(float32x4_t *)v11);
      v14 = vmaxq_f32(*(float32x4_t *)(v6 + v10), *(float32x4_t *)v11);
      v15 = vmulq_f32(v13, v12);
      v16 = vmulq_f32(v14, v12);
      v17 = *(int32x4_t *)(v11 + 32);
      v18 = *(float32x4_t *)(v11 + 48);
      v19 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, (int8x16_t)v15), (int8x16_t)v18);
      v20 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, (int8x16_t)v16), (int8x16_t)v18);
      v21 = *(float32x4_t *)(v11 + 64);
      v22 = *(float32x4_t *)(v11 + 80);
      v23 = *(float32x4_t *)(v11 + 96);
      v24 = *(float32x4_t *)(v11 + 112);
      v25 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v19, v24));
      v26 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v24));
      v27 = *(float32x4_t *)(v11 + 128);
      v28 = *(float32x4_t *)(v11 + 144);
      v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v21, v16))), v23), v26);
      v30 = vsubq_f32(vsubq_f32(v19, v18), vmulq_f32(vmulq_f32(v27, v25), v19));
      v31 = vsubq_f32(vsubq_f32(v20, v18), vmulq_f32(vmulq_f32(v27, v26), v20));
      v32 = *(float32x4_t *)(v11 + 160);
      v33 = *(float32x4_t *)(v11 + 176);
      v34 = *(float32x4_t *)(v11 + 192);
      v35 = *(float32x4_t *)(v11 + 208);
      v36 = vmulq_f32(v35, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v21, v15))), v23), v25), vmulq_f32(v30, vaddq_f32(vaddq_f32(v33, vmulq_f32(v30, v34)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(v28, vmulq_f32(v32, v30)))))));
      v37 = *(float32x4_t *)(v11 + 224);
      v38 = *(float32x4_t *)(v11 + 240);
      v39 = vmaxq_f32(v36, v37);
      v40 = vmaxq_f32(vmulq_f32(v35, vaddq_f32(v29, vmulq_f32(v31, vaddq_f32(vaddq_f32(v33, vmulq_f32(v31, v34)), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(v28, vmulq_f32(v32, v31))))))), v37);
      v41 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      v42 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      v43 = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v41, v39)));
      v44 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v42, v40)));
      v45 = vsubq_f32(v39, v43);
      v46 = vsubq_f32(v40, v44);
      v48 = *(float32x4_t *)(v11 + 256);
      v47 = *(float32x4_t *)(v11 + 272);
      v49 = vmulq_f32(v46, vaddq_f32(v47, vmulq_f32(v46, vaddq_f32(v38, vmulq_f32(v48, v46)))));
      v50 = *(int32x4_t *)(v11 + 288);
      v51 = *(int8x16_t *)(v11 + 304);
      v52 = (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v45, vaddq_f32(v47, vmulq_f32(v45, vaddq_f32(v38, vmulq_f32(v48, v45)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v50, vcvtq_s32_f32(v43)), 0x17uLL));
      v53 = (int8x16_t)vmulq_f32(vaddq_f32(v18, v49), (float32x4_t)vshlq_n_s32(vaddq_s32(v50, vcvtq_s32_f32(v44)), 0x17uLL));
      v49.i64[0] = vextq_s8((int8x16_t)v13, v52, 0xCuLL).u64[0];
      v52.i64[1] = v13.i64[1];
      v54.i64[0] = vextq_s8((int8x16_t)v14, v53, 0xCuLL).u64[0];
      v53.i64[1] = v14.i64[1];
      *(int8x8_t *)&v49.u32[2] = vext_s8(*(int8x8_t *)v52.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), 4uLL);
      *(int8x8_t *)&v54.u32[2] = vext_s8(*(int8x8_t *)v53.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), 4uLL);
      v55 = (int32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(v47, v49), v52);
      v56 = (int32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(v47, v54), v53);
      v57 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v55), vmulq_n_f32(v47, *(float *)v55.i32));
      v58 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v56), vmulq_n_f32(v47, *(float *)v56.i32));
      v59 = *(int8x16_t *)(v11 + 320);
      v60 = *(float32x4_t *)(v11 + 336);
      v61 = (float32x4_t)vbslq_s8(v59, v57, (int8x16_t)v15);
      v62 = (float32x4_t)vbslq_s8(v59, v58, (int8x16_t)v16);
      v63 = *(int8x16_t *)(v11 + 352);
      v64 = *(float32x4_t *)(v11 + 368);
      v65 = (float32x4_t)vbslq_s8(v63, (int8x16_t)vmulq_f32(v60, v61), (int8x16_t)v61);
      v66 = (float32x4_t)vbslq_s8(v63, (int8x16_t)vmulq_f32(v60, v62), (int8x16_t)v62);
      v62.i64[0] = vaddq_f32(vmulq_f32(v64, v65), (float32x4_t)vrev64q_s32((int32x4_t)v65)).u64[0];
      v61.i64[0] = vaddq_f32(vmulq_f32(v64, v66), (float32x4_t)vrev64q_s32((int32x4_t)v66)).u64[0];
      v62.i64[1] = v65.i64[1];
      v61.i64[1] = v66.i64[1];
      v67 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v50, (int8x16_t)v62), (int8x16_t)v64);
      v68 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v50, (int8x16_t)v61), (int8x16_t)v64);
      v69 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v48, v62));
      v70 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v48, v61));
      v71 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v62, 0x17uLL)), v69), v37);
      v72 = (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v67, v35));
      v73 = (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v68, v35));
      v74 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v61, 0x17uLL)), v70), v37);
      v75 = vaddq_f32(v71, v72);
      v76 = vsubq_f32(vsubq_f32(v67, v64), vmulq_f32(vmulq_f32(v34, v72), v67));
      v77 = vsubq_f32(vsubq_f32(v68, v64), vmulq_f32(vmulq_f32(v34, v73), v68));
      v78 = vaddq_f32(v33, vmulq_f32(v32, v76));
      v79 = vaddq_f32(v33, vmulq_f32(v32, v77));
      v80 = vmulq_f32(v27, v76);
      v81 = vaddq_f32(v28, vmulq_f32(v27, v77));
      v82 = vmulq_f32(v24, vaddq_f32(v75, vmulq_f32(v76, vaddq_f32(vaddq_f32(v28, v80), vmulq_f32(vmulq_f32(v76, v76), v78)))));
      v83 = vmulq_f32(v24, vaddq_f32(vaddq_f32(v74, v73), vmulq_f32(v77, vaddq_f32(v81, vmulq_f32(vmulq_f32(v77, v77), v79)))));
      v84 = vmaxq_f32(v82, v23);
      v85 = vmaxq_f32(v83, v23);
      v86 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
      v87 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
      v88 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v86, v84)));
      v89 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v87, v85)));
      v90 = vsubq_f32(v84, v88);
      v91 = vsubq_f32(v85, v89);
      v92 = vaddq_f32(v22, vmulq_f32(v21, v90));
      v93 = vaddq_f32(v22, vmulq_f32(v21, v91));
      v94 = vaddq_f32(v18, vmulq_f32(v90, v92));
      v95 = vaddq_f32(v18, vmulq_f32(v91, v93));
      v96 = vaddq_f32(v64, vmulq_f32(v90, v94));
      v97 = vaddq_s32(vcvtq_s32_f32(v88), v17);
      v98 = (int8x16_t)vmulq_f32(vaddq_f32(v64, vmulq_f32(v91, v95)), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v89), v17), 0x17uLL));
      v99 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(v96, (float32x4_t)vshlq_n_s32(v97, 0x17uLL)), v52);
      v100 = (float32x4_t)vbslq_s8(v51, v98, v53);
      v101 = (float32x4_t)vbslq_s8(v59, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v64, v99, 2), v62), (int8x16_t)v62);
      v102 = (float32x4_t)vbslq_s8(v59, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v64, v100, 2), v61), (int8x16_t)v61);
      v91.i64[0] = vextq_s8((int8x16_t)v101, (int8x16_t)v101, 8uLL).u64[0];
      v103 = *(float32x4_t *)(v11 + 384);
      v104 = *(float32x4_t *)(v11 + 400);
      v64.i64[0] = vextq_s8((int8x16_t)v102, (int8x16_t)v102, 8uLL).u64[0];
      v105 = vaddq_f32(vmulq_laneq_f32(v103, v101, 2), v101);
      v106 = vaddq_f32(vmulq_laneq_f32(v103, v102, 2), v102);
      *(int8x8_t *)v89.f32 = vext_s8(*(int8x8_t *)v91.f32, *(int8x8_t *)v105.f32, 4uLL);
      *(int8x8_t *)&v89.u32[2] = vext_s8(*(int8x8_t *)v105.f32, *(int8x8_t *)v91.f32, 4uLL);
      *(int8x8_t *)v62.f32 = vext_s8(*(int8x8_t *)v64.f32, *(int8x8_t *)v106.f32, 4uLL);
      *(int8x8_t *)&v62.u32[2] = vext_s8(*(int8x8_t *)v106.f32, *(int8x8_t *)v64.f32, 4uLL);
      v107 = *(float32x4_t *)(v11 + 416);
      v108 = *(float32x4_t *)(v11 + 432);
      v109 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v89), v104), v107), v108);
      v110 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v62), v104), v107), v108);
      v111 = (int8x16_t)vmulq_f32(vmulq_f32(v109, vrecpsq_f32(v89, v109)), v105);
      v112 = (int8x16_t)vmulq_f32(vmulq_f32(v110, vrecpsq_f32(v62, v110)), v106);
      *(int8x8_t *)v109.f32 = vext_s8(*(int8x8_t *)v111.i8, *(int8x8_t *)v91.f32, 4uLL);
      *(int8x8_t *)v91.f32 = vext_s8(*(int8x8_t *)v91.f32, *(int8x8_t *)v111.i8, 4uLL);
      v91.i64[1] = v109.i64[0];
      *(int8x8_t *)v110.f32 = vext_s8(*(int8x8_t *)v64.f32, *(int8x8_t *)v112.i8, 4uLL);
      *(int8x8_t *)&v110.u32[2] = vext_s8(*(int8x8_t *)v112.i8, *(int8x8_t *)v64.f32, 4uLL);
      v113 = (float32x4_t)vbslq_s8(v59, (int8x16_t)v100, (int8x16_t)vmulq_n_f32(v100, *(float *)vbslq_s8((int8x16_t)vcgtq_f32(v110, *(float32x4_t *)v11), v112, (int8x16_t)v60).i32));
      v114 = *(float32x4_t *)(v11 + 448);
      v115 = vbslq_s8(v59, (int8x16_t)v99, (int8x16_t)vmulq_f32(v114, (float32x4_t)vbslq_s8(v59, (int8x16_t)v99, (int8x16_t)vmulq_n_f32(v99, *(float *)vbslq_s8((int8x16_t)vcgtq_f32(v91, *(float32x4_t *)v11), v111, (int8x16_t)v60).i32))));
      v116 = (int8x16_t *)(v5 + v10);
      v116[-1] = v115;
      *v116 = vbslq_s8(v59, (int8x16_t)v100, (int8x16_t)vmulq_f32(v114, v113));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v117 = -v9;
    if (v117 >= v4)
      goto LABEL_3;
LABEL_10:
    v118 = 16 * v117;
    v119 = *((_QWORD *)this + 51);
    v120 = vmaxq_f32(*(float32x4_t *)(v6 + v118), *(float32x4_t *)v119);
    v121 = vmulq_f32(v120, *(float32x4_t *)(v119 + 16));
    v122 = *(int32x4_t *)(v119 + 32);
    v123 = *(float32x4_t *)(v119 + 48);
    v124 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v122, (int8x16_t)v121), (int8x16_t)v123);
    v125 = *(float32x4_t *)(v119 + 64);
    v126 = *(float32x4_t *)(v119 + 80);
    v127 = *(float32x4_t *)(v119 + 96);
    v128 = *(float32x4_t *)(v119 + 112);
    v129 = (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v124, v128));
    v130 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v126, (int8x16_t)vcgtq_f32(v125, v121))), v127), v129);
    v131 = *(float32x4_t *)(v119 + 128);
    v132 = *(float32x4_t *)(v119 + 144);
    v133 = vsubq_f32(vsubq_f32(v124, v123), vmulq_f32(vmulq_f32(v131, v129), v124));
    v134 = *(float32x4_t *)(v119 + 160);
    v135 = *(float32x4_t *)(v119 + 176);
    v136 = *(float32x4_t *)(v119 + 192);
    v137 = *(float32x4_t *)(v119 + 208);
    v138 = vmulq_f32(v137, vaddq_f32(v130, vmulq_f32(v133, vaddq_f32(vaddq_f32(v135, vmulq_f32(v133, v136)), vmulq_f32(vmulq_f32(v133, v133), vaddq_f32(v132, vmulq_f32(v134, v133)))))));
    v139 = *(float32x4_t *)(v119 + 224);
    v140 = *(float32x4_t *)(v119 + 240);
    v141 = vmaxq_f32(v138, v139);
    v142 = vcvtq_f32_s32(vcvtq_s32_f32(v141));
    v143 = vsubq_f32(v142, (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v142, v141)));
    v144 = vsubq_f32(v141, v143);
    v145 = *(float32x4_t *)(v119 + 256);
    v146 = *(float32x4_t *)(v119 + 272);
    v147 = *(int32x4_t *)(v119 + 288);
    v148 = *(int8x16_t *)(v119 + 304);
    v149 = (int8x16_t)vmulq_f32(vaddq_f32(v123, vmulq_f32(v144, vaddq_f32(v146, vmulq_f32(v144, vaddq_f32(v140, vmulq_f32(v145, v144)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v147, vcvtq_s32_f32(v143)), 0x17uLL));
    v150.i64[0] = vextq_s8((int8x16_t)v120, v149, 0xCuLL).u64[0];
    v151.i64[0] = v149.i64[0];
    v151.i64[1] = v120.i64[1];
    *(int8x8_t *)&v150.u32[2] = vext_s8(*(int8x8_t *)v149.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v120, (int8x16_t)v120, 8uLL), 4uLL);
    v152 = (int32x4_t)vbslq_s8(v148, (int8x16_t)vmulq_f32(v146, v150), v151);
    v153 = vaddq_f32((float32x4_t)vrev64q_s32(v152), vmulq_n_f32(v146, *(float *)v152.i32));
    v154 = *(int8x16_t *)(v119 + 320);
    v155 = *(float32x4_t *)(v119 + 336);
    v156 = (float32x4_t)vbslq_s8(v154, (int8x16_t)v153, (int8x16_t)v121);
    v157 = *(float32x4_t *)(v119 + 368);
    v158 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v119 + 352), (int8x16_t)vmulq_f32(v155, v156), (int8x16_t)v156);
    v153.i64[0] = vaddq_f32(vmulq_f32(v157, v158), (float32x4_t)vrev64q_s32((int32x4_t)v158)).u64[0];
    v153.i64[1] = v158.i64[1];
    v159 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v147, (int8x16_t)v153), (int8x16_t)v157);
    v160 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v153, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v140, (int8x16_t)vcgtq_f32(v145, v153))), v139);
    v161 = (float32x4_t)vandq_s8((int8x16_t)v157, (int8x16_t)vcgtq_f32(v159, v137));
    v162 = vsubq_f32(vsubq_f32(v159, v157), vmulq_f32(vmulq_f32(v136, v161), v159));
    v163 = vmaxq_f32(vmulq_f32(v128, vaddq_f32(vaddq_f32(v160, v161), vmulq_f32(v162, vaddq_f32(vaddq_f32(v132, vmulq_f32(v131, v162)), vmulq_f32(vmulq_f32(v162, v162), vaddq_f32(v135, vmulq_f32(v134, v162))))))), v127);
    v164 = vcvtq_f32_s32(vcvtq_s32_f32(v163));
    v165 = vsubq_f32(v164, (float32x4_t)vandq_s8((int8x16_t)v157, (int8x16_t)vcgtq_f32(v164, v163)));
    v166 = vsubq_f32(v163, v165);
    v167 = (float32x4_t)vbslq_s8(v148, (int8x16_t)vmulq_f32(vaddq_f32(v157, vmulq_f32(v166, vaddq_f32(v123, vmulq_f32(v166, vaddq_f32(v126, vmulq_f32(v125, v166)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v165), v122), 0x17uLL)), v151);
    v168 = (float32x4_t)vbslq_s8(v154, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v157, v167, 2), v153), (int8x16_t)v153);
    v125.i64[0] = vextq_s8((int8x16_t)v168, (int8x16_t)v168, 8uLL).u64[0];
    v169 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v119 + 384), v168, 2), v168);
    *(int8x8_t *)v165.f32 = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v169.f32, 4uLL);
    *(int8x8_t *)&v165.u32[2] = vext_s8(*(int8x8_t *)v169.f32, *(int8x8_t *)v125.f32, 4uLL);
    v170 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v165), *(float32x4_t *)(v119 + 400)), *(float32x4_t *)(v119 + 416)), *(float32x4_t *)(v119 + 432));
    v171 = (int8x16_t)vmulq_f32(vmulq_f32(v170, vrecpsq_f32(v165, v170)), v169);
    *(int8x8_t *)v170.f32 = vext_s8(*(int8x8_t *)v171.i8, *(int8x8_t *)v125.f32, 4uLL);
    *(int8x8_t *)v125.f32 = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v171.i8, 4uLL);
    v125.i64[1] = v170.i64[0];
    *(int8x16_t *)(v5 + v118) = vbslq_s8(v154, (int8x16_t)v167, (int8x16_t)vmulq_f32(*(float32x4_t *)(v119 + 448), (float32x4_t)vbslq_s8(v154, (int8x16_t)v167, (int8x16_t)vmulq_n_f32(v167, *(float *)vbslq_s8((int8x16_t)vcgtq_f32(v125, *(float32x4_t *)v119), v171, (int8x16_t)v155).i32))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::GetDOD(HgcBT2390_Gain_Sat_ToneAdj *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::GetROI(HgcBT2390_Gain_Sat_ToneAdj *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcBT2390_Gain_Sat_ToneAdj::HgcBT2390_Gain_Sat_ToneAdj(HgcBT2390_Gain_Sat_ToneAdj *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6540FD8;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B3553800;
  *(_OWORD *)(v3 + 32) = xmmword_1B3553810;
  *(_OWORD *)(v3 + 48) = xmmword_1B3553820;
  *(_OWORD *)(v3 + 64) = xmmword_1B3553830;
  *(_OWORD *)(v3 + 80) = xmmword_1B3553840;
  *(_OWORD *)(v3 + 96) = xmmword_1B3553850;
  *(_OWORD *)(v3 + 112) = xmmword_1B3553860;
  *(_OWORD *)(v3 + 128) = xmmword_1B3553870;
  *(_OWORD *)(v3 + 144) = xmmword_1B3553880;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 176) = xmmword_1B3553890;
  *(_OWORD *)(v3 + 192) = xmmword_1B35538A0;
  *(_OWORD *)(v3 + 208) = xmmword_1B35538B0;
  *(_OWORD *)(v3 + 224) = xmmword_1B35538C0;
  *(_OWORD *)(v3 + 240) = xmmword_1B35538D0;
  *(_OWORD *)(v3 + 256) = xmmword_1B35538E0;
  *(_OWORD *)(v3 + 272) = xmmword_1B35538F0;
  *(_OWORD *)(v3 + 288) = xmmword_1B3553900;
  *(_OWORD *)(v3 + 304) = xmmword_1B3050FE0;
  *(_OWORD *)(v3 + 320) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 336) = xmmword_1B3553910;
  *(_OWORD *)(v3 + 352) = xmmword_1B3050FF0;
  *(_OWORD *)(v3 + 368) = xmmword_1B3553920;
  *(_OWORD *)(v3 + 384) = xmmword_1B3553930;
  *(_OWORD *)(v3 + 400) = xmmword_1B3051540;
  *(_OWORD *)(v3 + 416) = xmmword_1B3051200;
  *(int32x4_t *)(v3 + 432) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 448) = xmmword_1B3553940;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BC2ACC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2390_Gain_Sat_ToneAdj::~HgcBT2390_Gain_Sat_ToneAdj(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6540FD8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019C028F0);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6540FD8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4019C028F0);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::SetParameter(HgcBT2390_Gain_Sat_ToneAdj *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::GetParameter(HgcBT2390_Gain_Sat_ToneAdj *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcRasterizerTextureNoColor::GetProgram(HgcRasterizerTextureNoColor *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[5].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[5].zw);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, float2(r0.xy));\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=4aaae76a:5a25eb2d:36af91f0:a92036c5\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000296\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[5].xy;\n"
             "    r0.xy = r0.xy*hg_Params[5].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=b070b0e3:02ff281f:fd62ccc2:049b1c99\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000031c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal5.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=8b328c37:2cd8c50a:51b32aa3:3f5d6ce5\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcRasterizerTextureNoColor::InitProgramDescriptor(HgcRasterizerTextureNoColor *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRasterizerTextureNoColor_hgc_visible", "//Metal1.0     \n//LEN=00000001de\n[[ visible ]] FragmentOut HgcRasterizerTextureNoColor_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[5].xy;\n"
    "    r0.xy = r0.xy*hg_Params[5].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC2F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC2F90(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC2F88);
}

char *HgcRasterizerTextureNoColor::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552AA0;
  strcpy(result, "HgcRasterizerTextureNoColor [hgc1]");
  return result;
}

uint64_t HgcRasterizerTextureNoColor::BindTexture(HgcRasterizerTextureNoColor *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 5, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::Bind(HgcRasterizerTextureNoColor *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t))(*(_QWORD *)a2 + 120))(a2, *((_QWORD *)this + 51) + 16);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcRasterizerTextureNoColor *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t *v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  int32x2_t v11;
  uint64_t v12;
  float32x4_t v13;
  int32x4_t v14;
  float32x2_t v15;
  float32x4_t *v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v20;
  float32x4_t v21;
  int32x4_t v22;

  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  v4 = a2[1];
  v5 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 3);
  v6 = *(float32x4_t **)(a1 + 408);
  v7 = v6[9];
  v8 = v6[10];
  v9 = vminq_f32(vmaxq_f32(vrecpeq_f32(v5), v7), v8);
  v10 = vminq_f32(vmaxq_f32(vmulq_f32(v9, vrecpsq_f32(v5, v9)), v7), v8);
  v11 = a3[10];
  v12 = a3[11].i32[0];
  v13 = vsubq_f32(vmulq_f32(v4, vmulq_f32(v10, vrecpsq_f32(v5, v10))), v3);
  if (a2[14].i32[0])
  {
    v14 = vaddq_s32(vcvtq_s32_f32(v13), vcltzq_f32(v13));
    v15 = (float32x2_t)vsubq_f32(v13, vcvtq_f32_s32(v14)).u64[0];
    v16 = (float32x4_t *)(*(_QWORD *)&v11 + 16 * (v14.i32[0] + v14.i32[1] * (int)v12));
    v17 = vaddq_f32(*v16, vmulq_n_f32(vsubq_f32(v16[1], *v16), v15.f32[0]));
    v18 = vmulq_f32(vaddq_f32(v17, vmulq_lane_f32(vsubq_f32(vaddq_f32(v16[v12], vmulq_n_f32(vsubq_f32(v16[(int)v12 + 1], v16[v12]), v15.f32[0])), v17), v15, 1)), *v6);
  }
  else
  {
    v20.i64[0] = 0x3F0000003F000000;
    v20.i64[1] = 0x3F0000003F000000;
    v21 = vaddq_f32(v13, v20);
    v22 = vcvtq_s32_f32(v21);
    v21.i64[0] = vaddq_s32(v22, vcgtq_f32(vcvtq_f32_s32(v22), v21)).u64[0];
    v18 = vmulq_f32(*(float32x4_t *)(*(_QWORD *)&v11 + 16 * (v21.i32[0] + v21.i32[1] * (int)v12)), *v6);
  }
  *(float32x4_t *)*(_QWORD *)&a3[2] = v18;
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  uint64_t v8;
  float32x4_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  int32x4_t v25;
  float32x4_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  uint64_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int32x4_t v39;

  v4 = HGTile::Renderer(a2);
  v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  v6 = *(int32x2_t *)a2;
  v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v7 >= 1)
  {
    v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      v10 = *((_QWORD *)a2 + 2);
      v11 = 0;
      v12 = 16 * *((int *)a2 + 6);
      v13 = 16 * v8;
      if (v5)
      {
        v14 = v9;
        do
        {
          v15 = 0;
          v16 = v14;
          do
          {
            v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3);
            v18 = this[51];
            v19 = v18[9];
            v20 = v18[10];
            v21 = vminq_f32(vmaxq_f32(vrecpeq_f32(v17), v19), v20);
            v22 = vminq_f32(vmaxq_f32(vmulq_f32(v21, vrecpsq_f32(v17, v21)), v19), v20);
            v23 = *((int *)a2 + 22);
            v24 = vsubq_f32(vmulq_f32(v16, vmulq_f32(v22, vrecpsq_f32(v17, v22))), v9);
            v25 = vaddq_s32(vcvtq_s32_f32(v24), vcltzq_f32(v24));
            v24.i64[0] = vsubq_f32(v24, vcvtq_f32_s32(v25)).u64[0];
            v26 = (float32x4_t *)(*((_QWORD *)a2 + 10) + 16 * (v25.i32[0] + v25.i32[1] * (int)v23));
            v27 = vaddq_f32(*v26, vmulq_n_f32(vsubq_f32(v26[1], *v26), v24.f32[0]));
            *(float32x4_t *)(v10 + v15) = vmulq_f32(vaddq_f32(v27, vmulq_lane_f32(vsubq_f32(vaddq_f32(v26[v23], vmulq_n_f32(vsubq_f32(v26[(int)v23 + 1], v26[v23]), v24.f32[0])), v27), *(float32x2_t *)v24.f32, 1)), *v18);
            v16 = vaddq_f32(v16, (float32x4_t)xmmword_1B304F230);
            v15 += 16;
          }
          while (v13 != v15);
          v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F240);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
      else
      {
        v28.i64[0] = 0x3F0000003F000000;
        v28.i64[1] = 0x3F0000003F000000;
        v29 = v9;
        do
        {
          v30 = 0;
          v31 = v29;
          do
          {
            v32 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 3);
            v33 = this[51];
            v34 = v33[9];
            v35 = v33[10];
            v36 = vminq_f32(vmaxq_f32(vrecpeq_f32(v32), v34), v35);
            v37 = vminq_f32(vmaxq_f32(vmulq_f32(v36, vrecpsq_f32(v32, v36)), v34), v35);
            v38 = vaddq_f32(vsubq_f32(vmulq_f32(v31, vmulq_f32(v37, vrecpsq_f32(v32, v37))), v9), v28);
            v39 = vcvtq_s32_f32(v38);
            v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
            *(float32x4_t *)(v10 + v30) = vmulq_f32(*(float32x4_t *)(*((_QWORD *)a2 + 10)+ 16 * (v38.i32[0] + v38.i32[1] * *((_DWORD *)a2 + 22))), *v33);
            v31 = vaddq_f32(v31, (float32x4_t)xmmword_1B304F230);
            v30 += 16;
          }
          while (v13 != v30);
          v29 = vaddq_f32(v29, (float32x4_t)xmmword_1B304F240);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::GetDOD(HgcRasterizerTextureNoColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  const HGTransform *v6;
  uint64_t v8;
  uint64_t v9;
  HGTransformUtils *v10;
  float v11;
  uint64_t DOD;
  uint64_t v13;
  float64x2_t v15[9];
  HGRect v16;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(const HGTransform **)&a4.var0;
  if ((*(int (**)(HgcRasterizerTextureNoColor *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
  {
    v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v6 = (const HGTransform *)HGRectGrow((uint64_t)v6, v5, v8);
    v5 = v9;
  }
  HGTransform::HGTransform((HGTransform *)v15);
  HGTransform::LoadMatrixf(v15, (float32x2_t *)(*((_QWORD *)this + 51) + 16));
  HGTransform::Invert2D((HGTransform *)v15);
  v11 = HGTransformUtils::MinW(v10);
  *(_QWORD *)&v16.var0 = v5;
  DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v15, v6, v16, 0.5, v11);
  v4 = HGRectUnion(0, 0, DOD, v13);
  HGTransform::~HGTransform((HGTransform *)v15);
  return v4;
}

void sub_1B2BC35F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2BC3604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HgcRasterizerTextureNoColor::GetROI(HgcRasterizerTextureNoColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  HGTransformUtils *v9;
  float v10;
  uint64_t ROI;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float64x2_t v17[9];
  HGRect v18;

  v4 = 0;
  if (!a3)
  {
    v5 = *(_QWORD *)&a4.var2;
    v6 = *(_QWORD *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((_QWORD *)this + 51) + 16));
    v10 = HGTransformUtils::MinW(v9);
    *(_QWORD *)&v18.var0 = v5;
    ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v10);
    v4 = HGRectUnion(0, 0, ROI, v12);
    v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    if ((*(int (**)(HgcRasterizerTextureNoColor *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
    {
      v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(v4, v14, v15);
    }
  }
  return v4;
}

void sub_1B2BC3714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2BC3728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void HgcRasterizerTextureNoColor::HgcRasterizerTextureNoColor(HgcRasterizerTextureNoColor *this)
{
  uint64_t v2;
  uint64_t v3;

  HGNode3D::HGNode3D(this);
  *(_QWORD *)v2 = off_1E6541240;
  *(_DWORD *)(v2 + 416) = 1;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 32) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 48) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 64) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 80) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 112) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 128) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 144) = xmmword_1B30527A0;
  *(int32x4_t *)(v3 + 160) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcRasterizerTextureNoColor *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BC3800(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcRasterizerTextureNoColor::~HgcRasterizerTextureNoColor(HgcRasterizerTextureNoColor *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541240;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541240;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6541240;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGMipmapLevel::~HGMipmapLevel(this);
  HGObject::operator delete(v3);
}

uint64_t HgcRasterizerTextureNoColor::SetParameter(HgcRasterizerTextureNoColor *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcRasterizerTextureNoColor::GetParameter(HgcRasterizerTextureNoColor *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

double HgcRasterizerTextureNoColor::GetOutput(HgcRasterizerTextureNoColor *this, HGRenderer *a2)
{
  uint64_t v2;
  __int128 v3;
  double result;

  if (*((_DWORD *)this + 104))
  {
    v2 = *((_QWORD *)this + 51);
    v3 = *(_OWORD *)(v2 + 96);
    *(_OWORD *)(v2 + 16) = *(unint64_t *)(v2 + 80);
    *(_OWORD *)(*((_QWORD *)this + 51) + 32) = (unint64_t)v3;
    *(_OWORD *)(*((_QWORD *)this + 51) + 48) = xmmword_1B304F250;
    result = 0.0;
    *(_OWORD *)(*((_QWORD *)this + 51) + 64) = xmmword_1B304EFF0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcDemosaic_1::GetProgram(HgcDemosaic_1 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1118;
    else
      return aMetal10Len0000_1119;
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_421;
  }
}

void HgcDemosaic_1::InitProgramDescriptor(HgcDemosaic_1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcDemosaic_1_hgc_visible", aMetal10Len0000_1120);
}

void sub_1B2BC3DD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC3E10(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC3E08);
}

void HgcDemosaic_1::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcDemosaic_1 [hgc1]");
}

uint64_t HgcDemosaic_1::BindTexture(HgcDemosaic_1 *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 3, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcDemosaic_1::Bind(HgcDemosaic_1 *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcDemosaic_1 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcDemosaic_1::RenderTile(HgcDemosaic_1 *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  float32x4_t v7;
  int8x16_t *v8;
  int32x2_t v9;
  int8x16_t *v10;
  uint64_t v11;
  int8x16_t *v12;
  int v13;
  int v14;
  uint64_t v15;
  int8x16_t v16;
  uint64_t v17;
  int8x16_t *v18;
  int8x16_t *v19;
  float32x4_t v20;
  uint64_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  int8x16_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  int32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x8_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x8_t v58;
  int32x4_t v59;
  float32x4_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x8_t v64;
  int8x16_t v65;
  float32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int64x2_t v69;
  int8x16_t v70;
  int8x16_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int64x2_t v76;
  int8x16_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  int8x16_t v81;
  float32x4_t v82;
  int32x4_t v83;
  int8x16_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  float32x4_t v106;
  int8x16_t v107;
  int8x16_t v108;
  int8x16_t v109;
  int8x16_t v110;
  int8x8_t v111;
  float32x4_t v112;
  float32x4_t v113;
  __int128 v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  int8x16_t v122;
  int8x16_t v123;
  float32x4_t v124;
  int64x2_t v125;
  float32x4_t v126;
  int32x4_t v127;
  int8x16_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  int8x16_t v132;
  float32x4_t v133;
  int32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  int8x16_t v137;
  int8x16_t v138;
  int8x16_t v139;
  float32x4_t v140;
  float32x4_t v141;
  int8x16_t v142;
  int8x16_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int8x16_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  int8x16_t v152;
  int64x2_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  int8x16_t v162;
  float32x4_t v163;
  int8x16_t v164;
  float32x4_t v165;
  int8x16_t v166;
  float32x4_t v167;
  int8x16_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  int8x16_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  int8x16_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  int8x16_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  int8x16_t v192;
  int8x16_t v193;
  float32x4_t v194;
  int8x16_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  int8x16_t v200;
  float32x4_t v201;
  float32x4_t v202;
  int32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  int8x16_t v206;
  int8x16_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  int8x16_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  int8x16_t v220;
  float32x4_t v221;
  float32x4_t v222;
  int8x16_t v223;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = (a2[1].i32[0] - v2.i32[0]);
    if ((int)v4 >= 1)
    {
      v5 = 0;
      v6 = a2[11].i32[0];
      *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v7.i64[1] = 0x3F80000000000000;
      v8 = (int8x16_t *)a2[10];
      v9 = a2[2];
      v10 = &v8[2 * (int)v6];
      v11 = 16 * v6;
      v12 = &v8[v6];
      v13 = -2 * v6;
      v14 = -(int)v6;
      v15 = 16 * a2[3].i32[0];
      v16 = 0uLL;
      do
      {
        v17 = 0;
        v18 = v8;
        v225 = v7;
        v19 = v8;
        do
        {
          v227 = v7;
          v20 = vcvtq_f32_s32(vcvtq_s32_f32(v7));
          v21 = *((_QWORD *)this + 51);
          v23 = *(float32x4_t *)(v21 + 32);
          v22 = *(float32x4_t *)(v21 + 48);
          v24 = vsubq_f32(v20, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v20, v7)));
          v25.i64[0] = v24.i64[0];
          v25.i64[1] = vmulq_f32(v22, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v24, 0)).i64[1];
          v26 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          v28 = *(float32x4_t *)(v21 + 64);
          v27 = *(float32x4_t *)(v21 + 80);
          v29 = (int8x16_t)vsubq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, v25), (int8x16_t)v28, v16));
          v30 = (float32x4_t)vextq_s8(v29, (int8x16_t)v24, 8uLL);
          v24.i64[1] = v29.i64[1];
          v31 = (int8x16_t)vsubq_f32(v24, vmulq_lane_f32(v30, *(float32x2_t *)v28.f32, 1));
          v32 = vaddq_f32((float32x4_t)vextq_s8(v31, v31, 8uLL), vmulq_lane_f32(v27, *(float32x2_t *)v31.i8, 1));
          v33 = *(float32x4_t *)(v21 + 16);
          v34 = (float32x4_t)vrev64q_s32(*(int32x4_t *)v21);
          v35 = v19[1];
          ++v19;
          v37 = *(int8x16_t *)(v21 + 96);
          v36 = *(float32x4_t *)(v21 + 112);
          v38 = (int8x16_t)vsubq_f32(v34, (float32x4_t)vextq_s8((int8x16_t)v32, (int8x16_t)v32, 4uLL));
          v39 = (float32x4_t)vextq_s8(*(int8x16_t *)v21, *(int8x16_t *)v21, 8uLL);
          v40 = (float32x4_t)vrev64q_s32((int32x4_t)vsubq_f32(vaddq_f32(v39, v32), v36));
          v41 = (float32x4_t)vbslq_s8(v37, v8[(v17 + 2)], v38);
          v40.i64[0] = v41.i64[0];
          v42 = (int8x16_t)vabsq_f32(v40);
          v43 = (int32x4_t)vbslq_s8(v37, v18[-2], v42);
          *(int8x8_t *)v38.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32((int32x4_t)vbslq_s8(v37, v35, v38)), (int8x8_t)*(_OWORD *)&vmvnq_s8(v37)), vand_s8(*(int8x8_t *)v18[-1].i8, *(int8x8_t *)v37.i8));
          v44 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v21, 3);
          v38.i64[1] = v43.i64[0];
          v45 = *(int8x16_t *)(v21 + 128);
          v46 = *(int8x16_t *)(v21 + 144);
          v47 = (float32x4_t)vbslq_s8(v45, vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL), v38);
          v48 = (float32x4_t)vbslq_s8(v37, vbslq_s8((int8x16_t)vcgtq_f32(v28, (float32x4_t)vbslq_s8(v37, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32(v43), v27), v42)), (int8x16_t)v23, (int8x16_t)vrev64q_s32((int32x4_t)v23)), v42);
          *(int8x8_t *)v49.f32 = vqtbl1_s8((int8x16_t)v48, *(int8x8_t *)v46.i8);
          v50 = (int8x8_t)vextq_s8(v46, v46, 8uLL).u64[0];
          *(int8x8_t *)&v49.u32[2] = vqtbl1_s8((int8x16_t)v48, v50);
          v51 = vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v22, v49));
          v49.i64[0] = vextq_s8(v51, v51, 8uLL).u64[0];
          *(int8x8_t *)v41.f32 = vext_s8(*(int8x8_t *)v49.f32, *(int8x8_t *)v48.f32, 4uLL);
          *(int8x8_t *)v49.f32 = vext_s8(*(int8x8_t *)v48.f32, *(int8x8_t *)v49.f32, 4uLL);
          v52 = (float32x4_t)vextq_s8(v51, (int8x16_t)v48, 8uLL);
          v48.i64[1] = v51.i64[1];
          v49.i64[1] = v41.i64[0];
          v53 = vmaxq_f32(v49, v52);
          v54 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v48, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v36, v7))));
          v55 = vmulq_laneq_f32(vsubq_f32(v47, v44), v23, 2);
          v48.i64[0] = *(_QWORD *)(v21 + 112);
          v56 = (int8x16_t)vminq_f32(v53, v54);
          v57 = vextq_s8((int8x16_t)v55, v56, 0xCuLL);
          v58 = (int8x8_t)vextq_s8(v57, v57, 8uLL).u64[0];
          *(int32x2_t *)&v48.u32[2] = vdup_lane_s32(*(int32x2_t *)v54.f32, 0);
          v41.i64[0] = vextq_s8(v57, (int8x16_t)v54, 0xCuLL).u64[0];
          v57.i64[0] = v54.i64[0];
          v59 = *(int32x4_t *)(v21 + 160);
          v60 = *(float32x4_t *)(v21 + 176);
          v61 = (int8x16_t)vminq_f32(v55, v48);
          *(int8x8_t *)v62.i8 = vqtbl1_s8(v61, *(int8x8_t *)v59.i8);
          v27.i64[0] = vextq_s8((int8x16_t)v59, (int8x16_t)v59, 8uLL).u64[0];
          *(int8x8_t *)v63.i8 = vqtbl1_s8(v61, *(int8x8_t *)v46.i8);
          *(int8x8_t *)&v41.u32[2] = vext_s8(*(int8x8_t *)v54.f32, v58, 4uLL);
          v62.u64[1] = (unint64_t)vqtbl1_s8(v61, *(int8x8_t *)v27.f32);
          v64 = vqtbl1_s8(v61, v50);
          v65 = *(int8x16_t *)(v21 + 192);
          v66 = *(float32x4_t *)(v21 + 208);
          v67 = vbslq_s8(v65, vandq_s8((int8x16_t)v28, (int8x16_t)vcgeq_f32(vnegq_f32(v41), v60)), v61);
          v63.u64[1] = (unint64_t)v64;
          v68 = vbslq_s8(v37, v57, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v37, *v18, v67)), v39));
          v69 = (int64x2_t)vmulq_lane_f32(v23, *(float32x2_t *)v68.i8, 1);
          v57.i64[0] = v53.i64[0];
          v57.i64[1] = v69.i64[1];
          v70 = (int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.i8, 1), v60);
          v53.i64[1] = vdupq_laneq_s64(v69, 1).u64[0];
          v71 = (int8x16_t)vcgtq_f32(v60, v7);
          v72 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32((float32x4_t)vextq_s8(v68, v68, 4uLL), (float32x4_t)vrev64q_s32((int32x4_t)v53)), v57);
          v73 = (float32x4_t)vorrq_s8(vbicq_s8(v67, v37), vandq_s8(vandq_s8(v37, (int8x16_t)v36), v71));
          v74 = (float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 0xCuLL);
          v75 = (float32x4_t)vbslq_s8(v65, (int8x16_t)vminq_f32(v74, v73), (int8x16_t)v73);
          v76 = (int64x2_t)vbslq_s8(v70, v63, v62);
          v77 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)vextq_s8((int8x16_t)v75, (int8x16_t)v75, 4uLL)), v75), v28), (int8x16_t)v74, vextq_s8((int8x16_t)v76, (int8x16_t)v76, 0xCuLL));
          v78 = (int8x16_t)vcgeq_f32(vnegq_f32(v75), v28);
          v79 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vsubq_f32(v34, v36), (int8x16_t)v75);
          v80 = (int8x16_t)vdupq_lane_s64(v77.i64[0], 0);
          v81 = vandq_s8((int8x16_t)v36, v78);
          v82 = (float32x4_t)vbslq_s8(v65, (int8x16_t)vminq_f32(v79, (float32x4_t)vextq_s8(v81, v81, 8uLL)), (int8x16_t)v79);
          v83 = (int32x4_t)vbslq_s8(v37, vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v7, v82)), (int8x16_t)v82);
          v82.i64[0] = vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL).u64[0];
          v84 = vextq_s8(v80, v80, 8uLL);
          v80.i64[0] = v76.i64[1];
          *(int8x8_t *)v59.i8 = vqtbl1_s8((int8x16_t)v83, *(int8x8_t *)v59.i8);
          v82.i64[1] = v84.i64[0];
          *(int8x8_t *)v84.i8 = vqtbl1_s8((int8x16_t)v82, *(int8x8_t *)v46.i8);
          v85 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v83, 2), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.i8, 0)), v66), v84, (int8x16_t)v59);
          v86 = *(int8x16_t *)(v21 + 224);
          v87 = *(float32x4_t *)(v21 + 240);
          v88 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vsubq_f32(*(float32x4_t *)v21, v60), (int8x16_t)v83);
          v59.i64[0] = v85.i64[0];
          v89 = (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v85, 8uLL);
          v60.i64[0] = vdupq_laneq_s64(v76, 1).u64[0];
          v85.i64[1] = v76.i64[1];
          v90 = (float32x4_t)vbslq_s8(v37, vandq_s8((int8x16_t)v36, (int8x16_t)vcgeq_f32(vnegq_f32(v88), v66)), (int8x16_t)v88);
          v59.i64[1] = v60.i64[0];
          v91 = (float32x4_t)vbslq_s8(v86, vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v7), v90)), (int8x16_t)v90);
          v92 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v91, (int8x16_t)v91, 8uLL), v91), (int8x16_t)v91);
          v93 = (float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 8uLL);
          v94 = (float32x4_t)vbslq_s8(v37, v77, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v92), v92), v66), (int8x16_t)v93, (int8x16_t)v85));
          v95 = (float32x4_t)vbslq_s8(v45, vextq_s8((int8x16_t)v94, (int8x16_t)v94, 8uLL), vbslq_s8(v86, (int8x16_t)vrev64q_s32(v59), v80));
          v96 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0);
          v97 = vaddq_f32(v96, v95);
          v226 = v95;
          v98 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2);
          v99 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 3);
          v100 = vaddq_f32(vmaxq_f32(vmulq_lane_f32(vmulq_f32(v97, v97), *(float32x2_t *)v33.f32, 1), v98), v99);
          v101 = vminq_f32(vrsqrteq_f32(v100), v87);
          v102 = vminq_f32(vmulq_f32(v101, vrsqrtsq_f32(vmulq_f32(v100, v101), v101)), v87);
          v103 = vmulq_f32(v100, vminq_f32(vmulq_f32(v102, vrsqrtsq_f32(vmulq_f32(v100, v102), v102)), v87));
          v90.i64[0] = v27.i64[0];
          v104 = (float32x4_t)vrev64q_s32((int32x4_t)v94);
          v105.i64[0] = vsubq_f32(v104, v94).u64[0];
          v106 = vsubq_f32(v89, v85);
          v105.u64[1] = (unint64_t)vadd_f32((float32x2_t)vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v27.f32), (float32x2_t)vqtbl1_s8((int8x16_t)v103, v50));
          v107 = vbslq_s8(v37, (int8x16_t)vmulq_lane_f32(v106, *(float32x2_t *)v105.i8, 1), v105);
          v108 = vmvnq_s8(v65);
          v109 = (int8x16_t)vabsq_f32((float32x4_t)vextq_s8((int8x16_t)v106, (int8x16_t)v106, 8uLL));
          v110 = (int8x16_t)vabsq_f32((float32x4_t)vextq_s8(v107, v107, 8uLL));
          v111 = (int8x8_t)vsubq_f32(v104, v74).u64[0];
          v112 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vsubq_f32(v104, v93), v107), *(float *)v111.i32), v107);
          *(int8x8_t *)v109.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v110, v110, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v108, v108, 8uLL)), vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v109, v109, 8uLL)));
          v113 = *(float32x4_t *)(v21 + 256);
          v114 = *(_OWORD *)(v21 + 272);
          *(int8x8_t *)v115.f32 = vbic_s8(v111, *(int8x8_t *)&v114);
          v115.i64[1] = v109.i64[0];
          v116 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v95, v103));
          v117 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v112, v115));
          v109.i64[0] = vmaxq_f32(v117, (float32x4_t)vrev64q_s32((int32x4_t)v117)).u64[0];
          v109.i64[1] = v117.i64[1];
          v118 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vminq_f32(vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v116), v116), (float32x4_t)vextq_s8((int8x16_t)v116, (int8x16_t)v116, 4uLL)), v109);
          v119 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vmaxq_f32(v118, (float32x4_t)vextq_s8((int8x16_t)v118, (int8x16_t)v118, 8uLL)), (int8x16_t)v118);
          v120 = (float32x4_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL);
          v121 = (float32x4_t)vrev64q_s32((int32x4_t)v119);
          v119.i64[0] = vminq_f32(v119, (float32x4_t)vextq_s8((int8x16_t)v116, (int8x16_t)v116, 8uLL)).u64[0];
          v119.i64[1] = vmaxq_f32(v120, v121).i64[1];
          v122 = vbslq_s8(v37, v8[v13 + (int)v17], (int8x16_t)v119);
          v123 = vextq_s8(v122, v122, 8uLL);
          v119.i64[0] = vbslq_s8(v37, v123, (int8x16_t)v119).u64[0];
          v123.i64[0] = vbslq_s8(v37, v8[v14 + (int)v17], (int8x16_t)vrev64q_s32((int32x4_t)v12[v17])).u64[0];
          v124 = (float32x4_t)vextq_s8((int8x16_t)v227, (int8x16_t)v227, 0xCuLL);
          v125 = (int64x2_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v113, v124));
          v95.i64[0] = v119.i64[0];
          v95.i64[1] = vdupq_laneq_s64(v125, 1).u64[0];
          v119.i64[1] = v125.i64[1];
          v126 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32(v93, (float32x4_t)vrev64q_s32((int32x4_t)v95)), (int8x16_t)v119);
          v127 = (int32x4_t)vminq_f32(v48, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v45, vextq_s8(v10[v17], v10[v17], 4uLL), v123), v44), v23, 2));
          v128 = vandq_s8((int8x16_t)v113, v71);
          v129 = vbslq_s8(v65, vextq_s8(v128, v128, 0xCuLL), (int8x16_t)v127);
          v130 = (float32x4_t)vrev64q_s32((int32x4_t)v72);
          v131 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vsubq_f32(v130, vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v126, (int8x16_t)v126, 8uLL), *(float32x2_t *)v72.f32, 1)), v129);
          v132 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v126, 1), v66), (int8x16_t)v127, (int8x16_t)vrev64q_s32(v127));
          v133 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v131, (int8x16_t)v131, 8uLL), v131), (int8x16_t)v126, 8uLL);
          v126.i64[1] = v131.i64[1];
          v134 = (int32x4_t)vbslq_s8(v86, (int8x16_t)v126, vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32(v126), v66)));
          v135 = (float32x4_t)vbslq_s8(v65, vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v124, (float32x4_t)vbslq_s8(v65, (int8x16_t)vsubq_f32(*(float32x4_t *)v21, v113), (int8x16_t)v131))), (int8x16_t)v131);
          v136 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32(v135, (float32x4_t)vextq_s8((int8x16_t)v134, (int8x16_t)v134, 8uLL)), (int8x16_t)v135);
          v137 = *(int8x16_t *)(v21 + 304);
          v138 = vbslq_s8(*(int8x16_t *)(v21 + 288), (int8x16_t)v85, v132);
          *(int8x8_t *)v123.i8 = vqtbl1_s8((int8x16_t)v136, v50);
          v139 = vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32(v136), v66));
          v140.i64[0] = v136.i64[0];
          v140.i64[1] = v139.i64[1];
          v139.i64[0] = vminq_f32(v140, (float32x4_t)vextq_s8(v139, (int8x16_t)v136, 8uLL)).u64[0];
          v141 = *(float32x4_t *)(v21 + 80);
          v139.i64[1] = vsubq_f32(*(float32x4_t *)v21, v141).i64[1];
          v142 = vbslq_s8((int8x16_t)vcgtq_f32(v133, v66), (int8x16_t)v74, vextq_s8(v138, v138, 0xCuLL));
          *(int32x2_t *)v85.f32 = vrev64_s32(*(int32x2_t *)v138.i8);
          v85.i64[1] = v142.i64[0];
          v123.i64[1] = v123.i64[0];
          *(int8x8_t *)v71.i8 = vqtbl1_s8((int8x16_t)v85, *(int8x8_t *)v90.f32);
          v71.i64[1] = v71.i64[0];
          v143 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.f32, 0), (float32x4_t)vdupq_laneq_s32((int32x4_t)v136, 2)), v66), v71, v123);
          v144 = (float32x4_t)vrev64q_s32((int32x4_t)v33);
          v145 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vaddq_f32(v144, v93), v139);
          v145.i64[1] = vandq_s8(*(int8x16_t *)&v113, (int8x16_t)vcgtq_f32(v124, v145)).i64[1];
          v146 = vmulq_f32((float32x4_t)vdupq_lane_s64(v145.i64[0], 0), v145);
          v100.i64[1] = v143.i64[1];
          v147 = (int8x16_t)vmulq_lane_f32(v144, *(float32x2_t *)v146.f32, 1);
          v148 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL), vmaxq_f32((float32x4_t)vextq_s8(v147, v147, 8uLL), v33));
          v149 = vminq_f32(vrsqrteq_f32(v148), v87);
          v150 = vminq_f32(vmulq_f32(v149, vrsqrtsq_f32(vmulq_f32(v149, v148), v149)), v87);
          v151 = vmulq_f32(v148, vminq_f32(vmulq_f32(v150, vrsqrtsq_f32(vmulq_f32(v148, v150), v150)), v87));
          v150.i64[0] = v134.i64[0];
          v150.i64[1] = v151.i64[1];
          v152 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v146, (int8x16_t)v146, 4uLL), v66), (int8x16_t)v93, vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL));
          v153 = (int64x2_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v130, v150));
          v146.i64[0] = v134.i64[0];
          v144.i64[0] = vdupq_laneq_s64(v153, 1).u64[0];
          v146.i64[1] = v153.i64[1];
          v154 = (float32x4_t)vbslq_s8(v37, v142, v152);
          v134.i64[1] = v144.i64[0];
          v155 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32(v93, (float32x4_t)vrev64q_s32(v134)), (int8x16_t)v100);
          v156 = (float32x4_t)vextq_s8((int8x16_t)v155, (int8x16_t)v155, 0xCuLL);
          v157 = (float32x4_t)vbslq_s8(v86, vextq_s8((int8x16_t)v155, (int8x16_t)v155, 4uLL), vbslq_s8(v45, vextq_s8((int8x16_t)v154, (int8x16_t)v154, 8uLL), (int8x16_t)v85));
          v158 = vaddq_f32(v96, v157);
          v159 = vaddq_f32(v99, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v158, v158), *(float32x2_t *)v33.f32, 1), v98));
          v160 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32(v156, v146), (int8x16_t)v146);
          *(int8x8_t *)v144.f32 = vqtbl1_s8((int8x16_t)v159, *(int8x8_t *)v137.i8);
          v158.i64[0] = vextq_s8(v137, v137, 8uLL).u64[0];
          *(int8x8_t *)&v144.u32[2] = vqtbl1_s8((int8x16_t)v159, *(int8x8_t *)v158.f32);
          v161 = vminq_f32(vrsqrteq_f32(v144), v87);
          v162 = vbslq_s8((int8x16_t)vcgtq_f32(v160, v66), (int8x16_t)v66, (int8x16_t)vrev64q_s32((int32x4_t)v160));
          v163 = vminq_f32(vmulq_f32(v161, vrsqrtsq_f32(vmulq_f32(v161, v144), v161)), v87);
          v164 = *(int8x16_t *)(v21 + 320);
          v165 = *(float32x4_t *)(v21 + 336);
          v166 = (int8x16_t)vmulq_f32(v163, vrsqrtsq_f32(vmulq_f32(v144, v163), v163));
          *(int8x8_t *)v144.f32 = vqtbl1_s8(v166, *(int8x8_t *)v164.i8);
          v96.i64[0] = vextq_s8(v164, v164, 8uLL).u64[0];
          *(int8x8_t *)&v144.u32[2] = vqtbl1_s8(v166, *(int8x8_t *)v96.f32);
          v167 = vminq_f32(vmaxq_f32(vrecpeq_f32(v144), v165), v87);
          v168 = (int8x16_t)vaddq_f32(v104, v94);
          v169 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v37, v168, v166));
          v170 = vminq_f32(vmaxq_f32(vrecpeq_f32(v169), v165), v87);
          v171 = vminq_f32(vmaxq_f32(vmulq_f32(v170, vrecpsq_f32(v169, v170)), v165), v87);
          v172 = vminq_f32(vmaxq_f32(vmulq_f32(v167, vrecpsq_f32(v144, v167)), v165), v87);
          v173 = (float32x4_t)vrev64q_s32((int32x4_t)v154);
          v174 = vaddq_f32((float32x4_t)vdupq_lane_s64(vbslq_s8(v37, v168, (int8x16_t)vaddq_f32(v173, v154)).i64[0], 0), vmulq_laneq_f32(*(float32x4_t *)(v21 + 352), v72, 3));
          v175 = (int8x16_t)vmulq_f32(v171, vrecpsq_f32(v169, v171));
          v176 = vminq_f32(vrsqrteq_f32(v159), v165);
          v177 = vminq_f32(vmulq_f32(v176, vrsqrtsq_f32(vmulq_f32(v159, v176), v176)), v165);
          v178 = vmulq_f32(v172, vrecpsq_f32(v144, v172));
          v179 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vmulq_f32(v159, vminq_f32(vmulq_f32(v177, vrsqrtsq_f32(vmulq_f32(v159, v177), v177)), v165)), vbslq_s8(v37, v175, (int8x16_t)v178));
          v180 = vaddq_f32(v174, v174);
          v181 = vminq_f32(vmaxq_f32(vrecpeq_f32(v180), v165), v87);
          v182 = vminq_f32(vmaxq_f32(vmulq_f32(v181, vrecpsq_f32(v180, v181)), v165), v87);
          v183 = vbslq_s8(v37, v162, (int8x16_t)v178);
          v178.i64[0] = vbslq_s8(v37, (int8x16_t)vmulq_f32(v182, vrecpsq_f32(v180, v182)), (int8x16_t)vsubq_f32(v173, v154)).u64[0];
          v184 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32(v155, (float32x4_t)vextq_s8(v183, v183, 4uLL)), v138);
          v180.i64[0] = v178.i64[0];
          v185 = (float32x4_t)vextq_s8((int8x16_t)v184, (int8x16_t)v184, 0xCuLL);
          *(float32x2_t *)&v180.u32[2] = vadd_f32((float32x2_t)vqtbl1_s8((int8x16_t)v179, *(int8x8_t *)v96.f32), (float32x2_t)vqtbl1_s8((int8x16_t)v179, *(int8x8_t *)v158.f32));
          v178.i64[1] = v180.i64[1];
          v186 = vsubq_f32(v185, v155);
          v154.i64[1] = v186.i64[1];
          v187 = vbslq_s8(v37, (int8x16_t)vmulq_laneq_f32((float32x4_t)vrev64q_s32((int32x4_t)v178), v186, 2), (int8x16_t)v180);
          v188 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vabsq_f32((float32x4_t)vextq_s8(v187, v187, 8uLL)), (int8x16_t)v154);
          v74.i64[0] = vsubq_f32(v188, v74).u64[0];
          *(int8x8_t *)v178.f32 = vbic_s8(*(int8x8_t *)v74.f32, *(int8x8_t *)&v114);
          *(int8x8_t *)&v178.u32[2] = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v188, (int8x16_t)v188, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v21 + 368), *(int8x16_t *)(v21 + 368), 8uLL));
          v189 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vsubq_f32(v188, v93), v187), v74.f32[0]), v187), v178));
          v190 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v189, (int8x16_t)v189, 4uLL), v189);
          v191 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v157, v179));
          v192 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v190, (float32x4_t)vextq_s8((int8x16_t)v190, (int8x16_t)v190, 8uLL)), v66), v113);
          v193 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v37, v192, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v37, v192, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v191), v191)), (float32x4_t)vextq_s8((int8x16_t)v191, (int8x16_t)v191, 4uLL))), (float32x4_t)vextq_s8((int8x16_t)v191, (int8x16_t)v191, 8uLL));
          v194 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vmulq_laneq_f32(v180, v174, 2), (int8x16_t)v174);
          v195 = vbslq_s8(v37, vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vbslq_s8(v37, v192, v193)), v66)), v193);
          v196 = (float32x4_t)vextq_s8(v195, (int8x16_t)vaddq_f32(v194, v194), 0xCuLL);
          v196.i64[0] = v195.i64[0];
          v197 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32(v156, v196), (int8x16_t)v196);
          v196.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32(v197, v66), (int8x16_t)v66, (int8x16_t)vrev64q_s32((int32x4_t)v197)).u64[0];
          v178.i64[0] = vextq_s8((int8x16_t)v197, (int8x16_t)v197, 8uLL).u64[0];
          *(int8x8_t *)v180.f32 = vext_s8(*(int8x8_t *)v178.f32, *(int8x8_t *)v196.f32, 4uLL);
          *(int8x8_t *)v178.f32 = vext_s8(*(int8x8_t *)v196.f32, *(int8x8_t *)v178.f32, 4uLL);
          v178.i64[1] = v180.i64[0];
          v196.i64[1] = v197.i64[1];
          v198 = vminq_f32(vmaxq_f32(vrecpeq_f32(v178), v165), v87);
          v199 = vminq_f32(vmaxq_f32(vmulq_f32(v198, vrecpsq_f32(v178, v198)), v165), v87);
          v200 = (int8x16_t)vmulq_laneq_f32(vmulq_f32(v199, vrecpsq_f32(v178, v199)), v194, 3);
          v200.i64[0] = vbslq_s8(v37, (int8x16_t)vminq_f32(v156, (float32x4_t)vbslq_s8(v37, (int8x16_t)v196, v200)), v200).u64[0];
          v201 = (float32x4_t)vextq_s8((int8x16_t)v184, (int8x16_t)v184, 8uLL);
          v200.i64[1] = vaddq_f32(v201, v184).i64[1];
          v202 = (float32x4_t)vrev64q_s32((int32x4_t)v155);
          v203 = (int32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v202, v201), v200);
          v204 = (float32x4_t)vbslq_s8(v37, vbslq_s8((int8x16_t)vcgtq_f32(v185, v66), (int8x16_t)v194, (int8x16_t)v66), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v203), v66), (int8x16_t)v203, (int8x16_t)v66));
          v205 = (float32x4_t)vextq_s8((int8x16_t)v203, (int8x16_t)v203, 8uLL);
          v206 = (int8x16_t)vmulq_f32(v141, vsubq_f32(v205, vmulq_f32(v205, v204)));
          v207 = (int8x16_t)vdupq_laneq_s32((int32x4_t)v72, 3);
          *(int32x2_t *)v178.f32 = vdup_lane_s32(*(int32x2_t *)v206.i8, 0);
          v178.i64[1] = v207.i64[0];
          v208 = vsubq_f32(v226, v178);
          v209 = vmulq_f32(v208, v208);
          v206.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v206, 0), (float32x4_t)vextq_s8(v207, v206, 0xCuLL)).i64[1];
          v210 = vaddq_f32(v209, (float32x4_t)vextq_s8((int8x16_t)v209, (int8x16_t)v209, 4uLL));
          v211 = vbslq_s8(v37, (int8x16_t)vaddq_f32(vaddq_f32(v210, (float32x4_t)vextq_s8((int8x16_t)v210, (int8x16_t)v210, 8uLL)), (float32x4_t)vbslq_s8(v37, (int8x16_t)vaddq_f32(v202, v155), v206)), v206);
          *(int32x2_t *)v210.f32 = vdup_lane_s32(*(int32x2_t *)v211.i8, 1);
          v210.i64[1] = v207.i64[0];
          v212 = vsubq_f32(v157, v210);
          v213 = vmulq_f32(v212, v212);
          v214 = vaddq_f32(v213, (float32x4_t)vextq_s8((int8x16_t)v213, (int8x16_t)v213, 4uLL));
          v215 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v159, (int8x16_t)v159, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v159, (int8x16_t)v159, 8uLL)), v211);
          v216 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v215, (int8x16_t)v215, 0xCuLL), vaddq_f32(v214, (float32x4_t)vextq_s8((int8x16_t)v214, (int8x16_t)v214, 8uLL)));
          v217 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v216, (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v216, v215)));
          v218 = vminq_f32(vmaxq_f32(vrecpeq_f32(v217), v165), v87);
          v219 = vminq_f32(vmaxq_f32(vmulq_f32(v218, vrecpsq_f32(v217, v218)), v165), v87);
          v220 = (int8x16_t)vmulq_f32(v219, vrecpsq_f32(v217, v219));
          v221 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v37, (int8x16_t)v216, v220), v215, 2), v220);
          v222 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v215), vmulq_lane_f32(v221, *(float32x2_t *)v221.f32, 1)), vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32(v72), v66)));
          v16 = 0uLL;
          v223 = vbslq_s8(v86, vbslq_s8((int8x16_t)vcgtq_f32(v222, v66), vextq_s8((int8x16_t)v72, v207, 4uLL), (int8x16_t)vrev64q_s32((int32x4_t)v222)), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v222.f32, 1), v66), (int8x16_t)v66, v207));
          v223.i32[3] = 1.0;
          *(int8x16_t *)(*(_QWORD *)&v9 + 16 * v17) = v223;
          v7 = vaddq_f32(v227, (float32x4_t)xmmword_1B304F230);
          v18 = v19;
          ++v17;
        }
        while (v4 != v17);
        v8 = (int8x16_t *)((char *)v8 + v11);
        ++v5;
        v7 = vaddq_f32(v225, (float32x4_t)xmmword_1B304F240);
        v10 = (int8x16_t *)((char *)v10 + v11);
        v12 = (int8x16_t *)((char *)v12 + v11);
        *(_QWORD *)&v9 += v15;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcDemosaic_1::GetDOD(HgcDemosaic_1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 2u, 2u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HgcDemosaic_1::GetROI(HgcDemosaic_1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 2u, 2u);
  return HGRectGrow(v6, v5, v7);
}

void HgcDemosaic_1::HgcDemosaic_1(HgcDemosaic_1 *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65414B8;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = xmmword_1B3052440;
  *(_OWORD *)(v3 + 64) = xmmword_1B3553990;
  *(_OWORD *)(v3 + 80) = xmmword_1B35539A0;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 112) = xmmword_1B35539B0;
  *(_OWORD *)(v3 + 128) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051010;
  *(_OWORD *)(v3 + 160) = xmmword_1B35539C0;
  *(_OWORD *)(v3 + 176) = xmmword_1B3053870;
  *(_OWORD *)(v3 + 192) = xmmword_1B3050FE0;
  *(_QWORD *)(v3 + 208) = 0;
  *(_QWORD *)(v3 + 216) = 0;
  *(_OWORD *)(v3 + 224) = xmmword_1B3050FF0;
  *(int32x4_t *)(v3 + 240) = vdupq_n_s32(0x7F7FFFFFu);
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 256) = _Q0;
  *(_OWORD *)(v3 + 272) = xmmword_1B3050F80;
  *(_QWORD *)&_Q0 = 0xFFFFFFFFLL;
  *((_QWORD *)&_Q0 + 1) = 0xFFFFFFFFLL;
  *(_OWORD *)(v3 + 288) = _Q0;
  *(_OWORD *)(v3 + 304) = xmmword_1B35539D0;
  *(_OWORD *)(v3 + 320) = xmmword_1B35539E0;
  *(_OWORD *)(v3 + 336) = xmmword_1B35539F0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3553A00;
  *(_OWORD *)(v3 + 368) = xmmword_1B3051020;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcDemosaic_1 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BC4D08(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDemosaic_1::~HgcDemosaic_1(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65414B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F47AF14);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65414B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F47AF14);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65414B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C400F47AF14);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcDemosaic_1::SetParameter(HgcDemosaic_1 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcDemosaic_1::GetParameter(HgcDemosaic_1 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcDemosaic_2::GetProgram(HgcDemosaic_2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return aMetal10Len0000_1121;
    else
      return aMetal10Len0000_1122;
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_422;
  }
}

void HgcDemosaic_2::InitProgramDescriptor(HgcDemosaic_2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcDemosaic_2_hgc_visible", aMetal10Len0000_1123);
}

void sub_1B2BC5294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC52CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC52C4);
}

void HgcDemosaic_2::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcDemosaic_2 [hgc1]");
}

uint64_t HgcDemosaic_2::BindTexture(HgcDemosaic_2 *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 3, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcDemosaic_2::Bind(HgcDemosaic_2 *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcDemosaic_2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcDemosaic_2::RenderTile(HgcDemosaic_2 *this, int32x2_t *a2)
{
  int32x2_t v2;
  uint64_t v3;
  uint64_t v4;
  float32x4_t v5;
  int32x2_t v6;
  int32x2_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  int8x16_t v33;
  int64x2_t v34;
  unint64_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int8x16_t v44;
  int64x2_t v45;
  float32x4_t v46;
  int32x2_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int32x4_t v50;
  __int32 v51;
  __int32 v52;
  int8x16_t v53;
  int8x16_t v54;
  __int32 v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int8x8_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  float32x4_t v71;
  uint64_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int32x4_t v75;
  int64x2_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int32x4_t v82;
  float32x4_t v83;
  int64x2_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int32x4_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int32x4_t v95;
  int8x16_t v96;
  float32x4_t v97;
  int8x16_t v98;
  int8x16_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  int8x16_t v105;
  int8x16_t v106;
  int8x16_t v107;
  float32x4_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  int8x16_t v114;
  float32x4_t v115;
  int8x16_t v116;
  int8x16_t v117;
  float32x4_t v118;
  float32x4_t v119;
  int8x16_t v120;
  int8x16_t v121;
  int8x16_t v122;
  float32x4_t v123;
  float32x4_t v124;
  int8x16_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  int8x16_t v130;
  float32x4_t v131;
  int8x16_t v132;
  int32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  int32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  int32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  int8x16_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  int8x16_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  int8x16_t v198;
  float32x4_t v199;
  float32x4_t v200;
  int8x16_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  int32x4_t v220;
  float32x4_t v221;
  int8x16_t v222;
  float32x4_t v223;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  int8x16_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  int32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  int8x16_t v254;
  float32x4_t v255;
  float32x4_t v256;
  int32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  int32x4_t v266;
  int8x16_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  int8x16_t v274;
  int32x4_t v275;
  int8x16_t v276;
  int8x16_t v277;
  int8x16_t v278;
  int32x4_t v279;
  float32x4_t v280;
  float32x4_t v281;
  float32x4_t v282;
  float32x4_t v283;
  float32x4_t v284;
  float32x4_t v285;
  float32x4_t v286;
  int8x16_t v287;
  float32x4_t v288;
  float32x4_t v289;
  float32x4_t v290;
  float32x4_t v291;
  float32x4_t v292;
  float32x4_t v293;
  float32x4_t v294;
  int32x4_t v295;
  float32x4_t v296;
  int32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  int32x4_t v300;
  float32x4_t v301;
  float32x4_t v302;
  float32x4_t v303;
  float32x4_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  float32x4_t v311;
  float32x4_t v312;
  float32x4_t v313;
  float32x4_t v314;
  float32x4_t v315;
  float32x4_t v316;
  float32x4_t v317;
  float32x4_t v318;
  float32x4_t v319;
  float32x4_t v320;
  float32x4_t v321;
  float32x4_t v322;
  float32x4_t v323;
  float32x4_t v324;
  int64x2_t v325;
  float32x4_t v326;
  float32x4_t v327;
  float32x4_t v328;
  float32x4_t v329;
  float32x4_t v330;
  int64x2_t v331;
  float32x4_t v332;
  float32x4_t v333;
  float32x4_t v334;
  float32x4_t v335;
  float32x4_t v336;
  int8x16_t v337;
  int8x16_t v338;
  float32x4_t v339;
  int8x16_t v340;
  float32x4_t v341;
  float32x4_t v342;
  int8x16_t v343;
  float32x4_t v344;
  int32x4_t v345;
  int8x16_t v346;
  int8x16_t v347;
  int8x16_t v348;
  float32x4_t v349;
  int8x16_t v350;
  float32x4_t v351;
  float32x4_t v352;
  int8x16_t v353;
  int8x16_t v354;
  int8x16_t v355;
  int8x16_t v356;
  float32x4_t v357;
  float32x4_t v359;
  float32x4_t v360;
  int8x8_t v361;
  float32x4_t v362;
  int8x16_t v363;
  int8x16_t v364;
  int8x8_t v365;
  int8x16_t v366;
  float32x4_t v367;
  int32x4_t v368;
  uint64_t v369;
  int8x16_t v370;
  float32x4_t v371;
  float32x4_t v372;
  float32x4_t v373;
  float32x4_t v374;
  float32x4_t v375;
  __int128 v376;
  int8x16_t v377;
  int8x16_t v378;
  float32x4_t v379;
  float32x4_t v380;
  float32x4_t v381;
  int8x16_t v382;
  float32x4_t v383;

  v2 = *a2;
  v3 = (a2[1].i32[1] - HIDWORD(*(unint64_t *)a2));
  if ((int)v3 >= 1 && a2[1].i32[0] - v2.i32[0] >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[10];
    v7 = a2[2];
    v8 = 16 * a2[3].i32[0];
    v9 = 16 * a2[11].i32[0];
    v10 = 16 * (a2[1].i32[0] - v2.i32[0]);
    v11 = 0uLL;
    v12 = v5;
    v360 = v5;
    do
    {
      v13 = 0;
      v359 = v12;
      do
      {
        v383 = v12;
        v14 = vcvtq_f32_s32(vcvtq_s32_f32(v12));
        v15 = *((_QWORD *)this + 51);
        v16 = *(float32x4_t *)(v15 + 48);
        v17 = vsubq_f32(v14, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v14, v12)));
        v18.i64[0] = v17.i64[0];
        v18.i64[1] = vmulq_f32(v16, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v17, 0)).i64[1];
        v19 = vcvtq_f32_s32(vcvtq_s32_f32(v18));
        v20 = *(float32x4_t *)(v15 + 80);
        v375 = *(float32x4_t *)(v15 + 64);
        v376 = *(_OWORD *)(v15 + 32);
        v21 = (int8x16_t)vsubq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v19, v18), (int8x16_t)v375, v11));
        v22 = (float32x4_t)vextq_s8(v21, (int8x16_t)v17, 8uLL);
        v17.i64[1] = v21.i64[1];
        v23 = vsubq_f32(v17, vmulq_laneq_f32(v22, v20, 2));
        v24 = (int32x4_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v23), vmulq_laneq_f32(v23, v20, 2));
        v25 = *(float32x4_t *)(v15 + 16);
        v27 = *(int8x16_t *)(v15 + 96);
        v26 = *(int8x16_t *)(v15 + 112);
        v28 = (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v27, (int8x16_t)vaddq_f32(*(float32x4_t *)v15, (float32x4_t)vrev64q_s32(v24)), (int8x16_t)v24), v20);
        v29 = (float32x4_t)vbslq_s8(v27, v28, (int8x16_t)v24);
        v30 = (float32x4_t)vrev64q_s32(*(int32x4_t *)v15);
        v31 = (int8x16_t)vcgtq_f32(v375, vabsq_f32((float32x4_t)vbslq_s8(v27, v28, (int8x16_t)vsubq_f32(v30, v29))));
        v32 = (float32x4_t)vextq_s8((int8x16_t)v383, (int8x16_t)v383, 8uLL);
        v33 = vandq_s8((int8x16_t)v16, v31);
        v34 = (int64x2_t)vextq_s8((int8x16_t)v23, v33, 0xCuLL);
        v35 = vdupq_laneq_s64(v34, 1).u64[0];
        v34.i64[0] = v23.i64[0];
        v23.i64[1] = v35;
        v36 = (float32x4_t)vbslq_s8(v26, (int8x16_t)vmaxq_f32((float32x4_t)vrev64q_s32((int32x4_t)v23), (float32x4_t)vextq_s8(v33, v33, 4uLL)), (int8x16_t)v34);
        v37 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v16, v383));
        v371 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
        v374 = vnegq_f32(v36);
        v38 = (int8x16_t)v36;
        v373 = v36;
        v40 = *(int8x16_t *)(v15 + 128);
        v39 = *(float32x4_t *)(v15 + 144);
        v41 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v374, (int8x16_t)v374, 0xCuLL), v39));
        v42 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 0);
        v44 = *(int8x16_t *)(v15 + 160);
        v43 = *(float32x4_t *)(v15 + 176);
        v45 = (int64x2_t)vbslq_s8(v40, (int8x16_t)vminq_f32(v371, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL)), vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v20, v32)));
        v46 = (float32x4_t)vcgtq_f32(v42, v43);
        v47 = a2[10];
        v48.i64[0] = 0x3F0000003F000000;
        v48.i64[1] = 0x3F0000003F000000;
        v49 = vaddq_f32(vsubq_f32(vaddq_f32(v383, (float32x4_t)vbslq_s8((int8x16_t)v46, (int8x16_t)v39, v44)), v5), v48);
        v50 = vcvtq_s32_f32(v49);
        v49.i64[0] = vaddq_s32(v50, vcgtq_f32(vcvtq_f32_s32(v50), v49)).u64[0];
        v51 = v49.i32[1];
        v52 = a2[11].i32[0];
        v53 = (int8x16_t)vcgtq_f32(v42, v39);
        v54 = (int8x16_t)vaddq_f32(v32, (float32x4_t)vbslq_s8(v53, v44, (int8x16_t)v43));
        v55 = v49.i32[0];
        v56 = vaddq_f32(vsubq_f32((float32x4_t)vextq_s8(v54, v54, 8uLL), v5), v48);
        v57 = (float32x4_t)vcvtq_s32_f32(v56);
        v56.i64[0] = vaddq_s32((int32x4_t)v57, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v57), v56)).u64[0];
        v57.i64[0] = vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL).u64[0];
        v58 = *(int32x4_t *)(v15 + 192);
        v59 = *(float32x4_t *)(v15 + 208);
        v46.i64[0] = vaddq_f32(v383, (float32x4_t)vbslq_s8((int8x16_t)v46, (int8x16_t)v58, (int8x16_t)v16)).u64[0];
        v60 = (float32x4_t)vbslq_s8(v53, (int8x16_t)v59, (int8x16_t)v58);
        v58.i64[0] = *(_QWORD *)(*(_QWORD *)&v47 + 16 * (v56.i32[0] + v56.i32[1] * v52));
        v61 = vext_s8(*(int8x8_t *)v58.i8, *(int8x8_t *)v57.f32, 4uLL);
        v62.i64[0] = v58.i64[0];
        v46.i64[1] = v60.i64[1];
        v62.i64[1] = v45.i64[1];
        *(int8x8_t *)v57.f32 = vext_s8(*(int8x8_t *)v57.f32, *(int8x8_t *)v58.i8, 4uLL);
        v63 = vaddq_f32(vsubq_f32(v46, v5), v48);
        v64 = vcvtq_s32_f32(v63);
        v58.i64[1] = vdupq_laneq_s64(v45, 1).u64[0];
        v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
        v65 = (float32x4_t)vrev64q_s32(v58);
        v66 = *(int8x16_t *)(*(_QWORD *)&v47 + 16 * (v63.i32[0] + v63.i32[1] * v52));
        v67 = (int8x16_t)vdupq_lane_s64(v62.i64[0], 0);
        v68 = (int32x4_t)vminq_f32(v65, v62);
        v69 = (float32x4_t)vdupq_laneq_s32(v68, 2);
        *(int8x8_t *)&v57.u32[2] = v61;
        v70 = vandq_s8((int8x16_t)v16, (int8x16_t)vcgeq_f32(vnegq_f32(v57), v59));
        *(int8x8_t *)v71.f32 = vext_s8(*(int8x8_t *)v70.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v68, (int8x16_t)v68, 8uLL), 4uLL);
        v72 = vextq_s8((int8x16_t)v68, v70, 0xCuLL).u64[0];
        v70.i64[1] = v68.i64[1];
        v73 = (float32x4_t)vextq_s8((int8x16_t)vaddq_f32(v32, v60), v66, 8uLL);
        v74 = vaddq_f32(vsubq_f32(v73, v5), v48);
        v75 = vcvtq_s32_f32(v74);
        v71.i64[1] = v72;
        v74.i64[0] = vaddq_s32(v75, vcgtq_f32(vcvtq_f32_s32(v75), v74)).u64[0];
        v76 = (int64x2_t)vbslq_s8(v40, vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v383, (int8x16_t)v383, 0xCuLL), (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)vsubq_f32((float32x4_t)vdupq_laneq_s64(*(int64x2_t *)v15, 1), v16), 8uLL))), (int8x16_t)v45);
        v77 = *(float32x4_t *)(*(_QWORD *)&v47 + 16 * (v74.i32[0] + v74.i32[1] * v52));
        v78 = vbslq_s8(v26, (int8x16_t)vminq_f32(v71, v65), v70);
        v65.i64[0] = vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL).u64[0];
        *(int8x8_t *)v71.f32 = vext_s8(*(int8x8_t *)v65.f32, *(int8x8_t *)v77.f32, 4uLL);
        *(int8x8_t *)v65.f32 = vext_s8(*(int8x8_t *)v77.f32, *(int8x8_t *)v65.f32, 4uLL);
        v77.i64[1] = v76.i64[1];
        v65.i64[1] = v71.i64[0];
        v80 = *(int8x16_t *)(v15 + 224);
        v79 = *(float32x4_t *)(v15 + 240);
        v81 = (int8x16_t)vcgtq_f32(v69, v39);
        v82 = (int32x4_t)vbslq_s8(v80, (int8x16_t)vminq_f32(v65, (float32x4_t)vextq_s8(v78, v78, 8uLL)), v78);
        v83 = (float32x4_t)vdupq_laneq_s32(v82, 2);
        v56.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32(v83, v59), v66, *(int8x16_t *)(*(_QWORD *)&v47 + 16 * (v55 + v51 * v52))).u64[0];
        v66.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v83, v39), *(int8x16_t *)&v73, (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v77, 0)).i64[1];
        v84 = (int64x2_t)vbslq_s8(v81, (int8x16_t)vdupq_lane_s64(v66.i64[0], 0), v67);
        v56.i64[1] = v84.i64[1];
        v85 = (float32x4_t)vbslq_s8(v40, vandq_s8((int8x16_t)v43, (int8x16_t)vcgeq_f32(vnegq_f32(v77), v39)), (int8x16_t)v82);
        v86 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 1);
        v87 = (int8x16_t)vcgtq_f32(v86, v59);
        v88 = vbslq_s8((int8x16_t)vcgtq_f32(v86, v79), (int8x16_t)vdupq_laneq_s64(v84, 1), v66);
        v89 = (int32x4_t)vbslq_s8(v26, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v85), v85), (int8x16_t)v85);
        v378 = v26;
        v30.i64[0] = vsubq_f32(v30, v16).u64[0];
        v30.i64[1] = v84.i64[1];
        v90 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v89, 3), v79), v88, vbslq_s8(v87, (int8x16_t)vdupq_laneq_s64((int64x2_t)v56, 1), (int8x16_t)v56));
        *(int8x8_t *)&v37.u32[2] = vand_s8(*(int8x8_t *)v16.f32, (int8x8_t)*(_OWORD *)&vcgeq_f32(vnegq_f32(v37), v79));
        v56.i64[0] = v90.i64[0];
        v91 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v383, v30))), (int8x16_t)v37);
        v372 = (float32x4_t)vextq_s8(v38, v38, 8uLL);
        v56.i64[1] = v76.i64[1];
        v92 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vminq_f32(v372, (float32x4_t)vextq_s8((int8x16_t)v91, (int8x16_t)v91, 4uLL)), (int8x16_t)v89);
        v93 = (float32x4_t)vrev64q_s32((int32x4_t)vminq_f32(v92, v91));
        v94 = (float32x4_t)vrev64q_s32((int32x4_t)vminq_f32(v92, v93));
        v95 = (int32x4_t)vbslq_s8(v27, (int8x16_t)v93, (int8x16_t)v94);
        v96 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3), v79), (int8x16_t)v84, v88);
        v97 = (float32x4_t)vbslq_s8(v26, (int8x16_t)vminq_f32(v56, (float32x4_t)vextq_s8((int8x16_t)v95, (int8x16_t)v95, 4uLL)), (int8x16_t)v92);
        v98 = vextq_s8(v96, v88, 8uLL);
        v99 = (int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3), v79);
        v100 = (float32x4_t)vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL);
        v101 = vbslq_s8(v27, (int8x16_t)vminq_f32(v100, (float32x4_t)vrev64q_s32(v95)), (int8x16_t)v94);
        v90.i64[0] = vbslq_s8(v99, v90, v98).u64[0];
        v102 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vminq_f32((float32x4_t)vextq_s8(v101, v101, 0xCuLL), v97), (int8x16_t)v97);
        v103 = vbslq_s8(v99, (int8x16_t)v100, v98);
        v104 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.i8, 0);
        v90.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&v102, 3), v79), *(int8x16_t *)&v100, *(int8x16_t *)&v84).i64[1];
        v105 = (int8x16_t)vcgtq_f32(v104, v79);
        v106 = vbslq_s8(v105, v90, (int8x16_t)v56);
        v107 = vextq_s8(v90, v90, 8uLL);
        v94.i64[0] = vandq_s8((int8x16_t)v16, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32((int32x4_t)v91)), v79)).u64[0];
        v94.i64[1] = v76.i64[1];
        v108 = vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v102), v94);
        v109 = vbslq_s8(v105, v107, v103);
        v103.i64[0] = v108.i64[0];
        v110 = (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v108, 8uLL);
        v108.i64[1] = vdupq_laneq_s64(v76, 1).u64[0];
        v103.i64[1] = v76.i64[1];
        v111 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vminq_f32(v110, (float32x4_t)vrev64q_s32((int32x4_t)v108)), v103);
        v364 = v80;
        v103.i64[0] = v106.i64[0];
        v103.i64[1] = v109.i64[1];
        v112 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 2);
        v113 = (float32x4_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v111.f32, 1), v79);
        v48.i64[0] = vbslq_s8((int8x16_t)v113, v103, v90).u64[0];
        v114 = vbslq_s8((int8x16_t)vcgtq_f32(v79, vminq_f32(vnegq_f32(v112), vnegq_f32(v104))), v107, v90);
        v115 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v112, v79), (int8x16_t)vdupq_lane_s64(v106.i64[0], 0), v103);
        v116 = vextq_s8((int8x16_t)v115, v106, 8uLL);
        v117 = (int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(v111, v102), 0), (float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 2)), v79);
        v102.i64[0] = vminq_f32(v41, v102).u64[0];
        v102.i64[1] = v115.i64[1];
        v110.i64[0] = vbslq_s8((int8x16_t)v113, v116, vextq_s8(v114, v114, 8uLL)).u64[0];
        v369 = v48.i64[0];
        v370 = vbslq_s8(v117, (int8x16_t)vdupq_lane_s64(v48.i64[0], 0), v116);
        v118 = (float32x4_t)vextq_s8((int8x16_t)v111, (int8x16_t)v111, 8uLL);
        v368 = (int32x4_t)vbslq_s8(v117, (int8x16_t)vdupq_lane_s64(v110.i64[0], 0), (int8x16_t)v102);
        v119 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v102, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v41), v118));
        v48.i64[1] = v370.i64[1];
        v120 = vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL);
        v110.i64[1] = v368.i64[1];
        v366 = (int8x16_t)v110;
        v121 = vextq_s8((int8x16_t)v110, (int8x16_t)v110, 8uLL);
        v67.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v119.f32, 1), v79), v121, v120).u64[0];
        v122 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(v118, v119), 0), v79), (int8x16_t)v48, (int8x16_t)v110);
        v123 = *(float32x4_t *)(*(_QWORD *)&v6 + v13);
        v124 = vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v123), v25);
        v125 = (int8x16_t)vmulq_lane_f32(vmulq_f32(v124, v124), *(float32x2_t *)v25.f32, 1);
        v126 = vaddq_f32(vmaxq_f32((float32x4_t)vextq_s8(v125, v125, 8uLL), v25), (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL));
        v127 = *(float32x4_t *)(v15 + 256);
        v128 = *(float32x4_t *)(v15 + 272);
        v129 = vminq_f32(vmulq_f32(vrsqrteq_f32(v126), v127), v128);
        v130 = (int8x16_t)vmulq_f32(v126, vminq_f32(vmulq_f32(v129, vrsqrtsq_f32(vmulq_f32(v126, v129), v129)), v128));
        v131 = (float32x4_t)vextq_s8(v130, v130, 4uLL);
        v132 = vbslq_s8(v27, (int8x16_t)v41, vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v123, v131)));
        v129.i64[0] = v67.i64[0];
        v129.i64[1] = vextq_s8(v122, v122, 8uLL).u64[0];
        v382 = *(int8x16_t *)(v15 + 288);
        *(int8x8_t *)v115.f32 = vqtbl1_s8((int8x16_t)v129, *(int8x8_t *)v382.i8);
        v365 = (int8x8_t)vextq_s8(v382, v382, 8uLL).u64[0];
        *(int8x8_t *)&v115.u32[2] = vqtbl1_s8((int8x16_t)v129, v365);
        v133 = (int32x4_t)vminq_f32((float32x4_t)vextq_s8(v132, v132, 8uLL), (float32x4_t)vextq_s8(v132, v132, 0xCuLL));
        v134 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0);
        v135 = vaddq_f32(v134, v115);
        v136 = v134;
        v381 = v134;
        v379 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3);
        v380 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2);
        v137 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v133, 2), v79), (int8x16_t)vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v135, v135), *(float32x2_t *)v25.f32, 1), v380)), (int8x16_t)v79);
        v377 = *(int8x16_t *)(v15 + 304);
        *(int8x8_t *)v108.f32 = vqtbl1_s8((int8x16_t)v129, *(int8x8_t *)v377.i8);
        v361 = (int8x8_t)vextq_s8(v377, v377, 8uLL).u64[0];
        *(int8x8_t *)&v108.u32[2] = vqtbl1_s8((int8x16_t)v129, v361);
        v138 = vrsqrteq_f32(v137);
        v139 = vminq_f32(v138, v127);
        v140 = vminq_f32(vmulq_f32(v139, vrsqrtsq_f32(vmulq_f32(v137, v139), v139)), v127);
        v141 = vminq_f32(v138, v128);
        v142 = vminq_f32(vmulq_f32(v141, vrsqrtsq_f32(vmulq_f32(v137, v141), v141)), v128);
        v143 = vminq_f32(vmulq_f32(v142, vrsqrtsq_f32(vmulq_f32(v137, v142), v142)), v128);
        v142.i64[0] = vmulq_f32(v137, vminq_f32(vmulq_f32(v140, vrsqrtsq_f32(vmulq_f32(v137, v140), v140)), v127)).u64[0];
        v142.i64[1] = vmulq_f32(v137, v143).i64[1];
        v140.i64[0] = v132.i64[0];
        v140.i64[1] = v133.i64[1];
        v144 = (float32x4_t)vextq_s8((int8x16_t)v133, v132, 8uLL);
        v145 = *(float32x4_t *)(v15 + 320);
        v146 = *(float32x4_t *)(v15 + 336);
        v147 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v115, v142));
        v148 = vminq_f32(v147, (float32x4_t)vrev64q_s32((int32x4_t)v147));
        v149.i64[0] = v148.i64[0];
        v149.i64[1] = v147.i64[1];
        v113.i64[0] = vminq_f32(v149, (float32x4_t)vextq_s8((int8x16_t)v147, (int8x16_t)v148, 8uLL)).u64[0];
        v149.i64[0] = vextq_s8((int8x16_t)v147, (int8x16_t)v147, 8uLL).u64[0];
        *(float32x2_t *)v148.f32 = vmin_f32(*(float32x2_t *)v148.f32, *(float32x2_t *)v149.f32);
        *(int8x8_t *)v134.f32 = vext_s8(*(int8x8_t *)v148.f32, *(int8x8_t *)v149.f32, 4uLL);
        *(int8x8_t *)v148.f32 = vext_s8(*(int8x8_t *)v149.f32, *(int8x8_t *)v148.f32, 4uLL);
        v113.i64[1] = v147.i64[1];
        v148.i64[1] = v134.i64[0];
        v150 = vminq_f32(v113, v148);
        v151 = vaddq_f32(v136, v108);
        v152 = vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v151, v151), *(float32x2_t *)v25.f32, 1), v380));
        v153 = vminq_f32(vrsqrteq_f32(v152), v127);
        v154 = vminq_f32(vmulq_f32(v153, vrsqrtsq_f32(vmulq_f32(v152, v153), v153)), v127);
        v154.i64[0] = vmulq_f32(v152, vminq_f32(vmulq_f32(v154, vrsqrtsq_f32(vmulq_f32(v152, v154), v154)), v127)).u64[0];
        v113.i64[0] = v154.i64[0];
        v113.i64[1] = v152.i64[1];
        v155 = vminq_f32(vrsqrteq_f32(v113), v128);
        v156 = vminq_f32(vmulq_f32(v155, vrsqrtsq_f32(vmulq_f32(v155, v113), v155)), v128);
        v154.i64[1] = vmulq_f32(v152, vminq_f32(vmulq_f32(v156, vrsqrtsq_f32(vmulq_f32(v113, v156), v156)), v128)).i64[1];
        v157 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v108, v154));
        v113.i64[0] = vminq_f32(v157, (float32x4_t)vrev64q_s32((int32x4_t)v157)).u64[0];
        v113.i64[1] = v157.i64[1];
        v158 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v150), v128))), (int8x16_t)v113);
        v159 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v158, (float32x4_t)vextq_s8((int8x16_t)v158, (int8x16_t)v158, 8uLL)), (int8x16_t)v158);
        v67.i64[1] = v122.i64[1];
        v160 = (float32x4_t)vextq_s8((int8x16_t)v159, (int8x16_t)v159, 8uLL);
        v161 = (float32x4_t)vrev64q_s32(v159);
        v162 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v144, v161), vbslq_s8(v40, (int8x16_t)vminq_f32(v160, v161), v67));
        v163 = (float32x4_t)vbslq_s8(v378, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v162, (int8x16_t)v162, 4uLL), v127), (int8x16_t)v127, (int8x16_t)vrev64q_s32(v162)), (int8x16_t)v140);
        v164 = *(float32x4_t *)(v15 + 384);
        v362 = *(float32x4_t *)(v15 + 400);
        v363 = (int8x16_t)v123;
        v165 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v91.f32, 1), vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v163.f32, 0), (float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 2))), v164), v120, v121);
        v160.i64[0] = vsubq_f32(v123, v131).u64[0];
        v160.i64[1] = v130.i64[1];
        *(int8x8_t *)v110.f32 = vqtbl1_s8((int8x16_t)v162, *(int8x8_t *)v377.i8);
        *(int8x8_t *)&v110.u32[2] = vqtbl1_s8((int8x16_t)v162, v361);
        v166 = *(float32x4_t *)(v15 + 352);
        v167 = *(float32x4_t *)(v15 + 368);
        v168 = vminq_f32(vmaxq_f32(vrecpeq_f32(v110), v146), v166);
        v169 = vminq_f32(vmaxq_f32(vmulq_f32(v168, vrecpsq_f32(v110, v168)), v146), v166);
        v170 = vmulq_f32(vmulq_lane_f32(v115, *(float32x2_t *)v123.f32, 1), vmulq_f32(v169, vrecpsq_f32(v110, v169)));
        v171 = vmulq_f32(v167, v170);
        v172 = vaddq_f32(v171, (float32x4_t)vextq_s8((int8x16_t)v171, (int8x16_t)v171, 4uLL));
        v367 = (float32x4_t)vrev64q_s32((int32x4_t)v163);
        v173 = vbslq_s8(v378, (int8x16_t)vminq_f32(v367, v163), (int8x16_t)v160);
        v174 = (float32x4_t)vbslq_s8(v27, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8(v173, v173, 0xCuLL), v128), (int8x16_t)vaddq_f32(v172, (float32x4_t)vextq_s8((int8x16_t)v172, (int8x16_t)v172, 8uLL)), (int8x16_t)v128), v173);
        v175 = vaddq_f32(v108, v154);
        v176 = vsubq_f32(v108, v154);
        v177 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v123, (int8x16_t)v123, 0xCuLL), v174), (int8x16_t)v174);
        v178 = vminq_f32(vmaxq_f32(vrecpeq_f32(v175), v146), v166);
        v179 = vminq_f32(vmaxq_f32(vmulq_f32(v178, vrecpsq_f32(v175, v178)), v146), v166);
        v180 = vmulq_f32(vmulq_f32(v179, vrecpsq_f32(v175, v179)), vmulq_lane_f32(vsubq_f32(v142, v115), *(float32x2_t *)v177.f32, 1));
        v181 = vminq_f32(vmaxq_f32(vrecpeq_f32(v176), v146), v166);
        v182 = vminq_f32(vmaxq_f32(vmulq_f32(v181, vrecpsq_f32(v176, v181)), v146), v166);
        v183 = vmulq_f32(vmulq_f32(v182, vrecpsq_f32(v176, v182)), vmulq_laneq_f32(vaddq_f32(v115, v142), v177, 2));
        v184 = vaddq_f32(v170, v180);
        v185 = vsubq_f32(v170, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v177.f32, 0));
        v186 = vsubq_f32(v183, v170);
        v187 = vmulq_f32(v185, v185);
        v188 = vaddq_f32(v187, (float32x4_t)vextq_s8((int8x16_t)v187, (int8x16_t)v187, 4uLL));
        v189 = vmulq_f32(v184, v186);
        v190 = vaddq_f32(v189, (float32x4_t)vextq_s8((int8x16_t)v189, (int8x16_t)v189, 4uLL));
        v191 = vaddq_f32(v190, (float32x4_t)vextq_s8((int8x16_t)v190, (int8x16_t)v190, 8uLL));
        v192 = vmulq_f32(v115, v167);
        v193 = vaddq_f32(v192, (float32x4_t)vextq_s8((int8x16_t)v192, (int8x16_t)v192, 4uLL));
        v91.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(v163, v91), 0), v79), v366, (int8x16_t)v48).u64[0];
        v113.i64[0] = v91.i64[0];
        v113.i64[1] = vextq_s8(v165, v165, 8uLL).u64[0];
        v194 = (float32x4_t)vbslq_s8(v378, (int8x16_t)vaddq_f32(v193, (float32x4_t)vextq_s8((int8x16_t)v193, (int8x16_t)v193, 8uLL)), (int8x16_t)v177);
        v195 = vsubq_f32(v115, (float32x4_t)vdupq_laneq_s32((int32x4_t)v194, 3));
        *(int8x8_t *)v123.f32 = vqtbl1_s8((int8x16_t)v113, *(int8x8_t *)v382.i8);
        *(int8x8_t *)&v123.u32[2] = vqtbl1_s8((int8x16_t)v113, v365);
        v196 = vmulq_f32(v195, v195);
        v197 = vaddq_f32(v196, (float32x4_t)vextq_s8((int8x16_t)v196, (int8x16_t)v196, 4uLL));
        v198 = (int8x16_t)vaddq_f32(vaddq_f32(v188, (float32x4_t)vextq_s8((int8x16_t)v188, (int8x16_t)v188, 8uLL)), vmulq_f32(v164, v191));
        v199 = vmulq_f32(v137, v362);
        v200 = vaddq_f32(v199, (float32x4_t)vextq_s8((int8x16_t)v199, (int8x16_t)v199, 4uLL));
        v201 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v177, (int8x16_t)v177, 0xCuLL), v128), v198, (int8x16_t)v128);
        v202 = vaddq_f32(v381, v123);
        v203 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v163, 2), v79), (int8x16_t)vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v202, v202), *(float32x2_t *)v25.f32, 1), v380)), (int8x16_t)v79);
        v204 = (float32x4_t)vbslq_s8(v27, v201, (int8x16_t)vaddq_f32(v197, (float32x4_t)vextq_s8((int8x16_t)v197, (int8x16_t)v197, 8uLL)));
        v205 = vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v200, (float32x4_t)vextq_s8((int8x16_t)v200, (int8x16_t)v200, 8uLL))), v204);
        *(int8x8_t *)v137.f32 = vqtbl1_s8((int8x16_t)v113, *(int8x8_t *)v377.i8);
        *(int8x8_t *)&v137.u32[2] = vqtbl1_s8((int8x16_t)v113, v361);
        v206 = vminq_f32(vrsqrteq_f32(v203), v166);
        v207 = vminq_f32(vmulq_f32(v206, vrsqrtsq_f32(vmulq_f32(v203, v206), v206)), v166);
        v208 = vmulq_f32(v203, vminq_f32(vmulq_f32(v207, vrsqrtsq_f32(vmulq_f32(v203, v207), v207)), v166));
        v209 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v123, v208));
        v210 = vminq_f32(v209, (float32x4_t)vrev64q_s32((int32x4_t)v209));
        v156.i64[0] = v210.i64[0];
        v156.i64[1] = v209.i64[1];
        v156.i64[0] = vminq_f32(v156, (float32x4_t)vextq_s8((int8x16_t)v209, (int8x16_t)v210, 8uLL)).u64[0];
        v48.i64[0] = vextq_s8((int8x16_t)v209, (int8x16_t)v209, 8uLL).u64[0];
        *(float32x2_t *)v210.f32 = vmin_f32(*(float32x2_t *)v210.f32, *(float32x2_t *)v48.f32);
        *(int8x8_t *)v38.i8 = vext_s8(*(int8x8_t *)v210.f32, *(int8x8_t *)v48.f32, 4uLL);
        *(int8x8_t *)v210.f32 = vext_s8(*(int8x8_t *)v48.f32, *(int8x8_t *)v210.f32, 4uLL);
        v156.i64[1] = v209.i64[1];
        v210.i64[1] = v38.i64[0];
        v211 = vminq_f32(v156, v210);
        v212 = vaddq_f32(v381, v137);
        v213 = vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v212, v212), *(float32x2_t *)v25.f32, 1), v380));
        v214 = vminq_f32(vrsqrteq_f32(v213), v166);
        v215 = vminq_f32(vmulq_f32(v214, vrsqrtsq_f32(vmulq_f32(v213, v214), v214)), v166);
        v215.i64[0] = vmulq_f32(v213, vminq_f32(vmulq_f32(v215, vrsqrtsq_f32(vmulq_f32(v213, v215), v215)), v166)).u64[0];
        v48.i64[0] = v215.i64[0];
        v48.i64[1] = v213.i64[1];
        v216 = vminq_f32(vrsqrteq_f32(v48), v166);
        v217 = vminq_f32(vmulq_f32(v216, vrsqrtsq_f32(vmulq_f32(v216, v48), v216)), v166);
        v215.i64[1] = vmulq_f32(v213, vminq_f32(vmulq_f32(v217, vrsqrtsq_f32(vmulq_f32(v48, v217), v217)), v166)).i64[1];
        v218 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v137, v215));
        v48.i64[0] = vminq_f32(v218, (float32x4_t)vrev64q_s32((int32x4_t)v218)).u64[0];
        v48.i64[1] = v218.i64[1];
        v219 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v211), v128))), (int8x16_t)v48);
        v220 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v219, (float32x4_t)vextq_s8((int8x16_t)v219, (int8x16_t)v219, 8uLL)), (int8x16_t)v219);
        v91.i64[1] = v165.i64[1];
        v221 = (float32x4_t)vrev64q_s32(v220);
        v222 = vbslq_s8(v40, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v220, (int8x16_t)v220, 8uLL), v221), (int8x16_t)v91);
        v223 = (float32x4_t)vextq_s8((int8x16_t)v163, (int8x16_t)v163, 8uLL);
        v224 = (float32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v223, v221), v222);
        v205.i64[1] = vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v204, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v381, *(int8x16_t *)&v205, 0xCuLL)).i64[1];
        v225 = (float32x4_t)vbslq_s8(v27, vbslq_s8((int8x16_t)vcgtq_f32(v224, v128), (int8x16_t)v128, vextq_s8((int8x16_t)v224, (int8x16_t)v224, 8uLL)), (int8x16_t)v205);
        *(int8x8_t *)v205.f32 = vqtbl1_s8((int8x16_t)v224, *(int8x8_t *)v377.i8);
        *(int8x8_t *)&v205.u32[2] = vqtbl1_s8((int8x16_t)v224, v361);
        v226 = vminq_f32(vmaxq_f32(vrecpeq_f32(v205), v146), v166);
        v227 = vminq_f32(vmaxq_f32(vmulq_f32(v226, vrecpsq_f32(v205, v226)), v146), v166);
        v228 = vmulq_f32(vmulq_lane_f32(v123, *(float32x2_t *)v363.i8, 1), vmulq_f32(v227, vrecpsq_f32(v205, v227)));
        v229 = vmulq_f32(v167, v228);
        v230 = vaddq_f32(v229, (float32x4_t)vextq_s8((int8x16_t)v229, (int8x16_t)v229, 4uLL));
        v231 = vminq_f32(v223, v225);
        v232 = vbslq_s8((int8x16_t)vcgtq_f32(v231, v128), (int8x16_t)vaddq_f32(v230, (float32x4_t)vextq_s8((int8x16_t)v230, (int8x16_t)v230, 8uLL)), (int8x16_t)v128);
        v233 = vaddq_f32(v137, v215);
        v234 = vsubq_f32(v137, v215);
        v235 = vminq_f32(vmaxq_f32(vrecpeq_f32(v233), v146), v166);
        v236 = vminq_f32(vmaxq_f32(vmulq_f32(v235, vrecpsq_f32(v233, v235)), v146), v166);
        v237 = vmulq_f32(vmulq_lane_f32(vsubq_f32(v208, v123), *(float32x2_t *)v194.f32, 1), vmulq_f32(v236, vrecpsq_f32(v233, v236)));
        v238 = vminq_f32(vmaxq_f32(vrecpeq_f32(v234), v146), v166);
        v239 = (int32x4_t)vbslq_s8(v378, vextq_s8(v232, v232, 4uLL), (int8x16_t)v225);
        v240 = vminq_f32(vmaxq_f32(vmulq_f32(v238, vrecpsq_f32(v234, v238)), v146), v166);
        v241 = vmulq_f32(vmulq_laneq_f32(vaddq_f32(v123, v208), v194, 2), vmulq_f32(v240, vrecpsq_f32(v234, v240)));
        v242 = vaddq_f32(v228, v237);
        v243 = vsubq_f32(v241, v228);
        v244 = vsubq_f32(v228, (float32x4_t)vdupq_laneq_s32(v239, 3));
        v245 = vmulq_f32(v242, v243);
        v246 = vaddq_f32(v245, (float32x4_t)vextq_s8((int8x16_t)v245, (int8x16_t)v245, 4uLL));
        v247 = vmulq_f32(v244, v244);
        v248 = vaddq_f32(v247, (float32x4_t)vextq_s8((int8x16_t)v247, (int8x16_t)v247, 4uLL));
        v249 = vmulq_f32(v167, v123);
        v250 = vaddq_f32(v249, (float32x4_t)vextq_s8((int8x16_t)v249, (int8x16_t)v249, 4uLL));
        v248.i64[0] = vbslq_s8(v27, (int8x16_t)vaddq_f32(v250, (float32x4_t)vdupq_laneq_s64((int64x2_t)v250, 1)), (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v248, (float32x4_t)vdupq_laneq_s64((int64x2_t)v248, 1))), vmulq_n_f32(v362, vaddq_f32(v246, (float32x4_t)vdupq_laneq_s32((int32x4_t)v246, 2)).f32[0]))).u64[0];
        v251 = vsubq_f32(v123, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v248.f32, 0));
        v252 = vmulq_f32(v251, v251);
        v253 = vaddq_f32(v252, (float32x4_t)vextq_s8((int8x16_t)v252, (int8x16_t)v252, 4uLL));
        v254 = (int8x16_t)vrev64q_s32(v368);
        v254.i64[0] = vaddq_f32(v253, (float32x4_t)vdupq_laneq_s64((int64x2_t)v253, 1)).u64[0];
        v255 = vmulq_f32(v362, v203);
        v256 = vaddq_f32(v255, (float32x4_t)vextq_s8((int8x16_t)v255, (int8x16_t)v255, 4uLL));
        v257 = (int32x4_t)vaddq_f32(v256, (float32x4_t)vdupq_lane_s64(v256.i64[0], 0));
        v258 = (float32x4_t)vbslq_s8(v40, vbslq_s8((int8x16_t)vcgtq_f32(v163, v164), vextq_s8((int8x16_t)v239, (int8x16_t)v239, 8uLL), (int8x16_t)v164), v254);
        v248.i64[1] = v257.i64[1];
        v257.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v257, 1), v258).u64[0];
        v254.i64[0] = v257.i64[0];
        v254.i64[1] = v258.i64[1];
        v257.i64[1] = vdupq_laneq_s64((int64x2_t)v258, 1).u64[0];
        v259 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v248, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v231), v164), (int8x16_t)v248, (int8x16_t)v164));
        v260 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v257), v259), v254);
        v261 = (float32x4_t)vrev64q_s32((int32x4_t)v260);
        v262 = vminq_f32(vmaxq_f32(vrecpeq_f32(v261), v146), v166);
        v263 = vminq_f32(vmaxq_f32(vmulq_f32(v262, vrecpsq_f32(v261, v262)), v146), v166);
        v261.i64[0] = vmulq_f32(vmulq_f32(v263, vrecpsq_f32(v261, v263)), v260).u64[0];
        v263.i64[0] = vextq_s8((int8x16_t)v260, (int8x16_t)v260, 8uLL).u64[0];
        *(int8x8_t *)v250.f32 = vext_s8(*(int8x8_t *)v263.f32, *(int8x8_t *)v261.f32, 4uLL);
        *(int8x8_t *)v263.f32 = vext_s8(*(int8x8_t *)v261.f32, *(int8x8_t *)v263.f32, 4uLL);
        v261.i64[1] = v260.i64[1];
        v263.i64[1] = v250.i64[0];
        v264 = (float32x4_t)vbslq_s8(v364, vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v263), v164)), (int8x16_t)v261);
        v265 = (float32x4_t)vbslq_s8(v27, (int8x16_t)vaddq_f32(vmulq_f32(vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v239, (int8x16_t)v239, 0xCuLL), v259), v264), v259), (int8x16_t)v264);
        v266 = (int32x4_t)vbslq_s8(v364, (int8x16_t)vminq_f32(v367, v265), (int8x16_t)v265);
        v267 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v266), v128), (int8x16_t)v259, (int8x16_t)v266);
        v268 = (float32x4_t)vbslq_s8(v27, v267, (int8x16_t)v239);
        v269 = vminq_f32(vmaxq_f32(vrecpeq_f32(v268), v146), v166);
        v270 = vminq_f32(vmaxq_f32(vmulq_f32(v269, vrecpsq_f32(v268, v269)), v146), v166);
        v271 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vmulq_lane_f32(vmulq_f32(v270, vrecpsq_f32(v268, v270)), *(float32x2_t *)v268.f32, 1), (int8x16_t)v266);
        v272 = (float32x4_t)vextq_s8((int8x16_t)v163, (int8x16_t)v163, 0xCuLL);
        v270.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32(v223, v128), (int8x16_t)v272, (int8x16_t)v128).u64[0];
        v270.i64[1] = v271.i64[1];
        v273 = (float32x4_t)vextq_s8((int8x16_t)v194, (int8x16_t)v194, 0xCuLL);
        v274 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v194, v273), v271, 2), v273);
        v275 = (int32x4_t)vbslq_s8(v27, v274, (int8x16_t)vminq_f32(v367, (float32x4_t)vbslq_s8(v27, v274, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v270), v128))))));
        v276 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v275), v128), (int8x16_t)v273, (int8x16_t)v275);
        v274.i64[0] = v369;
        v274.i64[1] = vextq_s8(v370, v370, 8uLL).u64[0];
        v277 = vbslq_s8(v40, (int8x16_t)vminq_f32(v371, v272), v366);
        v278 = vmvnq_s8(v40);
        v279 = (int32x4_t)vbslq_s8(v27, v276, v277);
        *(int8x8_t *)v277.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v271, (int8x16_t)v271, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v278, v278, 8uLL)), vand_s8(*(int8x8_t *)v277.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)));
        *(int8x8_t *)v271.f32 = vqtbl1_s8(v274, *(int8x8_t *)v382.i8);
        v271.i64[1] = v277.i64[0];
        v280 = vaddq_f32(v381, v271);
        v281 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v279, 2), v79), (int8x16_t)vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v280, v280), *(float32x2_t *)v25.f32, 1), v380)), (int8x16_t)v79);
        v282 = vminq_f32(vrsqrteq_f32(v281), v166);
        v283 = vminq_f32(vmulq_f32(v282, vrsqrtsq_f32(vmulq_f32(v282, v281), v282)), v166);
        *(int8x8_t *)v250.f32 = vqtbl1_s8(v274, v361);
        *(int8x8_t *)v208.f32 = vqtbl1_s8(v274, *(int8x8_t *)v377.i8);
        v231.i64[0] = v208.i64[0];
        *(int8x8_t *)&v231.u32[2] = vqtbl1_s8((int8x16_t)v279, v361);
        v284 = vaddq_f32(v381, v231);
        v285 = vmulq_f32(vminq_f32(vmulq_f32(v283, vrsqrtsq_f32(vmulq_f32(v283, v281), v283)), v166), v281);
        v286 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v271, v285));
        v287 = (int8x16_t)vminq_f32(v286, (float32x4_t)vrev64q_s32((int32x4_t)v286));
        v238.i64[0] = v287.i64[0];
        v238.i64[1] = v286.i64[1];
        v288 = vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v284, v284), *(float32x2_t *)v25.f32, 1), v380));
        v238.i64[0] = vminq_f32(v238, (float32x4_t)vextq_s8((int8x16_t)v286, v287, 8uLL)).u64[0];
        v238.i64[1] = v286.i64[1];
        v286.i64[0] = vextq_s8((int8x16_t)v286, (int8x16_t)v286, 8uLL).u64[0];
        *(float32x2_t *)v287.i8 = vmin_f32(*(float32x2_t *)v287.i8, *(float32x2_t *)v286.f32);
        *(int8x8_t *)v25.f32 = vext_s8(*(int8x8_t *)v287.i8, *(int8x8_t *)v286.f32, 4uLL);
        *(int8x8_t *)v286.f32 = vext_s8(*(int8x8_t *)v286.f32, *(int8x8_t *)v287.i8, 4uLL);
        v286.i64[1] = v25.i64[0];
        v289 = vminq_f32(v238, v286);
        v290 = vminq_f32(vrsqrteq_f32(v288), v166);
        v291 = vminq_f32(vmulq_f32(v290, vrsqrtsq_f32(vmulq_f32(v288, v290), v290)), v166);
        v292 = vmulq_f32(v288, vminq_f32(vmulq_f32(v291, vrsqrtsq_f32(vmulq_f32(v288, v291), v291)), v166));
        v293 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v231, v292));
        v238.i64[0] = vminq_f32(v293, (float32x4_t)vrev64q_s32((int32x4_t)v293)).u64[0];
        v238.i64[1] = v293.i64[1];
        v294 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v289), v128))), (int8x16_t)v238);
        v295 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v294, (float32x4_t)vextq_s8((int8x16_t)v294, (int8x16_t)v294, 8uLL)), (int8x16_t)v294);
        v296 = (float32x4_t)vrev64q_s32(v295);
        v297 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v279, (int8x16_t)v279, 8uLL), v296), (int8x16_t)vminq_f32(v296, (float32x4_t)vextq_s8((int8x16_t)v295, (int8x16_t)v295, 8uLL)));
        *(int8x8_t *)v293.f32 = vqtbl1_s8((int8x16_t)v279, *(int8x8_t *)v377.i8);
        v293.i64[1] = v231.i64[1];
        v298 = vminq_f32(vmaxq_f32(vrecpeq_f32(v293), v146), v166);
        v299 = vminq_f32(vmaxq_f32(vmulq_f32(v298, vrecpsq_f32(v293, v298)), v146), v166);
        v300 = (int32x4_t)vbslq_s8(v364, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v297), v164), (int8x16_t)v164, (int8x16_t)v297), (int8x16_t)v279);
        v208.i64[1] = v250.i64[0];
        v301 = vminq_f32(vmaxq_f32(vrecpeq_f32(v208), v146), v166);
        v302 = vminq_f32(vmaxq_f32(vmulq_f32(v301, vrecpsq_f32(v208, v301)), v146), v166);
        v302.i64[0] = vmulq_f32(v302, vrecpsq_f32(v208, v302)).u64[0];
        v302.i64[1] = vmulq_f32(v299, vrecpsq_f32(v293, v299)).i64[1];
        v303 = vmulq_f32(v302, vmulq_lane_f32(v271, *(float32x2_t *)v363.i8, 1));
        v304 = (float32x4_t)vbslq_s8(v378, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32(v300), (float32x4_t)vextq_s8((int8x16_t)v300, (int8x16_t)v300, 8uLL)), (int8x16_t)v300);
        v305 = vmulq_f32(v167, v303);
        v306 = vaddq_f32(v305, (float32x4_t)vextq_s8((int8x16_t)v305, (int8x16_t)v305, 4uLL));
        v307 = vaddq_f32(v231, v292);
        v308 = vsubq_f32(v231, v292);
        v309 = vminq_f32(vmaxq_f32(vrecpeq_f32(v307), v146), v166);
        v310 = vminq_f32(vmaxq_f32(vmulq_f32(v309, vrecpsq_f32(v307, v309)), v146), v166);
        v311 = vmulq_f32(v310, vrecpsq_f32(v307, v310));
        v312 = (float32x4_t)vextq_s8((int8x16_t)v304, (int8x16_t)v304, 0xCuLL);
        v313 = vmulq_f32(v311, vmulq_lane_f32(vsubq_f32(v285, v271), *(float32x2_t *)v194.f32, 1));
        v314 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v312, v128), (int8x16_t)vaddq_f32(v306, (float32x4_t)vextq_s8((int8x16_t)v306, (int8x16_t)v306, 8uLL)), (int8x16_t)v128);
        v315 = vminq_f32(vmaxq_f32(vrecpeq_f32(v308), v146), v166);
        v316 = vminq_f32(vmaxq_f32(vmulq_f32(v315, vrecpsq_f32(v308, v315)), v146), v166);
        v317 = vmulq_f32(vmulq_f32(v316, vrecpsq_f32(v308, v316)), vmulq_laneq_f32(vaddq_f32(v271, v285), v194, 2));
        v318 = vsubq_f32(v303, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v314.f32, 0));
        v319 = vmulq_f32(vaddq_f32(v303, v313), vsubq_f32(v317, v303));
        v320 = vaddq_f32(v319, (float32x4_t)vextq_s8((int8x16_t)v319, (int8x16_t)v319, 4uLL));
        v321 = vmulq_f32(v318, v318);
        v322 = vaddq_f32(v321, (float32x4_t)vextq_s8((int8x16_t)v321, (int8x16_t)v321, 4uLL));
        v323 = vmulq_f32(v167, v271);
        v324 = vaddq_f32(v323, (float32x4_t)vextq_s8((int8x16_t)v323, (int8x16_t)v323, 4uLL));
        v320.i64[0] = vbslq_s8(v27, (int8x16_t)vaddq_f32(v324, (float32x4_t)vdupq_laneq_s64((int64x2_t)v324, 1)), (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v322, (float32x4_t)vdupq_laneq_s64((int64x2_t)v322, 1))), vmulq_n_f32(v362, vaddq_f32(v320, (float32x4_t)vdupq_laneq_s32((int32x4_t)v320, 2)).f32[0]))).u64[0];
        v325 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_f32(v304, v164), (int8x16_t)v312, (int8x16_t)v164);
        v11 = 0uLL;
        v326 = vsubq_f32(v271, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v320.f32, 0));
        v327 = vmulq_f32(v326, v326);
        v328 = vmulq_f32(v362, v281);
        v329 = vaddq_f32(v328, (float32x4_t)vextq_s8((int8x16_t)v328, (int8x16_t)v328, 4uLL));
        v330 = vaddq_f32(v327, (float32x4_t)vextq_s8((int8x16_t)v327, (int8x16_t)v327, 4uLL));
        v331 = (int64x2_t)vaddq_f32(v329, (float32x4_t)vdupq_lane_s64(v329.i64[0], 0));
        v320.i64[1] = v331.i64[1];
        v330.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s64(v331, 1), vaddq_f32(v330, (float32x4_t)vdupq_laneq_s64((int64x2_t)v330, 1))).u64[0];
        v331.i64[0] = v330.i64[0];
        v332 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v320, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v304, (int8x16_t)v304, 8uLL), v164), (int8x16_t)v320, (int8x16_t)v164));
        v331.i64[1] = v325.i64[1];
        v330.i64[1] = vdupq_laneq_s64(v325, 1).u64[0];
        v333 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v330), v332), (int8x16_t)v331);
        v334 = (float32x4_t)vrev64q_s32((int32x4_t)v333);
        v335 = vminq_f32(vmaxq_f32(vrecpeq_f32(v334), v146), v166);
        v336 = vminq_f32(vmaxq_f32(vmulq_f32(v335, vrecpsq_f32(v334, v335)), v146), v166);
        v334.i64[0] = vmulq_f32(vmulq_f32(v336, vrecpsq_f32(v334, v336)), v333).u64[0];
        v336.i64[0] = vextq_s8((int8x16_t)v333, (int8x16_t)v333, 8uLL).u64[0];
        *(int8x8_t *)v324.f32 = vext_s8(*(int8x8_t *)v336.f32, *(int8x8_t *)v334.f32, 4uLL);
        *(int8x8_t *)v336.f32 = vext_s8(*(int8x8_t *)v334.f32, *(int8x8_t *)v336.f32, 4uLL);
        v334.i64[1] = v333.i64[1];
        v336.i64[1] = v324.i64[0];
        v337 = vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v336), v164));
        v338 = (int8x16_t)vaddq_f32(vmulq_f32(vsubq_f32(v314, v332), (float32x4_t)vbslq_s8(v27, (int8x16_t)v334, v337)), v332);
        v339 = (float32x4_t)vbslq_s8(v27, v338, (int8x16_t)vminq_f32(v372, (float32x4_t)vbslq_s8(v27, v338, v337)));
        v340 = vbslq_s8((int8x16_t)vcgtq_f32(v339, v164), (int8x16_t)vrev64q_s32((int32x4_t)v332), (int8x16_t)vrev64q_s32((int32x4_t)v339));
        v341 = (float32x4_t)vbslq_s8(v27, (int8x16_t)vmulq_f32(v375, *(float32x4_t *)v15), v340);
        v342 = vcvtq_f32_s32(vcvtq_s32_f32(v341));
        v340.i64[0] = vbslq_s8(v27, (int8x16_t)vsubq_f32(v342, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v342, v341), (int8x16_t)v145, (int8x16_t)0)), v340).u64[0];
        v343 = vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(v374, v164));
        v342.i64[0] = vextq_s8(v343, v343, 8uLL).u64[0];
        *(int8x8_t *)v336.f32 = vext_s8(*(int8x8_t *)v342.f32, *(int8x8_t *)v340.i8, 4uLL);
        *(int8x8_t *)v342.f32 = vext_s8(*(int8x8_t *)v340.i8, *(int8x8_t *)v342.f32, 4uLL);
        v340.i64[1] = v343.i64[1];
        v342.i64[1] = v336.i64[0];
        v344 = (float32x4_t)vbslq_s8(v378, (int8x16_t)vsubq_f32(v372, v342), v340);
        v345 = (int32x4_t)vbslq_s8(v40, (int8x16_t)vminq_f32(v371, v344), (int8x16_t)v344);
        v346 = vbslq_s8(v40, (int8x16_t)vminq_f32(v371, v373), vbslq_s8(v27, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v345, (int8x16_t)v345, 8uLL), v128), (int8x16_t)vrev64q_s32(v345), v363), (int8x16_t)v345));
        v347 = (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8(v346, v346, 4uLL), v164);
        v5 = v360;
        v348 = vbslq_s8(v364, vbslq_s8(v347, v346, vextq_s8(v363, v363, 4uLL)), v346);
        v349 = (float32x4_t)vbslq_s8(v27, vandq_s8((int8x16_t)vcagtq_f32(v375, (float32x4_t)vextq_s8(v348, v348, 0xCuLL)), (int8x16_t)v145), v363);
        v350 = (int8x16_t)vminq_f32(v163, v349);
        v351 = (float32x4_t)vbslq_s8(v40, vextq_s8(v350, v350, 8uLL), (int8x16_t)v349);
        v350.i64[0] = vmvnq_s8(v27).u64[0];
        v352 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v351, 2);
        v353 = vbslq_s8(v27, (int8x16_t)vsubq_f32(vmulq_f32(v163, v351), v163), (int8x16_t)v351);
        *(int8x8_t *)v267.i8 = vorr_s8(vand_s8((int8x8_t)vrev64_s32(*(int32x2_t *)v304.f32), *(int8x8_t *)v350.i8), (int8x8_t)*(_OWORD *)&vandq_s8(v267, v27));
        *(int8x8_t *)v348.i8 = vbsl_s8((int8x8_t)*(_OWORD *)&vcgtq_f32(v352, v79), *(int8x8_t *)v267.i8, *(int8x8_t *)v348.i8);
        *(int8x8_t *)v267.i8 = vorr_s8(vand_s8((int8x8_t)vrev64_s32(*(int32x2_t *)v267.i8), *(int8x8_t *)v350.i8), vand_s8(*(int8x8_t *)v304.f32, *(int8x8_t *)v27.i8));
        v354.i64[0] = v267.u32[0];
        v354.i64[1] = v267.u32[1];
        v355 = v354;
        v354.i64[0] = v348.u32[0];
        v354.i64[1] = v348.u32[1];
        v356 = *(int8x16_t *)(v15 + 416);
        v357 = (float32x4_t)vbslq_s8(v356, vbslq_s8((int8x16_t)vcgtq_f32(v79, (float32x4_t)vdupq_lane_s64(v353.i64[0], 0)), v355, v354), v353);
        v354.i64[0] = v376;
        v354.i64[1] = DWORD1(v376);
        *(float32x4_t *)(*(_QWORD *)&v7 + v13) = vminq_f32(vmulq_f32((float32x4_t)vbslq_s8(v356, v354, (int8x16_t)v145), v357), v145);
        v12 = vaddq_f32(v383, (float32x4_t)xmmword_1B304F230);
        v13 += 16;
      }
      while (v10 != v13);
      v12 = vaddq_f32(v359, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v7 += v8;
      *(_QWORD *)&v6 += v9;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcDemosaic_2::GetDOD(HgcDemosaic_2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcDemosaic_2::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcDemosaic_2::HgcDemosaic_2(HgcDemosaic_2 *this)
{
  _QWORD *v2;
  uint64_t v3;
  __int128 v9;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6541720;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = xmmword_1B3052440;
  *(_OWORD *)(v3 + 64) = xmmword_1B30532D0;
  *(_OWORD *)(v3 + 80) = xmmword_1B3553A20;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 112) = xmmword_1B3050F70;
  *(_OWORD *)(v3 + 128) = xmmword_1B3050FE0;
  *(_OWORD *)(v3 + 144) = xmmword_1B3523FD0;
  *(_OWORD *)(v3 + 160) = xmmword_1B3553A30;
  *(_OWORD *)(v3 + 176) = xmmword_1B3553A40;
  *(_OWORD *)(v3 + 192) = xmmword_1B3553A50;
  *(_OWORD *)(v3 + 208) = xmmword_1B3053300;
  *(_OWORD *)(v3 + 224) = xmmword_1B3050FF0;
  *(_QWORD *)(v3 + 240) = 0;
  *(_QWORD *)(v3 + 248) = 0;
  *(_OWORD *)(v3 + 256) = xmmword_1B3553A60;
  *(_OWORD *)(v3 + 272) = xmmword_1B3553A70;
  *(_OWORD *)(v3 + 288) = xmmword_1B3553A80;
  *(_OWORD *)(v3 + 304) = xmmword_1B3553A90;
  __asm { FMOV            V0.4S, #1.0 }
  *(_QWORD *)&v9 = 0x80000000800000;
  *((_QWORD *)&v9 + 1) = 0x80000000800000;
  *(_OWORD *)(v3 + 320) = _Q0;
  *(_OWORD *)(v3 + 336) = v9;
  __asm { FMOV            V1.4S, #0.25 }
  *(int32x4_t *)(v3 + 352) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 368) = _Q1;
  __asm { FMOV            V1.4S, #0.75 }
  *(_OWORD *)(v3 + 384) = xmmword_1B3553AA0;
  *(_OWORD *)(v3 + 400) = _Q1;
  *(_QWORD *)&_Q0 = 0xFFFFFFFFLL;
  *((_QWORD *)&_Q0 + 1) = 0xFFFFFFFFLL;
  *(_OWORD *)(v3 + 416) = _Q0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcDemosaic_2 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BC6A00(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDemosaic_2::~HgcDemosaic_2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541720;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541720;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6541720;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4003455651);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcDemosaic_2::SetParameter(HgcDemosaic_2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcDemosaic_2::GetParameter(HgcDemosaic_2 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcWhiteBalanceRAW::GetProgram(HgcWhiteBalanceRAW *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000634\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(hg_Params[2].zw) - c0.xx;\n"
             "    r0.zw = half2(frag._texCoord0.xy) - half2(hg_Params[1].xy);\n"
             "    r0.zw = fmin(r0.zw, r0.xy);\n"
             "    r0.zw = fmax(r0.zw, c0.xx);\n"
             "    s0.xy = float2(r0.zw) + hg_Params[3].xy;\n"
             "    s0.xy = s0.xy*hg_Params[3].zw;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).x;\n"
             "    r0.zw = half2(frag._texCoord0.xy) - half2(hg_Params[2].xy);\n"
             "    r1.zw = half2(frag._texCoord0.xy) - half2(hg_Params[1].zw);\n"
             "    r0.zw = fmin(r0.xy, r0.zw);\n"
             "    r1.zw = fmin(r0.xy, r1.zw);\n"
             "    r0.xy = fmax(r0.zw, c0.xx);\n"
             "    r0.zw = fmax(r1.zw, c0.xx);\n"
             "    s0.xy = float2(r0.xy) + hg_Params[3].xy;\n"
             "    s0.xy = s0.xy*hg_Params[3].zw;\n"
             "    r1.z = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).z;\n"
             "    s0.xy = float2(r0.zw) + hg_Params[3].xy;\n"
             "    s0.xy = s0.xy*hg_Params[3].zw;\n"
             "    r1.y = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).y;\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].yzw);\n"
             "    output.color0.xyz = fmin(float3(r1.xyz), float3(c0.yyy));\n"
             "    output.color0.w = float(c0.y);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6698d57:f4cd57fc:1ac6cad7:05401ec0\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000005aa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Params[2].zw - c0.xx;\n"
             "    r0.zw = frag._texCoord0.xy - hg_Params[1].xy;\n"
             "    r0.zw = fmin(r0.zw, r0.xy);\n"
             "    r0.zw = fmax(r0.zw, c0.xx);\n"
             "    r1.xy = r0.zw + hg_Params[3].xy;\n"
             "    r1.xy = r1.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, r1.xy).x;\n"
             "    r0.zw = frag._texCoord0.xy - hg_Params[2].xy;\n"
             "    r1.zw = frag._texCoord0.xy - hg_Params[1].zw;\n"
             "    r0.zw = fmin(r0.xy, r0.zw);\n"
             "    r1.zw = fmin(r0.xy, r1.zw);\n"
             "    r0.xy = fmax(r0.zw, c0.xx);\n"
             "    r0.zw = fmax(r1.zw, c0.xx);\n"
             "    r2.xy = r0.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture0.sample(hg_Sampler0, r2.xy).z;\n"
             "    r0.xy = r0.zw + hg_Params[3].xy;\n"
             "    r0.xy = r0.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture0.sample(hg_Sampler0, r0.xy).y;\n"
             "    r1.xyz = r1.xyz - hg_Params[0].xxx;\n"
             "    r1.xyz = r1.xyz*hg_Params[0].yzw;\n"
             "    output.color0.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    output.color0.w = c0.y;\n"
             "    return output;\n"
             "}\n"
             "//MD5=23ff346a:c4a2d73b:0b76461a:7c8c8ac4\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005ef\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xy = hg_ProgramLocal2.zw - c0.xx;\n"
           "    r0.zw = hg_TexCoord0.xy - hg_ProgramLocal1.xy;\n"
           "    r0.zw = min(r0.zw, r0.xy);\n"
           "    r0.zw = max(r0.zw, c0.xx);\n"
           "    r1.xy = r0.zw + hg_ProgramLocal3.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal3.zw;\n"
           "    r1.x = texture2D(hg_Texture0, r1.xy).x;\n"
           "    r0.zw = hg_TexCoord0.xy - hg_ProgramLocal2.xy;\n"
           "    r1.zw = hg_TexCoord0.xy - hg_ProgramLocal1.zw;\n"
           "    r0.zw = min(r0.xy, r0.zw);\n"
           "    r1.zw = min(r0.xy, r1.zw);\n"
           "    r0.xy = max(r0.zw, c0.xx);\n"
           "    r0.zw = max(r1.zw, c0.xx);\n"
           "    r2.xy = r0.xy + hg_ProgramLocal3.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal3.zw;\n"
           "    r1.z = texture2D(hg_Texture0, r2.xy).z;\n"
           "    r0.xy = r0.zw + hg_ProgramLocal3.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal3.zw;\n"
           "    r1.y = texture2D(hg_Texture0, r0.xy).y;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.yzw;\n"
           "    gl_FragColor.xyz = min(r1.xyz, c0.yyy);\n"
           "    gl_FragColor.w = c0.y;\n"
           "}\n"
           "//MD5=b7fe7f36:69cec0c5:5dc0df38:8bfb24de\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcWhiteBalanceRAW::InitProgramDescriptor(HgcWhiteBalanceRAW *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcWhiteBalanceRAW_hgc_visible", "//Metal1.0     \n//LEN=00000004e3\n[[ visible ]] FragmentOut HgcWhiteBalanceRAW_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Params[2].zw - c0.xx;\n"
    "    r0.zw = texCoord0.xy - hg_Params[1].xy;\n"
    "    r0.zw = fmin(r0.zw, r0.xy);\n"
    "    r0.zw = fmax(r0.zw, c0.xx);\n"
    "    r1.xy = r0.zw + hg_Params[3].xy;\n"
    "    r1.xy = r1.xy*hg_Params[3].zw;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, r1.xy).x;\n"
    "    r0.zw = texCoord0.xy - hg_Params[2].xy;\n"
    "    r1.zw = texCoord0.xy - hg_Params[1].zw;\n"
    "    r0.zw = fmin(r0.xy, r0.zw);\n"
    "    r1.zw = fmin(r0.xy, r1.zw);\n"
    "    r0.xy = fmax(r0.zw, c0.xx);\n"
    "    r0.zw = fmax(r1.zw, c0.xx);\n"
    "    r2.xy = r0.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r1.z = hg_Texture0.sample(hg_Sampler0, r2.xy).z;\n"
    "    r0.xy = r0.zw + hg_Params[3].xy;\n"
    "    r0.xy = r0.xy*hg_Params[3].zw;\n"
    "    r1.y = hg_Texture0.sample(hg_Sampler0, r0.xy).y;\n"
    "    r1.xyz = r1.xyz - hg_Params[0].xxx;\n"
    "    r1.xyz = r1.xyz*hg_Params[0].yzw;\n"
    "    output.color0.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    output.color0.w = c0.y;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC6F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC6FC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC6FBCLL);
}

double HgcWhiteBalanceRAW::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcWhiteBalanceRAW [hgc1]");
  return *(double *)"alanceRAW [hgc1]";
}

uint64_t HgcWhiteBalanceRAW::BindTexture(HgcWhiteBalanceRAW *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 3, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcWhiteBalanceRAW::Bind(HgcWhiteBalanceRAW *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HgcWhiteBalanceRAW *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcWhiteBalanceRAW::RenderTile(HgcWhiteBalanceRAW *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  int32x2_t v7;
  float32x4_t v8;
  float32x4_t *v9;
  uint64_t v10;
  float32x4_t v11;
  int v12;
  float32x4_t *v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  uint64_t v17;
  float32x4_t v18;
  int64x2_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  int8x16_t v37;
  int8x16_t v38;
  float32x4_t v39;
  int32x2_t v40;
  uint64_t v41;
  float32x4_t v42;
  int32x4_t v43;
  float32x4_t *v44;
  float32x4_t v45;
  float32x4_t v46;
  uint64_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int32x4_t v50;
  float32x4_t v51;
  float32x4_t *v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  float32x4_t v59;
  float32x4_t *v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x4_t *v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int32x4_t v98;
  float32x4_t v99;
  float32x4_t *v100;
  int32x4_t v101;
  float32x4_t v102;
  float32x4_t *v103;
  float32x4_t v104;
  float32x4_t v105;
  int32x4_t v106;
  float32x4_t *v107;
  float32x4_t v108;
  int32x4_t v109;
  float32x4_t v110;
  int32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t *v116;
  float32x4_t v117;
  float32x2_t v118;
  float32x4_t *v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  int32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t *v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  int8x16_t v134;
  float32x4_t v135;
  int32x4_t v136;
  float32x4_t *v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  int32x4_t v141;
  float32x4_t *v142;
  float32x4_t v143;
  int8x16_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  uint64_t v161;
  uint64_t v162;
  float32x4_t v163;
  float32x4_t v164;
  int8x16_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  int32x2_t v171;
  float32x4_t v172;
  uint64_t v173;
  int32x4_t v174;
  float32x4_t *v175;
  uint64_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  int8x16_t v181;
  float32x4_t v182;
  float32x4_t v183;
  int32x4_t v184;
  float32x4_t *v185;
  float32x4_t v186;
  float32x4_t v187;
  int32x4_t v188;
  float32x4_t *v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v193;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = a2[2];
    v8 = (float32x4_t)xmmword_1B304F240;
    v9 = (float32x4_t *)(*(_QWORD *)&v7 + 32);
    v10 = 16 * a2[3].i32[0];
    v11 = v5;
    while (v6 < 4)
    {
      LODWORD(v161) = 0;
      v14 = v11;
      if (v6 > 0)
        goto LABEL_10;
LABEL_3:
      v11 = vaddq_f32(v11, v8);
      ++v4;
      v9 = (float32x4_t *)((char *)v9 + v10);
      *(_QWORD *)&v7 += v10;
      if (v4 == v3)
        return 0;
    }
    v12 = 0;
    v13 = v9;
    v193 = v11;
    v14 = v11;
    do
    {
      v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F230);
      v16 = vaddq_f32(v15, (float32x4_t)xmmword_1B304F230);
      v17 = *((_QWORD *)this + 51);
      v19 = *(int64x2_t *)(v17 + 32);
      v18 = *(float32x4_t *)(v17 + 48);
      v20 = vaddq_f32(v16, (float32x4_t)xmmword_1B304F230);
      v21 = (int8x16_t)vsubq_f32((float32x4_t)vdupq_laneq_s64(v19, 1), v18);
      v22 = *(float32x4_t *)(v17 + 16);
      *(float32x2_t *)v23.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v22.f32);
      v24.i64[0] = v21.i64[0];
      *(float32x2_t *)v25.f32 = vsub_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)v22.f32);
      v26.i64[0] = v21.i64[0];
      v24.i64[1] = v23.i64[0];
      v26.i64[1] = v25.i64[0];
      *(float32x2_t *)v27.f32 = vsub_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)v22.f32);
      v28.i64[0] = v21.i64[0];
      v28.i64[1] = v27.i64[0];
      *(float32x2_t *)v29.f32 = vsub_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v22.f32);
      v30.i64[0] = v21.i64[0];
      v30.i64[1] = v29.i64[0];
      v23.i64[1] = v21.i64[0];
      v25.i64[1] = v21.i64[0];
      v27.i64[1] = v21.i64[0];
      v29.i64[1] = v21.i64[0];
      v31 = vminq_f32(v24, v23);
      v32 = vminq_f32(v26, v25);
      v33 = vminq_f32(v28, v27);
      v34 = vminq_f32(v30, v29);
      v27.i64[0] = v21.i64[0];
      v27.i64[1] = v31.i64[1];
      v28.i64[0] = v21.i64[0];
      v29.i64[0] = v21.i64[0];
      v28.i64[1] = v32.i64[1];
      v29.i64[1] = v33.i64[1];
      v33.i64[0] = v21.i64[0];
      v33.i64[1] = v34.i64[1];
      v36 = *(float32x4_t *)(v17 + 64);
      v35 = *(int8x16_t *)(v17 + 80);
      v37 = (int8x16_t)vmaxq_f32(v27, v36);
      v38 = (int8x16_t)vmaxq_f32(v28, v36);
      v39 = (float32x4_t)vextq_s8((int8x16_t)vmaxq_f32(v29, v36), v21, 8uLL);
      v40 = a2[10];
      v41 = a2[11].i32[0];
      v42 = vsubq_f32((float32x4_t)vextq_s8(v37, v21, 8uLL), v5);
      v43 = vaddq_s32(vcvtq_s32_f32(v42), vcltzq_f32(v42));
      v42.i64[0] = vsubq_f32(v42, vcvtq_f32_s32(v43)).u64[0];
      v44 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v43.i32[0] + v43.i32[1] * (int)v41));
      v45 = *v44;
      v46 = v44[v41];
      v47 = (int)v41 + 1;
      v48 = vsubq_f32((float32x4_t)vextq_s8(v38, v21, 8uLL), v5);
      v49 = vsubq_f32(v44[v47], v46);
      v50 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
      v48.i64[0] = vsubq_f32(v48, vcvtq_f32_s32(v50)).u64[0];
      v51 = vmulq_n_f32(vsubq_f32(v44[1], *v44), v42.f32[0]);
      v52 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v50.i32[0] + v50.i32[1] * (int)v41));
      v53 = v52[v41];
      v54 = vaddq_f32(v45, v51);
      v55 = vmulq_n_f32(vsubq_f32(v52[v47], v53), v48.f32[0]);
      v56 = vsubq_f32(v39, v5);
      v57 = vaddq_f32(v46, vmulq_n_f32(v49, v42.f32[0]));
      v58 = vaddq_s32(vcvtq_s32_f32(v56), vcltzq_f32(v56));
      v59 = vaddq_f32(*v52, vmulq_n_f32(vsubq_f32(v52[1], *v52), v48.f32[0]));
      v56.i64[0] = vsubq_f32(v56, vcvtq_f32_s32(v58)).u64[0];
      v60 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v58.i32[0] + v58.i32[1] * (int)v41));
      v61 = vaddq_f32(v53, v55);
      v62 = vaddq_f32(*v60, vmulq_n_f32(vsubq_f32(v60[1], *v60), v56.f32[0]));
      v63 = vsubq_f32((float32x4_t)vextq_s8((int8x16_t)vmaxq_f32(v33, v36), v21, 8uLL), v5);
      v64 = vaddq_f32(v60[v41], vmulq_n_f32(vsubq_f32(v60[v47], v60[v41]), v56.f32[0]));
      v65 = vaddq_s32(vcvtq_s32_f32(v63), vcltzq_f32(v63));
      v63.i64[0] = vsubq_f32(v63, vcvtq_f32_s32(v65)).u64[0];
      v66 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v65.i32[0] + v65.i32[1] * (int)v41));
      v67 = vaddq_f32(*v66, vmulq_n_f32(vsubq_f32(v66[1], *v66), v63.f32[0]));
      *(float32x2_t *)v68.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v19.i8);
      v69.i64[0] = v21.i64[0];
      v69.i64[1] = v68.i64[0];
      v70 = vmulq_lane_f32(vsubq_f32(v61, v59), *(float32x2_t *)v48.f32, 1);
      *(float32x2_t *)v61.f32 = vsub_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)v19.i8);
      v71.i64[0] = v21.i64[0];
      v71.i64[1] = v61.i64[0];
      v72 = vmulq_lane_f32(vsubq_f32(v64, v62), *(float32x2_t *)v56.f32, 1);
      *(float32x2_t *)v64.f32 = vsub_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)v19.i8);
      v73.i64[0] = v21.i64[0];
      v73.i64[1] = v64.i64[0];
      *(float32x2_t *)v74.f32 = vsub_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v19.i8);
      v19.i64[0] = vaddq_f32(v54, vmulq_lane_f32(vsubq_f32(v57, v54), *(float32x2_t *)v42.f32, 1)).u64[0];
      v42.i64[0] = v21.i64[0];
      v42.i64[1] = v74.i64[0];
      v75 = (float32x4_t)vdupq_lane_s64(v14.i64[0], 0);
      v76.i64[0] = vaddq_f32(v59, v70).u64[0];
      v77 = (float32x4_t)vdupq_lane_s64(v15.i64[0], 0);
      v78 = (float32x4_t)vdupq_lane_s64(v16.i64[0], 0);
      v15.i64[0] = vaddq_f32(v62, v72).u64[0];
      v79 = vsubq_f32(v77, v22);
      v16.i64[0] = vaddq_f32(v67, vmulq_lane_f32(vsubq_f32(vaddq_f32(v66[v41], vmulq_n_f32(vsubq_f32(v66[v47], v66[v41]), v63.f32[0])), v67), *(float32x2_t *)v63.f32, 1)).u64[0];
      v63.i64[0] = v19.i64[0];
      v77.i64[0] = v76.i64[0];
      v63.i64[1] = vsubq_f32(v75, v22).i64[1];
      v77.i64[1] = v79.i64[1];
      v70.i64[0] = v15.i64[0];
      v79.i64[0] = v16.i64[0];
      v70.i64[1] = vsubq_f32(v78, v22).i64[1];
      v68.i64[1] = v21.i64[0];
      v61.i64[1] = v21.i64[0];
      v79.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v20, 0), v22).i64[1];
      v64.i64[1] = v21.i64[0];
      v74.i64[1] = v21.i64[0];
      v80 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v68, v69), v21, 8uLL);
      v81 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v61, v71), v21, 8uLL);
      v82 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v64, v73), v21, 8uLL);
      v83 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v74, v42), v21, 8uLL);
      v84 = vminq_f32(v81, v77);
      v77.i64[0] = v19.i64[0];
      v77.i64[1] = vminq_f32(v80, v63).i64[1];
      v63.i64[0] = v76.i64[0];
      v62.i64[0] = v15.i64[0];
      v63.i64[1] = v84.i64[1];
      v62.i64[1] = vminq_f32(v82, v70).i64[1];
      v84.i64[0] = v16.i64[0];
      v84.i64[1] = vminq_f32(v83, v79).i64[1];
      v85 = vmaxq_f32(v80, v18);
      v86 = vmaxq_f32(v81, v18);
      v87 = vmaxq_f32(v82, v18);
      v88 = vmaxq_f32(v83, v18);
      v89 = (int8x16_t)vmaxq_f32(v77, v36);
      v90 = (int8x16_t)vmaxq_f32(v63, v36);
      v91 = (int8x16_t)vmaxq_f32(v62, v36);
      v92 = (float32x4_t)vextq_s8(v89, (int8x16_t)v85, 8uLL);
      v93 = (float32x4_t)vextq_s8(v90, (int8x16_t)v86, 8uLL);
      v85.i64[1] = v89.i64[1];
      v86.i64[1] = v90.i64[1];
      v94 = (float32x4_t)vextq_s8(v91, (int8x16_t)v87, 8uLL);
      v87.i64[1] = v91.i64[1];
      v95 = (int8x16_t)vmaxq_f32(v84, v36);
      v96 = (float32x4_t)vextq_s8(v95, (int8x16_t)v88, 8uLL);
      v88.i64[1] = v95.i64[1];
      v97 = vsubq_f32(v85, v5);
      v98 = vaddq_s32(vcvtq_s32_f32(v97), vcltzq_f32(v97));
      v97.i64[0] = vsubq_f32(v97, vcvtq_f32_s32(v98)).u64[0];
      LODWORD(v66) = v98.i32[0] + v98.i32[1] * v41;
      v99 = vsubq_f32(v86, v5);
      v100 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (int)v66);
      v101 = vaddq_s32(vcvtq_s32_f32(v99), vcltzq_f32(v99));
      v99.i64[0] = vsubq_f32(v99, vcvtq_f32_s32(v101)).u64[0];
      v102 = v100[v41];
      v103 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v101.i32[0] + v101.i32[1] * (int)v41));
      v104 = vsubq_f32(v87, v5);
      v105 = v103[v41];
      v106 = vaddq_s32(vcvtq_s32_f32(v104), vcltzq_f32(v104));
      v104.i64[0] = vsubq_f32(v104, vcvtq_f32_s32(v106)).u64[0];
      v107 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v106.i32[0] + v106.i32[1] * (int)v41));
      v108 = vsubq_f32(v88, v5);
      v109 = vaddq_s32(vcvtq_s32_f32(v108), vcltzq_f32(v108));
      v110 = vsubq_f32(v92, v5);
      v111 = vaddq_s32(vcvtq_s32_f32(v110), vcltzq_f32(v110));
      v112 = *v103;
      v113 = vmulq_n_f32(vsubq_f32(v100[v47], v102), v97.f32[0]);
      v114 = vmulq_n_f32(vsubq_f32(v103[1], *v103), v99.f32[0]);
      v115 = vmulq_n_f32(vsubq_f32(v103[v47], v105), v99.f32[0]);
      v108.i64[0] = vsubq_f32(v108, vcvtq_f32_s32(v109)).u64[0];
      v116 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v109.i32[0] + v109.i32[1] * (int)v41));
      v117 = vaddq_f32(*v100, vmulq_n_f32(vsubq_f32(v100[1], *v100), v97.f32[0]));
      v118 = (float32x2_t)vsubq_f32(v110, vcvtq_f32_s32(v111)).u64[0];
      v119 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v111.i32[0] + v111.i32[1] * (int)v41));
      v120 = vaddq_f32(v102, v113);
      v121 = vaddq_f32(*v119, vmulq_n_f32(vsubq_f32(v119[1], *v119), v118.f32[0]));
      v122 = vaddq_f32(v112, v114);
      v123 = vaddq_f32(v105, v115);
      v124 = vsubq_f32(v93, v5);
      v125 = vaddq_f32(*v107, vmulq_n_f32(vsubq_f32(v107[1], *v107), v104.f32[0]));
      v126 = vaddq_s32(vcvtq_s32_f32(v124), vcltzq_f32(v124));
      v124.i64[0] = vsubq_f32(v124, vcvtq_f32_s32(v126)).u64[0];
      v127 = vsubq_f32(vaddq_f32(v119[v41], vmulq_n_f32(vsubq_f32(v119[v47], v119[v41]), v118.f32[0])), v121);
      v128 = vaddq_f32(*v116, vmulq_n_f32(vsubq_f32(v116[1], *v116), v108.f32[0]));
      v129 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v126.i32[0] + v126.i32[1] * (int)v41));
      v130 = vaddq_f32(*v129, vmulq_n_f32(vsubq_f32(v129[1], *v129), v124.f32[0]));
      v131 = vmulq_lane_f32(v127, v118, 1);
      v132 = v129[v41];
      v133 = vsubq_f32(v129[v47], v132);
      v134 = (int8x16_t)vaddq_f32(v121, v131);
      v135 = vsubq_f32(v94, v5);
      v136 = vaddq_s32(vcvtq_s32_f32(v135), vcltzq_f32(v135));
      v135.i64[0] = vsubq_f32(v135, vcvtq_f32_s32(v136)).u64[0];
      v137 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v136.i32[0] + v136.i32[1] * (int)v41));
      v138 = vaddq_f32(*v137, vmulq_n_f32(vsubq_f32(v137[1], *v137), v135.f32[0]));
      v139 = vaddq_f32(v125, vmulq_lane_f32(vsubq_f32(vaddq_f32(v107[v41], vmulq_n_f32(vsubq_f32(v107[v47], v107[v41]), v104.f32[0])), v125), *(float32x2_t *)v104.f32, 1));
      v140 = vsubq_f32(v96, v5);
      v141 = vaddq_s32(vcvtq_s32_f32(v140), vcltzq_f32(v140));
      v140.i64[0] = vsubq_f32(v140, vcvtq_f32_s32(v141)).u64[0];
      v19.i64[1] = vaddq_f32(v117, vmulq_lane_f32(vsubq_f32(v120, v117), *(float32x2_t *)&v97, 1)).i64[1];
      v142 = (float32x4_t *)(*(_QWORD *)&v40 + 16 * (v141.i32[0] + v141.i32[1] * (int)v41));
      v76.i64[1] = vaddq_f32(v122, vmulq_lane_f32(vsubq_f32(v123, v122), *(float32x2_t *)&v99, 1)).i64[1];
      v15.i64[1] = v139.i64[1];
      v143 = vaddq_f32(*v142, vmulq_n_f32(vsubq_f32(v142[1], *v142), v140.f32[0]));
      v16.i64[1] = vaddq_f32(v128, vmulq_lane_f32(vsubq_f32(vaddq_f32(v116[16 * v41], vmulq_n_f32(vsubq_f32(v116[v47 * 16], v116[16 * v41]), *(float *)&v108)), v128), *(float32x2_t *)&v108, 1)).i64[1];
      v144 = (int8x16_t)vaddq_f32(v143, vmulq_lane_f32(vsubq_f32(vaddq_f32(v142[v41], vmulq_n_f32(vsubq_f32(v142[v47], v142[v41]), v140.f32[0])), v143), *(float32x2_t *)v140.f32, 1));
      v145 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v138, vmulq_lane_f32(vsubq_f32(vaddq_f32(v137[v41], vmulq_n_f32(vsubq_f32(v137[v47], v137[v41]), v135.f32[0])), v138), *(float32x2_t *)v135.f32, 1)), (int8x16_t)v15);
      v146 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17, 0);
      v147 = vsubq_f32((float32x4_t)vbslq_s8(v35, v134, (int8x16_t)v19), v146);
      v148 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v130, vmulq_lane_f32(vsubq_f32(vaddq_f32(v132, vmulq_n_f32(v133, v124.f32[0])), v130), *(float32x2_t *)v124.f32, 1)), v76), v146);
      v149 = vsubq_f32(v145, v146);
      v150 = vsubq_f32((float32x4_t)vbslq_s8(v35, v144, (int8x16_t)v16), v146);
      v151 = (float32x4_t)vextq_s8(*(int8x16_t *)v17, *(int8x16_t *)v17, 4uLL);
      v152 = vmulq_f32(v151, v147);
      v153 = vmulq_f32(v151, v148);
      v154 = vmulq_f32(v151, v149);
      v155 = vmulq_f32(v151, v150);
      v156 = *(float32x4_t *)(v17 + 96);
      v157 = vminq_f32(v152, v156);
      v158 = vminq_f32(v153, v156);
      v159 = vminq_f32(v154, v156);
      v157.i32[3] = 1.0;
      v158.i32[3] = 1.0;
      v159.i32[3] = 1.0;
      v160 = vminq_f32(v155, v156);
      v160.i32[3] = 1.0;
      v13[-2] = v157;
      v13[-1] = v158;
      *v13 = v159;
      v13[1] = v160;
      v13 += 4;
      v14 = vaddq_f32(v20, (float32x4_t)xmmword_1B304F230);
      v12 -= 4;
    }
    while (v6 + v12 > 3);
    LODWORD(v161) = -v12;
    v8 = (float32x4_t)xmmword_1B304F240;
    v11 = v193;
    if ((int)v161 >= v6)
      goto LABEL_3;
LABEL_10:
    v161 = v161;
    do
    {
      v162 = *((_QWORD *)this + 51);
      v164 = *(float32x4_t *)(v162 + 32);
      v163 = *(float32x4_t *)(v162 + 48);
      v165 = (int8x16_t)vsubq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v164, 1), v163);
      v166 = *(float32x4_t *)(v162 + 16);
      *(float32x2_t *)v167.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v166.f32);
      v168.i64[0] = v165.i64[0];
      v168.i64[1] = v167.i64[0];
      v167.i64[1] = v165.i64[0];
      v169 = vminq_f32(v168, v167);
      v168.i64[0] = v165.i64[0];
      v168.i64[1] = v169.i64[1];
      v170 = *(float32x4_t *)(v162 + 64);
      v171 = a2[10];
      v172 = vsubq_f32((float32x4_t)vextq_s8((int8x16_t)vmaxq_f32(v168, v170), v165, 8uLL), v5);
      v173 = a2[11].i32[0];
      v174 = vaddq_s32(vcvtq_s32_f32(v172), vcltzq_f32(v172));
      v172.i64[0] = vsubq_f32(v172, vcvtq_f32_s32(v174)).u64[0];
      v175 = (float32x4_t *)(*(_QWORD *)&v171 + 16 * (v174.i32[0] + v174.i32[1] * (int)v173));
      v176 = (int)v173 + 1;
      v177 = vaddq_f32(*v175, vmulq_n_f32(vsubq_f32(v175[1], *v175), v172.f32[0]));
      *(float32x2_t *)v164.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v164.f32);
      v178.i64[0] = v165.i64[0];
      v178.i64[1] = v164.i64[0];
      v172.i64[0] = vaddq_f32(v177, vmulq_lane_f32(vsubq_f32(vaddq_f32(v175[v173], vmulq_n_f32(vsubq_f32(v175[v176], v175[v173]), v172.f32[0])), v177), *(float32x2_t *)v172.f32, 1)).u64[0];
      v177.i64[0] = v172.i64[0];
      v177.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v14, 0), v166).i64[1];
      v164.i64[1] = v165.i64[0];
      v179 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v164, v178), v165, 8uLL);
      v164.i64[0] = v172.i64[0];
      v164.i64[1] = vminq_f32(v179, v177).i64[1];
      v180 = vmaxq_f32(v179, v163);
      v181 = (int8x16_t)vmaxq_f32(v164, v170);
      v182 = (float32x4_t)vextq_s8(v181, (int8x16_t)v180, 8uLL);
      v180.i64[1] = v181.i64[1];
      v183 = vsubq_f32(v180, v5);
      v184 = vaddq_s32(vcvtq_s32_f32(v183), vcltzq_f32(v183));
      v183.i64[0] = vsubq_f32(v183, vcvtq_f32_s32(v184)).u64[0];
      v185 = (float32x4_t *)(*(_QWORD *)&v171 + 16 * (v184.i32[0] + v184.i32[1] * (int)v173));
      v186 = vaddq_f32(*v185, vmulq_n_f32(vsubq_f32(v185[1], *v185), v183.f32[0]));
      v187 = vsubq_f32(v182, v5);
      v188 = vaddq_s32(vcvtq_s32_f32(v187), vcltzq_f32(v187));
      v187.i64[0] = vsubq_f32(v187, vcvtq_f32_s32(v188)).u64[0];
      v189 = (float32x4_t *)(*(_QWORD *)&v171 + 16 * (v188.i32[0] + v188.i32[1] * (int)v173));
      v190 = vaddq_f32(*v189, vmulq_n_f32(vsubq_f32(v189[1], *v189), v187.f32[0]));
      v172.i64[1] = vaddq_f32(v186, vmulq_lane_f32(vsubq_f32(vaddq_f32(v185[16 * v173], vmulq_n_f32(vsubq_f32(v185[v176 * 16], v185[16 * v173]), *(float *)&v183)), v186), *(float32x2_t *)&v183, 1)).i64[1];
      v191 = vminq_f32(vmulq_f32((float32x4_t)vextq_s8(*(int8x16_t *)v162, *(int8x16_t *)v162, 4uLL), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v162 + 80), (int8x16_t)vaddq_f32(v190, vmulq_lane_f32(vsubq_f32(vaddq_f32(v189[v173], vmulq_n_f32(vsubq_f32(v189[v176], v189[v173]), v187.f32[0])), v190), *(float32x2_t *)v187.f32, 1)), (int8x16_t)v172), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v162, 0))), *(float32x4_t *)(v162 + 96));
      v191.i32[3] = 1.0;
      *(float32x4_t *)(*(_QWORD *)&v7 + 16 * v161) = v191;
      v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F230);
      ++v161;
    }
    while (v161 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcWhiteBalanceRAW::GetDOD(HgcWhiteBalanceRAW *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  HGRectGrow(v6, v5, v7);
  return 0x8000000080000000;
}

uint64_t HgcWhiteBalanceRAW::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;
  uint64_t DOD;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v9 = v8;
  v10 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(DOD, v9, v10);
}

void HgcWhiteBalanceRAW::HgcWhiteBalanceRAW(HgcWhiteBalanceRAW *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6541988;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = xmmword_1B3052100;
  v3[4] = xmmword_1B3553AC0;
  v3[5] = xmmword_1B3050FF0;
  v3[6] = xmmword_1B3051560;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcWhiteBalanceRAW *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BC7C78(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcWhiteBalanceRAW::~HgcWhiteBalanceRAW(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541988;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541988;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6541988;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AC4F46D1);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcWhiteBalanceRAW::SetParameter(HgcWhiteBalanceRAW *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcWhiteBalanceRAW::GetParameter(HgcWhiteBalanceRAW *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcRasterizerGenerator::GetProgram(HgcRasterizerGenerator *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000183\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0 = frag._color*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f0fb2d12:8a63952b:8c3e7840:9534b621\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0200:0000:0000:00:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000183\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0 = frag._color*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f0fb2d12:8a63952b:8c3e7840:9534b621\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0200:0000:0000:00:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000017b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "void main()\n"
           "{\n"
           "\n"
           "    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0)*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=5ce95289:5b0ceedb:528a5b25:059f4e88\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
  }
}

void HgcRasterizerGenerator::InitProgramDescriptor(HgcRasterizerGenerator *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRasterizerGenerator_hgc_visible", "//Metal1.0     \n//LEN=00000000ea\n[[ visible ]] FragmentOut HgcRasterizerGenerator_hgc_visible(const constant float4* hg_Params,\n    float4 color)\n{\n    FragmentOut output;\n"
    "\n"
    "    output.color0 = color*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC80D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC8104(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC80FCLL);
}

double HgcRasterizerGenerator::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552C30;
  strcpy(v3, "HgcRasterizerGenerator [hgc1]");
  return *(double *)"Generator [hgc1]";
}

uint64_t HgcRasterizerGenerator::BindTexture(HgcRasterizerGenerator *this, HGHandler *a2)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcRasterizerGenerator::Bind(HgcRasterizerGenerator *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcRasterizerGenerator *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcRasterizerGenerator::UnBind(HgcRasterizerGenerator *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerGenerator::RenderFragment(uint64_t a1, float32x4_t *a2, uint64_t a3)
{
  *(float32x4_t *)*(_QWORD *)(a3 + 16) = vmulq_f32(a2[9], *(float32x4_t *)*(_QWORD *)(a1 + 408));
  return 0;
}

uint64_t HgcRasterizerGenerator::RenderTile(HgcRasterizerGenerator *this, HGTile *a2)
{
  int v2;
  int v3;
  float32x4_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    v3 = 0;
    v4 = *(float32x4_t *)(*((_QWORD *)this + 51) + 16);
    v5 = *((_QWORD *)a2 + 2);
    v6 = 16 * *((int *)a2 + 6);
    v7 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      v8 = 0;
      do
      {
        *(float32x4_t *)(v5 + v8) = vmulq_f32(v4, *(float32x4_t *)*((_QWORD *)this + 51));
        v8 += 16;
      }
      while (v7 != v8);
      ++v3;
      v5 += v6;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcRasterizerGenerator::GetDOD(HgcRasterizerGenerator *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcRasterizerGenerator::GetROI(HgcRasterizerGenerator *this, HGRenderer *a2, int a3, HGRect a4)
{
  return 0;
}

uint64_t HgcRasterizerGenerator::GetProperty(HGNode *this, int a2, uint64_t a3)
{
  if (a2 == 20)
    return 1;
  else
    return HGNode::GetProperty(this, a2, a3);
}

void HgcRasterizerGenerator::HgcRasterizerGenerator(HgcRasterizerGenerator *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode3D::HGNode3D(this);
  *v2 = off_1E6541BF0;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 16) = _Q0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BC8328(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcRasterizerGenerator::~HgcRasterizerGenerator(HgcRasterizerGenerator *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541BF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541BF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6541BF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40E0EAB150);
  HGMipmapLevel::~HGMipmapLevel(this);
  HGObject::operator delete(v3);
}

uint64_t HgcRasterizerGenerator::SetParameter(HgcRasterizerGenerator *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRasterizerGenerator::GetParameter(HgcRasterizerGenerator *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcRasterizerTexture::GetProgram(HgcRasterizerTexture *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002e8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[5].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[5].zw);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, float2(r0.xy));\n"
             "    r0 = r0*half4(frag._color);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=e403a67b:687ef7e8:b76ee859:1a4e898a\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0202:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002af\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[5].xy;\n"
             "    r0.xy = r0.xy*hg_Params[5].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0 = r0*frag._color;\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=ed919563:adff3d10:d856f429:fd9e4277\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0202:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000342\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal5.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0 = r0*vec4(1.0, 1.0, 1.0, 1.0);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=18ef6ee5:2f79df4d:2199991e:ce4393d9\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcRasterizerTexture::InitProgramDescriptor(HgcRasterizerTexture *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRasterizerTexture_hgc_visible", "//Metal1.0     \n//LEN=00000001fc\n[[ visible ]] FragmentOut HgcRasterizerTexture_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 color,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[5].xy;\n"
    "    r0.xy = r0.xy*hg_Params[5].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0 = r0*color;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC894C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC8988(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC8980);
}

double HgcRasterizerTexture::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EF0;
  strcpy(v3, "HgcRasterizerTexture [hgc1]");
  return *(double *)"erTexture [hgc1]";
}

uint64_t HgcRasterizerTexture::BindTexture(HgcRasterizerTexture *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 5, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcRasterizerTexture::Bind(HgcRasterizerTexture *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t))(*(_QWORD *)a2 + 120))(a2, *((_QWORD *)this + 51) + 32);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HgcRasterizerTexture *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcRasterizerTexture::UnBind(HgcRasterizerTexture *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerTexture::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  int32x2_t v12;
  uint64_t v13;
  float32x4_t v14;
  int32x4_t v15;
  float32x2_t v16;
  float32x4_t *v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v21;
  float32x4_t v22;
  int32x4_t v23;

  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  v4 = a2[9];
  v5 = a2[1];
  v6 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 3);
  v7 = *(float32x4_t **)(a1 + 408);
  v8 = v7[10];
  v9 = v7[11];
  v10 = vminq_f32(vmaxq_f32(vrecpeq_f32(v6), v8), v9);
  v11 = vminq_f32(vmaxq_f32(vmulq_f32(v10, vrecpsq_f32(v6, v10)), v8), v9);
  v12 = a3[10];
  v13 = a3[11].i32[0];
  v14 = vsubq_f32(vmulq_f32(v5, vmulq_f32(v11, vrecpsq_f32(v6, v11))), v3);
  if (a2[14].i32[0])
  {
    v15 = vaddq_s32(vcvtq_s32_f32(v14), vcltzq_f32(v14));
    v16 = (float32x2_t)vsubq_f32(v14, vcvtq_f32_s32(v15)).u64[0];
    v17 = (float32x4_t *)(*(_QWORD *)&v12 + 16 * (v15.i32[0] + v15.i32[1] * (int)v13));
    v18 = vaddq_f32(*v17, vmulq_n_f32(vsubq_f32(v17[1], *v17), v16.f32[0]));
    v19 = vmulq_f32(v4, vaddq_f32(v18, vmulq_lane_f32(vsubq_f32(vaddq_f32(v17[v13], vmulq_n_f32(vsubq_f32(v17[(int)v13 + 1], v17[v13]), v16.f32[0])), v18), v16, 1)));
  }
  else
  {
    v21.i64[0] = 0x3F0000003F000000;
    v21.i64[1] = 0x3F0000003F000000;
    v22 = vaddq_f32(v14, v21);
    v23 = vcvtq_s32_f32(v22);
    v22.i64[0] = vaddq_s32(v23, vcgtq_f32(vcvtq_f32_s32(v23), v22)).u64[0];
    v19 = vmulq_f32(v4, *(float32x4_t *)(*(_QWORD *)&v12 + 16 * (v22.i32[0] + v22.i32[1] * (int)v13)));
  }
  *(float32x4_t *)*(_QWORD *)&a3[2] = vmulq_f32(v19, *v7);
  return 0;
}

uint64_t HgcRasterizerTexture::RenderTile(HgcRasterizerTexture *this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  uint64_t v8;
  float32x4_t v9;
  uint64_t v10;
  float32x4_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  int32x4_t v26;
  float32x4_t *v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int32x4_t v40;

  v4 = HGTile::Renderer(a2);
  v5 = (*(uint64_t (**)(HgcRasterizerTexture *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *(int32x2_t *)a2;
  v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v7 >= 1)
  {
    v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      v10 = *((_QWORD *)a2 + 2);
      v11 = *(float32x4_t *)(*((_QWORD *)this + 51) + 16);
      v12 = 0;
      v13 = 16 * *((int *)a2 + 6);
      v14 = 16 * v8;
      if (v5)
      {
        v15 = v9;
        do
        {
          v16 = 0;
          v17 = v15;
          do
          {
            v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 3);
            v19 = (float32x4_t *)*((_QWORD *)this + 51);
            v20 = v19[10];
            v21 = v19[11];
            v22 = vminq_f32(vmaxq_f32(vrecpeq_f32(v18), v20), v21);
            v23 = vminq_f32(vmaxq_f32(vmulq_f32(v22, vrecpsq_f32(v18, v22)), v20), v21);
            v24 = *((int *)a2 + 22);
            v25 = vsubq_f32(vmulq_f32(v17, vmulq_f32(v23, vrecpsq_f32(v18, v23))), v9);
            v26 = vaddq_s32(vcvtq_s32_f32(v25), vcltzq_f32(v25));
            v25.i64[0] = vsubq_f32(v25, vcvtq_f32_s32(v26)).u64[0];
            v27 = (float32x4_t *)(*((_QWORD *)a2 + 10) + 16 * (v26.i32[0] + v26.i32[1] * (int)v24));
            v28 = vaddq_f32(*v27, vmulq_n_f32(vsubq_f32(v27[1], *v27), v25.f32[0]));
            *(float32x4_t *)(v10 + v16) = vmulq_f32(vmulq_f32(v11, vaddq_f32(v28, vmulq_lane_f32(vsubq_f32(vaddq_f32(v27[v24], vmulq_n_f32(vsubq_f32(v27[(int)v24 + 1], v27[v24]), v25.f32[0])), v28), *(float32x2_t *)v25.f32, 1))), *v19);
            v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F230);
            v16 += 16;
          }
          while (v14 != v16);
          v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B304F240);
          ++v12;
          v10 += v13;
        }
        while (v12 != v7);
      }
      else
      {
        v29.i64[0] = 0x3F0000003F000000;
        v29.i64[1] = 0x3F0000003F000000;
        v30 = v9;
        do
        {
          v31 = 0;
          v32 = v30;
          do
          {
            v33 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 3);
            v34 = (float32x4_t *)*((_QWORD *)this + 51);
            v35 = v34[10];
            v36 = v34[11];
            v37 = vminq_f32(vmaxq_f32(vrecpeq_f32(v33), v35), v36);
            v38 = vminq_f32(vmaxq_f32(vmulq_f32(v37, vrecpsq_f32(v33, v37)), v35), v36);
            v39 = vaddq_f32(vsubq_f32(vmulq_f32(v32, vmulq_f32(v38, vrecpsq_f32(v33, v38))), v9), v29);
            v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
            *(float32x4_t *)(v10 + v31) = vmulq_f32(vmulq_f32(v11, *(float32x4_t *)(*((_QWORD *)a2 + 10)+ 16 * (v39.i32[0] + v39.i32[1] * *((_DWORD *)a2 + 22)))), *v34);
            v32 = vaddq_f32(v32, (float32x4_t)xmmword_1B304F230);
            v31 += 16;
          }
          while (v14 != v31);
          v30 = vaddq_f32(v30, (float32x4_t)xmmword_1B304F240);
          ++v12;
          v10 += v13;
        }
        while (v12 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcRasterizerTexture::GetDOD(HgcRasterizerTexture *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  const HGTransform *v6;
  uint64_t v8;
  uint64_t v9;
  HGTransformUtils *v10;
  float v11;
  uint64_t DOD;
  uint64_t v13;
  float64x2_t v15[9];
  HGRect v16;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(const HGTransform **)&a4.var0;
  if ((*(int (**)(HgcRasterizerTexture *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
  {
    v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v6 = (const HGTransform *)HGRectGrow((uint64_t)v6, v5, v8);
    v5 = v9;
  }
  HGTransform::HGTransform((HGTransform *)v15);
  HGTransform::LoadMatrixf(v15, (float32x2_t *)(*((_QWORD *)this + 51) + 32));
  HGTransform::Invert2D((HGTransform *)v15);
  v11 = HGTransformUtils::MinW(v10);
  *(_QWORD *)&v16.var0 = v5;
  DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v15, v6, v16, 0.5, v11);
  v4 = HGRectUnion(0, 0, DOD, v13);
  HGTransform::~HGTransform((HGTransform *)v15);
  return v4;
}

void sub_1B2BC900C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2BC9020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HgcRasterizerTexture::GetROI(HgcRasterizerTexture *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  HGTransformUtils *v9;
  float v10;
  uint64_t ROI;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float64x2_t v17[9];
  HGRect v18;

  v4 = 0;
  if (!a3)
  {
    v5 = *(_QWORD *)&a4.var2;
    v6 = *(_QWORD *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((_QWORD *)this + 51) + 32));
    v10 = HGTransformUtils::MinW(v9);
    *(_QWORD *)&v18.var0 = v5;
    ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v10);
    v4 = HGRectUnion(0, 0, ROI, v12);
    v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    if ((*(int (**)(HgcRasterizerTexture *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
    {
      v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(v4, v14, v15);
    }
  }
  return v4;
}

void sub_1B2BC9130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B2BC9144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HgcRasterizerTexture::GetProperty(HGNode *this, int a2, uint64_t a3)
{
  if (a2 == 20)
    return 1;
  else
    return HGNode::GetProperty(this, a2, a3);
}

void HgcRasterizerTexture::HgcRasterizerTexture(HgcRasterizerTexture *this)
{
  uint64_t v2;
  uint64_t v3;

  HGNode3D::HGNode3D(this);
  *(_QWORD *)v2 = off_1E6541E68;
  *(_DWORD *)(v2 + 416) = 1;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 16) = _Q0;
  *(_OWORD *)(v3 + 32) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 48) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 64) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 80) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 112) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 128) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 144) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 160) = xmmword_1B30527A0;
  *(int32x4_t *)(v3 + 176) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcRasterizerTexture *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BC9238(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcRasterizerTexture::~HgcRasterizerTexture(HgcRasterizerTexture *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541E68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6541E68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6541E68;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGMipmapLevel::~HGMipmapLevel(this);
  HGObject::operator delete(v3);
}

uint64_t HgcRasterizerTexture::SetParameter(HgcRasterizerTexture *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRasterizerTexture::GetParameter(HgcRasterizerTexture *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

double HgcRasterizerTexture::GetOutput(HgcRasterizerTexture *this, HGRenderer *a2)
{
  uint64_t v2;
  __int128 v3;
  double result;

  if (*((_DWORD *)this + 104))
  {
    v2 = *((_QWORD *)this + 51);
    v3 = *(_OWORD *)(v2 + 112);
    *(_OWORD *)(v2 + 32) = *(unint64_t *)(v2 + 96);
    *(_OWORD *)(*((_QWORD *)this + 51) + 48) = (unint64_t)v3;
    *(_OWORD *)(*((_QWORD *)this + 51) + 64) = xmmword_1B304F250;
    result = 0.0;
    *(_OWORD *)(*((_QWORD *)this + 51) + 80) = xmmword_1B304EFF0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcBlur_cs9s::GetProgram(HgcBlur_cs9s *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000ef3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[5].xy;\n"
             "    s0.xy = s0.xy + frag._texCoord0.xy;\n"
             "    s0.xy = s0.xy + hg_Params[6].xy;\n"
             "    s0.zw = s0.xy + hg_Params[7].xy;\n"
             "    s1.xy = s0.zw + hg_Params[7].xy;\n"
             "    s2.zw = s1.xy + hg_Params[7].xy;\n"
             "    s3.xy = s2.zw + hg_Params[7].xy;\n"
             "    s4.xy = s3.xy + hg_Params[7].xy;\n"
             "    s2.xy = s4.xy + hg_Params[7].xy;\n"
             "    s1.zw = s3.xy + hg_Params[8].xy;\n"
             "    s1.zw = s1.zw*hg_Params[8].zw;\n"
             "    s6.xy = s1.zw*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    s1.zw = s2.xy + hg_Params[8].xy;\n"
             "    s1.xy = s1.xy + hg_Params[8].xy;\n"
             "    s4.zw = s1.xy*hg_Params[8].zw;\n"
             "    s1.zw = s1.zw*hg_Params[8].zw;\n"
             "    s4.xy = s4.xy + hg_Params[8].xy;\n"
             "    s2.zw = s2.zw + hg_Params[8].xy;\n"
             "    s0.zw = s0.zw + hg_Params[8].xy;\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    s7.xy = s4.zw*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s6.xy = s1.zw*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    s4.xy = s4.xy*hg_Params[8].zw;\n"
             "    r2 = r0 + r2;\n"
             "    s2.zw = s2.zw*hg_Params[8].zw;\n"
             "    s7.xy = s2.zw*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s6.xy = s4.xy*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r3 = r0 + r3;\n"
             "    r3 = r3*half4(hg_Params[1]) + r1;\n"
             "    s5.xy = s2.xy + hg_Params[7].xy;\n"
             "    s5.zw = s5.xy + hg_Params[8].xy;\n"
             "    s5.zw = s5.zw*hg_Params[8].zw;\n"
             "    r2 = r2*half4(hg_Params[2]) + r3;\n"
             "    s0.zw = s0.zw*hg_Params[8].zw;\n"
             "    s7.xy = s0.zw*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s0.zw = s5.xy + hg_Params[7].xy;\n"
             "    s5.xy = s0.zw + hg_Params[8].xy;\n"
             "    s0.zw = s0.xy + hg_Params[8].xy;\n"
             "    s6.xy = s5.zw*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r4 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    s0.xy = s5.xy*hg_Params[8].zw;\n"
             "    s5.xy = s0.zw*hg_Params[8].zw;\n"
             "    r4 = r3 + r4;\n"
             "    r2 = r4*half4(hg_Params[3]) + r2;\n"
             "    s7.xy = s0.xy*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r5 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s6.xy = s5.xy*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r6 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r5 = r6 + r5;\n"
             "    output.color0 = float4(r5)*hg_Params[4] + float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8af31599:eb0d3a9d:b19e4849:d2105752\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:000a:000f:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000dcc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[5].xy;\n"
             "    r0.xy = r0.xy + frag._texCoord0.xy;\n"
             "    r0.xy = r0.xy + hg_Params[6].xy;\n"
             "    r0.zw = r0.xy + hg_Params[7].xy;\n"
             "    r1.xy = r0.zw + hg_Params[7].xy;\n"
             "    r3.zw = r1.xy + hg_Params[7].xy;\n"
             "    r2.xy = r3.zw + hg_Params[7].xy;\n"
             "    r4.xy = r2.xy + hg_Params[7].xy;\n"
             "    r3.xy = r4.xy + hg_Params[7].xy;\n"
             "    r1.zw = r2.xy + hg_Params[8].xy;\n"
             "    r1.zw = r1.zw*hg_Params[8].zw;\n"
             "    r6.xy = r1.zw*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r1.zw = r3.xy + hg_Params[8].xy;\n"
             "    r1.xy = r1.xy + hg_Params[8].xy;\n"
             "    r4.zw = r1.xy*hg_Params[8].zw;\n"
             "    r1.zw = r1.zw*hg_Params[8].zw;\n"
             "    r4.xy = r4.xy + hg_Params[8].xy;\n"
             "    r3.zw = r3.zw + hg_Params[8].xy;\n"
             "    r0.zw = r0.zw + hg_Params[8].xy;\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r7.xy = r4.zw*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r6.xy = r1.zw*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r4.xy = r4.xy*hg_Params[8].zw;\n"
             "    r1 = r5 + r1;\n"
             "    r3.zw = r3.zw*hg_Params[8].zw;\n"
             "    r7.xy = r3.zw*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r6.xy = r4.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r4 = r5 + r4;\n"
             "    r4 = r4*hg_Params[1] + r2;\n"
             "    r2.xy = r3.xy + hg_Params[7].xy;\n"
             "    r2.zw = r2.xy + hg_Params[8].xy;\n"
             "    r2.zw = r2.zw*hg_Params[8].zw;\n"
             "    r1 = r1*hg_Params[2] + r4;\n"
             "    r0.zw = r0.zw*hg_Params[8].zw;\n"
             "    r7.xy = r0.zw*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r0.zw = r2.xy + hg_Params[7].xy;\n"
             "    r2.xy = r0.zw + hg_Params[8].xy;\n"
             "    r0.zw = r0.xy + hg_Params[8].xy;\n"
             "    r6.xy = r2.zw*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0.xy = r2.xy*hg_Params[8].zw;\n"
             "    r2.xy = r0.zw*hg_Params[8].zw;\n"
             "    r3 = r4 + r3;\n"
             "    r1 = r3*hg_Params[3] + r1;\n"
             "    r7.xy = r0.xy*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r6.xy = r2.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0 = r2 + r0;\n"
             "    output.color0 = r0*hg_Params[4] + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2a372906:61260339:48778105:68017d9d\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:000a:0008:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000c12\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "uniform highp vec4 hg_ProgramLocal9;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy + hg_TexCoord0.xy;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal6.xy;\n"
           "    r0.zw = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r1.xy = r0.zw + hg_ProgramLocal7.xy;\n"
           "    r3.zw = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r3.zw + hg_ProgramLocal7.xy;\n"
           "    r4.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r3.xy = r4.xy + hg_ProgramLocal7.xy;\n"
           "    r1.zw = r2.xy + hg_ProgramLocal8.xy;\n"
           "    r1.zw = r1.zw*hg_ProgramLocal8.zw;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r1.zw;\n"
           "    r2 = texture2D(hg_Texture0, r6.xy);\n"
           "    r1.zw = r3.xy + hg_ProgramLocal8.xy;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal8.xy;\n"
           "    r4.zw = r1.xy*hg_ProgramLocal8.zw;\n"
           "    r1.zw = r1.zw*hg_ProgramLocal8.zw;\n"
           "    r4.xy = r4.xy + hg_ProgramLocal8.xy;\n"
           "    r3.zw = r3.zw + hg_ProgramLocal8.xy;\n"
           "    r0.zw = r0.zw + hg_ProgramLocal8.xy;\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r4.zw;\n"
           "    r5 = texture2D(hg_Texture0, r6.xy);\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r1.zw;\n"
           "    r1 = texture2D(hg_Texture0, r6.xy);\n"
           "    r4.xy = r4.xy*hg_ProgramLocal8.zw;\n"
           "    r1 = r5 + r1;\n"
           "    r3.zw = r3.zw*hg_ProgramLocal8.zw;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r3.zw;\n"
           "    r5 = texture2D(hg_Texture0, r6.xy);\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r4.xy;\n"
           "    r4 = texture2D(hg_Texture0, r6.xy);\n"
           "    r4 = r5 + r4;\n"
           "    r4 = r4*hg_ProgramLocal1 + r2;\n"
           "    r2.xy = r3.xy + hg_ProgramLocal7.xy;\n"
           "    r2.zw = r2.xy + hg_ProgramLocal8.xy;\n"
           "    r2.zw = r2.zw*hg_ProgramLocal8.zw;\n"
           "    r1 = r1*hg_ProgramLocal2 + r4;\n"
           "    r0.zw = r0.zw*hg_ProgramLocal8.zw;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r0.zw;\n"
           "    r4 = texture2D(hg_Texture0, r6.xy);\n"
           "    r0.zw = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r0.zw + hg_ProgramLocal8.xy;\n"
           "    r0.zw = r0.xy + hg_ProgramLocal8.xy;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r2.zw;\n"
           "    r3 = texture2D(hg_Texture0, r6.xy);\n"
           "    r0.xy = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r2.xy = r0.zw*hg_ProgramLocal8.zw;\n"
           "    r3 = r4 + r3;\n"
           "    r1 = r3*hg_ProgramLocal3 + r1;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r6.xy);\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r2.xy;\n"
           "    r2 = texture2D(hg_Texture0, r6.xy);\n"
           "    r0 = r2 + r0;\n"
           "    gl_FragColor = r0*hg_ProgramLocal4 + r1;\n"
           "}\n"
           "//MD5=55e7fd50:9f7d4509:b6988dd8:48d03ab1\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:000a:0007:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_cs9s::InitProgramDescriptor(HgcBlur_cs9s *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_cs9s_hgc_visible", "//Metal1.0     \n//LEN=0000000d1b\n[[ visible ]] FragmentOut HgcBlur_cs9s_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[5].xy;\n"
    "    r0.xy = r0.xy + texCoord0.xy;\n"
    "    r0.xy = r0.xy + hg_Params[6].xy;\n"
    "    r0.zw = r0.xy + hg_Params[7].xy;\n"
    "    r1.xy = r0.zw + hg_Params[7].xy;\n"
    "    r3.zw = r1.xy + hg_Params[7].xy;\n"
    "    r2.xy = r3.zw + hg_Params[7].xy;\n"
    "    r4.xy = r2.xy + hg_Params[7].xy;\n"
    "    r3.xy = r4.xy + hg_Params[7].xy;\n"
    "    r1.zw = r2.xy + hg_Params[8].xy;\n"
    "    r1.zw = r1.zw*hg_Params[8].zw;\n"
    "    r6.xy = r1.zw*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r1.zw = r3.xy + hg_Params[8].xy;\n"
    "    r1.xy = r1.xy + hg_Params[8].xy;\n"
    "    r4.zw = r1.xy*hg_Params[8].zw;\n"
    "    r1.zw = r1.zw*hg_Params[8].zw;\n"
    "    r4.xy = r4.xy + hg_Params[8].xy;\n"
    "    r3.zw = r3.zw + hg_Params[8].xy;\n"
    "    r0.zw = r0.zw + hg_Params[8].xy;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r7.xy = r4.zw*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r6.xy = r1.zw*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r4.xy = r4.xy*hg_Params[8].zw;\n"
    "    r1 = r5 + r1;\n"
    "    r3.zw = r3.zw*hg_Params[8].zw;\n"
    "    r7.xy = r3.zw*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r6.xy = r4.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r4 = r5 + r4;\n"
    "    r4 = r4*hg_Params[1] + r2;\n"
    "    r2.xy = r3.xy + hg_Params[7].xy;\n"
    "    r2.zw = r2.xy + hg_Params[8].xy;\n"
    "    r2.zw = r2.zw*hg_Params[8].zw;\n"
    "    r1 = r1*hg_Params[2] + r4;\n"
    "    r0.zw = r0.zw*hg_Params[8].zw;\n"
    "    r7.xy = r0.zw*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r0.zw = r2.xy + hg_Params[7].xy;\n"
    "    r2.xy = r0.zw + hg_Params[8].xy;\n"
    "    r0.zw = r0.xy + hg_Params[8].xy;\n"
    "    r6.xy = r2.zw*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0.xy = r2.xy*hg_Params[8].zw;\n"
    "    r2.xy = r0.zw*hg_Params[8].zw;\n"
    "    r3 = r4 + r3;\n"
    "    r1 = r3*hg_Params[3] + r1;\n"
    "    r7.xy = r0.xy*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r6.xy = r2.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0 = r2 + r0;\n"
    "    output.color0 = r0*hg_Params[4] + r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BC98CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BC9908(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BC9900);
}

void HgcBlur_cs9s::shaderDescription(char *a1@<X8>)
{
  a1[23] = 19;
  strcpy(a1, "HgcBlur_cs9s [hgc1]");
}

uint64_t HgcBlur_cs9s::BindTexture(HgcBlur_cs9s *this, HGHandler *a2, int a3)
{
  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 9, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_cs9s::Bind(HgcBlur_cs9s *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 8, *((_QWORD *)this + 51) + 128, 1);
  (*(void (**)(HgcBlur_cs9s *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlur_cs9s::RenderTile(HgcBlur_cs9s *this, int32x2_t *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v16;
  float32x2_t v17;
  float32x4_t v18;
  int32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int32x2_t v26;
  int32x2_t v27;
  int32x2_t v28;
  __int32 v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  int8x16_t v33;
  float32x4_t v34;
  int8x16_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int32x2_t v41;
  uint64_t v42;
  float32x2_t v43;
  float32x2_t v44;
  int32x2_t v45;
  float32x2_t v46;
  float32x4_t *v47;
  float32x4_t v48;
  float32x4_t v49;
  int32x2_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  int8x16_t v55;
  float32x2_t v56;
  int8x16_t v57;
  float32x2_t v58;
  float32x2_t v59;
  int32x2_t v60;
  float32x2_t v61;
  float32x2_t v62;
  int32x2_t v63;
  float32x2_t v64;
  int32x2_t v65;
  int32x2_t v66;
  __int32 v67;
  float32x4_t *v68;
  float32x4_t v69;
  uint64_t v70;
  float32x4_t v71;
  float32x4_t *v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x2_t v75;
  float32x2_t v76;
  int32x2_t v77;
  float32x4_t *v78;
  float32x2_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t *v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t v85;
  int32x2_t v86;
  float32x4_t *v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x2_t v90;
  float32x2_t v91;
  int32x2_t v92;
  float32x2_t v93;
  float32x4_t *v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x2_t v97;
  int32x2_t v98;
  int32x2_t v99;
  int32x2_t v100;
  float32x2_t v101;
  int32x2_t v102;
  int32x2_t v103;
  int32x2_t v104;
  __int32 v105;
  int8x16_t v106;
  int32x2_t v107;
  float32x4_t v108;
  int8x16_t v109;
  float32x2_t v110;
  float32x2_t v111;
  float32x2_t v112;
  int32x2_t v113;
  float32x2_t v114;
  float32x2_t v115;
  int32x2_t v116;
  float32x2_t v117;
  int32x2_t v118;
  float32x4_t *v119;
  uint64_t v120;
  float32x4_t v121;
  float32x4_t *v122;
  float32x4_t v123;

  v4 = HGTile::Renderer((HGTile *)a2);
  v5 = (*(uint64_t (**)(HgcBlur_cs9s *, uint64_t))(*(_QWORD *)this + 312))(this, v4);
  v6 = *a2;
  v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1)
  {
    v8 = a2[1].i32[0] - v6.i32[0];
    if (v8 >= 1)
    {
      v9 = 0;
      v10 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
      __asm { FMOV            V2.2S, #-1.0 }
      v16 = vadd_f32(v10, _D2);
      v17 = vadd_f32(v16, _D2);
      *(float32x2_t *)v18.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v18.i64[1] = 0x3F80000000000000;
      v19 = a2[2];
      v20 = 16 * a2[3].i32[0];
      v21 = 16 * v8;
      v22 = v18;
      do
      {
        v23 = 0;
        v24 = v18;
        v25 = v22;
        do
        {
          v32 = *((_QWORD *)this + 51);
          v33 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v32 + 96), vaddq_f32(v24, vmulq_f32(v25, *(float32x4_t *)(v32 + 80))));
          v34 = *(float32x4_t *)(v32 + 112);
          v35 = *(int8x16_t *)(v32 + 128);
          v36 = (int8x16_t)vdupq_lane_s64(vaddq_f32(v34, (float32x4_t)v33).i64[0], 0);
          v37 = vaddq_f32(v34, (float32x4_t)vextq_s8(v36, v33, 8uLL));
          v38 = vaddq_f32(v34, v37);
          v39 = vaddq_f32(v34, v38);
          v40 = (float32x4_t)vextq_s8(v35, v35, 8uLL);
          v41 = a2[10];
          v42 = a2[11].i32[0];
          v43 = vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, vadd_f32(*(float32x2_t *)v35.i8, *(float32x2_t *)v39.f32)));
          if (v5)
          {
            v44 = vmin_f32(vmax_f32(vadd_f32(v43, (float32x2_t)0xBF000000BF000000), 0), v16);
            v45 = vcvt_s32_f32(vmin_f32(v44, v17));
            v46 = vsub_f32(v44, vcvt_f32_s32(v45));
            v47 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * (v45.i32[0] + v45.i32[1] * (int)v42));
            v48 = vaddq_f32(*v47, vmulq_n_f32(vsubq_f32(v47[1], *v47), v46.f32[0]));
            v49 = vaddq_f32(v48, vmulq_lane_f32(vsubq_f32(vaddq_f32(v47[v42], vmulq_n_f32(vsubq_f32(v47[(int)v42 + 1], v47[v42]), v46.f32[0])), v48), v46, 1));
          }
          else
          {
            v50 = vcvt_s32_f32(vmin_f32(vmax_f32(v43, 0), v16));
            v49 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * (v50.i32[0] + v50.i32[1] * (int)v42));
          }
          v51 = (float32x4_t)vdupq_lane_s64(v38.i64[0], 0);
          v52 = vaddq_f32(v34, v39);
          v39.i64[0] = vaddq_f32(v34, v52).u64[0];
          v53.i64[0] = vaddq_f32((float32x4_t)v35, v37).u64[0];
          v53.i64[1] = vaddq_f32(v40, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v39, 0)).i64[1];
          v54 = (int8x16_t)vmulq_f32((float32x4_t)v35, (float32x4_t)vdupq_lane_s64(v53.i64[0], 0));
          v55 = (int8x16_t)vmulq_f32((float32x4_t)v35, v53);
          v56 = (float32x2_t)vaddq_f32((float32x4_t)v35, v52).u64[0];
          v57 = (int8x16_t)vaddq_f32(v40, v51);
          v58 = vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL));
          if (v5)
          {
            v59 = vmin_f32(vmax_f32(vadd_f32(v58, (float32x2_t)0xBF000000BF000000), 0), v16);
            v60 = vcvt_s32_f32(vmin_f32(v59, v17));
            v61 = vsub_f32(v59, vcvt_f32_s32(v60));
            v62 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)), (float32x2_t)0xBF000000BF000000), 0), v16);
            v63 = vcvt_s32_f32(vmin_f32(v62, v17));
            v64 = vsub_f32(v62, vcvt_f32_s32(v63));
            v65 = vdup_n_s32(v42);
            v66 = vmla_s32(vzip1_s32(v60, v63), vzip2_s32(v60, v63), v65);
            v67 = v66.i32[1];
            v68 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * v66.i32[0]);
            v69 = vaddq_f32(*v68, vmulq_n_f32(vsubq_f32(v68[1], *v68), v61.f32[0]));
            v70 = (int)v42 + 1;
            v71 = vaddq_f32(v69, vmulq_lane_f32(vsubq_f32(vaddq_f32(v68[v42], vmulq_n_f32(vsubq_f32(v68[v70], v68[v42]), v61.f32[0])), v69), v61, 1));
            v72 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * v67);
            v73 = vaddq_f32(*v72, vmulq_n_f32(vsubq_f32(v72[1], *v72), v64.f32[0]));
            v74 = vaddq_f32(v71, vaddq_f32(v73, vmulq_lane_f32(vsubq_f32(vaddq_f32(v72[v42], vmulq_n_f32(vsubq_f32(v72[v70], v72[v42]), v64.f32[0])), v73), v64, 1)));
            *(float32x2_t *)&v39.u32[2] = vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL));
            v75 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, *(float32x2_t *)&v39.u32[2]), (float32x2_t)0xBF000000BF000000), 0), v16);
            *(int32x2_t *)v71.f32 = vcvt_s32_f32(vmin_f32(v75, v17));
            v76 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v56)), (float32x2_t)0xBF000000BF000000), 0), v16);
            *(int32x2_t *)v73.f32 = vcvt_s32_f32(vmin_f32(v76, v17));
            v77 = vmla_s32(vzip1_s32(*(int32x2_t *)v71.f32, *(int32x2_t *)v73.f32), vzip2_s32(*(int32x2_t *)v71.f32, *(int32x2_t *)v73.f32), v65);
            v78 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * v77.i32[0]);
            v79 = vsub_f32(v75, vcvt_f32_s32(*(int32x2_t *)v71.f32));
            *(float32x2_t *)v71.f32 = vsub_f32(v76, vcvt_f32_s32(*(int32x2_t *)v73.f32));
            v80 = vaddq_f32(*v78, vmulq_n_f32(vsubq_f32(v78[1], *v78), v79.f32[0]));
            v81 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v78[v42], vmulq_n_f32(vsubq_f32(v78[v70], v78[v42]), v79.f32[0])), v80), v79, 1));
            v82 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * v77.i32[1]);
            v83 = vaddq_f32(*v82, vmulq_n_f32(vsubq_f32(v82[1], *v82), v71.f32[0]));
            v84 = vaddq_f32(v83, vmulq_lane_f32(vsubq_f32(vaddq_f32(v82[v42], vmulq_n_f32(vsubq_f32(v82[v70], v82[v42]), v71.f32[0])), v83), *(float32x2_t *)v71.f32, 1));
            v85 = (int8x16_t)vaddq_f32(v40, (float32x4_t)v36);
            *(float32x2_t *)v85.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL))), (float32x2_t)0xBF000000BF000000), 0), v16);
            v86 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v85.i8, v17));
            *(float32x2_t *)v85.i8 = vsub_f32(*(float32x2_t *)v85.i8, vcvt_f32_s32(v86));
            v87 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * (v86.i32[0] + v86.i32[1] * (int)v42));
            v88 = vaddq_f32(*v87, vmulq_n_f32(vsubq_f32(v87[1], *v87), *(float *)v85.i32));
            v89 = vaddq_f32(v88, vmulq_lane_f32(vsubq_f32(vaddq_f32(v87[v42], vmulq_n_f32(vsubq_f32(v87[(int)v42 + 1], v87[v42]), *(float *)v85.i32)), v88), *(float32x2_t *)v85.i8, 1));
            v90 = (float32x2_t)vaddq_f32(v34, v39).u64[0];
            v91 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, vadd_f32(*(float32x2_t *)v35.i8, v90))), (float32x2_t)0xBF000000BF000000), 0), v16);
            v92 = vcvt_s32_f32(vmin_f32(v91, v17));
            v93 = vsub_f32(v91, vcvt_f32_s32(v92));
            v94 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * (v92.i32[0] + v92.i32[1] * (int)v42));
            v95 = vaddq_f32(*v94, vmulq_n_f32(vsubq_f32(v94[1], *v94), v93.f32[0]));
            v96 = vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(vaddq_f32(v94[v42], vmulq_n_f32(vsubq_f32(v94[(int)v42 + 1], v94[v42]), v93.f32[0])), v95), v93, 1));
          }
          else
          {
            v97 = vcvt_s32_f32(vmin_f32(vmax_f32(v58, 0), v16));
            v98 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)), 0), v16));
            v99 = vdup_n_s32(v42);
            v100 = vmla_s32(vzip1_s32(v97, v98), vzip2_s32(v97, v98), v99);
            v101 = vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL));
            v102 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, v101), 0), v16));
            v103 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v56)), 0), v16));
            v104 = vmla_s32(vzip1_s32(v102, v103), vzip2_s32(v102, v103), v99);
            v105 = v104.i32[1];
            v81 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * v104.i32[0]);
            v74 = vaddq_f32(*(float32x4_t *)(*(_QWORD *)&v41 + 16 * v100.i32[0]), *(float32x4_t *)(*(_QWORD *)&v41 + 16 * v100.i32[1]));
            *(float32x2_t *)&v39.u32[2] = v101;
            v84 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * v105);
            v106 = (int8x16_t)vaddq_f32(v40, (float32x4_t)v36);
            *(int32x2_t *)v106.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL))), 0), v16));
            v89 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * (v106.i32[0] + v106.i32[1] * (int)v42));
            v90 = (float32x2_t)vaddq_f32(v34, v39).u64[0];
            v107 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, vadd_f32(*(float32x2_t *)v35.i8, v90))), 0), v16));
            v96 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * (v107.i32[0] + v107.i32[1] * (int)v42));
          }
          *(float32x2_t *)v108.f32 = vadd_f32(*(float32x2_t *)v34.f32, v90);
          v108.i64[1] = v33.i64[0];
          v109 = (int8x16_t)vmulq_f32(v40, vaddq_f32((float32x4_t)v35, v108));
          v110 = (float32x2_t)vmulq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)vaddq_f32(v40, v108), v109, 8uLL)).u64[0];
          v111 = vmul_f32(v10, *(float32x2_t *)v109.i8);
          if (v5)
          {
            v112 = vmin_f32(vmax_f32(vadd_f32(v111, (float32x2_t)0xBF000000BF000000), 0), v16);
            v113 = vcvt_s32_f32(vmin_f32(v112, v17));
            v114 = vsub_f32(v112, vcvt_f32_s32(v113));
            v115 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, v110), (float32x2_t)0xBF000000BF000000), 0), v16);
            v116 = vcvt_s32_f32(vmin_f32(v115, v17));
            v117 = vsub_f32(v115, vcvt_f32_s32(v116));
            v118 = vmla_s32(vzip1_s32(v113, v116), vzip2_s32(v113, v116), vdup_n_s32(v42));
            v119 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * v118.i32[0]);
            v120 = (int)v42 + 1;
            v121 = vaddq_f32(*v119, vmulq_n_f32(vsubq_f32(v119[1], *v119), v114.f32[0]));
            v30 = vaddq_f32(v121, vmulq_lane_f32(vsubq_f32(vaddq_f32(v119[v42], vmulq_n_f32(vsubq_f32(v119[v120], v119[v42]), v114.f32[0])), v121), v114, 1));
            v122 = (float32x4_t *)(*(_QWORD *)&v41 + 16 * v118.i32[1]);
            v123 = vaddq_f32(*v122, vmulq_n_f32(vsubq_f32(v122[1], *v122), v117.f32[0]));
            v31 = vaddq_f32(v123, vmulq_lane_f32(vsubq_f32(vaddq_f32(v122[v42], vmulq_n_f32(vsubq_f32(v122[v120], v122[v42]), v117.f32[0])), v123), v117, 1));
          }
          else
          {
            v26 = vcvt_s32_f32(vmin_f32(vmax_f32(v111, 0), v16));
            v27 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, v110), 0), v16));
            v28 = vmla_s32(vzip1_s32(v26, v27), vzip2_s32(v26, v27), vdup_n_s32(v42));
            v29 = v28.i32[1];
            v30 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * v28.i32[0]);
            v31 = *(float32x4_t *)(*(_QWORD *)&v41 + 16 * v29);
          }
          *(float32x4_t *)(*(_QWORD *)&v19 + v23) = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v74, *(float32x4_t *)(v32 + 32)), vaddq_f32(vmulq_f32(v49, *(float32x4_t *)v32), vmulq_f32(vaddq_f32(v81, v84), *(float32x4_t *)(v32 + 16)))), vmulq_f32(vaddq_f32(v89, v96), *(float32x4_t *)(v32 + 48))), vmulq_f32(vaddq_f32(v30, v31), *(float32x4_t *)(v32 + 64)));
          v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B304F230);
          v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B304F230);
          v23 += 16;
        }
        while (v21 != v23);
        v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B304F240);
        v22 = vaddq_f32(v22, (float32x4_t)xmmword_1B304F240);
        ++v9;
        *(_QWORD *)&v19 += v20;
      }
      while (v9 != v7);
    }
  }
  return 0;
}

uint64_t HgcBlur_cs9s::GetDOD(HgcBlur_cs9s *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcBlur_cs9s::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_cs9s::HgcBlur_cs9s(HgcBlur_cs9s *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65420E0;
  v3 = (_OWORD *)operator new();
  v3[7] = 0u;
  v3[8] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  *v3 = 0u;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcBlur_cs9s *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BCA390(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_cs9s::~HgcBlur_cs9s(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65420E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65420E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65420E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlur_cs9s::SetParameter(HgcBlur_cs9s *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 8)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_cs9s::GetParameter(HgcBlur_cs9s *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 8)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlur_cs9s_rect::GetProgram(HgcBlur_cs9s_rect *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000952\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[5].xy + frag._texCoord0.xy;\n"
             "    s0.xy = s0.xy + hg_Params[6].xy;\n"
             "    s1.xy = s0.xy + hg_Params[7].xy;\n"
             "    s2.xy = s1.xy + hg_Params[7].xy;\n"
             "    s3.xy = s2.xy + hg_Params[7].xy;\n"
             "    s4.xy = s3.xy + hg_Params[7].xy;\n"
             "    s5.xy = s4.xy + hg_Params[7].xy;\n"
             "    s6.xy = s5.xy + hg_Params[7].xy;\n"
             "    s7.xy = s6.xy + hg_Params[7].xy;\n"
             "    s8.xy = s7.xy + hg_Params[7].xy;\n"
             "    s9.xy = s0.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s8.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r0 = r0 + r1;\n"
             "    s9.xy = s1.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s7.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r2 = r2 + r3;\n"
             "    s9.xy = s2.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r4 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s6.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r5 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r4 = r4 + r5;\n"
             "    s9.xy = s3.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r6 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s5.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r7 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r6 = r6 + r7;\n"
             "    s9.xy = s4.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r8 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r8 = r8*half4(hg_Params[0]);\n"
             "    r8 = r6*half4(hg_Params[1]) + r8;\n"
             "    r8 = r4*half4(hg_Params[2]) + r8;\n"
             "    r8 = r2*half4(hg_Params[3]) + r8;\n"
             "    r8 = r0*half4(hg_Params[4]) + r8;\n"
             "    output.color0 = float4(r8);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20231576:38422c71:410e9f91:50cad1c9\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0009:0013:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000008b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[5].xy + frag._texCoord0.xy;\n"
             "    r0.xy = r0.xy + hg_Params[6].xy;\n"
             "    r1.xy = r0.xy + hg_Params[7].xy;\n"
             "    r2.xy = r1.xy + hg_Params[7].xy;\n"
             "    r3.xy = r2.xy + hg_Params[7].xy;\n"
             "    r4.xy = r3.xy + hg_Params[7].xy;\n"
             "    r5.xy = r4.xy + hg_Params[7].xy;\n"
             "    r6.xy = r5.xy + hg_Params[7].xy;\n"
             "    r7.xy = r6.xy + hg_Params[7].xy;\n"
             "    r8.xy = r7.xy + hg_Params[7].xy;\n"
             "    r9.xy = r0.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r8.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r8 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r0 = r0 + r8;\n"
             "    r9.xy = r1.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r7.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r7 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r1 = r1 + r7;\n"
             "    r9.xy = r2.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r6.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r6 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r2 = r2 + r6;\n"
             "    r9.xy = r3.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r5.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r3 = r3 + r5;\n"
             "    r9.xy = r4.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r4 = r4*hg_Params[0];\n"
             "    r4 = r3*hg_Params[1] + r4;\n"
             "    r4 = r2*hg_Params[2] + r4;\n"
             "    r4 = r1*hg_Params[3] + r4;\n"
             "    r4 = r0*hg_Params[4] + r4;\n"
             "    output.color0 = r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32296e5f:5026098e:617aecba:68002612\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0009:000a:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000009f8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal5.xy + hg_TexCoord0.xy;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal6.xy;\n"
           "    r1.xy = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r4.xy = r3.xy + hg_ProgramLocal7.xy;\n"
           "    r5.xy = r4.xy + hg_ProgramLocal7.xy;\n"
           "    r6.xy = r5.xy + hg_ProgramLocal7.xy;\n"
           "    r7.xy = r6.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r7.xy + hg_ProgramLocal7.xy;\n"
           "    r9.xy = r0.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r0 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r8.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r8 = texture2D(hg_Texture0, r9.xy);\n"
           "    r0 = r0 + r8;\n"
           "    r9.xy = r1.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r1 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r7.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r7 = texture2D(hg_Texture0, r9.xy);\n"
           "    r1 = r1 + r7;\n"
           "    r9.xy = r2.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r2 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r6.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r6 = texture2D(hg_Texture0, r9.xy);\n"
           "    r2 = r2 + r6;\n"
           "    r9.xy = r3.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r3 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r5.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r5 = texture2D(hg_Texture0, r9.xy);\n"
           "    r3 = r3 + r5;\n"
           "    r9.xy = r4.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r4 = texture2D(hg_Texture0, r9.xy);\n"
           "    r4 = r4*hg_ProgramLocal0;\n"
           "    r4 = r3*hg_ProgramLocal1 + r4;\n"
           "    r4 = r2*hg_ProgramLocal2 + r4;\n"
           "    r4 = r1*hg_ProgramLocal3 + r4;\n"
           "    r4 = r0*hg_ProgramLocal4 + r4;\n"
           "    gl_FragColor = r4;\n"
           "}\n"
           "//MD5=7ad25e9b:38f9f67b:041a5da1:774d8277\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0009:000a:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_cs9s_rect::InitProgramDescriptor(HgcBlur_cs9s_rect *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_cs9s_rect_hgc_visible", "//Metal1.0     \n//LEN=0000000806\n[[ visible ]] FragmentOut HgcBlur_cs9s_rect_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[5].xy + texCoord0.xy;\n"
    "    r0.xy = r0.xy + hg_Params[6].xy;\n"
    "    r1.xy = r0.xy + hg_Params[7].xy;\n"
    "    r2.xy = r1.xy + hg_Params[7].xy;\n"
    "    r3.xy = r2.xy + hg_Params[7].xy;\n"
    "    r4.xy = r3.xy + hg_Params[7].xy;\n"
    "    r5.xy = r4.xy + hg_Params[7].xy;\n"
    "    r6.xy = r5.xy + hg_Params[7].xy;\n"
    "    r7.xy = r6.xy + hg_Params[7].xy;\n"
    "    r8.xy = r7.xy + hg_Params[7].xy;\n"
    "    r9.xy = r0.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r8.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r8 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r0 = r0 + r8;\n"
    "    r9.xy = r1.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r7.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r7 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r1 = r1 + r7;\n"
    "    r9.xy = r2.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r6.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r6 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r2 = r2 + r6;\n"
    "    r9.xy = r3.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r5.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r3 = r3 + r5;\n"
    "    r9.xy = r4.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r4 = r4*hg_Params[0];\n"
    "    r4 = r3*hg_Params[1] + r4;\n"
    "    r4 = r2*hg_Params[2] + r4;\n"
    "    r4 = r1*hg_Params[3] + r4;\n"
    "    r4 = r0*hg_Params[4] + r4;\n"
    "    output.color0 = r4;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCA9B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCA9F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCA9E8);
}

char *HgcBlur_cs9s_rect::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3525EE0;
  strcpy(result, "HgcBlur_cs9s_rect [hgc1]");
  return result;
}

uint64_t HgcBlur_cs9s_rect::BindTexture(HgcBlur_cs9s_rect *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 8, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcBlur_cs9s_rect::Bind(HgcBlur_cs9s_rect *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 6, *((_QWORD *)this + 51) + 96, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 7, *((_QWORD *)this + 51) + 112, 1);
  (*(void (**)(HgcBlur_cs9s_rect *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcBlur_cs9s_rect::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  int32x2_t v6;
  int v7;
  uint64_t v8;
  float32x4_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  float32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  __int32 v32;
  __int32 v33;
  float32x4_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  uint64_t v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t *v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int32x4_t v49;
  float32x4_t v50;
  __int32 v51;
  float32x4_t v52;
  float32x4_t *v53;
  float32x4_t v54;
  int32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  __int32 v65;
  __int32 v66;
  __int32 v67;
  float32x4_t v68;
  int v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t *v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t *v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t *v84;
  float32x4_t *v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t *v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int32x4_t v100;
  float32x4_t *v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  uint64_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t *v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  uint64_t v117;
  int v118;
  float32x4_t v119;
  float32x4_t v120;
  int32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int32x4_t v124;
  __int32 v125;
  __int32 v126;
  float32x4_t v127;
  __int32 v128;
  float32x4_t v129;
  float32x4_t v130;
  int32x4_t v131;
  int32x4_t v132;
  int32x4_t v133;
  __int32 v134;
  __int32 v135;
  float32x4_t v136;
  int32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  __int32 v140;
  float32x4_t v141;
  int32x4_t v142;
  __int32 v143;
  __int32 v144;
  float32x4_t v145;
  __int32 v146;
  float32x4_t v147;
  int32x4_t v148;
  float32x4_t v149;
  int32x4_t v150;

  v4 = HGTile::Renderer(a2);
  v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  v6 = *(int32x2_t *)a2;
  v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v7 >= 1)
  {
    v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      v10 = *((_QWORD *)a2 + 2);
      v11 = 0;
      v12 = 16 * *((int *)a2 + 6);
      v13 = 16 * v8;
      if (v5)
      {
        v14 = v9;
        v15 = v9;
        do
        {
          v16 = 0;
          v17 = v14;
          v18 = v15;
          do
          {
            v19 = this[51];
            v20 = v19[7];
            v21 = vaddq_f32(v19[6], vaddq_f32(v17, vmulq_f32(v18, v19[5])));
            v22 = vaddq_f32(v20, v21);
            v23 = vaddq_f32(v20, v22);
            v24 = vaddq_f32(v20, v23);
            v25 = vaddq_f32(v20, v24);
            v26 = vaddq_f32(v20, v25);
            v27 = *((_QWORD *)a2 + 10);
            v28 = *((int *)a2 + 22);
            v29 = vsubq_f32(v21, v9);
            v30 = vaddq_s32(vcvtq_s32_f32(v29), vcltzq_f32(v29));
            v31 = vaddq_f32(v20, v26);
            v29.i64[0] = vsubq_f32(v29, vcvtq_f32_s32(v30)).u64[0];
            v32 = v30.i32[1];
            v33 = v30.i32[0];
            v34 = vaddq_f32(v20, v31);
            v35 = (float32x4_t *)(v27 + 16 * (v33 + v32 * (int)v28));
            v36 = vaddq_f32(*v35, vmulq_n_f32(vsubq_f32(v35[1], *v35), v29.f32[0]));
            v37 = (int)v28 + 1;
            v38 = vsubq_f32(v22, v9);
            v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
            v40 = vsubq_f32(vaddq_f32(v20, v34), v9);
            v38.i64[0] = vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
            v41 = vsubq_f32(vaddq_f32(v35[v28], vmulq_n_f32(vsubq_f32(v35[v37], v35[v28]), v29.f32[0])), v36);
            v42 = (float32x4_t *)(v27 + 16 * (v39.i32[0] + v39.i32[1] * (int)v28));
            v43 = vaddq_f32(*v42, vmulq_n_f32(vsubq_f32(v42[1], *v42), v38.f32[0]));
            v44 = vaddq_f32(v42[v28], vmulq_n_f32(vsubq_f32(v42[v37], v42[v28]), v38.f32[0]));
            v45 = vsubq_f32(v34, v9);
            v46 = vaddq_s32(vcvtq_s32_f32(v45), vcltzq_f32(v45));
            v47 = vsubq_f32(v23, v9);
            v48 = vmulq_lane_f32(v41, *(float32x2_t *)v29.f32, 1);
            v49 = vaddq_s32(vcvtq_s32_f32(v47), vcltzq_f32(v47));
            v50 = vcvtq_f32_s32(v49);
            LODWORD(v42) = v49.i32[1];
            v51 = v49.i32[0];
            v52 = vsubq_f32(v44, v43);
            v53 = (float32x4_t *)(v27 + 16 * (v51 + (int)v42 * (int)v28));
            v54 = v53[v28];
            v55 = vaddq_s32(vcvtq_s32_f32(v40), vcltzq_f32(v40));
            v57 = *v53;
            v56 = v53[1];
            v58 = vsubq_f32(v31, v9);
            v59 = vaddq_s32(vcvtq_s32_f32(v58), vcltzq_f32(v58));
            v60 = vaddq_f32(v36, v48);
            v61 = vcvtq_f32_s32(v59);
            v62 = vsubq_f32(v24, v9);
            v63 = vaddq_s32(vcvtq_s32_f32(v62), vcltzq_f32(v62));
            v64 = vcvtq_f32_s32(v63);
            v65 = v55.i32[1];
            v66 = v63.i32[1];
            v67 = v63.i32[0];
            v68 = v53[v37];
            LODWORD(v53) = v55.i32[0];
            v69 = v46.i32[0] + v46.i32[1] * v28;
            v70 = vmulq_lane_f32(v52, *(float32x2_t *)v38.f32, 1);
            v38.i64[0] = vsubq_f32(v45, vcvtq_f32_s32(v46)).u64[0];
            v47.i64[0] = vsubq_f32(v47, v50).u64[0];
            v71 = vsubq_f32(v56, v57);
            v72 = (float32x4_t *)(v27 + 16 * (v59.i32[0] + v59.i32[1] * (int)v28));
            v46.i64[0] = vsubq_f32(v40, vcvtq_f32_s32(v55)).u64[0];
            v73 = v72[v28];
            v74 = v72[v37];
            v76 = *v72;
            v75 = v72[1];
            v77 = vaddq_f32(v57, vmulq_n_f32(v71, v47.f32[0]));
            v78 = vaddq_f32(v43, v70);
            v79 = (float32x4_t *)(v27 + 16 * (v67 + v66 * (int)v28));
            v81 = *v79;
            v80 = v79[1];
            v82 = v79[v28];
            v83 = v79[v37];
            v84 = (float32x4_t *)(v27 + 16 * v69);
            v85 = (float32x4_t *)(v27 + 16 * ((int)v53 + v65 * (int)v28));
            v86 = vaddq_f32(v77, vmulq_lane_f32(vsubq_f32(vaddq_f32(v54, vmulq_n_f32(vsubq_f32(v68, v54), v47.f32[0])), v77), *(float32x2_t *)v47.f32, 1));
            v58.i64[0] = vsubq_f32(v58, v61).u64[0];
            v87 = v85[v28];
            v62.i64[0] = vsubq_f32(v62, v64).u64[0];
            v88 = vaddq_f32(v81, vmulq_n_f32(vsubq_f32(v80, v81), v62.f32[0]));
            v89 = vaddq_f32(v76, vmulq_n_f32(vsubq_f32(v75, v76), v58.f32[0]));
            v90 = vaddq_f32(v73, vmulq_n_f32(vsubq_f32(v74, v73), v58.f32[0]));
            v91 = vaddq_f32(*v84, vmulq_n_f32(vsubq_f32(v84[1], *v84), v38.f32[0]));
            v92 = vsubq_f32(v26, v9);
            v93 = vaddq_s32(vcvtq_s32_f32(v92), vcltzq_f32(v92));
            v92.i64[0] = vsubq_f32(v92, vcvtq_f32_s32(v93)).u64[0];
            v94 = vmulq_n_f32(vsubq_f32(v85[v37], v87), *(float *)v46.i32);
            v95 = vaddq_f32(*v85, vmulq_n_f32(vsubq_f32(v85[1], *v85), *(float *)v46.i32));
            v96 = (float32x4_t *)(v27 + 16 * (v93.i32[0] + v93.i32[1] * (int)v28));
            v97 = vaddq_f32(*v96, vmulq_n_f32(vsubq_f32(v96[1], *v96), v92.f32[0]));
            v98 = vaddq_f32(vaddq_f32(v88, vmulq_lane_f32(vsubq_f32(vaddq_f32(v82, vmulq_n_f32(vsubq_f32(v83, v82), v62.f32[0])), v88), *(float32x2_t *)v62.f32, 1)), vaddq_f32(v97, vmulq_lane_f32(vsubq_f32(vaddq_f32(v96[v28], vmulq_n_f32(vsubq_f32(v96[v37], v96[v28]), v92.f32[0])), v97), *(float32x2_t *)v92.f32, 1)));
            v99 = vsubq_f32(v25, v9);
            v100 = vaddq_s32(vcvtq_s32_f32(v99), vcltzq_f32(v99));
            v99.i64[0] = vsubq_f32(v99, vcvtq_f32_s32(v100)).u64[0];
            v101 = (float32x4_t *)(v27 + 16 * (v100.i32[0] + v100.i32[1] * (int)v28));
            v102 = vaddq_f32(*v101, vmulq_n_f32(vsubq_f32(v101[1], *v101), v99.f32[0]));
            *(float32x4_t *)(v10 + v16) = vaddq_f32(vmulq_f32(vaddq_f32(v60, vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(vaddq_f32(v87, v94), v95), *(float32x2_t *)v46.i8, 1))), v19[4]), vaddq_f32(vmulq_f32(vaddq_f32(v78, vaddq_f32(v91, vmulq_lane_f32(vsubq_f32(vaddq_f32(
                                                          v84[v28],
                                                          vmulq_n_f32(vsubq_f32(v84[v37], v84[v28]), v38.f32[0])),
                                                        v91),
                                                      *(float32x2_t *)v38.f32,
                                                      1))),
                                                v19[3]),
                                              vaddq_f32(vmulq_f32(vaddq_f32(v86, vaddq_f32(v89, vmulq_lane_f32(vsubq_f32(v90, v89), *(float32x2_t *)v58.f32, 1))), v19[2]), vaddq_f32(vmulq_f32(vaddq_f32(v102, vmulq_lane_f32(vsubq_f32(vaddq_f32(v101[v28], vmulq_n_f32(vsubq_f32(v101[v37], v101[v28]), v99.f32[0])), v102), *(float32x2_t *)v99.f32, 1)),
                                                    *v19),
                                                  vmulq_f32(v98, v19[1])))));
            v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B304F230);
            v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B304F230);
            v16 += 16;
          }
          while (v13 != v16);
          v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B304F240);
          v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B304F240);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
      else
      {
        v103.i64[0] = 0x3F0000003F000000;
        v103.i64[1] = 0x3F0000003F000000;
        v104 = v9;
        v105 = v9;
        do
        {
          v106 = 0;
          v107 = v104;
          v108 = v105;
          do
          {
            v109 = this[51];
            v110 = v109[7];
            v111 = vaddq_f32(v109[6], vaddq_f32(v107, vmulq_f32(v108, v109[5])));
            v112 = vaddq_f32(v110, v111);
            v113 = vaddq_f32(v110, v112);
            v114 = vaddq_f32(v110, v113);
            v115 = vaddq_f32(v110, v114);
            v116 = vaddq_f32(v110, v115);
            v117 = *((_QWORD *)a2 + 10);
            v118 = *((_DWORD *)a2 + 22);
            v119 = vaddq_f32(v110, v116);
            v120 = vaddq_f32(vsubq_f32(v111, v9), v103);
            v121 = vcvtq_s32_f32(v120);
            v120.i64[0] = vaddq_s32(v121, vcgtq_f32(vcvtq_f32_s32(v121), v120)).u64[0];
            v122 = vaddq_f32(v110, v119);
            v123 = vaddq_f32(vsubq_f32(v112, v9), v103);
            v124 = vcvtq_s32_f32(v123);
            v123.i64[0] = vaddq_s32(v124, vcgtq_f32(vcvtq_f32_s32(v124), v123)).u64[0];
            v125 = v123.i32[1];
            v126 = v123.i32[0];
            v127 = vaddq_f32(vsubq_f32(vaddq_f32(v110, v122), v9), v103);
            v128 = v126 + v125 * v118;
            v129 = vaddq_f32(vsubq_f32(v122, v9), v103);
            v130 = vaddq_f32(vsubq_f32(v113, v9), v103);
            v131 = vcvtq_s32_f32(v129);
            v132 = vcvtq_s32_f32(v130);
            v130.i64[0] = vaddq_s32(v132, vcgtq_f32(vcvtq_f32_s32(v132), v130)).u64[0];
            v133 = vcvtq_s32_f32(v127);
            v134 = v130.i32[1];
            v135 = v130.i32[0];
            v136 = vaddq_f32(vsubq_f32(v119, v9), v103);
            v137 = vcvtq_s32_f32(v136);
            v138 = *(float32x4_t *)(v117 + 16 * v128);
            v129.i64[0] = vaddq_s32(v131, vcgtq_f32(vcvtq_f32_s32(v131), v129)).u64[0];
            v136.i64[0] = vaddq_s32(v137, vcgtq_f32(vcvtq_f32_s32(v137), v136)).u64[0];
            v139 = *(float32x4_t *)(v117 + 16 * (v135 + v134 * v118));
            v140 = v136.i32[0] + v136.i32[1] * v118;
            v127.i64[0] = vaddq_s32(v133, vcgtq_f32(vcvtq_f32_s32(v133), v127)).u64[0];
            v141 = vaddq_f32(vsubq_f32(v114, v9), v103);
            v142 = vcvtq_s32_f32(v141);
            v143 = v127.i32[1];
            v141.i64[0] = vaddq_s32(v142, vcgtq_f32(vcvtq_f32_s32(v142), v141)).u64[0];
            v144 = v127.i32[0];
            v145 = *(float32x4_t *)(v117 + 16 * (v141.i32[0] + v141.i32[1] * v118));
            v146 = v129.i32[0] + v129.i32[1] * v118;
            v147 = vaddq_f32(vsubq_f32(v116, v9), v103);
            v148 = vcvtq_s32_f32(v147);
            v147.i64[0] = vaddq_s32(v148, vcgtq_f32(vcvtq_f32_s32(v148), v147)).u64[0];
            v149 = vaddq_f32(vsubq_f32(v115, v9), v103);
            v150 = vcvtq_s32_f32(v149);
            v149.i64[0] = vaddq_s32(v150, vcgtq_f32(vcvtq_f32_s32(v150), v149)).u64[0];
            *(float32x4_t *)(v10 + v106) = vaddq_f32(vmulq_f32(vaddq_f32(*(float32x4_t *)(v117 + 16 * (v120.i32[0] + v120.i32[1] * v118)), *(float32x4_t *)(v117 + 16 * (v144 + v143 * v118))), v109[4]), vaddq_f32(vmulq_f32(vaddq_f32(v138, *(float32x4_t *)(v117 + 16 * v146)), v109[3]), vaddq_f32(vmulq_f32(vaddq_f32(v139, *(float32x4_t *)(v117 + 16 * v140)), v109[2]), vaddq_f32(vmulq_f32(*(float32x4_t *)(v117 + 16 * (v149.i32[0] + v149.i32[1] * v118)), *v109), vmulq_f32(vaddq_f32(v145, *(float32x4_t *)(v117 + 16 * (v147.i32[0] + v147.i32[1] * v118))),
                                                     v109[1])))));
            v107 = vaddq_f32(v107, (float32x4_t)xmmword_1B304F230);
            v108 = vaddq_f32(v108, (float32x4_t)xmmword_1B304F230);
            v106 += 16;
          }
          while (v13 != v106);
          v104 = vaddq_f32(v104, (float32x4_t)xmmword_1B304F240);
          v105 = vaddq_f32(v105, (float32x4_t)xmmword_1B304F240);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcBlur_cs9s_rect::GetDOD(HgcBlur_cs9s_rect *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  if ((*(int (**)(HgcBlur_cs9s_rect *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
  {
    v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    HGRectGrow(v6, v5, v7);
  }
  return 0x8000000080000000;
}

uint64_t HgcBlur_cs9s_rect::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t DOD;
  HGNode *Input;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v10 = v9;
  if ((*(int (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) < 1)
    return DOD;
  v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(DOD, v10, v11);
}

void HgcBlur_cs9s_rect::HgcBlur_cs9s_rect(HgcBlur_cs9s_rect *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6542348;
  v3 = (_OWORD *)operator new();
  v3[6] = 0u;
  v3[7] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcBlur_cs9s_rect *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BCB504(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542348;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542348;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6542348;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcBlur_cs9s_rect::SetParameter(HgcBlur_cs9s_rect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 7)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_cs9s_rect::GetParameter(HgcBlur_cs9s_rect *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 7)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_chroma_upsample_f1::GetProgram(HgcColorGamma_chroma_upsample_f1 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000532\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.x = floor(frag._texCoord1.x);\n"
             "    s1.xz = hg_Params[1].xz;\n"
             "    s1.x = dot(s1.xz, 1.00000f);\n"
             "    s1.x = s1.x - float(c0.x);\n"
             "    s1.x = s1.x - s0.x;\n"
             "    s1.xy = select(-float2(c0.xy), float2(c0.xy), s1.xx > 0.00000h);\n"
             "    s1.xy = frag._texCoord1.xy + s1.xy;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s1.xy = s1.xy + hg_Params[0].xy;\n"
             "    s1.xy = s1.xy*hg_Params[0].zw;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, s1.xy).yz;\n"
             "    r2.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).yz;\n"
             "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
             "    s0.yz = float2(fract(0.500000f*frag._texCoord1.xx) >= 0.500000f);\n"
             "    s1.xw = float2(r0.xw);\n"
             "    s1.yz = select(float2(r0.yz), float2(r1.yz), s0.yz > 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d15e8235:1bcea85f:801bb56b:2741a3f6\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0002:0005:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000004c9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = floor(frag._texCoord1.x);\n"
             "    r1.xz = hg_Params[1].xz;\n"
             "    r1.x = dot(r1.xz, 1.00000f);\n"
             "    r1.x = r1.x - c0.x;\n"
             "    r1.x = r1.x - r0.x;\n"
             "    r1.xy = select(-c0.xy, c0.xy, r1.xx > 0.00000f);\n"
             "    r1.xy = frag._texCoord1.xy + r1.xy;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = r1.xy + hg_Params[0].xy;\n"
             "    r1.xy = r1.xy*hg_Params[0].zw;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, r1.xy).yz;\n"
             "    r2.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).yz;\n"
             "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
             "    r2.yz = float2(fract(0.500000f*frag._texCoord1.xx) >= 0.500000f);\n"
             "    r0.yz = select(r0.yz, r1.yz, r2.yz > 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f819144d:7b0341ff:b247e70a:9881758d\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000054a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.x = floor(hg_TexCoord1.x);\n"
           "    r1.xz = hg_ProgramLocal1.xz;\n"
           "    r1.x = dot(r1.xz, vec2(1.00000));\n"
           "    r1.x = r1.x - c0.x;\n"
           "    r1.x = r1.x - r0.x;\n"
           "    r1.xy = vec2(r1.x > 0.00000 ? c0.x : -c0.x, r1.x > 0.00000 ? c0.y : -c0.y);\n"
           "    r1.xy = hg_TexCoord1.xy + r1.xy;\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xy = r1.xy + hg_ProgramLocal0.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal0.zw;\n"
           "    r1.yz = texture2D(hg_Texture0, r1.xy).yz;\n"
           "    r2.yz = texture2D(hg_Texture0, hg_TexCoord2.xy).yz;\n"
           "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
           "    r2.yz = c0.zz*hg_TexCoord1.xx;\n"
           "    r2.yz = fract(r2.yz);\n"
           "    r2.yz = vec2(greaterThanEqual(r2.yz, c0.zz));\n"
           "    r0.yz = vec2(r2.y > 0.00000 ? r1.y : r0.y, r2.z > 0.00000 ? r1.z : r0.z);\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2635f3eb:1d6c7af1:cbb290bc:c440b6c0\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
}

void HgcColorGamma_chroma_upsample_f1::InitProgramDescriptor(HgcColorGamma_chroma_upsample_f1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_chroma_upsample_f1_hgc_visible", "//Metal1.0     \n//LEN=0000000430\n[[ visible ]] FragmentOut HgcColorGamma_chroma_upsample_f1_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = floor(texCoord1.x);\n"
    "    r1.xz = hg_Params[1].xz;\n"
    "    r1.x = dot(r1.xz, 1.00000f);\n"
    "    r1.x = r1.x - c0.x;\n"
    "    r1.x = r1.x - r0.x;\n"
    "    r1.xy = select(-c0.xy, c0.xy, r1.xx > 0.00000f);\n"
    "    r1.xy = texCoord1.xy + r1.xy;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1.xy = r1.xy + hg_Params[0].xy;\n"
    "    r1.xy = r1.xy*hg_Params[0].zw;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, r1.xy).yz;\n"
    "    r2.yz = hg_Texture0.sample(hg_Sampler0, texCoord2.xy).yz;\n"
    "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
    "    r2.yz = float2(fract(0.500000f*texCoord1.xx) >= 0.500000f);\n"
    "    r0.yz = select(r0.yz, r1.yz, r2.yz > 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCBBC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCBC00(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCBBF8);
}

char *HgcColorGamma_chroma_upsample_f1::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552D10;
  strcpy(result, "HgcColorGamma_chroma_upsample_f1 [hgc1]");
  return result;
}

uint64_t HgcColorGamma_chroma_upsample_f1::BindTexture(HgcColorGamma_chroma_upsample_f1 *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 96))(a2, -1.0, 0.0, 0.0);
  return 0;
}

uint64_t HgcColorGamma_chroma_upsample_f1::Bind(HgcColorGamma_chroma_upsample_f1 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HgcColorGamma_chroma_upsample_f1 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcColorGamma_chroma_upsample_f1::RenderTile(HGNode *this, int8x8_t *a2)
{
  __int32 v4;
  uint64_t v5;
  uint64_t v6;
  int8x8_t v7;
  HGRenderer *v8;
  int32x2_t DOD;
  int32x2_t v10;
  uint64_t v11;
  float32x4_t v12;
  int v13;
  int8x8_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  uint64_t v21;
  unint64_t v22;
  float32x4_t v23;
  int8x8_t v24;
  float32x4_t v25;
  int8x16_t v26;
  int v27;
  uint64_t v28;
  float32x4_t v29;
  float32x4_t v30;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  uint64_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x8_t v45;
  __int32 v46;
  float32x4_t v47;
  int32x4_t v48;
  __int32 v49;
  __int32 v50;
  float32x4_t v51;
  int32x4_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t *v60;
  int v61;
  float32x4_t v62;
  uint64_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int32x2_t v70;

  v4 = a2[1].i32[0];
  v70 = (int32x2_t)*a2;
  v5 = (a2[1].i32[1] - HIDWORD(*(unint64_t *)a2));
  v6 = a2[11].i32[0];
  v7 = a2[10];
  v8 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  DOD = (int32x2_t)HGRenderer::GetDOD(v8, this);
  if ((int)v5 >= 1)
  {
    v11 = 0;
    *(float32x2_t *)v12.f32 = vadd_f32(vcvt_f32_s32(v70), (float32x2_t)0x3F0000003F000000);
    v12.i64[1] = 0x3F80000000000000;
    v13 = v4 - v70.i32[0];
    v14 = a2[2];
    *(float32x2_t *)v15.i8 = vcvt_f32_s32((int32x2_t)vand_s8(*a2, (int8x8_t)0x100000001));
    v15.i64[1] = 0x3F80000000000000;
    *(float *)v16.i32 = (float)((v4 - v70.i32[0]) & 1);
    v16.i32[1] = 1.0;
    v16.i64[1] = 0;
    *(int32x2_t *)v17.i8 = vsub_s32(v10, DOD);
    v17.u64[1] = (unint64_t)DOD;
    v18 = (int8x16_t)vcvtq_f32_s32(v17);
    v19 = vaddq_f32((float32x4_t)vextq_s8(v18, v18, 8uLL), (float32x4_t)v18);
    v20 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), (float32x4_t)v18);
    v21 = 16 * a2[3].i32[0];
    v22 = 0xFFFFFFFF00000000;
    v23.i64[0] = 0x3F0000003F000000;
    v23.i64[1] = 0x3F0000003F000000;
    v24 = v7;
    v25 = v12;
    while (1)
    {
      v26 = veorq_s8(v15, (int8x16_t)xmmword_1B304F230);
      if (v13 >= 2)
        break;
      v61 = 0;
      v32 = v25;
      if (v13 > 0)
        goto LABEL_10;
LABEL_3:
      v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B304F240);
      v15 = veorq_s8(v15, v16);
      *(_QWORD *)&v14 += v21;
      ++v11;
      v22 += v6 << 32;
      *(_QWORD *)&v24 += 16 * v6;
      if (v11 == v5)
        return 0;
    }
    v27 = 0;
    v28 = 0;
    v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
    v30 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 0);
    v31 = v22;
    v32 = v25;
    do
    {
      v33 = vaddq_f32(v32, (float32x4_t)xmmword_1B304F230);
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v36 = *((_QWORD *)this + 51);
      v37 = *(int8x16_t *)(v36 + 16);
      v38 = vsubq_f32(v19, *(float32x4_t *)v36);
      v39 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32(v38, vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v34, v32), *(int8x16_t *)v36, (int8x16_t)0), v34)), 0);
      v40 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32(v38, vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v35, v33), *(int8x16_t *)v36, (int8x16_t)0), v35)), 0);
      v41 = *(float32x4_t *)(v36 + 32);
      v42 = *(float32x4_t *)(v36 + 48);
      v43 = vaddq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v41), *(int8x16_t *)v36, v37));
      v44 = vaddq_f32(v33, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v40, v41), *(int8x16_t *)v36, v37));
      v45 = a2[10];
      v46 = a2[11].i32[0];
      v47 = vaddq_f32(vsubq_f32(v43, v12), v23);
      v48 = vcvtq_s32_f32(v47);
      v47.i64[0] = vaddq_s32(v48, vcgtq_f32(vcvtq_f32_s32(v48), v47)).u64[0];
      v49 = v47.i32[1];
      v50 = v47.i32[0];
      v51 = vaddq_f32(vsubq_f32(v44, v12), v23);
      v52 = vcvtq_s32_f32(v51);
      v51.i64[0] = vaddq_s32(v52, vcgtq_f32(vcvtq_f32_s32(v52), v51)).u64[0];
      v53 = *(int8x16_t *)(*(_QWORD *)&v24 + v28);
      v54 = *(int8x16_t *)(*(_QWORD *)&v24 + v28 + 16);
      v55 = (int8x16_t)vaddq_f32(*(float32x4_t *)(*(_QWORD *)&v7 + (v31 >> 28)), vmulq_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v45 + 16 * (v50 + v49 * v46)), *(float32x4_t *)(*(_QWORD *)&v7 + (v31 >> 28))), v42));
      v56 = (int8x16_t)vaddq_f32((float32x4_t)v53, vmulq_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&v45 + 16 * (v51.i32[0] + v51.i32[1] * v46)), (float32x4_t)v53), v42));
      v57 = (int8x16_t)vcgtq_f32(v29, v41);
      v58 = vbslq_s8((int8x16_t)vcgtq_f32(v30, v41), v56, v54);
      v59 = *(int8x16_t *)(v36 + 64);
      v60 = (int8x16_t *)(*(_QWORD *)&v14 + v28);
      *v60 = vbslq_s8(v59, vbslq_s8(v57, v55, v53), v53);
      v60[1] = vbslq_s8(v59, v58, v54);
      v32 = vaddq_f32(v33, (float32x4_t)xmmword_1B304F230);
      v31 += 0x200000000;
      v28 += 32;
      v27 -= 2;
    }
    while (v13 + v27 > 1);
    v61 = -v27;
    if (v61 >= v13)
      goto LABEL_3;
LABEL_10:
    v62 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
    v63 = *((_QWORD *)this + 51);
    v64 = *(float32x4_t *)(v63 + 32);
    v65 = vaddq_f32(vsubq_f32(vaddq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32(vsubq_f32(v20, *(float32x4_t *)v63), vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v62, v32), *(int8x16_t *)v63, (int8x16_t)0), v62)), 0), v64), *(int8x16_t *)v63, *(int8x16_t *)(v63 + 16))), v12),
            v23);
    v66 = vcvtq_s32_f32(v65);
    v67 = *(int8x16_t *)(*(_QWORD *)&v7 + 16 * (v11 * v6 + v61));
    v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
    v68 = *(float32x4_t *)(*(_QWORD *)&v7 + 16 * ((int)v11 * (int)v6 + v61 - 1));
    *(int8x16_t *)(*(_QWORD *)&v14 + 16 * v61) = vbslq_s8(*(int8x16_t *)(v63 + 64), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0), v64), (int8x16_t)vaddq_f32(v68, vmulq_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v65.i32[0] + v65.i32[1] * a2[11].i32[0])), v68), *(float32x4_t *)(v63 + 48))), v67), v67);
    v15 = v26;
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_chroma_upsample_f1::GetDOD(HgcColorGamma_chroma_upsample_f1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcColorGamma_chroma_upsample_f1::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcColorGamma_chroma_upsample_f1::HgcColorGamma_chroma_upsample_f1(HgcColorGamma_chroma_upsample_f1 *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65425B0;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B304F230;
  *(_OWORD *)(v3 + 16) = xmmword_1B3524180;
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3553B40;
  *(_OWORD *)(v3 + 64) = xmmword_1B30528A0;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcColorGamma_chroma_upsample_f1 *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BCC2D0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_chroma_upsample_f1::~HgcColorGamma_chroma_upsample_f1(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65425B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65425B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65425B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C404247E4FDLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_chroma_upsample_f1::SetParameter(HgcColorGamma_chroma_upsample_f1 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_chroma_upsample_f1::GetParameter(HgcColorGamma_chroma_upsample_f1 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcTextureWrapClampToEdge::GetProgram(HgcTextureWrapClampToEdge *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000036f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0 = hg_Params[1];\n"
             "    s1.xy = frag._texCoord0.xy - s0.zw;\n"
             "    s2.xy = s0.xy - float2(c0.xx);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    s1.xy = fmax(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy + s0.zw;\n"
             "    s1.xy = s1.xy + hg_Params[0].xy;\n"
             "    s1.xy = s1.xy*hg_Params[0].zw;\n"
             "    output.color0 = (float4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=221ff63d:13dd7d75:60c547a0:c3470b13\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000359\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Params[1];\n"
             "    r1.xy = frag._texCoord0.xy - r0.zw;\n"
             "    r2.xy = r0.xy - c0.xx;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1.xy = fmax(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy + r0.zw;\n"
             "    r1.xy = r1.xy + hg_Params[0].xy;\n"
             "    r1.xy = r1.xy*hg_Params[0].zw;\n"
             "    output.color0 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8f249fac:b1c9a8e2:b56a003b:e01656c1\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000034e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = hg_ProgramLocal1;\n"
           "    r1.xy = hg_TexCoord0.xy - r0.zw;\n"
           "    r2.xy = r0.xy - c0.xx;\n"
           "    r1.xy = min(r1.xy, r2.xy);\n"
           "    r1.xy = max(r1.xy, c0.xx);\n"
           "    r1.xy = r1.xy + r0.zw;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal0.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal0.zw;\n"
           "    gl_FragColor = texture2D(hg_Texture0, r1.xy);\n"
           "}\n"
           "//MD5=334048ff:96ec5d13:4628fd48:15f149a4\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcTextureWrapClampToEdge::InitProgramDescriptor(HgcTextureWrapClampToEdge *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcTextureWrapClampToEdge_hgc_visible", "//Metal1.0     \n//LEN=00000002a5\n[[ visible ]] FragmentOut HgcTextureWrapClampToEdge_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Params[1];\n"
    "    r1.xy = texCoord0.xy - r0.zw;\n"
    "    r2.xy = r0.xy - c0.xx;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1.xy = fmax(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy + r0.zw;\n"
    "    r1.xy = r1.xy + hg_Params[0].xy;\n"
    "    r1.xy = r1.xy*hg_Params[0].zw;\n"
    "    output.color0 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCC7A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCC7D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCC7D0);
}

char *HgcTextureWrapClampToEdge::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x28uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B3552EC0;
  strcpy(result, "HgcTextureWrapClampToEdge [hgc1]");
  return result;
}

uint64_t HgcTextureWrapClampToEdge::BindTexture(HgcTextureWrapClampToEdge *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(_QWORD *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
  return 0;
}

uint64_t HgcTextureWrapClampToEdge::Bind(HgcTextureWrapClampToEdge *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HgcTextureWrapClampToEdge *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcTextureWrapClampToEdge::RenderTile(HgcTextureWrapClampToEdge *this, int32x2_t *a2)
{
  __int32 v4;
  int v5;
  HGRenderer *v6;
  HGRenderer *v7;
  HGNode *Input;
  int32x2_t DOD;
  int32x2_t v10;
  float32x4_t v11;
  int32x4_t v12;
  unint64_t v13;
  int8x16_t v14;
  int32x2_t v15;
  uint64_t v16;
  float32x4_t v17;
  int v18;
  _OWORD *v19;
  uint64_t v20;
  _OWORD *v21;
  float32x4_t v22;
  float32x4_t v23;
  unint64_t v24;
  _OWORD *v25;
  _OWORD *v26;
  float32x4_t v27;
  _OWORD *v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  __int32 v34;
  float32x4_t v35;
  int32x4_t v36;
  float32x4_t v37;
  __int32 v38;
  int32x4_t v39;
  __int32 v40;
  __int32 v41;
  __int32 v42;
  float32x4_t v43;
  int32x4_t v44;
  __int32 v45;
  __int32 v46;
  __int32 v47;
  int32x2_t v48;
  __int128 v49;
  float32x4_t v50;
  int32x4_t v51;
  __int128 v52;
  __int32 v53;
  __int32 v54;
  __int128 v55;
  __int128 v56;
  float32x4_t v57;
  int32x4_t v58;
  int v59;
  float32x4_t v60;
  float32x4_t v61;
  uint64_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  int32x2_t v67;

  v4 = a2[1].i32[0];
  v67 = *a2;
  v5 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  v6 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  v7 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  Input = HGRenderer::GetInput(v7, (HGNode *)this, 0);
  DOD = (int32x2_t)HGRenderer::GetDOD(v6, Input);
  if (v5 >= 1)
  {
    *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(v67), (float32x2_t)0x3F0000003F000000);
    v11.i64[1] = 0x3F80000000000000;
    *(int32x2_t *)v12.i8 = vsub_s32(v10, DOD);
    v12.u64[1] = (unint64_t)DOD;
    v13 = (v4 - v67.i32[0]);
    v14 = (int8x16_t)vcvtq_f32_s32(v12);
    v15 = a2[2];
    v16 = a2[3].i32[0];
    v17 = (float32x4_t)vextq_s8(v14, v14, 8uLL);
    if ((int)v13 < 4)
    {
      if ((int)v13 >= 1)
      {
        v59 = 0;
        v60.i64[0] = 0x3F0000003F000000;
        v60.i64[1] = 0x3F0000003F000000;
        v61 = v11;
        do
        {
          v62 = 0;
          v63 = v61;
          do
          {
            v64 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v63, v17), vsubq_f32((float32x4_t)v14, *(float32x4_t *)*((_QWORD *)this + 51))), *(float32x4_t *)*((_QWORD *)this + 51))), v11), v60);
            v65 = vcvtq_s32_f32(v64);
            v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
            *(_OWORD *)(*(_QWORD *)&v15 + v62) = *(_OWORD *)(*(_QWORD *)&a2[10]
                                                           + 16 * (v64.i32[0] + v64.i32[1] * a2[11].i32[0]));
            v63 = vaddq_f32(v63, (float32x4_t)xmmword_1B304F230);
            v62 += 16;
          }
          while (16 * (v4 - v67.i32[0]) != v62);
          v61 = vaddq_f32(v61, (float32x4_t)xmmword_1B304F240);
          ++v59;
          *(_QWORD *)&v15 += 16 * v16;
        }
        while (v59 != v5);
      }
    }
    else
    {
      v18 = 0;
      v19 = (_OWORD *)(*(_QWORD *)&v15 + 32);
      v20 = 16 * v16;
      v21 = (_OWORD *)(*(_QWORD *)&v15 + 64);
      v22.i64[0] = 0x3F0000003F000000;
      v22.i64[1] = 0x3F0000003F000000;
      v23 = v11;
      do
      {
        v24 = 0;
        v25 = v21;
        v26 = v19;
        v27 = v23;
        do
        {
          v28 = v25;
          v29 = vaddq_f32(v27, (float32x4_t)xmmword_1B304F230);
          v30 = vaddq_f32(v29, (float32x4_t)xmmword_1B304F230);
          v31 = vaddq_f32(v30, (float32x4_t)xmmword_1B304F230);
          v32 = *(float32x4_t *)*((_QWORD *)this + 51);
          v33 = vsubq_f32((float32x4_t)v14, v32);
          v34 = a2[11].i32[0];
          v35 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v27, v17), v33), v32)), v11), v22);
          v36 = vcvtq_s32_f32(v35);
          v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
          v37 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v29, v17), v33), v32)), v11), v22);
          v38 = v35.i32[1];
          v39 = vcvtq_s32_f32(v37);
          v37.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v37)).u64[0];
          v40 = v37.i32[1];
          v41 = v35.i32[0];
          v42 = v37.i32[0];
          v43 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v30, v17), v33), v32)), v11), v22);
          v44 = vcvtq_s32_f32(v43);
          v45 = v41 + v38 * v34;
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          v46 = v42 + v40 * v34;
          v47 = v43.i32[0] + v43.i32[1] * v34;
          v48 = a2[10];
          v49 = *(_OWORD *)(*(_QWORD *)&v48 + 16 * v45);
          v50 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v31, v17), v33), v32)), v11), v22);
          v51 = vcvtq_s32_f32(v50);
          v52 = *(_OWORD *)(*(_QWORD *)&v48 + 16 * v46);
          v50.i64[0] = vaddq_s32(v51, vcgtq_f32(vcvtq_f32_s32(v51), v50)).u64[0];
          v53 = v50.i32[1];
          v54 = v50.i32[0];
          v55 = *(_OWORD *)(*(_QWORD *)&v48 + 16 * v47);
          v56 = *(_OWORD *)(*(_QWORD *)&v48 + 16 * (v54 + v53 * v34));
          *(v26 - 2) = v49;
          *(v26 - 1) = v52;
          *v26 = v55;
          v26[1] = v56;
          v26 += 4;
          v27 = vaddq_f32(v31, (float32x4_t)xmmword_1B304F230);
          v24 += 4;
          v25 = v28 + 4;
        }
        while ((uint64_t)v24 < (uint64_t)(v13 - 3));
        if ((int)v13 > (int)v24)
        {
          do
          {
            v57 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v27, v17), vsubq_f32((float32x4_t)v14, *(float32x4_t *)*((_QWORD *)this + 51))), *(float32x4_t *)*((_QWORD *)this + 51))), v11), v22);
            v58 = vcvtq_s32_f32(v57);
            v57.i64[0] = vaddq_s32(v58, vcgtq_f32(vcvtq_f32_s32(v58), v57)).u64[0];
            *v28++ = *(_OWORD *)(*(_QWORD *)&a2[10] + 16 * (v57.i32[0] + v57.i32[1] * a2[11].i32[0]));
            v27 = vaddq_f32(v27, (float32x4_t)xmmword_1B304F230);
            ++v24;
          }
          while (v24 < v13);
        }
        v23 = vaddq_f32(v23, (float32x4_t)xmmword_1B304F240);
        ++v18;
        v19 = (_OWORD *)((char *)v19 + v20);
        v21 = (_OWORD *)((char *)v21 + v20);
      }
      while (v18 != v5);
    }
  }
  return 0;
}

uint64_t HgcTextureWrapClampToEdge::GetDOD(HgcTextureWrapClampToEdge *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int128 *v4;

  v4 = &HGRectInfinite;
  if (a3)
    v4 = &HGRectNull;
  return *(_QWORD *)v4;
}

uint64_t HgcTextureWrapClampToEdge::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;

  if (a3)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcTextureWrapClampToEdge::HgcTextureWrapClampToEdge(HgcTextureWrapClampToEdge *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6542818;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3052100;
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcTextureWrapClampToEdge *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B2BCCDE4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcTextureWrapClampToEdge::~HgcTextureWrapClampToEdge(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542818;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542818;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6542818;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcTextureWrapClampToEdge::SetParameter(HgcTextureWrapClampToEdge *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcTextureWrapClampToEdge::GetParameter(HgcTextureWrapClampToEdge *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcToneParamCurve2::GetProgram(HgcToneParamCurve2 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r1.xyz = r1.xyz + half3(hg_Params[3].xyz);\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[4].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), hg_Params[3].xyz, float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=11f96f30:b2be53b4:29dcc524:84f02f26\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000329\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r1.xyz = r1.xyz + hg_Params[3].xyz;\n"
             "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, hg_Params[3].xyz, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=882be748:9bb58854:7a0b6941:5bec227a\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r1.xyz = r1.xyz + hg_ProgramLocal3.xyz;\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal4.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? hg_ProgramLocal3.x : r1.x, r2.y < 0.00000 ? hg_ProgramLocal3.y :"
           " r1.y, r2.z < 0.00000 ? hg_ProgramLocal3.z : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=6881b252:4d76b384:24ec1fbe:a73e8ed3\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve2::InitProgramDescriptor(HgcToneParamCurve2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve2_hgc_visible", "//Metal1.0     \n//LEN=0000000205\n[[ visible ]] FragmentOut HgcToneParamCurve2_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r1.xyz = r1.xyz + hg_Params[3].xyz;\n"
    "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, hg_Params[3].xyz, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCD184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCD1B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCD1ACLL);
}

double HgcToneParamCurve2::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcToneParamCurve2 [hgc1]");
  return *(double *)"ramCurve2 [hgc1]";
}

uint64_t HgcToneParamCurve2::BindTexture(HgcToneParamCurve2 *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve2::Bind(HgcToneParamCurve2 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcToneParamCurve2 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve2::RenderTile(HgcToneParamCurve2 *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t v9;
  int v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  uint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t *v64;
  int v65;
  uint64_t v66;
  float32x4_t v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    v9.i64[0] = 0x8000000080000000;
    v9.i64[1] = 0x8000000080000000;
    while (v4 < 2)
    {
      v65 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v10 = 0;
    v11 = 16;
    do
    {
      v13 = *(float32x4_t *)(v6 + v11 - 16);
      v12 = *(float32x4_t *)(v6 + v11);
      v14 = *((_QWORD *)this + 51);
      v15 = *(float32x4_t *)(v14 + 16);
      v16 = *(float32x4_t *)(v14 + 32);
      v17 = *(float32x4_t *)(v14 + 48);
      v18 = vaddq_f32(v16, vmulq_f32(v13, v15));
      v19 = vaddq_f32(v16, vmulq_f32(v12, v15));
      v21 = *(float32x4_t *)(v14 + 64);
      v20 = *(int8x16_t *)(v14 + 80);
      v22 = *(float32x4_t *)(v14 + 96);
      v23 = *(float32x4_t *)(v14 + 112);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v22);
      v25 = *(int8x16_t *)(v14 + 128);
      v26 = *(float32x4_t *)(v14 + 144);
      v27 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v22);
      v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v19)));
      v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v18))), v26);
      v30 = *(float32x4_t *)(v14 + 160);
      v31 = *(float32x4_t *)(v14 + 176);
      v32 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v24, v30));
      v33 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v27, v30));
      v34 = vaddq_f32(v29, v32);
      v35 = vaddq_f32(vsubq_f32(v28, v26), v33);
      v36 = vsubq_f32(vsubq_f32(v24, v22), vmulq_f32(vmulq_f32(v31, v32), v24));
      v37 = vsubq_f32(vsubq_f32(v27, v22), vmulq_f32(vmulq_f32(v31, v33), v27));
      v38 = *(float32x4_t *)(v14 + 192);
      v39 = *(float32x4_t *)(v14 + 208);
      v40 = vaddq_f32(v38, vmulq_f32(v39, v36));
      v41 = vaddq_f32(v38, vmulq_f32(v39, v37));
      v42 = *(float32x4_t *)(v14 + 224);
      v43 = *(float32x4_t *)(v14 + 240);
      v44 = vmulq_f32(*(float32x4_t *)v14, vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v42, vmulq_f32(v37, v43)), vmulq_f32(vmulq_f32(v37, v37), v41)))));
      v45 = *(float32x4_t *)(v14 + 256);
      v46 = *(float32x4_t *)(v14 + 272);
      v47 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v14, vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v42, vmulq_f32(v36, v43)), vmulq_f32(vmulq_f32(v36, v36), v40))))), v45);
      v48 = vmaxq_f32(v44, v45);
      v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v49, v47)));
      v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v50, v48)));
      v53 = vsubq_f32(v47, v51);
      v54 = vsubq_f32(v48, v52);
      v55 = *(float32x4_t *)(v14 + 288);
      v56 = *(float32x4_t *)(v14 + 304);
      v57 = vmulq_f32(v54, vaddq_f32(v56, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v55, v54)))));
      v58 = vaddq_f32(v22, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, vaddq_f32(v46, vmulq_f32(v55, v53))))));
      v59 = vcvtq_s32_f32(v52);
      v60 = *(int32x4_t *)(v14 + 320);
      v61 = *(float32x4_t *)(v14 + 336);
      v62 = (int8x16_t)vaddq_f32(v17, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v13, v21)), v9, (int8x16_t)vmulq_f32(v58, (float32x4_t)vshlq_n_s32(vaddq_s32(v60, vcvtq_s32_f32(v51)), 0x17uLL))));
      v63 = *(int8x16_t *)(v14 + 352);
      v64 = (int8x16_t *)(v5 + v11);
      v64[-1] = vbslq_s8(v63, (int8x16_t)v13, v62);
      *v64 = vbslq_s8(v63, (int8x16_t)v12, (int8x16_t)vaddq_f32(v17, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v12, v21)), v9, (int8x16_t)vmulq_f32(vaddq_f32(v22, v57), (float32x4_t)vshlq_n_s32(vaddq_s32(v60, v59), 0x17uLL)))));
      v10 -= 2;
      v11 += 32;
    }
    while (v4 + v10 > 1);
    v65 = -v10;
    if (v65 >= v4)
      goto LABEL_3;
LABEL_10:
    v66 = 16 * v65;
    v67 = *(float32x4_t *)(v6 + v66);
    v68 = *((_QWORD *)this + 51);
    v69 = vaddq_f32(*(float32x4_t *)(v68 + 32), vmulq_f32(v67, *(float32x4_t *)(v68 + 16)));
    v70 = *(float32x4_t *)(v68 + 96);
    v71 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v68 + 80), (int8x16_t)v69), (int8x16_t)v70);
    v72 = (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v71, *(float32x4_t *)(v68 + 160)));
    v73 = vsubq_f32(vsubq_f32(v71, v70), vmulq_f32(vmulq_f32(*(float32x4_t *)(v68 + 176), v72), v71));
    v74 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v68, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v68 + 128), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v68 + 112), v69))), *(float32x4_t *)(v68 + 144)), v72), vmulq_f32(v73, vaddq_f32(vaddq_f32(*(float32x4_t *)(v68 + 224), vmulq_f32(v73, *(float32x4_t *)(v68 + 240))), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(*(float32x4_t *)(v68 + 192), vmulq_f32(*(float32x4_t *)(v68 + 208), v73))))))),
            *(float32x4_t *)(v68 + 256));
    v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
    v76 = vsubq_f32(v75, (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v75, v74)));
    v77 = vsubq_f32(v74, v76);
    *(int8x16_t *)(v5 + v66) = vbslq_s8(*(int8x16_t *)(v68 + 352), (int8x16_t)v67, (int8x16_t)vaddq_f32(*(float32x4_t *)(v68 + 48), (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v68 + 336), vsubq_f32(v67, *(float32x4_t *)(v68 + 64))), v9, (int8x16_t)vmulq_f32(vaddq_f32(v70, vmulq_f32(v77, vaddq_f32(*(float32x4_t *)(v68 + 304), vmulq_f32(v77, vaddq_f32(
                                                                                    *(float32x4_t *)(v68 + 272),
                                                                                    vmulq_f32(*(float32x4_t *)(v68 + 288), v77)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v68 + 320), vcvtq_s32_f32(v76)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve2::GetDOD(HgcToneParamCurve2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve2::GetROI(HgcToneParamCurve2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve2::HgcToneParamCurve2(HgcToneParamCurve2 *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6542A80;
  v3 = operator new();
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 256) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 304) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 320) = xmmword_1B30516D0;
  *(_QWORD *)(v3 + 336) = 0;
  *(_QWORD *)(v3 + 344) = 0;
  *(_OWORD *)(v3 + 352) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BCD864(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve2::~HgcToneParamCurve2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542A80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6542A80;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C409BD2D9E4);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve2::SetParameter(HgcToneParamCurve2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve2::GetParameter(HgcToneParamCurve2 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 4)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve1::GetProgram(HgcToneParamCurve1 *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000388\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[3].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(c0.xxx), float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bbf4a9d3:8ac3c576:5d1632bf:935fc9e2\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000349\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r0.xyz - hg_Params[3].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, c0.xxx, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6f388f1a:83ba6503:f0c59378:67222bba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ce\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal3.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? c0.x : r1.x, r2.y < 0.00000 ? c0.x : r1.y, r2.z < 0.00000 ? c0.x"
           " : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=073b1929:ac9c9606:88f5e5f8:42afc5ab\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve1::InitProgramDescriptor(HgcToneParamCurve1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve1_hgc_visible", "//Metal1.0     \n//LEN=0000000225\n[[ visible ]] FragmentOut HgcToneParamCurve1_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r0.xyz - hg_Params[3].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, c0.xxx, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B2BCDC78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0)
    operator delete(__p);
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B2BCDCA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B2BCDCA0);
}

double HgcToneParamCurve1::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  char *v3;

  v3 = (char *)operator new(0x20uLL);
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B35257A0;
  strcpy(v3, "HgcToneParamCurve1 [hgc1]");
  return *(double *)"ramCurve1 [hgc1]";
}

uint64_t HgcToneParamCurve1::BindTexture(HgcToneParamCurve1 *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve1::Bind(HgcToneParamCurve1 *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HgcToneParamCurve1 *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcToneParamCurve1::RenderTile(HgcToneParamCurve1 *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t *v63;
  int v64;
  uint64_t v65;
  float32x4_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      v64 = 0;
      if (v4 > 0)
        goto LABEL_10;
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2)
        return 0;
    }
    v9 = 0;
    v10 = 16;
    do
    {
      v12 = *(float32x4_t *)(v6 + v10 - 16);
      v11 = *(float32x4_t *)(v6 + v10);
      v13 = *((_QWORD *)this + 51);
      v14 = *(float32x4_t *)(v13 + 16);
      v15 = *(float32x4_t *)(v13 + 32);
      v16 = *(float32x4_t *)(v13 + 48);
      v17 = vaddq_f32(v15, vmulq_f32(v12, v14));
      v18 = vaddq_f32(v15, vmulq_f32(v11, v14));
      v19 = *(int8x16_t *)(v13 + 64);
      v20 = *(float32x4_t *)(v13 + 80);
      v21 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v20);
      v22 = *(float32x4_t *)(v13 + 96);
      v23 = *(int8x16_t *)(v13 + 112);
      v24 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v20);
      v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v22, v17)));
      v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v22, v18)));
      v27 = *(float32x4_t *)(v13 + 128);
      v28 = *(float32x4_t *)(v13 + 144);
      v29 = vsubq_f32(v25, v27);
      v30 = vsubq_f32(v26, v27);
      v31 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v21, v28));
      v32 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v24, v28));
      v33 = *(float32x4_t *)(v13 + 160);
      v34 = *(float32x4_t *)(v13 + 176);
      v35 = vaddq_f32(v30, v32);
      v36 = vsubq_f32(vsubq_f32(v21, v20), vmulq_f32(vmulq_f32(v33, v31), v21));
      v37 = vsubq_f32(vsubq_f32(v24, v20), vmulq_f32(vmulq_f32(v33, v32), v24));
      v38 = *(float32x4_t *)(v13 + 192);
      v39 = *(float32x4_t *)(v13 + 208);
      v40 = vaddq_f32(v34, vmulq_f32(v38, v36));
      v41 = vaddq_f32(v34, vmulq_f32(v38, v37));
      v42 = *(float32x4_t *)(v13 + 224);
      v43 = *(float32x4_t *)(v13 + 240);
      v44 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(vaddq_f32(v29, v31), vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v36, v42)), vmulq_f32(vmulq_f32(v36, v36), v40))))), v43);
      v45 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v39, vmulq_f32(v37, v42)), vmulq_f32(vmulq_f32(v37, v37), v41))))), v43);
      v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v46, v44)));
      v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v47, v45)));
      v50 = vsubq_f32(v44, v48);
      v51 = vsubq_f32(v45, v49);
      v52 = *(float32x4_t *)(v13 + 256);
      v53 = *(float32x4_t *)(v13 + 272);
      v54 = vaddq_f32(v52, vmulq_f32(v53, v50));
      v55 = vaddq_f32(v52, vmulq_f32(v53, v51));
      v56 = vmulq_f32(v50, v54);
      v57 = *(float32x4_t *)(v13 + 288);
      v58 = *(int32x4_t *)(v13 + 304);
      v59 = vaddq_f32(v20, vmulq_f32(v51, vaddq_f32(v57, vmulq_f32(v51, v55))));
      v60 = (int8x16_t)vmulq_f32(vaddq_f32(v20, vmulq_f32(v50, vaddq_f32(v57, v56))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v48)), 0x17uLL));
      v61 = *(float32x4_t *)(v13 + 320);
      v62 = *(int8x16_t *)(v13 + 336);
      v63 = (int8x16_t *)(v5 + v10);
      v63[-1] = vbslq_s8(v62, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v12, v16)), (int8x16_t)v61, v60));
      *v63 = vbslq_s8(v62, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v11, v16)), (int8x16_t)v61, (int8x16_t)vmulq_f32(v59, (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v49)), 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    v64 = -v9;
    if (v64 >= v4)
      goto LABEL_3;
LABEL_10:
    v65 = 16 * v64;
    v66 = *(float32x4_t *)(v6 + v65);
    v67 = *((_QWORD *)this + 51);
    v68 = vaddq_f32(*(float32x4_t *)(v67 + 32), vmulq_f32(v66, *(float32x4_t *)(v67 + 16)));
    v69 = *(float32x4_t *)(v67 + 80);
    v70 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v67 + 64), (int8x16_t)v68), (int8x16_t)v69);
    v71 = (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v70, *(float32x4_t *)(v67 + 144)));
    v72 = vsubq_f32(vsubq_f32(v70, v69), vmulq_f32(vmulq_f32(*(float32x4_t *)(v67 + 160), v71), v70));
    v73 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v67, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v67 + 112), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 96), v68))), *(float32x4_t *)(v67 + 128)), v71), vmulq_f32(v72, vaddq_f32(vaddq_f32(*(float32x4_t *)(v67 + 208), vmulq_f32(v72, *(float32x4_t *)(v67 + 224))), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(*(float32x4_t *)(v67 + 176), vmulq_f32(*(float32x4_t *)(v67 + 192), v72))))))),
            *(float32x4_t *)(v67 + 240));
    v74 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
    v75 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v74, v73)));
    v76 = vsubq_f32(v73, v75);
    *(int8x16_t *)(v5 + v65) = vbslq_s8(*(int8x16_t *)(v67 + 336), (int8x16_t)v66, vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 320), vsubq_f32(v66, *(float32x4_t *)(v67 + 48))), *(int8x16_t *)(v67 + 320), (int8x16_t)vmulq_f32(vaddq_f32(v69, vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 288), vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 256), vmulq_f32(*(float32x4_t *)(v67 + 272), v76)))))),
                                                (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v67 + 304), vcvtq_s32_f32(v75)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve1::GetDOD(HgcToneParamCurve1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcToneParamCurve1::GetROI(HgcToneParamCurve1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcToneParamCurve1::HgcToneParamCurve1(HgcToneParamCurve1 *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E6542CE8;
  v3 = operator new();
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 64) = xmmword_1B3051600;
  *(_OWORD *)(v3 + 80) = xmmword_1B3051560;
  *(_OWORD *)(v3 + 96) = xmmword_1B3051610;
  *(_OWORD *)(v3 + 112) = xmmword_1B3051620;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051630;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051640;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051510;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051650;
  *(_OWORD *)(v3 + 192) = xmmword_1B3051660;
  *(_OWORD *)(v3 + 208) = xmmword_1B3051670;
  *(_OWORD *)(v3 + 224) = xmmword_1B3051680;
  *(_OWORD *)(v3 + 240) = xmmword_1B3051690;
  *(_OWORD *)(v3 + 256) = xmmword_1B30516A0;
  *(_OWORD *)(v3 + 272) = xmmword_1B30516B0;
  *(_OWORD *)(v3 + 288) = xmmword_1B30516C0;
  *(_OWORD *)(v3 + 304) = xmmword_1B30516D0;
  *(_QWORD *)(v3 + 320) = 0;
  *(_QWORD *)(v3 + 328) = 0;
  *(_OWORD *)(v3 + 336) = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B2BCE31C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve1::~HgcToneParamCurve1(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6542CE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AF73A19ALL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6542CE8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AF73A19ALL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve1::SetParameter(HgcToneParamCurve1 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

