void sub_24111B390(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_24111B54C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id MakeMTLTextureDescriptorFromTexture(void *a1)
{
  id v1;
  id v2;
  void *v3;
  int v4;

  v1 = a1;
  v2 = objc_alloc_init(MEMORY[0x24BDDD740]);
  objc_msgSend(v2, "setPixelFormat:", objc_msgSend(v1, "pixelFormat"));
  objc_msgSend(v2, "setWidth:", objc_msgSend(v1, "width"));
  objc_msgSend(v2, "setHeight:", objc_msgSend(v1, "height"));
  objc_msgSend(v2, "setResourceOptions:", 32);
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_msgSend(v1, "device");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = objc_msgSend(v3, "supportsFamily:", 1003);

    if (v4)
      objc_msgSend(v2, "setSwizzle:", objc_msgSend(v1, "swizzle"));
  }

  return v2;
}

void sub_24111B670(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_24111B9D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_24111BC6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_24111BE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_24111C3D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_24111C744(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_24111CBA8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_24111D10C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_24111D284(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t DYHarvesterInitMetadata(uint64_t result, __int16 a2, int a3)
{
  *(_QWORD *)result = 0x63617074757265;
  *(_WORD *)(result + 8) = 2;
  *(_WORD *)(result + 10) = a2;
  *(_DWORD *)(result + 12) = a3;
  *(_QWORD *)(result + 16) = 0;
  return result;
}

uint64_t DYHarvesterGetMetadataSize(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 8) == 1)
      return *(int *)(result + 12) + 16;
    else
      return *(int *)(result + 12);
  }
  return result;
}

_QWORD *DYHarvesterGetMetadata(_QWORD *result)
{
  if (result)
  {
    if (*result != 0x63617074757265)
      return 0;
  }
  return result;
}

uint64_t DYHarvesterGetDataSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (a1 && *(_QWORD *)a1 == 0x63617074757265)
  {
    v2 = *(int *)(a1 + 12);
    if (*(_WORD *)(a1 + 8) == 1)
      v2 += 16;
    a2 -= v2;
  }
  return a2;
}

uint64_t DYHarvesterGetOffset(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)result == 0x63617074757265)
    {
      if (*(_WORD *)(result + 8) == 1)
        return *(int *)(result + 12) + 16;
      else
        return *(int *)(result + 12);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DYHarvesterGetData(uint64_t result)
{
  uint64_t v1;

  if (result && *(_QWORD *)result == 0x63617074757265)
  {
    v1 = *(int *)(result + 12);
    if (*(_WORD *)(result + 8) == 1)
      v1 += 16;
    result += v1;
  }
  return result;
}

unint64_t DYHarvesterGetTextureMetadataRequiredSize(uint64_t a1)
{
  return (48 * a1 + 279) & 0xFFFFFFFFFFFFFF00;
}

uint64_t DYHarvesterGetTexturePlaneCount(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 10) == 1)
      return *(_QWORD *)(result + 16);
    else
      return 0;
  }
  return result;
}

uint64_t DYHarvesterGetTexturePlane(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(_WORD *)(result + 10) == 1)
    {
      if (*(_QWORD *)(result + 16) >= a2)
        result += 48 * a2 + 24;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__n128 DYHarvesterAddTexturePlane(uint64_t a1, __int128 *a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;

  v2 = a1 + 48 * *(_QWORD *)(a1 + 16);
  v4 = *a2;
  result = (__n128)a2[1];
  *(_OWORD *)(v2 + 56) = a2[2];
  *(_OWORD *)(v2 + 24) = v4;
  *(__n128 *)(v2 + 40) = result;
  ++*(_QWORD *)(a1 + 16);
  return result;
}

float64_t DYShaderProfilerTiming::Statistics::operator+=(float64x2_t *a1, float64x2_t *a2)
{
  float64_t result;

  *a1 = vaddq_f64(*a2, *a1);
  result = a2[1].f64[0] + a1[1].f64[0];
  a1[1].f64[0] = result;
  return result;
}

float64_t DYShaderProfilerTiming::Statistics::operator*=(float64x2_t *a1, double a2)
{
  float64_t result;

  *a1 = vmulq_n_f64(*a1, a2);
  result = a1[1].f64[0] * a2;
  a1[1].f64[0] = result;
  return result;
}

double DYShaderProfilerTiming::Statistics::operator+(double *a1, double *a2)
{
  return *a1 + *a2;
}

double DYShaderProfilerTiming::Statistics::operator*(double *a1, double a2)
{
  return *a1 * a2;
}

DYShaderProfilerTiming *DYShaderProfilerTiming::SetCycle(DYShaderProfilerTiming *this, double a2, double a3, double a4)
{
  this->_cycle.average = a2;
  this->_cycle.min = a3;
  this->_cycle.max = a4;
  return this;
}

float64x2_t DYShaderProfilerTiming::UpdateDependantVariables(DYShaderProfilerTiming *this, float64x2_t result, double a3)
{
  double v3;
  double v4;

  if (result.f64[0] != 0.0 && a3 != 0.0)
  {
    v3 = a3 / result.f64[0];
    v4 = v3 * this->_cycle.max;
    result = vmulq_n_f64(*(float64x2_t *)&this->_cycle.average, v3);
    *(float64x2_t *)&this->_time.average = result;
    this->_time.max = v4;
  }
  return result;
}

float64_t DYShaderProfilerTiming::operator+=(float64x2_t *a1, float64x2_t *a2)
{
  float64_t result;

  *a1 = vaddq_f64(*a2, *a1);
  result = a2[1].f64[0] + a1[1].f64[0];
  a1[1].f64[0] = result;
  return result;
}

void sub_24111D954(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_24111DDAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_24111DED8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_24111E36C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_24111E698(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<int,unsigned int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,unsigned int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,unsigned int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,unsigned int>>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<int,unsigned int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,unsigned int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,unsigned int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,unsigned int>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[2];
  char v25;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = (_QWORD *)*v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = a1 + 16;
  v14 = (char *)operator new(0x40uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *(_QWORD *)v14 = 0;
  *((_QWORD *)v14 + 1) = v7;
  *((_QWORD *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  v25 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v13;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8)
          v22 %= v8;
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  v11 = (_QWORD *)v24[0];
  v24[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return v11;
}

void sub_24111E9E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<int,unsigned int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,unsigned int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,unsigned int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,unsigned int>>>::~__hash_table((uint64_t)v2 + 24);
    operator delete(v2);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<int,unsigned int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,unsigned int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,unsigned int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,unsigned int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x18uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *v11 = *v20;
LABEL_38:
    *v20 = v11;
    goto LABEL_39;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v21 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_24111EEA4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void sub_24111F194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_24111F4A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_24111F7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void sub_24111F9B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_24111FAD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_24111FD1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_24111FE10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t GPUTools::MTL::Utils::DYMTLCounter::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned __int8 *v6;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const void **v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  uint64_t result;

  v2 = a1[23];
  if ((v2 & 0x80u) == 0)
    v3 = a1[23];
  else
    v3 = *((_QWORD *)a1 + 1);
  v4 = a2[23];
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 0;
  v6 = a2;
  if (v5 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)))
      return 0;
  }
  else if (a1[23])
  {
    v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2)
        goto LABEL_16;
    }
    return 0;
  }
LABEL_16:
  v9 = a1[47];
  if ((v9 & 0x80u) == 0)
    v10 = a1[47];
  else
    v10 = *((_QWORD *)a1 + 4);
  v11 = v6[47];
  v12 = (char)v11;
  if ((v11 & 0x80u) != 0)
    v11 = *((_QWORD *)v6 + 4);
  if (v10 != v11)
    return 0;
  v13 = (const void **)(a1 + 24);
  v16 = (unsigned __int8 *)*((_QWORD *)v6 + 3);
  v15 = v6 + 24;
  v14 = v16;
  if (v12 >= 0)
    v17 = v15;
  else
    v17 = v14;
  if ((v9 & 0x80) != 0)
    return memcmp(*v13, v17, *((_QWORD *)a1 + 4)) == 0;
  if (!a1[47])
    return 1;
  v18 = v9 - 1;
  do
  {
    v20 = *(unsigned __int8 *)v13;
    v13 = (const void **)((char *)v13 + 1);
    v19 = v20;
    v22 = *v17++;
    v21 = v22;
    v24 = v18-- != 0;
    result = v19 == v21;
  }
  while (v19 == v21 && v24);
  return result;
}

uint64_t GPUTools::MTL::Utils::DYMTLCounterSet::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned __int8 *v6;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const void **v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t result;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  unint64_t v20;
  char v21;

  v2 = a1[23];
  if ((v2 & 0x80u) == 0)
    v3 = a1[23];
  else
    v3 = *((_QWORD *)a1 + 1);
  v4 = a2[23];
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 0;
  v6 = a2;
  if (v5 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)))
      return 0;
  }
  else if (a1[23])
  {
    v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2)
        goto LABEL_16;
    }
    return 0;
  }
LABEL_16:
  v9 = a1[47];
  if ((v9 & 0x80u) == 0)
    v10 = a1[47];
  else
    v10 = *((_QWORD *)a1 + 4);
  v11 = v6[47];
  v12 = (char)v11;
  if ((v11 & 0x80u) != 0)
    v11 = *((_QWORD *)v6 + 4);
  if (v10 != v11)
    return 0;
  v13 = (const void **)(a1 + 24);
  if (v12 >= 0)
    v14 = v6 + 24;
  else
    v14 = (unsigned __int8 *)*((_QWORD *)v6 + 3);
  if ((v9 & 0x80) != 0)
  {
    if (!memcmp(*v13, v14, *((_QWORD *)a1 + 4)))
      goto LABEL_31;
    return 0;
  }
  if (a1[47])
  {
    while (*(unsigned __int8 *)v13 == *v14)
    {
      v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v9)
        goto LABEL_31;
    }
    return 0;
  }
LABEL_31:
  v15 = *((_QWORD *)a1 + 6);
  if (v15 != *((_QWORD *)v6 + 6) || *((_QWORD *)a1 + 103) != *((_QWORD *)v6 + 103))
    return 0;
  if (!v15)
    return 1;
  result = GPUTools::MTL::Utils::DYMTLCounter::operator==(a1 + 56, v6 + 56);
  if ((_DWORD)result)
  {
    v17 = v6 + 104;
    v18 = a1 + 104;
    v19 = 1;
    do
    {
      v20 = v19;
      if (v15 == v19)
        break;
      v21 = GPUTools::MTL::Utils::DYMTLCounter::operator==(v18, v17);
      v19 = v20 + 1;
      v17 += 48;
      v18 += 48;
    }
    while ((v21 & 1) != 0);
    return v20 >= v15;
  }
  return result;
}

void GPUTools::MTL::Utils::MakeAliasResourceList(unint64_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *a1;
  if (*a1)
  {
    v4 = a1;
    LODWORD(v5) = 0;
    v6 = (_QWORD *)(a2 + 16);
    v7 = *(unint64_t **)(a2 + 8);
    do
    {
      v9 = v4[1];
      ++v4;
      v8 = v9;
      if ((unint64_t)v7 >= *v6)
      {
        v11 = *(unint64_t **)a2;
        v12 = ((uint64_t)v7 - *(_QWORD *)a2) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v14 = *v6 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v6, v15);
          v11 = *(unint64_t **)a2;
          v7 = *(unint64_t **)(a2 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v8;
        v10 = (unint64_t *)(v17 + 8);
        while (v7 != v11)
        {
          v18 = *--v7;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        *(_QWORD *)a2 = v17;
        *(_QWORD *)(a2 + 8) = v10;
        *(_QWORD *)(a2 + 16) = &v16[8 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v7 = v8;
        v10 = v7 + 1;
      }
      *(_QWORD *)(a2 + 8) = v10;
      v5 = (v5 + 1);
      v7 = v10;
    }
    while (v2 > v5);
  }
}

void GPUTools::MTL::Utils::EnumerateValidAttachmentsForType(_QWORD *a1, char a2, void *a3)
{
  void (**v5)(id, _QWORD *, uint64_t, uint64_t, char *);
  uint64_t v6;
  _QWORD *v7;
  char v8;

  v5 = a3;
  v8 = 0;
  if ((a2 & 1) != 0)
  {
    v6 = 0;
    v7 = a1 + 2;
    while (1)
    {
      if (*v7)
      {
        v5[2](v5, v7, 1, v6, &v8);
        if (v8)
          break;
      }
      ++v6;
      v7 += 18;
      if (v6 == 8)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    if ((a2 & 2) != 0 && a1[146])
    {
      v5[2](v5, a1 + 146, 2, 0, &v8);
      if ((a2 & 4) == 0 || v8)
        goto LABEL_14;
    }
    else if ((a2 & 4) == 0)
    {
      goto LABEL_14;
    }
    if (a1[164])
      v5[2](v5, a1 + 164, 4, 0, &v8);
  }
LABEL_14:

}

void sub_241120364(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD **GPUTools::MTL::Utils::MakeDYMTLRenderPassDescriptor(uint64_t a1, _QWORD *a2)
{
  unsigned int v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  _QWORD **result;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  _OWORD __src[100];
  uint64_t *v24;

  v4 = *(_DWORD *)a1;
  bzero(__src, 0x63BuLL);
  v5 = 1;
  do
  {
    v6 = &__src[v5];
    v6[2] = 0uLL;
    v6[3] = 0uLL;
    *v6 = 0uLL;
    v6[1] = 0uLL;
    *((_QWORD *)v6 + 8) = 0;
    *((_QWORD *)v6 + 9) = 1;
    v6[5] = 0uLL;
    v6[6] = 0uLL;
    *((_QWORD *)v6 + 14) = 0x3FF0000000000000;
    v5 += 9;
    *((_QWORD *)v6 + 16) = 0;
    *((_QWORD *)v6 + 17) = 0;
  }
  while (v6 + 9 != &__src[73]);
  memset(&__src[73], 0, 72);
  *((_QWORD *)&__src[77] + 1) = 1;
  memset(&__src[78], 0, 32);
  *(_QWORD *)&__src[80] = 0x3FF0000000000000;
  memset(&__src[81], 0, 88);
  *((_QWORD *)&__src[86] + 1) = 1;
  memset(&__src[87], 0, 32);
  *(_QWORD *)&__src[89] = 0x3FF0000000000000;
  __src[90] = 0uLL;
  memcpy(a2, __src, 0x63BuLL);
  *a2 = *(_QWORD *)(a1 + 8);
  v24 = (uint64_t *)(a1 + 24);
  for (i = *(_QWORD *)(a1 + 16); i != -1; ++v24)
  {
    GPUTools::MTL::Utils::MakeDYMTLRenderPassAttachmentDescriptor(&v24, (uint64_t)&a2[18 * i + 2], v4);
    i = *v24;
  }
  GPUTools::MTL::Utils::MakeDYMTLRenderPassAttachmentDescriptor(&v24, (uint64_t)(a2 + 146), v4);
  if (v4 <= 4)
  {
    result = GPUTools::MTL::Utils::MakeDYMTLRenderPassAttachmentDescriptor(&v24, (uint64_t)(a2 + 164), v4);
LABEL_27:
    a2[198] = 0;
    goto LABEL_28;
  }
  v8 = *v24++;
  if (v8 == -1)
    v9 = 0;
  else
    v9 = v8;
  a2[162] = v9;
  result = GPUTools::MTL::Utils::MakeDYMTLRenderPassAttachmentDescriptor(&v24, (uint64_t)(a2 + 164), v4);
  if (v4 < 7)
    goto LABEL_27;
  v11 = v24;
  v12 = *v24++;
  v13 = v12 == -1 ? 0 : v12;
  a2[1] = v13;
  if (v4 <= 0xC)
    goto LABEL_27;
  a2[182] = v11[1];
  a2[183] = v11[2];
  a2[184] = v11[3];
  a2[185] = v11[4];
  a2[186] = v11[5];
  a2[187] = v11[6];
  a2[188] = v11[7];
  a2[198] = 0;
  if (v4 == 13)
    return result;
  v14 = v11 + 9;
  v24 = v11 + 9;
  v15 = v11[8];
  if (v15)
  {
    a2[198] = v15;
    v16 = (_DWORD *)a2 + 381;
    do
    {
      *(v16 - 1) = *(_DWORD *)v14;
      v17 = v14 + 2;
      *v16 = *((_DWORD *)v14 + 2);
      v16 += 2;
      v14 += 2;
      --v15;
    }
    while (v15);
    v24 = v17;
    v14 = v17;
  }
  if (v4 >= 0x14)
  {
    v18 = *v14;
    v24 = v14 + 1;
    v19 = v18 == -1 ? 0 : v18;
    a2[181] = v19;
    if (v4 >= 0x18)
    {
      v24 = v14 + 2;
      *((_BYTE *)a2 + 1592) = v14[1] != 0;
      if (v4 >= 0x21)
      {
        v24 = v14 + 3;
        a2[189] = v14[2];
      }
    }
  }
LABEL_28:
  if ((v4 & 0xFFFFFFFE) == 0x22)
  {
    v20 = v24 - 3;
    do
    {
      v21 = v20[3];
      v20 += 4;
    }
    while (v21 != -1);
    v24 = v20;
  }
  if (v4 >= 0x27)
  {
    v22 = v24;
    *((_BYTE *)a2 + 1593) = *v24 != 0;
    if (v4 >= 0x43)
      *((_BYTE *)a2 + 1594) = v22[1] != 0;
  }
  return result;
}

_QWORD **GPUTools::MTL::Utils::MakeDYMTLRenderPassAttachmentDescriptor(_QWORD **result, uint64_t a2, unsigned int a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  *(_QWORD *)a2 = **result;
  *(_QWORD *)(a2 + 8) = v3[1];
  *(_QWORD *)(a2 + 16) = v3[2];
  v4 = v3[3];
  *result = v3 + 3;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v3[4];
  *(_QWORD *)(a2 + 40) = v3[5];
  *(_QWORD *)(a2 + 48) = v3[6];
  *(_QWORD *)(a2 + 56) = v3[7];
  *(_OWORD *)(a2 + 64) = *((_OWORD *)v3 + 4);
  if (a3 < 0x13)
  {
    v5 = v3 + 10;
  }
  else
  {
    v5 = v3 + 11;
    *(_QWORD *)(a2 + 80) = v3[10];
  }
  v6 = *v5;
  *result = v5 + 1;
  *(_QWORD *)(a2 + 88) = v6;
  v7 = *(*result)++;
  *(_QWORD *)(a2 + 96) = v7;
  v8 = *(*result)++;
  *(_QWORD *)(a2 + 104) = v8;
  v9 = *(*result)++;
  *(_QWORD *)(a2 + 112) = v9;
  if (a3 >= 0x27)
  {
    v10 = *(*result)++;
    *(_BYTE *)(a2 + 120) = v10 != 0;
  }
  return result;
}

double GPUTools::MTL::Utils::MakeDYMTLRenderPipelineDescriptor(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  unsigned int v5;
  uint64_t v6;
  char *v7;
  unsigned int *v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD *v14;
  unsigned int *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  __int128 v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  __int128 v32;
  uint64_t v33;
  _QWORD v34[344];

  v4 = (_OWORD *)(a2 + 1560);
  v5 = *(_DWORD *)a1;
  bzero(&v32, 0x617uLL);
  bzero(&v34[192], 0x250uLL);
  v6 = 1576;
  do
  {
    v7 = (char *)&v32 + v6;
    *(_QWORD *)v7 = 1;
    *((_QWORD *)v7 + 1) = 0;
    *((_QWORD *)v7 + 2) = 0;
    *((_QWORD *)v7 + 3) = 1;
    *((_QWORD *)v7 + 4) = 0;
    *((_QWORD *)v7 + 5) = 0;
    *((_OWORD *)v7 + 3) = xmmword_24114E040;
    v6 += 72;
    v7[64] = 0;
  }
  while (v7 + 72 != (char *)&v34[266]);
  memset(&v34[266], 0, 25);
  bzero(&v34[270], 0x211uLL);
  memset(&v34[337], 0, 56);
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  *(_OWORD *)a2 = v32;
  *(_QWORD *)(a2 + 16) = v33;
  memcpy((void *)(a2 + 24), v34, 0xAC0uLL);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 16);
  if (v5 >= 0x1A)
  {
    v8 = (unsigned int *)(a1 + 32);
    v9 = *(unsigned int *)(a1 + 24);
    if (!(_DWORD)v9)
      goto LABEL_12;
  }
  else
  {
    v8 = (unsigned int *)(a1 + 24);
    v9 = 31;
  }
  v10 = (_QWORD *)(a2 + 64);
  v11 = v8;
  do
  {
    *(v10 - 1) = *(_QWORD *)v11;
    *(v10 - 2) = *((_QWORD *)v11 + 1);
    v8 = v11 + 6;
    *v10 = *((_QWORD *)v11 + 2);
    v10 += 3;
    v11 += 6;
    --v9;
  }
  while (v9);
  if (v5 >= 0x1A)
  {
LABEL_12:
    v13 = *v8;
    v8 += 2;
    v12 = v13;
    if (!v13)
      goto LABEL_16;
    goto LABEL_13;
  }
  v12 = 31;
LABEL_13:
  v14 = (_QWORD *)(a2 + 808);
  do
  {
    *v14 = *(_QWORD *)v8;
    *(v14 - 2) = *((_QWORD *)v8 + 1);
    v15 = v8 + 6;
    *(v14 - 1) = *((_QWORD *)v8 + 2);
    v14 += 3;
    v8 += 6;
    --v12;
  }
  while (v12);
  v8 = v15;
LABEL_16:
  *(_QWORD *)(a2 + 1536) = *(_QWORD *)v8;
  *(_QWORD *)(a2 + 1544) = *((_QWORD *)v8 + 1);
  *(_DWORD *)(a2 + 1552) = v8[4];
  *(_BYTE *)(a2 + 1556) = v8[6] != 0;
  *(_BYTE *)(a2 + 1557) = v8[8] != 0;
  *(_BYTE *)(a2 + 1558) = v8[10] != 0;
  *v4 = *((_OWORD *)v8 + 3);
  v16 = v8[16];
  v17 = (const char *)(v8 + 18);
  if ((_DWORD)v16)
  {
    v18 = 0;
    v19 = 72 * v16;
    do
    {
      v20 = a2 + v18;
      *(_BYTE *)(v20 + 1640) = *(_DWORD *)&v17[v18] != 0;
      *(_OWORD *)(a2 + v18 + 1576) = *(_OWORD *)&v17[v18 + 8];
      *(_OWORD *)(v20 + 1592) = *(_OWORD *)&v17[v18 + 24];
      *(_OWORD *)(v20 + 1608) = *(_OWORD *)&v17[v18 + 40];
      *(_OWORD *)(v20 + 1624) = *(_OWORD *)&v17[v18 + 56];
      v18 += 72;
    }
    while (v19 != v18);
    v17 += v18;
  }
  v21 = strlen(v17);
  MEMORY[0x24268F6D4](a2, v17);
  if (v5 <= 6 || (*(_QWORD *)(a2 + 2152) = *(_QWORD *)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 8], v5 <= 8))
  {
    *(_OWORD *)(a2 + 2160) = xmmword_24114E050;
    *(_BYTE *)(a2 + 2176) = 0;
    *(_QWORD *)(a2 + 2184) = 0;
    *(_OWORD *)(a2 + 2192) = xmmword_24114E060;
    *(_QWORD *)(a2 + 2208) = 1;
    goto LABEL_26;
  }
  *(_OWORD *)(a2 + 2160) = *(_OWORD *)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 16];
  *(_BYTE *)(a2 + 2176) = *(_DWORD *)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 32] != 0;
  v4[39] = *(_OWORD *)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 40];
  v22 = *(_OWORD *)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 56];
  v4[40] = v22;
  if (v5 <= 0x11)
  {
LABEL_26:
    *(_QWORD *)&v22 = 0;
    *(_OWORD *)(a2 + 2680) = 0u;
    *(_OWORD *)(a2 + 2696) = 0u;
    *(_OWORD *)(a2 + 2648) = 0u;
    *(_OWORD *)(a2 + 2664) = 0u;
    *(_OWORD *)(a2 + 2616) = 0u;
    *(_OWORD *)(a2 + 2632) = 0u;
    *(_OWORD *)(a2 + 2584) = 0u;
    *(_OWORD *)(a2 + 2600) = 0u;
    *(_OWORD *)(a2 + 2552) = 0u;
    *(_OWORD *)(a2 + 2568) = 0u;
    *(_OWORD *)(a2 + 2520) = 0u;
    *(_OWORD *)(a2 + 2536) = 0u;
    *(_OWORD *)(a2 + 2488) = 0u;
    *(_OWORD *)(a2 + 2504) = 0u;
    *(_OWORD *)(a2 + 2456) = 0u;
    *(_OWORD *)(a2 + 2472) = 0u;
    *(_OWORD *)(a2 + 2424) = 0u;
    *(_OWORD *)(a2 + 2440) = 0u;
    *(_OWORD *)(a2 + 2392) = 0u;
    *(_OWORD *)(a2 + 2408) = 0u;
    *(_OWORD *)(a2 + 2360) = 0u;
    *(_OWORD *)(a2 + 2376) = 0u;
    *(_OWORD *)(a2 + 2328) = 0u;
    *(_OWORD *)(a2 + 2344) = 0u;
    *(_OWORD *)(a2 + 2296) = 0u;
    *(_OWORD *)(a2 + 2312) = 0u;
    *(_OWORD *)(a2 + 2264) = 0u;
    *(_OWORD *)(a2 + 2280) = 0u;
    *(_OWORD *)(a2 + 2232) = 0u;
    *(_OWORD *)(a2 + 2248) = 0u;
    *(_OWORD *)(a2 + 2216) = 0u;
LABEL_27:
    *(_QWORD *)(a2 + 2728) = -1;
    return *(double *)&v22;
  }
  if (v5 >= 0x1A)
  {
    v23 = (unint64_t)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 80];
    LODWORD(v24) = *(_DWORD *)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 72];
    if (!(_DWORD)v24)
      goto LABEL_34;
  }
  else
  {
    v23 = (unint64_t)&v17[(v21 & 0xFFFFFFFFFFFFFFF8) + 72];
    LODWORD(v24) = 31;
  }
  v24 = v24;
  v25 = (_QWORD *)(a2 + 2216);
  do
  {
    v26 = *(_QWORD *)v23;
    v23 += 8;
    *v25++ = v26;
    --v24;
  }
  while (v24);
  if (v5 >= 0x1A)
  {
LABEL_34:
    v28 = *(_DWORD *)v23;
    v23 += 8;
    LODWORD(v27) = v28;
    if (!v28)
      goto LABEL_38;
    goto LABEL_35;
  }
  LODWORD(v27) = 31;
LABEL_35:
  v27 = v27;
  v29 = (_QWORD *)(a2 + 2464);
  do
  {
    v30 = *(_QWORD *)v23;
    v23 += 8;
    *v29++ = v30;
    --v27;
  }
  while (v27);
  if (v5 < 0x17)
    goto LABEL_27;
LABEL_38:
  *(_BYTE *)(a2 + 2712) = *(_DWORD *)v23 == 0;
  if (v5 <= 0x1F)
    goto LABEL_27;
  v22 = *(_OWORD *)(v23 + 8);
  *(_OWORD *)(a2 + 2720) = v22;
  if (v5 >= 0x27)
  {
    *(_QWORD *)(a2 + 2736) = *(_QWORD *)(v23 + 32);
    *(_QWORD *)(a2 + 2744) = *(_QWORD *)(v23 + 40);
    *(_QWORD *)(a2 + 2752) = *(_QWORD *)(v23 + 48);
    *(_QWORD *)(a2 + 2760) = *(_QWORD *)(v23 + 56);
    *(int8x8_t *)&v22 = vand_s8(vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)(v23 + 64)), (int32x4_t)vceqzq_s64(*(int64x2_t *)(v23 + 80))), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)(v23 + 96)), (int32x4_t)vceqzq_s64(*(int64x2_t *)(v23 + 112)))))), (int8x8_t)0x101010101010101);
    *(_QWORD *)(a2 + 2768) = v22;
  }
  return *(double *)&v22;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLTileRenderPipelineDescriptor(char *__s, uint64_t a2)
{
  const char *v3;
  unsigned int v4;
  __int128 v5;
  const char *v6;
  uint64_t result;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _BYTE v17[255];

  v3 = __s + 8;
  v4 = *(_DWORD *)__s;
  v5 = 0uLL;
  memset(&v17[7], 0, 248);
  if (*(char *)(a2 + 23) < 0)
  {
    operator delete(*(void **)a2);
    v5 = 0uLL;
  }
  *(_OWORD *)(a2 + 89) = v5;
  *(_OWORD *)(a2 + 64) = v5;
  *(_OWORD *)(a2 + 80) = v5;
  *(_OWORD *)(a2 + 32) = v5;
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)a2 = v5;
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 233) = *(_OWORD *)&v17[128];
  *(_OWORD *)(a2 + 249) = *(_OWORD *)&v17[144];
  *(_OWORD *)(a2 + 169) = *(_OWORD *)&v17[64];
  *(_OWORD *)(a2 + 185) = *(_OWORD *)&v17[80];
  *(_OWORD *)(a2 + 201) = *(_OWORD *)&v17[96];
  *(_OWORD *)(a2 + 217) = *(_OWORD *)&v17[112];
  *(_OWORD *)(a2 + 105) = *(_OWORD *)v17;
  *(_OWORD *)(a2 + 121) = *(_OWORD *)&v17[16];
  *(_OWORD *)(a2 + 137) = *(_OWORD *)&v17[32];
  *(_OWORD *)(a2 + 153) = *(_OWORD *)&v17[48];
  *(_OWORD *)(a2 + 297) = *(_OWORD *)&v17[192];
  *(_OWORD *)(a2 + 313) = *(_OWORD *)&v17[208];
  *(_OWORD *)(a2 + 329) = *(_OWORD *)&v17[224];
  *(_OWORD *)(a2 + 344) = *(_OWORD *)&v17[239];
  *(_OWORD *)(a2 + 265) = *(_OWORD *)&v17[160];
  *(_OWORD *)(a2 + 281) = *(_OWORD *)&v17[176];
  v6 = &v3[strlen(v3) & 0xFFFFFFFFFFFFFFF8];
  result = MEMORY[0x24268F6D4](a2, v3);
  *(_QWORD *)(a2 + 24) = *((_QWORD *)v6 + 1);
  *(_QWORD *)(a2 + 32) = *((_QWORD *)v6 + 2);
  v8 = (uint64_t *)(v6 + 32);
  v9 = *((unsigned int *)v6 + 6);
  if ((_DWORD)v9)
  {
    v10 = (_QWORD *)(a2 + 40);
    do
    {
      v11 = *v8++;
      *v10++ = v11;
      --v9;
    }
    while (v9);
  }
  v12 = v8 + 1;
  *(_BYTE *)(a2 + 104) = *(_DWORD *)v8 != 0;
  if (v4 <= 0x11)
  {
    *(_QWORD *)(a2 + 352) = 0;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    return result;
  }
  if (v4 >= 0x1A)
  {
    v13 = *((_DWORD *)v8 + 2);
    if (!v13)
      return result;
    v12 = v8 + 2;
  }
  else
  {
    v13 = 31;
  }
  v14 = v13;
  v15 = (_QWORD *)(a2 + 112);
  do
  {
    v16 = *v12++;
    *v15++ = v16;
    --v14;
  }
  while (v14);
  return result;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLDeviceDescriptor(int *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  void **v6;
  void **v7;
  void **v8;
  void *v9;
  __int128 v10;
  int *v11;
  size_t v12;
  uint64_t result;
  size_t v14;
  const char *v15;
  const char *v16;
  const char *v17;
  _OWORD *v18;
  unsigned int v19;
  __int128 v20;
  uint64_t v21;
  _QWORD *v22;
  __int128 v23;

  v4 = *a1;
  *(_DWORD *)a2 = 0;
  v5 = a2 + 8;
  if (*(char *)(a2 + 31) < 0)
    operator delete(*(void **)v5);
  v6 = (void **)(a2 + 32);
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 16) = 0;
  if (*(char *)(a2 + 55) < 0)
    operator delete(*v6);
  v7 = (void **)(a2 + 56);
  *v6 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  if (*(char *)(a2 + 79) < 0)
    operator delete(*v7);
  v8 = (void **)(a2 + 80);
  *v7 = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  if (*(char *)(a2 + 103) < 0)
    operator delete(*v8);
  v9 = *(void **)(a2 + 160);
  v10 = 0uLL;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *v8 = 0;
  *(_QWORD *)(a2 + 101) = 0;
  if (v9)
  {
    *(_QWORD *)(a2 + 168) = v9;
    operator delete(v9);
    v10 = 0uLL;
  }
  *(_OWORD *)(a2 + 240) = v10;
  *(_OWORD *)(a2 + 256) = v10;
  *(_OWORD *)(a2 + 208) = v10;
  *(_OWORD *)(a2 + 224) = v10;
  *(_OWORD *)(a2 + 176) = v10;
  *(_OWORD *)(a2 + 192) = v10;
  *(_OWORD *)(a2 + 160) = v10;
  *(_DWORD *)a2 = v4;
  v11 = a1 + 4;
  *(_QWORD *)(a2 + 112) = *((_QWORD *)a1 + 1);
  v12 = (size_t)a1 + (strlen((const char *)a1 + 16) & 0xFFFFFFFFFFFFFFF8) + 16;
  result = MEMORY[0x24268F6D4](v5, v11);
  *(_QWORD *)(a2 + 120) = *(_QWORD *)(v12 + 8);
  *(_QWORD *)(a2 + 128) = *(_QWORD *)(v12 + 16);
  *(_QWORD *)(a2 + 136) = *(_QWORD *)(v12 + 24);
  v14 = v12 + 40;
  *(_BYTE *)(a2 + 104) = *(_BYTE *)(v12 + 32);
  if (!*(_QWORD *)(a2 + 112))
  {
    v15 = (const char *)((strlen((const char *)(v12 + 40)) & 0xFFFFFFFFFFFFFFF8) + v14 + 8);
    MEMORY[0x24268F6D4](a2 + 32, v14);
    v16 = &v15[(strlen(v15) & 0xFFFFFFFFFFFFFFF8) + 8];
    MEMORY[0x24268F6D4](a2 + 56, v15);
    v17 = &v16[strlen(v16) & 0xFFFFFFFFFFFFFFF8];
    result = MEMORY[0x24268F6D4](a2 + 80, v16);
    *(_BYTE *)(a2 + 105) = v17[8];
    v14 = (size_t)(v17 + 24);
    *(_BYTE *)(a2 + 106) = v17[16];
  }
  v18 = (_OWORD *)(a2 + 184);
  v19 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 < 0xCu
    || (*(_QWORD *)(a2 + 144) = *(_QWORD *)v14, *(_QWORD *)(a2 + 152) = *(_QWORD *)(v14 + 8), v19 <= 0xE))
  {
    *(_QWORD *)&v23 = -1;
    *((_QWORD *)&v23 + 1) = -1;
    *(_OWORD *)(a2 + 232) = v23;
    *(_OWORD *)(a2 + 248) = v23;
    *(_OWORD *)(a2 + 200) = v23;
    *(_OWORD *)(a2 + 216) = v23;
    *v18 = v23;
  }
  else
  {
    *(_BYTE *)(a2 + 107) = *(_BYTE *)(v14 + 16);
    *(_QWORD *)&v20 = -1;
    *((_QWORD *)&v20 + 1) = -1;
    *v18 = v20;
    *(_OWORD *)(a2 + 200) = v20;
    *(_OWORD *)(a2 + 216) = v20;
    *(_OWORD *)(a2 + 232) = v20;
    *(_OWORD *)(a2 + 248) = v20;
    if (v19 >= 0x19)
    {
      v21 = *(_QWORD *)(v14 + 24);
      *(_QWORD *)v18 = v21;
      if (v21 == -1)
      {
        v22 = (_QWORD *)(v14 + 32);
      }
      else
      {
        *(_QWORD *)(a2 + 192) = *(_QWORD *)(v14 + 32);
        *(_QWORD *)(a2 + 200) = *(_QWORD *)(v14 + 40);
        *(_QWORD *)(a2 + 208) = *(_QWORD *)(v14 + 48);
        *(_QWORD *)(a2 + 216) = *(_QWORD *)(v14 + 56);
        *(_QWORD *)(a2 + 224) = *(_QWORD *)(v14 + 64);
        *(_QWORD *)(a2 + 232) = *(_QWORD *)(v14 + 72);
        *(_QWORD *)(a2 + 240) = *(_QWORD *)(v14 + 80);
        *(_QWORD *)(a2 + 248) = *(_QWORD *)(v14 + 88);
        v22 = (_QWORD *)(v14 + 104);
        *(_QWORD *)(a2 + 256) = *(_QWORD *)(v14 + 96);
      }
      if (v19 >= 0x1C)
      {
        *(_QWORD *)(a2 + 264) = *v22;
        if (v19 != 28)
          *(_BYTE *)(a2 + 108) = v22[1] != 0;
      }
    }
  }
  return result;
}

void *GPUTools::MTL::Utils::MakeDYMTLComputePipelineDescriptor(uint64_t a1, void **a2)
{
  unsigned int v4;
  uint64_t v5;
  size_t v6;
  void *result;
  int8x16_t *v8;
  uint64_t v9;
  int8x16_t *v10;
  int8x16_t *v11;
  int8x16_t *v12;
  uint64_t v13;
  unsigned __int32 v14;
  _QWORD *v15;
  int8x16_t *v16;
  int8x16_t v17;
  uint64_t v18;
  __int32 v19;
  uint64_t *v20;
  uint64_t v21;
  _OWORD v22[94];

  v4 = *(_DWORD *)a1;
  if (*((char *)a2 + 23) < 0)
    operator delete(*a2);
  bzero(a2, 0x702uLL);
  a2[3] = *(void **)(a1 + 8);
  v5 = a1 + 24;
  *((_BYTE *)a2 + 1792) = *(_DWORD *)(a1 + 16) != 0;
  v6 = strlen((const char *)(a1 + 24));
  result = (void *)MEMORY[0x24268F6D4](a2, v5);
  if (v4 < 0xB)
    goto LABEL_21;
  v8 = (int8x16_t *)((v6 & 0xFFFFFFFFFFFFFFF8) + v5 + 8);
  v9 = v8->i64[0];
  if (v8->i64[0] == -1)
  {
    v10 = (int8x16_t *)&v8->u64[1];
    goto LABEL_18;
  }
  if (v4 >= 0x1A)
  {
    v8 = (int8x16_t *)((char *)v8 + 8);
    v9 = v9;
    if (!(_DWORD)v9)
      goto LABEL_13;
  }
  else
  {
    v9 = 31;
  }
  v11 = (int8x16_t *)&v22[1];
  v12 = v8;
  do
  {
    v11[-1] = vextq_s8(*v12, *v12, 8uLL);
    v8 = (int8x16_t *)((char *)v12 + 24);
    v11->i64[0] = v12[1].i64[0];
    v11 = (int8x16_t *)((char *)v11 + 24);
    v12 = (int8x16_t *)((char *)v12 + 24);
    --v9;
  }
  while (v9);
  if (v4 < 0x1A)
  {
    v13 = 31;
    goto LABEL_14;
  }
LABEL_13:
  v14 = v8->i32[0];
  v8 = (int8x16_t *)((char *)v8 + 8);
  v13 = v14;
  if (v14)
  {
LABEL_14:
    v15 = (_QWORD *)&v22[47] + 1;
    do
    {
      *v15 = v8->i64[0];
      *(v15 - 2) = v8->i64[1];
      v16 = (int8x16_t *)((char *)v8 + 24);
      *(v15 - 1) = v8[1].i64[0];
      v15 += 3;
      v8 = (int8x16_t *)((char *)v8 + 24);
      --v13;
    }
    while (v13);
    v8 = v16;
  }
  v17 = *v8;
  v10 = v8 + 1;
  v22[93] = v17;
  result = memcpy(a2 + 5, v22, 0x5E0uLL);
LABEL_18:
  if (v4 <= 0x11)
  {
LABEL_21:
    a2[223] = 0;
    *(_OWORD *)(a2 + 219) = 0u;
    *(_OWORD *)(a2 + 221) = 0u;
    *(_OWORD *)(a2 + 215) = 0u;
    *(_OWORD *)(a2 + 217) = 0u;
    *(_OWORD *)(a2 + 211) = 0u;
    *(_OWORD *)(a2 + 213) = 0u;
    *(_OWORD *)(a2 + 207) = 0u;
    *(_OWORD *)(a2 + 209) = 0u;
    *(_OWORD *)(a2 + 203) = 0u;
    *(_OWORD *)(a2 + 205) = 0u;
    *(_OWORD *)(a2 + 199) = 0u;
    *(_OWORD *)(a2 + 201) = 0u;
    *(_OWORD *)(a2 + 195) = 0u;
    *(_OWORD *)(a2 + 197) = 0u;
    *(_OWORD *)(a2 + 193) = 0u;
    return result;
  }
  if (v4 >= 0x1A)
  {
    v19 = v10->i32[0];
    v10 = (int8x16_t *)((char *)v10 + 8);
    LODWORD(v18) = v19;
    if (!v19)
      goto LABEL_26;
  }
  else
  {
    LODWORD(v18) = 31;
  }
  v18 = v18;
  v20 = (uint64_t *)(a2 + 193);
  do
  {
    v21 = v10->i64[0];
    v10 = (int8x16_t *)((char *)v10 + 8);
    *v20++ = v21;
    --v18;
  }
  while (v18);
LABEL_26:
  if (v4 >= 0x1B)
  {
    *((_BYTE *)a2 + 1793) = v10->i32[0] == 0;
    if (v4 >= 0x25)
      a2[4] = (void *)v10->i64[1];
  }
  return result;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLMotionEstimationPipelineDescriptor(uint64_t result, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  *a2 = *(_QWORD *)(result + 8);
  a2[1] = *(_QWORD *)(result + 16);
  return result;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLDepthStencilDescriptor(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  int v13;
  uint64_t result;

  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  if (v4)
    MEMORY[0x24268F704](v4, 0x1000C400A747E1ELL);
  v5 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  if (v5)
    MEMORY[0x24268F704](v5, 0x1000C400A747E1ELL);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 8);
  *(_BYTE *)(a2 + 48) = *(_DWORD *)(a1 + 16) != 0;
  v6 = (strlen((const char *)(a1 + 24)) & 0xFFFFFFFFFFFFFFF8) + a1 + 24;
  MEMORY[0x24268F6D4](a2, a1 + 24);
  v7 = operator new();
  v8 = *(_OWORD *)(v6 + 32);
  *(_OWORD *)v7 = *(_OWORD *)(v6 + 16);
  *(_OWORD *)(v7 + 16) = v8;
  v9 = *(_DWORD *)(v6 + 56);
  *(_DWORD *)(v7 + 32) = *(_DWORD *)(v6 + 48);
  *(_DWORD *)(v7 + 36) = v9;
  v10 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v7;
  if (v10)
    MEMORY[0x24268F704](v10, 0x1000C400A747E1ELL);
  v11 = operator new();
  v12 = *(_OWORD *)(v6 + 88);
  *(_OWORD *)v11 = *(_OWORD *)(v6 + 72);
  *(_OWORD *)(v11 + 16) = v12;
  v13 = *(_DWORD *)(v6 + 112);
  *(_DWORD *)(v11 + 32) = *(_DWORD *)(v6 + 104);
  *(_DWORD *)(v11 + 36) = v13;
  result = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v11;
  if (result)
    JUMPOUT(0x24268F704);
  return result;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLSamplerDescriptor(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  uint64_t result;
  size_t v9;
  size_t v10;
  int v11;
  int v12;
  uint64_t v13;

  v4 = *(_DWORD *)a1;
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  *(_DWORD *)(a2 + 100) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_BYTE *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_BYTE *)(a2 + 128) = 0;
  *(_OWORD *)(a2 + 136) = 0u;
  v5 = (_QWORD *)(a2 + 136);
  *(_OWORD *)(a2 + 152) = 0u;
  *(_BYTE *)(a2 + 168) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_BYTE *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 56);
  *(_BYTE *)(a2 + 96) = *(_DWORD *)(a1 + 64) != 0;
  *(_DWORD *)(a2 + 88) = *(_DWORD *)(a1 + 72);
  v6 = a1 + 88;
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(a1 + 80);
  v7 = strlen((const char *)(a1 + 88));
  result = MEMORY[0x24268F6D4](a2, v6);
  if (v4 <= 1)
  {
    *(_DWORD *)(a2 + 100) = -1;
LABEL_17:
    *(_QWORD *)(a2 + 104) = 0;
    goto LABEL_18;
  }
  v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + v6;
  v12 = *(_DWORD *)(v9 + 8);
  v10 = v9 + 8;
  v11 = v12;
  if (v12 == -1)
    v11 = 0;
  *(_DWORD *)(a2 + 100) = v11;
  if (v4 <= 7)
    goto LABEL_17;
  *(_QWORD *)(a2 + 104) = *(unsigned int *)(v10 + 8);
  if (v4 <= 9)
  {
LABEL_18:
    *(_QWORD *)(a2 + 80) = 0;
LABEL_19:
    *(_BYTE *)(a2 + 112) = 0;
LABEL_20:
    *v5 = 0;
    return result;
  }
  LODWORD(v13) = *(_DWORD *)(v10 + 16);
  if ((_DWORD)v13 == -1)
    v13 = 0;
  else
    v13 = v13;
  *(_QWORD *)(a2 + 80) = v13;
  if (v4 <= 0x10)
    goto LABEL_19;
  *(_BYTE *)(a2 + 112) = (*(_DWORD *)(v10 + 24) - 1) < 0xFFFFFFFE;
  if (v4 < 0x16)
    goto LABEL_20;
  *(_QWORD *)(a2 + 120) = *(_QWORD *)(v10 + 32);
  *(_BYTE *)(a2 + 128) = *(_DWORD *)(v10 + 40) != 0;
  if (v4 <= 0x1B)
    goto LABEL_20;
  *v5 = *(_QWORD *)(v10 + 48);
  if (v4 >= 0x27)
  {
    *(_QWORD *)(a2 + 144) = *(unsigned int *)(v10 + 56);
    *(_DWORD *)(a2 + 152) = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(a2 + 156) = *(_DWORD *)(v10 + 72);
    *(_DWORD *)(a2 + 160) = *(_DWORD *)(v10 + 80);
    *(_DWORD *)(a2 + 164) = *(_DWORD *)(v10 + 88);
    *(_BYTE *)(a2 + 168) = *(_DWORD *)(v10 + 96) != 0;
  }
  return result;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLTextureDescriptor(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  v2 = *(_DWORD *)result;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 104) = xmmword_24114E070;
  *(_OWORD *)(a2 + 120) = xmmword_24114E080;
  *(_OWORD *)a2 = *(_OWORD *)(result + 8);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(result + 24);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(result + 32);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(result + 40);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(result + 48);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(result + 56);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(result + 64);
  v3 = 72;
  if (v2 < 3)
    v3 = 80;
  v4 = result + v3;
  *(_BYTE *)(a2 + 141) = *(_DWORD *)v4 != 0;
  *(_BYTE *)(a2 + 140) = *(_DWORD *)(v4 + 8) != 0;
  if (!v2)
  {
LABEL_13:
    *(_QWORD *)(a2 + 80) = 0;
    *(_QWORD *)(a2 + 88) = 0;
    return result;
  }
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(v4 + 16);
  if (v2 <= 3)
  {
    if (v2 == 3)
    {
      *(_OWORD *)(a2 + 80) = *(_OWORD *)(v4 + 24);
      return result;
    }
    goto LABEL_13;
  }
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(v4 + 24);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(v4 + 32);
  if (v2 >= 0x15)
  {
    v5 = *(_QWORD *)(v4 + 56);
    *(_BYTE *)(a2 + 142) = *(_QWORD *)(v4 + 48) != 0;
    *(_QWORD *)(a2 + 96) = v5;
    if (v2 != 21)
    {
      *(_QWORD *)(a2 + 144) = *(_QWORD *)(v4 + 64);
      *(_BYTE *)(a2 + 152) = *(_DWORD *)(v4 + 72) != 0;
      if (v2 >= 0x23)
      {
        v6 = *(_OWORD *)(v4 + 96);
        *(_OWORD *)(a2 + 104) = *(_OWORD *)(v4 + 80);
        *(_OWORD *)(a2 + 120) = v6;
        if (v2 >= 0x27)
          *(_DWORD *)(a2 + 136) = *(_DWORD *)(v4 + 112);
      }
    }
  }
  return result;
}

void GPUTools::MTL::Utils::MakeDYMTLFunctionConstantValues(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  int v5;
  const char *v6;
  size_t v7;
  const char *v8;
  id v9;
  uint64_t v10;
  void *v11;
  id v12;
  unint64_t v13;
  uint64_t v14;
  __int128 __p;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  id v20;

  v3 = (_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 != -1)
  {
    v5 = (_DWORD)a2 + 16;
    do
    {
      v6 = (const char *)(v3 + 1);
      __p = 0uLL;
      v20 = 0;
      v16 = 0;
      v17 = v2;
      v7 = strlen(v6);
      MEMORY[0x24268F6D4](&__p, v6);
      v8 = &v6[v7 & 0xFFFFFFFFFFFFFFF8];
      v19 = *((_QWORD *)v8 + 1);
      v18 = *((_DWORD *)v8 + 4) != 0;
      v9 = v20;
      v20 = 0;

      v3 = v8 + 32;
      v10 = *((_QWORD *)v8 + 3);
      if (v10)
      {
        objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", v3, v10);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v3 = (_QWORD *)((char *)v3 + ((v10 + 7) & 0xFFFFFFFFFFFFFFF8));
        v12 = v20;
        v20 = v11;

      }
      v13 = a2[1];
      if (v13 >= a2[2])
      {
        v14 = std::vector<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::__push_back_slow_path<GPUTools::MTL::Utils::DYMTLFunctionConstantValue const&>(a2, &__p);
      }
      else
      {
        std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLFunctionConstantValue,GPUTools::MTL::Utils::DYMTLFunctionConstantValue const&>(v5, (std::string *)a2[1], &__p);
        v14 = v13 + 56;
        a2[1] = v13 + 56;
      }
      a2[1] = v14;

      if (SHIBYTE(v16) < 0)
        operator delete((void *)__p);
      v2 = *v3;
    }
    while (*v3 != -1);
  }
}

void sub_241121828(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  *(_QWORD *)(v2 + 8) = v3;
  GPUTools::MTL::Utils::DYMTLFunctionConstantValue::~DYMTLFunctionConstantValue((id *)va);
  _Unwind_Resume(a1);
}

void GPUTools::MTL::Utils::DYMTLFunctionConstantValue::~DYMTLFunctionConstantValue(id *this)
{

  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

void GPUTools::MTL::Utils::MakeDYMTLCompileOptions(unsigned int *a1, uint64_t a2)
{
  unsigned int v3;
  void *v4;
  const void **v5;
  uint64_t v6;
  void *v7;
  _DWORD *v8;
  _QWORD *v9;
  _DWORD *v10;

  v3 = *a1;
  v10 = a1 + 2;
  v4 = *(void **)a2;
  *(_QWORD *)a2 = 0;

  *(_WORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0x10000;
  GPUTools::ReadDynamicBufferObject((GPUTools *)&v10, v5);
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = *(void **)a2;
  *(_QWORD *)a2 = v6;

  v8 = v10;
  *(_BYTE *)(a2 + 8) = *v10 != 0;
  *(_BYTE *)(a2 + 9) = v8[2] != 0;
  if (v3 > 0xF)
  {
    v9 = v8 + 4;
  }
  else
  {
    if (v3 < 6)
      return;
    v9 = v8 + 10;
  }
  *(_QWORD *)(a2 + 16) = *v9;
}

id GPUTools::ReadDynamicBufferObject(GPUTools *this, const void **a2)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v13;

  *(_QWORD *)this += 8 + ((**(_QWORD **)this + 7) & 0xFFFFFFFFFFFFFFF8);
  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytesNoCopy:length:freeWhenDone:");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)MEMORY[0x24BE39120];
  v4 = (void *)MEMORY[0x24BDBCF20];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  objc_msgSend(v4, "setWithObjects:", v5, v6, v7, v8, v9, objc_opt_class(), 0);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = 0;
  objc_msgSend(v3, "unarchivedObjectOfClasses:fromData:error:", v10, v2, &v13);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

void sub_241121A48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 GPUTools::MTL::Utils::MakeDYMTLHeapDescriptor(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  __n128 result;

  v2 = *(_DWORD *)a1;
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)a2 = result;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 24);
  if (v2 >= 0x1D)
  {
    *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 32);
    if (v2 >= 0x1F)
    {
      *(_BYTE *)(a2 + 32) = *(_QWORD *)(a1 + 40) != 0;
      result = *(__n128 *)(a1 + 48);
      *(__n128 *)(a2 + 40) = result;
    }
  }
  return result;
}

void GPUTools::MTL::Utils::MakeDYMTLPostVertexDump(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v3;
  const char *v6;
  int v7;
  size_t v8;
  const char *v9;
  const char *v10;
  size_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  void **v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  void *__p[2];
  uint64_t v24;
  uint64_t v25;

  *a2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    v6 = (const char *)(a1 + 24);
    v7 = (_DWORD)a3 + 16;
    do
    {
      v20 = 0uLL;
      v21 = 0;
      __p[1] = 0;
      v24 = 0;
      __p[0] = 0;
      v8 = strlen(v6);
      MEMORY[0x24268F6D4](&v20, v6);
      v9 = &v6[v8 & 0xFFFFFFFFFFFFFFF8];
      v10 = v9 + 16;
      v22 = *((_QWORD *)v9 + 1);
      v11 = strlen(v9 + 16);
      MEMORY[0x24268F6D4](__p, v10);
      v12 = &v10[v11 & 0xFFFFFFFFFFFFFFF8];
      v13 = *((_QWORD *)v12 + 1);
      v25 = v13;
      if (v13 == 8)
      {
        v14 = 24;
      }
      else
      {
        if (v13 != 12)
        {
          v15 = 0;
          goto LABEL_9;
        }
        v14 = 28;
      }
      v15 = *a2 == v14;
LABEL_9:
      if (v24 >= 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      if (*(_BYTE *)v16)
        v17 = 1;
      else
        v17 = !v15;
      if (!v17)
      {
        MEMORY[0x24268F6D4](&v20, "air.position");
        MEMORY[0x24268F6D4](__p, "return");
        v22 = 6;
      }
      v18 = a3[1];
      if (v18 >= a3[2])
      {
        v19 = std::vector<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::__push_back_slow_path<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>(a3, &v20);
      }
      else
      {
        std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput,GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>(v7, (std::string *)a3[1], &v20);
        v19 = v18 + 64;
        a3[1] = v18 + 64;
      }
      a3[1] = v19;
      if (SHIBYTE(v24) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v21) < 0)
        operator delete((void *)v20);
      v6 = v12 + 16;
      --v3;
    }
    while (v3);
  }
}

void sub_241121C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput::~DYMTLPostVertexDumpOutput(&a9);
  _Unwind_Resume(a1);
}

void GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput::~DYMTLPostVertexDumpOutput(void **this)
{
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

void GPUTools::MTL::Utils::MakeDYMTLPostMeshDumpOutput(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v3;
  const char *v5;
  int v6;
  size_t v7;
  const char *v8;
  const char *v9;
  size_t v10;
  const char *v11;
  void **v12;
  unint64_t v13;
  uint64_t v14;
  __int128 *v15;
  uint64_t v16;
  int v17;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  void *__p[2];
  uint64_t v23;
  uint64_t v24;

  *a2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    v5 = (const char *)(a1 + 24);
    v6 = (_DWORD)a3 + 16;
    do
    {
      v19 = 0uLL;
      v20 = 0;
      __p[1] = 0;
      v23 = 0;
      __p[0] = 0;
      v7 = strlen(v5);
      MEMORY[0x24268F6D4](&v19, v5);
      v8 = &v5[v7 & 0xFFFFFFFFFFFFFFF8];
      v9 = v8 + 16;
      v21 = *((_QWORD *)v8 + 1);
      v10 = strlen(v8 + 16);
      MEMORY[0x24268F6D4](__p, v9);
      v11 = &v9[v10 & 0xFFFFFFFFFFFFFFF8];
      v24 = *((_QWORD *)v11 + 1);
      if (v23 >= 0)
        v12 = __p;
      else
        v12 = (void **)__p[0];
      if (!*(_BYTE *)v12)
      {
        if (SHIBYTE(v20) < 0)
        {
          if (*((_QWORD *)&v19 + 1) == 12)
          {
            v15 = (__int128 *)v19;
LABEL_21:
            v16 = *(_QWORD *)v15;
            v17 = *((_DWORD *)v15 + 2);
            if (v16 == 0x69736F702E726961 && v17 == 1852795252)
              MEMORY[0x24268F6D4](__p, "return");
          }
        }
        else if (SHIBYTE(v20) == 12)
        {
          v15 = &v19;
          goto LABEL_21;
        }
      }
      v13 = a3[1];
      if (v13 >= a3[2])
      {
        v14 = std::vector<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::__push_back_slow_path<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>(a3, &v19);
      }
      else
      {
        std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput,GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>(v6, (std::string *)a3[1], &v19);
        v14 = v13 + 64;
        a3[1] = v13 + 64;
      }
      a3[1] = v14;
      if (SHIBYTE(v23) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v20) < 0)
        operator delete((void *)v19);
      v5 = v11 + 16;
      --v3;
    }
    while (v3);
  }
}

void sub_241121E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput::~DYMTLPostVertexDumpOutput(&a9);
  _Unwind_Resume(a1);
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLMutableBufferAncestorMaps(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  int i;
  unint64_t v18;
  _OWORD v19[2];
  int v20;
  unint64_t *v21;

  v11 = *(_QWORD *)(result + 8);
  if (v11)
  {
    v2 = 0;
    v3 = (unint64_t *)(result + 16);
    do
    {
      v13 = v2;
      memset(v19, 0, sizeof(v19));
      v20 = 1065353216;
      v5 = *v3++;
      v4 = v5;
      if (v5)
      {
        v6 = 0;
        do
        {
          v18 = 0;
          v7 = *v3;
          v8 = v3[1];
          v3 += 2;
          v18 = v7;
          v15 = 0u;
          v16 = 0u;
          for (i = 1065353216; v8; --v8)
          {
            v14 = 0;
            v14 = *v3;
            v9 = v3[1];
            v21 = &v14;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)&v15, &v14, (uint64_t)&std::piecewise_construct, &v21)[3] = v9;
            v3 += 2;
          }
          v21 = &v18;
          v10 = std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v19, &v18, (uint64_t)&std::piecewise_construct, &v21);
          if (v10 + 3 != (_QWORD *)&v15)
          {
            *((_DWORD *)v10 + 14) = i;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,unsigned long long>,void *> *>>(v10 + 3, (_QWORD *)v16, 0);
          }
          std::__hash_table<std::__hash_value_type<int,unsigned int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,unsigned int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,unsigned int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,unsigned int>>>::~__hash_table((uint64_t)&v15);
          ++v6;
        }
        while (v6 != v4);
      }
      std::vector<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::push_back[abi:ne180100](a2, (uint64_t *)v19);
      result = std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::~__hash_table((uint64_t)v19);
      v2 = v13 + 1;
    }
    while (v13 + 1 != v11);
  }
  return result;
}

void sub_241122000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::push_back[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v10 + 1 > 0x666666666666666)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    v12 = 2 * v11;
    if (2 * v11 <= v10 + 1)
      v12 = v10 + 1;
    if (v11 >= 0x333333333333333)
      v13 = 0x666666666666666;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[40 * v10];
    v18 = &v14[40 * v13];
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__hash_table((uint64_t)v16, a2);
    v17 = v16 + 40;
    std::vector<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__hash_table(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 40;
    a1[1] = v7 + 40;
  }
  a1[1] = v9;
  return result;
}

void sub_241122134(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void GPUTools::MTL::Utils::MakeDYMTLIndirectArgumentBufferInfos(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  char *v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  void *__p;
  char *v31;
  char *v32;

  v26 = *(_QWORD *)(a1 + 8);
  if (v26)
  {
    v2 = 0;
    v3 = (uint64_t *)(a1 + 16);
    v4 = (uint64_t *)(a1 + 16);
    do
    {
      v28 = v2;
      __p = 0;
      v31 = 0;
      v32 = 0;
      v6 = *v4++;
      v5 = v6;
      if (v6)
      {
        v7 = 0;
        v8 = 0;
        v9 = v3;
        v29 = v5;
        do
        {
          v11 = v9[5];
          v9 += 5;
          v10 = v11;
          v12 = *v4;
          v14 = *(v9 - 3);
          v13 = *(v9 - 2);
          v15 = *(v9 - 1);
          if (v7 >= v32)
          {
            v16 = (char *)__p;
            v17 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (_BYTE *)__p) >> 3);
            v18 = v17 + 1;
            if (v17 + 1 > 0x666666666666666)
              std::vector<float>::__throw_length_error[abi:ne180100]();
            if (0x999999999999999ALL * ((v32 - (_BYTE *)__p) >> 3) > v18)
              v18 = 0x999999999999999ALL * ((v32 - (_BYTE *)__p) >> 3);
            if (0xCCCCCCCCCCCCCCCDLL * ((v32 - (_BYTE *)__p) >> 3) >= 0x333333333333333)
              v19 = 0x666666666666666;
            else
              v19 = v18;
            if (v19)
            {
              v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>((uint64_t)&v32, v19);
              v16 = (char *)__p;
              v7 = v31;
            }
            else
            {
              v20 = 0;
            }
            v21 = &v20[40 * v17];
            *(_QWORD *)v21 = v12;
            *((_QWORD *)v21 + 1) = v14;
            *((_QWORD *)v21 + 2) = v15;
            *((_QWORD *)v21 + 3) = v10;
            *((_QWORD *)v21 + 4) = v13;
            if (v7 == v16)
            {
              v25 = &v20[40 * v17];
            }
            else
            {
              v22 = &v20[40 * v17];
              do
              {
                v23 = *(_OWORD *)(v7 - 40);
                v24 = *(_OWORD *)(v7 - 24);
                v25 = v22 - 40;
                *((_QWORD *)v22 - 1) = *((_QWORD *)v7 - 1);
                *(_OWORD *)(v22 - 24) = v24;
                *(_OWORD *)(v22 - 40) = v23;
                v7 -= 40;
                v22 -= 40;
              }
              while (v7 != v16);
            }
            v7 = v21 + 40;
            __p = v25;
            v31 = v21 + 40;
            v32 = &v20[40 * v19];
            if (v16)
              operator delete(v16);
            v5 = v29;
          }
          else
          {
            *(_QWORD *)v7 = v12;
            *((_QWORD *)v7 + 1) = v14;
            *((_QWORD *)v7 + 2) = v15;
            *((_QWORD *)v7 + 3) = v10;
            *((_QWORD *)v7 + 4) = v13;
            v7 += 40;
          }
          v31 = v7;
          ++v8;
          v4 = v3 + 6;
          v3 = v9;
        }
        while (v8 != v5);
      }
      std::vector<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::push_back[abi:ne180100](a2, (uint64_t)&__p);
      if (__p)
      {
        v31 = (char *)__p;
        operator delete(__p);
      }
      v2 = v28 + 1;
      v3 = v4;
    }
    while (v28 + 1 != v26);
  }
}

void sub_241122340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>>(result, v12);
    v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((_QWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 2) = 0;
    *(_QWORD *)v14 = 0;
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::__swap_out_circular_buffer(a1, v16);
    v8 = (_QWORD *)a1[1];
    result = std::__split_buffer<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v7[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_24112248C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLIndirectCommandBufferDescriptor(uint64_t result, uint64_t a2)
{
  unsigned int v2;

  v2 = *(_DWORD *)result;
  *(_QWORD *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)a2 = *(_QWORD *)(result + 8);
  *(_BYTE *)(a2 + 9) = *(_DWORD *)(result + 16) != 0;
  *(_BYTE *)(a2 + 8) = *(_DWORD *)(result + 24) != 0;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(result + 32);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(result + 40);
  if (v2 >= 0x1B)
  {
    *(_QWORD *)(a2 + 48) = *(_QWORD *)(result + 48);
    *(_QWORD *)(a2 + 64) = *(_QWORD *)(result + 56);
  }
  return result;
}

void GPUTools::MTL::Utils::MakeDYMTLIOCommandQueueDescriptor(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = 0;
  *(_WORD *)(a2 + 4) = 0;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLCommandQueueDescriptor(uint64_t result, uint64_t a2)
{
  unsigned int v2;

  v2 = *(_DWORD *)result;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(result + 16);
  *(_BYTE *)(a2 + 16) = *(_QWORD *)(result + 24) != 0;
  if (v2 >= 0x27)
    *(_BYTE *)(a2 + 17) = *(_QWORD *)(result + 32) != 0;
  return result;
}

uint64_t GPUTools::MTL::Utils::MakeDYMTLCounterSampleBufferDescriptor(uint64_t a1, _QWORD *a2)
{
  const char *v3;
  uint64_t v4;
  void **v5;
  const char *v6;
  const char *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  const char *v12;
  const char *v13;
  uint64_t result;
  void *v15[2];
  char v16;
  void *v17;
  char v18;
  _BYTE v19[522];
  __int128 __p;
  __int128 v21;
  uint64_t v22;

  v3 = (const char *)(a1 + 8);
  GPUTools::MTL::Utils::DYMTLCounterSet::DYMTLCounterSet((GPUTools::MTL::Utils::DYMTLCounterSet *)v15);
  v22 = 0;
  v21 = 0u;
  __p = 0u;
  GPUTools::MTL::Utils::DYMTLCounterSampleBufferDescriptor::operator=((uint64_t)a2, (__int128 *)v15);
  if (SBYTE7(v21) < 0)
    operator delete((void *)__p);
  v4 = 96;
  do
  {
    v5 = &v15[v4];
    if ((char)v19[v4 * 8] < 0)
      operator delete(v5[4]);
    if (*((char *)v5 + 31) < 0)
      operator delete(v5[1]);
    v4 -= 6;
  }
  while (v4 * 8);
  if (v18 < 0)
    operator delete(v17);
  if (v16 < 0)
    operator delete(v15[0]);
  v6 = &v3[(strlen(v3) & 0xFFFFFFFFFFFFFFF8) + 8];
  MEMORY[0x24268F6D4](a2, v3);
  v7 = &v6[strlen(v6) & 0xFFFFFFFFFFFFFFF8];
  MEMORY[0x24268F6D4](a2 + 3, v6);
  a2[103] = *((_QWORD *)v7 + 1);
  v8 = v7 + 24;
  v9 = *((_QWORD *)v7 + 2);
  a2[6] = v9;
  if ((int)v9 >= 1)
  {
    v10 = 0;
    v11 = a2 + 7;
    do
    {
      v12 = &v8[(strlen(v8) & 0xFFFFFFFFFFFFFFF8) + 8];
      MEMORY[0x24268F6D4](v11, v8);
      v8 = &v12[(strlen(v12) & 0xFFFFFFFFFFFFFFF8) + 8];
      MEMORY[0x24268F6D4](v11 + 3, v12);
      ++v10;
      v11 += 6;
    }
    while (v10 < *((int *)a2 + 12));
  }
  v13 = &v8[strlen(v8) & 0xFFFFFFFFFFFFFFF8];
  result = MEMORY[0x24268F6D4](a2 + 104, v8);
  a2[107] = *((_QWORD *)v13 + 1);
  a2[108] = *((_QWORD *)v13 + 2);
  return result;
}

uint64_t GPUTools::MTL::Utils::DYMTLCounterSampleBufferDescriptor::operator=(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  void **v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  void **v9;
  __int128 *v10;
  __int128 v11;
  void **v12;
  __int128 *v13;
  __int128 v14;
  void **v15;
  __int128 v16;

  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_BYTE *)a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0)
    operator delete(*v5);
  v6 = 0;
  v7 = *(__int128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(_OWORD *)v5 = v7;
  *((_BYTE *)a2 + 47) = 0;
  *((_BYTE *)a2 + 24) = 0;
  *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 6);
  do
  {
    v8 = a1 + v6 * 16;
    v9 = (void **)(a1 + v6 * 16 + 56);
    if (*(char *)(a1 + v6 * 16 + 79) < 0)
      operator delete(*v9);
    v10 = (__int128 *)((char *)&a2[v6 + 3] + 8);
    v11 = *v10;
    *(_QWORD *)(a1 + v6 * 16 + 72) = *((_QWORD *)&a2[v6 + 4] + 1);
    *(_OWORD *)v9 = v11;
    HIBYTE(a2[v6 + 4]) = 0;
    *(_BYTE *)v10 = 0;
    v12 = (void **)(v8 + 80);
    if (*(char *)(v8 + 103) < 0)
      operator delete(*v12);
    v13 = &a2[v6];
    v14 = a2[v6 + 5];
    *(_QWORD *)(v8 + 96) = *(_QWORD *)&a2[v6 + 6];
    *(_OWORD *)v12 = v14;
    *((_BYTE *)v13 + 103) = 0;
    *((_BYTE *)v13 + 80) = 0;
    v6 += 3;
  }
  while (v6 != 48);
  *(_QWORD *)(a1 + 824) = *((_QWORD *)a2 + 103);
  v15 = (void **)(a1 + 832);
  if (*(char *)(a1 + 855) < 0)
    operator delete(*v15);
  v16 = a2[52];
  *(_QWORD *)(a1 + 848) = *((_QWORD *)a2 + 106);
  *(_OWORD *)v15 = v16;
  *((_BYTE *)a2 + 855) = 0;
  *((_BYTE *)a2 + 832) = 0;
  *(_OWORD *)(a1 + 856) = *(__int128 *)((char *)a2 + 856);
  return a1;
}

BOOL GPUTools::MTL::Utils::IsIndirectCommandBufferRender(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFFFE70) == 0;
}

BOOL GPUTools::MTL::Utils::IsIndirectCommandBufferCompute(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFFFF9FLL) == 0;
}

void GPUTools::MTL::Utils::MakeDYMTLRasterizationRateMapDescriptor(uint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t *v4;
  const char *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  _DWORD *v17;
  int v18;
  int v19;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  int v28;
  void **v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  _DWORD **v33;
  char *v34;
  _QWORD *v35;
  int v36;
  int v37;
  _DWORD *v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  int v46;
  uint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  _OWORD v50[2];
  __int128 v51;
  uint64_t v52;
  void **v53;

  v3 = (const char *)(a1 + 8);
  v52 = 0;
  v51 = 0u;
  memset(v50, 0, 24);
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)v50 + 8);
  *(_QWORD *)(a2 + 40) = 0;
  v4 = (uint64_t *)(a2 + 48);
  std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__vdeallocate((void **)(a2 + 48));
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  v52 = 0;
  v51 = 0uLL;
  v53 = (void **)&v51;
  std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__destroy_vector::operator()[abi:ne180100](&v53);
  v5 = &v3[strlen(v3) & 0xFFFFFFFFFFFFFFF8];
  MEMORY[0x24268F6D4](a2, v3);
  v7 = *((_QWORD *)v5 + 1);
  v6 = v5 + 8;
  *(_QWORD *)(a2 + 24) = v7;
  *(_QWORD *)(a2 + 32) = v6[1];
  *(_QWORD *)(a2 + 40) = v6[2];
  v8 = v6[3];
  std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::resize(v4, v8);
  v48 = v8;
  if (v8)
  {
    v9 = 0;
    v10 = v6 + 4;
    v47 = v4;
    do
    {
      v49 = *v4;
      v11 = *v4 + 56 * v9;
      v13 = *v10;
      v12 = v10[1];
      v14 = v10 + 3;
      *(_QWORD *)(v11 + 48) = v10[2];
      std::vector<float>::reserve((void **)v11, v13);
      if (v13)
      {
        v15 = 0;
        v16 = (_QWORD *)(v11 + 16);
        v17 = *(_DWORD **)(v11 + 8);
        do
        {
          v18 = *(_DWORD *)v14++;
          v19 = v18;
          if ((unint64_t)v17 >= *v16)
          {
            v21 = *(_DWORD **)v11;
            v22 = ((uint64_t)v17 - *(_QWORD *)v11) >> 2;
            v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 62)
LABEL_45:
              std::vector<float>::__throw_length_error[abi:ne180100]();
            v24 = *v16 - (_QWORD)v21;
            if (v24 >> 1 > v23)
              v23 = v24 >> 1;
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
              v25 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v25 = v23;
            if (v25)
            {
              v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v11 + 16, v25);
              v21 = *(_DWORD **)v11;
              v17 = *(_DWORD **)(v11 + 8);
            }
            else
            {
              v26 = 0;
            }
            v27 = &v26[4 * v22];
            *(_DWORD *)v27 = v19;
            v20 = v27 + 4;
            while (v17 != v21)
            {
              v28 = *--v17;
              *((_DWORD *)v27 - 1) = v28;
              v27 -= 4;
            }
            *(_QWORD *)v11 = v27;
            *(_QWORD *)(v11 + 8) = v20;
            *(_QWORD *)(v11 + 16) = &v26[4 * v25];
            if (v21)
              operator delete(v21);
          }
          else
          {
            *v17 = v19;
            v20 = v17 + 1;
          }
          *(_QWORD *)(v11 + 8) = v20;
          ++v15;
          v17 = v20;
        }
        while (v15 != v13);
      }
      v29 = (void **)(v49 + 56 * v9 + 24);
      std::vector<float>::reserve(v29, v12);
      if (v12)
      {
        v30 = 0;
        v31 = v49 + 56 * v9;
        v34 = *(char **)(v31 + 32);
        v33 = (_DWORD **)(v31 + 32);
        v32 = v34;
        v35 = v33 + 1;
        do
        {
          v36 = *(_DWORD *)v14++;
          v37 = v36;
          if ((unint64_t)v32 >= *v35)
          {
            v39 = (char *)*v29;
            v40 = (v32 - (_BYTE *)*v29) >> 2;
            v41 = v40 + 1;
            if ((unint64_t)(v40 + 1) >> 62)
              goto LABEL_45;
            v42 = *v35 - (_QWORD)v39;
            if (v42 >> 1 > v41)
              v41 = v42 >> 1;
            if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL)
              v43 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v43 = v41;
            if (v43)
            {
              v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v33 + 1), v43);
              v32 = (char *)*v33;
              v39 = (char *)*v29;
            }
            else
            {
              v44 = 0;
            }
            v45 = &v44[4 * v40];
            *(_DWORD *)v45 = v37;
            v38 = v45 + 4;
            while (v32 != v39)
            {
              v46 = *((_DWORD *)v32 - 1);
              v32 -= 4;
              *((_DWORD *)v45 - 1) = v46;
              v45 -= 4;
            }
            *v29 = v45;
            *v33 = v38;
            *v35 = &v44[4 * v43];
            if (v39)
              operator delete(v39);
          }
          else
          {
            *(_DWORD *)v32 = v37;
            v38 = v32 + 4;
          }
          *v33 = v38;
          ++v30;
          v32 = (char *)v38;
        }
        while (v30 != v12);
      }
      ++v9;
      v10 = v14;
      v4 = v47;
    }
    while (v9 != v48);
  }
}

void std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 56 * a2;
    while (v3 != v7)
    {
      v3 -= 56;
      std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

GPUTools::MTL::Utils::DYMTLCounterSet *GPUTools::MTL::Utils::DYMTLCounterSet::DYMTLCounterSet(GPUTools::MTL::Utils::DYMTLCounterSet *this)
{
  _QWORD *v2;

  v2 = std::string::basic_string[abi:ne180100]<0>(this, "");
  std::string::basic_string[abi:ne180100]<0>(v2 + 3, "");
  bzero((char *)this + 48, 0x308uLL);
  return this;
}

void sub_241122C8C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_241122DA8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__vdeallocate(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 56;
        std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  v3 = *(void **)(a2 + 24);
  if (v3)
  {
    *(_QWORD *)(a2 + 32) = v3;
    operator delete(v3);
  }
  v4 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v4;
    operator delete(v4);
  }
}

void std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 2)
  {
    if (a2 >> 62)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = &v6[4 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<float>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

uint64_t std::vector<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::__push_back_slow_path<GPUTools::MTL::Utils::DYMTLFunctionConstantValue const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  std::string *v11;
  std::string::value_type *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492)
    std::vector<float>::__throw_length_error[abi:ne180100]();
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249)
    v6 = 0x492492492492492;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = (std::string *)&v7[56 * v3];
  v13 = &v7[56 * v6];
  std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLFunctionConstantValue,GPUTools::MTL::Utils::DYMTLFunctionConstantValue const&>((_DWORD)a1 + 16, v11, a2);
  v12 = &v11[2].__r_.__value_.__s.__data_[8];
  std::vector<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::~__split_buffer(&v10);
  return v8;
}

void sub_241123134(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

id std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLFunctionConstantValue,GPUTools::MTL::Utils::DYMTLFunctionConstantValue const&>(int a1, std::string *this, __int128 *a3)
{
  __int128 v5;
  __int128 v6;
  id result;

  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v5 = *a3;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = *(__int128 *)((char *)a3 + 24);
  this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 5);
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v6;
  result = *((id *)a3 + 6);
  this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)result;
  return result;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t std::vector<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(56 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      v9 = *(_OWORD *)(a3 - 56);
      *(_QWORD *)(v8 - 40) = *(_QWORD *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      *(_QWORD *)(a3 - 48) = 0;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      v10 = *(_OWORD *)(a3 - 32);
      *(_QWORD *)(v8 - 16) = *(_QWORD *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v10;
      v11 = *(_QWORD *)(a3 - 8);
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(v8 - 8) = v11;
      v8 -= 56;
      v7 -= 56;
      a3 -= 56;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v8;
    v12 = v17;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::destroy[abi:ne180100](v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{

  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

void **std::__split_buffer<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::~__split_buffer(void **a1)
{
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 56;
    std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>::destroy[abi:ne180100](v4, i - 56);
  }
}

uint64_t std::vector<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::__push_back_slow_path<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  void *v11;
  std::string *v12;
  std::string::value_type *v13;
  char *v14;
  uint64_t *v15;

  v3 = (a1[1] - *a1) >> 6;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 58)
    std::vector<float>::__throw_length_error[abi:ne180100]();
  v6 = a1[2] - *a1;
  if (v6 >> 5 > v4)
    v4 = v6 >> 5;
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFC0)
    v7 = 0x3FFFFFFFFFFFFFFLL;
  else
    v7 = v4;
  v15 = a1 + 2;
  if (v7)
    v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>>((uint64_t)(a1 + 2), v7);
  else
    v8 = 0;
  v11 = v8;
  v12 = (std::string *)&v8[64 * v3];
  v14 = &v8[64 * v7];
  std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput,GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>((_DWORD)a1 + 16, v12, a2);
  v13 = &v12[2].__r_.__value_.__s.__data_[16];
  std::vector<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::__swap_out_circular_buffer(a1, &v11);
  v9 = a1[1];
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::~__split_buffer(&v11);
  return v9;
}

void sub_2411235C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::construct[abi:ne180100]<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput,GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput const&>(int a1, std::string *this, __int128 *a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;

  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v5 = *a3;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__r.__words[0] = *((_QWORD *)a3 + 3);
  v6 = (std::string *)((char *)this + 32);
  if (*((char *)a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *((const std::string::value_type **)a3 + 4), *((_QWORD *)a3 + 5));
  }
  else
  {
    v7 = a3[2];
    this[2].__r_.__value_.__r.__words[0] = *((_QWORD *)a3 + 6);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  this[2].__r_.__value_.__l.__size_ = *((_QWORD *)a3 + 7);
}

void sub_241123658(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 6);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v7 = 0;
    do
    {
      v8 = a7 + v7;
      v9 = a3 + v7;
      v10 = *(_OWORD *)(a3 + v7 - 64);
      *(_QWORD *)(v8 - 48) = *(_QWORD *)(a3 + v7 - 48);
      *(_OWORD *)(v8 - 64) = v10;
      *(_QWORD *)(v9 - 56) = 0;
      *(_QWORD *)(v9 - 48) = 0;
      *(_QWORD *)(v9 - 64) = 0;
      *(_QWORD *)(v8 - 40) = *(_QWORD *)(a3 + v7 - 40);
      v11 = *(_OWORD *)(a3 + v7 - 32);
      *(_QWORD *)(v8 - 16) = *(_QWORD *)(a3 + v7 - 16);
      *(_OWORD *)(v8 - 32) = v11;
      *(_QWORD *)(v9 - 24) = 0;
      *(_QWORD *)(v9 - 16) = 0;
      *(_QWORD *)(v9 - 32) = 0;
      *(_QWORD *)(v8 - 8) = *(_QWORD *)(a3 + v7 - 8);
      v7 -= 64;
    }
    while (a3 + v7 != a5);
    *((_QWORD *)&v17 + 1) = a7 + v7;
    v12 = v17;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::destroy[abi:ne180100](v3, v1);
      v1 += 64;
    }
    while (v1 != v2);
  }
}

void std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

void **std::__split_buffer<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::~__split_buffer(void **a1)
{
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 64;
    std::allocator<GPUTools::MTL::Utils::DYMTLPostVertexDumpOutput>::destroy[abi:ne180100](v4, i - 64);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *i = *v20;
LABEL_38:
    *v20 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241123B30(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[2];
  char v25;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = (_QWORD *)*v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = a1 + 16;
  v14 = (char *)operator new(0x40uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *(_QWORD *)v14 = 0;
  *((_QWORD *)v14 + 1) = v7;
  *((_QWORD *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  v25 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v13;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8)
          v22 %= v8;
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  v11 = (_QWORD *)v24[0];
  v24[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return v11;
}

void sub_241123D98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,unsigned long long>,void *> *>>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t i;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *inserted;
  _QWORD *v12;

  v6 = a1[1];
  if (!v6)
    goto LABEL_9;
  for (i = 0; i != v6; *(_QWORD *)(*a1 + 8 * i++) = 0)
    ;
  v8 = (_QWORD *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v8)
  {
    while (a2 != a3)
    {
      v9 = a2[2];
      v8[2] = v9;
      v8[3] = a2[3];
      v10 = (_QWORD *)*v8;
      v8[1] = v9;
      inserted = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__node_insert_multi_prepare((uint64_t)a1, v9, v8 + 2);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__node_insert_multi_perform(a1, v8, inserted);
      a2 = (_QWORD *)*a2;
      v8 = v10;
      if (!v10)
        goto LABEL_9;
    }
    do
    {
      v12 = (_QWORD *)*v8;
      operator delete(v8);
      v8 = v12;
    }
    while (v12);
  }
  else
  {
LABEL_9:
    while (a2 != a3)
    {
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_multi<std::pair<unsigned long long const,unsigned long long> const&>(a1, (_OWORD *)a2 + 1);
      a2 = (_QWORD *)*a2;
    }
  }
}

void sub_241123E8C(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_241123EAC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  float v7;
  float v8;
  uint64_t v9;
  _BOOL8 v10;
  size_t v11;
  unint64_t v12;
  size_t v13;
  uint8x8_t v14;
  unint64_t v15;
  _QWORD *v16;
  int v17;
  _QWORD *result;
  unint64_t v19;
  unint64_t v20;
  _BOOL4 v21;
  int v22;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    v9 = 2 * v6;
    v10 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    v11 = v10 | v9;
    v12 = vcvtps_u32_f32(v7 / v8);
    if (v11 <= v12)
      v13 = v12;
    else
      v13 = v11;
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__rehash<false>(a1, v13);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v14 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    v15 = a2;
    if (v6 <= a2)
      v15 = a2 % v6;
  }
  else
  {
    v15 = (v6 - 1) & a2;
  }
  v16 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
  if (!v16)
    return 0;
  v17 = 0;
  do
  {
    result = v16;
    v16 = (_QWORD *)*v16;
    if (!v16)
      break;
    v19 = v16[1];
    if (v14.u32[0] > 1uLL)
    {
      v20 = v16[1];
      if (v19 >= v6)
        v20 = v19 % v6;
    }
    else
    {
      v20 = v19 & (v6 - 1);
    }
    if (v20 != v15)
      break;
    v21 = v19 == a2 && v16[2] == *a3;
    v22 = v17 & !v21;
    v17 |= v21;
  }
  while (v22 != 1);
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__node_insert_multi_perform(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(_QWORD *)(*result + 8 * v4) = result + 2;
    if (!*a2)
      goto LABEL_19;
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
LABEL_18:
    *(_QWORD *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
    if (v6 != v4)
      goto LABEL_18;
  }
LABEL_19:
  ++result[3];
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__do_rehash<false>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      for (i = (_QWORD *)*v7; *v7; i = (_QWORD *)*v7)
      {
        v12 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v12 >= a2)
            v12 %= a2;
        }
        else
        {
          v12 &= a2 - 1;
        }
        if (v12 == v8)
        {
          v7 = i;
        }
        else
        {
          v13 = i;
          if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
          {
            do
            {
              v14 = v13;
              v13 = (_QWORD *)*v13;
            }
            while (v13 && i[2] == v13[2]);
            *v7 = v13;
            *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = i;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
            v7 = i;
            v8 = v12;
          }
        }
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_multi<std::pair<unsigned long long const,unsigned long long> const&>(_QWORD *a1, _OWORD *a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *inserted;

  v4 = operator new(0x20uLL);
  *((_OWORD *)v4 + 1) = *a2;
  v5 = v4[2];
  *v4 = 0;
  v4[1] = v5;
  inserted = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__node_insert_multi_prepare((uint64_t)a1, v5, v4 + 2);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__node_insert_multi_perform(a1, v4, inserted);
  return v4;
}

void sub_2411243AC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)result = v2;
  *(_QWORD *)(result + 8) = a2[1];
  a2[1] = 0;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  *(_QWORD *)(result + 16) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t std::vector<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = (uint64_t *)*a1;
  v4 = (uint64_t *)a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 5;
    result = std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__hash_table(result - 40, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a2);
}

uint64_t std::__split_buffer<std::unordered_map<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::~__hash_table(i - 40);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>,std::reverse_iterator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x249249249249249)
      v11 = 0x492492492492492;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLFunctionConstantValue>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[56 * v8];
    v18 = &v12[56 * v11];
    v14 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::~__split_buffer(&v15);
  }
}

void sub_241124930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 56) = 0;
      *(_QWORD *)(v7 - 48) = 0;
      *(_QWORD *)(v7 - 40) = 0;
      v8 = *(_OWORD *)(a3 - 56);
      a3 -= 56;
      *(_OWORD *)(v7 - 56) = v8;
      *(_QWORD *)(v7 - 40) = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(a3 + 24);
      *(_QWORD *)(v7 - 16) = *(_QWORD *)(a3 + 40);
      *(_QWORD *)(a3 + 32) = 0;
      *(_QWORD *)(a3 + 40) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 48);
      v7 = *((_QWORD *)&v14 + 1) - 56;
      *((_QWORD *)&v14 + 1) -= 56;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>,std::reverse_iterator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::destroy[abi:ne180100](v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::~__split_buffer(void **a1)
{
  std::__split_buffer<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 56;
    std::allocator<GPUTools::MTL::Utils::DYMTLRasterizationRateLayerDescriptor>::destroy[abi:ne180100](v4, i - 56);
  }
}

id DYGetMTLGuestAppClient()
{
  if (!_guestAppClientMTL)
    __assert_rtn("DYGuestAppClient *DYGetMTLGuestAppClient()", "", 0, "_guestAppClientMTL != nil");
  return (id)_guestAppClientMTL;
}

void DYSetMTLGuestAppClient(id obj)
{
  objc_storeStrong((id *)&_guestAppClientMTL, obj);
}

void DYMTLSetObjectRemappingBlock(void *a1, void *a2)
{
  id v3;
  id v4;

  v4 = a1;
  v3 = a2;
  if (g_interpose_api_once != -1)
    dispatch_once_f(&g_interpose_api_once, 0, (dispatch_function_t)init_interpose_api);
  DYSetBlockPointer();
  DYSetBlockPointer();

}

void sub_241124C4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t init_interpose_api(void *a1)
{
  void *v1;
  void *v2;
  const char *v4;

  v1 = (void *)DYGetInterposeDylibHandle();
  if (!v1)
  {
    dlerror();
    dy_abort();
    goto LABEL_6;
  }
  v2 = v1;
  g_interpose_api = (uint64_t)dlsym(v1, "gDYMTLObjectRemappingBlock");
  if (!g_interpose_api)
  {
LABEL_6:
    v4 = "g_interpose_api.gDYMTLObjectRemappingBlock != nullptr";
    goto LABEL_8;
  }
  g_interpose_api = (uint64_t)dlsym(v2, "gDYMTLObjectUnmappingBlock");
  if (!g_interpose_api)
  {
    v4 = "g_interpose_api.gDYMTLObjectUnmappingBlock != nullptr";
LABEL_8:
    __assert_rtn("void init_interpose_api(void *)", "", 0, v4);
  }
  return dlclose(v2);
}

GPUTools::MTL::CaptureHelper *GPUTools::MTL::CaptureHelper::CaptureHelper(GPUTools::MTL::CaptureHelper *this)
{
  dispatch_semaphore_t v2;
  void *v3;

  *((_QWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_QWORD *)this + 3) = 850045863;
  *((_QWORD *)this + 17) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  if (GPUTools::MTL::onceToken != -1)
    dispatch_once(&GPUTools::MTL::onceToken, &__block_literal_global_0);
  v2 = dispatch_semaphore_create(1);
  v3 = (void *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = v2;

  return this;
}

void ___ZN8GPUTools3MTL13CaptureHelperC2Ev_block_invoke()
{
  dispatch_semaphore_t v0;
  void *v1;
  uint64_t v2;
  void *v3;

  v0 = dispatch_semaphore_create(1);
  v1 = (void *)GPUTools::MTL::_gPointerSemaphore;
  GPUTools::MTL::_gPointerSemaphore = (uint64_t)v0;

  objc_msgSend(MEMORY[0x24BDD1748], "strongObjectsPointerArray");
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = (void *)GPUTools::MTL::_gStrongPointersArray;
  GPUTools::MTL::_gStrongPointersArray = v2;

}

void GPUTools::MTL::CaptureHelper::~CaptureHelper(GPUTools::MTL::CaptureHelper *this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  v2 = (void *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;

  v3 = (void *)*((_QWORD *)this + 14);
  if (v3)
    free(v3);
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  v5 = (void **)((char *)this + 88);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveString(GPUTools::MTL::CaptureHelper *this, const char *__s, uint64_t a3)
{
  uint64_t v6;

  v6 = strlen(__s) + 1;
  return GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)__s, v6, a3, 0);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveClientMemory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v6;
  pthread_mutex_t *v7;
  _WORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  std::string *v17;
  std::string *v18;
  _QWORD *v19;
  void *v20;
  std::__split_buffer<std::string> __v;

  v6 = a5;
  v7 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  v8 = operator new(0x48uLL);
  v8[32] = 0;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  v9 = *(_QWORD *)(a1 + 104);
  v10 = *(_QWORD *)(a1 + 96);
  if (v10 >= v9)
  {
    v12 = *(_QWORD *)(a1 + 88);
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v12) >> 3);
    v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v12) >> 3);
    if (2 * v15 > v14)
      v14 = 2 * v15;
    if (v15 >= 0x555555555555555)
      v16 = 0xAAAAAAAAAAAAAAALL;
    else
      v16 = v14;
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 104);
    if (v16)
      v17 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>>(a1 + 104, v16);
    else
      v17 = 0;
    v18 = v17 + v13;
    __v.__first_ = v17;
    __v.__begin_ = v18;
    __v.__end_cap_.__value_ = &v17[v16];
    v18->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    *(_OWORD *)&v18->__r_.__value_.__r.__words[1] = xmmword_24114E0B0;
    __v.__end_ = v18 + 1;
    std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)(a1 + 88), &__v);
    v11 = *(_QWORD *)(a1 + 96);
    std::__split_buffer<std::string>::~__split_buffer(&__v);
  }
  else
  {
    *(_QWORD *)v10 = v8;
    *(_OWORD *)(v10 + 8) = xmmword_24114E0B0;
    v11 = v10 + 24;
    *(_QWORD *)(a1 + 96) = v10 + 24;
  }
  *(_QWORD *)(a1 + 96) = v11;
  v19 = (_QWORD *)(v11 - 24);
  if (*(char *)(v11 - 1) < 0)
    v19 = (_QWORD *)*v19;
  pthread_mutex_unlock(v7);
  DYGetMTLGuestAppClient();
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  GPUTools::Interpose::DYSavePointer();

  return v19;
}

void sub_241125294(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);

  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unsigned int v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  unint64_t v70;
  unint64_t v71;
  char v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  int v83;
  unint64_t v84;
  unint64_t v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  _QWORD *v92;

  v7 = a2;
  v8 = a4;
  v9 = *(id *)(a1 + 136);
  dispatch_semaphore_wait(v9, 0xFFFFFFFFFFFFFFFFLL);
  if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1)
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)a1, &GPUTools::MTL::kMTLCaptureVersion);
  v10 = objc_msgSend(v7, "textureType");
  v11 = *(_QWORD *)a1;
  v12 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v12 + v11 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v11 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v11 + v12) = v10;
  v13 = objc_msgSend(v7, "pixelFormat");
  v14 = *(_QWORD *)a1;
  v15 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v15 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v15 + v14 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v14 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v14 + v15) = v13;
  v16 = objc_msgSend(v7, "width");
  v17 = *(_QWORD *)a1;
  v18 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v18 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v18 + v17 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v17 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v17 + v18) = v16;
  v19 = objc_msgSend(v7, "height");
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v21 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v21 + v20 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v20 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v20 + v21) = v19;
  v22 = objc_msgSend(v7, "depth");
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v24 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v24 + v23 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v23 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v23 + v24) = v22;
  v25 = objc_msgSend(v7, "mipmapLevelCount");
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v27 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v27 + v26 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v26 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v26 + v27) = v25;
  v28 = objc_msgSend(v7, "sampleCount");
  v29 = *(_QWORD *)a1;
  v30 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v30 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v30 + v29 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v29 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v29 + v30) = v28;
  v31 = objc_msgSend(v7, "arrayLength");
  v32 = *(_QWORD *)a1;
  v33 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v33 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v33 + v32 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v32 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v32 + v33) = v31;
  v34 = objc_msgSend(v7, "framebufferOnly");
  v35 = *(_QWORD *)a1;
  v36 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v36 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v36 + v35 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v35 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v35 + v36) = v34;
  v37 = objc_msgSend(v7, "isDrawable");
  v38 = *(_QWORD *)a1;
  v39 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v39 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v39 + v38 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v38 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v38 + v39) = v37;
  v40 = objc_msgSend(v7, "usage");
  v41 = *(_QWORD *)a1;
  v42 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v42 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v42 + v41 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v41 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v41 + v42) = v40;
  v43 = objc_msgSend(v7, "rotation");
  v44 = *(_QWORD *)a1;
  v45 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v45 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v45 + v44 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v44 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v44 + v45) = v43;
  v46 = objc_msgSend(v7, "storageMode");
  v47 = *(_QWORD *)a1;
  v48 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v48 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v48 + v47 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v47 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v47 + v48) = v46;
  v49 = objc_msgSend(v7, "cpuCacheMode");
  v50 = *(_QWORD *)a1;
  v51 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v51 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v51 + v50 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v50 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v50 + v51) = v49;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v52 = objc_msgSend(v7, "allowGPUOptimizedContents");
    v53 = *(_QWORD *)a1;
    v54 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v54 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v54 + v53 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v53 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v53 + v54) = v52;
  }
  else
  {
    v55 = *(_QWORD *)a1;
    v56 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v56 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v56 + v55 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v55 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v55 + v56) = 0;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v57 = objc_msgSend(v7, "compressionMode");
    v58 = *(_QWORD *)a1;
    v59 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v59 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v59 + v58 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v58 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v58 + v59) = v57;
  }
  else
  {
    v60 = *(_QWORD *)a1;
    v61 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v61 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v61 + v60 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v60 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v60 + v61) = 0;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v62 = objc_msgSend(v7, "resourceIndex");
    v63 = *(_QWORD *)a1;
    v64 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v64 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v64 + v63 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v63 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v63 + v64) = v62;
    v69 = objc_msgSend(v7, "forceResourceIndex");
    v70 = *(_QWORD *)a1;
    v71 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v71 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v71 + v70 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v70 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v70 + v71) = v69;
  }
  else
  {
    v65 = *(_QWORD *)a1;
    v66 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v66 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v66 + v65 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v65 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v65 + v66) = -1;
    v67 = *(_QWORD *)a1;
    v68 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v68 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v68 + v67 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v67 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v67 + v68) = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v72 = objc_msgSend(v7, "swizzle");
    v73 = *(_QWORD *)a1;
    v74 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v74 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v74 + v73 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v73 = *(_QWORD *)a1;
    }
    *(_BYTE *)(v73 + v74) = v72;
    v83 = objc_msgSend(v7, "swizzle");
    v84 = *(_QWORD *)a1;
    v85 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v85 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v85 + v84 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v84 = *(_QWORD *)a1;
    }
    *(_BYTE *)(v84 + v85) = BYTE1(v83);
    v86 = objc_msgSend(v7, "swizzle");
    v87 = *(_QWORD *)a1;
    v88 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v88 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v88 + v87 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v87 = *(_QWORD *)a1;
    }
    *(_BYTE *)(v87 + v88) = BYTE2(v86);
    v89 = objc_msgSend(v7, "swizzle");
    v90 = *(_QWORD *)a1;
    v91 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v91 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v91 + v90 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v90 = *(_QWORD *)a1;
    }
    *(_BYTE *)(v90 + v91) = HIBYTE(v89);
  }
  else
  {
    v75 = *(_QWORD *)a1;
    v76 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v76 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v76 + v75 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v75 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v75 + v76) = 2;
    v77 = *(_QWORD *)a1;
    v78 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v78 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v78 + v77 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v77 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v77 + v78) = 3;
    v79 = *(_QWORD *)a1;
    v80 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v80 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v80 + v79 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v79 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v79 + v80) = 4;
    v81 = *(_QWORD *)a1;
    v82 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v82 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v82 + v81 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v81 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v81 + v82) = 5;
  }
  v92 = GPUTools::MTL::CaptureHelper::SaveClientMemory(a1, *(_QWORD *)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1, a3, v8);
  dispatch_semaphore_signal(v9);

  return v92;
}

{
  id v7;
  id v8;
  NSObject *v9;
  id v10;
  id v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  id v15;
  id v16;
  void *v17;
  unint64_t v18;
  unint64_t v19;
  MTLVertexDescriptor *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  void *v49;
  MTLRenderPipelineColorAttachmentDescriptor *v50;
  id v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t i;
  void *v81;
  void *v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t j;
  void *v92;
  void *v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  int v97;
  unint64_t v98;
  unint64_t v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  _QWORD *v115;

  v7 = a2;
  v8 = a4;
  v9 = *(id *)(a1 + 136);
  dispatch_semaphore_wait(v9, 0xFFFFFFFFFFFFFFFFLL);
  if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1)
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)a1, &GPUTools::MTL::kMTLCaptureVersion);
  objc_msgSend(v7, "vertexFunction");
  v10 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v10, "originalObject");
    v11 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v11 = v10;
  }
  v12 = v11;

  v13 = *(_QWORD *)a1;
  v14 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v14 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v14 + v13 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v13 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v13 + v14) = v12;

  objc_msgSend(v7, "fragmentFunction");
  v15 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v15, "originalObject");
    v16 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v16 = v15;
  }
  v17 = v16;

  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v19 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v19 + v18 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v18 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v18 + v19) = v17;

  objc_msgSend(v7, "vertexDescriptor");
  v20 = (MTLVertexDescriptor *)objc_claimAutoreleasedReturnValue();
  GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)a1, v20);

  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v21 = objc_msgSend(v7, "rasterSampleCount");
    v22 = *(_QWORD *)a1;
    v23 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v23 <= 0xFFFFFFFFFFFFFFF7)
      goto LABEL_19;
  }
  else
  {
    v21 = objc_msgSend(v7, "sampleCount");
    v22 = *(_QWORD *)a1;
    v23 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v23 <= 0xFFFFFFFFFFFFFFF7)
    {
LABEL_19:
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v22 = *(_QWORD *)a1;
      goto LABEL_21;
    }
  }
  *(_QWORD *)(a1 + 8) = v23 + v22 + 8;
LABEL_21:
  *(_QWORD *)(v22 + v23) = v21;
  v24 = objc_msgSend(v7, "sampleMask");
  v25 = *(_QWORD *)a1;
  v26 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v26 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v26 + v25 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v25 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v25 + v26) = v24;
  objc_msgSend(v7, "sampleCoverage");
  v28 = v27;
  v29 = *(_QWORD *)a1;
  v30 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v30 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v30 + v29 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v29 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v29 + v30) = v28;
  v31 = objc_msgSend(v7, "isAlphaToCoverageEnabled");
  v32 = *(_QWORD *)a1;
  v33 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v33 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v33 + v32 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v32 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v32 + v33) = v31;
  v34 = objc_msgSend(v7, "isAlphaToOneEnabled");
  v35 = *(_QWORD *)a1;
  v36 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v36 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v36 + v35 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v35 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v35 + v36) = v34;
  v37 = objc_msgSend(v7, "isRasterizationEnabled");
  v38 = *(_QWORD *)a1;
  v39 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v39 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v39 + v38 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v38 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v38 + v39) = v37;
  v40 = objc_msgSend(v7, "depthAttachmentPixelFormat");
  v41 = *(_QWORD *)a1;
  v42 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v42 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v42 + v41 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v41 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v41 + v42) = v40;
  v43 = objc_msgSend(v7, "stencilAttachmentPixelFormat");
  v44 = *(_QWORD *)a1;
  v45 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v45 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v45 + v44 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v44 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v44 + v45) = v43;
  v46 = *(_QWORD *)a1;
  v47 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v47 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v47 + v46 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v46 = *(_QWORD *)a1;
  }
  v48 = 0;
  *(_DWORD *)(v46 + v47) = 8;
  do
  {
    objc_msgSend(v7, "colorAttachments");
    v49 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v49, "objectAtIndexedSubscript:", v48);
    v50 = (MTLRenderPipelineColorAttachmentDescriptor *)objc_claimAutoreleasedReturnValue();
    GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)a1, v50);

    ++v48;
  }
  while (v48 != 8);
  objc_msgSend(v7, "label");
  v51 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append((GPUTools::DynamicBuffer *)a1, (const char *)objc_msgSend(v51, "UTF8String"));

  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v52 = objc_msgSend(v7, "inputPrimitiveTopology");
    v53 = *(_QWORD *)a1;
    v54 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v54 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v54 + v53 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v53 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v53 + v54) = v52;
  }
  else
  {
    v55 = *(_QWORD *)a1;
    v56 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v56 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v56 + v55 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v55 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v55 + v56) = -1;
  }
  v57 = objc_msgSend(v7, "tessellationPartitionMode");
  v58 = *(_QWORD *)a1;
  v59 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v59 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v59 + v58 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v58 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v58 + v59) = v57;
  v60 = objc_msgSend(v7, "maxTessellationFactor");
  v61 = *(_QWORD *)a1;
  v62 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v62 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v62 + v61 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v61 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v61 + v62) = v60;
  v63 = objc_msgSend(v7, "isTessellationFactorScaleEnabled");
  v64 = *(_QWORD *)a1;
  v65 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v65 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v65 + v64 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v64 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v64 + v65) = v63;
  v66 = objc_msgSend(v7, "tessellationFactorFormat");
  v67 = *(_QWORD *)a1;
  v68 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v68 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v68 + v67 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v67 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v67 + v68) = v66;
  v69 = objc_msgSend(v7, "tessellationControlPointIndexType");
  v70 = *(_QWORD *)a1;
  v71 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v71 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v71 + v70 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v70 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v70 + v71) = v69;
  v72 = objc_msgSend(v7, "tessellationFactorStepFunction");
  v73 = *(_QWORD *)a1;
  v74 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v74 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v74 + v73 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v73 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v73 + v74) = v72;
  v75 = objc_msgSend(v7, "tessellationOutputWindingOrder");
  v76 = *(_QWORD *)a1;
  v77 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v77 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v77 + v76 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v76 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v76 + v77) = v75;
  v78 = *(_QWORD *)a1;
  v79 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v79 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v79 + v78 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v78 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v78 + v79) = 31;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    for (i = 0; i != 31; ++i)
    {
      objc_msgSend(v7, "vertexBuffers");
      v81 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v81, "objectAtIndexedSubscript:", i);
      v82 = (void *)objc_claimAutoreleasedReturnValue();

      v83 = objc_msgSend(v82, "mutability");
      v84 = *(_QWORD *)a1;
      v85 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
      if (v85 > 0xFFFFFFFFFFFFFFF7)
      {
        *(_QWORD *)(a1 + 8) = v85 + v84 + 8;
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
        v84 = *(_QWORD *)a1;
      }
      *(_QWORD *)(v84 + v85) = v83;

    }
  }
  else
  {
    v86 = 31;
    do
    {
      v87 = *(_QWORD *)a1;
      v88 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
      if (v88 > 0xFFFFFFFFFFFFFFF7)
      {
        *(_QWORD *)(a1 + 8) = v88 + v87 + 8;
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
        v87 = *(_QWORD *)a1;
      }
      *(_QWORD *)(v87 + v88) = 0;
      --v86;
    }
    while (v86);
  }
  v89 = *(_QWORD *)a1;
  v90 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v90 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v90 + v89 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v89 = *(_QWORD *)a1;
  }
  *(_DWORD *)(v89 + v90) = 31;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    for (j = 0; j != 31; ++j)
    {
      objc_msgSend(v7, "fragmentBuffers");
      v92 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v92, "objectAtIndexedSubscript:", j);
      v93 = (void *)objc_claimAutoreleasedReturnValue();

      v94 = objc_msgSend(v93, "mutability");
      v95 = *(_QWORD *)a1;
      v96 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
      if (v96 > 0xFFFFFFFFFFFFFFF7)
      {
        *(_QWORD *)(a1 + 8) = v96 + v95 + 8;
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
        v95 = *(_QWORD *)a1;
      }
      *(_QWORD *)(v95 + v96) = v94;

    }
  }
  else
  {
    v97 = 31;
    do
    {
      v98 = *(_QWORD *)a1;
      v99 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
      if (v99 > 0xFFFFFFFFFFFFFFF7)
      {
        *(_QWORD *)(a1 + 8) = v99 + v98 + 8;
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
        v98 = *(_QWORD *)a1;
      }
      *(_QWORD *)(v98 + v99) = 0;
      --v97;
    }
    while (v97);
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v100 = objc_msgSend(v7, "supportIndirectCommandBuffers");
    v101 = *(_QWORD *)a1;
    v102 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v102 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v102 + v101 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v101 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v101 + v102) = v100;
  }
  else
  {
    v103 = *(_QWORD *)a1;
    v104 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v104 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v104 + v103 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v103 = *(_QWORD *)a1;
    }
    *(_DWORD *)(v103 + v104) = 0;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v105 = objc_msgSend(v7, "vertexAmplificationMode");
    v106 = *(_QWORD *)a1;
    v107 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v107 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v107 + v106 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v106 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v106 + v107) = v105;
  }
  else
  {
    v108 = *(_QWORD *)a1;
    v109 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v109 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v109 + v108 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v108 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v108 + v109) = 0;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v110 = objc_msgSend(v7, "maxVertexAmplificationCount");
    v111 = *(_QWORD *)a1;
    v112 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v112 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v112 + v111 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v111 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v111 + v112) = v110;
  }
  else
  {
    v113 = *(_QWORD *)a1;
    v114 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v114 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v114 + v113 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v113 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v113 + v114) = -1;
  }
  v115 = GPUTools::MTL::CaptureHelper::SaveClientMemory(a1, *(_QWORD *)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1, a3, v8);
  dispatch_semaphore_signal(v9);

  return v115;
}

void sub_241125B34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  NSObject *v3;

  dispatch_semaphore_signal(v3);

  _Unwind_Resume(a1);
}

void GPUTools::DynamicBuffer::Append<unsigned int>(unint64_t *a1, _DWORD *a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = *a1;
  v5 = a1[1] - *a1;
  if (v5 > 0xFFFFFFFFFFFFFFF7)
  {
    a1[1] = v5 + v4 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append(a1, 8uLL);
    v4 = *a1;
  }
  *(_DWORD *)(v4 + v5) = *a2;
}

void GPUTools::MTL::CaptureHelper::SaveObject(GPUTools::MTL::CaptureHelper *this, MTLSamplerDescriptor *a2, GPUTools::DynamicBuffer *a3)
{
  uint64_t v4;
  Class isa;
  unint64_t v6;
  uint64_t v7;
  Class v8;
  unint64_t v9;
  uint64_t v10;
  Class v11;
  unint64_t v12;
  uint64_t v13;
  Class v14;
  unint64_t v15;
  uint64_t v16;
  Class v17;
  unint64_t v18;
  uint64_t v19;
  Class v20;
  unint64_t v21;
  uint64_t v22;
  Class v23;
  unint64_t v24;
  int v25;
  Class v26;
  unint64_t v27;
  int v28;
  int v29;
  Class v30;
  unint64_t v31;
  int v32;
  int v33;
  Class v34;
  unint64_t v35;
  id v36;
  int v37;
  Class v38;
  unint64_t v39;
  int v40;
  Class v41;
  unint64_t v42;
  Class v43;
  unint64_t v44;
  int v45;
  Class v46;
  unint64_t v47;
  Class v48;
  unint64_t v49;
  uint64_t v50;
  Class v51;
  unint64_t v52;
  Class v53;
  unint64_t v54;
  Class v55;
  unint64_t v56;
  int v57;
  Class v58;
  unint64_t v59;
  Class v60;
  unint64_t v61;
  GPUTools::MTL::CaptureHelper *v62;

  v62 = this;
  if (a2[1].super.isa != a2->super.isa)
    a2[1].super.isa = a2->super.isa;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)a2, &GPUTools::MTL::kMTLCaptureVersion);
  v4 = -[GPUTools::MTL::CaptureHelper minFilter](v62, "minFilter");
  isa = a2->super.isa;
  v6 = a2[1].super.isa - a2->super.isa;
  if (v6 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)isa + v6 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    isa = a2->super.isa;
  }
  *(_QWORD *)((char *)isa + v6) = v4;
  v7 = -[GPUTools::MTL::CaptureHelper magFilter](v62, "magFilter");
  v8 = a2->super.isa;
  v9 = a2[1].super.isa - a2->super.isa;
  if (v9 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v8 + v9 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v8 = a2->super.isa;
  }
  *(_QWORD *)((char *)v8 + v9) = v7;
  v10 = -[GPUTools::MTL::CaptureHelper mipFilter](v62, "mipFilter");
  v11 = a2->super.isa;
  v12 = a2[1].super.isa - a2->super.isa;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v11 + v12 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v11 = a2->super.isa;
  }
  *(_QWORD *)((char *)v11 + v12) = v10;
  v13 = -[GPUTools::MTL::CaptureHelper maxAnisotropy](v62, "maxAnisotropy");
  v14 = a2->super.isa;
  v15 = a2[1].super.isa - a2->super.isa;
  if (v15 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v14 + v15 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v14 = a2->super.isa;
  }
  *(_QWORD *)((char *)v14 + v15) = v13;
  v16 = -[GPUTools::MTL::CaptureHelper sAddressMode](v62, "sAddressMode");
  v17 = a2->super.isa;
  v18 = a2[1].super.isa - a2->super.isa;
  if (v18 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v17 + v18 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v17 = a2->super.isa;
  }
  *(_QWORD *)((char *)v17 + v18) = v16;
  v19 = -[GPUTools::MTL::CaptureHelper tAddressMode](v62, "tAddressMode");
  v20 = a2->super.isa;
  v21 = a2[1].super.isa - a2->super.isa;
  if (v21 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v20 + v21 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v20 = a2->super.isa;
  }
  *(_QWORD *)((char *)v20 + v21) = v19;
  v22 = -[GPUTools::MTL::CaptureHelper rAddressMode](v62, "rAddressMode");
  v23 = a2->super.isa;
  v24 = a2[1].super.isa - a2->super.isa;
  if (v24 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v23 + v24 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v23 = a2->super.isa;
  }
  *(_QWORD *)((char *)v23 + v24) = v22;
  v25 = -[GPUTools::MTL::CaptureHelper normalizedCoordinates](v62, "normalizedCoordinates");
  v26 = a2->super.isa;
  v27 = a2[1].super.isa - a2->super.isa;
  if (v27 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v26 + v27 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v26 = a2->super.isa;
  }
  *(_DWORD *)((char *)v26 + v27) = v25;
  -[GPUTools::MTL::CaptureHelper lodMinClamp](v62, "lodMinClamp");
  v29 = v28;
  v30 = a2->super.isa;
  v31 = a2[1].super.isa - a2->super.isa;
  if (v31 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v30 + v31 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v30 = a2->super.isa;
  }
  *(_DWORD *)((char *)v30 + v31) = v29;
  -[GPUTools::MTL::CaptureHelper lodMaxClamp](v62, "lodMaxClamp");
  v33 = v32;
  v34 = a2->super.isa;
  v35 = a2[1].super.isa - a2->super.isa;
  if (v35 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v34 + v35 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v34 = a2->super.isa;
  }
  *(_DWORD *)((char *)v34 + v35) = v33;
  -[GPUTools::MTL::CaptureHelper label](v62, "label");
  v36 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append((GPUTools::DynamicBuffer *)a2, (const char *)objc_msgSend(v36, "UTF8String"));

  v37 = -[GPUTools::MTL::CaptureHelper lodAverage](v62, "lodAverage");
  v38 = a2->super.isa;
  v39 = a2[1].super.isa - a2->super.isa;
  if (v39 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v38 + v39 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v38 = a2->super.isa;
  }
  *(_DWORD *)((char *)v38 + v39) = v37;
  v40 = -[GPUTools::MTL::CaptureHelper compareFunction](v62, "compareFunction");
  v41 = a2->super.isa;
  v42 = a2[1].super.isa - a2->super.isa;
  if (v42 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v41 + v42 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v41 = a2->super.isa;
  }
  *(_DWORD *)((char *)v41 + v42) = v40;
  v43 = a2->super.isa;
  v44 = a2[1].super.isa - a2->super.isa;
  if (v44 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v43 + v44 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v43 = a2->super.isa;
  }
  *(_DWORD *)((char *)v43 + v44) = -1;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v45 = -[GPUTools::MTL::CaptureHelper supportArgumentBuffers](v62, "supportArgumentBuffers");
    v46 = a2->super.isa;
    v47 = a2[1].super.isa - a2->super.isa;
    if (v47 > 0xFFFFFFFFFFFFFFF7)
    {
      a2[1].super.isa = (Class)((char *)v46 + v47 + 8);
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
      v46 = a2->super.isa;
    }
    *(_DWORD *)((char *)v46 + v47) = v45;
  }
  else
  {
    v48 = a2->super.isa;
    v49 = a2[1].super.isa - a2->super.isa;
    if (v49 > 0xFFFFFFFFFFFFFFF7)
    {
      a2[1].super.isa = (Class)((char *)v48 + v49 + 8);
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
      v48 = a2->super.isa;
    }
    *(_DWORD *)((char *)v48 + v49) = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v50 = -[GPUTools::MTL::CaptureHelper resourceIndex](v62, "resourceIndex");
    v51 = a2->super.isa;
    v52 = a2[1].super.isa - a2->super.isa;
    if (v52 > 0xFFFFFFFFFFFFFFF7)
    {
      a2[1].super.isa = (Class)((char *)v51 + v52 + 8);
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
      v51 = a2->super.isa;
    }
    *(_QWORD *)((char *)v51 + v52) = v50;
    v57 = -[GPUTools::MTL::CaptureHelper forceResourceIndex](v62, "forceResourceIndex");
    v58 = a2->super.isa;
    v59 = a2[1].super.isa - a2->super.isa;
    if (v59 > 0xFFFFFFFFFFFFFFF7)
    {
      a2[1].super.isa = (Class)((char *)v58 + v59 + 8);
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
      v58 = a2->super.isa;
    }
    *(_DWORD *)((char *)v58 + v59) = v57;
  }
  else
  {
    v53 = a2->super.isa;
    v54 = a2[1].super.isa - a2->super.isa;
    if (v54 > 0xFFFFFFFFFFFFFFF7)
    {
      a2[1].super.isa = (Class)((char *)v53 + v54 + 8);
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
      v53 = a2->super.isa;
    }
    *(_QWORD *)((char *)v53 + v54) = -1;
    v55 = a2->super.isa;
    v56 = a2[1].super.isa - a2->super.isa;
    if (v56 > 0xFFFFFFFFFFFFFFF7)
    {
      a2[1].super.isa = (Class)((char *)v55 + v56 + 8);
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
      v55 = a2->super.isa;
    }
    *(_DWORD *)((char *)v55 + v56) = -1;
  }
  v60 = a2->super.isa;
  v61 = a2[1].super.isa - a2->super.isa;
  if (v61 > 0xFFFFFFFFFFFFFFF7)
  {
    a2[1].super.isa = (Class)((char *)v60 + v61 + 8);
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a2, 8uLL);
    v60 = a2->super.isa;
  }
  *(_DWORD *)((char *)v60 + v61) = 0;

}

void sub_2411261B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void *GPUTools::DynamicBuffer::Append(GPUTools::DynamicBuffer *this, const char *a2)
{
  const char *v3;
  uint64_t v4;
  size_t v5;
  size_t v6;
  size_t v7;

  if (a2)
    v3 = a2;
  else
    v3 = "";
  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  v6 = strlen(v3);
  v7 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
  if (v5 >= v7 + v5)
  {
    if (v5 > v7 + v5)
      *((_QWORD *)this + 1) = v4 + v7 + v5;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, v7);
    v4 = *(_QWORD *)this;
  }
  return memcpy((void *)(v4 + v5), v3, v6 + 1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(MTLSamplerDescriptor *this, MTLSamplerDescriptor *a2, uint64_t a3)
{
  MTLSamplerDescriptor *v5;
  NSObject *v6;
  GPUTools::DynamicBuffer *v7;
  _QWORD *v8;

  v5 = a2;
  v6 = this[17].super.isa;
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  GPUTools::MTL::CaptureHelper::SaveObject((GPUTools::MTL::CaptureHelper *)v5, this, v7);
  v8 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)this->super.isa, this[1].super.isa - this->super.isa, a3, 0);
  dispatch_semaphore_signal(v6);

  return v8;
}

void sub_241126334(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;

  dispatch_semaphore_signal(v2);

  _Unwind_Resume(a1);
}

void GPUTools::MTL::CaptureHelper::_SaveObject(GPUTools::MTL::CaptureHelper *this, MTLStencilDescriptor *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint32_t v17;
  uint64_t v18;
  unint64_t v19;
  uint32_t v20;
  uint64_t v21;
  unint64_t v22;
  MTLStencilDescriptor *v23;

  v23 = a2;
  v3 = *(_QWORD *)this;
  v4 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v4 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v4 + v3 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v3 = *(_QWORD *)this;
  }
  *(_QWORD *)(v3 + v4) = v23;
  v5 = -[MTLStencilDescriptor stencilCompareFunction](v23, "stencilCompareFunction");
  v6 = *(_QWORD *)this;
  v7 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v7 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v7 + v6 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v6 = *(_QWORD *)this;
  }
  *(_QWORD *)(v6 + v7) = v5;
  v8 = -[MTLStencilDescriptor stencilFailureOperation](v23, "stencilFailureOperation");
  v9 = *(_QWORD *)this;
  v10 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v10 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v10 + v9 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v9 = *(_QWORD *)this;
  }
  *(_QWORD *)(v9 + v10) = v8;
  v11 = -[MTLStencilDescriptor depthFailureOperation](v23, "depthFailureOperation");
  v12 = *(_QWORD *)this;
  v13 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v13 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v13 + v12 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v12 = *(_QWORD *)this;
  }
  *(_QWORD *)(v12 + v13) = v11;
  v14 = -[MTLStencilDescriptor depthStencilPassOperation](v23, "depthStencilPassOperation");
  v15 = *(_QWORD *)this;
  v16 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v16 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v16 + v15 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v15 = *(_QWORD *)this;
  }
  *(_QWORD *)(v15 + v16) = v14;
  v17 = -[MTLStencilDescriptor readMask](v23, "readMask");
  v18 = *(_QWORD *)this;
  v19 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v19 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v19 + v18 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v18 = *(_QWORD *)this;
  }
  *(_DWORD *)(v18 + v19) = v17;
  v20 = -[MTLStencilDescriptor writeMask](v23, "writeMask");
  v21 = *(_QWORD *)this;
  v22 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v22 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v22 + v21 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v21 = *(_QWORD *)this;
  }
  *(_DWORD *)(v21 + v22) = v20;

}

void sub_24112653C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(id *this, MTLDepthStencilDescriptor *a2, uint64_t a3)
{
  MTLDepthStencilDescriptor *v5;
  NSObject *v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  _BOOL4 v10;
  char *v11;
  unint64_t v12;
  id v13;
  MTLStencilDescriptor *v14;
  MTLStencilDescriptor *v15;
  _QWORD *v16;

  v5 = a2;
  v6 = this[17];
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  if (this[1] != *this)
    this[1] = *this;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)this, &GPUTools::MTL::kMTLCaptureVersion);
  v7 = -[MTLDepthStencilDescriptor depthCompareFunction](v5, "depthCompareFunction");
  v8 = (char *)*this;
  v9 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v9 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v8[v9 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v8 = (char *)*this;
  }
  *(_QWORD *)&v8[v9] = v7;
  v10 = -[MTLDepthStencilDescriptor isDepthWriteEnabled](v5, "isDepthWriteEnabled");
  v11 = (char *)*this;
  v12 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v11[v12 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v11 = (char *)*this;
  }
  *(_DWORD *)&v11[v12] = v10;
  -[MTLDepthStencilDescriptor label](v5, "label");
  v13 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append((GPUTools::DynamicBuffer *)this, (const char *)objc_msgSend(v13, "UTF8String"));

  -[MTLDepthStencilDescriptor frontFaceStencil](v5, "frontFaceStencil");
  v14 = (MTLStencilDescriptor *)objc_claimAutoreleasedReturnValue();
  GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)this, v14);

  -[MTLDepthStencilDescriptor backFaceStencil](v5, "backFaceStencil");
  v15 = (MTLStencilDescriptor *)objc_claimAutoreleasedReturnValue();
  GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)this, v15);

  v16 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)*this, (_BYTE *)this[1] - (_BYTE *)*this, a3, 0);
  dispatch_semaphore_signal(v6);

  return v16;
}

void sub_2411266EC(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;
  void *v3;

  dispatch_semaphore_signal(v2);
  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(id *this, MTLCompileOptions *a2, uint64_t a3)
{
  MTLCompileOptions *v5;
  NSObject *v6;
  objc_object *v7;
  _BOOL4 v8;
  char *v9;
  unint64_t v10;
  _QWORD *v11;
  int v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;

  v5 = a2;
  if (v5)
  {
    v6 = this[17];
    dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
    if (this[1] != *this)
      this[1] = *this;
    GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)this, &GPUTools::MTL::kMTLCaptureVersion);
    -[MTLCompileOptions preprocessorMacros](v5, "preprocessorMacros");
    v7 = (objc_object *)objc_claimAutoreleasedReturnValue();
    GPUTools::DynamicBuffer::AppendObject((GPUTools::DynamicBuffer *)this, v7);

    v8 = -[MTLCompileOptions fastMathEnabled](v5, "fastMathEnabled");
    v9 = (char *)*this;
    v10 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v10 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v9[v10 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v9 = (char *)*this;
    }
    *(_DWORD *)&v9[v10] = v8;
    v12 = -[MTLCompileOptions debuggingEnabled](v5, "debuggingEnabled");
    v13 = (char *)*this;
    v14 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v14 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v13[v14 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v13 = (char *)*this;
    }
    *(_DWORD *)&v13[v14] = v12;
    v15 = -[MTLCompileOptions languageVersion](v5, "languageVersion");
    v16 = (char *)*this;
    v17 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v17 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v16[v17 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v16 = (char *)*this;
    }
    *(_QWORD *)&v16[v17] = v15;
    v11 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)*this, (_BYTE *)this[1] - (_BYTE *)*this, a3, 0);
    dispatch_semaphore_signal(v6);

  }
  else
  {
    v11 = 0;
  }

  return v11;
}

void sub_2411268AC(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;
  void *v3;

  dispatch_semaphore_signal(v2);
  _Unwind_Resume(a1);
}

void GPUTools::DynamicBuffer::AppendObject(GPUTools::DynamicBuffer *this, objc_object *a2)
{
  void *v4;
  void *v5;
  id v6;
  id v7;
  id v8;

  v4 = (void *)MEMORY[0x24268F8C0]();
  v8 = 0;
  objc_msgSend(MEMORY[0x24BDD1618], "archivedDataWithRootObject:requiringSecureCoding:error:", a2, 1, &v8);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v8;
  v7 = objc_retainAutorelease(v5);
  GPUTools::DynamicBuffer::Append(this, (const void *)objc_msgSend(v7, "bytes"), objc_msgSend(v7, "length"));

  objc_autoreleasePoolPop(v4);
}

void sub_24112698C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void GPUTools::MTL::CaptureHelper::_SaveObject(GPUTools::MTL::CaptureHelper *this, MTLRenderPipelineColorAttachmentDescriptor *a2)
{
  _BOOL4 v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  MTLRenderPipelineColorAttachmentDescriptor *v30;

  v30 = a2;
  v3 = -[MTLRenderPipelineColorAttachmentDescriptor isBlendingEnabled](v30, "isBlendingEnabled");
  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v5 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v5 + v4 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v4 = *(_QWORD *)this;
  }
  *(_DWORD *)(v4 + v5) = v3;
  v6 = -[MTLRenderPipelineColorAttachmentDescriptor sourceRGBBlendFactor](v30, "sourceRGBBlendFactor");
  v7 = *(_QWORD *)this;
  v8 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v8 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v8 + v7 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v7 = *(_QWORD *)this;
  }
  *(_QWORD *)(v7 + v8) = v6;
  v9 = -[MTLRenderPipelineColorAttachmentDescriptor destinationRGBBlendFactor](v30, "destinationRGBBlendFactor");
  v10 = *(_QWORD *)this;
  v11 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v11 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v11 + v10 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v10 = *(_QWORD *)this;
  }
  *(_QWORD *)(v10 + v11) = v9;
  v12 = -[MTLRenderPipelineColorAttachmentDescriptor rgbBlendOperation](v30, "rgbBlendOperation");
  v13 = *(_QWORD *)this;
  v14 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v14 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v14 + v13 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v13 = *(_QWORD *)this;
  }
  *(_QWORD *)(v13 + v14) = v12;
  v15 = -[MTLRenderPipelineColorAttachmentDescriptor sourceAlphaBlendFactor](v30, "sourceAlphaBlendFactor");
  v16 = *(_QWORD *)this;
  v17 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v17 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v17 + v16 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v16 = *(_QWORD *)this;
  }
  *(_QWORD *)(v16 + v17) = v15;
  v18 = -[MTLRenderPipelineColorAttachmentDescriptor destinationAlphaBlendFactor](v30, "destinationAlphaBlendFactor");
  v19 = *(_QWORD *)this;
  v20 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v20 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v20 + v19 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v19 = *(_QWORD *)this;
  }
  *(_QWORD *)(v19 + v20) = v18;
  v21 = -[MTLRenderPipelineColorAttachmentDescriptor alphaBlendOperation](v30, "alphaBlendOperation");
  v22 = *(_QWORD *)this;
  v23 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v23 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v23 + v22 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v22 = *(_QWORD *)this;
  }
  *(_QWORD *)(v22 + v23) = v21;
  v24 = -[MTLRenderPipelineColorAttachmentDescriptor writeMask](v30, "writeMask");
  v25 = *(_QWORD *)this;
  v26 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v26 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v26 + v25 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v25 = *(_QWORD *)this;
  }
  *(_QWORD *)(v25 + v26) = v24;
  v27 = -[MTLRenderPipelineColorAttachmentDescriptor pixelFormat](v30, "pixelFormat");
  v28 = *(_QWORD *)this;
  v29 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v29 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v29 + v28 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v28 = *(_QWORD *)this;
  }
  *(_QWORD *)(v28 + v29) = v27;

}

void sub_241126C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPUTools::MTL::CaptureHelper::_SaveObject(GPUTools::MTL::CaptureHelper *this, MTLRenderPassAttachmentDescriptor *a2, MTLClearColor *a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  id v19;
  id v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  MTLRenderPassAttachmentDescriptor *v44;

  v44 = a2;
  -[MTLRenderPassAttachmentDescriptor texture](v44, "texture");
  v5 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v5, "originalObject");
    v6 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v6 = v5;
  }
  v7 = v6;

  v8 = *(_QWORD *)this;
  v9 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v9 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v9 + v8 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v8 = *(_QWORD *)this;
  }
  *(_QWORD *)(v8 + v9) = v7;

  v10 = -[MTLRenderPassAttachmentDescriptor level](v44, "level");
  v11 = *(_QWORD *)this;
  v12 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v12 + v11 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v11 = *(_QWORD *)this;
  }
  *(_QWORD *)(v11 + v12) = v10;
  v13 = -[MTLRenderPassAttachmentDescriptor slice](v44, "slice");
  v14 = *(_QWORD *)this;
  v15 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v15 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v15 + v14 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v14 = *(_QWORD *)this;
  }
  *(_QWORD *)(v14 + v15) = v13;
  v16 = -[MTLRenderPassAttachmentDescriptor depthPlane](v44, "depthPlane");
  v17 = *(_QWORD *)this;
  v18 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v18 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v18 + v17 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v17 = *(_QWORD *)this;
  }
  *(_QWORD *)(v17 + v18) = v16;
  -[MTLRenderPassAttachmentDescriptor resolveTexture](v44, "resolveTexture");
  v19 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v19, "originalObject");
    v20 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v20 = v19;
  }
  v21 = v20;

  v22 = *(_QWORD *)this;
  v23 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v23 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v23 + v22 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v22 = *(_QWORD *)this;
  }
  *(_QWORD *)(v22 + v23) = v21;

  v24 = -[MTLRenderPassAttachmentDescriptor resolveLevel](v44, "resolveLevel");
  v25 = *(_QWORD *)this;
  v26 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v26 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v26 + v25 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v25 = *(_QWORD *)this;
  }
  *(_QWORD *)(v25 + v26) = v24;
  v27 = -[MTLRenderPassAttachmentDescriptor resolveSlice](v44, "resolveSlice");
  v28 = *(_QWORD *)this;
  v29 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v29 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v29 + v28 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v28 = *(_QWORD *)this;
  }
  *(_QWORD *)(v28 + v29) = v27;
  v30 = -[MTLRenderPassAttachmentDescriptor resolveDepthPlane](v44, "resolveDepthPlane");
  v31 = *(_QWORD *)this;
  v32 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v32 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v32 + v31 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v31 = *(_QWORD *)this;
  }
  *(_QWORD *)(v31 + v32) = v30;
  v33 = -[MTLRenderPassAttachmentDescriptor loadAction](v44, "loadAction");
  v34 = *(_QWORD *)this;
  v35 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v35 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v35 + v34 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v34 = *(_QWORD *)this;
  }
  *(_QWORD *)(v34 + v35) = v33;
  v36 = -[MTLRenderPassAttachmentDescriptor storeAction](v44, "storeAction");
  v37 = *(_QWORD *)this;
  v38 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v38 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v38 + v37 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v37 = *(_QWORD *)this;
  }
  *(_QWORD *)(v37 + v38) = v36;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v39 = -[MTLRenderPassAttachmentDescriptor storeActionOptions](v44, "storeActionOptions");
    v40 = *(_QWORD *)this;
    v41 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v41 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v41 + v40 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v40 = *(_QWORD *)this;
    }
    *(_QWORD *)(v40 + v41) = v39;
  }
  else
  {
    v42 = *(_QWORD *)this;
    v43 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v43 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v43 + v42 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v42 = *(_QWORD *)this;
    }
    *(_QWORD *)(v42 + v43) = 0;
  }
  GPUTools::DynamicBuffer::Append<double>((unint64_t *)this, a3);
  GPUTools::DynamicBuffer::Append<double>((unint64_t *)this, &a3->green);
  GPUTools::DynamicBuffer::Append<double>((unint64_t *)this, &a3->blue);
  GPUTools::DynamicBuffer::Append<double>((unint64_t *)this, &a3->alpha);

}

void sub_241127050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPUTools::DynamicBuffer::Append<double>(unint64_t *a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = *a1;
  v5 = a1[1] - *a1;
  if (v5 > 0xFFFFFFFFFFFFFFF7)
  {
    a1[1] = v5 + v4 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append(a1, 8uLL);
    v4 = *a1;
  }
  *(_QWORD *)(v4 + v5) = *a2;
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(id *this, MTLRenderPassDescriptor *a2, uint64_t a3)
{
  MTLRenderPassDescriptor *v5;
  NSObject *v6;
  id v7;
  id v8;
  void *v9;
  char *v10;
  unint64_t v11;
  uint64_t i;
  void *v13;
  MTLRenderPassAttachmentDescriptor *v14;
  void *v15;
  char *v16;
  unint64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  char *v22;
  unint64_t v23;
  MTLRenderPassAttachmentDescriptor *v24;
  uint64_t v25;
  double v26;
  void *v27;
  void *v28;
  uint64_t v29;
  char *v30;
  unint64_t v31;
  char *v32;
  unint64_t v33;
  MTLRenderPassAttachmentDescriptor *v34;
  void *v35;
  uint64_t v36;
  char *v37;
  unint64_t v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  unint64_t v49;
  uint64_t v50;
  char *v51;
  unint64_t v52;
  char *v53;
  unint64_t v54;
  uint64_t v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  unint64_t v60;
  uint64_t v61;
  char *v62;
  unint64_t v63;
  char *v64;
  unint64_t v65;
  char *v66;
  unint64_t v67;
  uint64_t v68;
  char *v69;
  unint64_t v70;
  uint64_t v71;
  char *v72;
  unint64_t v73;
  char *v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  unint64_t v78;
  char *v79;
  unint64_t v80;
  uint64_t v81;
  int v82;
  char *v83;
  unint64_t v84;
  int v85;
  char *v86;
  unint64_t v87;
  void *v88;
  char v89;
  void *v90;
  uint64_t v91;
  char *v92;
  unint64_t v93;
  char *v94;
  unint64_t v95;
  unsigned int v96;
  char *v97;
  unint64_t v98;
  char *v99;
  unint64_t v100;
  void *v101;
  char *v102;
  unint64_t v103;
  char *v104;
  unint64_t v105;
  _QWORD *v106;
  MTLClearColor __p;

  v5 = a2;
  v6 = this[17];
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  if (this[1] != *this)
    this[1] = *this;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)this, &GPUTools::MTL::kMTLCaptureVersion);
  -[MTLRenderPassDescriptor visibilityResultBuffer](v5, "visibilityResultBuffer");
  v7 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v7, "originalObject");
    v8 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v8 = v7;
  }
  v9 = v8;

  v10 = (char *)*this;
  v11 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v11 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v10[v11 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v10 = (char *)*this;
  }
  *(_QWORD *)&v10[v11] = v9;

  for (i = 0; i != 8; ++i)
  {
    -[MTLRenderPassDescriptor colorAttachments](v5, "colorAttachments");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "objectAtIndexedSubscript:", i);
    v14 = (MTLRenderPassAttachmentDescriptor *)objc_claimAutoreleasedReturnValue();

    -[MTLRenderPassAttachmentDescriptor texture](v14, "texture");
    v15 = (void *)objc_claimAutoreleasedReturnValue();

    if (v15)
    {
      v16 = (char *)*this;
      v17 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v17 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v16[v17 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v16 = (char *)*this;
      }
      *(_QWORD *)&v16[v17] = i;
      -[MTLRenderPassAttachmentDescriptor clearColor](v14, "clearColor");
      __p.red = v18;
      __p.green = v19;
      __p.blue = v20;
      __p.alpha = v21;
      GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)this, v14, &__p);
    }

  }
  v22 = (char *)*this;
  v23 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v23 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v22[v23 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v22 = (char *)*this;
  }
  *(_QWORD *)&v22[v23] = -1;
  -[MTLRenderPassDescriptor depthAttachment](v5, "depthAttachment");
  v24 = (MTLRenderPassAttachmentDescriptor *)objc_claimAutoreleasedReturnValue();
  -[MTLRenderPassDescriptor depthAttachment](v5, "depthAttachment");
  v25 = objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)v25, "clearDepth");
  __p.red = v26;
  memset(&__p.green, 0, 24);
  GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)this, v24, &__p);

  -[MTLRenderPassDescriptor depthAttachment](v5, "depthAttachment");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v25) = objc_opt_respondsToSelector();

  if ((v25 & 1) != 0)
  {
    -[MTLRenderPassDescriptor depthAttachment](v5, "depthAttachment");
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v29 = objc_msgSend(v28, "depthResolveFilter");
    v30 = (char *)*this;
    v31 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v31 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v30[v31 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v30 = (char *)*this;
    }
    *(_QWORD *)&v30[v31] = v29;

  }
  else
  {
    v32 = (char *)*this;
    v33 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v33 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v32[v33 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v32 = (char *)*this;
    }
    *(_QWORD *)&v32[v33] = -1;
  }
  -[MTLRenderPassDescriptor stencilAttachment](v5, "stencilAttachment");
  v34 = (MTLRenderPassAttachmentDescriptor *)objc_claimAutoreleasedReturnValue();
  -[MTLRenderPassDescriptor stencilAttachment](v5, "stencilAttachment");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  __p.red = (double)objc_msgSend(v35, "clearStencil");
  memset(&__p.green, 0, 24);
  GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)this, v34, &__p);

  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v36 = -[MTLRenderPassDescriptor renderTargetArrayLength](v5, "renderTargetArrayLength");
    v37 = (char *)*this;
    v38 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v38 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v37[v38 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v37 = (char *)*this;
    }
    *(_QWORD *)&v37[v38] = v36;
  }
  else
  {
    v39 = (char *)*this;
    v40 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v40 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v39[v40 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v39 = (char *)*this;
    }
    *(_QWORD *)&v39[v40] = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v41 = -[MTLRenderPassDescriptor imageblockSampleLength](v5, "imageblockSampleLength");
    v42 = (char *)*this;
    v43 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v43 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v42[v43 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v42 = (char *)*this;
    }
    *(_QWORD *)&v42[v43] = v41;
    v50 = -[MTLRenderPassDescriptor threadgroupMemoryLength](v5, "threadgroupMemoryLength");
    v51 = (char *)*this;
    v52 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v52 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v51[v52 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v51 = (char *)*this;
    }
    *(_QWORD *)&v51[v52] = v50;
    v55 = -[MTLRenderPassDescriptor tileWidth](v5, "tileWidth");
    v56 = (char *)*this;
    v57 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v57 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v56[v57 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v56 = (char *)*this;
    }
    *(_QWORD *)&v56[v57] = v55;
    v58 = -[MTLRenderPassDescriptor tileHeight](v5, "tileHeight");
    v59 = (char *)*this;
    v60 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v60 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v59[v60 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v59 = (char *)*this;
    }
    *(_QWORD *)&v59[v60] = v58;
  }
  else
  {
    v44 = (char *)*this;
    v45 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v45 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v44[v45 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v44 = (char *)*this;
    }
    *(_QWORD *)&v44[v45] = -1;
    v46 = (char *)*this;
    v47 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v47 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v46[v47 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v46 = (char *)*this;
    }
    *(_QWORD *)&v46[v47] = -1;
    v48 = (char *)*this;
    v49 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v49 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v48[v49 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v48 = (char *)*this;
    }
    *(_QWORD *)&v48[v49] = -1;
    v53 = (char *)*this;
    v54 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v54 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v53[v54 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v53 = (char *)*this;
    }
    *(_QWORD *)&v53[v54] = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v61 = -[MTLRenderPassDescriptor renderTargetWidth](v5, "renderTargetWidth");
    v62 = (char *)*this;
    v63 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v63 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v62[v63 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v62 = (char *)*this;
    }
    *(_QWORD *)&v62[v63] = v61;
    v68 = -[MTLRenderPassDescriptor renderTargetHeight](v5, "renderTargetHeight");
    v69 = (char *)*this;
    v70 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v70 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v69[v70 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v69 = (char *)*this;
    }
    *(_QWORD *)&v69[v70] = v68;
  }
  else
  {
    v64 = (char *)*this;
    v65 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v65 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v64[v65 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v64 = (char *)*this;
    }
    *(_QWORD *)&v64[v65] = -1;
    v66 = (char *)*this;
    v67 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v67 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v66[v67 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v66 = (char *)*this;
    }
    *(_QWORD *)&v66[v67] = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v71 = -[MTLRenderPassDescriptor defaultRasterSampleCount](v5, "defaultRasterSampleCount");
    v72 = (char *)*this;
    v73 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v73 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v72[v73 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v72 = (char *)*this;
    }
    *(_QWORD *)&v72[v73] = v71;
  }
  else
  {
    v74 = (char *)*this;
    v75 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v75 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v74[v75 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v74 = (char *)*this;
    }
    *(_QWORD *)&v74[v75] = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v76 = -[MTLRenderPassDescriptor getSamplePositions:count:](v5, "getSamplePositions:count:", 0, 0);
    v77 = (char *)*this;
    v78 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v78 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v77[v78 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v77 = (char *)*this;
    }
    *(_QWORD *)&v77[v78] = v76;
    if (v76)
    {
      std::vector<MTLSamplePosition>::vector(&__p, v76);
      -[MTLRenderPassDescriptor getSamplePositions:count:](v5, "getSamplePositions:count:", *(_QWORD *)&__p.red, v76);
      v81 = 0;
      do
      {
        v82 = *(_DWORD *)(*(_QWORD *)&__p.red + v81);
        v83 = (char *)*this;
        v84 = (_BYTE *)this[1] - (_BYTE *)*this;
        if (v84 > 0xFFFFFFFFFFFFFFF7)
        {
          this[1] = &v83[v84 + 8];
        }
        else
        {
          std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
          v83 = (char *)*this;
        }
        *(_DWORD *)&v83[v84] = v82;
        v85 = *(_DWORD *)(*(_QWORD *)&__p.red + v81 + 4);
        v86 = (char *)*this;
        v87 = (_BYTE *)this[1] - (_BYTE *)*this;
        if (v87 > 0xFFFFFFFFFFFFFFF7)
        {
          this[1] = &v86[v87 + 8];
        }
        else
        {
          std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
          v86 = (char *)*this;
        }
        *(_DWORD *)&v86[v87] = v85;
        v81 += 8;
        --v76;
      }
      while (v76);
      if (*(_QWORD *)&__p.red)
      {
        __p.green = __p.red;
        operator delete(*(void **)&__p.red);
      }
    }
  }
  else
  {
    v79 = (char *)*this;
    v80 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v80 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v79[v80 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v79 = (char *)*this;
    }
    *(_QWORD *)&v79[v80] = 0;
  }
  -[MTLRenderPassDescriptor stencilAttachment](v5, "stencilAttachment");
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v89 = objc_opt_respondsToSelector();

  if ((v89 & 1) != 0)
  {
    -[MTLRenderPassDescriptor stencilAttachment](v5, "stencilAttachment");
    v90 = (void *)objc_claimAutoreleasedReturnValue();
    v91 = objc_msgSend(v90, "stencilResolveFilter");
    v92 = (char *)*this;
    v93 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v93 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v92[v93 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v92 = (char *)*this;
    }
    *(_QWORD *)&v92[v93] = v91;

  }
  else
  {
    v94 = (char *)*this;
    v95 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v95 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v94[v95 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v94 = (char *)*this;
    }
    *(_QWORD *)&v94[v95] = -1;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v96 = -[MTLRenderPassDescriptor openGLModeEnabled](v5, "openGLModeEnabled");
    v97 = (char *)*this;
    v98 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v98 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v97[v98 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v97 = (char *)*this;
    }
    *(_QWORD *)&v97[v98] = v96;
  }
  else
  {
    v99 = (char *)*this;
    v100 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v100 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v99[v100 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v99 = (char *)*this;
    }
    *(_QWORD *)&v99[v100] = 0;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    -[MTLRenderPassDescriptor rasterizationRateMap](v5, "rasterizationRateMap");
    v101 = (void *)objc_claimAutoreleasedReturnValue();
    v102 = (char *)*this;
    v103 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v103 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v102[v103 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v102 = (char *)*this;
    }
    *(_QWORD *)&v102[v103] = v101;

  }
  else
  {
    v104 = (char *)*this;
    v105 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v105 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v104[v105 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v104 = (char *)*this;
    }
    *(_QWORD *)&v104[v105] = 0;
  }
  v106 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)*this, (_BYTE *)this[1] - (_BYTE *)*this, a3, 0);
  dispatch_semaphore_signal(v6);

  return v106;
}

void sub_241127BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  void *v10;
  NSObject *v11;

  dispatch_semaphore_signal(v11);

  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(id *this, MTLComputePipelineDescriptor *a2, uint64_t a3)
{
  MTLComputePipelineDescriptor *v5;
  NSObject *v6;
  id v7;
  id v8;
  void *v9;
  char *v10;
  unint64_t v11;
  _BOOL4 v12;
  char *v13;
  unint64_t v14;
  id v15;
  void *v16;
  char *v17;
  unint64_t v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  void *v27;
  void *v28;
  uint64_t v29;
  char *v30;
  unint64_t v31;
  void *v32;
  void *v33;
  uint64_t v34;
  char *v35;
  unint64_t v36;
  char *v37;
  unint64_t v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  char *v43;
  unint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;
  char *v48;
  unint64_t v49;
  void *v50;
  void *v51;
  uint64_t v52;
  char *v53;
  unint64_t v54;
  uint64_t v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  unint64_t v60;
  char *v61;
  unint64_t v62;
  uint64_t i;
  void *v64;
  void *v65;
  uint64_t v66;
  char *v67;
  unint64_t v68;
  int v69;
  char *v70;
  unint64_t v71;
  _BOOL4 v72;
  char *v73;
  unint64_t v74;
  char *v75;
  unint64_t v76;
  uint64_t v77;
  char *v78;
  unint64_t v79;
  char *v80;
  unint64_t v81;
  _QWORD *v82;

  v5 = a2;
  v6 = this[17];
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  if (this[1] != *this)
    this[1] = *this;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)this, &GPUTools::MTL::kMTLCaptureVersion);
  -[MTLComputePipelineDescriptor computeFunction](v5, "computeFunction");
  v7 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v7, "originalObject");
    v8 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v8 = v7;
  }
  v9 = v8;

  v10 = (char *)*this;
  v11 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v11 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v10[v11 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v10 = (char *)*this;
  }
  *(_QWORD *)&v10[v11] = v9;

  v12 = -[MTLComputePipelineDescriptor threadGroupSizeIsMultipleOfThreadExecutionWidth](v5, "threadGroupSizeIsMultipleOfThreadExecutionWidth");
  v13 = (char *)*this;
  v14 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v14 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v13[v14 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v13 = (char *)*this;
  }
  *(_DWORD *)&v13[v14] = v12;
  -[MTLComputePipelineDescriptor label](v5, "label");
  v15 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append((GPUTools::DynamicBuffer *)this, (const char *)objc_msgSend(v15, "UTF8String"));

  if ((objc_opt_respondsToSelector() & 1) != 0
    && (-[MTLComputePipelineDescriptor stageInputDescriptor](v5, "stageInputDescriptor"),
        (v16 = (void *)objc_claimAutoreleasedReturnValue()) != 0))
  {
    v17 = (char *)*this;
    v18 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v18 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v17[v18 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v17 = (char *)*this;
    }
    v21 = 0;
    *(_DWORD *)&v17[v18] = 31;
    do
    {
      objc_msgSend(v16, "layouts");
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v22, "objectAtIndexedSubscript:", v21);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      v24 = objc_msgSend(v23, "stride");
      v25 = (char *)*this;
      v26 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v26 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v25[v26 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v25 = (char *)*this;
      }
      *(_QWORD *)&v25[v26] = v24;

      objc_msgSend(v16, "layouts");
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "objectAtIndexedSubscript:", v21);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = objc_msgSend(v28, "stepRate");
      v30 = (char *)*this;
      v31 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v31 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v30[v31 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v30 = (char *)*this;
      }
      *(_QWORD *)&v30[v31] = v29;

      objc_msgSend(v16, "layouts");
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v32, "objectAtIndexedSubscript:", v21);
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      v34 = objc_msgSend(v33, "stepFunction");
      v35 = (char *)*this;
      v36 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v36 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v35[v36 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v35 = (char *)*this;
      }
      *(_QWORD *)&v35[v36] = v34;

      ++v21;
    }
    while (v21 != 31);
    v37 = (char *)*this;
    v38 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v38 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v37[v38 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v37 = (char *)*this;
    }
    v39 = 0;
    *(_DWORD *)&v37[v38] = 31;
    do
    {
      objc_msgSend(v16, "attributes");
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v40, "objectAtIndexedSubscript:", v39);
      v41 = (void *)objc_claimAutoreleasedReturnValue();
      v42 = objc_msgSend(v41, "format");
      v43 = (char *)*this;
      v44 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v44 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v43[v44 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v43 = (char *)*this;
      }
      *(_QWORD *)&v43[v44] = v42;

      objc_msgSend(v16, "attributes");
      v45 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v45, "objectAtIndexedSubscript:", v39);
      v46 = (void *)objc_claimAutoreleasedReturnValue();
      v47 = objc_msgSend(v46, "offset");
      v48 = (char *)*this;
      v49 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v49 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v48[v49 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v48 = (char *)*this;
      }
      *(_QWORD *)&v48[v49] = v47;

      objc_msgSend(v16, "attributes");
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v50, "objectAtIndexedSubscript:", v39);
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      v52 = objc_msgSend(v51, "bufferIndex");
      v53 = (char *)*this;
      v54 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v54 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v53[v54 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v53 = (char *)*this;
      }
      *(_QWORD *)&v53[v54] = v52;

      ++v39;
    }
    while (v39 != 31);
    v55 = objc_msgSend(v16, "indexType");
    v56 = (char *)*this;
    v57 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v57 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v56[v57 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v56 = (char *)*this;
    }
    *(_QWORD *)&v56[v57] = v55;
    v58 = objc_msgSend(v16, "indexBufferIndex");
    v59 = (char *)*this;
    v60 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v60 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v59[v60 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v59 = (char *)*this;
    }
    *(_QWORD *)&v59[v60] = v58;

  }
  else
  {
    v19 = (char *)*this;
    v20 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v20 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v19[v20 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v19 = (char *)*this;
    }
    *(_QWORD *)&v19[v20] = -1;
  }
  v61 = (char *)*this;
  v62 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v62 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v61[v62 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v61 = (char *)*this;
  }
  *(_DWORD *)&v61[v62] = 31;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    for (i = 0; i != 31; ++i)
    {
      -[MTLComputePipelineDescriptor buffers](v5, "buffers");
      v64 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v64, "objectAtIndexedSubscript:", i);
      v65 = (void *)objc_claimAutoreleasedReturnValue();

      v66 = objc_msgSend(v65, "mutability");
      v67 = (char *)*this;
      v68 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v68 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v67[v68 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v67 = (char *)*this;
      }
      *(_QWORD *)&v67[v68] = v66;

    }
  }
  else
  {
    v69 = 31;
    do
    {
      v70 = (char *)*this;
      v71 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v71 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v70[v71 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v70 = (char *)*this;
      }
      *(_QWORD *)&v70[v71] = 0;
      --v69;
    }
    while (v69);
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v72 = -[MTLComputePipelineDescriptor supportIndirectCommandBuffers](v5, "supportIndirectCommandBuffers");
    v73 = (char *)*this;
    v74 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v74 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v73[v74 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v73 = (char *)*this;
    }
    *(_DWORD *)&v73[v74] = v72;
  }
  else
  {
    v75 = (char *)*this;
    v76 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v76 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v75[v76 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v75 = (char *)*this;
    }
    *(_DWORD *)&v75[v76] = 0;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v77 = -[MTLComputePipelineDescriptor maxTotalThreadsPerThreadgroup](v5, "maxTotalThreadsPerThreadgroup");
    v78 = (char *)*this;
    v79 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v79 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v78[v79 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v78 = (char *)*this;
    }
    *(_QWORD *)&v78[v79] = v77;
  }
  else
  {
    v80 = (char *)*this;
    v81 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v81 > 0xFFFFFFFFFFFFFFF7)
    {
      this[1] = &v80[v81 + 8];
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v80 = (char *)*this;
    }
    *(_QWORD *)&v80[v81] = 0;
  }
  v82 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)*this, (_BYTE *)this[1] - (_BYTE *)*this, a3, 0);
  dispatch_semaphore_signal(v6);

  return v82;
}

void sub_24112845C(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;
  void *v3;

  dispatch_semaphore_signal(v2);
  _Unwind_Resume(a1);
}

void sub_24112852C()
{
  void *v0;

  JUMPOUT(0x241128514);
}

void sub_241128540()
{
  void *v0;

  JUMPOUT(0x241128514);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(uint64_t a1, dispatch_data_t data, uint64_t a3)
{
  dispatch_data_t v5;
  _QWORD *v6;
  uint64_t v8;
  size_t size_ptr;

  v8 = 0;
  size_ptr = 0;
  v5 = dispatch_data_create_map(data, (const void **)&v8, &size_ptr);
  v6 = GPUTools::MTL::CaptureHelper::SaveClientMemory(a1, v8, size_ptr, a3, 0);

  return v6;
}

void sub_2411285B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void GPUTools::MTL::CaptureHelper::_SaveObject(GPUTools::MTL::CaptureHelper *this, MTLTileRenderPipelineColorAttachmentDescriptor *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  MTLTileRenderPipelineColorAttachmentDescriptor *v6;

  v6 = a2;
  v3 = -[MTLTileRenderPipelineColorAttachmentDescriptor pixelFormat](v6, "pixelFormat");
  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v5 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v5 + v4 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v4 = *(_QWORD *)this;
  }
  *(_QWORD *)(v4 + v5) = v3;

}

void sub_24112863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPUTools::MTL::CaptureHelper::_SaveObject(GPUTools::MTL::CaptureHelper *this, MTLVertexDescriptor *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  MTLVertexDescriptor *v39;

  v39 = a2;
  v3 = *(_QWORD *)this;
  v4 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v4 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v4 + v3 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v3 = *(_QWORD *)this;
  }
  v5 = 0;
  *(_DWORD *)(v3 + v4) = 31;
  do
  {
    -[MTLVertexDescriptor layouts](v39, "layouts");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "objectAtIndexedSubscript:", v5);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = objc_msgSend(v7, "stride");
    v9 = *(_QWORD *)this;
    v10 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v10 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v10 + v9 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v9 = *(_QWORD *)this;
    }
    *(_QWORD *)(v9 + v10) = v8;

    -[MTLVertexDescriptor layouts](v39, "layouts");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "objectAtIndexedSubscript:", v5);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "stepRate");
    v14 = *(_QWORD *)this;
    v15 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v15 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v15 + v14 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v14 = *(_QWORD *)this;
    }
    *(_QWORD *)(v14 + v15) = v13;

    -[MTLVertexDescriptor layouts](v39, "layouts");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "objectAtIndexedSubscript:", v5);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v18 = objc_msgSend(v17, "stepFunction");
    v19 = *(_QWORD *)this;
    v20 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v20 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v20 + v19 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v19 = *(_QWORD *)this;
    }
    *(_QWORD *)(v19 + v20) = v18;

    ++v5;
  }
  while (v5 != 31);
  v21 = *(_QWORD *)this;
  v22 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v22 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v22 + v21 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v21 = *(_QWORD *)this;
  }
  v23 = 0;
  *(_DWORD *)(v21 + v22) = 31;
  do
  {
    -[MTLVertexDescriptor attributes](v39, "attributes");
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v24, "objectAtIndexedSubscript:", v23);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = objc_msgSend(v25, "format");
    v27 = *(_QWORD *)this;
    v28 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v28 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v28 + v27 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v27 = *(_QWORD *)this;
    }
    *(_QWORD *)(v27 + v28) = v26;

    -[MTLVertexDescriptor attributes](v39, "attributes");
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v29, "objectAtIndexedSubscript:", v23);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v31 = objc_msgSend(v30, "offset");
    v32 = *(_QWORD *)this;
    v33 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v33 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v33 + v32 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v32 = *(_QWORD *)this;
    }
    *(_QWORD *)(v32 + v33) = v31;

    -[MTLVertexDescriptor attributes](v39, "attributes");
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v34, "objectAtIndexedSubscript:", v23);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    v36 = objc_msgSend(v35, "bufferIndex");
    v37 = *(_QWORD *)this;
    v38 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    if (v38 > 0xFFFFFFFFFFFFFFF7)
    {
      *((_QWORD *)this + 1) = v38 + v37 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v37 = *(_QWORD *)this;
    }
    *(_QWORD *)(v37 + v38) = v36;

    ++v23;
  }
  while (v23 != 31);

}

void sub_241128978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2411294C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  NSObject *v3;

  dispatch_semaphore_signal(v3);

  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(id *this, MTLTileRenderPipelineDescriptor *a2, uint64_t a3)
{
  MTLTileRenderPipelineDescriptor *v5;
  NSObject *v6;
  id v7;
  id v8;
  id v9;
  void *v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  MTLTileRenderPipelineColorAttachmentDescriptor *v20;
  _BOOL4 v21;
  char *v22;
  unint64_t v23;
  char *v24;
  unint64_t v25;
  uint64_t i;
  void *v27;
  void *v28;
  uint64_t v29;
  char *v30;
  unint64_t v31;
  int v32;
  char *v33;
  unint64_t v34;
  _QWORD *v35;

  v5 = a2;
  v6 = this[17];
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  if (this[1] != *this)
    this[1] = *this;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)this, &GPUTools::MTL::kMTLCaptureVersion);
  -[MTLTileRenderPipelineDescriptor label](v5, "label");
  v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append((GPUTools::DynamicBuffer *)this, (const char *)objc_msgSend(v7, "UTF8String"));

  -[MTLTileRenderPipelineDescriptor tileFunction](v5, "tileFunction");
  v8 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v8, "originalObject");
    v9 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v9 = v8;
  }
  v10 = v9;

  v11 = (char *)*this;
  v12 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v11[v12 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v11 = (char *)*this;
  }
  *(_QWORD *)&v11[v12] = v10;

  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v13 = -[MTLTileRenderPipelineDescriptor rasterSampleCount](v5, "rasterSampleCount");
    v14 = (char *)*this;
    v15 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v15 <= 0xFFFFFFFFFFFFFFF7)
      goto LABEL_13;
  }
  else
  {
    v13 = -[MTLTileRenderPipelineDescriptor sampleCount](v5, "sampleCount");
    v14 = (char *)*this;
    v15 = (_BYTE *)this[1] - (_BYTE *)*this;
    if (v15 <= 0xFFFFFFFFFFFFFFF7)
    {
LABEL_13:
      std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
      v14 = (char *)*this;
      goto LABEL_15;
    }
  }
  this[1] = &v14[v15 + 8];
LABEL_15:
  *(_QWORD *)&v14[v15] = v13;
  v16 = (char *)*this;
  v17 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v17 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v16[v17 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v16 = (char *)*this;
  }
  v18 = 0;
  *(_DWORD *)&v16[v17] = 8;
  do
  {
    -[MTLTileRenderPipelineDescriptor colorAttachments](v5, "colorAttachments");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "objectAtIndexedSubscript:", v18);
    v20 = (MTLTileRenderPipelineColorAttachmentDescriptor *)objc_claimAutoreleasedReturnValue();
    GPUTools::MTL::CaptureHelper::_SaveObject((GPUTools::MTL::CaptureHelper *)this, v20);

    ++v18;
  }
  while (v18 != 8);
  v21 = -[MTLTileRenderPipelineDescriptor threadgroupSizeMatchesTileSize](v5, "threadgroupSizeMatchesTileSize");
  v22 = (char *)*this;
  v23 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v23 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v22[v23 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v22 = (char *)*this;
  }
  *(_DWORD *)&v22[v23] = v21;
  v24 = (char *)*this;
  v25 = (_BYTE *)this[1] - (_BYTE *)*this;
  if (v25 > 0xFFFFFFFFFFFFFFF7)
  {
    this[1] = &v24[v25 + 8];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v24 = (char *)*this;
  }
  *(_DWORD *)&v24[v25] = 31;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    for (i = 0; i != 31; ++i)
    {
      -[MTLTileRenderPipelineDescriptor tileBuffers](v5, "tileBuffers");
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "objectAtIndexedSubscript:", i);
      v28 = (void *)objc_claimAutoreleasedReturnValue();

      v29 = objc_msgSend(v28, "mutability");
      v30 = (char *)*this;
      v31 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v31 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v30[v31 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v30 = (char *)*this;
      }
      *(_QWORD *)&v30[v31] = v29;

    }
  }
  else
  {
    v32 = 31;
    do
    {
      v33 = (char *)*this;
      v34 = (_BYTE *)this[1] - (_BYTE *)*this;
      if (v34 > 0xFFFFFFFFFFFFFFF7)
      {
        this[1] = &v33[v34 + 8];
      }
      else
      {
        std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
        v33 = (char *)*this;
      }
      *(_QWORD *)&v33[v34] = 0;
      --v32;
    }
    while (v32);
  }
  v35 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, (uint64_t)*this, (_BYTE *)this[1] - (_BYTE *)*this, a3, 0);
  dispatch_semaphore_signal(v6);

  return v35;
}

void sub_241129964(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;

  dispatch_semaphore_signal(v2);

  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveObject(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  NSObject *v6;
  unint64_t v7;
  unint64_t v8;
  id v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  void *v21;
  id v22;
  void *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  void *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char v41;
  unint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v5 = a2;
  v6 = *(id *)(a1 + 136);
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1)
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)a1, &GPUTools::MTL::kMTLCaptureVersion);
  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v8 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v8 + v7 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v7 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v7 + v8) = 1;
  objc_msgSend(v5, "name");
  v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append((GPUTools::DynamicBuffer *)a1, (const char *)objc_msgSend(v9, "UTF8String"));

  if (v5)
  {
    objc_msgSend(v5, "maxThreadsPerThreadgroup");
    v10 = v46;
  }
  else
  {
    v10 = 0;
    v47 = 0;
    v48 = 0;
  }
  v11 = *(_QWORD *)a1;
  v12 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v12 + v11 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v11 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v11 + v12) = v10;
  if (v5)
  {
    objc_msgSend(v5, "maxThreadsPerThreadgroup");
    v13 = v47;
  }
  else
  {
    v13 = 0;
    v48 = 0;
  }
  v14 = *(_QWORD *)a1;
  v15 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v15 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v15 + v14 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v14 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v14 + v15) = v13;
  if (v5)
  {
    objc_msgSend(v5, "maxThreadsPerThreadgroup");
    v16 = v48;
  }
  else
  {
    v16 = 0;
  }
  v17 = *(_QWORD *)a1;
  v18 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v18 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v18 + v17 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v17 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v17 + v18) = v16;
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v20 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v20 + v19 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v19 = *(_QWORD *)a1;
  }
  *(_BYTE *)(v19 + v20) = 0;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v21 = v5;
  else
    v21 = 0;
  v22 = v21;
  if (v22 && (NSSelectorFromString(CFSTR("sharedMemorySize")), (objc_opt_respondsToSelector() & 1) != 0))
  {
    objc_msgSend(v22, "valueForKey:", CFSTR("sharedMemorySize"));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = objc_msgSend(v23, "unsignedLongValue");
    v25 = *(_QWORD *)a1;
    v26 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v26 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v26 + v25 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v25 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v25 + v26) = v24;

  }
  else
  {
    v27 = *(_QWORD *)a1;
    v28 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v28 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v28 + v27 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v27 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v27 + v28) = 0;
    if (!v22)
      goto LABEL_44;
  }
  NSSelectorFromString(CFSTR("dedicatedMemorySize"));
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_msgSend(v22, "valueForKey:", CFSTR("dedicatedMemorySize"));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = objc_msgSend(v29, "unsignedLongValue");
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if (v32 > 0xFFFFFFFFFFFFFFF7)
    {
      *(_QWORD *)(a1 + 8) = v32 + v31 + 8;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
      v31 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v31 + v32) = v30;

    goto LABEL_50;
  }
LABEL_44:
  v33 = *(_QWORD *)a1;
  v34 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v34 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v34 + v33 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v33 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v33 + v34) = 0;
LABEL_50:
  v35 = *(_QWORD *)a1;
  v36 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v36 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v36 + v35 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v35 = *(_QWORD *)a1;
  }
  *(_BYTE *)(v35 + v36) = 0;
  v37 = *(_QWORD *)a1;
  v38 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v38 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v38 + v37 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v37 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v37 + v38) = -1;
  v39 = *(_QWORD *)a1;
  v40 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v40 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v40 + v39 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v39 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v39 + v40) = 0;
  v41 = objc_opt_respondsToSelector();
  v42 = *(_QWORD *)a1;
  v43 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if ((v41 & 1) != 0)
  {
    if (v43 <= 0xFFFFFFFFFFFFFFF7)
      goto LABEL_63;
LABEL_64:
    *(_QWORD *)(a1 + 8) = v43 + v42 + 8;
    goto LABEL_65;
  }
  if (v43 > 0xFFFFFFFFFFFFFFF7)
    goto LABEL_64;
LABEL_63:
  std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
  v42 = *(_QWORD *)a1;
LABEL_65:
  *(_QWORD *)(v42 + v43) = 0;
  v44 = GPUTools::MTL::CaptureHelper::SaveClientMemory(a1, *(_QWORD *)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1, a3, 0);

  dispatch_semaphore_signal(v6);
  return v44;
}

void sub_241129EC0(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;
  void *v3;

  dispatch_semaphore_signal(v2);
  _Unwind_Resume(a1);
}

uint64_t GPUTools::MTL::GetClientMemorySize(void *a1, void *a2, uint64_t *a3, unint64_t a4, unint64_t a5, unint64_t *a6, uint64_t *a7)
{
  id v11;
  id v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  id v23;
  __IOSurface *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  void *v30;

  v11 = a1;
  v12 = a2;
  v30 = v11;
  v13 = objc_msgSend(v12, "pixelFormat");
  v14 = objc_msgSend(v12, "sampleCount");
  if (v14 <= 1)
    v15 = 1;
  else
    v15 = v14;
  if ((unint64_t)*a3 <= 1)
    v16 = 1;
  else
    v16 = *a3;
  if ((unint64_t)a3[1] <= 1)
    v17 = 1;
  else
    v17 = a3[1];
  MTLPixelFormatGetInfoForDevice();
  if (v13 == 260)
    v18 = 5;
  else
    v18 = 0;
  v19 = v18 * v15;
  v20 = v19 * v16;
  if (a4)
    v21 = a4;
  else
    v21 = v19 * v16;
  if (a5)
    v22 = a5;
  else
    v22 = v21 * v17;
  if (a6)
    *a6 = v21;
  if (a7)
    *a7 = v22;
  v23 = v12;
  v24 = (__IOSurface *)objc_msgSend(v23, "iosurface");
  if (v24 && DYGetHostInfo())
  {
    *a6 = IOSurfaceGetBytesPerRowOfPlane(v24, objc_msgSend(v23, "iosurfacePlane"));
    *a7 = *a6 * IOSurfaceGetHeightOfPlane(v24, objc_msgSend(v23, "iosurfacePlane"));
    if (objc_msgSend(v23, "isFramebufferOnly"))
      v25 = *a6 * v17;
    else
      v25 = *a7;
  }
  else
  {
    v26 = a3[2];
    if (v26 <= 1)
      v26 = 1;
    v27 = v26 - 1;
    if (v17 <= 1)
      v28 = 1;
    else
      v28 = v17;
    v25 = v20 + v21 * (v28 - 1) + v27 * v22;
  }
  if ((v13 & 0xFFFFFFFFFFFFFFFELL) == 0x226)
  {
    v25 = 5 * v16 * v17;
    if (v21 < 4 * v16)
    {
      if (a6)
        *a6 = 4 * v16;
      if (a7)
        *a7 = 4 * v16 * v17;
    }
  }

  return v25;
}

void sub_24112A1A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void GPUTools::MTL::CaptureHelper::EncodeChainedRenderPipelineStateInfo(GPUTools::MTL::CaptureHelper *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  id v9;
  MTLRenderPipelineReflection *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  int v18;
  void *v19;
  int v20;
  uint64_t v21;
  int v22;
  id v23;
  void *v24;
  int v25;
  id v26;
  void *v27;
  int v28;
  id v29;
  void *v30;
  int v31;
  MTLRenderPipelineReflection *v32;
  id v33;
  unsigned int v34;
  void *v35;
  id v36;
  id v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  id v52;
  id v53;
  id v54;
  void *v55;
  id v56;
  void *v57;
  id v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  uint64_t *v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t *v73;
  char *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  id v87;
  void *v88;
  _QWORD v89[4];
  MTLRenderPipelineReflection *v90;
  id v91;
  _QWORD *v92;
  GPUTools::MTL::CaptureHelper *v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  _QWORD v97[4];
  id v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  _QWORD v103[4];
  id v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  _QWORD v109[4];
  id v110;
  _QWORD *v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  _QWORD v115[3];
  int v116;
  char v117;
  id v118[12];

  v118[10] = *(id *)MEMORY[0x24BDAC8D0];
  v9 = a3;
  v10 = a4;
  v87 = a5;
  v88 = v9;
  if (v9 && v10)
  {
    -[MTLRenderPipelineReflection performanceStatistics](v10, "performanceStatistics");
    v85 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_msgSend(v85, "count");
    -[MTLRenderPipelineReflection vertexBuiltInArguments](v10, "vertexBuiltInArguments");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v84 = objc_msgSend(v12, "count");

    -[MTLRenderPipelineReflection vertexBindings](v10, "vertexBindings");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v86 = objc_msgSend(v13, "count");

    -[MTLRenderPipelineReflection fragmentBindings](v10, "fragmentBindings");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = objc_msgSend(v14, "count");

    -[MTLRenderPipelineReflection tileBindings](v10, "tileBindings");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "count");

    v18 = GPUTools::MTL::CaptureHelper::_EncodeImageBlockDataReturn(a1, v10);
    v83 = v11;
    v115[0] = 0;
    v115[1] = v115;
    v115[2] = 0x2020000000;
    v116 = 0;
    -[MTLRenderPipelineReflection vertexBuiltInArguments](v10, "vertexBuiltInArguments");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = (v11 == 0) & ~v18;
    v21 = MEMORY[0x24BDAC760];
    v109[0] = MEMORY[0x24BDAC760];
    v109[1] = 3221225472;
    v109[2] = ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke;
    v109[3] = &unk_251122D58;
    if ((((v86 | v15 | v17) == 0) & v20) != 0)
      v22 = 0x2000;
    else
      v22 = 0;
    v111 = v115;
    v112 = v84;
    v114 = v22;
    v113 = a2;
    v23 = v88;
    v110 = v23;
    objc_msgSend(v19, "enumerateObjectsUsingBlock:", v109);

    -[MTLRenderPipelineReflection vertexBindings](v10, "vertexBindings");
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    v103[0] = v21;
    v103[1] = 3221225472;
    v103[2] = ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke_2;
    v103[3] = &unk_251122D58;
    if ((((v15 | v17) == 0) & v20) != 0)
      v25 = 0x2000;
    else
      v25 = 0;
    v105 = v115;
    v106 = v86;
    v107 = a2;
    v108 = v25;
    v26 = v23;
    v104 = v26;
    objc_msgSend(v24, "enumerateObjectsUsingBlock:", v103);

    -[MTLRenderPipelineReflection fragmentBindings](v10, "fragmentBindings");
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v97[0] = v21;
    v97[1] = 3221225472;
    if (((v17 == 0) & v20) != 0)
      v28 = 0x2000;
    else
      v28 = 0;
    v97[2] = ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke_3;
    v97[3] = &unk_251122D58;
    v99 = v115;
    v100 = v15;
    v102 = v28;
    v101 = a2;
    v29 = v26;
    v98 = v29;
    objc_msgSend(v27, "enumerateObjectsUsingBlock:", v97);

    -[MTLRenderPipelineReflection tileBindings](v10, "tileBindings");
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v89[0] = v21;
    if (v20)
      v31 = 0x2000;
    else
      v31 = 0;
    v89[1] = 3221225472;
    v89[2] = ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke_4;
    v89[3] = &unk_251122D80;
    v92 = v115;
    v93 = a1;
    v94 = v17;
    v96 = v31;
    v32 = v10;
    v90 = v32;
    v95 = a2;
    v33 = v29;
    v91 = v33;
    objc_msgSend(v30, "enumerateObjectsUsingBlock:", v89);

    if (v18)
    {
      v34 = (v83 == 0) << 13;
      if (v84 || v86 || v15)
      {
        -[MTLRenderPipelineReflection imageBlockDataReturn](v32, "imageBlockDataReturn");
        v35 = (void *)objc_claimAutoreleasedReturnValue();
        Encode((char **)a2, v35, 104, v34, v33);
      }
      else
      {
        -[MTLRenderPipelineReflection imageBlockDataReturn](v32, "imageBlockDataReturn");
        v35 = (void *)objc_claimAutoreleasedReturnValue();
        Encode((char **)a2, v35, 121, v34, v33);
      }

    }
    if (v83)
    {
      v52 = v85;
      v53 = v33;
      v54 = v87;
      v118[0] = 0;
      objc_msgSend(MEMORY[0x24BDD1618], "archivedDataWithRootObject:requiringSecureCoding:error:", v52, 1, v118);
      v55 = (void *)objc_claimAutoreleasedReturnValue();
      v56 = v118[0];
      v117 = 0;
      DYGetMTLGuestAppClient();
      v57 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v55, "length");
      v58 = objc_retainAutorelease(v55);
      objc_msgSend(v58, "bytes");
      GPUTools::Interpose::DYSavePointer();

      v59 = operator new();
      *(_QWORD *)v59 = 0;
      *(_QWORD *)(v59 + 8) = 0;
      *(_DWORD *)(v59 + 16) = 0;
      v60 = *(_QWORD *)(a2 + 16);
      v61 = *(uint64_t **)(a2 + 8);
      if ((unint64_t)v61 >= v60)
      {
        v63 = ((uint64_t)v61 - *(_QWORD *)a2) >> 3;
        if ((unint64_t)(v63 + 1) >> 61)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v64 = v60 - *(_QWORD *)a2;
        v65 = v64 >> 2;
        if (v64 >> 2 <= (unint64_t)(v63 + 1))
          v65 = v63 + 1;
        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
          v66 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v66 = v65;
        if (v66)
          v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a2 + 16, v66);
        else
          v67 = 0;
        v73 = (uint64_t *)&v67[8 * v63];
        v74 = &v67[8 * v66];
        *v73 = v59;
        v62 = v73 + 1;
        v76 = *(char **)a2;
        v75 = *(char **)(a2 + 8);
        if (v75 != *(char **)a2)
        {
          do
          {
            v77 = *((_QWORD *)v75 - 1);
            v75 -= 8;
            *--v73 = v77;
          }
          while (v75 != v76);
          v75 = *(char **)a2;
        }
        *(_QWORD *)a2 = v73;
        *(_QWORD *)(a2 + 8) = v62;
        *(_QWORD *)(a2 + 16) = v74;
        if (v75)
          operator delete(v75);
      }
      else
      {
        *v61 = v59;
        v62 = v61 + 1;
      }
      *(_QWORD *)(a2 + 8) = v62;
      v78 = *(v62 - 1);
      objc_msgSend(v58, "length", &v117);
      GPUTools::FB::Encode(v78, 4294955024, 0x2000, (uint64_t)"CiUul", v79, v80, v81, v82, (char)v53);

    }
    _Block_object_dispose(v115, 8);

  }
  else
  {
    v36 = v9;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend(v36, "originalObject");
      v37 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v37 = v36;
    }
    v38 = v37;

    v43 = operator new();
    *(_QWORD *)v43 = 0;
    *(_QWORD *)(v43 + 8) = 0;
    *(_DWORD *)(v43 + 16) = 0;
    v44 = *(_QWORD *)(a2 + 16);
    v45 = *(uint64_t **)(a2 + 8);
    if ((unint64_t)v45 >= v44)
    {
      v47 = ((uint64_t)v45 - *(_QWORD *)a2) >> 3;
      if ((unint64_t)(v47 + 1) >> 61)
        std::vector<float>::__throw_length_error[abi:ne180100]();
      v48 = v44 - *(_QWORD *)a2;
      v49 = v48 >> 2;
      if (v48 >> 2 <= (unint64_t)(v47 + 1))
        v49 = v47 + 1;
      if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
        v50 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v50 = v49;
      if (v50)
        v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a2 + 16, v50);
      else
        v51 = 0;
      v68 = (uint64_t *)&v51[8 * v47];
      v69 = &v51[8 * v50];
      *v68 = v43;
      v46 = v68 + 1;
      v71 = *(char **)a2;
      v70 = *(char **)(a2 + 8);
      if (v70 != *(char **)a2)
      {
        do
        {
          v72 = *((_QWORD *)v70 - 1);
          v70 -= 8;
          *--v68 = v72;
        }
        while (v70 != v71);
        v70 = *(char **)a2;
      }
      *(_QWORD *)a2 = v68;
      *(_QWORD *)(a2 + 8) = v46;
      *(_QWORD *)(a2 + 16) = v69;
      if (v70)
        operator delete(v70);
    }
    else
    {
      *v45 = v43;
      v46 = v45 + 1;
    }
    *(_QWORD *)(a2 + 8) = v46;
    GPUTools::FB::Encode(*(v46 - 1), 4294955024, 0x2000, (uint64_t)"Ci", v39, v40, v41, v42, (char)v38);

  }
}

void sub_24112A8F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  void *v53;
  void *v54;
  uint64_t v55;

  _Block_object_dispose((const void *)(v55 - 232), 8);
  _Unwind_Resume(a1);
}

void GPUTools::FB::Encode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _BYTE v9[16];
  char *v10;

  v10 = &a9;
  GPUTools::FB::VAListArgumentProvider::VAListArgumentProvider((GPUTools::FB::VAListArgumentProvider *)v9, &a9);
  GPUTools::FB::Encode();
  GPUTools::FB::VAListArgumentProvider::~VAListArgumentProvider((GPUTools::FB::VAListArgumentProvider *)v9);
}

void sub_24112AAD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  GPUTools::FB::VAListArgumentProvider::~VAListArgumentProvider((GPUTools::FB::VAListArgumentProvider *)va);
  _Unwind_Resume(a1);
}

BOOL GPUTools::MTL::CaptureHelper::_EncodeImageBlockDataReturn(GPUTools::MTL::CaptureHelper *this, MTLRenderPipelineReflection *a2)
{
  MTLRenderPipelineReflection *v3;
  GPUTools::MTL::CaptureHelper *v4;
  GPUTools::MTL::CaptureHelper *v5;
  void *v6;
  void *v7;
  void *v8;
  _BOOL8 v9;
  void *v11;
  uint64_t v12;
  _QWORD v13[6];
  _QWORD v14[6];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;

  v3 = a2;
  -[MTLRenderPipelineReflection imageBlockDataReturn](v3, "imageBlockDataReturn");
  v4 = (GPUTools::MTL::CaptureHelper *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (!v4 || !GPUTools::MTL::CaptureHelper::_IsArgumentExplicitImageBlock(v4, (MTLArgument *)v4))
  {
    v9 = 0;
    goto LABEL_10;
  }
  -[MTLRenderPipelineReflection vertexBuiltInArguments](v3, "vertexBuiltInArguments");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v6, "count"))
    goto LABEL_6;
  -[MTLRenderPipelineReflection vertexBindings](v3, "vertexBindings");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v7, "count"))
  {

LABEL_6:
    goto LABEL_7;
  }
  -[MTLRenderPipelineReflection fragmentBindings](v3, "fragmentBindings");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = objc_msgSend(v11, "count");

  if (!v12)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v18 = 0;
    -[MTLRenderPipelineReflection tileBindings](v3, "tileBindings");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v13[0] = MEMORY[0x24BDAC760];
    v13[1] = 3221225472;
    v13[2] = ___ZN8GPUTools3MTL13CaptureHelper27_EncodeImageBlockDataReturnEP27MTLRenderPipelineReflection_block_invoke_2;
    v13[3] = &unk_251122DA8;
    v13[4] = &v15;
    v13[5] = this;
    objc_msgSend(v8, "enumerateObjectsUsingBlock:", v13);
    goto LABEL_8;
  }
LABEL_7:
  v15 = 0;
  v16 = &v15;
  v17 = 0x2020000000;
  v18 = 0;
  -[MTLRenderPipelineReflection fragmentBindings](v3, "fragmentBindings");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v14[0] = MEMORY[0x24BDAC760];
  v14[1] = 3221225472;
  v14[2] = ___ZN8GPUTools3MTL13CaptureHelper27_EncodeImageBlockDataReturnEP27MTLRenderPipelineReflection_block_invoke;
  v14[3] = &unk_251122DA8;
  v14[4] = &v15;
  v14[5] = this;
  objc_msgSend(v8, "enumerateObjectsUsingBlock:", v14);
LABEL_8:

  v9 = *((_BYTE *)v16 + 24) == 0;
  _Block_object_dispose(&v15, 8);
LABEL_10:

  return v9;
}

void sub_24112AC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  void *v15;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  int v6;
  id v7;

  v5 = a2;
  if (*(_QWORD *)(a1 + 48) - 1 == a3)
    v6 = *(_DWORD *)(a1 + 64);
  else
    v6 = 0;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v6;
  v7 = v5;
  Encode(*(char ***)(a1 + 56), v5, 102, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(void **)(a1 + 32));

}

void sub_24112AD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Encode(char **a1, void *a2, uint64_t a3, unsigned int a4, void *a5)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  char *v23;
  id v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t *v42;
  char *v43;
  _QWORD *v44;
  unint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  uint64_t *v63;
  char *v64;
  char *v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  id v70;
  void *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  void *v78;
  uint64_t *v79;
  char *v80;
  char *v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t *v89;
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  char *v100;
  char *v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  unsigned int v105;
  id v106;
  void *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  char *v113;
  char *v114;
  char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  void *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  char *v127;
  uint64_t v128;
  uint64_t v129;
  unsigned int v130;
  void *v131;
  void *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  void *v137;
  void *v138;
  unsigned int v139;
  uint64_t v140;
  id v141;
  void *v142;
  void *v143;
  id v144;
  void *v145;
  id v147;
  id v148;

  v148 = a2;
  v147 = a5;
  v7 = objc_msgSend(v148, "type");
  switch(v7)
  {
    case 0:
      if ((objc_opt_respondsToSelector() & 1) != 0)
        objc_msgSend(v148, "isVertexDescriptorBuffer");
      v40 = operator new();
      *(_QWORD *)v40 = 0;
      *(_QWORD *)(v40 + 8) = 0;
      *(_DWORD *)(v40 + 16) = 0;
      v41 = (unint64_t)a1[2];
      v42 = (uint64_t *)a1[1];
      if ((unint64_t)v42 >= v41)
      {
        v48 = ((char *)v42 - *a1) >> 3;
        if ((unint64_t)(v48 + 1) >> 61)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v49 = v41 - (_QWORD)*a1;
        v50 = v49 >> 2;
        if (v49 >> 2 <= (unint64_t)(v48 + 1))
          v50 = v48 + 1;
        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8)
          v51 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v51 = v50;
        if (v51)
          v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v51);
        else
          v52 = 0;
        v99 = (uint64_t *)&v52[8 * v48];
        v100 = &v52[8 * v51];
        *v99 = v40;
        v43 = (char *)(v99 + 1);
        v102 = *a1;
        v101 = a1[1];
        if (v101 != *a1)
        {
          do
          {
            v103 = *((_QWORD *)v101 - 1);
            v101 -= 8;
            *--v99 = v103;
          }
          while (v101 != v102);
          v101 = *a1;
        }
        *a1 = (char *)v99;
        a1[1] = v43;
        a1[2] = v100;
        if (v101)
          operator delete(v101);
      }
      else
      {
        *v42 = v40;
        v43 = (char *)(v42 + 1);
      }
      a1[1] = v43;
      v104 = *((_QWORD *)v43 - 1);
      objc_msgSend(v148, "bufferStructType");
      v143 = (void *)objc_claimAutoreleasedReturnValue();
      if (v143)
        v105 = 0;
      else
        v105 = a4;
      v139 = v105;
      objc_msgSend(v148, "name");
      v106 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v106, "UTF8String");
      objc_msgSend(v148, "access");
      objc_msgSend(v148, "isActive");
      objc_msgSend(v148, "index");
      objc_msgSend(v148, "bufferAlignment");
      objc_msgSend(v148, "bufferDataSize");
      objc_msgSend(v148, "bufferDataType");
      objc_msgSend(v148, "bufferStructType");
      v107 = (void *)objc_claimAutoreleasedReturnValue();
      GPUTools::FB::Encode(v104, 4294955024, v139, (uint64_t)"CiSululuiululululbb", v108, v109, v110, v111, (char)v147);

      objc_msgSend(v148, "bufferStructType");
      v112 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v112)
        goto LABEL_132;
      objc_msgSend(v148, "bufferStructType");
      v24 = (id)objc_claimAutoreleasedReturnValue();
      Encode(a1, v24, a4, v147, 0);
      goto LABEL_131;
    case 1:
      if ((objc_opt_respondsToSelector() & 1) != 0)
      {
        objc_msgSend(v148, "dataTypeDescription");
        v24 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v24 = 0;
      }
      v44 = (_QWORD *)operator new();
      *v44 = 0;
      v44[1] = 0;
      *((_DWORD *)v44 + 4) = 0;
      v45 = (unint64_t)a1[2];
      v46 = a1[1];
      if ((unint64_t)v46 >= v45)
      {
        v53 = (v46 - *a1) >> 3;
        if ((unint64_t)(v53 + 1) >> 61)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v54 = v45 - (_QWORD)*a1;
        v55 = v54 >> 2;
        if (v54 >> 2 <= (unint64_t)(v53 + 1))
          v55 = v53 + 1;
        if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
          v56 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v56 = v55;
        if (v56)
          v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v56);
        else
          v57 = 0;
        v113 = &v57[8 * v53];
        v114 = &v57[8 * v56];
        *(_QWORD *)v113 = v44;
        v47 = v113 + 8;
        v116 = *a1;
        v115 = a1[1];
        if (v115 != *a1)
        {
          do
          {
            v117 = *((_QWORD *)v115 - 1);
            v115 -= 8;
            *((_QWORD *)v113 - 1) = v117;
            v113 -= 8;
          }
          while (v115 != v116);
          v115 = *a1;
        }
        *a1 = v113;
        a1[1] = v47;
        a1[2] = v114;
        if (v115)
          operator delete(v115);
      }
      else
      {
        *(_QWORD *)v46 = v44;
        v47 = v46 + 8;
      }
      a1[1] = v47;
      v140 = *((_QWORD *)v47 - 1);
      objc_msgSend(v148, "name");
      v144 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v144, "UTF8String");
      objc_msgSend(v148, "access");
      objc_msgSend(v148, "isActive");
      objc_msgSend(v148, "index");
      objc_msgSend(v148, "threadgroupMemoryAlignment");
      objc_msgSend(v148, "threadgroupMemoryDataSize");
      if (v24)
      {
        objc_msgSend(v24, "elementType");
        objc_msgSend(v24, "dataSize");
        objc_msgSend(v24, "elementTypeDescription");
        v44 = (_QWORD *)objc_claimAutoreleasedReturnValue();
      }
      GPUTools::FB::Encode(v140, 4294955024, a4, (uint64_t)"CiSululuiulululululb", v118, v119, v120, v121, (char)v147);
      if (v24)

      objc_msgSend(v24, "elementTypeDescription");
      v122 = (void *)objc_claimAutoreleasedReturnValue();

      if (v122)
      {
        objc_msgSend(v24, "elementTypeDescription");
        v123 = (void *)objc_claimAutoreleasedReturnValue();
        Encode(a1, v123, a4, v147, 0);

      }
      goto LABEL_131;
    case 2:
      v16 = operator new();
      *(_QWORD *)v16 = 0;
      *(_QWORD *)(v16 + 8) = 0;
      *(_DWORD *)(v16 + 16) = 0;
      v17 = (unint64_t)a1[2];
      v18 = (uint64_t *)a1[1];
      if ((unint64_t)v18 < v17)
      {
        *v18 = v16;
        v19 = (char *)(v18 + 1);
LABEL_88:
        a1[1] = v19;
        v84 = *((_QWORD *)v19 - 1);
        objc_msgSend(v148, "name");
        v24 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        objc_msgSend(v24, "UTF8String");
        objc_msgSend(v148, "access");
        objc_msgSend(v148, "isActive");
        objc_msgSend(v148, "index");
        objc_msgSend(v148, "textureDataType");
        objc_msgSend(v148, "textureType");
        GPUTools::FB::Encode(v84, 4294955024, a4, (uint64_t)"CiSululuiululul", v85, v86, v87, v88, (char)v147);
        goto LABEL_131;
      }
      v30 = ((char *)v18 - *a1) >> 3;
      if (!((unint64_t)(v30 + 1) >> 61))
      {
        v31 = v17 - (_QWORD)*a1;
        v32 = v31 >> 2;
        if (v31 >> 2 <= (unint64_t)(v30 + 1))
          v32 = v30 + 1;
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
          v33 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v33 = v32;
        if (v33)
          v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v33);
        else
          v34 = 0;
        v79 = (uint64_t *)&v34[8 * v30];
        v80 = &v34[8 * v33];
        *v79 = v16;
        v19 = (char *)(v79 + 1);
        v82 = *a1;
        v81 = a1[1];
        if (v81 != *a1)
        {
          do
          {
            v83 = *((_QWORD *)v81 - 1);
            v81 -= 8;
            *--v79 = v83;
          }
          while (v81 != v82);
          v81 = *a1;
        }
        *a1 = (char *)v79;
        a1[1] = v19;
        a1[2] = v80;
        if (v81)
          operator delete(v81);
        goto LABEL_88;
      }
      goto LABEL_133;
    case 3:
      v20 = operator new();
      *(_QWORD *)v20 = 0;
      *(_QWORD *)(v20 + 8) = 0;
      *(_DWORD *)(v20 + 16) = 0;
      v21 = (unint64_t)a1[2];
      v22 = (uint64_t *)a1[1];
      if ((unint64_t)v22 < v21)
      {
        *v22 = v20;
        v23 = (char *)(v22 + 1);
LABEL_95:
        a1[1] = v23;
        v94 = *((_QWORD *)v23 - 1);
        objc_msgSend(v148, "name");
        v24 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        objc_msgSend(v24, "UTF8String");
        objc_msgSend(v148, "access");
        objc_msgSend(v148, "isActive");
        objc_msgSend(v148, "index");
        GPUTools::FB::Encode(v94, 4294955024, a4, (uint64_t)"CiSululuiul", v95, v96, v97, v98, (char)v147);
        goto LABEL_131;
      }
      v35 = ((char *)v22 - *a1) >> 3;
      if (!((unint64_t)(v35 + 1) >> 61))
      {
        v36 = v21 - (_QWORD)*a1;
        v37 = v36 >> 2;
        if (v36 >> 2 <= (unint64_t)(v35 + 1))
          v37 = v35 + 1;
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
          v38 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v38 = v37;
        if (v38)
          v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v38);
        else
          v39 = 0;
        v89 = (uint64_t *)&v39[8 * v35];
        v90 = &v39[8 * v38];
        *v89 = v20;
        v23 = (char *)(v89 + 1);
        v92 = *a1;
        v91 = a1[1];
        if (v91 != *a1)
        {
          do
          {
            v93 = *((_QWORD *)v91 - 1);
            v91 -= 8;
            *--v89 = v93;
          }
          while (v91 != v92);
          v91 = *a1;
        }
        *a1 = (char *)v89;
        a1[1] = v23;
        a1[2] = v90;
        if (v91)
          operator delete(v91);
        goto LABEL_95;
      }
      goto LABEL_133;
    default:
      if (v7 != 16)
      {
        if (v7 != 17 || !objc_msgSend(v148, "imageBlockKind"))
          goto LABEL_132;
        v8 = operator new();
        *(_QWORD *)v8 = 0;
        *(_QWORD *)(v8 + 8) = 0;
        *(_DWORD *)(v8 + 16) = 0;
        v9 = (unint64_t)a1[2];
        v10 = (uint64_t *)a1[1];
        if ((unint64_t)v10 < v9)
        {
          *v10 = v8;
          v11 = (char *)(v10 + 1);
          goto LABEL_125;
        }
        v58 = ((char *)v10 - *a1) >> 3;
        if (!((unint64_t)(v58 + 1) >> 61))
        {
          v59 = v9 - (_QWORD)*a1;
          v60 = v59 >> 2;
          if (v59 >> 2 <= (unint64_t)(v58 + 1))
            v60 = v58 + 1;
          if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
            v61 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v61 = v60;
          if (v61)
            v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v61);
          else
            v62 = 0;
          v124 = (uint64_t *)&v62[8 * v58];
          v125 = &v62[8 * v61];
          *v124 = v8;
          v11 = (char *)(v124 + 1);
          v127 = *a1;
          v126 = a1[1];
          if (v126 != *a1)
          {
            do
            {
              v128 = *((_QWORD *)v126 - 1);
              v126 -= 8;
              *--v124 = v128;
            }
            while (v126 != v127);
            v126 = *a1;
          }
          *a1 = (char *)v124;
          a1[1] = v11;
          a1[2] = v125;
          if (v126)
            operator delete(v126);
LABEL_125:
          a1[1] = v11;
          v129 = *((_QWORD *)v11 - 1);
          objc_msgSend(v148, "dataTypeDescription");
          v145 = (void *)objc_claimAutoreleasedReturnValue();
          if (v145)
            v130 = 0;
          else
            v130 = a4;
          objc_msgSend(v148, "name");
          v141 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          objc_msgSend(v141, "UTF8String");
          objc_msgSend(v148, "access");
          objc_msgSend(v148, "isActive");
          objc_msgSend(v148, "index");
          objc_msgSend(v148, "dataTypeDescription");
          v131 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v148, "imageBlockKind");
          objc_msgSend(v148, "imageBlockDataSize");
          objc_msgSend(v148, "imageBlockMasterStructMembers");
          v132 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v148, "aliasImplicitImageBlock");
          objc_msgSend(v148, "aliasImplicitImageBlockRenderTarget");
          GPUTools::FB::Encode(v129, 4294955024, v130, (uint64_t)"CiSululuiulbululbbul", v133, v134, v135, v136, (char)v147);

          objc_msgSend(v148, "dataTypeDescription");
          v137 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v137)
          {
            objc_msgSend(v148, "imageBlockMasterStructMembers");
            v138 = (void *)objc_claimAutoreleasedReturnValue();

            if (v138)
            {
LABEL_130:
              objc_msgSend(v148, "imageBlockMasterStructMembers");
              v24 = (id)objc_claimAutoreleasedReturnValue();
              Encode(a1, v24, a4, v147, 1);
              goto LABEL_131;
            }
            goto LABEL_132;
          }
LABEL_81:
          objc_msgSend(v148, "dataTypeDescription");
          v24 = (id)objc_claimAutoreleasedReturnValue();
          Encode(a1, v24, a4, v147, 1);
LABEL_131:

          goto LABEL_132;
        }
LABEL_133:
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      v12 = operator new();
      *(_QWORD *)v12 = 0;
      *(_QWORD *)(v12 + 8) = 0;
      *(_DWORD *)(v12 + 16) = 0;
      v13 = (unint64_t)a1[2];
      v14 = (uint64_t *)a1[1];
      if ((unint64_t)v14 >= v13)
      {
        v25 = ((char *)v14 - *a1) >> 3;
        if ((unint64_t)(v25 + 1) >> 61)
          goto LABEL_133;
        v26 = v13 - (_QWORD)*a1;
        v27 = v26 >> 2;
        if (v26 >> 2 <= (unint64_t)(v25 + 1))
          v27 = v25 + 1;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
          v28 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v28 = v27;
        if (v28)
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v28);
        else
          v29 = 0;
        v63 = (uint64_t *)&v29[8 * v25];
        v64 = &v29[8 * v28];
        *v63 = v12;
        v15 = (char *)(v63 + 1);
        v66 = *a1;
        v65 = a1[1];
        if (v65 != *a1)
        {
          do
          {
            v67 = *((_QWORD *)v65 - 1);
            v65 -= 8;
            *--v63 = v67;
          }
          while (v65 != v66);
          v65 = *a1;
        }
        *a1 = (char *)v63;
        a1[1] = v15;
        a1[2] = v64;
        if (v65)
          operator delete(v65);
      }
      else
      {
        *v14 = v12;
        v15 = (char *)(v14 + 1);
      }
      a1[1] = v15;
      v68 = *((_QWORD *)v15 - 1);
      objc_msgSend(v148, "imageBlockMasterStructMembers");
      v142 = (void *)objc_claimAutoreleasedReturnValue();
      if (v142)
        v69 = 0;
      else
        v69 = a4;
      objc_msgSend(v148, "name");
      v70 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      objc_msgSend(v70, "UTF8String");
      objc_msgSend(v148, "access");
      objc_msgSend(v148, "isActive");
      objc_msgSend(v148, "index");
      objc_msgSend(v148, "dataTypeDescription");
      v71 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v148, "imageBlockDataSize");
      objc_msgSend(v148, "imageBlockMasterStructMembers");
      v72 = (void *)objc_claimAutoreleasedReturnValue();
      GPUTools::FB::Encode(v68, 4294955024, v69, (uint64_t)"CiSululuiulbulb", v73, v74, v75, v76, (char)v147);

      objc_msgSend(v148, "imageBlockMasterStructMembers");
      v77 = (void *)objc_claimAutoreleasedReturnValue();

      if (v77)
        goto LABEL_130;
      objc_msgSend(v148, "dataTypeDescription");
      v78 = (void *)objc_claimAutoreleasedReturnValue();

      if (v78)
        goto LABEL_81;
LABEL_132:

      return;
  }
}

void sub_24112BA44(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Unwind_Resume(a1);
}

void ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  int v6;
  id v7;

  v5 = a2;
  if (*(_QWORD *)(a1 + 48) - 1 == a3)
    v6 = *(_DWORD *)(a1 + 64);
  else
    v6 = 0;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v6;
  v7 = v5;
  Encode(*(char ***)(a1 + 56), v5, 103, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(void **)(a1 + 32));

}

void sub_24112BBAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke_3(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  int v6;
  id v7;

  v5 = a2;
  if (*(_QWORD *)(a1 + 48) - 1 == a3)
    v6 = *(_DWORD *)(a1 + 64);
  else
    v6 = 0;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v6;
  v7 = v5;
  Encode(*(char ***)(a1 + 56), v5, 104, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(void **)(a1 + 32));

}

void sub_24112BC38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZN8GPUTools3MTL13CaptureHelper36EncodeChainedRenderPipelineStateInfoEPNSt3__16vectorIPNS_2FB4FbufENS2_9allocatorIS6_EEEEPU33objcproto22MTLRenderPipelineState11objc_objectP27MTLRenderPipelineReflectionP18DYTransportMessage_block_invoke_4(uint64_t a1, void *a2, uint64_t a3)
{
  int v5;
  GPUTools::MTL::CaptureHelper *v6;
  GPUTools::MTL::CaptureHelper *v7;
  _BOOL4 IsArgumentExplicitImageBlock;
  char **v9;
  void *v10;
  MTLArgument *v11;

  v11 = a2;
  if (*(_QWORD *)(a1 + 64) - 1 == a3)
    v5 = *(_DWORD *)(a1 + 80);
  else
    v5 = 0;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v5;
  objc_msgSend(*(id *)(a1 + 32), "imageBlockDataReturn");
  v6 = (GPUTools::MTL::CaptureHelper *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (v6
    && (IsArgumentExplicitImageBlock = GPUTools::MTL::CaptureHelper::_IsArgumentExplicitImageBlock(v6, v11),
        v7,
        IsArgumentExplicitImageBlock))
  {
    v9 = *(char ***)(a1 + 72);
    objc_msgSend(*(id *)(a1 + 32), "imageBlockDataReturn");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    Encode(v9, v10, 121, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), *(void **)(a1 + 40));

  }
  else
  {
    Encode(*(char ***)(a1 + 72), v11, 121, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), *(void **)(a1 + 40));
  }

}

void sub_24112BD2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL GPUTools::MTL::CaptureHelper::_IsArgumentExplicitImageBlock(GPUTools::MTL::CaptureHelper *this, MTLArgument *a2)
{
  MTLArgument *v2;
  uint64_t v3;
  _BOOL8 v4;

  v2 = a2;
  v3 = -[MTLArgument type](v2, "type");
  if (v3 == 16)
    v4 = 1;
  else
    v4 = v3 == 17 && -[MTLArgument imageBlockKind](v2, "imageBlockKind") == 1;

  return v4;
}

void sub_24112BDAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL ___ZN8GPUTools3MTL13CaptureHelper27_EncodeImageBlockDataReturnEP27MTLRenderPipelineReflection_block_invoke(GPUTools::MTL::CaptureHelper *a1, MTLArgument *a2)
{
  _BOOL8 result;

  result = GPUTools::MTL::CaptureHelper::_IsArgumentExplicitImageBlock(a1, a2);
  if (result)
    *(_BYTE *)(*(_QWORD *)(*((_QWORD *)a1 + 4) + 8) + 24) = 1;
  return result;
}

BOOL ___ZN8GPUTools3MTL13CaptureHelper27_EncodeImageBlockDataReturnEP27MTLRenderPipelineReflection_block_invoke_2(GPUTools::MTL::CaptureHelper *a1, MTLArgument *a2)
{
  _BOOL8 result;

  result = GPUTools::MTL::CaptureHelper::_IsArgumentExplicitImageBlock(a1, a2);
  if (result)
    *(_BYTE *)(*(_QWORD *)(*((_QWORD *)a1 + 4) + 8) + 24) = 1;
  return result;
}

uint64_t GPUTools::MTL::CaptureHelper::SaveObject(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  NSObject *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD v16[5];

  v7 = a3;
  v8 = *(id *)(a1 + 136);
  dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1)
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  GPUTools::DynamicBuffer::Append<unsigned int>((unint64_t *)a1, &GPUTools::MTL::kMTLCaptureVersion);
  v9 = *(_QWORD *)a1;
  v10 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v10 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v10 + v9 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v9 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v9 + v10) = a2;
  v11 = objc_msgSend(v7, "count");
  v12 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v13 > 0xFFFFFFFFFFFFFFF7)
  {
    *(_QWORD *)(a1 + 8) = v13 + v12 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)a1, 8uLL);
    v12 = *(_QWORD *)a1;
  }
  *(_QWORD *)(v12 + v13) = v11;
  v16[0] = MEMORY[0x24BDAC760];
  v16[1] = 3221225472;
  v16[2] = ___ZN8GPUTools3MTL13CaptureHelper10SaveObjectEmP7NSArrayIP23MTLPostVertexDumpOutputEPv_block_invoke;
  v16[3] = &__block_descriptor_40_e40_v32__0__MTLPostVertexDumpOutput_8Q16_B24l;
  v16[4] = a1;
  objc_msgSend(v7, "enumerateObjectsUsingBlock:", v16);
  memcpy(a4, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v14 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  dispatch_semaphore_signal(v8);

  return v14;
}

void sub_24112BF78(_Unwind_Exception *a1)
{
  void *v1;
  NSObject *v2;

  dispatch_semaphore_signal(v2);

  _Unwind_Resume(a1);
}

void ___ZN8GPUTools3MTL13CaptureHelper10SaveObjectEmP7NSArrayIP23MTLPostVertexDumpOutputEPv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  GPUTools::DynamicBuffer *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  id v13;

  v3 = a2;
  v4 = *(GPUTools::DynamicBuffer **)(a1 + 32);
  v13 = v3;
  objc_msgSend(v3, "airMDType");
  v5 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append(v4, (const char *)objc_msgSend(v5, "UTF8String"));

  v6 = objc_msgSend(v13, "dataType");
  v7 = *(_QWORD *)v4;
  v8 = *((_QWORD *)v4 + 1) - *(_QWORD *)v4;
  if (v8 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)v4 + 1) = v8 + v7 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)v4, 8uLL);
    v7 = *(_QWORD *)v4;
  }
  *(_QWORD *)(v7 + v8) = v6;
  objc_msgSend(v13, "name");
  v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  GPUTools::DynamicBuffer::Append(v4, (const char *)objc_msgSend(v9, "UTF8String"));

  v10 = objc_msgSend(v13, "offset");
  v11 = *(_QWORD *)v4;
  v12 = *((_QWORD *)v4 + 1) - *(_QWORD *)v4;
  if (v12 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)v4 + 1) = v12 + v11 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)v4, 8uLL);
    v11 = *(_QWORD *)v4;
  }
  *(_QWORD *)(v11 + v12) = v10;

}

void sub_24112C0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

_QWORD *GPUTools::MTL::CaptureHelper::SaveFileContents(GPUTools::MTL::CaptureHelper *this, NSString *a2, uint64_t a3)
{
  id v5;
  _QWORD *v6;

  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithContentsOfFile:", a2);
  v5 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v6 = GPUTools::MTL::CaptureHelper::SaveClientMemory((uint64_t)this, objc_msgSend(v5, "bytes"), objc_msgSend(v5, "length"), a3, 0);

  return v6;
}

void sub_24112C148(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

void GPUTools::DynamicBuffer::Append(GPUTools::DynamicBuffer *this, const void *a2, size_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;

  v6 = *(_QWORD *)this;
  v7 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v7 > 0xFFFFFFFFFFFFFFF7)
  {
    *((_QWORD *)this + 1) = v7 + v6 + 8;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this, 8uLL);
    v6 = *(_QWORD *)this;
  }
  *(_QWORD *)(v6 + v7) = a3;
  if (a3)
  {
    v8 = *(_QWORD *)this;
    v9 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    v10 = (a3 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (v9 >= v9 + v10)
    {
      if (v9 > v9 + v10)
        *((_QWORD *)this + 1) = v8 + v9 + v10;
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this, v10);
      v8 = *(_QWORD *)this;
    }
    memcpy((void *)(v8 + v9), a2, a3);
  }
}

void Encode(char **a1, void *a2, unsigned int a3, void *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t *v44;
  char *v45;
  char *v46;
  uint64_t v47;
  uint64_t **v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  id v52;
  void *v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  id v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t *v70;
  char *v71;
  char *v72;
  uint64_t v73;
  uint64_t **v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  BOOL v83;
  void *v84;
  void *v85;
  uint64_t v86;
  void *v87;
  BOOL v88;
  void *v89;
  void *v90;
  uint64_t v91;
  id obj;
  void *v93;
  uint64_t v94;
  id v96;
  uint64_t v97;
  id v98;
  unsigned int v99;
  uint64_t i;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  _BYTE v107[128];
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  v96 = a2;
  v98 = a4;
  v6 = operator new();
  v7 = v6;
  *(_QWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 16) = 0;
  v8 = (unint64_t)a1[2];
  v91 = (uint64_t)(a1 + 2);
  v9 = (uint64_t *)a1[1];
  if ((unint64_t)v9 >= v8)
  {
    v11 = ((char *)v9 - *a1) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v12 = v8 - (_QWORD)*a1;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v91, v14);
    else
      v15 = 0;
    v16 = (uint64_t *)&v15[8 * v11];
    v17 = &v15[8 * v14];
    *v16 = v7;
    v10 = v16 + 1;
    v19 = *a1;
    v18 = a1[1];
    if (v18 == *a1)
    {
      v21 = (uint64_t **)a1;
    }
    else
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *--v16 = v20;
      }
      while (v18 != v19);
      v21 = (uint64_t **)a1;
      v18 = *a1;
    }
    *v21 = v16;
    v21[1] = v10;
    v21[2] = (uint64_t *)v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v9 = v6;
    v10 = v9 + 1;
  }
  a1[1] = (char *)v10;
  v22 = *(v10 - 1);
  objc_msgSend(v96, "members");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v23, "count"))
    v24 = 0;
  else
    v24 = a3;
  objc_msgSend(v96, "members");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v25, "count");
  GPUTools::FB::Encode(v22, 4294955024, v24, (uint64_t)"Ci", v26, v27, v28, v29, (char)v98);

  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  objc_msgSend(v96, "members");
  obj = (id)objc_claimAutoreleasedReturnValue();
  v97 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v103, v107, 16);
  if (v97)
  {
    v94 = *(_QWORD *)v104;
    do
    {
      for (i = 0; i != v97; ++i)
      {
        if (*(_QWORD *)v104 != v94)
          objc_enumerationMutation(obj);
        v30 = *(void **)(*((_QWORD *)&v103 + 1) + 8 * i);
        objc_msgSend(v96, "members");
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v31, "lastObject");
        v32 = (void *)objc_claimAutoreleasedReturnValue();
        v33 = a3;
        if (v30 != v32)
          v33 = 0;
        v99 = v33;

        if ((objc_opt_respondsToSelector() & 1) != 0)
          objc_msgSend(v30, "indirectArgumentIndex");
        v34 = operator new();
        v35 = v34;
        *(_QWORD *)v34 = 0;
        *(_QWORD *)(v34 + 8) = 0;
        *(_DWORD *)(v34 + 16) = 0;
        v37 = (uint64_t *)a1[1];
        v36 = (unint64_t)a1[2];
        if ((unint64_t)v37 >= v36)
        {
          v39 = ((char *)v37 - *a1) >> 3;
          if ((unint64_t)(v39 + 1) >> 61)
            std::vector<float>::__throw_length_error[abi:ne180100]();
          v40 = v36 - (_QWORD)*a1;
          v41 = v40 >> 2;
          if (v40 >> 2 <= (unint64_t)(v39 + 1))
            v41 = v39 + 1;
          if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8)
            v42 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v42 = v41;
          if (v42)
            v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v91, v42);
          else
            v43 = 0;
          v44 = (uint64_t *)&v43[8 * v39];
          *v44 = v35;
          v38 = v44 + 1;
          v46 = *a1;
          v45 = a1[1];
          if (v45 == *a1)
          {
            v48 = (uint64_t **)a1;
          }
          else
          {
            do
            {
              v47 = *((_QWORD *)v45 - 1);
              v45 -= 8;
              *--v44 = v47;
            }
            while (v45 != v46);
            v48 = (uint64_t **)a1;
            v45 = *a1;
          }
          *v48 = v44;
          v48[1] = v38;
          v48[2] = (uint64_t *)&v43[8 * v42];
          if (v45)
            operator delete(v45);
        }
        else
        {
          *v37 = v34;
          v38 = v37 + 1;
        }
        a1[1] = (char *)v38;
        v49 = *(v38 - 1);
        objc_msgSend(v30, "structType");
        v50 = (void *)objc_claimAutoreleasedReturnValue();
        if (v50)
        {
          v51 = 0;
        }
        else
        {
          objc_msgSend(v30, "arrayType");
          v93 = (void *)objc_claimAutoreleasedReturnValue();
          if (v93)
            v51 = 0;
          else
            v51 = v99;
        }
        objc_msgSend(v30, "dataType");
        objc_msgSend(v30, "name");
        v52 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        objc_msgSend(v52, "UTF8String");
        objc_msgSend(v30, "offset");
        objc_msgSend(v30, "structType");
        v53 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v30, "arrayType");
        v54 = (void *)objc_claimAutoreleasedReturnValue();
        GPUTools::FB::Encode(v49, 4294955024, v51, (uint64_t)"CiSulbbulb", v55, v56, v57, v58, (char)v98);

        if (!v50)
        if ((_DWORD)a5)
        {
          v59 = v30;
          v60 = operator new();
          v61 = v60;
          *(_QWORD *)v60 = 0;
          *(_QWORD *)(v60 + 8) = 0;
          *(_DWORD *)(v60 + 16) = 0;
          v63 = (uint64_t *)a1[1];
          v62 = (unint64_t)a1[2];
          if ((unint64_t)v63 >= v62)
          {
            v65 = ((char *)v63 - *a1) >> 3;
            if ((unint64_t)(v65 + 1) >> 61)
              std::vector<float>::__throw_length_error[abi:ne180100]();
            v66 = v62 - (_QWORD)*a1;
            v67 = v66 >> 2;
            if (v66 >> 2 <= (unint64_t)(v65 + 1))
              v67 = v65 + 1;
            if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8)
              v68 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v68 = v67;
            if (v68)
              v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v91, v68);
            else
              v69 = 0;
            v70 = (uint64_t *)&v69[8 * v65];
            *v70 = v61;
            v64 = v70 + 1;
            v72 = *a1;
            v71 = a1[1];
            if (v71 == *a1)
            {
              v74 = (uint64_t **)a1;
            }
            else
            {
              do
              {
                v73 = *((_QWORD *)v71 - 1);
                v71 -= 8;
                *--v70 = v73;
              }
              while (v71 != v72);
              v74 = (uint64_t **)a1;
              v71 = *a1;
            }
            *v74 = v70;
            v74[1] = v64;
            v74[2] = (uint64_t *)&v69[8 * v68];
            if (v71)
              operator delete(v71);
          }
          else
          {
            *v63 = v60;
            v64 = v63 + 1;
          }
          a1[1] = (char *)v64;
          v75 = *(v64 - 1);
          objc_msgSend(v59, "structType");
          v76 = (void *)objc_claimAutoreleasedReturnValue();
          if (v76)
          {
            v77 = 0;
          }
          else
          {
            objc_msgSend(v59, "arrayType");
            v90 = (void *)objc_claimAutoreleasedReturnValue();
            if (v90)
              v77 = 0;
            else
              v77 = v99;
          }
          objc_msgSend(v59, "pixelFormat");
          objc_msgSend(v59, "aluType");
          GPUTools::FB::Encode(v75, 4294955024, v77, (uint64_t)"Culul", v78, v79, v80, v81, (char)v98);
          if (!v76)

        }
        objc_msgSend(v30, "structType");
        v82 = (void *)objc_claimAutoreleasedReturnValue();
        v83 = v82 == 0;

        if (!v83)
        {
          objc_msgSend(v30, "structType");
          v84 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v30, "arrayType");
          v85 = (void *)objc_claimAutoreleasedReturnValue();
          if (v85)
            v86 = 0;
          else
            v86 = v99;
          Encode(a1, v84, v86, v98, a5);

        }
        objc_msgSend(v30, "arrayType");
        v87 = (void *)objc_claimAutoreleasedReturnValue();
        v88 = v87 == 0;

        if (!v88)
        {
          objc_msgSend(v30, "arrayType");
          v89 = (void *)objc_claimAutoreleasedReturnValue();
          Encode((void **)a1, v89, v99, v98, a5);

        }
      }
      v97 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v103, v107, 16);
    }
    while (v97);
  }

}

void sub_24112CC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{

  _Unwind_Resume(a1);
}

void Encode(void **a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  void **v10;
  unint64_t v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  uint64_t v36;
  void *v37;
  void **v38;
  unint64_t v39;
  uint64_t *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  void *v64;
  void *v65;
  id v66;
  id v68;

  v68 = a2;
  v66 = a4;
  if ((objc_opt_respondsToSelector() & 1) != 0)
    objc_msgSend(v68, "argumentIndexStride");
  v8 = operator new();
  v9 = v8;
  *(_QWORD *)v8 = 0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_DWORD *)(v8 + 16) = 0;
  v10 = a1;
  v11 = (unint64_t)a1[2];
  v12 = (uint64_t *)a1[1];
  if ((unint64_t)v12 >= v11)
  {
    v14 = ((char *)v12 - (_BYTE *)*a1) >> 3;
    if ((unint64_t)(v14 + 1) >> 61)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v15 = v11 - (_QWORD)*a1;
    v16 = v15 >> 2;
    if (v15 >> 2 <= (unint64_t)(v14 + 1))
      v16 = v14 + 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
    {
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v17);
      v10 = a1;
    }
    else
    {
      v18 = 0;
    }
    v19 = (uint64_t *)&v18[8 * v14];
    v20 = &v18[8 * v17];
    *v19 = v9;
    v13 = v19 + 1;
    v22 = (char *)*v10;
    v21 = (char *)v10[1];
    if (v21 != *v10)
    {
      do
      {
        v23 = *((_QWORD *)v21 - 1);
        v21 -= 8;
        *--v19 = v23;
      }
      while (v21 != v22);
      v21 = (char *)*v10;
    }
    *v10 = v19;
    v10[1] = v13;
    v10[2] = v20;
    if (v21)
      operator delete(v21);
  }
  else
  {
    *v12 = v8;
    v13 = v12 + 1;
  }
  v10[1] = v13;
  v24 = *(v13 - 1);
  objc_msgSend(v68, "elementStructType");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  if (v25)
  {
    v26 = a3;
    v27 = 0;
  }
  else
  {
    objc_msgSend(v68, "elementArrayType");
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = a3;
    if (v65)
      v27 = 0;
    else
      v27 = a3;
  }
  objc_msgSend(v68, "arrayLength");
  objc_msgSend(v68, "elementType");
  objc_msgSend(v68, "stride");
  objc_msgSend(v68, "elementStructType");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v68, "elementArrayType");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  GPUTools::FB::Encode(v24, 4294955024, v27, (uint64_t)"Ciululbbbul", v30, v31, v32, v33, (char)v66);

  v34 = v26;
  if (!v25)

  if ((_DWORD)a5)
  {
    v35 = v68;
    v36 = operator new();
    v37 = (void *)v36;
    *(_QWORD *)v36 = 0;
    *(_QWORD *)(v36 + 8) = 0;
    *(_DWORD *)(v36 + 16) = 0;
    v38 = a1;
    v40 = (uint64_t *)a1[1];
    v39 = (unint64_t)a1[2];
    if ((unint64_t)v40 >= v39)
    {
      v42 = ((char *)v40 - (_BYTE *)*a1) >> 3;
      if ((unint64_t)(v42 + 1) >> 61)
        std::vector<float>::__throw_length_error[abi:ne180100]();
      v43 = v39 - (_QWORD)*a1;
      v44 = v43 >> 2;
      if (v43 >> 2 <= (unint64_t)(v42 + 1))
        v44 = v42 + 1;
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
        v45 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v45 = v44;
      if (v45)
      {
        v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), v45);
        v38 = a1;
      }
      else
      {
        v46 = 0;
      }
      v47 = &v46[8 * v42];
      v48 = &v46[8 * v45];
      *(_QWORD *)v47 = v37;
      v41 = v47 + 8;
      v50 = (char *)*v38;
      v49 = (char *)v38[1];
      if (v49 != *v38)
      {
        do
        {
          v51 = *((_QWORD *)v49 - 1);
          v49 -= 8;
          *((_QWORD *)v47 - 1) = v51;
          v47 -= 8;
        }
        while (v49 != v50);
        v49 = (char *)*v38;
      }
      *v38 = v47;
      v38[1] = v41;
      v38[2] = v48;
      if (v49)
        operator delete(v49);
    }
    else
    {
      *v40 = v36;
      v41 = v40 + 1;
    }
    v38[1] = v41;
    v52 = *(v41 - 1);
    objc_msgSend(v35, "elementStructType");
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    if (v53)
    {
      v54 = 0;
    }
    else
    {
      objc_msgSend(v35, "elementArrayType");
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      if (v37)
        v54 = 0;
      else
        v54 = v34;
    }
    objc_msgSend(v35, "pixelFormat");
    objc_msgSend(v35, "aluType");
    GPUTools::FB::Encode(v52, 4294955024, v54, (uint64_t)"Culul", v55, v56, v57, v58, (char)v66);
    if (!v53)

  }
  objc_msgSend(v68, "elementStructType");
  v59 = (void *)objc_claimAutoreleasedReturnValue();

  if (v59)
  {
    objc_msgSend(v68, "elementStructType");
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v68, "elementArrayType");
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    if (v61)
      v62 = 0;
    else
      v62 = v34;
    Encode(a1, v60, v62, v66, a5);

  }
  objc_msgSend(v68, "elementArrayType");
  v63 = (void *)objc_claimAutoreleasedReturnValue();

  if (v63)
  {
    objc_msgSend(v68, "elementArrayType");
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    Encode(a1, v64, v34, v66, a5);

  }
}

void sub_24112D1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;
  uint64_t v22;

  _Unwind_Resume(a1);
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

_QWORD *std::vector<MTLSamplePosition>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MTLSamplePosition>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_24112D340(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MTLSamplePosition>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<float>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void DYInterposeArchiveFlushStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  void *v11;
  id v12;

  v12 = a1;
  if (!streams)
  {
    v7 = objc_opt_new();
    v8 = (void *)streams;
    streams = v7;

  }
  v9 = *(id *)(a2 + 32);
  objc_msgSend((id)streams, "objectForKey:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  if (v10)
  {
    objc_msgSend((id)streams, "objectForKeyedSubscript:", v9);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "appendBytes:length:", a3, a4);
  }
  else
  {
    v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCEC8]), "initWithBytes:length:", a3, a4);
    objc_msgSend((id)streams, "setObject:forKeyedSubscript:", v11, v9);
  }

}

void sub_24112D488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void DYInterposeArchiveStorePointer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  void *v7;
  void *v8;
  id v9;

  v9 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDBCE50]), "initWithBytesNoCopy:length:freeWhenDone:", a4, a5, 0);
  DYGetMTLGuestAppClient();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "localActiveArchive");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", a3);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "addFileWithName:data:options:error:waitUntilDone:", v8, v9, 0, 0, 1);

}

void sub_24112D568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

void DYInterposeArchiveFlush(void)
{
  void *v0;

  if (streams)
  {
    objc_msgSend((id)streams, "removeObjectForKey:", *MEMORY[0x24BE393C8]);
    objc_msgSend((id)streams, "enumerateKeysAndObjectsUsingBlock:", &__block_literal_global_1);
    v0 = (void *)streams;
    streams = 0;

  }
}

void ___Z23DYInterposeArchiveFlushv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  id v7;

  v7 = a2;
  v4 = a3;
  DYGetMTLGuestAppClient();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "localActiveArchive");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "addFileWithName:data:options:error:waitUntilDone:", v7, v4, 0, 0, 1);

}

void sub_24112D678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

uint64_t DYDerivedCounterInfo::DYDerivedCounterInfo(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  uint64_t v8;
  id v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id obj;
  id v31;
  uint64_t v32;
  uint64_t v33;
  id v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  id *location;
  id v40;
  id v41;
  uint64_t v42;
  id v43;
  id v44;
  void *__p[2];
  char v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _BYTE v63[128];
  _BYTE v64[128];
  _BYTE v65[128];
  _BYTE v66[128];
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v7 = a2;
  v43 = a3;
  v40 = a4;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 1065353216;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 1065353216;
  *(_OWORD *)(a1 + 160) = 0u;
  location = (id *)(a1 + 160);
  v8 = a1 + 168;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = 1065353216;
  v9 = v7;
  v37 = a1;
  *(_QWORD *)(a1 + 208) = v9;
  v38 = v9;
  v36 = *MEMORY[0x24BE39388];
  objc_msgSend(v9, "objectForKeyedSubscript:");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = (void *)objc_msgSend(v10, "mutableCopy");

  if (v40 && (objc_msgSend(v40, "containsString:", CFSTR("AGX")) & 1) == 0)
  {
    objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("Instruments"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    if (v12)
    {
      v34 = v12;
      objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("Profiles"));
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      if (v35)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          objc_msgSend(v35, "allKeys");
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          v14 = v13;
          if (v13)
          {
            v61 = 0u;
            v62 = 0u;
            v59 = 0u;
            v60 = 0u;
            obj = v13;
            v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v59, v66, 16);
            if (v15)
            {
              v32 = *(_QWORD *)v60;
              do
              {
                v33 = 0;
                do
                {
                  if (*(_QWORD *)v60 != v32)
                    objc_enumerationMutation(obj);
                  objc_msgSend(v35, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v59 + 1) + 8 * v33));
                  v16 = (void *)objc_claimAutoreleasedReturnValue();
                  if (v16)
                  {
                    v31 = v16;
                    objc_msgSend(v16, "objectForKeyedSubscript:", v36);
                    v17 = (void *)objc_claimAutoreleasedReturnValue();
                    v57 = 0u;
                    v58 = 0u;
                    v55 = 0u;
                    v56 = 0u;
                    v41 = v17;
                    v18 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v55, v65, 16);
                    if (v18)
                    {
                      v42 = *(_QWORD *)v56;
                      do
                      {
                        v19 = 0;
                        do
                        {
                          if (*(_QWORD *)v56 != v42)
                            objc_enumerationMutation(v41);
                          objc_msgSend(*(id *)(*((_QWORD *)&v55 + 1) + 8 * v19), "allValues");
                          v20 = (void *)objc_claimAutoreleasedReturnValue();
                          v54 = 0u;
                          v52 = 0u;
                          v53 = 0u;
                          v51 = 0u;
                          v21 = v20;
                          v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v51, v64, 16);
                          if (v22)
                          {
                            v23 = *(_QWORD *)v52;
                            do
                            {
                              v24 = 0;
                              do
                              {
                                if (*(_QWORD *)v52 != v23)
                                  objc_enumerationMutation(v21);
                                objc_msgSend(v11, "removeObjectForKey:", *(_QWORD *)(*((_QWORD *)&v51 + 1) + 8 * v24++));
                              }
                              while (v22 != v24);
                              v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v51, v64, 16);
                            }
                            while (v22);
                          }

                          ++v19;
                        }
                        while (v19 != v18);
                        v18 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v55, v65, 16);
                      }
                      while (v18);
                    }

                    v16 = v31;
                  }

                  ++v33;
                }
                while (v33 != v15);
                v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v59, v66, 16);
              }
              while (v15);
            }

          }
        }
      }

      v12 = v34;
    }

  }
  objc_storeStrong(location, v11);
  if (v43)
  {
    v25 = v43;
  }
  else
  {
    objc_msgSend(*location, "allKeys");
    v25 = (void *)objc_claimAutoreleasedReturnValue();
  }
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v44 = v25;
  v26 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v47, v63, 16);
  if (v26)
  {
    v27 = *(_QWORD *)v48;
    do
    {
      v28 = 0;
      do
      {
        if (*(_QWORD *)v48 != v27)
          objc_enumerationMutation(v44);
        std::string::basic_string[abi:ne180100]<0>(__p, (char *)objc_msgSend(objc_retainAutorelease(*(id *)(*((_QWORD *)&v47 + 1) + 8 * v28)), "UTF8String"));
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(v8, (unsigned __int8 *)__p, (uint64_t)__p);
        if (v46 < 0)
          operator delete(__p[0]);
        ++v28;
      }
      while (v26 != v28);
      v26 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v47, v63, 16);
    }
    while (v26);
  }

  return v37;
}

void sub_24112DB7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;
  void *v32;

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v31);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a15);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a16);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a17);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a19);

  _Unwind_Resume(a1);
}

uint64_t DYDerivedCounterInfo::_dfs(_QWORD *a1, unsigned __int8 *a2, _QWORD *a3)
{
  _QWORD *v6;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *i;

  v6 = a1 + 5;
  if (std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a1 + 5, a2))
  {
    return 1;
  }
  if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a1, a2))
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)a1, a2, (uint64_t)a2);
    v8 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::find<std::string>(a3, a2);
    v9 = (unsigned __int8 *)*((_QWORD *)v8 + 5);
    for (i = (unsigned __int8 *)*((_QWORD *)v8 + 6); v9 != i; v9 += 24)
    {
      if (std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::find<std::string>(a3, v9))
      {
        if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(v6, v9)&& (DYDerivedCounterInfo::_dfs(a1, v9, a3) & 1) == 0)
        {
          return 0;
        }
      }
      else
      {
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)(a1 + 10), v9, (uint64_t)v9);
      }
    }
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__erase_unique<std::string>(a1, a2);
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v6, a2, (uint64_t)a2);
    return 1;
  }
  return 0;
}

uint64_t DYDerivedCounterInfo::ProcessInfo(DYDerivedCounterInfo *this)
{
  void *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  _QWORD v10[7];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 (*v14)(__n128 *, __n128 *);
  void (*v15)(uint64_t);
  const char *v16;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  uint64_t (*v22)(uint64_t);
  _BYTE v23[32];
  uint64_t v24;
  int v25;
  void **v26;

  v18 = 0;
  v19 = &v18;
  v20 = 0x5812000000;
  v21 = __Block_byref_object_copy_;
  v22 = __Block_byref_object_dispose_;
  memset(v23, 0, sizeof(v23));
  v24 = 0;
  v25 = 1065353216;
  v11 = 0;
  v12 = &v11;
  v13 = 0x4812000000;
  v14 = __Block_byref_object_copy__31;
  v15 = __Block_byref_object_dispose__32;
  v16 = "";
  memset(v17, 0, sizeof(v17));
  v2 = (void *)*((_QWORD *)this + 20);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3221225472;
  v10[2] = ___ZN20DYDerivedCounterInfo11ProcessInfoEv_block_invoke;
  v10[3] = &unk_251122E30;
  v10[5] = &v11;
  v10[6] = this;
  v10[4] = &v18;
  objc_msgSend(v2, "enumerateKeysAndObjectsUsingBlock:", v10);
  v3 = (unsigned __int8 *)v19[8];
  if (v3)
  {
    while (std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((_QWORD *)this + 5, v3 + 16)|| DYDerivedCounterInfo::_dfs(this, v3 + 16, v19 + 6))
    {
      v3 = *(unsigned __int8 **)v3;
      if (!v3)
        goto LABEL_5;
    }
    v8 = 0;
  }
  else
  {
LABEL_5:
    v4 = (unsigned __int8 *)v12[6];
    v5 = (unsigned __int8 *)v12[7];
    if (v4 != v5)
    {
      v6 = (_QWORD *)((char *)this + 80);
      v7 = (char *)this + 120;
      do
      {
        if (std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(v6, v4))
        {
          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v7, v4, (uint64_t)v4);
        }
        v4 += 24;
      }
      while (v4 != v5);
    }
    v8 = 1;
  }
  _Block_object_dispose(&v11, 8);
  v26 = (void **)v17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v26);
  _Block_object_dispose(&v18, 8);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)&v23[8]);
  return v8;
}

void sub_24112DF98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  v21 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  *(_QWORD *)(v10 - 72) = v9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v10 - 72));
  _Block_object_dispose(va1, 8);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<unsigned long long,unsigned long long>>>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose_(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__31(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN20DYDerivedCounterInfo11ProcessInfoEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  id v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  void *v16;
  unint64_t v17;
  __int128 v18;
  uint64_t v19;
  void *v20;
  void *v21;
  _QWORD *v22;
  unint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  std::string v34;
  __int128 v35;
  uint64_t v36;
  std::string __p;
  void **v38;
  _BYTE v39[128];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v27 = a3;
  v26 = a1;
  v6 = *(_QWORD *)(a1 + 48);
  v7 = objc_retainAutorelease(v5);
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)objc_msgSend(v7, "UTF8String"));
  if (std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((_QWORD *)(v6 + 168), (unsigned __int8 *)&__p))
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v8 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v26 + 32) + 8) + 48), (unsigned __int8 *)&__p);
      if (!v8)
      {
        v9 = *(_QWORD *)(*(_QWORD *)(v26 + 32) + 8);
        v32 = 0uLL;
        v33 = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(&v34, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          v11 = v32;
          v10 = v33;
        }
        else
        {
          v10 = 0;
          v34 = __p;
          v11 = 0uLL;
        }
        v35 = v11;
        v36 = v10;
        v33 = 0;
        v32 = 0uLL;
        v8 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::vector<std::string>>>(v9 + 48, (unsigned __int8 *)&v34, (uint64_t)&v34);
        v38 = (void **)&v35;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v38);
        if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v34.__r_.__value_.__l.__data_);
        v38 = (void **)&v32;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v38);
      }
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("counters"));
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v39, 16);
      if (v13)
      {
        v14 = *(_QWORD *)v29;
        do
        {
          for (i = 0; i != v13; ++i)
          {
            if (*(_QWORD *)v29 != v14)
              objc_enumerationMutation(v12);
            v16 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * i);
            if ((objc_msgSend(v7, "isEqualToString:", v16) & 1) == 0)
            {
              std::string::basic_string[abi:ne180100]<0>(&v34, (char *)objc_msgSend(objc_retainAutorelease(v16), "UTF8String"));
              v17 = *((_QWORD *)v8 + 6);
              if (v17 >= *((_QWORD *)v8 + 7))
              {
                v19 = std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)v8 + 5, (__int128 *)&v34);
              }
              else
              {
                if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
                {
                  std::string::__init_copy_ctor_external(*((std::string **)v8 + 6), v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
                }
                else
                {
                  v18 = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
                  *(_QWORD *)(v17 + 16) = *((_QWORD *)&v34.__r_.__value_.__l + 2);
                  *(_OWORD *)v17 = v18;
                }
                v19 = v17 + 24;
                *((_QWORD *)v8 + 6) = v17 + 24;
              }
              *((_QWORD *)v8 + 6) = v19;
              objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("subtype"));
              v20 = (void *)objc_claimAutoreleasedReturnValue();
              v21 = v20;
              if (v20 && objc_msgSend(v20, "isEqualToString:", CFSTR("Normalize")))
              {
                v22 = *(_QWORD **)(*(_QWORD *)(v26 + 40) + 8);
                v23 = v22[7];
                if (v23 >= v22[8])
                {
                  v25 = std::vector<std::string>::__push_back_slow_path<std::string const&>(v22 + 6, (__int128 *)&v34);
                }
                else
                {
                  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
                  {
                    std::string::__init_copy_ctor_external((std::string *)v22[7], v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
                  }
                  else
                  {
                    v24 = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
                    *(_QWORD *)(v23 + 16) = *((_QWORD *)&v34.__r_.__value_.__l + 2);
                    *(_OWORD *)v23 = v24;
                  }
                  v25 = v23 + 24;
                  v22[7] = v23 + 24;
                }
                v22[7] = v25;
              }

              if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v34.__r_.__value_.__l.__data_);
            }
          }
          v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v39, 16);
        }
        while (v13);
      }

    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);

}

void sub_24112E3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,char *a40)
{
  void *v40;

  a40 = &a21;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a40);
  if (a39 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string,std::vector<std::string>>::~pair(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

id DYDerivedCounterInfo::RawCounterList(DYDerivedCounterInfo *this)
{
  void *v2;
  uint64_t *i;
  _QWORD *v4;
  void *v5;

  v2 = (void *)objc_opt_new();
  for (i = (uint64_t *)*((_QWORD *)this + 12); i; i = (uint64_t *)*i)
  {
    v4 = i + 2;
    if (*((char *)i + 39) < 0)
      v4 = (_QWORD *)*v4;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "addObject:", v5);

  }
  return v2;
}

void sub_24112E528(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id DYDerivedCounterInfo::RawCountersToNormalizeSet(DYDerivedCounterInfo *this)
{
  void *v2;
  uint64_t *i;
  _QWORD *v4;
  void *v5;

  v2 = (void *)objc_opt_new();
  for (i = (uint64_t *)*((_QWORD *)this + 17); i; i = (uint64_t *)*i)
  {
    v4 = i + 2;
    if (*((char *)i + 39) < 0)
      v4 = (_QWORD *)*v4;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "addObject:", v5);

  }
  return v2;
}

void sub_24112E5C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id DYDerivedCounterInfo::DerivedCounterList(DYDerivedCounterInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  _QWORD v10[4];
  id v11;

  v2 = (void *)objc_opt_new();
  v3 = (void *)objc_opt_new();
  objc_msgSend(v2, "addObject:", v3);

  v4 = (void *)objc_opt_new();
  objc_msgSend(v2, "addObject:", v4);

  v5 = (void *)objc_opt_new();
  objc_msgSend(v2, "addObject:", v5);

  v6 = (void *)objc_opt_new();
  objc_msgSend(v2, "addObject:", v6);

  v7 = (void *)*((_QWORD *)this + 20);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3221225472;
  v10[2] = ___ZNK20DYDerivedCounterInfo18DerivedCounterListEv_block_invoke;
  v10[3] = &unk_251122E58;
  v8 = v2;
  v11 = v8;
  objc_msgSend(v7, "enumerateKeysAndObjectsUsingBlock:", v10);

  return v8;
}

void sub_24112E6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZNK20DYDerivedCounterInfo18DerivedCounterListEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  __CFString *v6;
  __CFString *v7;
  __CFString *v8;
  void *v9;
  void *v10;
  void *v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  const __CFString *v15;
  void *v16;
  void *v17;
  const __CFString *v18;
  id v19;

  v19 = a2;
  v5 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("name"));
    v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("description"));
    v7 = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("type"));
    v8 = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", 0);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "addObject:", v19);

    objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", 1);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = v10;
    if (v6)
      v12 = v6;
    else
      v12 = CFSTR("Unknown");
    objc_msgSend(v10, "addObject:", v12);

    objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", 2);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (v7)
      v15 = v7;
    else
      v15 = &stru_2511238E0;
    objc_msgSend(v13, "addObject:", v15);

    objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", 3);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = v16;
    if (v8)
      v18 = v8;
    else
      v18 = CFSTR("Value");
    objc_msgSend(v16, "addObject:", v18);

  }
}

void sub_24112E878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

id DYDerivedCounterInfo::BottleneckFunctions(id *this)
{
  void *v1;
  void *v2;

  objc_msgSend(this[26], "objectForKeyedSubscript:", *MEMORY[0x24BE39280]);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = (void *)objc_msgSend(v1, "mutableCopy");

  return v2;
}

void sub_24112E914(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NSDictionary *DYDerivedCounterInfo::AppendDerivedCounterInfoToPayload(DYDerivedCounterInfo *this, NSDictionary *a2)
{
  NSDictionary *v3;
  NSDictionary *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v3 = a2;
  if ((DYDerivedCounterInfo::ProcessInfo(this) & 1) != 0)
  {
    v4 = (NSDictionary *)-[NSDictionary mutableCopy](v3, "mutableCopy");
    DYDerivedCounterInfo::RawCounterList(this);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    -[NSDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v5, *MEMORY[0x24BE396C0]);

    -[NSDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C8], *MEMORY[0x24BE395C8]);
    -[NSDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C8], *MEMORY[0x24BE39718]);
    v6 = (void *)MEMORY[0x24BDD16E0];
    objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "numberWithBool:", objc_msgSend(v7, "BOOLForKey:", CFSTR("GPUDebugger.ShaderProfiler.SplitEncoderData")));
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    -[NSDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v8, *MEMORY[0x24BE39720]);

    DYDerivedCounterInfo::RawCountersToNormalizeSet(this);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    -[NSDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v9, *MEMORY[0x24BE395D0]);

  }
  else
  {
    v4 = v3;
  }

  return v4;
}

void sub_24112EA70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void DYDerivedCounterInfo::MergeDictionaries(DYDerivedCounterInfo *this, NSMutableDictionary *a2, NSMutableDictionary *a3)
{
  DYDerivedCounterInfo *v4;
  NSMutableDictionary *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  void *v10;
  NSMutableDictionary *v11;
  NSMutableDictionary *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = this;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v5 = a2;
  v6 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v14;
    do
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v14 != v7)
          objc_enumerationMutation(v5);
        v9 = *(_QWORD *)(*((_QWORD *)&v13 + 1) + 8 * i);
        -[DYDerivedCounterInfo objectForKey:](v4, "objectForKey:", v9, (_QWORD)v13);
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSMutableDictionary objectForKey:](v5, "objectForKey:", v9);
        v11 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue();
        if (v10)
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
          {
            objc_msgSend(v10, "addObjectsFromArray:", v11);
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
                DYDerivedCounterInfo::MergeDictionaries((DYDerivedCounterInfo *)v10, v11, v12);
            }
          }
        }
        else
        {
          -[DYDerivedCounterInfo setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v11, v9);
        }

      }
      v6 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
    }
    while (v6);
  }

}

void sub_24112EC84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

NSString *DYDerivedCounterInfo::MergeDerivedCounterDataFromHost(DYDerivedCounterInfo *this, NSString *a2, NSString *a3, NSDictionary *a4)
{
  NSString *v6;
  void *v7;
  void *v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  CFPropertyListRef DeepCopy;
  uint64_t v16;
  void *v17;
  NSMutableDictionary *v18;
  NSMutableDictionary *v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  NSString *v24;
  void *v25;
  id v26;
  void *v27;
  uint64_t v28;
  void *v29;
  const __CFString *v30;
  void *v31;
  void *v32;
  id v33;
  const __CFString *v34;
  void *v35;
  uint64_t v37;
  __CFString *v38;
  void *v39;
  void *v40;
  void *v41;
  __CFString *v42;
  DYDerivedCounterInfo *v43;
  void *v44;
  void *v45;
  id v46;
  id v47;
  id v48;

  v6 = a3;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@/%@"), a2, this);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "stringByStandardizingPath");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = objc_msgSend(v9, "fileExistsAtPath:isDirectory:", v8, 0);

  if (v10)
  {
    objc_msgSend(MEMORY[0x24BDBCED8], "dictionaryWithDictionary:", v6);
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@/MetalStatistics%@"), v8, CFSTR("-counters.plist"));
    v11 = objc_claimAutoreleasedReturnValue();
    v40 = (void *)v11;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@/MetalStatistics%@"), v8, CFSTR("-analysis.js"));
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@/MetalStatistics%@"), v8, CFSTR("-derived.js"));
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = *MEMORY[0x24BE39378];
    -[NSString objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", *MEMORY[0x24BE39378]);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v39 = v13;
    v14 = (void *)objc_opt_new();
    if (v13)
    {
      DeepCopy = CFPropertyListCreateDeepCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], v13, 2uLL);

      v14 = (void *)DeepCopy;
    }
    v16 = *MEMORY[0x24BE39380];
    v43 = (DYDerivedCounterInfo *)v14;
    -[NSString objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", *MEMORY[0x24BE39380]);
    v42 = (__CFString *)objc_claimAutoreleasedReturnValue();
    v37 = *MEMORY[0x24BE39350];
    -[NSString objectForKeyedSubscript:](v6, "objectForKeyedSubscript:");
    v38 = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDBCE50], "dataWithContentsOfFile:", v11);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    if (v17)
    {
      v48 = 0;
      objc_msgSend(MEMORY[0x24BDD1770], "propertyListWithData:options:format:error:", v17, 1, 0, &v48);
      v18 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue();
      v20 = v48;
      if (!v20 && v18)
      {
        DYDerivedCounterInfo::MergeDictionaries(v43, v18, v19);
        v21 = (void *)objc_opt_new();
        objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObject:", CFSTR("MTLStat_nSec"));
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v21, "setObject:forKeyedSubscript:", v22, CFSTR("counters"));

        objc_msgSend(v21, "setObject:forKeyedSubscript:", CFSTR("GPU Time"), CFSTR("name"));
        objc_msgSend(v21, "setObject:forKeyedSubscript:", CFSTR("GPU Time in nSec"), CFSTR("description"));
        objc_msgSend(v21, "setObject:forKeyedSubscript:", CFSTR("Count"), CFSTR("type"));
        -[DYDerivedCounterInfo objectForKeyedSubscript:](v43, "objectForKeyedSubscript:", *MEMORY[0x24BE39388]);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v23, "setObject:forKeyedSubscript:", v21, *MEMORY[0x24BE39408]);

        objc_msgSend(v41, "setObject:forKeyedSubscript:", v43, v12);
      }

    }
    else
    {
      v20 = 0;
    }
    v47 = v20;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithContentsOfFile:encoding:error:", v44, 4, &v47);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = v47;

    v24 = (NSString *)v41;
    if (!v26 && v25)
    {
      v27 = (void *)MEMORY[0x24BDD17C8];
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "\nfunction GPUToolsGPUTime()\n{\n   return MTLStat_nSec\n}\n");
      v28 = objc_claimAutoreleasedReturnValue();
      v29 = (void *)v28;
      v30 = &stru_2511238E0;
      if (v42)
        v30 = v42;
      objc_msgSend(v27, "stringWithFormat:", CFSTR("%@\n%@\n%@"), v30, v25, v28);
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v41, "setObject:forKeyedSubscript:", v31, v16);

    }
    v46 = v26;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithContentsOfFile:encoding:error:", v45, 4, &v46);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = v46;

    if (!v33 && v32)
    {
      v34 = &stru_2511238E0;
      if (v38)
        v34 = v38;
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@\n%@"), v34, v32);
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v41, "setObject:forKeyedSubscript:", v35, v37);

    }
  }
  else
  {
    v24 = v6;
  }

  return v24;
}

void sub_24112F158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

void sub_24112F27C()
{
  void *v0;

  JUMPOUT(0x24112F26CLL);
}

void sub_24112F290()
{
  void *v0;

  JUMPOUT(0x24112F270);
}

void sub_24112F29C()
{
  JUMPOUT(0x24112F270);
}

NSString *DYDerivedCounterInfo::AppendDerivedCounterDataFromHost(void *a1, int a2, void *a3)
{
  DYDerivedCounterInfo *v5;
  NSString *v6;
  NSDictionary *v7;
  uint64_t v8;

  v5 = a1;
  v6 = a3;
  if (v6)
  {
    if (!v5)
      goto LABEL_8;
  }
  else
  {
    v6 = (NSString *)objc_opt_new();
    if (!v5)
      goto LABEL_8;
  }
  if (a2 != 1 && -[DYDerivedCounterInfo length](v5, "length"))
  {
    DYDerivedCounterInfo::MergeDerivedCounterDataFromHost(v5, CFSTR("~/Library/Developer/MetalStatistics"), v6, v7);
    v8 = objc_claimAutoreleasedReturnValue();

    v6 = (NSString *)v8;
  }
LABEL_8:

  return v6;
}

void sub_24112F33C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void DYDerivedCounterInfo::_ProcessKickCounters(void *a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, unint64_t a6, void *a7, void *a8, uint64_t a9, _QWORD *a10, void *a11, void *a12)
{
  id v16;
  void *v17;
  char isKindOfClass;
  void *v19;
  void *v20;
  void *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  void *v30;
  unint64_t v31;
  void *v32;
  unint64_t v33;
  unint64_t v34;
  double v35;
  void *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t i;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  uint64_t v49;
  double v50;
  void *v51;
  id v52;
  void *v53;
  id v54;
  int v55;
  id v58;
  uint64_t v60;
  unint64_t v61;
  id v62;
  char v63;
  void *v64;
  void *v65;
  id v66;
  id v67;
  id obj;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  _BYTE v73[128];
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  v66 = a1;
  v62 = a4;
  v16 = a7;
  v58 = a8;
  v52 = a11;
  v54 = a12;
  v64 = v16;
  objc_msgSend(v16, "objectAtIndexedSubscript:", 0);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  v63 = isKindOfClass;
  objc_msgSend(v16, "objectAtIndexedSubscript:", a2, v52);
  if ((isKindOfClass & 1) != 0)
  {
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "objectAtIndexedSubscript:", 0);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v19 = v20;
  }
  v61 = objc_msgSend(v20, "unsignedLongLongValue");
  if ((isKindOfClass & 1) != 0)

  if (v61 < 4)
  {
    v55 = objc_msgSend(v16, "count");
    if (v62 && objc_msgSend(v62, "count") > a5)
    {
      objc_msgSend(v62, "objectAtIndexedSubscript:");
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = objc_msgSend(v21, "count");
      if (v22 <= 1)
        v23 = 1;
      else
        v23 = v22;
      a6 %= v23;

    }
    v24 = 0;
    v60 = 0;
    while (1)
    {
      if (v24 >= objc_msgSend(v64, "count"))
        goto LABEL_46;
      objc_msgSend(v64, "objectAtIndexedSubscript:", v24);
      v65 = (void *)objc_claimAutoreleasedReturnValue();
      if ((v63 & 1) != 0)
      {
        objc_msgSend(v65, "objectAtIndexedSubscript:", 0);
        v67 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v67 = v65;
      }
      if (v62 && v24 == a3 && objc_msgSend(v62, "count") > a5)
      {
        objc_msgSend(v62, "objectAtIndexedSubscript:");
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v25, "objectAtIndexedSubscript:", a6);
        v26 = objc_claimAutoreleasedReturnValue();

        v67 = (id)v26;
      }
      v27 = (void *)MEMORY[0x24BDD16E0];
      v28 = objc_msgSend(v67, "unsignedLongLongValue");
      objc_msgSend(v66, "objectAtIndexedSubscript:", v24 + *(unsigned int *)(a9 + 12));
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "numberWithUnsignedLongLong:", objc_msgSend(v29, "unsignedLongLongValue") + v28);
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v66, "setObject:atIndexedSubscript:", v30, v24 + *(unsigned int *)(a9 + 12));

      objc_msgSend(v66, "setObject:atIndexedSubscript:", v67, v24 + *(unsigned int *)(a9 + 4 * v61));
      if ((v63 & 1) != 0 && ((*(_QWORD *)(*a10 + ((v24 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v24) & 1) != 0)
        break;
LABEL_45:

      ++v24;
    }
    v31 = objc_msgSend(v67, "unsignedLongLongValue");
    objc_msgSend(v65, "objectAtIndexedSubscript:", 1);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = objc_msgSend(v32, "unsignedLongLongValue");

    if (v33 <= 1)
      v34 = 1;
    else
      v34 = v33;
    v35 = (double)v31 * 100.0 / (double)v34;
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v35);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v66, "setObject:atIndexedSubscript:", v36, v60 + (*(_DWORD *)(a9 + 4 * v61) + v55));

    v37 = objc_msgSend(v58, "count");
    if (a6 || v37 < 2)
    {
      if (objc_msgSend(v58, "count") != 1)
      {
LABEL_44:
        ++v60;
        goto LABEL_45;
      }
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v35);
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v66, "setObject:atIndexedSubscript:", v51, v60 + (*(_DWORD *)(a9 + 12) + v55));
LABEL_43:

      goto LABEL_44;
    }
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    obj = v58;
    v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v69, v73, 16);
    if (v38)
    {
      v39 = 0;
      v40 = 0;
      v41 = *(_QWORD *)v70;
      do
      {
        for (i = 0; i != v38; ++i)
        {
          if (*(_QWORD *)v70 != v41)
            objc_enumerationMutation(obj);
          v43 = *(void **)(*((_QWORD *)&v69 + 1) + 8 * i);
          objc_msgSend(v43, "objectAtIndexedSubscript:", v24);
          v44 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v44, "objectAtIndexedSubscript:", 0);
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          v46 = objc_msgSend(v45, "unsignedLongLongValue");

          objc_msgSend(v43, "objectAtIndexedSubscript:", v24);
          v47 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v47, "objectAtIndexedSubscript:", 1);
          v48 = (void *)objc_claimAutoreleasedReturnValue();
          v49 = objc_msgSend(v48, "unsignedLongLongValue");

          v40 += v46;
          v39 += v49;
        }
        v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v69, v73, 16);
      }
      while (v38);

      v50 = (double)v40 * 100.0;
      if (v39)
        goto LABEL_42;
    }
    else
    {

      v50 = 0.0;
    }
    v39 = 1;
LABEL_42:
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v50 / (double)v39);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v66, "setObject:atIndexedSubscript:", v51, v60 + (*(_DWORD *)(a9 + 12) + v55));
    goto LABEL_43;
  }
LABEL_46:

}

void sub_24112F918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24)
{
  void *v24;

  _Unwind_Resume(a1);
}

id DYDerivedCounterInfo::_ProcessSplitEncoderDerivedCounterDataFromDevice(void *a1, void *a2, _QWORD *a3)
{
  id v5;
  uint64_t v6;
  void *v7;
  id v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  id v14;
  unsigned int v15;
  void *v16;
  NSArray *v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  id v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t j;
  uint64_t v31;
  void *v32;
  void *v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  void *v39;
  id obj;
  uint64_t i;
  id v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  void *v48;
  id v49;
  void *v50;
  id v51;
  uint64_t v52;
  uint64_t v53;
  _anonymous_namespace_ *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  _BYTE v78[128];
  _BYTE v79[128];
  _BYTE v80[128];
  _BYTE v81[128];
  _DWORD v82[32];
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v49 = a2;
  v48 = v5;
  objc_msgSend(v5, "objectForKeyedSubscript:", *MEMORY[0x24BE39720]);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  if (v50)
  {
    v47 = (void *)objc_opt_new();
    v6 = *MEMORY[0x24BE39310];
    objc_msgSend(v50, "objectForKeyedSubscript:", *MEMORY[0x24BE39310]);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    if (v7)
    {
      objc_msgSend(v7, "count");
      v45 = v6;
      v74 = 0u;
      v75 = 0u;
      v76 = 0u;
      v77 = 0u;
      v8 = v8;
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v74, v82, 16);
      if (v9)
      {
        v10 = 0;
        v11 = *(_QWORD *)v75;
LABEL_5:
        v12 = 0;
        v13 = v10 + v9;
        while (1)
        {
          if (*(_QWORD *)v75 != v11)
            objc_enumerationMutation(v8);
          if ((objc_msgSend(*(id *)(*((_QWORD *)&v74 + 1) + 8 * v12), "isEqualToString:", CFSTR("MTLStatDataMaster")) & 1) != 0)
            break;
          if (v9 == ++v12)
          {
            v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v74, v82, 16);
            v10 = v13;
            if (v9)
              goto LABEL_5;
            goto LABEL_11;
          }
        }

        v15 = v12 + v10;
        if ((_DWORD)v12 + v10 == -1)
          goto LABEL_43;
        objc_msgSend(v8, "arrayByAddingObjectsFromArray:", v49);
        v16 = (void *)objc_claimAutoreleasedReturnValue();

        v54 = (_anonymous_namespace_ *)objc_msgSend(v16, "count");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        v82[0] = 0;
        v82[1] = (_DWORD)v54;
        v82[2] = 2 * (_DWORD)v54;
        v82[3] = 3 * (_DWORD)v54;
        v35 = *MEMORY[0x24BE39270];
        objc_msgSend(v50, "objectForKeyedSubscript:");
        v38 = (void *)objc_claimAutoreleasedReturnValue();
        v39 = (void *)objc_opt_new();
        v72 = 0u;
        v73 = 0u;
        v70 = 0u;
        v71 = 0u;
        obj = v38;
        v36 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v70, v81, 16);
        if (v36)
        {
          v19 = v15;
          v37 = *(_QWORD *)v71;
          do
          {
            for (i = 0; i != v36; ++i)
            {
              if (*(_QWORD *)v71 != v37)
                objc_enumerationMutation(obj);
              v20 = *(void **)(*((_QWORD *)&v70 + 1) + 8 * i);
              v44 = (void *)objc_opt_new();
              v68 = 0u;
              v69 = 0u;
              v66 = 0u;
              v67 = 0u;
              v42 = v20;
              v21 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v66, v80, 16);
              if (v21)
              {
                v43 = *(_QWORD *)v67;
                do
                {
                  v46 = 0;
                  v52 = v21;
                  do
                  {
                    if (*(_QWORD *)v67 != v43)
                      objc_enumerationMutation(v42);
                    v22 = *(void **)(*((_QWORD *)&v66 + 1) + 8 * v46);
                    v55 = (void *)objc_opt_new();
                    v64 = 0u;
                    v65 = 0u;
                    v62 = 0u;
                    v63 = 0u;
                    v51 = v22;
                    v23 = objc_msgSend(v51, "countByEnumeratingWithState:objects:count:", &v62, v79, 16);
                    if (v23)
                    {
                      v53 = *(_QWORD *)v63;
                      do
                      {
                        v24 = 0;
                        v56 = v23;
                        do
                        {
                          if (*(_QWORD *)v63 != v53)
                            objc_enumerationMutation(v51);
                          v57 = v24;
                          v25 = *(void **)(*((_QWORD *)&v62 + 1) + 8 * v24);
                          v26 = (void *)objc_claimAutoreleasedReturnValue();
                          v60 = 0u;
                          v61 = 0u;
                          v58 = 0u;
                          v59 = 0u;
                          v27 = v25;
                          v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v58, v78, 16);
                          if (v28)
                          {
                            v29 = *(_QWORD *)v59;
                            do
                            {
                              for (j = 0; j != v28; ++j)
                              {
                                if (*(_QWORD *)v59 != v29)
                                  objc_enumerationMutation(v27);
                                DYDerivedCounterInfo::_ProcessKickCounters(v26, v19, 0xFFFFFFFFLL, 0, 0, 0, *(void **)(*((_QWORD *)&v58 + 1) + 8 * j), v27, (uint64_t)v82, a3, v16, v18);
                              }
                              v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v58, v78, 16);
                            }
                            while (v28);
                          }

                          v21 = v52;
                          objc_msgSend(v55, "addObject:", v26);

                          v24 = v57 + 1;
                        }
                        while (v57 + 1 != v56);
                        v23 = objc_msgSend(v51, "countByEnumeratingWithState:objects:count:", &v62, v79, 16);
                      }
                      while (v23);
                    }

                    objc_msgSend(v44, "addObject:", v55);
                    ++v46;
                  }
                  while (v46 != v21);
                  v21 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v66, v80, 16);
                }
                while (v21);
              }

              objc_msgSend(v39, "addObject:", v44);
            }
            v36 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v70, v81, 16);
          }
          while (v36);
        }

        objc_msgSend(v47, "setObject:forKeyedSubscript:", v18, v45);
        objc_msgSend(v47, "setObject:forKeyedSubscript:", v39, v35);
        v31 = *MEMORY[0x24BE39308];
        objc_msgSend(v50, "objectForKeyedSubscript:", *MEMORY[0x24BE39308]);
        v32 = (void *)objc_claimAutoreleasedReturnValue();
        v33 = (void *)objc_msgSend(v32, "copy");
        objc_msgSend(v47, "setObject:forKeyedSubscript:", v33, v31);

        v14 = v47;
        v8 = v16;
        goto LABEL_44;
      }
LABEL_11:

    }
LABEL_43:
    v14 = 0;
LABEL_44:

    goto LABEL_45;
  }
  v14 = 0;
LABEL_45:

  return v14;
}

void sub_241130054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,void *a28,void *a29)
{
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

id `anonymous namespace'::AddSuffixToCounters(_anonymous_namespace_ *this, NSArray *a2)
{
  _anonymous_namespace_ *v2;
  void *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t i;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _QWORD v16[4];
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = this;
  v3 = (void *)objc_opt_new();
  v4 = 0;
  v16[0] = CFSTR("_vtx");
  v16[1] = CFSTR("_frg");
  v16[2] = CFSTR("_cmp");
  v16[3] = &stru_2511238E0;
  do
  {
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v5 = v2;
    v6 = -[_anonymous_namespace_ countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v12, v17, 16);
    if (v6)
    {
      v7 = *(_QWORD *)v13;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v13 != v7)
            objc_enumerationMutation(v5);
          objc_msgSend(*(id *)(*((_QWORD *)&v12 + 1) + 8 * v8), "stringByAppendingString:", v16[v4]);
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v3, "addObject:", v9);

          ++v8;
        }
        while (v6 != v8);
        v6 = -[_anonymous_namespace_ countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v12, v17, 16);
      }
      while (v6);
    }

    ++v4;
  }
  while (v4 != 4);
  for (i = 3; i != -1; --i)

  return v3;
}

void sub_24113032C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id `anonymous namespace'::CreateCounterSpaceForSuffixes(_anonymous_namespace_ *this)
{
  uint64_t v1;
  void *v2;

  v1 = (4 * (_DWORD)this);
  objc_msgSend(MEMORY[0x24BDBCEB8], "arrayWithCapacity:", v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if ((_DWORD)v1)
  {
    do
    {
      objc_msgSend(v2, "addObject:", &unk_251127F00);
      --v1;
    }
    while (v1);
  }
  return v2;
}

void sub_2411303E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id DYDerivedCounterInfo::ProcessDerivedCounterDataFromDevice(DYDerivedCounterInfo *this, NSDictionary *a2, NSDictionary *a3, NSArray *a4)
{
  DYDerivedCounterInfo *v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  void *v12;
  void *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t j;
  id v18;
  id v19;
  void *v20;
  id v21;
  id v22;
  void *v23;
  _anonymous_namespace_ *v24;
  NSNumber *v25;
  unsigned int v26;
  _anonymous_namespace_ *v27;
  NSNumber *v28;
  unsigned int v29;
  void *v30;
  NSArray *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  void *v37;
  int v38;
  unint64_t v39;
  void *v40;
  int v41;
  void *v42;
  void *v43;
  void *v44;
  id v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t k;
  void *v50;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  void *v60;
  void *v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  unsigned int v66;
  void *v67;
  void *v68;
  void *v69;
  id v70;
  NSDictionary *v71;
  char v72;
  _anonymous_namespace_ *v73;
  unsigned int v74;
  void *v75;
  void *v76;
  unsigned int v77;
  void *v78;
  void *v79;
  unsigned int v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  NSDictionary *v85;
  void *v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  void *__p[3];
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  uint64_t v101;
  void (*v102)(uint64_t, void *, uint64_t);
  void *v103;
  id v104;
  id v105;
  _BYTE v106[128];
  _BYTE v107[128];
  _BYTE v108[128];
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  v6 = this;
  v71 = a2;
  v85 = a3;
  if (v6)
  {
    v68 = (void *)objc_opt_new();
    v64 = *MEMORY[0x24BE39310];
    -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:");
    v7 = (id)objc_claimAutoreleasedReturnValue();
    -[NSDictionary objectForKeyedSubscript:](v71, "objectForKeyedSubscript:", *MEMORY[0x24BE395D0]);
    v83 = (void *)objc_claimAutoreleasedReturnValue();
    if (v7)
    {
      objc_msgSend(v7, "count");
      v82 = (void *)objc_opt_new();
      if (v83)
      {
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v8 = v7;
        v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v96, v108, 16);
        if (v9)
        {
          v10 = *(_QWORD *)v97;
          do
          {
            for (i = 0; i != v9; ++i)
            {
              if (*(_QWORD *)v97 != v10)
                objc_enumerationMutation(v8);
              v12 = *(void **)(*((_QWORD *)&v96 + 1) + 8 * i);
              if (objc_msgSend(v83, "containsObject:", v12))
              {
                objc_msgSend(v12, "stringByAppendingString:", CFSTR("_norm"));
                v13 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v82, "addObject:", v13);

              }
            }
            v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v96, v108, 16);
          }
          while (v9);
        }

      }
      memset(__p, 0, sizeof(__p));
      v91 = 0u;
      v92 = 0u;
      v93 = 0u;
      v94 = 0u;
      v14 = v7;
      v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v91, v107, 16);
      if (v15)
      {
        v16 = *(_QWORD *)v92;
        do
        {
          for (j = 0; j != v15; ++j)
          {
            if (*(_QWORD *)v92 != v16)
              objc_enumerationMutation(v14);
            LOBYTE(v100) = objc_msgSend(v83, "containsObject:", *(_QWORD *)(*((_QWORD *)&v91 + 1) + 8 * j));
            std::vector<BOOL>::push_back((uint64_t)__p, &v100);
          }
          v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v91, v107, 16);
        }
        while (v15);
      }

      objc_msgSend(MEMORY[0x24BDBCF20], "setWithObjects:", CFSTR("MTLStatDataMaster"), CFSTR("MTLStat_nSec"), 0);
      v18 = (id)objc_claimAutoreleasedReturnValue();
      v19 = v14;
      v20 = (void *)objc_opt_new();
      v100 = MEMORY[0x24BDAC760];
      v101 = 3221225472;
      v102 = ___ZN12_GLOBAL__N_128CounterIndicesFromCounterSetEP5NSSetP7NSArray_block_invoke;
      v103 = &unk_251122EB8;
      v21 = v18;
      v104 = v21;
      v22 = v20;
      v105 = v22;
      objc_msgSend(v19, "enumerateObjectsUsingBlock:", &v100);
      v23 = v105;
      v70 = v22;

      objc_msgSend(v70, "objectForKeyedSubscript:", CFSTR("MTLStatDataMaster"));
      v24 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v70, "objectForKeyedSubscript:", CFSTR("MTLStat_nSec"));
      v27 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();

      v7 = 0;
      if (v26 == -1 || v29 == -1)
      {
        v30 = v19;
      }
      else
      {
        objc_msgSend(v19, "arrayByAddingObjectsFromArray:", v82);
        v30 = (void *)objc_claimAutoreleasedReturnValue();

        v73 = (_anonymous_namespace_ *)objc_msgSend(v30, "count");
        v84 = (void *)objc_claimAutoreleasedReturnValue();
        LODWORD(v100) = 0;
        HIDWORD(v100) = (_DWORD)v73;
        LODWORD(v101) = 2 * (_DWORD)v73;
        HIDWORD(v101) = 3 * (_DWORD)v73;
        v63 = *MEMORY[0x24BE39270];
        v86 = v30;
        -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:");
        v67 = (void *)objc_claimAutoreleasedReturnValue();
        v65 = (void *)objc_opt_new();
        -[NSDictionary objectForKeyedSubscript:](v71, "objectForKeyedSubscript:", CFSTR("perCommandBufferEncoderCount"));
        v69 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSDictionary objectForKeyedSubscript:](v71, "objectForKeyedSubscript:", CFSTR("activePerEncoderDrawCallCount"));
        v75 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSDictionary objectForKeyedSubscript:](v71, "objectForKeyedSubscript:", CFSTR("perEncoderKickCount"));
        v76 = (void *)objc_claimAutoreleasedReturnValue();
        v66 = 0;
        v32 = 0;
        v33 = 0;
        v34 = v26;
        v35 = v29;
        while (1)
        {
          v36 = v33;
          if (objc_msgSend(v69, "count") <= (unint64_t)v33)
          {
            objc_msgSend(v68, "setObject:forKeyedSubscript:", v84, v64);
            objc_msgSend(v68, "setObject:forKeyedSubscript:", v65, v63);
            v52 = *MEMORY[0x24BE39308];
            -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", *MEMORY[0x24BE39308]);
            v53 = objc_claimAutoreleasedReturnValue();
            v54 = (void *)objc_msgSend((id)v53, "copy");
            objc_msgSend(v68, "setObject:forKeyedSubscript:", v54, v52);

            v55 = *MEMORY[0x24BE39278];
            -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", *MEMORY[0x24BE39278]);
            v56 = (void *)objc_claimAutoreleasedReturnValue();
            LOBYTE(v53) = v56 == 0;

            if ((v53 & 1) == 0)
            {
              -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v55);
              v57 = objc_claimAutoreleasedReturnValue();
              v58 = (void *)objc_msgSend((id)v57, "copy");
              objc_msgSend(v68, "setObject:forKeyedSubscript:", v58, v55);

              v59 = *MEMORY[0x24BE39460];
              -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", *MEMORY[0x24BE39460]);
              v60 = (void *)objc_claimAutoreleasedReturnValue();
              LOBYTE(v57) = v60 == 0;

              if ((v57 & 1) == 0)
              {
                -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v59);
                v61 = (void *)objc_claimAutoreleasedReturnValue();
                v62 = (void *)objc_msgSend(v61, "copy");
                objc_msgSend(v68, "setObject:forKeyedSubscript:", v62, v59);

              }
            }
            DYDerivedCounterInfo::_ProcessSplitEncoderDerivedCounterDataFromDevice(v6, v82, __p);
            v50 = (void *)objc_claimAutoreleasedReturnValue();
            if (v50)
              objc_msgSend(v68, "setObject:forKeyedSubscript:", v50, *MEMORY[0x24BE39720]);
            v7 = v68;
LABEL_46:

            goto LABEL_47;
          }
          objc_msgSend(v69, "objectAtIndexedSubscript:", v33);
          v37 = (void *)objc_claimAutoreleasedReturnValue();
          v38 = objc_msgSend(v37, "unsignedIntValue");

          if (v38)
            break;
LABEL_42:
          v33 = v36 + 1;
        }
        if (objc_msgSend(v67, "count") > (unint64_t)v66)
        {
          objc_msgSend(v67, "objectAtIndexedSubscript:");
          v79 = (void *)objc_claimAutoreleasedReturnValue();
          v78 = (void *)objc_opt_new();
          v80 = 0;
          v77 = v32 + v38;
          v72 = 1;
          v74 = v36;
          while (1)
          {
            v39 = v32;
            objc_msgSend(v76, "objectAtIndexedSubscript:", v32);
            v40 = (void *)objc_claimAutoreleasedReturnValue();
            v41 = objc_msgSend(v40, "unsignedIntValue");

            objc_msgSend(v75, "objectAtIndexedSubscript:", v39);
            v42 = (void *)objc_claimAutoreleasedReturnValue();
            LODWORD(v40) = objc_msgSend(v42, "unsignedIntValue");

            if ((_DWORD)v40 || v41 != 1)
            {
              if (objc_msgSend(v79, "count") <= (unint64_t)v80)
              {

                v7 = 0;
                v50 = v79;
                goto LABEL_46;
              }
              objc_msgSend(v79, "objectAtIndexedSubscript:");
              v43 = (void *)objc_claimAutoreleasedReturnValue();
              v72 = 0;
              ++v80;
            }
            else
            {
              v43 = (void *)objc_opt_new();
            }
            v81 = (void *)objc_opt_new();
            v44 = (void *)objc_claimAutoreleasedReturnValue();
            v89 = 0u;
            v90 = 0u;
            v87 = 0u;
            v88 = 0u;
            v45 = v43;
            v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v87, v106, 16);
            if (v46)
            {
              v47 = 0;
              v48 = *(_QWORD *)v88;
              do
              {
                for (k = 0; k != v46; ++k)
                {
                  if (*(_QWORD *)v88 != v48)
                    objc_enumerationMutation(v45);
                  DYDerivedCounterInfo::_ProcessKickCounters(v44, v34, v35, v85, v39, (v47 + k), *(void **)(*((_QWORD *)&v87 + 1) + 8 * k), v45, (uint64_t)&v100, __p, v86, v84);
                }
                v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v87, v106, 16);
                v47 += k;
              }
              while (v46);
            }

            v30 = v86;
            v36 = v74;
            objc_msgSend(v81, "addObject:", v44);
            objc_msgSend(v78, "addObject:", v81);

            v32 = v39 + 1;
            if ((_DWORD)v39 + 1 == v77)
            {
              objc_msgSend(v65, "addObject:", v78);

              v66 += (v72 & 1) == 0;
              v32 = v77;
              goto LABEL_42;
            }
          }
        }
        v7 = 0;
LABEL_47:

      }
      if (__p[0])
        operator delete(__p[0]);

    }
  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void sub_241130D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,void *a35,void *a36,void *a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p)
{
  void *v56;
  void *v57;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void std::vector<BOOL>::push_back(uint64_t a1, _BYTE *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64)
      v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    if (v4 <= 0x3FFFFFFFFFFFFFFELL)
      v7 = v6;
    else
      v7 = 0x7FFFFFFFFFFFFFFFLL;
    std::vector<BOOL>::reserve((char **)a1, v7);
    v4 = *(_QWORD *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v4 + 1;
  v8 = *(char **)a1;
  v9 = v4 >> 6;
  v10 = 1 << v4;
  if (*a2)
    v11 = *(_QWORD *)&v8[8 * v9] | v10;
  else
    v11 = *(_QWORD *)&v8[8 * v9] & ~v10;
  *(_QWORD *)&v8[8 * v9] = v11;
}

uint64_t `anonymous namespace'::CounterIndex(_anonymous_namespace_ *this, NSNumber *a2)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;
  uint64_t v4;

  v2 = this;
  v3 = v2;
  if (v2)
    v4 = -[_anonymous_namespace_ unsignedIntValue](v2, "unsignedIntValue");
  else
    v4 = 0xFFFFFFFFLL;

  return v4;
}

void sub_24113105C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NSDictionary *DYDerivedCounterInfo::WriteToJSONPerDerivedCounterData(DYDerivedCounterInfo *this, NSDictionary *a2, NSString *a3, NSString *a4)
{
  DYDerivedCounterInfo *v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  void *v15;
  void *v16;
  id v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t k;
  uint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  void *v26;
  NSDictionary *v27;
  void *v28;
  char v29;
  uint64_t v30;
  NSDictionary *m;
  void *v32;
  int v33;
  uint64_t v34;
  id v35;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  NSDictionary *v42;
  DYDerivedCounterInfo *v43;
  NSString *v44;
  id obj;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  void *v49;
  uint64_t j;
  id v51;
  id v52;
  id v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  _BYTE v66[128];
  _BYTE v67[128];
  _BYTE v68[128];
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v6 = this;
  v42 = a2;
  v44 = a3;
  v43 = v6;
  -[DYDerivedCounterInfo objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", *MEMORY[0x24BE39370]);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = v7;
  v41 = v7;
  if (v7)
  {
    objc_msgSend(v7, "objectForKeyedSubscript:", *MEMORY[0x24BE39310]);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "objectForKeyedSubscript:", *MEMORY[0x24BE39270]);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    v40 = (void *)objc_opt_new();
    v9 = (void *)objc_opt_new();
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v10 = v38;
    v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v62, v68, 16);
    if (v11)
    {
      v12 = *(_QWORD *)v63;
      do
      {
        for (i = 0; i != v11; ++i)
        {
          if (*(_QWORD *)v63 != v12)
            objc_enumerationMutation(v10);
          v14 = *(_QWORD *)(*((_QWORD *)&v62 + 1) + 8 * i);
          v15 = (void *)objc_opt_new();
          objc_msgSend(v9, "setObject:forKeyedSubscript:", v15, v14);

        }
        v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v62, v68, 16);
      }
      while (v11);
    }

    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    obj = v39;
    v48 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v58, v67, 16);
    if (v48)
    {
      v46 = *(_QWORD *)v59;
      do
      {
        for (j = 0; j != v48; ++j)
        {
          if (*(_QWORD *)v59 != v46)
            objc_enumerationMutation(obj);
          v16 = *(void **)(*((_QWORD *)&v58 + 1) + 8 * j);
          v54 = 0u;
          v55 = 0u;
          v56 = 0u;
          v57 = 0u;
          v17 = v16;
          v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v54, v66, 16);
          if (v18)
          {
            v19 = 0;
            v20 = *(_QWORD *)v55;
            do
            {
              for (k = 0; k != v18; ++k)
              {
                if (*(_QWORD *)v55 != v20)
                  objc_enumerationMutation(v17);
                v22 = *(_QWORD *)(*((_QWORD *)&v54 + 1) + 8 * k);
                objc_msgSend(v10, "objectAtIndexedSubscript:", (v19 + k));
                v23 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v9, "objectForKeyedSubscript:", v23);
                v24 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v24, "addObject:", v22);

              }
              v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v54, v66, 16);
              v19 += k;
            }
            while (v18);
          }

        }
        v48 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v58, v67, 16);
      }
      while (v48);
    }

    if (v44)
      objc_msgSend(v40, "setObject:forKeyedSubscript:", v44, CFSTR("MetalPluginName"));
    -[DYDerivedCounterInfo objectForKeyedSubscript:](v43, "objectForKeyedSubscript:", CFSTR("perEncoderIndexDrawCallCount"));
    v25 = objc_claimAutoreleasedReturnValue();
    v49 = (void *)v25;
    if (v25)
      objc_msgSend(v40, "setObject:forKeyedSubscript:", v25, CFSTR("perEncoderIndexDrawCallCount"));
    objc_msgSend(v40, "setObject:forKeyedSubscript:", v9, CFSTR("PerCounterDrawCallData"));
    v53 = 0;
    objc_msgSend(MEMORY[0x24BDD1608], "dataWithJSONObject:options:error:", v40, 1, &v53);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    v51 = v53;
    if (v26)
    {
      v37 = v26;
      v47 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithData:encoding:", v26, 4);
      v27 = v42;
      -[NSDictionary pathExtension](v27, "pathExtension");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = objc_msgSend(v28, "isEqualToString:", CFSTR("json"));

      if ((v29 & 1) == 0)
      {
        v30 = 0;
        for (m = v27; ; m = (NSDictionary *)v34)
        {
          objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
          v32 = (void *)objc_claimAutoreleasedReturnValue();
          v33 = objc_msgSend(v32, "fileExistsAtPath:", m);

          if (!v33)
            break;
          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@_%lu.json"), v27, v30);
          v34 = objc_claimAutoreleasedReturnValue();

          ++v30;
        }
        v27 = m;
      }
      v52 = v51;
      objc_msgSend(v47, "writeToFile:atomically:encoding:error:", v27, 0, 4, &v52);
      v35 = v52;

      v51 = v35;
      v26 = v37;
    }
    else
    {
      v27 = 0;
    }

  }
  else
  {
    v27 = 0;
  }

  return v27;
}

void sub_24113157C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

id DYDerivedCounterInfo::ComputeDerivedCountersFromData(DYDerivedCounterInfo *this, NSDictionary *a2, NSDictionary *a3)
{
  NSDictionary *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  NSDictionary *v14;
  uint64_t *v15;
  _QWORD *v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char **v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t j;
  void *v37;
  id v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t k;
  void *v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t n;
  void *v48;
  id v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t ii;
  unsigned int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  void *v57;
  void *v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  id v62;
  void *v63;
  void *v64;
  char v65;
  int v66;
  id v67;
  id v68;
  id v70;
  uint64_t jj;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  id v81;
  void *v82;
  void *v83;
  uint64_t v84;
  NSObject *v85;
  id v86;
  NSObject *v87;
  NSDictionary *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  void *v94;
  uint64_t v95;
  void *v96;
  void *v97;
  uint64_t m;
  void *v99;
  void *v100;
  NSDictionary *v101;
  id v102;
  id v103;
  id obj;
  _QWORD block[4];
  id v106;
  id v107;
  id v108;
  id v109;
  id v110;
  char **v111;
  void *v112;
  void *v113;
  uint64_t v114;
  unsigned int v115;
  int v116;
  int v117;
  char *v118;
  char **v119;
  uint64_t v120;
  char v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  void *__p;
  _QWORD *v143;
  unint64_t v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  char **v149;
  char *v150;
  unint64_t v151;
  _QWORD v152[2];
  _QWORD v153[2];
  _QWORD v154[2];
  _QWORD v155[2];
  _BYTE v156[128];
  _BYTE v157[128];
  _BYTE v158[128];
  _BYTE v159[128];
  _BYTE v160[128];
  _BYTE v161[128];
  uint64_t v162;

  v162 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v101 = a3;
  v88 = v5;
  v6 = objc_opt_new();
  v7 = *MEMORY[0x24BE39270];
  v89 = (void *)v6;
  -[NSDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", *MEMORY[0x24BE39270]);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = *MEMORY[0x24BE39310];
  -[NSDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", *MEMORY[0x24BE39310]);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v9)
  {
    v70 = 0;
    goto LABEL_102;
  }
  v79 = v8;
  v80 = v7;
  v151 = 0;
  v150 = 0;
  v149 = &v150;
  v145 = 0u;
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v81 = v9;
  obj = v9;
  v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v145, v161, 16);
  if (v10)
  {
    v11 = 0;
    v12 = *(_QWORD *)v146;
    do
    {
      for (i = 0; i != v10; ++i)
      {
        if (*(_QWORD *)v146 != v12)
          objc_enumerationMutation(obj);
        v118 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)(*((_QWORD *)&v145 + 1) + 8 * i)), "UTF8String");
        __p = (void *)(v11 + i);
        std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__emplace_unique_impl<char const*,unsigned long>((uint64_t **)&v149, &v118, &__p);
      }
      v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v145, v161, 16);
      v11 += i;
    }
    while (v10);
  }

  v143 = 0;
  __p = 0;
  v144 = 0;
  std::vector<unsigned long>::reserve(&__p, v151);
  v14 = v101;
  v100 = (void *)objc_opt_new();
  v15 = (uint64_t *)v149;
  if (v149 != &v150)
  {
    do
    {
      v16 = v15 + 4;
      if (*((char *)v15 + 55) < 0)
        v16 = (_QWORD *)*v16;
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v16);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v100, "addObject:", v17);
      v18 = v143;
      if ((unint64_t)v143 >= v144)
      {
        v20 = __p;
        v21 = ((char *)v143 - (_BYTE *)__p) >> 3;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 61)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v23 = v144 - (_QWORD)__p;
        if ((uint64_t)(v144 - (_QWORD)__p) >> 2 > v22)
          v22 = v23 >> 2;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
          v24 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
        {
          v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v144, v24);
          v18 = v143;
          v20 = __p;
        }
        else
        {
          v25 = 0;
        }
        v26 = &v25[8 * v21];
        *(_QWORD *)v26 = v15[7];
        v19 = v26 + 8;
        while (v18 != v20)
        {
          v27 = *--v18;
          *((_QWORD *)v26 - 1) = v27;
          v26 -= 8;
        }
        __p = v26;
        v143 = v19;
        v144 = (unint64_t)&v25[8 * v24];
        if (v20)
          operator delete(v20);
      }
      else
      {
        *v143 = v15[7];
        v19 = v18 + 1;
      }
      v143 = v19;

      v28 = (char *)v15[1];
      if (v28)
      {
        do
        {
          v29 = (char **)v28;
          v28 = *(char **)v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          v29 = (char **)v15[2];
          v30 = *v29 == (char *)v15;
          v15 = (uint64_t *)v29;
        }
        while (!v30);
      }
      v15 = (uint64_t *)v29;
      v14 = v101;
    }
    while (v29 != &v150);
  }
  DYDerivedCounterInfo::DerivedCounterList(this);
  v94 = (void *)objc_claimAutoreleasedReturnValue();
  -[NSDictionary objectForKeyedSubscript:](v14, "objectForKeyedSubscript:", *MEMORY[0x24BE39380]);
  v92 = (void *)objc_claimAutoreleasedReturnValue();
  DYDerivedCounterInfo::BottleneckFunctions((id *)this);
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = *MEMORY[0x24BE39350];
  -[NSDictionary objectForKeyedSubscript:](v14, "objectForKeyedSubscript:", *MEMORY[0x24BE39350]);
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = *MEMORY[0x24BE39360];
  -[NSDictionary objectForKeyedSubscript:](v14, "objectForKeyedSubscript:", *MEMORY[0x24BE39360]);
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  v90 = (void *)objc_opt_new();
  v77 = v31;
  v78 = v32;
  v93 = (void *)objc_opt_new();
  v140 = 0u;
  v141 = 0u;
  v138 = 0u;
  v139 = 0u;
  v33 = v97;
  v34 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v138, v160, 16);
  if (v34)
  {
    v35 = *(_QWORD *)v139;
    do
    {
      for (j = 0; j != v34; ++j)
      {
        if (*(_QWORD *)v139 != v35)
          objc_enumerationMutation(v33);
        v37 = *(void **)(*((_QWORD *)&v138 + 1) + 8 * j);
        v134 = 0u;
        v135 = 0u;
        v136 = 0u;
        v137 = 0u;
        v38 = v37;
        v39 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v134, v159, 16);
        if (v39)
        {
          v40 = *(_QWORD *)v135;
          do
          {
            for (k = 0; k != v39; ++k)
            {
              if (*(_QWORD *)v135 != v40)
                objc_enumerationMutation(v38);
              objc_msgSend(*(id *)(*((_QWORD *)&v134 + 1) + 8 * k), "count");
            }
            v39 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v134, v159, 16);
          }
          while (v39);
        }

      }
      v34 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v138, v160, 16);
    }
    while (v34);
  }

  v42 = (void *)objc_opt_new();
  v132 = 0u;
  v133 = 0u;
  v130 = 0u;
  v131 = 0u;
  v86 = v33;
  v43 = objc_msgSend(v86, "countByEnumeratingWithState:objects:count:", &v130, v158, 16);
  if (v43)
  {
    v95 = *(_QWORD *)v131;
    do
    {
      for (m = 0; m != v43; ++m)
      {
        if (*(_QWORD *)v131 != v95)
          objc_enumerationMutation(v86);
        v44 = *(void **)(*((_QWORD *)&v130 + 1) + 8 * m);
        v126 = 0u;
        v127 = 0u;
        v128 = 0u;
        v129 = 0u;
        v102 = v44;
        v45 = objc_msgSend(v102, "countByEnumeratingWithState:objects:count:", &v126, v157, 16);
        if (v45)
        {
          v46 = *(_QWORD *)v127;
          do
          {
            for (n = 0; n != v45; ++n)
            {
              if (*(_QWORD *)v127 != v46)
                objc_enumerationMutation(v102);
              v48 = *(void **)(*((_QWORD *)&v126 + 1) + 8 * n);
              v122 = 0u;
              v123 = 0u;
              v124 = 0u;
              v125 = 0u;
              v49 = v48;
              v50 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v122, v156, 16);
              if (v50)
              {
                v51 = *(_QWORD *)v123;
                do
                {
                  for (ii = 0; ii != v50; ++ii)
                  {
                    if (*(_QWORD *)v123 != v51)
                      objc_enumerationMutation(v49);
                    objc_msgSend(v42, "addObject:", *(_QWORD *)(*((_QWORD *)&v122 + 1) + 8 * ii));
                  }
                  v50 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v122, v156, 16);
                }
                while (v50);
              }

            }
            v45 = objc_msgSend(v102, "countByEnumeratingWithState:objects:count:", &v126, v157, 16);
          }
          while (v45);
        }

      }
      v43 = objc_msgSend(v86, "countByEnumeratingWithState:objects:count:", &v130, v158, 16);
    }
    while (v43);
  }

  v103 = (id)objc_opt_new();
  v99 = (void *)objc_opt_new();
  v53 = std::thread::hardware_concurrency();
  if (v53 <= 1)
    v54 = 1;
  else
    v54 = v53 >> 1;
  dispatch_get_global_queue(0, 0);
  v85 = objc_claimAutoreleasedReturnValue();
  v87 = dispatch_group_create();
  v55 = objc_msgSend(v42, "count");
  if ((_DWORD)v54)
  {
    v56 = v54;
    do
    {
      v57 = (void *)objc_opt_new();
      objc_msgSend(v103, "addObject:", v57);

      v58 = (void *)objc_opt_new();
      objc_msgSend(v99, "addObject:", v58);

      --v56;
    }
    while (v56);
  }
  v118 = 0;
  v119 = &v118;
  v120 = 0x2020000000;
  v121 = 0;
  v96 = (void *)objc_opt_new();
  if (!*((_BYTE *)v119 + 24) && (_DWORD)v54)
  {
    v59 = 0;
    v60 = 1;
    v61 = v55 / v54;
    v84 = v54;
    while (1)
    {
      v62 = objc_alloc_init(MEMORY[0x24BE39000]);
      objc_msgSend(v96, "addObject:", v62);
      if ((objc_msgSend(v62, "evaluateScriptCode:", v92) & 1) == 0)
      {
        v70 = 0;
        goto LABEL_98;
      }
      objc_msgSend(v94, "objectAtIndexedSubscript:", 0);
      v63 = (void *)objc_claimAutoreleasedReturnValue();
      v64 = (void *)objc_opt_new();
      v65 = objc_msgSend(v62, "prepareCounterNames:softwareCounterNames:derivedCounterNames:", obj, v64, v63);

      if ((v65 & 1) == 0)
        break;
      objc_msgSend(v62, "exportCounterValues:", v91);
      if ((_DWORD)v54 == v60)
        v66 = objc_msgSend(v42, "count");
      else
        v66 = (v59 + 1) * v61;
      block[0] = MEMORY[0x24BDAC760];
      block[1] = 3321888768;
      block[2] = ___ZN20DYDerivedCounterInfo30ComputeDerivedCountersFromDataEP12NSDictionaryS1__block_invoke;
      block[3] = &unk_251122E80;
      v67 = v96;
      v115 = v60 - 1;
      v116 = v59 * v61;
      v106 = v67;
      v111 = &v118;
      v117 = v66;
      v107 = v42;
      v68 = v63;
      v108 = v68;
      v109 = v103;
      v113 = 0;
      v114 = 0;
      v112 = 0;
      std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(&v112, __p, (uint64_t)v143, ((char *)v143 - (_BYTE *)__p) >> 3);
      v110 = v99;
      dispatch_group_async(v87, v85, block);

      v54 = v84;
      if (v112)
      {
        v113 = v112;
        operator delete(v112);
      }

      if (!*((_BYTE *)v119 + 24))
      {
        ++v59;
        if (v60++ < v84)
          continue;
      }
      goto LABEL_88;
    }
    v70 = 0;
    goto LABEL_97;
  }
LABEL_88:
  dispatch_group_wait(v87, 0xFFFFFFFFFFFFFFFFLL);
  if (!*((_BYTE *)v119 + 24))
  {
    if ((_DWORD)v54)
    {
      for (jj = 0; jj != v54; ++jj)
      {
        objc_msgSend(v103, "objectAtIndexedSubscript:", jj);
        v72 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v90, "addObjectsFromArray:", v72);

        objc_msgSend(v99, "objectAtIndexedSubscript:", jj);
        v73 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v93, "addObjectsFromArray:", v73);

      }
    }
    objc_msgSend(v94, "objectAtIndexedSubscript:", 0);
    v74 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v74, "arrayByAddingObjectsFromArray:", v100);
    v62 = (id)objc_claimAutoreleasedReturnValue();

    v154[0] = v80;
    v154[1] = v79;
    v155[0] = v93;
    v155[1] = v62;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v155, v154, 2);
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v89, "setObject:forKeyedSubscript:", v63, *MEMORY[0x24BE39370]);
    objc_msgSend(v89, "setObject:forKeyedSubscript:", v91, v78);
    v152[0] = v80;
    v152[1] = v79;
    v153[0] = v90;
    v153[1] = v94;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v153, v152, 2);
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v89, "setObject:forKeyedSubscript:", v75, *MEMORY[0x24BE39368]);

    objc_msgSend(v89, "setObject:forKeyedSubscript:", v83, v77);
    objc_msgSend(v89, "setObject:forKeyedSubscript:", v82, *MEMORY[0x24BE39358]);
    v70 = v89;
LABEL_97:

LABEL_98:
    goto LABEL_99;
  }
  v70 = 0;
LABEL_99:

  _Block_object_dispose(&v118, 8);
  if (__p)
  {
    v143 = __p;
    operator delete(__p);
  }
  std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::destroy((uint64_t)&v149, v150);
  v9 = v81;
LABEL_102:

  return v70;
}

void sub_241132270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,uint64_t a27,void *a28,uint64_t a29,void *a30,void *a31,uint64_t a32,void *a33)
{
  void *v33;
  void *v35;

  v35 = (void *)STACK[0x2A8];
  if (STACK[0x2A8])
  {
    STACK[0x2B0] = (unint64_t)v35;
    operator delete(v35);
  }
  std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::destroy((uint64_t)&STACK[0x300], (char *)STACK[0x308]);

  _Unwind_Resume(a1);
}

void std::vector<unsigned long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void ___ZN20DYDerivedCounterInfo30ComputeDerivedCountersFromDataEP12NSDictionaryS1__block_invoke(uint64_t a1)
{
  void *v2;
  unsigned int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  id *v15;
  id *v16;
  id v17;
  void *v18;
  void *v19;
  _QWORD v20[3];
  void **v21;

  objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", *(unsigned int *)(a1 + 104));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24))
  {
    v3 = *(_DWORD *)(a1 + 108);
    while (v3 < *(_DWORD *)(a1 + 112))
    {
      objc_msgSend(*(id *)(a1 + 40), "objectAtIndexedSubscript:", v3);
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      v5 = (void *)objc_opt_new();
      objc_msgSend(v2, "prepareCounterValues:softwareCounterValues:", v4, v5);

      objc_msgSend(v2, "evaluateDerivedCounters");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = (void *)objc_msgSend(v6, "mutableCopy");

      if (!v7 || (v8 = objc_msgSend(v7, "count"), v8 != objc_msgSend(*(id *)(a1 + 48), "count")))
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = 1;

        break;
      }
      objc_msgSend(*(id *)(a1 + 56), "objectAtIndexedSubscript:", *(unsigned int *)(a1 + 104));
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "addObject:", v7);

      std::vector<NSNumber * {__strong}>::vector(v20, objc_msgSend(v4, "count"));
      v10 = *(_QWORD *)(a1 + 80);
      if (*(_QWORD *)(a1 + 88) != v10)
      {
        v11 = 0;
        do
        {
          objc_msgSend(v4, "objectAtIndexedSubscript:", *(_QWORD *)(v10 + 8 * v11));
          v12 = objc_claimAutoreleasedReturnValue();
          v13 = *(void **)(v20[0] + 8 * v11);
          *(_QWORD *)(v20[0] + 8 * v11) = v12;

          ++v11;
          v10 = *(_QWORD *)(a1 + 80);
        }
        while (v11 < (*(_QWORD *)(a1 + 88) - v10) >> 3);
      }
      objc_msgSend(MEMORY[0x24BDBCEB8], "arrayWithCapacity:", objc_msgSend(v4, "count"));
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      v15 = (id *)v20[0];
      v16 = (id *)v20[1];
      while (v15 != v16)
      {
        v17 = *v15;
        objc_msgSend(v14, "addObject:", v17);

        ++v15;
      }
      objc_msgSend(v7, "arrayByAddingObjectsFromArray:", v14);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(*(id *)(a1 + 64), "objectAtIndexedSubscript:", *(unsigned int *)(a1 + 104));
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "addObject:", v18);

      v21 = (void **)v20;
      std::vector<NSNumber * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v21);

      ++v3;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24))
        break;
    }
  }

}

void sub_2411327F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  a12 = (void **)&a9;
  std::vector<NSNumber * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_80c39_ZTSNSt3__16vectorImNS_9allocatorImEEEE(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  v2 = (_QWORD *)(a1 + 80);
  v2[2] = 0;
  return std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(v2, *(const void **)(a2 + 80), *(_QWORD *)(a2 + 88), (uint64_t)(*(_QWORD *)(a2 + 88) - *(_QWORD *)(a2 + 80)) >> 3);
}

void __destroy_helper_block_ea8_80c39_ZTSNSt3__16vectorImNS_9allocatorImEEEE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(_QWORD *)(a1 + 88) = v2;
    operator delete(v2);
  }
}

void ___ZN12_GLOBAL__N_128CounterIndicesFromCounterSetEP5NSSetP7NSArray_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  id v6;

  v6 = a2;
  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:"))
  {
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInteger:", a3);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(a1 + 40), "setObject:forKeyedSubscript:", v5, v6);

  }
}

void sub_24113292C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(a1, *(void ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(int a1, void **__p)
{
  void **v2;
  void **v3;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  void *i;
  unint64_t v15;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(void **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, (unsigned __int8 *)i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  i = operator new(0x28uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v9;
  *((_OWORD *)i + 1) = *(_OWORD *)a3;
  *((_QWORD *)i + 4) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *(_QWORD *)i = *v24;
LABEL_38:
    *v24 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v16;
  *v16 = i;
  *(_QWORD *)(v23 + 8 * v3) = v16;
  if (*(_QWORD *)i)
  {
    v25 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*v7;
  return i;
}

void sub_241132C2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void **v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v3 = v2;
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v5, (uint64_t *)a2, v3);
}

uint64_t std::equal_to<std::string>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t result;

  v3 = a3;
  v4 = a2[23];
  if ((v4 & 0x80u) == 0)
    v5 = a2[23];
  else
    v5 = *((_QWORD *)a2 + 1);
  v6 = a3[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    v3 = *(unsigned __int8 **)a3;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a2, v3, *((_QWORD *)a2 + 1)) == 0;
  if (!a2[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a2++;
    v9 = v10;
    v12 = *v3++;
    v11 = v12;
    v14 = v8-- != 0;
    result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;

  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      v11 = v7 + v9;
      v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      v14 = v8 + a3 + v7 + v4;
      v15 = v14 + v5;
      v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v18 = v17 + v6 + v9;
      v19 = __ROR8__(v18, 44);
      v20 = v18 + v10;
      v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      v23 = *a2;
      v22 = a2 + 4;
      v24 = v23 - 0x4B6D499041670D8DLL * v5;
      v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v26 = *(v22 - 3);
        v27 = v24 + v15 + v11 + v26;
        v28 = v22[2];
        v29 = v22[3];
        v30 = v22[1];
        v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        v31 = v13 + v20;
        v32 = *(v22 - 2);
        v33 = *(v22 - 1);
        v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        v35 = v34 + v20 + v33;
        v36 = v34 + v26 + v32;
        v15 = v36 + v33;
        v37 = __ROR8__(v36, 44) + v34;
        v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        v16 = v37 + __ROR8__(v35 + v38, 21);
        v39 = v24 + v21 + *v22;
        v20 = v39 + v30 + v28 + v29;
        v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        v13 = v38;
        v25 += 64;
      }
      while (v25);
      v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](_DWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (a2 < 9)
  {
    if (a2 < 4)
    {
      result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    v3 = *(_QWORD *)((char *)a1 + a2 - 8);
    v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = a1[1];
  v3 = 0xB492B66FBE98F273 * *a1;
  v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8);
  v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v2 = *(_QWORD *)((char *)a1 + a2 - 16);
  v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  v5 = a1[2];
  v4 = a1[3];
  v6 = __ROR8__(v3 + v4, 52);
  v7 = v3 + a1[1];
  v8 = __ROR8__(v7, 7);
  v9 = v7 + v5;
  v10 = *(_QWORD *)((char *)a1 + a2 - 32) + v5;
  v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  v12 = *(_QWORD *)((char *)a1 + a2 - 24) + v10 + v2;
  v13 = 0xC3A5C85C97CB3127 * (v12 + *(_QWORD *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v13 == v6)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__construct_node_hash<std::string const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_241133538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__construct_node_hash<std::string const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v9->__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 16);
  }
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_2411335E0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v6 == v13)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__erase_unique<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a1, a2);
  if (result)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void **v3;
  void *__p;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (void **)__p;
  __p = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

_QWORD *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::string>>,0>(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::vector<std::string>>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  char *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[2];
  char v27;

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  v16 = (char *)operator new(0x40uLL);
  v26[0] = v16;
  v26[1] = a1 + 16;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v9;
  *((_OWORD *)v16 + 1) = *(_OWORD *)a3;
  *((_QWORD *)v16 + 4) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_OWORD *)(v16 + 40) = *(_OWORD *)(a3 + 24);
  *((_QWORD *)v16 + 7) = *(_QWORD *)(a3 + 40);
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  v27 = 1;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v24 >= v10)
          v24 %= v10;
      }
      else
      {
        v24 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_241133BF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::__split_buffer<std::string>::pointer end;
  __int128 v12;
  uint64_t v13;
  std::__split_buffer<std::string> __v;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<float>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9)
    v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<GPUTools::MTL::Utils::DYMTLIndirectArgumentBufferInfo>>>(v7, v9);
  else
    v10 = 0;
  end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    end = __v.__end_;
  }
  else
  {
    v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_241133D60(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

void std::vector<BOOL>::reserve(char **a1, unint64_t a2)
{
  unint64_t v3;
  char *v4;
  __int128 v5;
  char *v6;
  int v7;
  char *v8;
  int v9;
  char *v10;
  __int128 v11;

  if (a2 > (_QWORD)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v10 = 0;
    v11 = 0uLL;
    std::vector<BOOL>::__vallocate[abi:ne180100](&v10, a2);
    v3 = (unint64_t)a1[1];
    v8 = *a1;
    v9 = 0;
    v6 = &v8[8 * (v3 >> 6)];
    v7 = v3 & 0x3F;
    std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    v4 = *a1;
    *a1 = v10;
    v10 = v4;
    v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    v11 = v5;
    if (v4)
      operator delete(v4);
  }
}

void sub_241133E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *std::vector<BOOL>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  void *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<float>::__throw_length_error[abi:ne180100]();
  result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;

  v4 = a1[1];
  v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41)
      v6 = (v5 - 1) >> 6;
    else
      v6 = 0;
    *(_QWORD *)(*a1 + 8 * v6) = 0;
  }
  v7 = *(_DWORD *)(a2 + 8);
  v8 = *(_QWORD *)a3;
  v9 = *(_DWORD *)(a3 + 8);
  v10 = *a1 + 8 * (v4 >> 6);
  v16 = *(_QWORD *)a2;
  v17 = v7;
  v14 = v8;
  v15 = v9;
  v12 = v10;
  v13 = v4 & 0x3F;
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(&v16, &v14, &v12, (uint64_t)&v11);
}

void std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;

  v5 = *((_DWORD *)a1 + 2);
  v6 = *a2;
  v7 = *((_DWORD *)a2 + 2);
  v16 = *a1;
  v17 = v5;
  v14 = v6;
  v15 = v7;
  v8 = *((_DWORD *)a3 + 2);
  v12 = *a3;
  v13 = v8;
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  v9 = v19;
  v10 = v20;
  v11 = v21;
  *(_QWORD *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(_QWORD *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  _QWORD *v4;
  int v5;
  int i;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  v4 = *(_QWORD **)a1;
  v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(_QWORD *)a1 != *(_QWORD *)a2 || v5 != *(_DWORD *)(a2 + 8); v5 = *(_DWORD *)(a1 + 8))
  {
    v8 = *(uint64_t **)a3;
    v9 = 1 << i;
    if (((*v4 >> v5) & 1) != 0)
      v10 = *v8 | v9;
    else
      v10 = *v8 & ~v9;
    *v8 = v10;
    if (v5 == 63)
    {
      v11 = 0;
      *(_QWORD *)a1 = v4 + 1;
    }
    else
    {
      v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      i = 0;
      *(_QWORD *)a3 += 8;
    }
    else
    {
      i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    v4 = *(_QWORD **)a1;
  }
  *(_QWORD *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(_QWORD *)(a4 + 16) = *(_QWORD *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

void std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__emplace_unique_impl<char const*,unsigned long>(uint64_t **a1, char **a2, _QWORD *a3)
{
  uint64_t **v4;
  uint64_t *v5;
  void **v6;
  uint64_t v8;
  void *__p;
  uint64_t v10;

  std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__construct_node<char const*,unsigned long>((uint64_t)a1, a2, a3, (uint64_t)&__p);
  v4 = (uint64_t **)std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__find_equal<std::__value_type<std::string,unsigned long>>((uint64_t)a1, &v8, (const void **)__p + 4);
  v5 = *v4;
  if (*v4)
  {
    v6 = (void **)__p;
    __p = 0;
    if (v6)
      std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned long>,void *>>>::operator()[abi:ne180100]((uint64_t)&v10, v6);
  }
  else
  {
    std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__insert_node_at(a1, v8, v4, (uint64_t *)__p);
    return (uint64_t *)__p;
  }
  return v5;
}

void sub_241134144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned long>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__construct_node<char const*,unsigned long>@<X0>(uint64_t a1@<X0>, char **a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v7 = a1 + 8;
  v8 = operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  result = std::string::basic_string[abi:ne180100]<0>(v8 + 4, *a2);
  v8[7] = *a3;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_2411341D8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned long>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__find_equal<std::__value_type<std::string,unsigned long>>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,unsigned long>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

_QWORD *std::vector<NSNumber * {__strong}>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MTLSamplePosition>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_241134598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<NSNumber * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<NSNumber * {__strong}>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 1);
        v4 -= 8;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<MTLSamplePosition>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241134674(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_2411348FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2411349CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241134A6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241134BD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;

  _Block_object_dispose((const void *)(v4 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_241134FC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_24113533C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_241135558(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241135628(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2411357F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_241135A4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241135B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241135BE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241135DC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

const char *GPUTools::MTL::GetMTLAccelerationStructureCommandSubstreamSelectMethodAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLAccelerationStructureCommandSubstreamSelectMethodEmpirical";
      v3 = "Empirical";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLAccelerationStructureCommandSubstreamSelectMethodRoundRobin";
      v3 = "RoundRobin";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLAccelerationStructureCommandSubstreamSelectMethodRandom";
      v3 = "Random";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLAccelerationStructureCommandSubstreamSelectMethodGreedy";
      v3 = "Greedy";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLAccelerationStructureInstanceDescriptorTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLAccelerationStructureInstanceDescriptorTypeDefault";
      v3 = "Default";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLAccelerationStructureInstanceDescriptorTypeUserID";
      v3 = "UserID";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLAccelerationStructureInstanceDescriptorTypeMotion";
      v3 = "Motion";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLAccelerationStructureInstanceDescriptorTypeIndirect";
      v3 = "Indirect";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLAccelerationStructureInstanceDescriptorTypeIndirectMotion";
      v3 = "IndirectMotion";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLAccelerationStructureInstanceOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLAccelerationStructureInstanceOptionNone";
      v5 = "None";
      goto LABEL_7;
    case 1uLL:
      v4 = "MTLAccelerationStructureInstanceOptionDisableTriangleCulling";
      v5 = "DisableTriangleCulling";
      goto LABEL_7;
    case 2uLL:
      v4 = "MTLAccelerationStructureInstanceOptionTriangleFrontFacingWindingCounterClockwise";
      v5 = "TriangleFrontFacingWindingCounterClockwise";
      goto LABEL_7;
    case 4uLL:
      v4 = "MTLAccelerationStructureInstanceOptionOpaque";
      v5 = "Opaque";
      goto LABEL_7;
    case 8uLL:
      v4 = "MTLAccelerationStructureInstanceOptionNonOpaque";
      v5 = "NonOpaque";
LABEL_7:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLAccelerationStructureRefitOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLAccelerationStructureRefitOptionVertexData";
  if (a2)
    v3 = "VertexData";
  v4 = "MTLAccelerationStructureRefitOptionPerPrimitiveData";
  if (a2)
    v4 = "PerPrimitiveData";
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLAccelerationStructureUsageAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLAccelerationStructureUsageNone";
      v5 = "None";
      goto LABEL_7;
    case 1uLL:
      v4 = "MTLAccelerationStructureUsageRefit";
      v5 = "Refit";
      goto LABEL_7;
    case 2uLL:
      v4 = "MTLAccelerationStructureUsagePreferFastBuild";
      v5 = "PreferFastBuild";
      goto LABEL_7;
    case 4uLL:
      v4 = "MTLAccelerationStructureUsageExtendedLimits";
      v5 = "ExtendedLimits";
      goto LABEL_7;
    case 8uLL:
      v4 = "MTLAccelerationStructureUsagePrivateDeterministicBuild";
      v5 = "PrivateDeterministicBuild";
LABEL_7:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLAllocationTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLAllocationTypeUnknown";
  if (a2)
    v3 = "Unknown";
  v4 = "MTLAllocationTypeResource";
  if (a2)
    v4 = "Resource";
  v5 = "Heap";
  if (!a2)
    v5 = "MTLAllocationTypeHeap";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLArgumentBuffersTierAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLArgumentBuffersTier2";
  if (a2)
    v3 = "2";
  v4 = "MTLArgumentBuffersTier1";
  if (a2)
    v4 = "1";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLArgumentImageBlockKindAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLArgumentImageBlockKindPrivateImplicit";
  if (a2)
    v3 = "PrivateImplicit";
  v4 = "MTLArgumentImageBlockKindPrivateExplicit";
  if (a2)
    v4 = "PrivateExplicit";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLArgumentTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLArgumentTypeBuffer";
      v5 = "Buffer";
      goto LABEL_25;
    case 1uLL:
      v4 = "MTLArgumentTypeThreadgroupMemory";
      v5 = "ThreadgroupMemory";
      goto LABEL_25;
    case 2uLL:
      v4 = "MTLArgumentTypeTexture";
      v5 = "Texture";
      goto LABEL_25;
    case 3uLL:
      v4 = "MTLArgumentTypeSampler";
      v5 = "Sampler";
      goto LABEL_25;
    case 4uLL:
      v4 = "MTLArgumentTypePrivateIndirectConstant";
      v5 = "PrivateIndirectConstant";
      goto LABEL_25;
    case 0xFuLL:
      v4 = "MTLArgumentTypePrivateBuiltIn";
      v5 = "PrivateBuiltIn";
      goto LABEL_25;
    case 0x10uLL:
      v4 = "MTLArgumentTypeImageblockData";
      v5 = "ImageblockData";
      goto LABEL_25;
    case 0x11uLL:
      v4 = "MTLArgumentTypeImageblock";
      v5 = "Imageblock";
      goto LABEL_25;
    case 0x12uLL:
      v4 = "MTLArgumentTypePrivateValue";
      v5 = "PrivateValue";
      goto LABEL_25;
    case 0x13uLL:
      v4 = "MTLArgumentTypePrivateRenderPipeline";
      v5 = "PrivateRenderPipeline";
      goto LABEL_25;
    case 0x14uLL:
      v4 = "MTLArgumentTypePrivateComputePipeline";
      v5 = "PrivateComputePipeline";
      goto LABEL_25;
    case 0x15uLL:
      v4 = "MTLArgumentTypePrivateIndirectCommandBuffer";
      v5 = "PrivateIndirectCommandBuffer";
      goto LABEL_25;
    case 0x16uLL:
      v4 = "MTLArgumentTypePrivateByVal";
      v5 = "PrivateByVal";
      goto LABEL_25;
    case 0x17uLL:
      v4 = "MTLArgumentTypePrivateFunctionPointer";
      v5 = "PrivateFunctionPointer";
      goto LABEL_25;
    case 0x18uLL:
      v4 = "MTLArgumentTypeVisibleFunctionTable";
      v5 = "VisibleFunctionTable";
      goto LABEL_25;
    case 0x19uLL:
      v4 = "MTLArgumentTypePrimitiveAccelerationStructure";
      v5 = "PrimitiveAccelerationStructure";
      goto LABEL_25;
    case 0x1AuLL:
      v4 = "MTLArgumentTypeInstanceAccelerationStructure";
      v5 = "InstanceAccelerationStructure";
      goto LABEL_25;
    case 0x1BuLL:
      v4 = "MTLArgumentTypeIntersectionFunctionTable";
      v5 = "IntersectionFunctionTable";
      goto LABEL_25;
    case 0x1CuLL:
      v4 = "MTLArgumentTypePrivatePointer";
      v5 = "PrivatePointer";
      goto LABEL_25;
    case 0x1DuLL:
      v4 = "MTLArgumentTypePrivateStruct";
      v5 = "PrivateStruct";
      goto LABEL_25;
    case 0x22uLL:
      v4 = "MTLArgumentTypePrivateObjectPayload";
      v5 = "PrivateObjectPayload";
      goto LABEL_25;
    case 0x23uLL:
      v4 = "MTLArgumentTypePrivateMesh";
      v5 = "PrivateMesh";
      goto LABEL_25;
    case 0x24uLL:
      v4 = "MTLArgumentTypePrivateDepthStencilState";
      v5 = "PrivateDepthStencilState";
LABEL_25:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLAttributeFormatAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLAttributeFormatInvalid";
      v3 = "Invalid";
      goto LABEL_59;
    case 1uLL:
      v2 = "MTLAttributeFormatUChar2";
      v3 = "UChar2";
      goto LABEL_59;
    case 2uLL:
      v2 = "MTLAttributeFormatUChar3";
      v3 = "UChar3";
      goto LABEL_59;
    case 3uLL:
      v2 = "MTLAttributeFormatUChar4";
      v3 = "UChar4";
      goto LABEL_59;
    case 4uLL:
      v2 = "MTLAttributeFormatChar2";
      v3 = "Char2";
      goto LABEL_59;
    case 5uLL:
      v2 = "MTLAttributeFormatChar3";
      v3 = "Char3";
      goto LABEL_59;
    case 6uLL:
      v2 = "MTLAttributeFormatChar4";
      v3 = "Char4";
      goto LABEL_59;
    case 7uLL:
      v2 = "MTLAttributeFormatUChar2Normalized";
      v3 = "UChar2Normalized";
      goto LABEL_59;
    case 8uLL:
      v2 = "MTLAttributeFormatUChar3Normalized";
      v3 = "UChar3Normalized";
      goto LABEL_59;
    case 9uLL:
      v2 = "MTLAttributeFormatUChar4Normalized";
      v3 = "UChar4Normalized";
      goto LABEL_59;
    case 0xAuLL:
      v2 = "MTLAttributeFormatChar2Normalized";
      v3 = "Char2Normalized";
      goto LABEL_59;
    case 0xBuLL:
      v2 = "MTLAttributeFormatChar3Normalized";
      v3 = "Char3Normalized";
      goto LABEL_59;
    case 0xCuLL:
      v2 = "MTLAttributeFormatChar4Normalized";
      v3 = "Char4Normalized";
      goto LABEL_59;
    case 0xDuLL:
      v2 = "MTLAttributeFormatUShort2";
      v3 = "UShort2";
      goto LABEL_59;
    case 0xEuLL:
      v2 = "MTLAttributeFormatUShort3";
      v3 = "UShort3";
      goto LABEL_59;
    case 0xFuLL:
      v2 = "MTLAttributeFormatUShort4";
      v3 = "UShort4";
      goto LABEL_59;
    case 0x10uLL:
      v2 = "MTLAttributeFormatShort2";
      v3 = "Short2";
      goto LABEL_59;
    case 0x11uLL:
      v2 = "MTLAttributeFormatShort3";
      v3 = "Short3";
      goto LABEL_59;
    case 0x12uLL:
      v2 = "MTLAttributeFormatShort4";
      v3 = "Short4";
      goto LABEL_59;
    case 0x13uLL:
      v2 = "MTLAttributeFormatUShort2Normalized";
      v3 = "UShort2Normalized";
      goto LABEL_59;
    case 0x14uLL:
      v2 = "MTLAttributeFormatUShort3Normalized";
      v3 = "UShort3Normalized";
      goto LABEL_59;
    case 0x15uLL:
      v2 = "MTLAttributeFormatUShort4Normalized";
      v3 = "UShort4Normalized";
      goto LABEL_59;
    case 0x16uLL:
      v2 = "MTLAttributeFormatShort2Normalized";
      v3 = "Short2Normalized";
      goto LABEL_59;
    case 0x17uLL:
      v2 = "MTLAttributeFormatShort3Normalized";
      v3 = "Short3Normalized";
      goto LABEL_59;
    case 0x18uLL:
      v2 = "MTLAttributeFormatShort4Normalized";
      v3 = "Short4Normalized";
      goto LABEL_59;
    case 0x19uLL:
      v2 = "MTLAttributeFormatHalf2";
      v3 = "Half2";
      goto LABEL_59;
    case 0x1AuLL:
      v2 = "MTLAttributeFormatHalf3";
      v3 = "Half3";
      goto LABEL_59;
    case 0x1BuLL:
      v2 = "MTLAttributeFormatHalf4";
      v3 = "Half4";
      goto LABEL_59;
    case 0x1CuLL:
      v2 = "MTLAttributeFormatFloat";
      v3 = "Float";
      goto LABEL_59;
    case 0x1DuLL:
      v2 = "MTLAttributeFormatFloat2";
      v3 = "Float2";
      goto LABEL_59;
    case 0x1EuLL:
      v2 = "MTLAttributeFormatFloat3";
      v3 = "Float3";
      goto LABEL_59;
    case 0x1FuLL:
      v2 = "MTLAttributeFormatFloat4";
      v3 = "Float4";
      goto LABEL_59;
    case 0x20uLL:
      v2 = "MTLAttributeFormatInt";
      v3 = "Int";
      goto LABEL_59;
    case 0x21uLL:
      v2 = "MTLAttributeFormatInt2";
      v3 = "Int2";
      goto LABEL_59;
    case 0x22uLL:
      v2 = "MTLAttributeFormatInt3";
      v3 = "Int3";
      goto LABEL_59;
    case 0x23uLL:
      v2 = "MTLAttributeFormatInt4";
      v3 = "Int4";
      goto LABEL_59;
    case 0x24uLL:
      v2 = "MTLAttributeFormatUInt";
      v3 = "UInt";
      goto LABEL_59;
    case 0x25uLL:
      v2 = "MTLAttributeFormatUInt2";
      v3 = "UInt2";
      goto LABEL_59;
    case 0x26uLL:
      v2 = "MTLAttributeFormatUInt3";
      v3 = "UInt3";
      goto LABEL_59;
    case 0x27uLL:
      v2 = "MTLAttributeFormatUInt4";
      v3 = "UInt4";
      goto LABEL_59;
    case 0x28uLL:
      v2 = "MTLAttributeFormatInt1010102Normalized";
      v3 = "Int1010102Normalized";
      goto LABEL_59;
    case 0x29uLL:
      v2 = "MTLAttributeFormatUInt1010102Normalized";
      v3 = "UInt1010102Normalized";
      goto LABEL_59;
    case 0x2AuLL:
      v2 = "MTLAttributeFormatUChar4Normalized_BGRA";
      v3 = "UChar4Normalized_BGRA";
      goto LABEL_59;
    case 0x2BuLL:
      v2 = "MTLAttributeFormatUInt_VertexID";
      v3 = "UInt_VertexID";
      goto LABEL_59;
    case 0x2CuLL:
      v2 = "MTLAttributeFormatUInt_InstanceID";
      v3 = "UInt_InstanceID";
      goto LABEL_59;
    case 0x2DuLL:
      v2 = "MTLAttributeFormatUChar";
      v3 = "UChar";
      goto LABEL_59;
    case 0x2EuLL:
      v2 = "MTLAttributeFormatChar";
      v3 = "Char";
      goto LABEL_59;
    case 0x2FuLL:
      v2 = "MTLAttributeFormatUCharNormalized";
      v3 = "UCharNormalized";
      goto LABEL_59;
    case 0x30uLL:
      v2 = "MTLAttributeFormatCharNormalized";
      v3 = "CharNormalized";
      goto LABEL_59;
    case 0x31uLL:
      v2 = "MTLAttributeFormatUShort";
      v3 = "UShort";
      goto LABEL_59;
    case 0x32uLL:
      v2 = "MTLAttributeFormatShort";
      v3 = "Short";
      goto LABEL_59;
    case 0x33uLL:
      v2 = "MTLAttributeFormatUShortNormalized";
      v3 = "UShortNormalized";
      goto LABEL_59;
    case 0x34uLL:
      v2 = "MTLAttributeFormatShortNormalized";
      v3 = "ShortNormalized";
      goto LABEL_59;
    case 0x35uLL:
      v2 = "MTLAttributeFormatHalf";
      v3 = "Half";
      goto LABEL_59;
    case 0x36uLL:
      v2 = "MTLAttributeFormatFloatRG11B10";
      v3 = "FloatRG11B10";
      goto LABEL_59;
    case 0x37uLL:
      v2 = "MTLAttributeFormatFloatRGB9E5";
      v3 = "FloatRGB9E5";
LABEL_59:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBarrierScopeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLBarrierScopeRenderTargets";
  if (a2)
    v3 = "RenderTargets";
  v4 = "MTLBarrierScopeTextures";
  if (a2)
    v4 = "Textures";
  v5 = "Buffers";
  if (!a2)
    v5 = "MTLBarrierScopeBuffers";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this == (GPUTools::MTL *)4)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLBinaryArchiveErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLBinaryArchiveErrorNone";
      v3 = "None";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLBinaryArchiveErrorInvalidFile";
      v3 = "InvalidFile";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLBinaryArchiveErrorUnexpectedElement";
      v3 = "UnexpectedElement";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLBinaryArchiveErrorCompilationFailure";
      v3 = "CompilationFailure";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLBinaryArchiveErrorInternalError";
      v3 = "InternalError";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBinaryArchiveSerializationOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;

  result = "Unknown";
  if ((uint64_t)this > 15)
  {
    v6 = "MTLBinaryArchiveSerializationSpecializedFunctionsAspectIfAvailable";
    if (a2)
      v6 = "SpecializedFunctionsAspectIfAvailable";
    v7 = "MTLBinaryArchiveSerializationSpecializedFunctionsAspectAlways";
    if (a2)
      v7 = "SpecializedFunctionsAspectAlways";
    if (this != (GPUTools::MTL *)128)
      v7 = "Unknown";
    if (this != (GPUTools::MTL *)64)
      v6 = v7;
    v8 = "MTLBinaryArchiveSerializationDescriptorAspectIfAvailable";
    if (a2)
      v8 = "DescriptorAspectIfAvailable";
    v9 = "MTLBinaryArchiveSerializationDescriptorAspectAlways";
    if (a2)
      v9 = "DescriptorAspectAlways";
    if (this != (GPUTools::MTL *)32)
      v9 = "Unknown";
    if (this != (GPUTools::MTL *)16)
      v8 = v9;
    if ((uint64_t)this <= 63)
      return v8;
    else
      return v6;
  }
  else
  {
    switch((unint64_t)this)
    {
      case 1uLL:
        v4 = "MTLBinaryArchiveSerializationAtomic";
        v5 = "Atomic";
        goto LABEL_26;
      case 2uLL:
        v4 = "MTLBinaryArchiveSerializationChecksum";
        v5 = "Checksum";
        goto LABEL_26;
      case 4uLL:
        v4 = "MTLBinaryArchiveSerializationDeviceAspectIfAvailable";
        v5 = "DeviceAspectIfAvailable";
        goto LABEL_26;
      case 8uLL:
        v4 = "MTLBinaryArchiveSerializationDeviceAspectAlways";
        v5 = "DeviceAspectAlways";
LABEL_26:
        if (a2)
          result = v5;
        else
          result = v4;
        break;
      default:
        return result;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBinaryArchiveStorageOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;

  if ((uint64_t)this > 15)
  {
    if (this == (GPUTools::MTL *)16)
    {
      return "MTLBinaryArchiveLoadToRecompile";
    }
    else if (this == (GPUTools::MTL *)32)
    {
      return "MTLBinaryArchiveSkipAIRValidation";
    }
    else if (this == (GPUTools::MTL *)64)
    {
      return "MTLBinaryArchiveRecompileTarget";
    }
    else
    {
      return "Unknown";
    }
  }
  else
  {
    switch((unint64_t)this)
    {
      case 1uLL:
        v2 = "MTLBinaryArchiveStoreDescriptors";
        v3 = "Descriptors";
        break;
      case 2uLL:
        v2 = "MTLBinaryArchiveStoreFunctions";
        v3 = "Functions";
        break;
      case 4uLL:
        v2 = "MTLBinaryArchiveStoreAIR";
        v3 = "AIR";
        break;
      case 8uLL:
        v2 = "MTLBinaryArchiveSupportAIRNT";
        v3 = "SupportAIRNT";
        break;
      default:
        return "Unknown";
    }
    if (a2)
      return v3;
    else
      return v2;
  }
}

const char *GPUTools::MTL::GetMTLBindingAccessAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLBindingAccessWriteOnly";
  if (a2)
    v3 = "WriteOnly";
  v4 = "MTLBindingAccessReadWrite";
  if (a2)
    v4 = "ReadWrite";
  v5 = "ReadOnly";
  if (!a2)
    v5 = "MTLBindingAccessReadOnly";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLBindingTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLBindingTypeBuffer";
      v5 = "Buffer";
      goto LABEL_25;
    case 1uLL:
      v4 = "MTLBindingTypeThreadgroupMemory";
      v5 = "ThreadgroupMemory";
      goto LABEL_25;
    case 2uLL:
      v4 = "MTLBindingTypeTexture";
      v5 = "Texture";
      goto LABEL_25;
    case 3uLL:
      v4 = "MTLBindingTypeSampler";
      v5 = "Sampler";
      goto LABEL_25;
    case 4uLL:
      v4 = "MTLArgumentTypePrivateIndirectConstant";
      v5 = "PrivateIndirectConstant";
      goto LABEL_25;
    case 0xFuLL:
      v4 = "MTLArgumentTypePrivateBuiltIn";
      v5 = "PrivateBuiltIn";
      goto LABEL_25;
    case 0x10uLL:
      v4 = "MTLBindingTypeImageblockData";
      v5 = "ImageblockData";
      goto LABEL_25;
    case 0x11uLL:
      v4 = "MTLBindingTypeImageblock";
      v5 = "Imageblock";
      goto LABEL_25;
    case 0x12uLL:
      v4 = "MTLArgumentTypePrivateValue";
      v5 = "PrivateValue";
      goto LABEL_25;
    case 0x13uLL:
      v4 = "MTLArgumentTypePrivateRenderPipeline";
      v5 = "PrivateRenderPipeline";
      goto LABEL_25;
    case 0x14uLL:
      v4 = "MTLArgumentTypePrivateComputePipeline";
      v5 = "PrivateComputePipeline";
      goto LABEL_25;
    case 0x15uLL:
      v4 = "MTLArgumentTypePrivateIndirectCommandBuffer";
      v5 = "PrivateIndirectCommandBuffer";
      goto LABEL_25;
    case 0x16uLL:
      v4 = "MTLArgumentTypePrivateByVal";
      v5 = "PrivateByVal";
      goto LABEL_25;
    case 0x17uLL:
      v4 = "MTLArgumentTypePrivateFunctionPointer";
      v5 = "PrivateFunctionPointer";
      goto LABEL_25;
    case 0x18uLL:
      v4 = "MTLBindingTypeVisibleFunctionTable";
      v5 = "VisibleFunctionTable";
      goto LABEL_25;
    case 0x19uLL:
      v4 = "MTLBindingTypePrimitiveAccelerationStructure";
      v5 = "PrimitiveAccelerationStructure";
      goto LABEL_25;
    case 0x1AuLL:
      v4 = "MTLBindingTypeInstanceAccelerationStructure";
      v5 = "InstanceAccelerationStructure";
      goto LABEL_25;
    case 0x1BuLL:
      v4 = "MTLBindingTypeIntersectionFunctionTable";
      v5 = "IntersectionFunctionTable";
      goto LABEL_25;
    case 0x1CuLL:
      v4 = "MTLArgumentTypePrivatePointer";
      v5 = "PrivatePointer";
      goto LABEL_25;
    case 0x1DuLL:
      v4 = "MTLArgumentTypePrivateStruct";
      v5 = "PrivateStruct";
      goto LABEL_25;
    case 0x22uLL:
      v4 = "MTLBindingTypeObjectPayload";
      v5 = "ObjectPayload";
      goto LABEL_25;
    case 0x23uLL:
      v4 = "MTLArgumentTypePrivateMesh";
      v5 = "PrivateMesh";
      goto LABEL_25;
    case 0x24uLL:
      v4 = "MTLArgumentTypePrivateDepthStencilState";
      v5 = "PrivateDepthStencilState";
LABEL_25:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBlendFactorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLBlendFactorZero";
      v3 = "Zero";
      goto LABEL_22;
    case 1uLL:
      v2 = "MTLBlendFactorOne";
      v3 = "One";
      goto LABEL_22;
    case 2uLL:
      v2 = "MTLBlendFactorSourceColor";
      v3 = "SourceColor";
      goto LABEL_22;
    case 3uLL:
      v2 = "MTLBlendFactorOneMinusSourceColor";
      v3 = "OneMinusSourceColor";
      goto LABEL_22;
    case 4uLL:
      v2 = "MTLBlendFactorSourceAlpha";
      v3 = "SourceAlpha";
      goto LABEL_22;
    case 5uLL:
      v2 = "MTLBlendFactorOneMinusSourceAlpha";
      v3 = "OneMinusSourceAlpha";
      goto LABEL_22;
    case 6uLL:
      v2 = "MTLBlendFactorDestinationColor";
      v3 = "DestinationColor";
      goto LABEL_22;
    case 7uLL:
      v2 = "MTLBlendFactorOneMinusDestinationColor";
      v3 = "OneMinusDestinationColor";
      goto LABEL_22;
    case 8uLL:
      v2 = "MTLBlendFactorDestinationAlpha";
      v3 = "DestinationAlpha";
      goto LABEL_22;
    case 9uLL:
      v2 = "MTLBlendFactorOneMinusDestinationAlpha";
      v3 = "OneMinusDestinationAlpha";
      goto LABEL_22;
    case 0xAuLL:
      v2 = "MTLBlendFactorSourceAlphaSaturated";
      v3 = "SourceAlphaSaturated";
      goto LABEL_22;
    case 0xBuLL:
      v2 = "MTLBlendFactorBlendColor";
      v3 = "BlendColor";
      goto LABEL_22;
    case 0xCuLL:
      v2 = "MTLBlendFactorOneMinusBlendColor";
      v3 = "OneMinusBlendColor";
      goto LABEL_22;
    case 0xDuLL:
      v2 = "MTLBlendFactorBlendAlpha";
      v3 = "BlendAlpha";
      goto LABEL_22;
    case 0xEuLL:
      v2 = "MTLBlendFactorOneMinusBlendAlpha";
      v3 = "OneMinusBlendAlpha";
      goto LABEL_22;
    case 0xFuLL:
      v2 = "MTLBlendFactorSource1Color";
      v3 = "Source1Color";
      goto LABEL_22;
    case 0x10uLL:
      v2 = "MTLBlendFactorOneMinusSource1Color";
      v3 = "OneMinusSource1Color";
      goto LABEL_22;
    case 0x11uLL:
      v2 = "MTLBlendFactorSource1Alpha";
      v3 = "Source1Alpha";
      goto LABEL_22;
    case 0x12uLL:
      v2 = "MTLBlendFactorOneMinusSource1Alpha";
      v3 = "OneMinusSource1Alpha";
LABEL_22:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBlendOperationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLBlendOperationAdd";
      v3 = "Add";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLBlendOperationSubtract";
      v3 = "Subtract";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLBlendOperationReverseSubtract";
      v3 = "ReverseSubtract";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLBlendOperationMin";
      v3 = "Min";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLBlendOperationMax";
      v3 = "Max";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBlitOptionAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLBlitOptionNone";
      v5 = "None";
      goto LABEL_16;
    case 1uLL:
      v4 = "MTLBlitOptionDepthFromDepthStencil";
      v5 = "DepthFromDepthStencil";
      goto LABEL_16;
    case 2uLL:
      v4 = "MTLBlitOptionStencilFromDepthStencil";
      v5 = "StencilFromDepthStencil";
      goto LABEL_16;
    case 3uLL:
      return result;
    case 4uLL:
      v4 = "MTLBlitOptionRowLinearPVRTC";
      v5 = "RowLinearPVRTC";
LABEL_16:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      v6 = "MTLBlitOptionOpenGLClient";
      if (a2)
        v6 = "OpenGLClient";
      v7 = "MTLBlitOptionToolsClient";
      if (a2)
        v7 = "ToolsClient";
      if (this == (GPUTools::MTL *)0x40000000)
        v8 = v7;
      else
        v8 = "Unknown";
      if (this == (GPUTools::MTL *)0x20000000)
        result = v6;
      else
        result = v8;
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBufferRobustnessSupportAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLBufferRobustnessSupportNotSupported";
      v3 = "NotSupported";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLBufferRobustnessSupportNilBinding";
      v3 = "NilBinding";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLBufferRobustnessSupportNilCheckedAccess";
      v3 = "NilCheckedAccess";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLBufferRobustnessSupportInvalidAccess";
      v3 = "InvalidAccess";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLBuiltInArgumentTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLBuiltInArgumentInvalid";
      v3 = "Invalid";
      goto LABEL_28;
    case 1uLL:
      v2 = "MTLBuiltInArgumentVertexID";
      v3 = "VertexID";
      goto LABEL_28;
    case 2uLL:
      v2 = "MTLBuiltInArgumentInstanceID";
      v3 = "InstanceID";
      goto LABEL_28;
    case 3uLL:
      v2 = "MTLBuiltInArgumentBaseVertex";
      v3 = "BaseVertex";
      goto LABEL_28;
    case 4uLL:
      v2 = "MTLBuiltInArgumentBaseInstance";
      v3 = "BaseInstance";
      goto LABEL_28;
    case 5uLL:
      v2 = "MTLBuiltInArgumentThreadPositionInGrid";
      v3 = "ThreadPositionInGrid";
      goto LABEL_28;
    case 6uLL:
      v2 = "MTLBuiltInArgumentThreadsPerGrid";
      v3 = "ThreadsPerGrid";
      goto LABEL_28;
    case 7uLL:
      v2 = "MTLBuiltInArgumentThreadPositionInThreadgroup";
      v3 = "ThreadPositionInThreadgroup";
      goto LABEL_28;
    case 8uLL:
      v2 = "MTLBuiltInArgumentThreadIndexInThreadgroup";
      v3 = "ThreadIndexInThreadgroup";
      goto LABEL_28;
    case 9uLL:
      v2 = "MTLBuiltInArgumentThreadsPerThreadgroup";
      v3 = "ThreadsPerThreadgroup";
      goto LABEL_28;
    case 0xAuLL:
      v2 = "MTLBuiltInArgumentThreadgroupPositionInGrid";
      v3 = "ThreadgroupPositionInGrid";
      goto LABEL_28;
    case 0xBuLL:
      v2 = "MTLBuiltInArgumentThreadgroupsPerGrid";
      v3 = "ThreadgroupsPerGrid";
      goto LABEL_28;
    case 0xCuLL:
      v2 = "MTLBuiltInArgumentThreadExecutionWidth";
      v3 = "ThreadExecutionWidth";
      goto LABEL_28;
    case 0xDuLL:
      v2 = "MTLBuiltInArgumentPatchID";
      v3 = "PatchID";
      goto LABEL_28;
    case 0xEuLL:
      v2 = "MTLBuiltInArgumentPositionInPatch";
      v3 = "PositionInPatch";
      goto LABEL_28;
    case 0xFuLL:
      v2 = "MTLBuiltInArgumentStageInGridOrigin";
      v3 = "StageInGridOrigin";
      goto LABEL_28;
    case 0x10uLL:
      v2 = "MTLBuiltInArgumentStageInGridSize";
      v3 = "StageInGridSize";
      goto LABEL_28;
    case 0x11uLL:
      v2 = "MTLBuiltInArgumentThreadIndexInQuadgroup";
      v3 = "ThreadIndexInQuadgroup";
      goto LABEL_28;
    case 0x12uLL:
      v2 = "MTLBuiltInArgumentThreadIndexInSimdgroup";
      v3 = "ThreadIndexInSimdgroup";
      goto LABEL_28;
    case 0x13uLL:
      v2 = "MTLBuiltInArgumentThreadsPerQuadgroup";
      v3 = "ThreadsPerQuadgroup";
      goto LABEL_28;
    case 0x14uLL:
      v2 = "MTLBuiltInArgumentThreadsPerSimdgroup";
      v3 = "ThreadsPerSimdgroup";
      goto LABEL_28;
    case 0x15uLL:
      v2 = "MTLBuiltInAmplificationID";
      v3 = "BuiltInAmplificationID";
      goto LABEL_28;
    case 0x16uLL:
      v2 = "MTLBuiltInAmplificationCount";
      v3 = "BuiltInAmplificationCount";
      goto LABEL_28;
    case 0x17uLL:
      v2 = "MTLBuiltInMeshGridProperties";
      v3 = "BuiltInMeshGridProperties";
      goto LABEL_28;
    case 0x18uLL:
      v2 = "MTLBuiltInMesh";
      v3 = "BuiltInMesh";
LABEL_28:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCPUCacheModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCPUCacheModeWriteCombined";
  if (a2)
    v3 = "WriteCombined";
  v4 = "MTLCPUCacheModeDefaultCache";
  if (a2)
    v4 = "DefaultCache";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLCaptureDestinationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCaptureDestinationGPUTraceDocument";
  if (a2)
    v3 = "GPUTraceDocument";
  v4 = "MTLCaptureDestinationDeveloperTools";
  if (a2)
    v4 = "DeveloperTools";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLCaptureErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLCaptureErrorNotSupported";
  if (a2)
    v3 = "NotSupported";
  v4 = "MTLCaptureErrorInvalidDescriptor";
  if (a2)
    v4 = "InvalidDescriptor";
  v5 = "AlreadyCapturing";
  if (!a2)
    v5 = "MTLCaptureErrorAlreadyCapturing";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)3)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLColorWriteMaskAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLColorWriteMaskNone";
      v5 = "None";
      goto LABEL_12;
    case 1uLL:
      v4 = "MTLColorWriteMaskAlpha";
      v5 = "Alpha";
      goto LABEL_12;
    case 2uLL:
      v4 = "MTLColorWriteMaskBlue";
      v5 = "Blue";
      goto LABEL_12;
    case 3uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      return result;
    case 4uLL:
      v4 = "MTLColorWriteMaskGreen";
      v5 = "Green";
      goto LABEL_12;
    case 8uLL:
      v4 = "MTLColorWriteMaskRed";
      v5 = "Red";
LABEL_12:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      v6 = "MTLColorWriteMaskAll";
      if (a2)
        v6 = "All";
      if (this == (GPUTools::MTL *)15)
        result = v6;
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCommandBufferErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLCommandBufferErrorNone";
      v5 = "None";
      goto LABEL_15;
    case 1uLL:
      v4 = "MTLCommandBufferErrorInternal";
      v5 = "Internal";
      goto LABEL_15;
    case 2uLL:
      v4 = "MTLCommandBufferErrorTimeout";
      v5 = "Timeout";
      goto LABEL_15;
    case 3uLL:
      v4 = "MTLCommandBufferErrorPageFault";
      v5 = "PageFault";
      goto LABEL_15;
    case 4uLL:
      v4 = "MTLCommandBufferErrorAccessRevoked";
      v5 = "AccessRevoked";
      goto LABEL_15;
    case 7uLL:
      v4 = "MTLCommandBufferErrorNotPermitted";
      v5 = "NotPermitted";
      goto LABEL_15;
    case 8uLL:
      v4 = "MTLCommandBufferErrorOutOfMemory";
      v5 = "OutOfMemory";
      goto LABEL_15;
    case 9uLL:
      v4 = "MTLCommandBufferErrorInvalidResource";
      v5 = "InvalidResource";
      goto LABEL_15;
    case 0xAuLL:
      v4 = "MTLCommandBufferErrorMemoryless";
      v5 = "Memoryless";
      goto LABEL_15;
    case 0xBuLL:
      v4 = "MTLCommandBufferErrorDeviceRemoved";
      v5 = "DeviceRemoved";
      goto LABEL_15;
    case 0xCuLL:
      v4 = "MTLCommandBufferErrorStackOverflow";
      v5 = "StackOverflow";
      goto LABEL_15;
    case 0x10uLL:
      v4 = "MTLCommandBufferErrorProtectionViolation";
      v5 = "ProtectionViolation";
      goto LABEL_15;
    case 0x11uLL:
      v4 = "MTLCommandBufferErrorConditionalEventAbort";
      v5 = "ConditionalEventAbort";
LABEL_15:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCommandBufferErrorOptionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCommandBufferErrorOptionNone";
  if (a2)
    v3 = "None";
  v4 = "MTLCommandBufferErrorOptionEncoderExecutionStatus";
  if (a2)
    v4 = "EncoderExecutionStatus";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLCommandBufferStatusAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLCommandBufferStatusNotEnqueued";
      v3 = "NotEnqueued";
      goto LABEL_10;
    case 1uLL:
      v2 = "MTLCommandBufferStatusEnqueued";
      v3 = "Enqueued";
      goto LABEL_10;
    case 2uLL:
      v2 = "MTLCommandBufferStatusCommitted";
      v3 = "Committed";
      goto LABEL_10;
    case 3uLL:
      v2 = "MTLCommandBufferStatusScheduled";
      v3 = "Scheduled";
      goto LABEL_10;
    case 4uLL:
      v2 = "MTLCommandBufferStatusCompleted";
      v3 = "Completed";
      goto LABEL_10;
    case 5uLL:
      v2 = "MTLCommandBufferStatusError";
      v3 = "Error";
      goto LABEL_10;
    case 6uLL:
      v2 = "MTLCommandBufferStatusAbort";
      v3 = "Abort";
LABEL_10:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCommandBufferSynchronizationTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLSynchronizationTypeExplicit";
      v3 = "Explicit";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLSynchronizationTypeImplicit";
      v3 = "Implicit";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLSynchronizationTypeCommit";
      v3 = "Commit";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLSynchronizationTypeDealloc";
      v3 = "Dealloc";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCommandDataCorruptionModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCommandDataCorruptionModeRandomLocation";
  if (a2)
    v3 = "RandomLocation";
  v4 = "MTLCommandDataCorruptionModeAllBytes";
  if (a2)
    v4 = "AllBytes";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLCommandEncoderErrorStateAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      if (!a2)
        return "MTLCommandEncoderErrorStateUnknown";
      return result;
    case 1uLL:
      v4 = "MTLCommandEncoderErrorStateCompleted";
      v5 = "Completed";
      goto LABEL_9;
    case 2uLL:
      v4 = "MTLCommandEncoderErrorStateAffected";
      v5 = "Affected";
      goto LABEL_9;
    case 3uLL:
      v4 = "MTLCommandEncoderErrorStatePending";
      v5 = "Pending";
      goto LABEL_9;
    case 4uLL:
      v4 = "MTLCommandEncoderErrorStateFaulted";
      v5 = "Faulted";
LABEL_9:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCommandEncoderTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLCommandEncoderTypeRender";
      v5 = "Render";
      goto LABEL_9;
    case 1uLL:
      v4 = "MTLCommandEncoderTypeCompute";
      v5 = "Compute";
      goto LABEL_9;
    case 2uLL:
      v4 = "MTLCommandEncoderTypeBlit";
      v5 = "Blit";
      goto LABEL_9;
    case 3uLL:
      v4 = "MTLCommandEncoderTypeParallelRender";
      v5 = "ParallelRender";
      goto LABEL_9;
    case 5uLL:
      v4 = "MTLCommandEncoderTypeVideo";
      v5 = "Video";
      goto LABEL_9;
    case 6uLL:
      v4 = "MTLCommandEncoderTypeResourceState";
      v5 = "ResourceState";
      goto LABEL_9;
    case 7uLL:
      v4 = "MTLCommandEncoderTypeAccelerationStructure";
      v5 = "AccelerationStructure";
LABEL_9:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCompareFunctionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLCompareFunctionNever";
      v3 = "Never";
      goto LABEL_11;
    case 1uLL:
      v2 = "MTLCompareFunctionLess";
      v3 = "Less";
      goto LABEL_11;
    case 2uLL:
      v2 = "MTLCompareFunctionEqual";
      v3 = "Equal";
      goto LABEL_11;
    case 3uLL:
      v2 = "MTLCompareFunctionLessEqual";
      v3 = "LessEqual";
      goto LABEL_11;
    case 4uLL:
      v2 = "MTLCompareFunctionGreater";
      v3 = "Greater";
      goto LABEL_11;
    case 5uLL:
      v2 = "MTLCompareFunctionNotEqual";
      v3 = "NotEqual";
      goto LABEL_11;
    case 6uLL:
      v2 = "MTLCompareFunctionGreaterEqual";
      v3 = "GreaterEqual";
      goto LABEL_11;
    case 7uLL:
      v2 = "MTLCompareFunctionAlways";
      v3 = "Always";
LABEL_11:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLComparisonAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLComparisonEqual";
      v3 = "Equal";
      goto LABEL_9;
    case 1uLL:
      v2 = "MTLComparisonNotEqual";
      v3 = "NotEqual";
      goto LABEL_9;
    case 2uLL:
      v2 = "MTLComparisonGreaterThan";
      v3 = "GreaterThan";
      goto LABEL_9;
    case 3uLL:
      v2 = "MTLComparisonGreaterThanOrEqual";
      v3 = "GreaterThanOrEqual";
      goto LABEL_9;
    case 4uLL:
      v2 = "MTLComparisonLessThan";
      v3 = "LessThan";
      goto LABEL_9;
    case 5uLL:
      v2 = "MTLComparisonLessThanOrEqual";
      v3 = "LessThanOrEqual";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCompileSymbolVisibilityAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCompileSymbolVisibilityHidden";
  if (a2)
    v3 = "Hidden";
  v4 = "MTLCompileSymbolVisibilityDefault";
  if (a2)
    v4 = "Default";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLCompilerErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLCompilerErrorNoError";
      v3 = "NoError";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLCompilerErrorFatalError";
      v3 = "FatalError";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLCompilerErrorCompilationError";
      v3 = "CompilationError";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLCompilerErrorTimeout";
      v3 = "Timeout";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLCompilerErrorEarlyExit";
      v3 = "EarlyExit";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCompilerFlagAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;

  result = "Unknown";
  if ((uint64_t)this > 31)
  {
    v6 = "MTLCompilerFlagIgnorePlatformValidation";
    if (a2)
      v6 = "IgnorePlatformValidation";
    v7 = "MTLCompilerFlagEmulateIndirectAccelerationStructures";
    if (a2)
      v7 = "EmulateIndirectAccelerationStructures";
    v8 = "MTLCompilerFlagCompilerPluginRequiresSerializedBitcode";
    if (a2)
      v8 = "CompilerPluginRequiresSerializedBitcode";
    if (this != (GPUTools::MTL *)256)
      v8 = "Unknown";
    if (this != (GPUTools::MTL *)512)
      v7 = v8;
    if (this != (GPUTools::MTL *)128)
      v6 = v7;
    v9 = "MTLCompilerFlagNoVertexFragmentLinking";
    if (a2)
      v9 = "NoVertexFragmentLinking";
    v10 = "MTLCompilerFlagSkipStageInputLoading";
    if (a2)
      v10 = "SkipStageInputLoading";
    if (this != (GPUTools::MTL *)64)
      v10 = "Unknown";
    if (this != (GPUTools::MTL *)32)
      v9 = v10;
    if ((uint64_t)this <= 127)
      return v9;
    else
      return v6;
  }
  else
  {
    switch((unint64_t)this)
    {
      case 0uLL:
        v4 = "MTLCompilerFlagNone";
        v5 = "None";
        goto LABEL_35;
      case 1uLL:
      case 3uLL:
      case 5uLL:
      case 6uLL:
      case 7uLL:
        return result;
      case 2uLL:
        v4 = "MTLCompilerFlagPackVaryings";
        v5 = "PackVaryings";
        goto LABEL_35;
      case 4uLL:
        v4 = "MTLCompilerFlagLoadVertexAttributeData";
        v5 = "LoadVertexAttributeData";
        goto LABEL_35;
      case 8uLL:
        v4 = "MTLCompilerFlagLoadPatchData";
        v5 = "LoadPatchData";
LABEL_35:
        if (a2)
          result = v5;
        else
          result = v4;
        break;
      default:
        v11 = "MTLCompilerFlagLoadPatchControlPointData";
        if (a2)
          v11 = "LoadPatchControlPointData";
        if (this == (GPUTools::MTL *)16)
          result = v11;
        break;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCompilerTestModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCompilerTestModeIntermittentCrash";
  if (a2)
    v3 = "IntermittentCrash";
  v4 = "MTLCompilerTestModeDefault";
  if (a2)
    v4 = "Default";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLComputeFPConfigAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = "Unknown";
  v3 = "MTLComputeFPRoundToZeroBit";
  if (a2)
    v3 = "RoundToZeroBit";
  v4 = "RoundToInfinityBit";
  if (!a2)
    v4 = "MTLComputeFPRoundToInfinityBit";
  v5 = "MTLComputeFMABit";
  if (a2)
    v5 = "FMABit";
  if (this != (GPUTools::MTL *)64)
    v5 = "Unknown";
  if (this != (GPUTools::MTL *)32)
    v4 = v5;
  if (this != (GPUTools::MTL *)16)
    v3 = v4;
  v6 = "MTLComputeFPDenormBit";
  if (a2)
    v6 = "DenormBit";
  v7 = "MTLComputeFPInfNanBit";
  if (a2)
  {
    v7 = "InfNanBit";
    v8 = "RoundToNearestBit";
  }
  else
  {
    v8 = "MTLComputeFPRoundToNearestBit";
  }
  if (this == (GPUTools::MTL *)8)
    v2 = v8;
  if (this == (GPUTools::MTL *)4)
    v2 = v7;
  if (this == (GPUTools::MTL *)2)
    v2 = v6;
  if ((uint64_t)this <= 15)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLCounterSampleBufferErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLCounterSampleBufferErrorOutOfMemory";
  if (a2)
    v3 = "OutOfMemory";
  v4 = "MTLCounterSampleBufferErrorInvalid";
  if (a2)
    v4 = "Invalid";
  v5 = "Internal";
  if (!a2)
    v5 = "MTLCounterSampleBufferErrorInternal";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLCounterSamplingPointAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLCounterSamplingPointAtStageBoundary";
      v3 = "AtStageBoundary";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLCounterSamplingPointAtDrawBoundary";
      v3 = "AtDrawBoundary";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLCounterSamplingPointAtDispatchBoundary";
      v3 = "AtDispatchBoundary";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLCounterSamplingPointAtTileDispatchBoundary";
      v3 = "AtTileDispatchBoundary";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLCounterSamplingPointAtBlitBoundary";
      v3 = "AtBlitBoundary";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCullModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLCullModeNone";
  if (a2)
    v3 = "None";
  v4 = "MTLCullModeFront";
  if (a2)
    v4 = "Front";
  v5 = "Back";
  if (!a2)
    v5 = "MTLCullModeBack";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLCurveAdjacencyAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLCurveAdjacencyNone";
  if (a2)
    v3 = "None";
  v4 = "MTLCurveAdjacencyEnd";
  if (a2)
    v4 = "End";
  v5 = "Begin";
  if (!a2)
    v5 = "MTLCurveAdjacencyBegin";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLCurveBasisAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLCurveBasisBSpline";
      v3 = "BSpline";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLCurveBasisCatmullRom";
      v3 = "CatmullRom";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLCurveBasisLinear";
      v3 = "Linear";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLCurveBasisBezier";
      v3 = "Bezier";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLCurveEndCapsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLCurveEndCapsNone";
  if (a2)
    v3 = "None";
  v4 = "MTLCurveEndCapsSphere";
  if (a2)
    v4 = "Sphere";
  v5 = "Disk";
  if (!a2)
    v5 = "MTLCurveEndCapsDisk";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLCurveTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLCurveTypeRound";
  if (a2)
    v3 = "Round";
  v4 = "MTLCurveTypeFlat";
  if (a2)
    v4 = "Flat";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLDashboardAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;

  v2 = "MTLDashboardStreamingCodec";
  if (a2)
    v2 = "StreamingCodec";
  if (this)
    return "Unknown";
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLDataTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLDataTypeNone";
      v3 = "None";
      goto LABEL_143;
    case 1uLL:
      v2 = "MTLDataTypeStruct";
      v3 = "Struct";
      goto LABEL_143;
    case 2uLL:
      v2 = "MTLDataTypeArray";
      v3 = "Array";
      goto LABEL_143;
    case 3uLL:
      v2 = "MTLDataTypeFloat";
      v3 = "Float";
      goto LABEL_143;
    case 4uLL:
      v2 = "MTLDataTypeFloat2";
      v3 = "Float2";
      goto LABEL_143;
    case 5uLL:
      v2 = "MTLDataTypeFloat3";
      v3 = "Float3";
      goto LABEL_143;
    case 6uLL:
      v2 = "MTLDataTypeFloat4";
      v3 = "Float4";
      goto LABEL_143;
    case 7uLL:
      v2 = "MTLDataTypeFloat2x2";
      v3 = "Float2x2";
      goto LABEL_143;
    case 8uLL:
      v2 = "MTLDataTypeFloat2x3";
      v3 = "Float2x3";
      goto LABEL_143;
    case 9uLL:
      v2 = "MTLDataTypeFloat2x4";
      v3 = "Float2x4";
      goto LABEL_143;
    case 0xAuLL:
      v2 = "MTLDataTypeFloat3x2";
      v3 = "Float3x2";
      goto LABEL_143;
    case 0xBuLL:
      v2 = "MTLDataTypeFloat3x3";
      v3 = "Float3x3";
      goto LABEL_143;
    case 0xCuLL:
      v2 = "MTLDataTypeFloat3x4";
      v3 = "Float3x4";
      goto LABEL_143;
    case 0xDuLL:
      v2 = "MTLDataTypeFloat4x2";
      v3 = "Float4x2";
      goto LABEL_143;
    case 0xEuLL:
      v2 = "MTLDataTypeFloat4x3";
      v3 = "Float4x3";
      goto LABEL_143;
    case 0xFuLL:
      v2 = "MTLDataTypeFloat4x4";
      v3 = "Float4x4";
      goto LABEL_143;
    case 0x10uLL:
      v2 = "MTLDataTypeHalf";
      v3 = "Half";
      goto LABEL_143;
    case 0x11uLL:
      v2 = "MTLDataTypeHalf2";
      v3 = "Half2";
      goto LABEL_143;
    case 0x12uLL:
      v2 = "MTLDataTypeHalf3";
      v3 = "Half3";
      goto LABEL_143;
    case 0x13uLL:
      v2 = "MTLDataTypeHalf4";
      v3 = "Half4";
      goto LABEL_143;
    case 0x14uLL:
      v2 = "MTLDataTypeHalf2x2";
      v3 = "Half2x2";
      goto LABEL_143;
    case 0x15uLL:
      v2 = "MTLDataTypeHalf2x3";
      v3 = "Half2x3";
      goto LABEL_143;
    case 0x16uLL:
      v2 = "MTLDataTypeHalf2x4";
      v3 = "Half2x4";
      goto LABEL_143;
    case 0x17uLL:
      v2 = "MTLDataTypeHalf3x2";
      v3 = "Half3x2";
      goto LABEL_143;
    case 0x18uLL:
      v2 = "MTLDataTypeHalf3x3";
      v3 = "Half3x3";
      goto LABEL_143;
    case 0x19uLL:
      v2 = "MTLDataTypeHalf3x4";
      v3 = "Half3x4";
      goto LABEL_143;
    case 0x1AuLL:
      v2 = "MTLDataTypeHalf4x2";
      v3 = "Half4x2";
      goto LABEL_143;
    case 0x1BuLL:
      v2 = "MTLDataTypeHalf4x3";
      v3 = "Half4x3";
      goto LABEL_143;
    case 0x1CuLL:
      v2 = "MTLDataTypeHalf4x4";
      v3 = "Half4x4";
      goto LABEL_143;
    case 0x1DuLL:
      v2 = "MTLDataTypeInt";
      v3 = "Int";
      goto LABEL_143;
    case 0x1EuLL:
      v2 = "MTLDataTypeInt2";
      v3 = "Int2";
      goto LABEL_143;
    case 0x1FuLL:
      v2 = "MTLDataTypeInt3";
      v3 = "Int3";
      goto LABEL_143;
    case 0x20uLL:
      v2 = "MTLDataTypeInt4";
      v3 = "Int4";
      goto LABEL_143;
    case 0x21uLL:
      v2 = "MTLDataTypeUInt";
      v3 = "UInt";
      goto LABEL_143;
    case 0x22uLL:
      v2 = "MTLDataTypeUInt2";
      v3 = "UInt2";
      goto LABEL_143;
    case 0x23uLL:
      v2 = "MTLDataTypeUInt3";
      v3 = "UInt3";
      goto LABEL_143;
    case 0x24uLL:
      v2 = "MTLDataTypeUInt4";
      v3 = "UInt4";
      goto LABEL_143;
    case 0x25uLL:
      v2 = "MTLDataTypeShort";
      v3 = "Short";
      goto LABEL_143;
    case 0x26uLL:
      v2 = "MTLDataTypeShort2";
      v3 = "Short2";
      goto LABEL_143;
    case 0x27uLL:
      v2 = "MTLDataTypeShort3";
      v3 = "Short3";
      goto LABEL_143;
    case 0x28uLL:
      v2 = "MTLDataTypeShort4";
      v3 = "Short4";
      goto LABEL_143;
    case 0x29uLL:
      v2 = "MTLDataTypeUShort";
      v3 = "UShort";
      goto LABEL_143;
    case 0x2AuLL:
      v2 = "MTLDataTypeUShort2";
      v3 = "UShort2";
      goto LABEL_143;
    case 0x2BuLL:
      v2 = "MTLDataTypeUShort3";
      v3 = "UShort3";
      goto LABEL_143;
    case 0x2CuLL:
      v2 = "MTLDataTypeUShort4";
      v3 = "UShort4";
      goto LABEL_143;
    case 0x2DuLL:
      v2 = "MTLDataTypeChar";
      v3 = "Char";
      goto LABEL_143;
    case 0x2EuLL:
      v2 = "MTLDataTypeChar2";
      v3 = "Char2";
      goto LABEL_143;
    case 0x2FuLL:
      v2 = "MTLDataTypeChar3";
      v3 = "Char3";
      goto LABEL_143;
    case 0x30uLL:
      v2 = "MTLDataTypeChar4";
      v3 = "Char4";
      goto LABEL_143;
    case 0x31uLL:
      v2 = "MTLDataTypeUChar";
      v3 = "UChar";
      goto LABEL_143;
    case 0x32uLL:
      v2 = "MTLDataTypeUChar2";
      v3 = "UChar2";
      goto LABEL_143;
    case 0x33uLL:
      v2 = "MTLDataTypeUChar3";
      v3 = "UChar3";
      goto LABEL_143;
    case 0x34uLL:
      v2 = "MTLDataTypeUChar4";
      v3 = "UChar4";
      goto LABEL_143;
    case 0x35uLL:
      v2 = "MTLDataTypeBool";
      v3 = "Bool";
      goto LABEL_143;
    case 0x36uLL:
      v2 = "MTLDataTypeBool2";
      v3 = "Bool2";
      goto LABEL_143;
    case 0x37uLL:
      v2 = "MTLDataTypeBool3";
      v3 = "Bool3";
      goto LABEL_143;
    case 0x38uLL:
      v2 = "MTLDataTypeBool4";
      v3 = "Bool4";
      goto LABEL_143;
    case 0x39uLL:
      v2 = "MTLDataTypePrivateIndirectArgument";
      v3 = "PrivateIndirectArgument";
      goto LABEL_143;
    case 0x3AuLL:
      v2 = "MTLDataTypeTexture";
      v3 = "Texture";
      goto LABEL_143;
    case 0x3BuLL:
      v2 = "MTLDataTypeSampler";
      v3 = "Sampler";
      goto LABEL_143;
    case 0x3CuLL:
      v2 = "MTLDataTypePointer";
      v3 = "Pointer";
      goto LABEL_143;
    case 0x3DuLL:
      v2 = "MTLDataTypePrivateVoid";
      v3 = "PrivateVoid";
      goto LABEL_143;
    case 0x3EuLL:
      v2 = "MTLDataTypeR8Unorm";
      v3 = "R8Unorm";
      goto LABEL_143;
    case 0x3FuLL:
      v2 = "MTLDataTypeR8Snorm";
      v3 = "R8Snorm";
      goto LABEL_143;
    case 0x40uLL:
      v2 = "MTLDataTypeR16Unorm";
      v3 = "R16Unorm";
      goto LABEL_143;
    case 0x41uLL:
      v2 = "MTLDataTypeR16Snorm";
      v3 = "R16Snorm";
      goto LABEL_143;
    case 0x42uLL:
      v2 = "MTLDataTypeRG8Unorm";
      v3 = "RG8Unorm";
      goto LABEL_143;
    case 0x43uLL:
      v2 = "MTLDataTypeRG8Snorm";
      v3 = "RG8Snorm";
      goto LABEL_143;
    case 0x44uLL:
      v2 = "MTLDataTypeRG16Unorm";
      v3 = "RG16Unorm";
      goto LABEL_143;
    case 0x45uLL:
      v2 = "MTLDataTypeRG16Snorm";
      v3 = "RG16Snorm";
      goto LABEL_143;
    case 0x46uLL:
      v2 = "MTLDataTypeRGBA8Unorm";
      v3 = "RGBA8Unorm";
      goto LABEL_143;
    case 0x47uLL:
      v2 = "MTLDataTypeRGBA8Unorm_sRGB";
      v3 = "RGBA8Unorm_sRGB";
      goto LABEL_143;
    case 0x48uLL:
      v2 = "MTLDataTypeRGBA8Snorm";
      v3 = "RGBA8Snorm";
      goto LABEL_143;
    case 0x49uLL:
      v2 = "MTLDataTypeRGBA16Unorm";
      v3 = "RGBA16Unorm";
      goto LABEL_143;
    case 0x4AuLL:
      v2 = "MTLDataTypeRGBA16Snorm";
      v3 = "RGBA16Snorm";
      goto LABEL_143;
    case 0x4BuLL:
      v2 = "MTLDataTypeRGB10A2Unorm";
      v3 = "RGB10A2Unorm";
      goto LABEL_143;
    case 0x4CuLL:
      v2 = "MTLDataTypeRG11B10Float";
      v3 = "RG11B10Float";
      goto LABEL_143;
    case 0x4DuLL:
      v2 = "MTLDataTypeRGB9E5Float";
      v3 = "RGB9E5Float";
      goto LABEL_143;
    case 0x4EuLL:
      v2 = "MTLDataTypeRenderPipeline";
      v3 = "RenderPipeline";
      goto LABEL_143;
    case 0x4FuLL:
      v2 = "MTLDataTypeComputePipeline";
      v3 = "ComputePipeline";
      goto LABEL_143;
    case 0x50uLL:
      v2 = "MTLDataTypeIndirectCommandBuffer";
      v3 = "IndirectCommandBuffer";
      goto LABEL_143;
    case 0x51uLL:
      v2 = "MTLDataTypeLong";
      v3 = "Long";
      goto LABEL_143;
    case 0x52uLL:
      v2 = "MTLDataTypeLong2";
      v3 = "Long2";
      goto LABEL_143;
    case 0x53uLL:
      v2 = "MTLDataTypeLong3";
      v3 = "Long3";
      goto LABEL_143;
    case 0x54uLL:
      v2 = "MTLDataTypeLong4";
      v3 = "Long4";
      goto LABEL_143;
    case 0x55uLL:
      v2 = "MTLDataTypeULong";
      v3 = "ULong";
      goto LABEL_143;
    case 0x56uLL:
      v2 = "MTLDataTypeULong2";
      v3 = "ULong2";
      goto LABEL_143;
    case 0x57uLL:
      v2 = "MTLDataTypeULong3";
      v3 = "ULong3";
      goto LABEL_143;
    case 0x58uLL:
      v2 = "MTLDataTypeULong4";
      v3 = "ULong4";
      goto LABEL_143;
    case 0x59uLL:
      v2 = "MTLDataTypeDouble";
      v3 = "Double";
      goto LABEL_143;
    case 0x5AuLL:
      v2 = "MTLDataTypeDouble2";
      v3 = "Double2";
      goto LABEL_143;
    case 0x5BuLL:
      v2 = "MTLDataTypeDouble3";
      v3 = "Double3";
      goto LABEL_143;
    case 0x5CuLL:
      v2 = "MTLDataTypeDouble4";
      v3 = "Double4";
      goto LABEL_143;
    case 0x5DuLL:
      v2 = "MTLDataTypeFloat8";
      v3 = "Float8";
      goto LABEL_143;
    case 0x5EuLL:
      v2 = "MTLDataTypeFloat16";
      v3 = "Float16";
      goto LABEL_143;
    case 0x5FuLL:
      v2 = "MTLDataTypeHalf8";
      v3 = "Half8";
      goto LABEL_143;
    case 0x60uLL:
      v2 = "MTLDataTypeHalf16";
      v3 = "Half16";
      goto LABEL_143;
    case 0x61uLL:
      v2 = "MTLDataTypeInt8";
      v3 = "Int8";
      goto LABEL_143;
    case 0x62uLL:
      v2 = "MTLDataTypeInt16";
      v3 = "Int16";
      goto LABEL_143;
    case 0x63uLL:
      v2 = "MTLDataTypeUInt8";
      v3 = "UInt8";
      goto LABEL_143;
    case 0x64uLL:
      v2 = "MTLDataTypeUInt16";
      v3 = "UInt16";
      goto LABEL_143;
    case 0x65uLL:
      v2 = "MTLDataTypeShort8";
      v3 = "Short8";
      goto LABEL_143;
    case 0x66uLL:
      v2 = "MTLDataTypeShort16";
      v3 = "Short16";
      goto LABEL_143;
    case 0x67uLL:
      v2 = "MTLDataTypeUShort8";
      v3 = "UShort8";
      goto LABEL_143;
    case 0x68uLL:
      v2 = "MTLDataTypeUShort16";
      v3 = "UShort16";
      goto LABEL_143;
    case 0x69uLL:
      v2 = "MTLDataTypeChar8";
      v3 = "Char8";
      goto LABEL_143;
    case 0x6AuLL:
      v2 = "MTLDataTypeChar16";
      v3 = "Char16";
      goto LABEL_143;
    case 0x6BuLL:
      v2 = "MTLDataTypeUChar8";
      v3 = "UChar8";
      goto LABEL_143;
    case 0x6CuLL:
      v2 = "MTLDataTypeUChar16";
      v3 = "UChar16";
      goto LABEL_143;
    case 0x6DuLL:
      v2 = "MTLDataTypeLong8";
      v3 = "Long8";
      goto LABEL_143;
    case 0x6EuLL:
      v2 = "MTLDataTypeLong16";
      v3 = "Long16";
      goto LABEL_143;
    case 0x6FuLL:
      v2 = "MTLDataTypeULong8";
      v3 = "ULong8";
      goto LABEL_143;
    case 0x70uLL:
      v2 = "MTLDataTypeULong16";
      v3 = "ULong16";
      goto LABEL_143;
    case 0x71uLL:
      v2 = "MTLDataTypeDouble8";
      v3 = "Double8";
      goto LABEL_143;
    case 0x72uLL:
      v2 = "MTLDataTypeDouble16";
      v3 = "Double16";
      goto LABEL_143;
    case 0x73uLL:
      v2 = "MTLDataTypeVisibleFunctionTable";
      v3 = "VisibleFunctionTable";
      goto LABEL_143;
    case 0x74uLL:
      v2 = "MTLDataTypeIntersectionFunctionTable";
      v3 = "IntersectionFunctionTable";
      goto LABEL_143;
    case 0x75uLL:
      v2 = "MTLDataTypePrimitiveAccelerationStructure";
      v3 = "PrimitiveAccelerationStructure";
      goto LABEL_143;
    case 0x76uLL:
      v2 = "MTLDataTypeInstanceAccelerationStructure";
      v3 = "InstanceAccelerationStructure";
      goto LABEL_143;
    case 0x77uLL:
      v2 = "MTLDataTypeBool8";
      v3 = "Bool8";
      goto LABEL_143;
    case 0x78uLL:
      v2 = "MTLDataTypeBool16";
      v3 = "Bool16";
      goto LABEL_143;
    case 0x79uLL:
      v2 = "MTLDataTypeBFloat";
      v3 = "BFloat";
      goto LABEL_143;
    case 0x7AuLL:
      v2 = "MTLDataTypeBFloat2";
      v3 = "BFloat2";
      goto LABEL_143;
    case 0x7BuLL:
      v2 = "MTLDataTypeBFloat3";
      v3 = "BFloat3";
      goto LABEL_143;
    case 0x7CuLL:
      v2 = "MTLDataTypeBFloat4";
      v3 = "BFloat4";
      goto LABEL_143;
    case 0x7DuLL:
      v2 = "MTLDataTypeBFloat8";
      v3 = "BFloat8";
      goto LABEL_143;
    case 0x7EuLL:
      v2 = "MTLDataTypeBFloat16";
      v3 = "BFloat16";
      goto LABEL_143;
    case 0x7FuLL:
      v2 = "MTLDataTypeBFloat2x2";
      v3 = "BFloat2x2";
      goto LABEL_143;
    case 0x80uLL:
      v2 = "MTLDataTypeBFloat2x3";
      v3 = "BFloat2x3";
      goto LABEL_143;
    case 0x81uLL:
      v2 = "MTLDataTypeBFloat2x4";
      v3 = "BFloat2x4";
      goto LABEL_143;
    case 0x82uLL:
      v2 = "MTLDataTypeBFloat3x2";
      v3 = "BFloat3x2";
      goto LABEL_143;
    case 0x83uLL:
      v2 = "MTLDataTypeBFloat3x3";
      v3 = "BFloat3x3";
      goto LABEL_143;
    case 0x84uLL:
      v2 = "MTLDataTypeBFloat3x4";
      v3 = "BFloat3x4";
      goto LABEL_143;
    case 0x85uLL:
      v2 = "MTLDataTypeBFloat4x2";
      v3 = "BFloat4x2";
      goto LABEL_143;
    case 0x86uLL:
      v2 = "MTLDataTypeBFloat4x3";
      v3 = "BFloat4x3";
      goto LABEL_143;
    case 0x87uLL:
      v2 = "MTLDataTypeBFloat4x4";
      v3 = "BFloat4x4";
      goto LABEL_143;
    case 0x88uLL:
      v2 = "MTLDataTypeMatrix";
      v3 = "Matrix";
      goto LABEL_143;
    case 0x89uLL:
      v2 = "MTLDataTypeVector";
      v3 = "Vector";
      goto LABEL_143;
    case 0x8AuLL:
      v2 = "MTLDataTypeImageBlock";
      v3 = "ImageBlock";
      goto LABEL_143;
    case 0x8BuLL:
      v2 = "MTLDataTypeDepthStencilState";
      v3 = "DepthStencilState";
LABEL_143:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDeadlineExecutionBucketsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLDeadlineExecutionTiny";
      v3 = "Tiny";
      goto LABEL_12;
    case 1uLL:
      v2 = "MTLDeadlineExecutionSmall";
      v3 = "Small";
      goto LABEL_12;
    case 2uLL:
      v2 = "MTLDeadlineExecutionMedium";
      v3 = "Medium";
      goto LABEL_12;
    case 3uLL:
      v2 = "MTLDeadlineExecutionLarge";
      v3 = "Large";
      goto LABEL_12;
    case 4uLL:
      v2 = "MTLDeadlineExecutionNum";
      v3 = "Num";
LABEL_12:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      v4 = "MTLDeadlineExecutionInvalid";
      if (a2)
        v4 = "Invalid";
      if (this == (GPUTools::MTL *)0xFFFFFFFFLL)
        result = v4;
      else
        result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDepthClipModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLDepthClipModeClip";
  if (a2)
    v3 = "Clip";
  v4 = "MTLDepthClipModeClamp";
  if (a2)
    v4 = "Clamp";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLDeviceFeatureProfileAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;

  result = "Unknown";
  if ((uint64_t)this > 10000)
  {
    if ((uint64_t)this <= 20001)
    {
      if ((uint64_t)this > 19999)
      {
        v6 = 20000;
        v7 = "MTLDeviceFeatureProfilewatchOS_1";
        if (a2)
          v7 = "watchOS_1";
        v8 = 20001;
        v9 = "MTLDeviceFeatureProfilewatchOS_2";
        v10 = "watchOS_2";
      }
      else
      {
        v6 = 10001;
        v7 = "MTLDeviceFeatureProfilemacOS_2";
        if (a2)
          v7 = "macOS_2";
        v8 = 10002;
        v9 = "MTLDeviceFeatureProfilemacOS_3";
        v10 = "macOS_3";
      }
      if (a2)
        v9 = v10;
      if (this == (GPUTools::MTL *)v8)
        v11 = v9;
      else
        v11 = "Unknown";
LABEL_26:
      if (this == (GPUTools::MTL *)v6)
        return v7;
      else
        return v11;
    }
    else
    {
      switch((unint64_t)this)
      {
        case 0x7530uLL:
          v4 = "MTLDeviceFeatureProfiletvOS_1";
          v5 = "tvOS_1";
          goto LABEL_49;
        case 0x7531uLL:
          v4 = "MTLDeviceFeatureProfiletvOS_2";
          v5 = "tvOS_2";
          goto LABEL_49;
        case 0x7532uLL:
          v4 = "MTLDeviceFeatureProfiletvOS_3";
          v5 = "tvOS_3";
          goto LABEL_49;
        case 0x7533uLL:
          return result;
        case 0x7534uLL:
          v4 = "MTLDeviceFeatureProfiletvOS_5";
          v5 = "tvOS_5";
          goto LABEL_49;
        case 0x7535uLL:
          v4 = "MTLDeviceFeatureProfiletvOS_6";
          v5 = "tvOS_6";
          goto LABEL_49;
        case 0x7536uLL:
          v4 = "MTLDeviceFeatureProfiletvOS_7";
          v5 = "tvOS_7";
LABEL_49:
          if (a2)
            result = v5;
          else
            result = v4;
          break;
        default:
          v6 = 20002;
          v7 = "MTLDeviceFeatureProfilewatchOS_3";
          if (a2)
            v7 = "watchOS_3";
          v12 = "MTLDeviceFeatureProfileUndefined";
          if (a2)
            v12 = "Undefined";
          if (this == (GPUTools::MTL *)0xFFFFFFFFLL)
            v11 = v12;
          else
            v11 = "Unknown";
          goto LABEL_26;
      }
    }
  }
  else
  {
    switch((unint64_t)this)
    {
      case 0uLL:
        v4 = "MTLDeviceFeatureProfileiOS_1";
        v5 = "iOS_1";
        goto LABEL_49;
      case 1uLL:
        v4 = "MTLDeviceFeatureProfileiOS_2";
        v5 = "iOS_2";
        goto LABEL_49;
      case 2uLL:
      case 3uLL:
        return result;
      case 4uLL:
        v4 = "MTLDeviceFeatureProfileiOS_3";
        v5 = "iOS_3";
        goto LABEL_49;
      case 5uLL:
        v4 = "MTLDeviceFeatureProfileiOS_4";
        v5 = "iOS_4";
        goto LABEL_49;
      case 6uLL:
        v4 = "MTLDeviceFeatureProfileiOS_5";
        v5 = "iOS_5";
        goto LABEL_49;
      case 7uLL:
        v4 = "MTLDeviceFeatureProfileiOS_6";
        v5 = "iOS_6";
        goto LABEL_49;
      case 8uLL:
        v4 = "MTLDeviceFeatureProfileiOS_7";
        v5 = "iOS_7";
        goto LABEL_49;
      case 9uLL:
        v4 = "MTLDeviceFeatureProfileiOS_8";
        v5 = "iOS_8";
        goto LABEL_49;
      case 0xAuLL:
        v4 = "MTLDeviceFeatureProfileiOS_9";
        v5 = "iOS_9";
        goto LABEL_49;
      case 0xBuLL:
        v4 = "MTLDeviceFeatureProfileiOS_9B";
        v5 = "iOS_9B";
        goto LABEL_49;
      case 0xCuLL:
        v4 = "MTLDeviceFeatureProfileiOS_10";
        v5 = "iOS_10";
        goto LABEL_49;
      default:
        v13 = "MTLDeviceFeatureProfilemacOS_1";
        if (a2)
          v13 = "macOS_1";
        if (this == (GPUTools::MTL *)10000)
          result = v13;
        break;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDeviceLocationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0xFFFFFFFFFFFFFFFFLL:
      v2 = "MTLDeviceLocationUnspecified";
      v3 = "Unspecified";
      goto LABEL_7;
    case 0uLL:
      v2 = "MTLDeviceLocationBuiltIn";
      v3 = "BuiltIn";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLDeviceLocationSlot";
      v3 = "Slot";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLDeviceLocationExternal";
      v3 = "External";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDevicePartitionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLDevicePartitionDefault";
  if (a2)
    v3 = "Default";
  v4 = "MTLDevicePartition1";
  if (a2)
    v4 = "1";
  v5 = "0";
  if (!a2)
    v5 = "MTLDevicePartition0";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLDispatchTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLDispatchTypeSerial";
  if (a2)
    v3 = "Serial";
  v4 = "MTLDispatchTypeConcurrent";
  if (a2)
    v4 = "Concurrent";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLDynamicLibraryErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLDynamicLibraryErrorNone";
      v3 = "None";
      goto LABEL_9;
    case 1uLL:
      v2 = "MTLDynamicLibraryErrorInvalidFile";
      v3 = "InvalidFile";
      goto LABEL_9;
    case 2uLL:
      v2 = "MTLDynamicLibraryErrorCompilationFailure";
      v3 = "CompilationFailure";
      goto LABEL_9;
    case 3uLL:
      v2 = "MTLDynamicLibraryErrorUnresolvedInstallName";
      v3 = "UnresolvedInstallName";
      goto LABEL_9;
    case 4uLL:
      v2 = "MTLDynamicLibraryErrorDependencyLoadFailure";
      v3 = "DependencyLoadFailure";
      goto LABEL_9;
    case 5uLL:
      v2 = "MTLDynamicLibraryErrorUnsupported";
      v3 = "Unsupported";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDynamicLibraryLoadOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLDynamicLibraryLoadOptionNone";
      v5 = "LoadOptionNone";
      goto LABEL_7;
    case 1uLL:
      v4 = "MTLDynamicLibraryLoadSkipAIRValidation";
      v5 = "LoadSkipAIRValidation";
      goto LABEL_7;
    case 2uLL:
      v4 = "MTLDynamicLibraryEnableInstrumentation";
      v5 = "EnableInstrumentation";
      goto LABEL_7;
    case 4uLL:
      v4 = "MTLDynamicLibraryEnableResourcePatchingInstrumentation";
      v5 = "EnableResourcePatchingInstrumentation";
      goto LABEL_7;
    case 8uLL:
      v4 = "MTLDynamicLibraryEnableResourceUsageInstrumentation";
      v5 = "EnableResourceUsageInstrumentation";
LABEL_7:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDynamicLibrarySerializationOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 1uLL:
      v4 = "MTLDynamicLibrarySerializationAtomic";
      v5 = "Atomic";
      goto LABEL_11;
    case 2uLL:
      v4 = "MTLDynamicLibrarySerializationChecksum";
      v5 = "Checksum";
      goto LABEL_11;
    case 3uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      return result;
    case 4uLL:
      v4 = "MTLDynamicLibrarySerializationDeviceAspect";
      v5 = "DeviceAspect";
      goto LABEL_11;
    case 8uLL:
      v4 = "MTLDynamicLibrarySerializationAirAspectIfAvailable";
      v5 = "AirAspectIfAvailable";
LABEL_11:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      v6 = "MTLDynamicLibrarySerializationAirAspectAlways";
      if (a2)
        v6 = "AirAspectAlways";
      if (this == (GPUTools::MTL *)16)
        result = v6;
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLDynamicLibraryTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLDynamicLibraryTypeInvalid";
      v3 = "Invalid";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLDynamicLibraryTypeAIROnly";
      v3 = "AIROnly";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLDynamicLibraryTypeCompatible";
      v3 = "Compatible";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLDynamicLibraryTypeRebuild";
      v3 = "Rebuild";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLDynamicLibraryTypeNoVendorSlice";
      v3 = "NoVendorSlice";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLEventOptionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;

  v2 = "MTLEventOptionSupportRollback";
  if (a2)
    v2 = "SupportRollback";
  if (this == (GPUTools::MTL *)1)
    return v2;
  else
    return "Unknown";
}

const char *GPUTools::MTL::GetMTLFeatureSetAsString(uint64_t this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  const char *v8;

  result = "Unknown";
  if (this > 9999)
  {
    if (this <= 20000)
    {
      switch(this)
      {
        case 10000:
          v4 = "MTLFeatureSet_macOS_GPUFamily1_v1";
          v5 = "macOS_GPUFamily1_v1";
          goto LABEL_42;
        case 10001:
          v4 = "MTLFeatureSet_macOS_GPUFamily1_v2";
          v5 = "macOS_GPUFamily1_v2";
          goto LABEL_42;
        case 10002:
          v4 = "MTLFeatureSet_macOS_ReadWriteTextureTier2";
          v5 = "macOS_ReadWriteTextureTier2";
          goto LABEL_42;
        case 10003:
          v4 = "MTLFeatureSet_macOS_GPUFamily1_v3";
          v5 = "macOS_GPUFamily1_v3";
          goto LABEL_42;
        case 10004:
          v4 = "MTLFeatureSet_macOS_GPUFamily1_v4";
          v5 = "macOS_GPUFamily1_v4";
          goto LABEL_42;
        case 10005:
          v4 = "MTLFeatureSet_macOS_GPUFamily2_v1";
          v5 = "macOS_GPUFamily2_v1";
          goto LABEL_42;
        default:
          v6 = 20000;
          v7 = "MTLFeatureSet_watchOS_GPUFamily1_v1";
          v8 = "watchOS_GPUFamily1_v1";
          goto LABEL_11;
      }
    }
    switch(this)
    {
      case 30000:
        v4 = "MTLFeatureSet_tvOS_GPUFamily1_v1";
        v5 = "tvOS_GPUFamily1_v1";
        goto LABEL_42;
      case 30001:
        v4 = "MTLFeatureSet_tvOS_GPUFamily1_v2";
        v5 = "tvOS_GPUFamily1_v2";
        goto LABEL_42;
      case 30002:
        v4 = "MTLFeatureSet_tvOS_GPUFamily1_v3";
        v5 = "tvOS_GPUFamily1_v3";
        goto LABEL_42;
      case 30003:
        v4 = "MTLFeatureSet_tvOS_GPUFamily2_v1";
        v5 = "tvOS_GPUFamily2_v1";
        goto LABEL_42;
      case 30004:
        v4 = "MTLFeatureSet_tvOS_GPUFamily1_v4";
        v5 = "tvOS_GPUFamily1_v4";
        goto LABEL_42;
      case 30005:
        v4 = "MTLFeatureSet_tvOS_GPUFamily2_v2";
        v5 = "tvOS_GPUFamily2_v2";
LABEL_42:
        if (a2)
          result = v5;
        else
          result = v4;
        break;
      default:
        v6 = 20001;
        v7 = "MTLFeatureSet_watchOS_GPUFamily2_v1";
        v8 = "watchOS_GPUFamily2_v1";
LABEL_11:
        if (a2)
          v7 = v8;
        if (this == v6)
          result = v7;
        break;
    }
  }
  else
  {
    switch(this)
    {
      case 0:
        v4 = "MTLFeatureSet_iOS_GPUFamily1_v1";
        v5 = "iOS_GPUFamily1_v1";
        goto LABEL_42;
      case 1:
        v4 = "MTLFeatureSet_iOS_GPUFamily2_v1";
        v5 = "iOS_GPUFamily2_v1";
        goto LABEL_42;
      case 2:
        v4 = "MTLFeatureSet_iOS_GPUFamily1_v2";
        v5 = "iOS_GPUFamily1_v2";
        goto LABEL_42;
      case 3:
        v4 = "MTLFeatureSet_iOS_GPUFamily2_v2";
        v5 = "iOS_GPUFamily2_v2";
        goto LABEL_42;
      case 4:
        v4 = "MTLFeatureSet_iOS_GPUFamily3_v1";
        v5 = "iOS_GPUFamily3_v1";
        goto LABEL_42;
      case 5:
        v4 = "MTLFeatureSet_iOS_GPUFamily1_v3";
        v5 = "iOS_GPUFamily1_v3";
        goto LABEL_42;
      case 6:
        v4 = "MTLFeatureSet_iOS_GPUFamily2_v3";
        v5 = "iOS_GPUFamily2_v3";
        goto LABEL_42;
      case 7:
        v4 = "MTLFeatureSet_iOS_GPUFamily3_v2";
        v5 = "iOS_GPUFamily3_v2";
        goto LABEL_42;
      case 8:
        v4 = "MTLFeatureSet_iOS_GPUFamily1_v4";
        v5 = "iOS_GPUFamily1_v4";
        goto LABEL_42;
      case 9:
        v4 = "MTLFeatureSet_iOS_GPUFamily2_v4";
        v5 = "iOS_GPUFamily2_v4";
        goto LABEL_42;
      case 10:
        v4 = "MTLFeatureSet_iOS_GPUFamily3_v3";
        v5 = "iOS_GPUFamily3_v3";
        goto LABEL_42;
      case 11:
        v4 = "MTLFeatureSet_iOS_GPUFamily4_v1";
        v5 = "iOS_GPUFamily4_v1";
        goto LABEL_42;
      case 12:
        v4 = "MTLFeatureSet_iOS_GPUFamily1_v5";
        v5 = "iOS_GPUFamily1_v5";
        goto LABEL_42;
      case 13:
        v4 = "MTLFeatureSet_iOS_GPUFamily2_v5";
        v5 = "iOS_GPUFamily2_v5";
        goto LABEL_42;
      case 14:
        v4 = "MTLFeatureSet_iOS_GPUFamily3_v4";
        v5 = "iOS_GPUFamily3_v4";
        goto LABEL_42;
      case 15:
        v4 = "MTLFeatureSet_iOS_GPUFamily4_v2";
        v5 = "iOS_GPUFamily4_v2";
        goto LABEL_42;
      case 16:
        v4 = "MTLFeatureSet_iOS_GPUFamily5_v1";
        v5 = "iOS_GPUFamily5_v1";
        goto LABEL_42;
      default:
        return result;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLFunctionLogTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;

  v2 = "MTLFunctionLogTypeValidation";
  if (a2)
    v2 = "Validation";
  if (this)
    return "Unknown";
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLFunctionOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLFunctionOptionNone";
      v5 = "None";
      goto LABEL_6;
    case 1uLL:
      v4 = "MTLFunctionOptionCompileToBinary";
      v5 = "CompileToBinary";
      goto LABEL_6;
    case 2uLL:
      v4 = "MTLFunctionOptionStoreFunctionInMetalScript";
      v5 = "StoreFunctionInMetalScript";
      goto LABEL_6;
    case 4uLL:
      v4 = "MTLFunctionOptionFailOnBinaryArchiveMiss";
      v5 = "FailOnBinaryArchiveMiss";
LABEL_6:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLFunctionTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *result;

  switch((unint64_t)this)
  {
    case 1uLL:
      v2 = "MTLFunctionTypeVertex";
      v3 = "Vertex";
      goto LABEL_15;
    case 2uLL:
      v2 = "MTLFunctionTypeFragment";
      v3 = "Fragment";
      goto LABEL_15;
    case 3uLL:
      v2 = "MTLFunctionTypeKernel";
      v3 = "Kernel";
      goto LABEL_15;
    case 4uLL:
      v2 = "MTLFunctionTypeExtern";
      v3 = "Extern";
      goto LABEL_15;
    case 5uLL:
      v2 = "MTLFunctionTypeVisible";
      v3 = "Visible";
      goto LABEL_15;
    case 6uLL:
      v2 = "MTLFunctionTypeIntersection";
      v3 = "Intersection";
      goto LABEL_15;
    case 7uLL:
      v2 = "MTLFunctionTypeMesh";
      v3 = "Mesh";
      goto LABEL_15;
    case 8uLL:
      v2 = "MTLFunctionTypeObject";
      v3 = "Object";
LABEL_15:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      v4 = "MTLFunctionTypeInvalid";
      if (a2)
        v4 = "Invalid";
      if (this == (GPUTools::MTL *)0xFFFF)
        result = v4;
      else
        result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGLFragmentInputTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLGLFragmentInputTypePPAttrib";
  if (a2)
    v3 = "PPAttrib";
  v4 = "MTLGLFragmentInputTypeGeneric";
  if (a2)
    v4 = "Generic";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLGPUAddressSpaceAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 1uLL:
      v4 = "MTLGPUAddressSpaceDevice";
      v5 = "Device";
      goto LABEL_6;
    case 2uLL:
      v4 = "MTLGPUAddressSpaceConstant";
      v5 = "Constant";
      goto LABEL_6;
    case 3uLL:
      v4 = "MTLGPUAddressSpaceThreadgroup";
      v5 = "Threadgroup";
      goto LABEL_6;
    case 5uLL:
      v4 = "MTLGPUAddressSpaceRayPayload";
      v5 = "RayPayload";
LABEL_6:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGPUFamilyAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  const char *v13;
  const char *v14;

  result = "Unknown";
  if ((uint64_t)this > 2000)
  {
    if ((uint64_t)this > 3002)
    {
      v6 = "MTLGPUFamilyMacCatalyst2";
      if (a2)
        v6 = "MacCatalyst2";
      v13 = "MTLGPUFamilyMetal3";
      if (a2)
        v13 = "Metal3";
      if (this != (GPUTools::MTL *)5001)
        v13 = "Unknown";
      if (this != (GPUTools::MTL *)4002)
        v6 = v13;
      v8 = "MTLGPUFamilyCommon3";
      if (a2)
        v8 = "Common3";
      v14 = "MTLGPUFamilyMacCatalyst1";
      if (a2)
        v14 = "MacCatalyst1";
      if (this != (GPUTools::MTL *)4001)
        v14 = "Unknown";
      if (this != (GPUTools::MTL *)3003)
        v8 = v14;
      v12 = __OFSUB__(this, 4001);
      v10 = this == (GPUTools::MTL *)4001;
      v11 = (uint64_t)this - 4001 < 0;
    }
    else
    {
      v6 = "MTLGPUFamilyCommon1";
      if (a2)
        v6 = "Common1";
      v7 = "MTLGPUFamilyCommon2";
      if (a2)
        v7 = "Common2";
      if (this != (GPUTools::MTL *)3002)
        v7 = "Unknown";
      if (this != (GPUTools::MTL *)3001)
        v6 = v7;
      v8 = "MTLGPUFamilyMac1";
      if (a2)
        v8 = "Mac1";
      v9 = "MTLGPUFamilyMac2";
      if (a2)
        v9 = "Mac2";
      if (this != (GPUTools::MTL *)2002)
        v9 = "Unknown";
      if (this != (GPUTools::MTL *)2001)
        v8 = v9;
      v12 = __OFSUB__(this, 3000);
      v10 = this == (GPUTools::MTL *)3000;
      v11 = (uint64_t)this - 3000 < 0;
    }
    if (v11 ^ v12 | v10)
      return v8;
    else
      return v6;
  }
  else
  {
    switch((unint64_t)this)
    {
      case 0x3E9uLL:
        v4 = "MTLGPUFamilyApple1";
        v5 = "Apple1";
        goto LABEL_51;
      case 0x3EAuLL:
        v4 = "MTLGPUFamilyApple2";
        v5 = "Apple2";
        goto LABEL_51;
      case 0x3EBuLL:
        v4 = "MTLGPUFamilyApple3";
        v5 = "Apple3";
        goto LABEL_51;
      case 0x3ECuLL:
        v4 = "MTLGPUFamilyApple4";
        v5 = "Apple4";
        goto LABEL_51;
      case 0x3EDuLL:
        v4 = "MTLGPUFamilyApple5";
        v5 = "Apple5";
        goto LABEL_51;
      case 0x3EEuLL:
        v4 = "MTLGPUFamilyApple6";
        v5 = "Apple6";
        goto LABEL_51;
      case 0x3EFuLL:
        v4 = "MTLGPUFamilyApple7";
        v5 = "Apple7";
        goto LABEL_51;
      case 0x3F0uLL:
        v4 = "MTLGPUFamilyApple8";
        v5 = "Apple8";
        goto LABEL_51;
      case 0x3F1uLL:
        v4 = "MTLGPUFamilyApple9";
        v5 = "Apple9";
        goto LABEL_51;
      case 0x3F2uLL:
        v4 = "MTLGPUFamilyApple10";
        v5 = "Apple10";
LABEL_51:
        if (a2)
          result = v5;
        else
          result = v4;
        break;
      default:
        return result;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGPUMemoryErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLGPUMemoryErrorNull";
      v3 = "Null";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLGPUMemoryErrorAddress";
      v3 = "Address";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLGPUMemoryErrorUsage";
      v3 = "Usage";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLGPUMemoryErrorType";
      v3 = "Type";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGPUOperationAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      if (!a2)
        return "MTLGPUOperationUnknown";
      return result;
    case 1uLL:
      v4 = "MTLGPUOperationLoad";
      v5 = "Load";
      goto LABEL_18;
    case 2uLL:
      v4 = "MTLGPUOperationStore";
      v5 = "Store";
      goto LABEL_18;
    case 3uLL:
      v4 = "MTLGPUOperationAtomicLoad";
      v5 = "AtomicLoad";
      goto LABEL_18;
    case 4uLL:
      v4 = "MTLGPUOperationAtomicStore";
      v5 = "AtomicStore";
      goto LABEL_18;
    case 5uLL:
      v4 = "MTLGPUOperationAtomicExchange";
      v5 = "AtomicExchange";
      goto LABEL_18;
    case 6uLL:
      v4 = "MTLGPUOperationAtomicCompareExchange";
      v5 = "AtomicCompareExchange";
      goto LABEL_18;
    case 7uLL:
      v4 = "MTLGPUOperationAtomicFetchAdd";
      v5 = "AtomicFetchAdd";
      goto LABEL_18;
    case 8uLL:
      v4 = "MTLGPUOperationAtomicFetchAnd";
      v5 = "AtomicFetchAnd";
      goto LABEL_18;
    case 9uLL:
      v4 = "MTLGPUOperationAtomicFetchMax";
      v5 = "AtomicFetchMax";
      goto LABEL_18;
    case 0xAuLL:
      v4 = "MTLGPUOperationAtomicFetchMin";
      v5 = "AtomicFetchMin";
      goto LABEL_18;
    case 0xBuLL:
      v4 = "MTLGPUOperationAtomicFetchOr";
      v5 = "AtomicFetchOr";
      goto LABEL_18;
    case 0xCuLL:
      v4 = "MTLGPUOperationAtomicFetchSub";
      v5 = "AtomicFetchSub";
      goto LABEL_18;
    case 0xDuLL:
      v4 = "MTLGPUOperationAtomicFetchXor";
      v5 = "AtomicFetchXor";
LABEL_18:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGPUPriorityAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLGPUPriorityHigh";
      v3 = "High";
      goto LABEL_9;
    case 1uLL:
      v2 = "MTLGPUPriorityNormal";
      v3 = "Normal";
      goto LABEL_9;
    case 2uLL:
      v2 = "MTLGPUPriorityLow";
      v3 = "Low";
      goto LABEL_9;
    case 3uLL:
      v2 = "MTLGPUPriorityDisabled";
      v3 = "Disabled";
      goto LABEL_9;
    case 4uLL:
      v2 = "MTLGPUPriorityNormalHigh";
      v3 = "NormalHigh";
      goto LABEL_9;
    case 5uLL:
      v2 = "MTLGPUPriorityRealTime";
      v3 = "RealTime";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGenericBVHHeaderVersionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0x100uLL:
      v2 = "MTLGenericBVHHeaderVersionInitialSPI";
      v3 = "InitialSPI";
      goto LABEL_9;
    case 0x101uLL:
      v2 = "MTLGenericBVHHeaderVersionMotionSPI";
      v3 = "MotionSPI";
      goto LABEL_9;
    case 0x102uLL:
      v2 = "MTLGenericBVHHeaderVersionPerPrimitiveData";
      v3 = "PerPrimitiveData";
      goto LABEL_9;
    case 0x103uLL:
      v2 = "MTLGenericBVHHeaderVersionUniqueIdentifier";
      v3 = "UniqueIdentifier";
      goto LABEL_9;
    case 0x104uLL:
      v2 = "MTLGenericBVHHeaderVersionCurves";
      v3 = "Curves";
      goto LABEL_9;
    case 0x105uLL:
      v2 = "MTLGenericBVHHeaderVersionRaytracing2024";
      v3 = "Raytracing2024";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLGenericBVHPrimitiveTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLGenericBVHPrimitiveTypeTriangleSPI";
  if (a2)
    v3 = "TriangleSPI";
  v4 = "MTLGenericBVHPrimitiveTypeCurveSPI";
  if (a2)
    v4 = "CurveSPI";
  v5 = "BoundingBoxSPI";
  if (!a2)
    v5 = "MTLGenericBVHPrimitiveTypeBoundingBoxSPI";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLGenericBVHTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLGenericBVHTypePrimitiveSPI";
      v3 = "PrimitiveSPI";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLGenericBVHTypeInstanceSPI";
      v3 = "InstanceSPI";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLGenericBVHTypePrimitiveMotionSPI";
      v3 = "PrimitiveMotionSPI";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLGenericBVHTypeInstanceMotionSPI";
      v3 = "InstanceMotionSPI";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLHazardTrackingModeAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLHazardTrackingModeDefault";
      v5 = "Default";
      goto LABEL_6;
    case 1uLL:
      v4 = "MTLHazardTrackingModeUntracked";
      v5 = "Untracked";
      goto LABEL_6;
    case 2uLL:
      v4 = "MTLHazardTrackingModeTracked";
      v5 = "Tracked";
      goto LABEL_6;
    case 8uLL:
      v4 = "MTLHazardTrackingModeGrouped";
      v5 = "Grouped";
LABEL_6:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLHeapTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLHeapTypeSparse";
  if (a2)
    v3 = "Sparse";
  v4 = "MTLHeapTypePlacement";
  if (a2)
    v4 = "Placement";
  v5 = "Automatic";
  if (!a2)
    v5 = "MTLHeapTypeAutomatic";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLIOCommandQueueTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLIOCommandQueueTypeSerial";
  if (a2)
    v3 = "Serial";
  v4 = "MTLIOCommandQueueTypeConcurrent";
  if (a2)
    v4 = "Concurrent";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLIOCompressionMethodAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLIOCompressionMethodZlib";
      v3 = "Zlib";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLIOCompressionMethodLZFSE";
      v3 = "LZFSE";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLIOCompressionMethodLZ4";
      v3 = "LZ4";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLIOCompressionMethodLZMA";
      v3 = "LZMA";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLIOCompressionMethodLZBitmap";
      v3 = "LZBitmap";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLIOErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLIOErrorURLInvalid";
  if (a2)
    v3 = "URLInvalid";
  v4 = "MTLIOErrorInternal";
  if (a2)
    v4 = "Internal";
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLIOPriorityAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLIOPriorityLow";
  if (a2)
    v3 = "Low";
  v4 = "MTLIOPriorityNormal";
  if (a2)
    v4 = "Normal";
  v5 = "High";
  if (!a2)
    v5 = "MTLIOPriorityHigh";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLIOStatusAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLIOStatusPending";
      v3 = "Pending";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLIOStatusCancelled";
      v3 = "Cancelled";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLIOStatusError";
      v3 = "Error";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLIOStatusComplete";
      v3 = "Complete";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLImageFilterFunctionArgumentTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeTexture2DSPI";
      v3 = "Texture2DSPI";
      goto LABEL_11;
    case 1uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeTexture2DWriteSPI";
      v3 = "Texture2DWriteSPI";
      goto LABEL_11;
    case 2uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeSamplerSPI";
      v3 = "SamplerSPI";
      goto LABEL_11;
    case 3uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeBufferSPI";
      v3 = "BufferSPI";
      goto LABEL_11;
    case 4uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeThreadPositionInGridSPI";
      v3 = "ThreadPositionInGridSPI";
      goto LABEL_11;
    case 5uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeOutputSPI";
      v3 = "OutputSPI";
      goto LABEL_11;
    case 6uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeThreadPositionInThreadgroupSPI";
      v3 = "ThreadPositionInThreadgroupSPI";
      goto LABEL_11;
    case 7uLL:
      v2 = "MTLImageFilterFunctionArgumentTypeImageBlockSPI";
      v3 = "ImageBlockSPI";
LABEL_11:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLIndexTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLIndexTypeUInt32";
  if (a2)
    v3 = "UInt32";
  v4 = "MTLIndexTypeUInt16";
  if (a2)
    v4 = "UInt16";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLIndirectArgumentBuffersTierAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLIndirectArgumentBuffersTier2";
  if (a2)
    v3 = "2";
  v4 = "MTLIndirectArgumentBuffersTier1";
  if (a2)
    v4 = "1";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLIndirectCommandTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;

  result = "Unknown";
  if ((uint64_t)this > 31)
  {
    v6 = "MTLIndirectCommandTypeDrawMeshThreadgroups";
    if (a2)
      v6 = "DrawMeshThreadgroups";
    v7 = "MTLIndirectCommandTypeDrawMeshThreads";
    if (a2)
      v7 = "DrawMeshThreads";
    if (this != (GPUTools::MTL *)256)
      v7 = "Unknown";
    if (this != (GPUTools::MTL *)128)
      v6 = v7;
    v8 = "MTLIndirectCommandTypeConcurrentDispatch";
    if (a2)
      v8 = "ConcurrentDispatch";
    v9 = "MTLIndirectCommandTypeConcurrentDispatchThreads";
    if (a2)
      v9 = "ConcurrentDispatchThreads";
    if (this != (GPUTools::MTL *)64)
      v9 = "Unknown";
    if (this != (GPUTools::MTL *)32)
      v8 = v9;
    if ((uint64_t)this <= 127)
      return v8;
    else
      return v6;
  }
  else
  {
    switch((unint64_t)this)
    {
      case 1uLL:
        v4 = "MTLIndirectCommandTypeDraw";
        v5 = "Draw";
        goto LABEL_26;
      case 2uLL:
        v4 = "MTLIndirectCommandTypeDrawIndexed";
        v5 = "DrawIndexed";
        goto LABEL_26;
      case 4uLL:
        v4 = "MTLIndirectCommandTypeDrawPatches";
        v5 = "DrawPatches";
        goto LABEL_26;
      case 8uLL:
        v4 = "MTLIndirectCommandTypeDrawIndexedPatches";
        v5 = "DrawIndexedPatches";
LABEL_26:
        if (a2)
          result = v5;
        else
          result = v4;
        break;
      default:
        return result;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLIntersectionFunctionSignatureAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;

  result = "Unknown";
  if ((uint64_t)this > 15)
  {
    v6 = "MTLIntersectionFunctionSignatureMaxLevels";
    if (a2)
      v6 = "MaxLevels";
    v7 = "MTLIntersectionFunctionSignatureCurveData";
    if (a2)
      v7 = "CurveData";
    if (this != (GPUTools::MTL *)128)
      v7 = "Unknown";
    if (this != (GPUTools::MTL *)64)
      v6 = v7;
    v8 = "MTLIntersectionFunctionSignaturePrimitiveMotion";
    if (a2)
      v8 = "PrimitiveMotion";
    v9 = "MTLIntersectionFunctionSignatureExtendedLimits";
    if (a2)
      v9 = "ExtendedLimits";
    if (this != (GPUTools::MTL *)32)
      v9 = "Unknown";
    if (this != (GPUTools::MTL *)16)
      v8 = v9;
    if ((uint64_t)this <= 63)
      return v8;
    else
      return v6;
  }
  else
  {
    switch((unint64_t)this)
    {
      case 0uLL:
        v4 = "MTLIntersectionFunctionSignatureNone";
        v5 = "None";
        goto LABEL_27;
      case 1uLL:
        v4 = "MTLIntersectionFunctionSignatureInstancing";
        v5 = "Instancing";
        goto LABEL_27;
      case 2uLL:
        v4 = "MTLIntersectionFunctionSignatureTriangleData";
        v5 = "TriangleData";
        goto LABEL_27;
      case 4uLL:
        v4 = "MTLIntersectionFunctionSignatureWorldSpaceData";
        v5 = "WorldSpaceData";
        goto LABEL_27;
      case 8uLL:
        v4 = "MTLIntersectionFunctionSignatureInstanceMotion";
        v5 = "InstanceMotion";
LABEL_27:
        if (a2)
          result = v5;
        else
          result = v4;
        break;
      default:
        return result;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLLanguageVersionAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  BOOL v10;
  const char *v11;
  const char *v12;

  result = "Unknown";
  if ((uint64_t)this < 0x20000)
  {
    v6 = "MTLLanguageVersion1_0";
    if (a2)
      v6 = "1_0";
    v7 = "MTLLanguageVersion1_1";
    if (a2)
      v7 = "1_1";
    v8 = "MTLLanguageVersion1_2";
    if (a2)
      v8 = "1_2";
    if (this == (GPUTools::MTL *)65538)
      v9 = v8;
    else
      v9 = "Unknown";
    if (this != (GPUTools::MTL *)65537)
      v7 = v9;
    v10 = this == (GPUTools::MTL *)0x10000;
    goto LABEL_29;
  }
  if ((uint64_t)this >= 196608)
  {
    v6 = "MTLLanguageVersion3_0";
    if (a2)
      v6 = "3_0";
    v7 = "MTLLanguageVersion3_1";
    if (a2)
      v7 = "3_1";
    v11 = "MTLLanguageVersion3_2";
    if (a2)
      v11 = "3_2";
    if (this == (GPUTools::MTL *)196610)
      v12 = v11;
    else
      v12 = "Unknown";
    if (this != (GPUTools::MTL *)196609)
      v7 = v12;
    v10 = this == (GPUTools::MTL *)196608;
LABEL_29:
    if (v10)
      return v6;
    else
      return v7;
  }
  switch((unint64_t)this)
  {
    case 0x20000uLL:
      v4 = "MTLLanguageVersion2_0";
      v5 = "2_0";
      goto LABEL_36;
    case 0x20001uLL:
      v4 = "MTLLanguageVersion2_1";
      v5 = "2_1";
      goto LABEL_36;
    case 0x20002uLL:
      v4 = "MTLLanguageVersion2_2";
      v5 = "2_2";
      goto LABEL_36;
    case 0x20003uLL:
      v4 = "MTLLanguageVersion2_3";
      v5 = "2_3";
      goto LABEL_36;
    case 0x20004uLL:
      v4 = "MTLLanguageVersion2_4";
      v5 = "2_4";
LABEL_36:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLLibraryErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 1uLL:
      v2 = "MTLLibraryErrorUnsupported";
      v3 = "Unsupported";
      goto LABEL_9;
    case 2uLL:
      v2 = "MTLLibraryErrorInternal";
      v3 = "Internal";
      goto LABEL_9;
    case 3uLL:
      v2 = "MTLLibraryErrorCompileFailure";
      v3 = "CompileFailure";
      goto LABEL_9;
    case 4uLL:
      v2 = "MTLLibraryErrorCompileWarning";
      v3 = "CompileWarning";
      goto LABEL_9;
    case 5uLL:
      v2 = "MTLLibraryErrorFunctionNotFound";
      v3 = "FunctionNotFound";
      goto LABEL_9;
    case 6uLL:
      v2 = "MTLLibraryErrorFileNotFound";
      v3 = "FileNotFound";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLLibraryOptimizationLevelAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLLibraryOptimizationLevelSize";
  if (a2)
    v3 = "Size";
  v4 = "MTLLibraryOptimizationLevelDefault";
  if (a2)
    v4 = "Default";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLLibraryTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLLibraryTypeExecutable";
  if (a2)
    v3 = "Executable";
  v4 = "MTLLibraryTypeDynamic";
  if (a2)
    v4 = "Dynamic";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLLoadActionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLLoadActionDontCare";
  if (a2)
    v3 = "DontCare";
  v4 = "MTLLoadActionLoad";
  if (a2)
    v4 = "Load";
  v5 = "Clear";
  if (!a2)
    v5 = "MTLLoadActionClear";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLLogLevelAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLLogLevelUndefined";
      v3 = "Undefined";
      goto LABEL_9;
    case 1uLL:
      v2 = "MTLLogLevelDebug";
      v3 = "Debug";
      goto LABEL_9;
    case 2uLL:
      v2 = "MTLLogLevelInfo";
      v3 = "Info";
      goto LABEL_9;
    case 3uLL:
      v2 = "MTLLogLevelNotice";
      v3 = "Notice";
      goto LABEL_9;
    case 4uLL:
      v2 = "MTLLogLevelError";
      v3 = "Error";
      goto LABEL_9;
    case 5uLL:
      v2 = "MTLLogLevelFault";
      v3 = "Fault";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLLogStateErrorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLLogStateErrorInvalidSize";
  if (a2)
    v3 = "InvalidSize";
  v4 = "MTLLogStateErrorInvalid";
  if (a2)
    v4 = "Invalid";
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLLogicOpAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLLogicOpClear";
      v3 = "Clear";
      goto LABEL_19;
    case 1uLL:
      v2 = "MTLLogicOpSet";
      v3 = "Set";
      goto LABEL_19;
    case 2uLL:
      v2 = "MTLLogicOpCopy";
      v3 = "Copy";
      goto LABEL_19;
    case 3uLL:
      v2 = "MTLLogicOpInverseCopy";
      v3 = "InverseCopy";
      goto LABEL_19;
    case 4uLL:
      v2 = "MTLLogicOpNoop";
      v3 = "Noop";
      goto LABEL_19;
    case 5uLL:
      v2 = "MTLLogicOpInverse";
      v3 = "Inverse";
      goto LABEL_19;
    case 6uLL:
      v2 = "MTLLogicOpAnd";
      v3 = "And";
      goto LABEL_19;
    case 7uLL:
      v2 = "MTLLogicOpNand";
      v3 = "Nand";
      goto LABEL_19;
    case 8uLL:
      v2 = "MTLLogicOpOr";
      v3 = "Or";
      goto LABEL_19;
    case 9uLL:
      v2 = "MTLLogicOpNor";
      v3 = "Nor";
      goto LABEL_19;
    case 0xAuLL:
      v2 = "MTLLogicOpXor";
      v3 = "Xor";
      goto LABEL_19;
    case 0xBuLL:
      v2 = "MTLLogicOpEquiv";
      v3 = "Equiv";
      goto LABEL_19;
    case 0xCuLL:
      v2 = "MTLLogicOpRevAnd";
      v3 = "RevAnd";
      goto LABEL_19;
    case 0xDuLL:
      v2 = "MTLLogicOpInvAnd";
      v3 = "InvAnd";
      goto LABEL_19;
    case 0xEuLL:
      v2 = "MTLLogicOpRevOr";
      v3 = "RevOr";
      goto LABEL_19;
    case 0xFuLL:
      v2 = "MTLLogicOpInvOr";
      v3 = "InvOr";
LABEL_19:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLLogicOperationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLLogicOperationClear";
      v3 = "Clear";
      goto LABEL_19;
    case 1uLL:
      v2 = "MTLLogicOperationSet";
      v3 = "Set";
      goto LABEL_19;
    case 2uLL:
      v2 = "MTLLogicOperationCopy";
      v3 = "Copy";
      goto LABEL_19;
    case 3uLL:
      v2 = "MTLLogicOperationInverseCopy";
      v3 = "InverseCopy";
      goto LABEL_19;
    case 4uLL:
      v2 = "MTLLogicOperationNoop";
      v3 = "Noop";
      goto LABEL_19;
    case 5uLL:
      v2 = "MTLLogicOperationInverse";
      v3 = "Inverse";
      goto LABEL_19;
    case 6uLL:
      v2 = "MTLLogicOperationAnd";
      v3 = "And";
      goto LABEL_19;
    case 7uLL:
      v2 = "MTLLogicOperationNand";
      v3 = "Nand";
      goto LABEL_19;
    case 8uLL:
      v2 = "MTLLogicOperationOr";
      v3 = "Or";
      goto LABEL_19;
    case 9uLL:
      v2 = "MTLLogicOperationNor";
      v3 = "Nor";
      goto LABEL_19;
    case 0xAuLL:
      v2 = "MTLLogicOperationXor";
      v3 = "Xor";
      goto LABEL_19;
    case 0xBuLL:
      v2 = "MTLLogicOperationEquiv";
      v3 = "Equiv";
      goto LABEL_19;
    case 0xCuLL:
      v2 = "MTLLogicOperationRevAnd";
      v3 = "RevAnd";
      goto LABEL_19;
    case 0xDuLL:
      v2 = "MTLLogicOperationInvAnd";
      v3 = "InvAnd";
      goto LABEL_19;
    case 0xEuLL:
      v2 = "MTLLogicOperationRevOr";
      v3 = "RevOr";
      goto LABEL_19;
    case 0xFuLL:
      v2 = "MTLLogicOperationInvOr";
      v3 = "InvOr";
LABEL_19:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLMathFloatingPointFunctionsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLMathFloatingPointFunctionsPrecise";
  if (a2)
    v3 = "Precise";
  v4 = "MTLMathFloatingPointFunctionsFast";
  if (a2)
    v4 = "Fast";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLMathModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLMathModeSafe";
  if (a2)
    v3 = "Safe";
  v4 = "MTLMathModeRelaxed";
  if (a2)
    v4 = "Relaxed";
  v5 = "Fast";
  if (!a2)
    v5 = "MTLMathModeFast";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLMatrixLayoutAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLMatrixLayoutRowMajor";
  if (a2)
    v3 = "RowMajor";
  v4 = "MTLMatrixLayoutColumnMajor";
  if (a2)
    v4 = "ColumnMajor";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLMeshTopologyKindAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLMeshTopologyKindNone";
      v3 = "None";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLMeshTopologyKindPoint";
      v3 = "Point";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLMeshTopologyKindLine";
      v3 = "Line";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLMeshTopologyKindTriangle";
      v3 = "Triangle";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLMessageTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLMessageTypeWarning";
  if (a2)
    v3 = "Warning";
  v4 = "MTLMessageTypeError";
  if (a2)
    v4 = "Error";
  v5 = "DebugError";
  if (!a2)
    v5 = "MTLMessageTypeDebugError";
  if (this == (GPUTools::MTL *)8)
    v2 = v5;
  if (this == (GPUTools::MTL *)4)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLMotionBorderModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLMotionBorderModeVanish";
  if (a2)
    v3 = "Vanish";
  v4 = "MTLMotionBorderModeClamp";
  if (a2)
    v4 = "Clamp";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLMultisampleDepthResolveFilterAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLMultisampleDepthResolveFilterSample0";
  if (a2)
    v3 = "Sample0";
  v4 = "MTLMultisampleDepthResolveFilterMin";
  if (a2)
    v4 = "Min";
  v5 = "Max";
  if (!a2)
    v5 = "MTLMultisampleDepthResolveFilterMax";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLMultisampleStencilResolveFilterAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLMultisampleStencilResolveFilterSample0";
  if (a2)
    v3 = "Sample0";
  v4 = "MTLMultisampleStencilResolveFilterDepthResolvedSample";
  if (a2)
    v4 = "DepthResolvedSample";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLMutabilityAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLMutabilityImmutable";
  if (a2)
    v3 = "Immutable";
  v4 = "MTLMutabilityMutable";
  if (a2)
    v4 = "Mutable";
  v5 = "Default";
  if (!a2)
    v5 = "MTLMutabilityDefault";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLPatchTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLPatchTypeQuad";
  if (a2)
    v3 = "Quad";
  v4 = "MTLPatchTypeTriangle";
  if (a2)
    v4 = "Triangle";
  v5 = "None";
  if (!a2)
    v5 = "MTLPatchTypeNone";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLPipelineOptionAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  BOOL v14;
  const char *v15;
  const char *v16;
  const char *v17;

  result = "Unknown";
  if ((uint64_t)this <= 0xFFFFFF)
  {
    if ((uint64_t)this >= 0x40000)
    {
      if ((uint64_t)this >= 0x200000)
      {
        v11 = "MTLPipelineOptionPrivateTraceBuffer";
        if (a2)
          v11 = "PrivateTraceBuffer";
        v12 = "MTLPipelineOptionPrivateCompileTimeStatistics";
        if (a2)
          v12 = "PrivateCompileTimeStatistics";
        v16 = "MTLPipelineOptionPrivateFrameworkGeneratedReflection";
        if (a2)
          v16 = "PrivateFrameworkGeneratedReflection";
        if (this != (GPUTools::MTL *)0x800000)
          v16 = "Unknown";
        if (this != (GPUTools::MTL *)0x400000)
          v12 = v16;
        v14 = this == (GPUTools::MTL *)0x200000;
      }
      else
      {
        v11 = "MTLPipelineOptionPrivatePerformanceStatistics";
        if (a2)
          v11 = "PrivatePerformanceStatistics";
        v12 = "MTLPipelineOptionPrivatePostVertexDump";
        if (a2)
          v12 = "PrivatePostVertexDump";
        v13 = "MTLPipelineOptionPrivateBufferAccessToVertexDescriptor";
        if (a2)
          v13 = "PrivateBufferAccessToVertexDescriptor";
        if (this != (GPUTools::MTL *)0x100000)
          v13 = "Unknown";
        if (this != (GPUTools::MTL *)0x80000)
          v12 = v13;
        v14 = this == (GPUTools::MTL *)0x40000;
      }
    }
    else
    {
      if ((uint64_t)this < 0x8000)
      {
        switch((unint64_t)this)
        {
          case 0uLL:
            v4 = "MTLPipelineOptionNone";
            v5 = "None";
            goto LABEL_77;
          case 1uLL:
            v4 = "MTLPipelineOptionBindingInfo";
            v5 = "BindingInfo";
            goto LABEL_77;
          case 2uLL:
            v4 = "MTLPipelineOptionBufferTypeInfo";
            v5 = "BufferTypeInfo";
            goto LABEL_77;
          case 4uLL:
            v4 = "MTLPipelineOptionFailOnBinaryArchiveMiss";
            v5 = "FailOnBinaryArchiveMiss";
            goto LABEL_77;
          default:
            return result;
        }
        return result;
      }
      v11 = "MTLPipelineOptionPrivateRequestDriverReflection";
      if (a2)
        v11 = "PrivateRequestDriverReflection";
      v12 = "MTLPipelineOptionPrivateBuiltInArguments";
      if (a2)
        v12 = "PrivateBuiltInArguments";
      v15 = "MTLPipelineOptionPrivateFunctionWithNoReflection";
      if (a2)
        v15 = "PrivateFunctionWithNoReflection";
      if (this != (GPUTools::MTL *)0x20000)
        v15 = "Unknown";
      if (this != (GPUTools::MTL *)0x10000)
        v12 = v15;
      v14 = this == (GPUTools::MTL *)0x8000;
    }
    if (v14)
      return v11;
    else
      return v12;
  }
  if ((uint64_t)this > 0x3FFFFFFF)
  {
    if ((uint64_t)this > 0x3FFFFFFFFLL)
    {
      if (this != (GPUTools::MTL *)0x400000000)
      {
        v6 = 0x800000000;
        v7 = "MTLPipelineOptionPrivateShaderValidationChecksEnable";
        if (a2)
          v7 = "PrivateShaderValidationChecksEnable";
        v8 = 0x1000000000;
        v9 = "MTLPipelineOptionPrivateShaderValidationChecksDisable";
        v10 = "PrivateShaderValidationChecksDisable";
        goto LABEL_62;
      }
      v4 = "MTLPipelineOptionPrivateFailOnFSCacheMiss";
      v5 = "PrivateFailOnFSCacheMiss";
    }
    else
    {
      if (this != (GPUTools::MTL *)0x40000000)
      {
        v6 = 0x80000000;
        v7 = "MTLPipelineOptionPrivateEnableResourceUsageInstrumentation";
        if (a2)
          v7 = "PrivateEnableResourceUsageInstrumentation";
        v8 = 0x200000000;
        v9 = "MTLPipelineOptionPrivateForceLateReflection";
        v10 = "PrivateForceLateReflection";
        goto LABEL_62;
      }
      v4 = "MTLPipelineOptionPrivateEnableResourcePatchingInstrumentation";
      v5 = "PrivateEnableResourcePatchingInstrumentation";
    }
    goto LABEL_77;
  }
  if ((uint64_t)this > 0x7FFFFFF)
  {
    if (this != (GPUTools::MTL *)0x8000000)
    {
      v6 = 0x10000000;
      v7 = "MTLPipelineOptionPrivateInlinedSymbols";
      if (a2)
        v7 = "PrivateInlinedSymbols";
      v8 = 0x20000000;
      v9 = "MTLPipelineOptionPrivateStitchingReflection";
      v10 = "PrivateStitchingReflection";
      goto LABEL_62;
    }
    v4 = "MTLPipelineOptionEnableAssertions";
    v5 = "EnableAssertions";
LABEL_77:
    if (a2)
      return v5;
    else
      return v4;
  }
  if (this == (GPUTools::MTL *)0x1000000)
  {
    v4 = "MTLPipelineOptionPrivateDebugInstrumentation";
    v5 = "PrivateDebugInstrumentation";
    goto LABEL_77;
  }
  v6 = 0x2000000;
  v7 = "MTLPipelineOptionPrivateAlmondRequest";
  if (a2)
    v7 = "PrivateAlmondRequest";
  v8 = 0x4000000;
  v9 = "MTLPipelineOptionPrivateZeroOutFragmentShaderRTAI";
  v10 = "PrivateZeroOutFragmentShaderRTAI";
LABEL_62:
  if (a2)
    v9 = v10;
  if (this == (GPUTools::MTL *)v8)
    v17 = v9;
  else
    v17 = "Unknown";
  if (this == (GPUTools::MTL *)v6)
    return v7;
  else
    return v17;
}

const char *GPUTools::MTL::GetMTLPixelFormatAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLPixelFormatInvalid";
      v5 = "Invalid";
      goto LABEL_287;
    case 1uLL:
      v4 = "MTLPixelFormatA8Unorm";
      v5 = "A8Unorm";
      goto LABEL_287;
    case 0xAuLL:
      v4 = "MTLPixelFormatR8Unorm";
      v5 = "R8Unorm";
      goto LABEL_287;
    case 0xBuLL:
      v4 = "MTLPixelFormatR8Unorm_sRGB";
      v5 = "R8Unorm_sRGB";
      goto LABEL_287;
    case 0xCuLL:
      v4 = "MTLPixelFormatR8Snorm";
      v5 = "R8Snorm";
      goto LABEL_287;
    case 0xDuLL:
      v4 = "MTLPixelFormatR8Uint";
      v5 = "R8Uint";
      goto LABEL_287;
    case 0xEuLL:
      v4 = "MTLPixelFormatR8Sint";
      v5 = "R8Sint";
      goto LABEL_287;
    case 0x14uLL:
      v4 = "MTLPixelFormatR16Unorm";
      v5 = "R16Unorm";
      goto LABEL_287;
    case 0x16uLL:
      v4 = "MTLPixelFormatR16Snorm";
      v5 = "R16Snorm";
      goto LABEL_287;
    case 0x17uLL:
      v4 = "MTLPixelFormatR16Uint";
      v5 = "R16Uint";
      goto LABEL_287;
    case 0x18uLL:
      v4 = "MTLPixelFormatR16Sint";
      v5 = "R16Sint";
      goto LABEL_287;
    case 0x19uLL:
      v4 = "MTLPixelFormatR16Float";
      v5 = "R16Float";
      goto LABEL_287;
    case 0x1AuLL:
      v4 = "MTLPixelFormatR16Bfloat";
      v5 = "R16Bfloat";
      goto LABEL_287;
    case 0x1EuLL:
      v4 = "MTLPixelFormatRG8Unorm";
      v5 = "RG8Unorm";
      goto LABEL_287;
    case 0x1FuLL:
      v4 = "MTLPixelFormatRG8Unorm_sRGB";
      v5 = "RG8Unorm_sRGB";
      goto LABEL_287;
    case 0x20uLL:
      v4 = "MTLPixelFormatRG8Snorm";
      v5 = "RG8Snorm";
      goto LABEL_287;
    case 0x21uLL:
      v4 = "MTLPixelFormatRG8Uint";
      v5 = "RG8Uint";
      goto LABEL_287;
    case 0x22uLL:
      v4 = "MTLPixelFormatRG8Sint";
      v5 = "RG8Sint";
      goto LABEL_287;
    case 0x28uLL:
      v4 = "MTLPixelFormatB5G6R5Unorm";
      v5 = "B5G6R5Unorm";
      goto LABEL_287;
    case 0x29uLL:
      v4 = "MTLPixelFormatA1BGR5Unorm";
      v5 = "A1BGR5Unorm";
      goto LABEL_287;
    case 0x2AuLL:
      v4 = "MTLPixelFormatABGR4Unorm";
      v5 = "ABGR4Unorm";
      goto LABEL_287;
    case 0x2BuLL:
      v4 = "MTLPixelFormatBGR5A1Unorm";
      v5 = "BGR5A1Unorm";
      goto LABEL_287;
    case 0x2CuLL:
      v4 = "MTLPixelFormatBGRA4Unorm";
      v5 = "BGRA4Unorm";
      goto LABEL_287;
    case 0x35uLL:
      v4 = "MTLPixelFormatR32Uint";
      v5 = "R32Uint";
      goto LABEL_287;
    case 0x36uLL:
      v4 = "MTLPixelFormatR32Sint";
      v5 = "R32Sint";
      goto LABEL_287;
    case 0x37uLL:
      v4 = "MTLPixelFormatR32Float";
      v5 = "R32Float";
      goto LABEL_287;
    case 0x3CuLL:
      v4 = "MTLPixelFormatRG16Unorm";
      v5 = "RG16Unorm";
      goto LABEL_287;
    case 0x3EuLL:
      v4 = "MTLPixelFormatRG16Snorm";
      v5 = "RG16Snorm";
      goto LABEL_287;
    case 0x3FuLL:
      v4 = "MTLPixelFormatRG16Uint";
      v5 = "RG16Uint";
      goto LABEL_287;
    case 0x40uLL:
      v4 = "MTLPixelFormatRG16Sint";
      v5 = "RG16Sint";
      goto LABEL_287;
    case 0x41uLL:
      v4 = "MTLPixelFormatRG16Float";
      v5 = "RG16Float";
      goto LABEL_287;
    case 0x42uLL:
      v4 = "MTLPixelFormatRG16Bfloat";
      v5 = "RG16Bfloat";
      goto LABEL_287;
    case 0x46uLL:
      v4 = "MTLPixelFormatRGBA8Unorm";
      v5 = "RGBA8Unorm";
      goto LABEL_287;
    case 0x47uLL:
      v4 = "MTLPixelFormatRGBA8Unorm_sRGB";
      v5 = "RGBA8Unorm_sRGB";
      goto LABEL_287;
    case 0x48uLL:
      v4 = "MTLPixelFormatRGBA8Snorm";
      v5 = "RGBA8Snorm";
      goto LABEL_287;
    case 0x49uLL:
      v4 = "MTLPixelFormatRGBA8Uint";
      v5 = "RGBA8Uint";
      goto LABEL_287;
    case 0x4AuLL:
      v4 = "MTLPixelFormatRGBA8Sint";
      v5 = "RGBA8Sint";
      goto LABEL_287;
    case 0x50uLL:
      v4 = "MTLPixelFormatBGRA8Unorm";
      v5 = "BGRA8Unorm";
      goto LABEL_287;
    case 0x51uLL:
      v4 = "MTLPixelFormatBGRA8Unorm_sRGB";
      v5 = "BGRA8Unorm_sRGB";
      goto LABEL_287;
    case 0x54uLL:
      v4 = "MTLPixelFormatARGB8Unorm";
      v5 = "ARGB8Unorm";
      goto LABEL_287;
    case 0x55uLL:
      v4 = "MTLPixelFormatARGB8Unorm_sRGB";
      v5 = "ARGB8Unorm_sRGB";
      goto LABEL_287;
    case 0x5AuLL:
      v4 = "MTLPixelFormatRGB10A2Unorm";
      v5 = "RGB10A2Unorm";
      goto LABEL_287;
    case 0x5BuLL:
      v4 = "MTLPixelFormatRGB10A2Uint";
      v5 = "RGB10A2Uint";
      goto LABEL_287;
    case 0x5CuLL:
      v4 = "MTLPixelFormatRG11B10Float";
      v5 = "RG11B10Float";
      goto LABEL_287;
    case 0x5DuLL:
      v4 = "MTLPixelFormatRGB9E5Float";
      v5 = "RGB9E5Float";
      goto LABEL_287;
    case 0x5EuLL:
      v4 = "MTLPixelFormatBGR10A2Unorm";
      v5 = "BGR10A2Unorm";
      goto LABEL_287;
    case 0x67uLL:
      v4 = "MTLPixelFormatRG32Uint";
      v5 = "RG32Uint";
      goto LABEL_287;
    case 0x68uLL:
      v4 = "MTLPixelFormatRG32Sint";
      v5 = "RG32Sint";
      goto LABEL_287;
    case 0x69uLL:
      v4 = "MTLPixelFormatRG32Float";
      v5 = "RG32Float";
      goto LABEL_287;
    case 0x6EuLL:
      v4 = "MTLPixelFormatRGBA16Unorm";
      v5 = "RGBA16Unorm";
      goto LABEL_287;
    case 0x70uLL:
      v4 = "MTLPixelFormatRGBA16Snorm";
      v5 = "RGBA16Snorm";
      goto LABEL_287;
    case 0x71uLL:
      v4 = "MTLPixelFormatRGBA16Uint";
      v5 = "RGBA16Uint";
      goto LABEL_287;
    case 0x72uLL:
      v4 = "MTLPixelFormatRGBA16Sint";
      v5 = "RGBA16Sint";
      goto LABEL_287;
    case 0x73uLL:
      v4 = "MTLPixelFormatRGBA16Float";
      v5 = "RGBA16Float";
      goto LABEL_287;
    case 0x74uLL:
      v4 = "MTLPixelFormatRGBA16Bfloat";
      v5 = "RGBA16Bfloat";
      goto LABEL_287;
    case 0x7BuLL:
      v4 = "MTLPixelFormatRGBA32Uint";
      v5 = "RGBA32Uint";
      goto LABEL_287;
    case 0x7CuLL:
      v4 = "MTLPixelFormatRGBA32Sint";
      v5 = "RGBA32Sint";
      goto LABEL_287;
    case 0x7DuLL:
      v4 = "MTLPixelFormatRGBA32Float";
      v5 = "RGBA32Float";
      goto LABEL_287;
    case 0x82uLL:
      v4 = "MTLPixelFormatBC1_RGBA";
      v5 = "BC1_RGBA";
      goto LABEL_287;
    case 0x83uLL:
      v4 = "MTLPixelFormatBC1_RGBA_sRGB";
      v5 = "BC1_RGBA_sRGB";
      goto LABEL_287;
    case 0x84uLL:
      v4 = "MTLPixelFormatBC2_RGBA";
      v5 = "BC2_RGBA";
      goto LABEL_287;
    case 0x85uLL:
      v4 = "MTLPixelFormatBC2_RGBA_sRGB";
      v5 = "BC2_RGBA_sRGB";
      goto LABEL_287;
    case 0x86uLL:
      v4 = "MTLPixelFormatBC3_RGBA";
      v5 = "BC3_RGBA";
      goto LABEL_287;
    case 0x87uLL:
      v4 = "MTLPixelFormatBC3_RGBA_sRGB";
      v5 = "BC3_RGBA_sRGB";
      goto LABEL_287;
    case 0x8CuLL:
      v4 = "MTLPixelFormatBC4_RUnorm";
      v5 = "BC4_RUnorm";
      goto LABEL_287;
    case 0x8DuLL:
      v4 = "MTLPixelFormatBC4_RSnorm";
      v5 = "BC4_RSnorm";
      goto LABEL_287;
    case 0x8EuLL:
      v4 = "MTLPixelFormatBC5_RGUnorm";
      v5 = "BC5_RGUnorm";
      goto LABEL_287;
    case 0x8FuLL:
      v4 = "MTLPixelFormatBC5_RGSnorm";
      v5 = "BC5_RGSnorm";
      goto LABEL_287;
    case 0x96uLL:
      v4 = "MTLPixelFormatBC6H_RGBFloat";
      v5 = "BC6H_RGBFloat";
      goto LABEL_287;
    case 0x97uLL:
      v4 = "MTLPixelFormatBC6H_RGBUfloat";
      v5 = "BC6H_RGBUfloat";
      goto LABEL_287;
    case 0x98uLL:
      v4 = "MTLPixelFormatBC7_RGBAUnorm";
      v5 = "BC7_RGBAUnorm";
      goto LABEL_287;
    case 0x99uLL:
      v4 = "MTLPixelFormatBC7_RGBAUnorm_sRGB";
      v5 = "BC7_RGBAUnorm_sRGB";
      goto LABEL_287;
    case 0xA0uLL:
      v4 = "MTLPixelFormatPVRTC_RGB_2BPP";
      v5 = "PVRTC_RGB_2BPP";
      goto LABEL_287;
    case 0xA1uLL:
      v4 = "MTLPixelFormatPVRTC_RGB_2BPP_sRGB";
      v5 = "PVRTC_RGB_2BPP_sRGB";
      goto LABEL_287;
    case 0xA2uLL:
      v4 = "MTLPixelFormatPVRTC_RGB_4BPP";
      v5 = "PVRTC_RGB_4BPP";
      goto LABEL_287;
    case 0xA3uLL:
      v4 = "MTLPixelFormatPVRTC_RGB_4BPP_sRGB";
      v5 = "PVRTC_RGB_4BPP_sRGB";
      goto LABEL_287;
    case 0xA4uLL:
      v4 = "MTLPixelFormatPVRTC_RGBA_2BPP";
      v5 = "PVRTC_RGBA_2BPP";
      goto LABEL_287;
    case 0xA5uLL:
      v4 = "MTLPixelFormatPVRTC_RGBA_2BPP_sRGB";
      v5 = "PVRTC_RGBA_2BPP_sRGB";
      goto LABEL_287;
    case 0xA6uLL:
      v4 = "MTLPixelFormatPVRTC_RGBA_4BPP";
      v5 = "PVRTC_RGBA_4BPP";
      goto LABEL_287;
    case 0xA7uLL:
      v4 = "MTLPixelFormatPVRTC_RGBA_4BPP_sRGB";
      v5 = "PVRTC_RGBA_4BPP_sRGB";
      goto LABEL_287;
    case 0xAAuLL:
      v4 = "MTLPixelFormatEAC_R11Unorm";
      v5 = "EAC_R11Unorm";
      goto LABEL_287;
    case 0xACuLL:
      v4 = "MTLPixelFormatEAC_R11Snorm";
      v5 = "EAC_R11Snorm";
      goto LABEL_287;
    case 0xAEuLL:
      v4 = "MTLPixelFormatEAC_RG11Unorm";
      v5 = "EAC_RG11Unorm";
      goto LABEL_287;
    case 0xB0uLL:
      v4 = "MTLPixelFormatEAC_RG11Snorm";
      v5 = "EAC_RG11Snorm";
      goto LABEL_287;
    case 0xB2uLL:
      v4 = "MTLPixelFormatEAC_RGBA8";
      v5 = "EAC_RGBA8";
      goto LABEL_287;
    case 0xB3uLL:
      v4 = "MTLPixelFormatEAC_RGBA8_sRGB";
      v5 = "EAC_RGBA8_sRGB";
      goto LABEL_287;
    case 0xB4uLL:
      v4 = "MTLPixelFormatETC2_RGB8";
      v5 = "ETC2_RGB8";
      goto LABEL_287;
    case 0xB5uLL:
      v4 = "MTLPixelFormatETC2_RGB8_sRGB";
      v5 = "ETC2_RGB8_sRGB";
      goto LABEL_287;
    case 0xB6uLL:
      v4 = "MTLPixelFormatETC2_RGB8A1";
      v5 = "ETC2_RGB8A1";
      goto LABEL_287;
    case 0xB7uLL:
      v4 = "MTLPixelFormatETC2_RGB8A1_sRGB";
      v5 = "ETC2_RGB8A1_sRGB";
      goto LABEL_287;
    case 0xB9uLL:
      v4 = "MTLPixelFormatASTC_4x2_sRGB";
      v5 = "ASTC_4x2_sRGB";
      goto LABEL_287;
    case 0xBAuLL:
      v4 = "MTLPixelFormatASTC_4x4_sRGB";
      v5 = "ASTC_4x4_sRGB";
      goto LABEL_287;
    case 0xBBuLL:
      v4 = "MTLPixelFormatASTC_5x4_sRGB";
      v5 = "ASTC_5x4_sRGB";
      goto LABEL_287;
    case 0xBCuLL:
      v4 = "MTLPixelFormatASTC_5x5_sRGB";
      v5 = "ASTC_5x5_sRGB";
      goto LABEL_287;
    case 0xBDuLL:
      v4 = "MTLPixelFormatASTC_6x5_sRGB";
      v5 = "ASTC_6x5_sRGB";
      goto LABEL_287;
    case 0xBEuLL:
      v4 = "MTLPixelFormatASTC_6x6_sRGB";
      v5 = "ASTC_6x6_sRGB";
      goto LABEL_287;
    case 0xBFuLL:
      v4 = "MTLPixelFormatASTC_8x4_sRGB";
      v5 = "ASTC_8x4_sRGB";
      goto LABEL_287;
    case 0xC0uLL:
      v4 = "MTLPixelFormatASTC_8x5_sRGB";
      v5 = "ASTC_8x5_sRGB";
      goto LABEL_287;
    case 0xC1uLL:
      v4 = "MTLPixelFormatASTC_8x6_sRGB";
      v5 = "ASTC_8x6_sRGB";
      goto LABEL_287;
    case 0xC2uLL:
      v4 = "MTLPixelFormatASTC_8x8_sRGB";
      v5 = "ASTC_8x8_sRGB";
      goto LABEL_287;
    case 0xC3uLL:
      v4 = "MTLPixelFormatASTC_10x5_sRGB";
      v5 = "ASTC_10x5_sRGB";
      goto LABEL_287;
    case 0xC4uLL:
      v4 = "MTLPixelFormatASTC_10x6_sRGB";
      v5 = "ASTC_10x6_sRGB";
      goto LABEL_287;
    case 0xC5uLL:
      v4 = "MTLPixelFormatASTC_10x8_sRGB";
      v5 = "ASTC_10x8_sRGB";
      goto LABEL_287;
    case 0xC6uLL:
      v4 = "MTLPixelFormatASTC_10x10_sRGB";
      v5 = "ASTC_10x10_sRGB";
      goto LABEL_287;
    case 0xC7uLL:
      v4 = "MTLPixelFormatASTC_12x10_sRGB";
      v5 = "ASTC_12x10_sRGB";
      goto LABEL_287;
    case 0xC8uLL:
      v4 = "MTLPixelFormatASTC_12x12_sRGB";
      v5 = "ASTC_12x12_sRGB";
      goto LABEL_287;
    case 0xCBuLL:
      v4 = "MTLPixelFormatASTC_4x2_LDR";
      v5 = "ASTC_4x2_LDR";
      goto LABEL_287;
    case 0xCCuLL:
      v4 = "MTLPixelFormatASTC_4x4_LDR";
      v5 = "ASTC_4x4_LDR";
      goto LABEL_287;
    case 0xCDuLL:
      v4 = "MTLPixelFormatASTC_5x4_LDR";
      v5 = "ASTC_5x4_LDR";
      goto LABEL_287;
    case 0xCEuLL:
      v4 = "MTLPixelFormatASTC_5x5_LDR";
      v5 = "ASTC_5x5_LDR";
      goto LABEL_287;
    case 0xCFuLL:
      v4 = "MTLPixelFormatASTC_6x5_LDR";
      v5 = "ASTC_6x5_LDR";
      goto LABEL_287;
    case 0xD0uLL:
      v4 = "MTLPixelFormatASTC_6x6_LDR";
      v5 = "ASTC_6x6_LDR";
      goto LABEL_287;
    case 0xD1uLL:
      v4 = "MTLPixelFormatASTC_8x4_LDR";
      v5 = "ASTC_8x4_LDR";
      goto LABEL_287;
    case 0xD2uLL:
      v4 = "MTLPixelFormatASTC_8x5_LDR";
      v5 = "ASTC_8x5_LDR";
      goto LABEL_287;
    case 0xD3uLL:
      v4 = "MTLPixelFormatASTC_8x6_LDR";
      v5 = "ASTC_8x6_LDR";
      goto LABEL_287;
    case 0xD4uLL:
      v4 = "MTLPixelFormatASTC_8x8_LDR";
      v5 = "ASTC_8x8_LDR";
      goto LABEL_287;
    case 0xD5uLL:
      v4 = "MTLPixelFormatASTC_10x5_LDR";
      v5 = "ASTC_10x5_LDR";
      goto LABEL_287;
    case 0xD6uLL:
      v4 = "MTLPixelFormatASTC_10x6_LDR";
      v5 = "ASTC_10x6_LDR";
      goto LABEL_287;
    case 0xD7uLL:
      v4 = "MTLPixelFormatASTC_10x8_LDR";
      v5 = "ASTC_10x8_LDR";
      goto LABEL_287;
    case 0xD8uLL:
      v4 = "MTLPixelFormatASTC_10x10_LDR";
      v5 = "ASTC_10x10_LDR";
      goto LABEL_287;
    case 0xD9uLL:
      v4 = "MTLPixelFormatASTC_12x10_LDR";
      v5 = "ASTC_12x10_LDR";
      goto LABEL_287;
    case 0xDAuLL:
      v4 = "MTLPixelFormatASTC_12x12_LDR";
      v5 = "ASTC_12x12_LDR";
      goto LABEL_287;
    case 0xDDuLL:
      v4 = "MTLPixelFormatASTC_4x2_HDR";
      v5 = "ASTC_4x2_HDR";
      goto LABEL_287;
    case 0xDEuLL:
      v4 = "MTLPixelFormatASTC_4x4_HDR";
      v5 = "ASTC_4x4_HDR";
      goto LABEL_287;
    case 0xDFuLL:
      v4 = "MTLPixelFormatASTC_5x4_HDR";
      v5 = "ASTC_5x4_HDR";
      goto LABEL_287;
    case 0xE0uLL:
      v4 = "MTLPixelFormatASTC_5x5_HDR";
      v5 = "ASTC_5x5_HDR";
      goto LABEL_287;
    case 0xE1uLL:
      v4 = "MTLPixelFormatASTC_6x5_HDR";
      v5 = "ASTC_6x5_HDR";
      goto LABEL_287;
    case 0xE2uLL:
      v4 = "MTLPixelFormatASTC_6x6_HDR";
      v5 = "ASTC_6x6_HDR";
      goto LABEL_287;
    case 0xE3uLL:
      v4 = "MTLPixelFormatASTC_8x4_HDR";
      v5 = "ASTC_8x4_HDR";
      goto LABEL_287;
    case 0xE4uLL:
      v4 = "MTLPixelFormatASTC_8x5_HDR";
      v5 = "ASTC_8x5_HDR";
      goto LABEL_287;
    case 0xE5uLL:
      v4 = "MTLPixelFormatASTC_8x6_HDR";
      v5 = "ASTC_8x6_HDR";
      goto LABEL_287;
    case 0xE6uLL:
      v4 = "MTLPixelFormatASTC_8x8_HDR";
      v5 = "ASTC_8x8_HDR";
      goto LABEL_287;
    case 0xE7uLL:
      v4 = "MTLPixelFormatASTC_10x5_HDR";
      v5 = "ASTC_10x5_HDR";
      goto LABEL_287;
    case 0xE8uLL:
      v4 = "MTLPixelFormatASTC_10x6_HDR";
      v5 = "ASTC_10x6_HDR";
      goto LABEL_287;
    case 0xE9uLL:
      v4 = "MTLPixelFormatASTC_10x8_HDR";
      v5 = "ASTC_10x8_HDR";
      goto LABEL_287;
    case 0xEAuLL:
      v4 = "MTLPixelFormatASTC_10x10_HDR";
      v5 = "ASTC_10x10_HDR";
      goto LABEL_287;
    case 0xEBuLL:
      v4 = "MTLPixelFormatASTC_12x10_HDR";
      v5 = "ASTC_12x10_HDR";
      goto LABEL_287;
    case 0xECuLL:
      v4 = "MTLPixelFormatASTC_12x12_HDR";
      v5 = "ASTC_12x12_HDR";
      goto LABEL_287;
    case 0xF0uLL:
      v4 = "MTLPixelFormatGBGR422";
      v5 = "GBGR422";
      goto LABEL_287;
    case 0xF1uLL:
      v4 = "MTLPixelFormatBGRG422";
      v5 = "BGRG422";
      goto LABEL_287;
    case 0xFAuLL:
      v4 = "MTLPixelFormatDepth16Unorm";
      v5 = "Depth16Unorm";
      goto LABEL_287;
    case 0xFCuLL:
      v4 = "MTLPixelFormatDepth32Float";
      v5 = "Depth32Float";
      goto LABEL_287;
    case 0xFDuLL:
      v4 = "MTLPixelFormatStencil8";
      v5 = "Stencil8";
      goto LABEL_287;
    case 0xFFuLL:
      v4 = "MTLPixelFormatDepth24Unorm_Stencil8";
      v5 = "Depth24Unorm_Stencil8";
      goto LABEL_287;
    case 0x104uLL:
      v4 = "MTLPixelFormatDepth32Float_Stencil8";
      v5 = "Depth32Float_Stencil8";
      goto LABEL_287;
    case 0x105uLL:
      v4 = "MTLPixelFormatX32_Stencil8";
      v5 = "X32_Stencil8";
      goto LABEL_287;
    case 0x106uLL:
      v4 = "MTLPixelFormatX24_Stencil8";
      v5 = "X24_Stencil8";
      goto LABEL_287;
    case 0x12CuLL:
      v4 = "MTLPixelFormatRGBX8Unorm";
      v5 = "RGBX8Unorm";
      goto LABEL_287;
    case 0x12DuLL:
      v4 = "MTLPixelFormatRGBX8Unorm_sRGB";
      v5 = "RGBX8Unorm_sRGB";
      goto LABEL_287;
    case 0x12EuLL:
      v4 = "MTLPixelFormatRGBX8Snorm";
      v5 = "RGBX8Snorm";
      goto LABEL_287;
    case 0x12FuLL:
      v4 = "MTLPixelFormatRGBX8Uint";
      v5 = "RGBX8Uint";
      goto LABEL_287;
    case 0x130uLL:
      v4 = "MTLPixelFormatRGBX8Sint";
      v5 = "RGBX8Sint";
      goto LABEL_287;
    case 0x139uLL:
      v4 = "MTLPixelFormatRGBX16Uint";
      v5 = "RGBX16Uint";
      goto LABEL_287;
    case 0x13AuLL:
      v4 = "MTLPixelFormatRGBX16Sint";
      v5 = "RGBX16Sint";
      goto LABEL_287;
    case 0x13BuLL:
      v4 = "MTLPixelFormatRGBX16Float";
      v5 = "RGBX16Float";
      goto LABEL_287;
    case 0x143uLL:
      v4 = "MTLPixelFormatRGBX32Uint";
      v5 = "RGBX32Uint";
      goto LABEL_287;
    case 0x144uLL:
      v4 = "MTLPixelFormatRGBX32Sint";
      v5 = "RGBX32Sint";
      goto LABEL_287;
    case 0x145uLL:
      v4 = "MTLPixelFormatRGBX32Float";
      v5 = "RGBX32Float";
      goto LABEL_287;
    case 0x1F4uLL:
      v4 = "MTLPixelFormatYCBCR8_420_2P";
      v5 = "YCBCR8_420_2P";
      goto LABEL_287;
    case 0x1F5uLL:
      v4 = "MTLPixelFormatYCBCR8_422_1P";
      v5 = "YCBCR8_422_1P";
      goto LABEL_287;
    case 0x1F6uLL:
      v4 = "MTLPixelFormatYCBCR8_422_2P";
      v5 = "YCBCR8_422_2P";
      goto LABEL_287;
    case 0x1F7uLL:
      v4 = "MTLPixelFormatYCBCR8_444_2P";
      v5 = "YCBCR8_444_2P";
      goto LABEL_287;
    case 0x1F8uLL:
      v4 = "MTLPixelFormatYCBCR10_444_1P";
      v5 = "YCBCR10_444_1P";
      goto LABEL_287;
    case 0x1F9uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P";
      v5 = "YCBCR10_420_2P";
      goto LABEL_287;
    case 0x1FAuLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P";
      v5 = "YCBCR10_422_2P";
      goto LABEL_287;
    case 0x1FBuLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P";
      v5 = "YCBCR10_444_2P";
      goto LABEL_287;
    case 0x1FCuLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_PACKED";
      v5 = "YCBCR10_420_2P_PACKED";
      goto LABEL_287;
    case 0x1FDuLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_PACKED";
      v5 = "YCBCR10_422_2P_PACKED";
      goto LABEL_287;
    case 0x1FEuLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_PACKED";
      v5 = "YCBCR10_444_2P_PACKED";
      goto LABEL_287;
    case 0x208uLL:
      v4 = "MTLPixelFormatYCBCR8_420_2P_sRGB";
      v5 = "YCBCR8_420_2P_sRGB";
      goto LABEL_287;
    case 0x209uLL:
      v4 = "MTLPixelFormatYCBCR8_422_1P_sRGB";
      v5 = "YCBCR8_422_1P_sRGB";
      goto LABEL_287;
    case 0x20AuLL:
      v4 = "MTLPixelFormatYCBCR8_422_2P_sRGB";
      v5 = "YCBCR8_422_2P_sRGB";
      goto LABEL_287;
    case 0x20BuLL:
      v4 = "MTLPixelFormatYCBCR8_444_2P_sRGB";
      v5 = "YCBCR8_444_2P_sRGB";
      goto LABEL_287;
    case 0x20CuLL:
      v4 = "MTLPixelFormatYCBCR10_444_1P_sRGB";
      v5 = "YCBCR10_444_1P_sRGB";
      goto LABEL_287;
    case 0x20DuLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_sRGB";
      v5 = "YCBCR10_420_2P_sRGB";
      goto LABEL_287;
    case 0x20EuLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_sRGB";
      v5 = "YCBCR10_422_2P_sRGB";
      goto LABEL_287;
    case 0x20FuLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_sRGB";
      v5 = "YCBCR10_444_2P_sRGB";
      goto LABEL_287;
    case 0x210uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_PACKED_sRGB";
      v5 = "YCBCR10_420_2P_PACKED_sRGB";
      goto LABEL_287;
    case 0x211uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_PACKED_sRGB";
      v5 = "YCBCR10_422_2P_PACKED_sRGB";
      goto LABEL_287;
    case 0x212uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_PACKED_sRGB";
      v5 = "YCBCR10_444_2P_PACKED_sRGB";
      goto LABEL_287;
    case 0x21CuLL:
      v4 = "MTLPixelFormatRGB8_420_2P";
      v5 = "RGB8_420_2P";
      goto LABEL_287;
    case 0x21DuLL:
      v4 = "MTLPixelFormatRGB8_422_2P";
      v5 = "RGB8_422_2P";
      goto LABEL_287;
    case 0x21EuLL:
      v4 = "MTLPixelFormatRGB8_444_2P";
      v5 = "RGB8_444_2P";
      goto LABEL_287;
    case 0x21FuLL:
      v4 = "MTLPixelFormatRGB10_420_2P";
      v5 = "RGB10_420_2P";
      goto LABEL_287;
    case 0x220uLL:
      v4 = "MTLPixelFormatRGB10_422_2P";
      v5 = "RGB10_422_2P";
      goto LABEL_287;
    case 0x221uLL:
      v4 = "MTLPixelFormatRGB10_444_2P";
      v5 = "RGB10_444_2P";
      goto LABEL_287;
    case 0x222uLL:
      v4 = "MTLPixelFormatRGB10_420_2P_PACKED";
      v5 = "RGB10_420_2P_PACKED";
      goto LABEL_287;
    case 0x223uLL:
      v4 = "MTLPixelFormatRGB10_422_2P_PACKED";
      v5 = "RGB10_422_2P_PACKED";
      goto LABEL_287;
    case 0x224uLL:
      v4 = "MTLPixelFormatRGB10_444_2P_PACKED";
      v5 = "RGB10_444_2P_PACKED";
      goto LABEL_287;
    case 0x226uLL:
      v4 = "MTLPixelFormatRGB10A8_2P_XR10";
      v5 = "RGB10A8_2P_XR10";
      goto LABEL_287;
    case 0x227uLL:
      v4 = "MTLPixelFormatRGB10A8_2P_XR10_sRGB";
      v5 = "RGB10A8_2P_XR10_sRGB";
      goto LABEL_287;
    case 0x228uLL:
      v4 = "MTLPixelFormatBGRA10_XR";
      v5 = "BGRA10_XR";
      goto LABEL_287;
    case 0x229uLL:
      v4 = "MTLPixelFormatBGRA10_XR_sRGB";
      v5 = "BGRA10_XR_sRGB";
      goto LABEL_287;
    case 0x22AuLL:
      v4 = "MTLPixelFormatBGR10_XR";
      v5 = "BGR10_XR";
      goto LABEL_287;
    case 0x22BuLL:
      v4 = "MTLPixelFormatBGR10_XR_sRGB";
      v5 = "BGR10_XR_sRGB";
      goto LABEL_287;
    case 0x22CuLL:
      v4 = "MTLPixelFormatRGBA16Float_XR";
      v5 = "RGBA16Float_XR";
      goto LABEL_287;
    case 0x230uLL:
      v4 = "MTLPixelFormatYCBCRA8_444_1P";
      v5 = "YCBCRA8_444_1P";
      goto LABEL_287;
    case 0x232uLL:
      v4 = "MTLPixelFormatYCBCR8_422_1P_REV";
      v5 = "YCBCR8_422_1P_REV";
      goto LABEL_287;
    case 0x233uLL:
      v4 = "MTLPixelFormatYCBCR10_444_1P_PQ";
      v5 = "YCBCR10_444_1P_PQ";
      goto LABEL_287;
    case 0x234uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_PQ";
      v5 = "YCBCR10_420_2P_PQ";
      goto LABEL_287;
    case 0x235uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_PQ";
      v5 = "YCBCR10_422_2P_PQ";
      goto LABEL_287;
    case 0x236uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_PQ";
      v5 = "YCBCR10_444_2P_PQ";
      goto LABEL_287;
    case 0x237uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_PACKED_PQ";
      v5 = "YCBCR10_420_2P_PACKED_PQ";
      goto LABEL_287;
    case 0x238uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_PACKED_PQ";
      v5 = "YCBCR10_422_2P_PACKED_PQ";
      goto LABEL_287;
    case 0x239uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_PACKED_PQ";
      v5 = "YCBCR10_444_2P_PACKED_PQ";
      goto LABEL_287;
    case 0x23AuLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P";
      v5 = "YCBCR12_420_2P";
      goto LABEL_287;
    case 0x23BuLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P";
      v5 = "YCBCR12_422_2P";
      goto LABEL_287;
    case 0x23CuLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P";
      v5 = "YCBCR12_444_2P";
      goto LABEL_287;
    case 0x23DuLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_PQ";
      v5 = "YCBCR12_420_2P_PQ";
      goto LABEL_287;
    case 0x23EuLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_PQ";
      v5 = "YCBCR12_422_2P_PQ";
      goto LABEL_287;
    case 0x23FuLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_PQ";
      v5 = "YCBCR12_444_2P_PQ";
      goto LABEL_287;
    case 0x240uLL:
      v4 = "MTLPixelFormatR10Unorm_X6";
      v5 = "R10Unorm_X6";
      goto LABEL_287;
    case 0x241uLL:
      v4 = "MTLPixelFormatR10Unorm_X6_sRGB";
      v5 = "R10Unorm_X6_sRGB";
      goto LABEL_287;
    case 0x242uLL:
      v4 = "MTLPixelFormatRG10Unorm_X12";
      v5 = "RG10Unorm_X12";
      goto LABEL_287;
    case 0x243uLL:
      v4 = "MTLPixelFormatRG10Unorm_X12_sRGB";
      v5 = "RG10Unorm_X12_sRGB";
      goto LABEL_287;
    case 0x244uLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_PACKED";
      v5 = "YCBCR12_420_2P_PACKED";
      goto LABEL_287;
    case 0x245uLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_PACKED";
      v5 = "YCBCR12_422_2P_PACKED";
      goto LABEL_287;
    case 0x246uLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_PACKED";
      v5 = "YCBCR12_444_2P_PACKED";
      goto LABEL_287;
    case 0x247uLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_PACKED_PQ";
      v5 = "YCBCR12_420_2P_PACKED_PQ";
      goto LABEL_287;
    case 0x248uLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_PACKED_PQ";
      v5 = "YCBCR12_422_2P_PACKED_PQ";
      goto LABEL_287;
    case 0x249uLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_PACKED_PQ";
      v5 = "YCBCR12_444_2P_PACKED_PQ";
      goto LABEL_287;
    case 0x24AuLL:
      v4 = "MTLPixelFormatRGB10A2Unorm_sRGB";
      v5 = "RGB10A2Unorm_sRGB";
      goto LABEL_287;
    case 0x24BuLL:
      v4 = "MTLPixelFormatRGB10A2Unorm_PQ";
      v5 = "RGB10A2Unorm_PQ";
      goto LABEL_287;
    case 0x24CuLL:
      v4 = "MTLPixelFormatR10Unorm_PACKED";
      v5 = "R10Unorm_PACKED";
      goto LABEL_287;
    case 0x24DuLL:
      v4 = "MTLPixelFormatRG10Unorm_PACKED";
      v5 = "RG10Unorm_PACKED";
      goto LABEL_287;
    case 0x24EuLL:
      v4 = "MTLPixelFormatYCBCR10_444_1P_XR";
      v5 = "YCBCR10_444_1P_XR";
      goto LABEL_287;
    case 0x24FuLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_XR";
      v5 = "YCBCR10_420_2P_XR";
      goto LABEL_287;
    case 0x250uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_XR";
      v5 = "YCBCR10_422_2P_XR";
      goto LABEL_287;
    case 0x251uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_XR";
      v5 = "YCBCR10_444_2P_XR";
      goto LABEL_287;
    case 0x252uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_PACKED_XR";
      v5 = "YCBCR10_420_2P_PACKED_XR";
      goto LABEL_287;
    case 0x253uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_PACKED_XR";
      v5 = "YCBCR10_422_2P_PACKED_XR";
      goto LABEL_287;
    case 0x254uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_PACKED_XR";
      v5 = "YCBCR10_444_2P_PACKED_XR";
      goto LABEL_287;
    case 0x255uLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_XR";
      v5 = "YCBCR12_420_2P_XR";
      goto LABEL_287;
    case 0x256uLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_XR";
      v5 = "YCBCR12_422_2P_XR";
      goto LABEL_287;
    case 0x257uLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_XR";
      v5 = "YCBCR12_444_2P_XR";
      goto LABEL_287;
    case 0x258uLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_PACKED_XR";
      v5 = "YCBCR12_420_2P_PACKED_XR";
      goto LABEL_287;
    case 0x259uLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_PACKED_XR";
      v5 = "YCBCR12_422_2P_PACKED_XR";
      goto LABEL_287;
    case 0x25AuLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_PACKED_XR";
      v5 = "YCBCR12_444_2P_PACKED_XR";
      goto LABEL_287;
    case 0x25BuLL:
      v4 = "MTLPixelFormatR12Unorm_X4";
      v5 = "R12Unorm_X4";
      goto LABEL_287;
    case 0x25CuLL:
      v4 = "MTLPixelFormatR12Unorm_X4_PQ";
      v5 = "R12Unorm_X4_PQ";
      goto LABEL_287;
    case 0x25DuLL:
      v4 = "MTLPixelFormatRG12Unorm_X8";
      v5 = "RG12Unorm_X8";
      goto LABEL_287;
    case 0x25EuLL:
      v4 = "MTLPixelFormatR10Unorm_X6_PQ";
      v5 = "R10Unorm_X6_PQ";
      goto LABEL_287;
    case 0x25FuLL:
      v4 = "MTLPixelFormatYCBCR10_444_1P_HLG";
      v5 = "YCBCR10_444_1P_HLG";
      goto LABEL_287;
    case 0x260uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_HLG";
      v5 = "YCBCR10_420_2P_HLG";
      goto LABEL_287;
    case 0x261uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_HLG";
      v5 = "YCBCR10_422_2P_HLG";
      goto LABEL_287;
    case 0x262uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_HLG";
      v5 = "YCBCR10_444_2P_HLG";
      goto LABEL_287;
    case 0x263uLL:
      v4 = "MTLPixelFormatYCBCR10_420_2P_PACKED_HLG";
      v5 = "YCBCR10_420_2P_PACKED_HLG";
      goto LABEL_287;
    case 0x264uLL:
      v4 = "MTLPixelFormatYCBCR10_422_2P_PACKED_HLG";
      v5 = "YCBCR10_422_2P_PACKED_HLG";
      goto LABEL_287;
    case 0x265uLL:
      v4 = "MTLPixelFormatYCBCR10_444_2P_PACKED_HLG";
      v5 = "YCBCR10_444_2P_PACKED_HLG";
      goto LABEL_287;
    case 0x267uLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_HLG";
      v5 = "YCBCR12_420_2P_HLG";
      goto LABEL_287;
    case 0x268uLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_HLG";
      v5 = "YCBCR12_422_2P_HLG";
      goto LABEL_287;
    case 0x269uLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_HLG";
      v5 = "YCBCR12_444_2P_HLG";
      goto LABEL_287;
    case 0x26AuLL:
      v4 = "MTLPixelFormatYCBCR12_420_2P_PACKED_HLG";
      v5 = "YCBCR12_420_2P_PACKED_HLG";
      goto LABEL_287;
    case 0x26BuLL:
      v4 = "MTLPixelFormatYCBCR12_422_2P_PACKED_HLG";
      v5 = "YCBCR12_422_2P_PACKED_HLG";
      goto LABEL_287;
    case 0x26CuLL:
      v4 = "MTLPixelFormatYCBCR12_444_2P_PACKED_HLG";
      v5 = "YCBCR12_444_2P_PACKED_HLG";
      goto LABEL_287;
    case 0x26DuLL:
      v4 = "MTLPixelFormatR10Unorm_X6_HLG";
      v5 = "R10Unorm_X6_HLG";
      goto LABEL_287;
    case 0x26EuLL:
      v4 = "MTLPixelFormatR12Unorm_X4_HLG";
      v5 = "R12Unorm_X4_HLG";
      goto LABEL_287;
    case 0x26FuLL:
      v4 = "MTLPixelFormatRGB10A2Unorm_HLG";
      v5 = "RGB10A2Unorm_HLG";
      goto LABEL_287;
    case 0x270uLL:
      v4 = "MTLPixelFormatRGB10A8_2P";
      v5 = "RGB10A8_2P";
      goto LABEL_287;
    case 0x271uLL:
      v4 = "MTLPixelFormatRGB10A8_2P_sRGB";
      v5 = "RGB10A8_2P_sRGB";
      goto LABEL_287;
    case 0x272uLL:
      v4 = "MTLPixelFormatRGB10A8_2P_PQ";
      v5 = "RGB10A8_2P_PQ";
      goto LABEL_287;
    case 0x273uLL:
      v4 = "MTLPixelFormatRGB10A8_2P_HLG";
      v5 = "RGB10A8_2P_HLG";
      goto LABEL_287;
    case 0x274uLL:
      v4 = "MTLPixelFormatBGR10A2Unorm_sRGB";
      v5 = "BGR10A2Unorm_sRGB";
      goto LABEL_287;
    case 0x275uLL:
      v4 = "MTLPixelFormatBGR10A2Unorm_PQ";
      v5 = "BGR10A2Unorm_PQ";
      goto LABEL_287;
    case 0x276uLL:
      v4 = "MTLPixelFormatBGRA10Uint_PACKED";
      v5 = "BGRA10Uint_PACKED";
      goto LABEL_287;
    case 0x277uLL:
      v4 = "MTLPixelFormatBGRA10_XR_PACKED";
      v5 = "BGRA10_XR_PACKED";
      goto LABEL_287;
    case 0x278uLL:
      v4 = "MTLPixelFormatBGRA10_XR_PACKED_sRGB";
      v5 = "BGRA10_XR_PACKED_sRGB";
      goto LABEL_287;
    case 0x279uLL:
      v4 = "MTLPixelFormatBGRA10Unorm_PACKED";
      v5 = "BGRA10Unorm_PACKED";
      goto LABEL_287;
    case 0x27AuLL:
      v4 = "MTLPixelFormatBGRA10Unorm_PACKED_sRGB";
      v5 = "BGRA10Unorm_PACKED_sRGB";
      goto LABEL_287;
    case 0x27BuLL:
      v4 = "MTLPixelFormatBGRA10Unorm_PACKED_HLG";
      v5 = "BGRA10Unorm_PACKED_HLG";
      goto LABEL_287;
    case 0x27CuLL:
      v4 = "MTLPixelFormatBGRA10Unorm_PACKED_PQ";
      v5 = "BGRA10Unorm_PACKED_PQ";
      goto LABEL_287;
    case 0x27DuLL:
      v4 = "MTLPixelFormatBGRA10Uint";
      v5 = "BGRA10Uint";
      goto LABEL_287;
    case 0x27EuLL:
      v4 = "MTLPixelFormatBGRA10Unorm";
      v5 = "BGRA10Unorm";
      goto LABEL_287;
    case 0x27FuLL:
      v4 = "MTLPixelFormatBGRA10Unorm_sRGB";
      v5 = "BGRA10Unorm_sRGB";
      goto LABEL_287;
    case 0x280uLL:
      v4 = "MTLPixelFormatBGRA10Unorm_HLG";
      v5 = "BGRA10Unorm_HLG";
      goto LABEL_287;
    case 0x281uLL:
      v4 = "MTLPixelFormatBGRA10Unorm_PQ";
      v5 = "BGRA10Unorm_PQ";
      goto LABEL_287;
    case 0x282uLL:
      v4 = "MTLPixelFormatR10Uint_X6";
      v5 = "R10Uint_X6";
      goto LABEL_287;
    case 0x283uLL:
      v4 = "MTLPixelFormatR10Uint_PACKED";
      v5 = "R10Uint_PACKED";
      goto LABEL_287;
    case 0x284uLL:
      v4 = "MTLPixelFormatRG10Uint_X12";
      v5 = "RG10Uint_X12";
      goto LABEL_287;
    case 0x285uLL:
      v4 = "MTLPixelFormatRG10Uint_PACKED";
      v5 = "RG10Uint_PACKED";
      goto LABEL_287;
    case 0x286uLL:
      v4 = "MTLPixelFormatR12Uint_X4";
      v5 = "R12Uint_X4";
      goto LABEL_287;
    case 0x287uLL:
      v4 = "MTLPixelFormatR12Uint_PACKED";
      v5 = "R12Uint_PACKED";
      goto LABEL_287;
    case 0x288uLL:
      v4 = "MTLPixelFormatRG12Uint_X8";
      v5 = "RG12Uint_X8";
      goto LABEL_287;
    case 0x289uLL:
      v4 = "MTLPixelFormatRG12Uint_PACKED";
      v5 = "RG12Uint_PACKED";
      goto LABEL_287;
    case 0x28AuLL:
      v4 = "MTLPixelFormatRGB10A8Uint_2P";
      v5 = "RGB10A8Uint_2P";
LABEL_287:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLPixelFormatFlagsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  BOOL v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  BOOL v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;

  result = "Unknown";
  if ((uint64_t)this < 0x8000)
  {
    if ((uint64_t)this <= 255)
    {
      if ((uint64_t)this > 15)
      {
        v16 = "MTLPixelFormatFlagsIsStencilRenderable";
        if (a2)
          v16 = "IsStencilRenderable";
        v17 = "MTLPixelFormatFlagsIsAllowedForMSAAResolve";
        if (a2)
          v17 = "IsAllowedForMSAAResolve";
        if (this != (GPUTools::MTL *)128)
          v17 = "Unknown";
        if (this != (GPUTools::MTL *)64)
          v16 = v17;
        v18 = "MTLPixelFormatFlagsIsColorRenderable";
        if (a2)
          v18 = "IsColorRenderable";
        v19 = "MTLPixelFormatFlagsIsDepthRenderable";
        if (a2)
          v19 = "IsDepthRenderable";
        if (this != (GPUTools::MTL *)32)
          v19 = "Unknown";
        if (this != (GPUTools::MTL *)16)
          v18 = v19;
        if ((uint64_t)this <= 63)
          return v18;
        else
          return v16;
      }
      else
      {
        switch((unint64_t)this)
        {
          case 1uLL:
            v4 = "MTLPixelFormatFlagsIsValid";
            v5 = "IsValid";
            goto LABEL_119;
          case 2uLL:
            v4 = "MTLPixelFormatFlagsIsWriteable";
            v5 = "IsWriteable";
            goto LABEL_119;
          case 4uLL:
            v4 = "MTLPixelFormatFlagsIsFilterable";
            v5 = "IsFilterable";
            goto LABEL_119;
          case 8uLL:
            v4 = "MTLPixelFormatFlagsIsBlendable";
            v5 = "IsBlendable";
LABEL_119:
            if (a2)
              result = v5;
            else
              result = v4;
            break;
          default:
            return result;
        }
      }
      return result;
    }
    if ((uint64_t)this > 2047)
    {
      v9 = "MTLPixelFormatFlagsIsPVRTC";
      if (a2)
        v9 = "IsPVRTC";
      v10 = "MTLPixelFormatFlagsIs422";
      if (a2)
        v10 = "Is422";
      if (this != (GPUTools::MTL *)0x4000)
        v10 = "Unknown";
      if (this != (GPUTools::MTL *)0x2000)
        v9 = v10;
      v11 = "MTLPixelFormatFlagsIsSRGB";
      if (a2)
        v11 = "IsSRGB";
      v12 = "MTLPixelFormatFlagsIsASTC";
      if (a2)
        v12 = "IsASTC";
      if (this != (GPUTools::MTL *)4096)
        v12 = "Unknown";
      if (this != (GPUTools::MTL *)2048)
        v11 = v12;
      v13 = (uint64_t)this < 0x2000;
LABEL_51:
      if (v13)
        return v11;
      else
        return v9;
    }
    v6 = "MTLPixelFormatFlagsIsMSAACapable";
    if (a2)
      v6 = "IsMSAACapable";
    v7 = "MTLPixelFormatFlagsIsRestrictedFormatAccess";
    if (a2)
      v7 = "IsRestrictedFormatAccess";
    v25 = "MTLPixelFormatFlagsIsCompressed";
    if (a2)
      v25 = "IsCompressed";
    if (this != (GPUTools::MTL *)1024)
      v25 = "Unknown";
    if (this != (GPUTools::MTL *)512)
      v7 = v25;
    v8 = this == (GPUTools::MTL *)256;
    goto LABEL_99;
  }
  if ((uint64_t)this < 0x400000)
  {
    if ((uint64_t)this >= 0x40000)
    {
      v9 = "MTLPixelFormatFlagsIsShortCompatible";
      if (a2)
        v9 = "IsShortCompatible";
      v14 = "MTLPixelFormatFlagsIsUShortCompatible";
      if (a2)
        v14 = "IsUShortCompatible";
      if (this != (GPUTools::MTL *)0x200000)
        v14 = "Unknown";
      if (this != (GPUTools::MTL *)0x100000)
        v9 = v14;
      v11 = "MTLPixelFormatFlagsIsIntCompatible";
      if (a2)
        v11 = "IsIntCompatible";
      v15 = "MTLPixelFormatFlagsIsUIntCompatible";
      if (a2)
        v15 = "IsUIntCompatible";
      if (this != (GPUTools::MTL *)0x80000)
        v15 = "Unknown";
      if (this != (GPUTools::MTL *)0x40000)
        v11 = v15;
      v13 = (uint64_t)this < 0x100000;
      goto LABEL_51;
    }
    v6 = "MTLPixelFormatFlagsIsFullMaskRequired";
    if (a2)
      v6 = "IsFullMaskRequired";
    v7 = "MTLPixelFormatFlagsIsFloatCompatible";
    if (a2)
      v7 = "IsFloatCompatible";
    v26 = "MTLPixelFormatFlagsIsHalfCompatible";
    if (a2)
      v26 = "IsHalfCompatible";
    if (this != (GPUTools::MTL *)0x20000)
      v26 = "Unknown";
    if (this != (GPUTools::MTL *)0x10000)
      v7 = v26;
    v8 = this == (GPUTools::MTL *)0x8000;
LABEL_99:
    if (v8)
      return v6;
    else
      return v7;
  }
  if ((uint64_t)this > 0x3FFFFFF)
  {
    if ((uint64_t)this > 0xFFFFFFF)
    {
      v20 = 0x10000000;
      v21 = "MTLPixelFormatFlagsIsHLG";
      if (a2)
        v21 = "IsHLG";
      v22 = 0x20000000;
      v23 = "MTLPixelFormatFlagsIsULongCompatible";
      v24 = "IsULongCompatible";
    }
    else
    {
      v20 = 0x4000000;
      v21 = "MTLPixelFormatFlagsIsLossyLevel3Compatible";
      if (a2)
        v21 = "IsLossyLevel3Compatible";
      v22 = 0x8000000;
      v23 = "MTLPixelFormatFlagsIsPQ";
      v24 = "IsPQ";
    }
  }
  else
  {
    if ((uint64_t)this <= 0xFFFFFF)
    {
      v6 = "MTLPixelFormatFlagsIsBC";
      if (a2)
      {
        v6 = "IsBC";
        v7 = "IsDualPlane";
      }
      else
      {
        v7 = "MTLPixelFormatFlagsIsDualPlane";
      }
      if (this != (GPUTools::MTL *)0x800000)
        v7 = "Unknown";
      v8 = this == (GPUTools::MTL *)0x400000;
      goto LABEL_99;
    }
    v20 = 0x1000000;
    v21 = "MTLPixelFormatFlagsIsLossyLevel1Compatible";
    if (a2)
      v21 = "IsLossyLevel1Compatible";
    v22 = 0x2000000;
    v23 = "MTLPixelFormatFlagsIsLossyLevel2Compatible";
    v24 = "IsLossyLevel2Compatible";
  }
  if (a2)
    v23 = v24;
  if (this == (GPUTools::MTL *)v22)
    v27 = v23;
  else
    v27 = "Unknown";
  if (this == (GPUTools::MTL *)v20)
    return v21;
  else
    return v27;
}

const char *GPUTools::MTL::GetMTLPrecompiledDataTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLPrecompiledDataTypePipelineData";
      v3 = "PipelineData";
      goto LABEL_16;
    case 1uLL:
      v2 = "MTLPrecompiledDataTypeVertexFunction";
      v3 = "VertexFunction";
      goto LABEL_16;
    case 2uLL:
      v2 = "MTLPrecompiledDataTypeFragmentFunction";
      v3 = "FragmentFunction";
      goto LABEL_16;
    case 3uLL:
      v2 = "MTLPrecompiledDataTypeComputeFunction";
      v3 = "ComputeFunction";
      goto LABEL_16;
    case 4uLL:
      v2 = "MTLPrecompiledDataTypeVertexReflectionData";
      v3 = "VertexReflectionData";
      goto LABEL_16;
    case 5uLL:
      v2 = "MTLPrecompiledDataTypeFragmentReflectionData";
      v3 = "FragmentReflectionData";
      goto LABEL_16;
    case 6uLL:
      v2 = "MTLPrecompiledDataTypeComputeReflectionData";
      v3 = "ComputeReflectionData";
      goto LABEL_16;
    case 7uLL:
      v2 = "MTLPrecompiledDataTypeTileFunction";
      v3 = "TileFunction";
      goto LABEL_16;
    case 8uLL:
      v2 = "MTLPrecompiledDataTypeTileReflectionData";
      v3 = "TileReflectionData";
LABEL_16:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      v4 = "MTLPrecompiledDataTypeCustomStart";
      if (a2)
        v4 = "CustomStart";
      if (this == (GPUTools::MTL *)256)
        result = v4;
      else
        result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLPrimitiveKindAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLPrimitiveKindNone";
      v3 = "None";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLPrimitiveKindTriangle";
      v3 = "Triangle";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLPrimitiveKindBoundingBox";
      v3 = "BoundingBox";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLPrimitiveKindCurve";
      v3 = "Curve";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLPrimitiveTopologyClassAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLPrimitiveTopologyClassUnspecified";
      v3 = "Unspecified";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLPrimitiveTopologyClassPoint";
      v3 = "Point";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLPrimitiveTopologyClassLine";
      v3 = "Line";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLPrimitiveTopologyClassTriangle";
      v3 = "Triangle";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLPrimitiveTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLPrimitiveTypePoint";
      v3 = "Point";
      goto LABEL_13;
    case 1uLL:
      v2 = "MTLPrimitiveTypeLine";
      v3 = "Line";
      goto LABEL_13;
    case 2uLL:
      v2 = "MTLPrimitiveTypeLineStrip";
      v3 = "LineStrip";
      goto LABEL_13;
    case 3uLL:
      v2 = "MTLPrimitiveTypeTriangle";
      v3 = "Triangle";
      goto LABEL_13;
    case 4uLL:
      v2 = "MTLPrimitiveTypeTriangleStrip";
      v3 = "TriangleStrip";
      goto LABEL_13;
    case 5uLL:
      v2 = "MTLPrimitiveTypeLineLoop";
      v3 = "LineLoop";
      goto LABEL_13;
    case 6uLL:
      v2 = "MTLPrimitiveTypeTriangleFan";
      v3 = "TriangleFan";
      goto LABEL_13;
    case 7uLL:
      v2 = "MTLPrimitiveTypeQuad";
      v3 = "Quad";
      goto LABEL_13;
    case 8uLL:
      v2 = "MTLPrimitiveTypeQuadStrip";
      v3 = "QuadStrip";
      goto LABEL_13;
    case 9uLL:
      v2 = "MTLPrimitiveTypePolygon";
      v3 = "Polygon";
LABEL_13:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLProvokingVertexModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLProvokingVertexModeSecond";
  if (a2)
    v3 = "Second";
  v4 = "MTLProvokingVertexModeLast";
  if (a2)
    v4 = "Last";
  v5 = "First";
  if (!a2)
    v5 = "MTLProvokingVertexModeFirst";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLPurgeableStateAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *result;

  switch((unint64_t)this)
  {
    case 1uLL:
      v2 = "MTLPurgeableStateKeepCurrent";
      v3 = "KeepCurrent";
      goto LABEL_11;
    case 2uLL:
      v2 = "MTLPurgeableStateNonVolatile";
      v3 = "NonVolatile";
      goto LABEL_11;
    case 3uLL:
      v2 = "MTLPurgeableStateVolatile";
      v3 = "Volatile";
      goto LABEL_11;
    case 4uLL:
      v2 = "MTLPurgeableStateEmpty";
      v3 = "Empty";
LABEL_11:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      v4 = "MTLPurgeableStateMakeResident";
      if (a2)
        v4 = "MakeResident";
      if (this == (GPUTools::MTL *)256)
        result = v4;
      else
        result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLQosLevelAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLQosExclusive";
      v3 = "Exclusive";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLQosHigh";
      v3 = "High";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLQosMedium";
      v3 = "Medium";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLQosLow";
      v3 = "Low";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLQosOpportunistic";
      v3 = "Opportunistic";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLReadWriteTextureTierAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLReadWriteTextureTierNone";
  if (a2)
    v3 = "None";
  v4 = "MTLReadWriteTextureTier2";
  if (a2)
    v4 = "2";
  v5 = "1";
  if (!a2)
    v5 = "MTLReadWriteTextureTier1";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLRenderCommandEncoderSplitReasonAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 1uLL:
      v4 = "MTLRenderCommandEncoderSplitReasonTooManyResources";
      v5 = "TooManyResources";
      goto LABEL_14;
    case 2uLL:
      v4 = "MTLRenderCommandEncoderSplitReasonTooManyScissorEmits";
      v5 = "TooManyScissorEmits";
      goto LABEL_14;
    case 3uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      return result;
    case 4uLL:
      v4 = "MTLRenderCommandEncoderSplitReasonTooManyDepthBiasEmits";
      v5 = "TooManyDepthBiasEmits";
      goto LABEL_14;
    case 8uLL:
      v4 = "MTLRenderCommandEncoderSplitReasonForcedManually";
      v5 = "ForcedManually";
LABEL_14:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      v6 = "MTLRenderCommandEncoderSplitReasonInsertMemoryBarrier";
      if (a2)
      {
        v6 = "InsertMemoryBarrier";
        v7 = "RenderPassCommitAndReset";
      }
      else
      {
        v7 = "MTLRenderCommandEncoderSplitReasonRenderPassCommitAndReset";
      }
      if (this != (GPUTools::MTL *)32)
        v7 = "Unknown";
      if (this == (GPUTools::MTL *)16)
        result = v6;
      else
        result = v7;
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLRenderStagesAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 1uLL:
      v4 = "MTLRenderStageVertex";
      v5 = "Vertex";
      goto LABEL_11;
    case 2uLL:
      v4 = "MTLRenderStageFragment";
      v5 = "Fragment";
      goto LABEL_11;
    case 3uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      return result;
    case 4uLL:
      v4 = "MTLRenderStageTile";
      v5 = "Tile";
      goto LABEL_11;
    case 8uLL:
      v4 = "MTLRenderStageObject";
      v5 = "Object";
LABEL_11:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      v6 = "MTLRenderStageMesh";
      if (a2)
        v6 = "Mesh";
      if (this == (GPUTools::MTL *)16)
        result = v6;
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLResourceGroupCacheHintAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLResourceGroupCacheHintInvalidate";
  if (a2)
    v3 = "Invalidate";
  v4 = "MTLResourceGroupCacheHintFlush";
  if (a2)
    v4 = "Flush";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLResourceOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  BOOL v7;
  const char *v8;
  const char *v9;
  const char *v10;

  v2 = "Unknown";
  if ((uint64_t)this > 47)
  {
    v3 = "MTLResourceHazardTrackingModeTracked";
    if (a2)
      v3 = "HazardTrackingModeTracked";
    v8 = "MTLResourceHazardTrackingModeGrouped";
    if (a2)
      v8 = "HazardTrackingModeGrouped";
    if (this != (GPUTools::MTL *)2048)
      v8 = "Unknown";
    if (this != (GPUTools::MTL *)512)
      v3 = v8;
    v9 = "MTLResourceStorageModeMemoryless";
    if (a2)
      v9 = "StorageModeMemoryless";
    v10 = "MTLResourceHazardTrackingModeUntracked";
    if (a2)
      v10 = "HazardTrackingModeUntracked";
    if (this == (GPUTools::MTL *)256)
      v2 = v10;
    if (this == (GPUTools::MTL *)48)
      v2 = v9;
    v7 = (uint64_t)this <= 511;
  }
  else
  {
    v3 = "MTLResourceStorageModeManaged";
    if (a2)
      v3 = "StorageModeManaged";
    v4 = "MTLResourceStorageModePrivate";
    if (a2)
      v4 = "StorageModePrivate";
    if (this != (GPUTools::MTL *)32)
      v4 = "Unknown";
    if (this != (GPUTools::MTL *)16)
      v3 = v4;
    v5 = "MTLResourceCPUCacheModeDefaultCache";
    if (a2)
      v5 = "CPUCacheModeDefaultCache";
    v6 = "MTLResourceCPUCacheModeWriteCombined";
    if (a2)
      v6 = "CPUCacheModeWriteCombined";
    if (this == (GPUTools::MTL *)1)
      v2 = v6;
    if (!this)
      v2 = v5;
    v7 = (uint64_t)this <= 15;
  }
  if (v7)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLResourceUsageAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLResourceUsageSample";
  if (a2)
    v3 = "Sample";
  v4 = "MTLResourceUsageWrite";
  if (a2)
    v4 = "Write";
  v5 = "Read";
  if (!a2)
    v5 = "MTLResourceUsageRead";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this == (GPUTools::MTL *)4)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLRoundingModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLRoundingModeRTNE";
  if (a2)
    v3 = "RTNE";
  v4 = "MTLRoundingModeRTZ";
  if (a2)
    v4 = "RTZ";
  v5 = "Default";
  if (!a2)
    v5 = "MTLRoundingModeDefault";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLSamplerAddressModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLSamplerAddressModeClampToEdge";
      v3 = "ClampToEdge";
      goto LABEL_10;
    case 1uLL:
      v2 = "MTLSamplerAddressModeMirrorClampToEdge";
      v3 = "MirrorClampToEdge";
      goto LABEL_10;
    case 2uLL:
      v2 = "MTLSamplerAddressModeRepeat";
      v3 = "Repeat";
      goto LABEL_10;
    case 3uLL:
      v2 = "MTLSamplerAddressModeMirrorRepeat";
      v3 = "MirrorRepeat";
      goto LABEL_10;
    case 4uLL:
      v2 = "MTLSamplerAddressModeClampToZero";
      v3 = "ClampToZero";
      goto LABEL_10;
    case 5uLL:
      v2 = "MTLSamplerAddressModeClampToBorderColor";
      v3 = "ClampToBorderColor";
      goto LABEL_10;
    case 6uLL:
      v2 = "MTLSamplerAddressModeClampToHalfBorderColor";
      v3 = "ClampToHalfBorderColor";
LABEL_10:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLSamplerBorderColorAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLSamplerBorderColorTransparentBlack";
      v3 = "TransparentBlack";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLSamplerBorderColorOpaqueBlack";
      v3 = "OpaqueBlack";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLSamplerBorderColorOpaqueWhite";
      v3 = "OpaqueWhite";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLSamplerBorderColorSPICustom";
      v3 = "SPICustom";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLSamplerMinMagFilterAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLSamplerMinMagFilterNearest";
  if (a2)
    v3 = "Nearest";
  v4 = "MTLSamplerMinMagFilterLinear";
  if (a2)
    v4 = "Linear";
  v5 = "Cubic";
  if (!a2)
    v5 = "MTLSamplerMinMagFilterCubic";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLSamplerMipFilterAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLSamplerMipFilterNotMipmapped";
  if (a2)
    v3 = "NotMipmapped";
  v4 = "MTLSamplerMipFilterNearest";
  if (a2)
    v4 = "Nearest";
  v5 = "Linear";
  if (!a2)
    v5 = "MTLSamplerMipFilterLinear";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLSamplerReductionModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLSamplerReductionModeWeightedAverage";
  if (a2)
    v3 = "WeightedAverage";
  v4 = "MTLSamplerReductionModeMinimum";
  if (a2)
    v4 = "Minimum";
  v5 = "Maximum";
  if (!a2)
    v5 = "MTLSamplerReductionModeMaximum";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLSamplerReductionModeSupportAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLSamplerReductionModeSupportNone";
  if (a2)
    v3 = "None";
  v4 = "MTLSamplerReductionModeSupportSingleChannel";
  if (a2)
    v4 = "SingleChannel";
  v5 = "AllChannels";
  if (!a2)
    v5 = "MTLSamplerReductionModeSupportAllChannels";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLShaderValidationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLShaderValidationDisabled";
  if (a2)
    v3 = "Disabled";
  v4 = "MTLShaderValidationEnabled";
  if (a2)
    v4 = "Enabled";
  v5 = "Default";
  if (!a2)
    v5 = "MTLShaderValidationDefault";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLSourceLanguageAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLSourceLanguageOpenCL";
  if (a2)
    v3 = "OpenCL";
  v4 = "MTLSourceLanguageMetal";
  if (a2)
    v4 = "Metal";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLSparsePageSizeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLSparsePageSize256";
  if (a2)
    v3 = "256";
  v4 = "MTLSparsePageSize64";
  if (a2)
    v4 = "64";
  v5 = "16";
  if (!a2)
    v5 = "MTLSparsePageSize16";
  if (this == (GPUTools::MTL *)101)
    v2 = v5;
  if (this == (GPUTools::MTL *)102)
    v2 = v4;
  if (this == (GPUTools::MTL *)103)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLSparseTextureMappingModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLSparseTextureMappingModeUnmap";
  if (a2)
    v3 = "Unmap";
  v4 = "MTLSparseTextureMappingModeMap";
  if (a2)
    v4 = "Map";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLSparseTextureRegionAlignmentModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLSparseTextureRegionAlignmentModeOutward";
  if (a2)
    v3 = "Outward";
  v4 = "MTLSparseTextureRegionAlignmentModeInward";
  if (a2)
    v4 = "Inward";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLSparseTexturesTierAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLSparseTexturesTierNone";
      v3 = "None";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLSparseTexturesTier1";
      v3 = "1";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLSparseTexturesTier2";
      v3 = "2";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLSparseTexturesTier3";
      v3 = "3";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLStencilOperationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLStencilOperationKeep";
      v3 = "Keep";
      goto LABEL_11;
    case 1uLL:
      v2 = "MTLStencilOperationZero";
      v3 = "Zero";
      goto LABEL_11;
    case 2uLL:
      v2 = "MTLStencilOperationReplace";
      v3 = "Replace";
      goto LABEL_11;
    case 3uLL:
      v2 = "MTLStencilOperationIncrementClamp";
      v3 = "IncrementClamp";
      goto LABEL_11;
    case 4uLL:
      v2 = "MTLStencilOperationDecrementClamp";
      v3 = "DecrementClamp";
      goto LABEL_11;
    case 5uLL:
      v2 = "MTLStencilOperationInvert";
      v3 = "Invert";
      goto LABEL_11;
    case 6uLL:
      v2 = "MTLStencilOperationIncrementWrap";
      v3 = "IncrementWrap";
      goto LABEL_11;
    case 7uLL:
      v2 = "MTLStencilOperationDecrementWrap";
      v3 = "DecrementWrap";
LABEL_11:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLStepFunctionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLStepFunctionConstant";
      v3 = "Constant";
      goto LABEL_12;
    case 1uLL:
      v2 = "MTLStepFunctionPerVertex";
      v3 = "PerVertex";
      goto LABEL_12;
    case 2uLL:
      v2 = "MTLStepFunctionPerInstance";
      v3 = "PerInstance";
      goto LABEL_12;
    case 3uLL:
      v2 = "MTLStepFunctionPerPatch";
      v3 = "PerPatch";
      goto LABEL_12;
    case 4uLL:
      v2 = "MTLStepFunctionPerPatchControlPoint";
      v3 = "PerPatchControlPoint";
      goto LABEL_12;
    case 5uLL:
      v2 = "MTLStepFunctionThreadPositionInGridX";
      v3 = "ThreadPositionInGridX";
      goto LABEL_12;
    case 6uLL:
      v2 = "MTLStepFunctionThreadPositionInGridY";
      v3 = "ThreadPositionInGridY";
      goto LABEL_12;
    case 7uLL:
      v2 = "MTLStepFunctionThreadPositionInGridXIndexed";
      v3 = "ThreadPositionInGridXIndexed";
      goto LABEL_12;
    case 8uLL:
      v2 = "MTLStepFunctionThreadPositionInGridYIndexed";
      v3 = "ThreadPositionInGridYIndexed";
LABEL_12:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLStitchedLibraryOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLStitchedLibraryOptionNone";
      v5 = "None";
      goto LABEL_6;
    case 1uLL:
      v4 = "MTLStitchedLibraryOptionFailOnBinaryArchiveMiss";
      v5 = "FailOnBinaryArchiveMiss";
      goto LABEL_6;
    case 2uLL:
      v4 = "MTLStitchedLibraryOptionStoreLibraryInMetalScript";
      v5 = "StoreLibraryInMetalScript";
      goto LABEL_6;
    case 4uLL:
      v4 = "MTLStitchedLibraryOptionAllowBadLegacyDAGs";
      v5 = "AllowBadLegacyDAGs";
LABEL_6:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLStorageModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLStorageModeShared";
      v3 = "Shared";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLStorageModeManaged";
      v3 = "Managed";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLStorageModePrivate";
      v3 = "Private";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLStorageModeMemoryless";
      v3 = "Memoryless";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLStoreActionAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLStoreActionDontCare";
      v5 = "DontCare";
      goto LABEL_10;
    case 1uLL:
      v4 = "MTLStoreActionStore";
      v5 = "Store";
      goto LABEL_10;
    case 2uLL:
      v4 = "MTLStoreActionMultisampleResolve";
      v5 = "MultisampleResolve";
      goto LABEL_10;
    case 3uLL:
      v4 = "MTLStoreActionStoreAndMultisampleResolve";
      v5 = "StoreAndMultisampleResolve";
      goto LABEL_10;
    case 4uLL:
      if (!a2)
        return "MTLStoreActionUnknown";
      return result;
    case 5uLL:
      v4 = "MTLStoreActionCustomSampleDepthStore";
      v5 = "CustomSampleDepthStore";
LABEL_10:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLStoreActionOptionsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLStoreActionOptionNone";
  if (a2)
    v3 = "None";
  v4 = "MTLStoreActionOptionCustomSamplePositions";
  if (a2)
    v4 = "CustomSamplePositions";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLTagTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTagTypeNone";
      v3 = "None";
      goto LABEL_12;
    case 1uLL:
      v2 = "MTLTagTypeInstancing";
      v3 = "Instancing";
      goto LABEL_12;
    case 2uLL:
      v2 = "MTLTagTypeTriangleData";
      v3 = "TriangleData";
      goto LABEL_12;
    case 3uLL:
      v2 = "MTLTagTypeWorldSpaceData";
      v3 = "WorldSpaceData";
      goto LABEL_12;
    case 4uLL:
      v2 = "MTLTagTypeInstanceMotion";
      v3 = "InstanceMotion";
      goto LABEL_12;
    case 5uLL:
      v2 = "MTLTagTypePrimitiveMotion";
      v3 = "PrimitiveMotion";
      goto LABEL_12;
    case 6uLL:
      v2 = "MTLTagTypeExtendedLimits";
      v3 = "ExtendedLimits";
      goto LABEL_12;
    case 7uLL:
      v2 = "MTLTagTypeCurveData";
      v3 = "CurveData";
      goto LABEL_12;
    case 8uLL:
      v2 = "MTLTagTypeMaxLevels";
      v3 = "MaxLevels";
LABEL_12:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTessellationControlPointIndexTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLTessellationControlPointIndexTypeUInt32";
  if (a2)
    v3 = "UInt32";
  v4 = "MTLTessellationControlPointIndexTypeUInt16";
  if (a2)
    v4 = "UInt16";
  v5 = "None";
  if (!a2)
    v5 = "MTLTessellationControlPointIndexTypeNone";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLTessellationFactorFormatAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLTessellationFactorFormatHalf";
  if (a2)
    v3 = "Half";
  v4 = "MTLTessellationFactorFormatFloat_SPI";
  if (a2)
    v4 = "Float_SPI";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLTessellationFactorStepFunctionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTessellationFactorStepFunctionConstant";
      v3 = "Constant";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLTessellationFactorStepFunctionPerPatch";
      v3 = "PerPatch";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLTessellationFactorStepFunctionPerInstance";
      v3 = "PerInstance";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLTessellationFactorStepFunctionPerPatchAndPerInstance";
      v3 = "PerPatchAndPerInstance";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTessellationPartitionModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTessellationPartitionModePow2";
      v3 = "Pow2";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLTessellationPartitionModeInteger";
      v3 = "Integer";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLTessellationPartitionModeFractionalOdd";
      v3 = "FractionalOdd";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLTessellationPartitionModeFractionalEven";
      v3 = "FractionalEven";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureColorSpaceConversionMatrixAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixDefault";
      v3 = "Default";
      goto LABEL_14;
    case 1uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixUtil1";
      v3 = "Util1";
      goto LABEL_14;
    case 2uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixUtil2";
      v3 = "Util2";
      goto LABEL_14;
    case 3uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixUtil3";
      v3 = "Util3";
      goto LABEL_14;
    case 4uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixUtil4";
      v3 = "Util4";
      goto LABEL_14;
    case 5uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixBT601Video";
      v3 = "BT601Video";
      goto LABEL_14;
    case 6uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixBT601Full";
      v3 = "BT601Full";
      goto LABEL_14;
    case 7uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixBT709Video";
      v3 = "BT709Video";
      goto LABEL_14;
    case 8uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixBT709Full";
      v3 = "BT709Full";
      goto LABEL_14;
    case 9uLL:
      v2 = "MTLTextureColorSpaceConversionMatrixBT2020Video";
      v3 = "BT2020Video";
      goto LABEL_14;
    case 0xAuLL:
      v2 = "MTLTextureColorSpaceConversionMatrixBT2020Full";
      v3 = "BT2020Full";
LABEL_14:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureCompressionFeedbackAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;

  result = "Unknown";
  if ((uint64_t)this <= 31)
  {
    switch((unint64_t)this)
    {
      case 0uLL:
        if (!a2)
          return "MTLTextureCompressionFeedbackUnknown";
        return result;
      case 1uLL:
        v12 = "MTLTextureCompressionFeedbackSupported";
        v13 = "Supported";
        goto LABEL_48;
      case 2uLL:
        v12 = "MTLTextureCompressionFeedbackUnsupported";
        v13 = "Unsupported";
        goto LABEL_48;
      case 3uLL:
      case 5uLL:
      case 6uLL:
      case 7uLL:
        return result;
      case 4uLL:
        v12 = "MTLTextureCompressionFeedbackUnsupportedDevice";
        v13 = "UnsupportedDevice";
        goto LABEL_48;
      case 8uLL:
        v12 = "MTLTextureCompressionFeedbackUnsupportedPixelFormat";
        v13 = "UnsupportedPixelFormat";
LABEL_48:
        if (a2)
          result = v13;
        else
          result = v12;
        break;
      default:
        v11 = "MTLTextureCompressionFeedbackUnsupportedTextureUsageShaderWrite";
        if (a2)
          v11 = "UnsupportedTextureUsageShaderWrite";
        if (this == (GPUTools::MTL *)16)
          result = v11;
        break;
    }
  }
  else if ((uint64_t)this <= 255)
  {
    v8 = "MTLTextureCompressionFeedbackUnsupportedTextureUsagePixelFormatView";
    if (a2)
      v8 = "UnsupportedTextureUsagePixelFormatView";
    v9 = "MTLTextureCompressionFeedbackUnsupportedTextureType";
    if (a2)
      v9 = "UnsupportedTextureType";
    v10 = "MTLTextureCompressionFeedbackUnsupportedHeapTypeSparse";
    if (a2)
      v10 = "UnsupportedHeapTypeSparse";
    if (this != (GPUTools::MTL *)128)
      v10 = "Unknown";
    if (this != (GPUTools::MTL *)64)
      v9 = v10;
    if (this == (GPUTools::MTL *)32)
      return v8;
    else
      return v9;
  }
  else
  {
    v4 = "MTLTextureCompressionFeedbackUnsupportedSmallTexture";
    if (a2)
      v4 = "UnsupportedSmallTexture";
    v5 = "MTLTextureCompressionFeedbackUnsupportedTextureUsageShaderAtomic";
    if (a2)
      v5 = "UnsupportedTextureUsageShaderAtomic";
    if (this != (GPUTools::MTL *)2048)
      v5 = "Unknown";
    if (this != (GPUTools::MTL *)1024)
      v4 = v5;
    v6 = "MTLTextureCompressionFeedbackUnsupportedLinearLayout";
    if (a2)
      v6 = "UnsupportedLinearLayout";
    v7 = "MTLTextureCompressionFeedbackUnsupportedOptOut";
    if (a2)
      v7 = "UnsupportedOptOut";
    if (this != (GPUTools::MTL *)512)
      v7 = "Unknown";
    if (this != (GPUTools::MTL *)256)
      v6 = v7;
    if ((uint64_t)this <= 1023)
      return v6;
    else
      return v4;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureCompressionFootprintAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTextureCompressionFootprintLossless";
      v3 = "Lossless";
      goto LABEL_7;
    case 1uLL:
      v2 = "MTLTextureCompressionFootprintLevel1";
      v3 = "Level1";
      goto LABEL_7;
    case 2uLL:
      v2 = "MTLTextureCompressionFootprintLevel2";
      v3 = "Level2";
      goto LABEL_7;
    case 3uLL:
      v2 = "MTLTextureCompressionFootprintLevel3";
      v3 = "Level3";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureCompressionModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLTextureCompressionModeOptOut";
  if (a2)
    v3 = "OptOut";
  v4 = "MTLTextureCompressionModeOptIn";
  if (a2)
    v4 = "OptIn";
  v5 = "Default";
  if (!a2)
    v5 = "MTLTextureCompressionModeDefault";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLTextureCompressionTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLTextureCompressionTypeLossy";
  if (a2)
    v3 = "Lossy";
  v4 = "MTLTextureCompressionTypeLossless";
  if (a2)
    v4 = "Lossless";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLTextureRotationAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTextureRotation0Degrees";
      v3 = "0Degrees";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLTextureRotation90DegreesClockwise";
      v3 = "90DegreesClockwise";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLTextureRotation180DegreesClockwise";
      v3 = "180DegreesClockwise";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLTextureRotation270DegreesClockwise";
      v3 = "270DegreesClockwise";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLTextureRotationTranspose";
      v3 = "Transpose";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureSwizzleAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTextureSwizzleZero";
      v3 = "Zero";
      goto LABEL_9;
    case 1uLL:
      v2 = "MTLTextureSwizzleOne";
      v3 = "One";
      goto LABEL_9;
    case 2uLL:
      v2 = "MTLTextureSwizzleRed";
      v3 = "Red";
      goto LABEL_9;
    case 3uLL:
      v2 = "MTLTextureSwizzleGreen";
      v3 = "Green";
      goto LABEL_9;
    case 4uLL:
      v2 = "MTLTextureSwizzleBlue";
      v3 = "Blue";
      goto LABEL_9;
    case 5uLL:
      v2 = "MTLTextureSwizzleAlpha";
      v3 = "Alpha";
LABEL_9:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureSwizzleShiftAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch(__ROR8__(this, 3))
  {
    case 0:
      v2 = "MTLTextureSwizzleShiftRed";
      v3 = "Red";
      goto LABEL_7;
    case 1:
      v2 = "MTLTextureSwizzleShiftGreen";
      v3 = "Green";
      goto LABEL_7;
    case 2:
      v2 = "MTLTextureSwizzleShiftBlue";
      v3 = "Blue";
      goto LABEL_7;
    case 3:
      v2 = "MTLTextureSwizzleShiftAlpha";
      v3 = "Alpha";
LABEL_7:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLTextureType1D";
      v3 = "1D";
      goto LABEL_13;
    case 1uLL:
      v2 = "MTLTextureType1DArray";
      v3 = "1DArray";
      goto LABEL_13;
    case 2uLL:
      v2 = "MTLTextureType2D";
      v3 = "2D";
      goto LABEL_13;
    case 3uLL:
      v2 = "MTLTextureType2DArray";
      v3 = "2DArray";
      goto LABEL_13;
    case 4uLL:
      v2 = "MTLTextureType2DMultisample";
      v3 = "2DMultisample";
      goto LABEL_13;
    case 5uLL:
      v2 = "MTLTextureTypeCube";
      v3 = "Cube";
      goto LABEL_13;
    case 6uLL:
      v2 = "MTLTextureTypeCubeArray";
      v3 = "CubeArray";
      goto LABEL_13;
    case 7uLL:
      v2 = "MTLTextureType3D";
      v3 = "3D";
      goto LABEL_13;
    case 8uLL:
      v2 = "MTLTextureType2DMultisampleArray";
      v3 = "2DMultisampleArray";
      goto LABEL_13;
    case 9uLL:
      v2 = "MTLTextureTypeTextureBuffer";
      v3 = "TextureBuffer";
LABEL_13:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLTextureUsageAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;

  result = "Unknown";
  if ((uint64_t)this > 31)
  {
    v4 = "MTLTextureUsageVideo";
    if (a2)
      v4 = "Video";
    v5 = "MTLTextureUsageBlockWritesOnly";
    if (a2)
      v5 = "BlockWritesOnly";
    if (this != (GPUTools::MTL *)0x10000)
      v5 = "Unknown";
    if (this != (GPUTools::MTL *)0x8000)
      v4 = v5;
    v6 = "MTLTextureUsageShaderAtomic";
    if (a2)
      v6 = "ShaderAtomic";
    v7 = "MTLTextureUsageNoConcurrentAccess";
    if (a2)
      v7 = "NoConcurrentAccess";
    if (this != (GPUTools::MTL *)0x4000)
      v7 = "Unknown";
    if (this != (GPUTools::MTL *)32)
      v6 = v7;
    if ((uint64_t)this < 0x8000)
      return v6;
    else
      return v4;
  }
  else
  {
    switch((unint64_t)this)
    {
      case 0uLL:
        if (!a2)
          return "MTLTextureUsageUnknown";
        return result;
      case 1uLL:
        v9 = "MTLTextureUsageShaderRead";
        v10 = "ShaderRead";
        goto LABEL_33;
      case 2uLL:
        v9 = "MTLTextureUsageShaderWrite";
        v10 = "ShaderWrite";
        goto LABEL_33;
      case 3uLL:
        return result;
      case 4uLL:
        v9 = "MTLTextureUsageRenderTarget";
        v10 = "RenderTarget";
LABEL_33:
        if (a2)
          result = v10;
        else
          result = v9;
        break;
      default:
        v8 = "MTLTextureUsagePixelFormatView";
        if (a2)
          v8 = "PixelFormatView";
        if (this == (GPUTools::MTL *)16)
          result = v8;
        break;
    }
  }
  return result;
}

const char *GPUTools::MTL::GetMTLThreadgroupDistributionModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLThreadgroupDistributionModeSingleClusterGroup";
  if (a2)
    v3 = "SingleClusterGroup";
  v4 = "MTLThreadgroupDistributionModeSingleCluster";
  if (a2)
    v4 = "SingleCluster";
  v5 = "Default";
  if (!a2)
    v5 = "MTLThreadgroupDistributionModeDefault";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLTransformFeedbackStateAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLTransformFeedbackInactive";
  if (a2)
    v3 = "Inactive";
  v4 = "MTLTransformFeedbackActive";
  if (a2)
    v4 = "Active";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLTransformTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLTransformTypePackedFloat4x3";
  if (a2)
    v3 = "PackedFloat4x3";
  v4 = "MTLTransformTypeComponent";
  if (a2)
    v4 = "Component";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLTriangleFillModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLTriangleFillModePoint";
  if (a2)
    v3 = "Point";
  v4 = "MTLTriangleFillModeLines";
  if (a2)
    v4 = "Lines";
  v5 = "Fill";
  if (!a2)
    v5 = "MTLTriangleFillModeFill";
  if (!this)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this == (GPUTools::MTL *)2)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLUnmappedDepthValueAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLUnmappedDepthValueZero";
  if (a2)
    v3 = "Zero";
  v4 = "MTLUnmappedDepthValueOne";
  if (a2)
    v4 = "One";
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLVREyeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLVREyeRight";
  if (a2)
    v3 = "Right";
  v4 = "MTLVREyeLeft";
  if (a2)
    v4 = "Left";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLVRSubmitFlagsAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLVRSubmitLensDistortionApplied";
  if (a2)
    v3 = "LensDistortionApplied";
  v4 = "MTLVRSubmitDefault";
  if (a2)
    v4 = "Default";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLValidationCodeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLValidationCodeTextureDescriptor";
      v3 = "TextureDescriptor";
      goto LABEL_42;
    case 1uLL:
      v2 = "MTLValidationCodeComputePipelineDescriptor";
      v3 = "ComputePipelineDescriptor";
      goto LABEL_42;
    case 2uLL:
      v2 = "MTLValidationCodeHeapDescriptor";
      v3 = "HeapDescriptor";
      goto LABEL_42;
    case 3uLL:
      v2 = "MTLValidationCodeRenderPipelineDescriptor";
      v3 = "RenderPipelineDescriptor";
      goto LABEL_42;
    case 4uLL:
      v2 = "MTLValidationCodeVertexDescriptor";
      v3 = "VertexDescriptor";
      goto LABEL_42;
    case 5uLL:
      v2 = "MTLValidationCodeNewSerializedDescriptor";
      v3 = "NewSerializedDescriptor";
      goto LABEL_42;
    case 6uLL:
      v2 = "MTLValidationCodeSamplerDescriptor";
      v3 = "SamplerDescriptor";
      goto LABEL_42;
    case 7uLL:
      v2 = "MTLValidationCodeArgumentEncoder";
      v3 = "ArgumentEncoder";
      goto LABEL_42;
    case 8uLL:
      v2 = "MTLValidationCodeFramebuffer";
      v3 = "Framebuffer";
      goto LABEL_42;
    case 9uLL:
      v2 = "MTLValidationCodeTileRenderPipelineDescriptor";
      v3 = "TileRenderPipelineDescriptor";
      goto LABEL_42;
    case 0xAuLL:
      v2 = "MTLValidationCodeDepthStencilState";
      v3 = "DepthStencilState";
      goto LABEL_42;
    case 0xBuLL:
      v2 = "MTLValidationCodeRenderPassDescriptor";
      v3 = "RenderPassDescriptor";
      goto LABEL_42;
    case 0xCuLL:
      v2 = "MTLValidationCodeNewSamplerState";
      v3 = "NewSamplerState";
      goto LABEL_42;
    case 0xDuLL:
      v2 = "MTLValidationCodeCommandQueue";
      v3 = "CommandQueue";
      goto LABEL_42;
    case 0xEuLL:
      v2 = "MTLValidationCodeCommandEncoder";
      v3 = "CommandEncoder";
      goto LABEL_42;
    case 0xFuLL:
      v2 = "MTLValidationCodeViewport";
      v3 = "Viewport";
      goto LABEL_42;
    case 0x10uLL:
      v2 = "MTLValidationCodeIndirectCommandBuffer";
      v3 = "IndirectCommandBuffer";
      goto LABEL_42;
    case 0x11uLL:
      v2 = "MTLValidationCodeBuffer";
      v3 = "Buffer";
      goto LABEL_42;
    case 0x12uLL:
      v2 = "MTLValidationCodeResource";
      v3 = "Resource";
      goto LABEL_42;
    case 0x13uLL:
      v2 = "MTLValidationCodePipelineState";
      v3 = "PipelineState";
      goto LABEL_42;
    case 0x14uLL:
      v2 = "MTLValidationCodeDraw";
      v3 = "Draw";
      goto LABEL_42;
    case 0x15uLL:
      v2 = "MTLValidationCodeBlitCommandEncoder";
      v3 = "BlitCommandEncoder";
      goto LABEL_42;
    case 0x16uLL:
      v2 = "MTLValidationCodeTexture";
      v3 = "Texture";
      goto LABEL_42;
    case 0x17uLL:
      v2 = "MTLValidationCodeBinaryArchive";
      v3 = "BinaryArchive";
      goto LABEL_42;
    case 0x18uLL:
      v2 = "MTLValidationCodeLibrary";
      v3 = "Library";
      goto LABEL_42;
    case 0x19uLL:
      v2 = "MTLValidationCodePixelFormat";
      v3 = "PixelFormat";
      goto LABEL_42;
    case 0x1AuLL:
      v2 = "MTLValidationCodeRasterizationRateMap";
      v3 = "RasterizationRateMap";
      goto LABEL_42;
    case 0x1BuLL:
      v2 = "MTLValidationCodeMotionEstimation";
      v3 = "MotionEstimation";
      goto LABEL_42;
    case 0x1CuLL:
      v2 = "MTLValidationCodeRenderCommandEncoder";
      v3 = "RenderCommandEncoder";
      goto LABEL_42;
    case 0x1DuLL:
      v2 = "MTLValidationCodeAcelerationStructureCommandEncoder";
      v3 = "AcelerationStructureCommandEncoder";
      goto LABEL_42;
    case 0x1EuLL:
      v2 = "MTLValidationCodeEvent";
      v3 = "Event";
      goto LABEL_42;
    case 0x1FuLL:
      v2 = "MTLValidationCodeMeshPipelineDescriptor";
      v3 = "MeshPipelineDescriptor";
      goto LABEL_42;
    case 0x20uLL:
      v2 = "MTLValidationCodeIOHandle";
      v3 = "IOHandle";
      goto LABEL_42;
    case 0x21uLL:
      v2 = "MTLValidationCodeIOCommandQueue";
      v3 = "IOCommandQueue";
      goto LABEL_42;
    case 0x22uLL:
      v2 = "MTLValidationCodeIOCommandBuffer";
      v3 = "IOCommandBuffer";
      goto LABEL_42;
    case 0x23uLL:
      v2 = "MTLValidationCodeResourceStateCommandEncoder";
      v3 = "ResourceStateCommandEncoder";
      goto LABEL_42;
    case 0x24uLL:
      v2 = "MTLValidationCodeResourceStateCommandEncoderMoveMappings";
      v3 = "ResourceStateCommandEncoderMoveMappings";
      goto LABEL_42;
    case 0x25uLL:
      v2 = "MTLValidationCodeSamplerArgumentBufferEncoding";
      v3 = "SamplerArgumentBufferEncoding";
      goto LABEL_42;
    case 0x26uLL:
      v2 = "MTLValidationCodeCount";
      v3 = "Count";
LABEL_42:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLVertexAmplificationModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLVertexAmplificationModeMask";
  if (a2)
    v3 = "Mask";
  v4 = "MTLVertexAmplificationModeCount";
  if (a2)
    v4 = "Count";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLVertexFormatAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0uLL:
      v4 = "MTLVertexFormatInvalid";
      v5 = "Invalid";
      goto LABEL_56;
    case 1uLL:
      v4 = "MTLVertexFormatUChar2";
      v5 = "UChar2";
      goto LABEL_56;
    case 2uLL:
      v4 = "MTLVertexFormatUChar3";
      v5 = "UChar3";
      goto LABEL_56;
    case 3uLL:
      v4 = "MTLVertexFormatUChar4";
      v5 = "UChar4";
      goto LABEL_56;
    case 4uLL:
      v4 = "MTLVertexFormatChar2";
      v5 = "Char2";
      goto LABEL_56;
    case 5uLL:
      v4 = "MTLVertexFormatChar3";
      v5 = "Char3";
      goto LABEL_56;
    case 6uLL:
      v4 = "MTLVertexFormatChar4";
      v5 = "Char4";
      goto LABEL_56;
    case 7uLL:
      v4 = "MTLVertexFormatUChar2Normalized";
      v5 = "UChar2Normalized";
      goto LABEL_56;
    case 8uLL:
      v4 = "MTLVertexFormatUChar3Normalized";
      v5 = "UChar3Normalized";
      goto LABEL_56;
    case 9uLL:
      v4 = "MTLVertexFormatUChar4Normalized";
      v5 = "UChar4Normalized";
      goto LABEL_56;
    case 0xAuLL:
      v4 = "MTLVertexFormatChar2Normalized";
      v5 = "Char2Normalized";
      goto LABEL_56;
    case 0xBuLL:
      v4 = "MTLVertexFormatChar3Normalized";
      v5 = "Char3Normalized";
      goto LABEL_56;
    case 0xCuLL:
      v4 = "MTLVertexFormatChar4Normalized";
      v5 = "Char4Normalized";
      goto LABEL_56;
    case 0xDuLL:
      v4 = "MTLVertexFormatUShort2";
      v5 = "UShort2";
      goto LABEL_56;
    case 0xEuLL:
      v4 = "MTLVertexFormatUShort3";
      v5 = "UShort3";
      goto LABEL_56;
    case 0xFuLL:
      v4 = "MTLVertexFormatUShort4";
      v5 = "UShort4";
      goto LABEL_56;
    case 0x10uLL:
      v4 = "MTLVertexFormatShort2";
      v5 = "Short2";
      goto LABEL_56;
    case 0x11uLL:
      v4 = "MTLVertexFormatShort3";
      v5 = "Short3";
      goto LABEL_56;
    case 0x12uLL:
      v4 = "MTLVertexFormatShort4";
      v5 = "Short4";
      goto LABEL_56;
    case 0x13uLL:
      v4 = "MTLVertexFormatUShort2Normalized";
      v5 = "UShort2Normalized";
      goto LABEL_56;
    case 0x14uLL:
      v4 = "MTLVertexFormatUShort3Normalized";
      v5 = "UShort3Normalized";
      goto LABEL_56;
    case 0x15uLL:
      v4 = "MTLVertexFormatUShort4Normalized";
      v5 = "UShort4Normalized";
      goto LABEL_56;
    case 0x16uLL:
      v4 = "MTLVertexFormatShort2Normalized";
      v5 = "Short2Normalized";
      goto LABEL_56;
    case 0x17uLL:
      v4 = "MTLVertexFormatShort3Normalized";
      v5 = "Short3Normalized";
      goto LABEL_56;
    case 0x18uLL:
      v4 = "MTLVertexFormatShort4Normalized";
      v5 = "Short4Normalized";
      goto LABEL_56;
    case 0x19uLL:
      v4 = "MTLVertexFormatHalf2";
      v5 = "Half2";
      goto LABEL_56;
    case 0x1AuLL:
      v4 = "MTLVertexFormatHalf3";
      v5 = "Half3";
      goto LABEL_56;
    case 0x1BuLL:
      v4 = "MTLVertexFormatHalf4";
      v5 = "Half4";
      goto LABEL_56;
    case 0x1CuLL:
      v4 = "MTLVertexFormatFloat";
      v5 = "Float";
      goto LABEL_56;
    case 0x1DuLL:
      v4 = "MTLVertexFormatFloat2";
      v5 = "Float2";
      goto LABEL_56;
    case 0x1EuLL:
      v4 = "MTLVertexFormatFloat3";
      v5 = "Float3";
      goto LABEL_56;
    case 0x1FuLL:
      v4 = "MTLVertexFormatFloat4";
      v5 = "Float4";
      goto LABEL_56;
    case 0x20uLL:
      v4 = "MTLVertexFormatInt";
      v5 = "Int";
      goto LABEL_56;
    case 0x21uLL:
      v4 = "MTLVertexFormatInt2";
      v5 = "Int2";
      goto LABEL_56;
    case 0x22uLL:
      v4 = "MTLVertexFormatInt3";
      v5 = "Int3";
      goto LABEL_56;
    case 0x23uLL:
      v4 = "MTLVertexFormatInt4";
      v5 = "Int4";
      goto LABEL_56;
    case 0x24uLL:
      v4 = "MTLVertexFormatUInt";
      v5 = "UInt";
      goto LABEL_56;
    case 0x25uLL:
      v4 = "MTLVertexFormatUInt2";
      v5 = "UInt2";
      goto LABEL_56;
    case 0x26uLL:
      v4 = "MTLVertexFormatUInt3";
      v5 = "UInt3";
      goto LABEL_56;
    case 0x27uLL:
      v4 = "MTLVertexFormatUInt4";
      v5 = "UInt4";
      goto LABEL_56;
    case 0x28uLL:
      v4 = "MTLVertexFormatInt1010102Normalized";
      v5 = "Int1010102Normalized";
      goto LABEL_56;
    case 0x29uLL:
      v4 = "MTLVertexFormatUInt1010102Normalized";
      v5 = "UInt1010102Normalized";
      goto LABEL_56;
    case 0x2AuLL:
      v4 = "MTLVertexFormatUChar4Normalized_BGRA";
      v5 = "UChar4Normalized_BGRA";
      goto LABEL_56;
    case 0x2DuLL:
      v4 = "MTLVertexFormatUChar";
      v5 = "UChar";
      goto LABEL_56;
    case 0x2EuLL:
      v4 = "MTLVertexFormatChar";
      v5 = "Char";
      goto LABEL_56;
    case 0x2FuLL:
      v4 = "MTLVertexFormatUCharNormalized";
      v5 = "UCharNormalized";
      goto LABEL_56;
    case 0x30uLL:
      v4 = "MTLVertexFormatCharNormalized";
      v5 = "CharNormalized";
      goto LABEL_56;
    case 0x31uLL:
      v4 = "MTLVertexFormatUShort";
      v5 = "UShort";
      goto LABEL_56;
    case 0x32uLL:
      v4 = "MTLVertexFormatShort";
      v5 = "Short";
      goto LABEL_56;
    case 0x33uLL:
      v4 = "MTLVertexFormatUShortNormalized";
      v5 = "UShortNormalized";
      goto LABEL_56;
    case 0x34uLL:
      v4 = "MTLVertexFormatShortNormalized";
      v5 = "ShortNormalized";
      goto LABEL_56;
    case 0x35uLL:
      v4 = "MTLVertexFormatHalf";
      v5 = "Half";
      goto LABEL_56;
    case 0x36uLL:
      v4 = "MTLVertexFormatFloatRG11B10";
      v5 = "FloatRG11B10";
      goto LABEL_56;
    case 0x37uLL:
      v4 = "MTLVertexFormatFloatRGB9E5";
      v5 = "FloatRGB9E5";
LABEL_56:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLVertexStepFunctionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "MTLVertexStepFunctionConstant";
      v3 = "Constant";
      goto LABEL_8;
    case 1uLL:
      v2 = "MTLVertexStepFunctionPerVertex";
      v3 = "PerVertex";
      goto LABEL_8;
    case 2uLL:
      v2 = "MTLVertexStepFunctionPerInstance";
      v3 = "PerInstance";
      goto LABEL_8;
    case 3uLL:
      v2 = "MTLVertexStepFunctionPerPatch";
      v3 = "PerPatch";
      goto LABEL_8;
    case 4uLL:
      v2 = "MTLVertexStepFunctionPerPatchControlPoint";
      v3 = "PerPatchControlPoint";
LABEL_8:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLVisibilityResultModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLVisibilityResultModeDisabled";
  if (a2)
    v3 = "Disabled";
  v4 = "MTLVisibilityResultModeCounting";
  if (a2)
    v4 = "Counting";
  v5 = "Boolean";
  if (!a2)
    v5 = "MTLVisibilityResultModeBoolean";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLWindingAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLWindingCounterClockwise";
  if (a2)
    v3 = "CounterClockwise";
  v4 = "MTLWindingClockwise";
  if (a2)
    v4 = "Clockwise";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::Get_MTLArgumentBufferPatchingTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "_MTLArgumentBufferPatchingTypeNone";
  if (a2)
    v3 = "None";
  v4 = "_MTLArgumentBufferPatchingTypeReplace";
  if (a2)
    v4 = "Replace";
  v5 = "Indexed";
  if (!a2)
    v5 = "_MTLArgumentBufferPatchingTypeIndexed";
  if (this == (GPUTools::MTL *)1)
    v2 = v5;
  if (this == (GPUTools::MTL *)2)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::Get_MTLArgumentBufferResourceTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *result;

  switch((unint64_t)this)
  {
    case 0uLL:
      v2 = "_MTLArgumentBufferResourceTypeTexture";
      v3 = "Texture";
      goto LABEL_13;
    case 1uLL:
      v2 = "_MTLArgumentBufferResourceTypeSampler";
      v3 = "Sampler";
      goto LABEL_13;
    case 2uLL:
      v2 = "_MTLArgumentBufferResourceTypeConstant";
      v3 = "Constant";
      goto LABEL_13;
    case 3uLL:
      v2 = "_MTLArgumentBufferResourceTypeBuffer";
      v3 = "Buffer";
      goto LABEL_13;
    case 4uLL:
      v2 = "_MTLArgumentBufferResourceTypePipelineState";
      v3 = "PipelineState";
      goto LABEL_13;
    case 5uLL:
      v2 = "_MTLArgumentBufferResourceTypeIndirectCommandBuffer";
      v3 = "IndirectCommandBuffer";
      goto LABEL_13;
    case 6uLL:
      v2 = "_MTLArgumentBufferResourceTypeVisibleFunctionTable";
      v3 = "VisibleFunctionTable";
      goto LABEL_13;
    case 7uLL:
      v2 = "_MTLArgumentBufferResourceTypeIntersectionFunctionTable";
      v3 = "IntersectionFunctionTable";
      goto LABEL_13;
    case 8uLL:
      v2 = "_MTLArgumentBufferResourceTypeAccelerationStructure";
      v3 = "AccelerationStructure";
      goto LABEL_13;
    case 9uLL:
      v2 = "_MTLArgumentBufferResourceTypeCount";
      v3 = "Count";
LABEL_13:
      if (a2)
        result = v3;
      else
        result = v2;
      break;
    default:
      result = "Unknown";
      break;
  }
  return result;
}

const char *GPUTools::MTL::Get_MTLMachOTypeAsString(GPUTools::MTL *this, int a2)
{
  const char *result;
  const char *v4;
  const char *v5;

  result = "Unknown";
  switch((unint64_t)this)
  {
    case 0x1000013uLL:
      v4 = "_MTLMachOTypeAppleGPU";
      v5 = "AppleGPU";
      goto LABEL_6;
    case 0x1000014uLL:
      v4 = "_MTLMachOTypeAMDGPU";
      v5 = "AMDGPU";
      goto LABEL_6;
    case 0x1000015uLL:
      v4 = "_MTLMachOTypeIntelGPU";
      v5 = "IntelGPU";
      goto LABEL_6;
    case 0x1000017uLL:
      v4 = "_MTLMachOTypeAIR";
      v5 = "AIR";
LABEL_6:
      if (a2)
        result = v5;
      else
        result = v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *GPUTools::MTL::GetMTLFXSpatialScalerColorProcessingModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = "Unknown";
  v3 = "MTLFXSpatialScalerColorProcessingModePerceptual";
  if (a2)
    v3 = "Perceptual";
  v4 = "MTLFXSpatialScalerColorProcessingModeLinear";
  if (a2)
    v4 = "Linear";
  v5 = "HDR";
  if (!a2)
    v5 = "MTLFXSpatialScalerColorProcessingModeHDR";
  if (this == (GPUTools::MTL *)2)
    v2 = v5;
  if (this == (GPUTools::MTL *)1)
    v2 = v4;
  if (this)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLFXSpatialScalerVersionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;

  v2 = "Unknown";
  v3 = "MTLFXSpatialScalerVersionPrivate_Bicubic";
  if (a2)
    v3 = "Private_Bicubic";
  v4 = "MTLFXSpatialScalerVersionPrivate_v1";
  if (a2)
    v4 = "Private_v1";
  v5 = "MTLFXSpatialScalerVersionPrivate_ASE";
  if (a2)
    v5 = "Private_ASE";
  if (this != (GPUTools::MTL *)65538)
    v5 = "Unknown";
  if (this != (GPUTools::MTL *)65537)
    v4 = v5;
  if (this != (GPUTools::MTL *)0x10000)
    v3 = v4;
  v6 = "MTLFXSpatialScalerVersion_v1";
  if (a2)
    v6 = "_v1";
  v7 = "MTLFXSpatialScalerVersion_End";
  if (a2)
    v7 = "_End";
  if (this == (GPUTools::MTL *)1)
    v2 = v7;
  if (!this)
    v2 = v6;
  if ((uint64_t)this < 0x10000)
    return v2;
  else
    return v3;
}

const char *GPUTools::MTL::GetMTLFXTemporalScalerExecutionModeAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "Unknown";
  v3 = "MTLFXTemporalScalerExecutionModeGPU";
  if (a2)
    v3 = "GPU";
  v4 = "MTLFXTemporalScalerExecutionModeANE";
  if (a2)
    v4 = "ANE";
  if (!this)
    v2 = v4;
  if (this == (GPUTools::MTL *)1)
    return v3;
  else
    return v2;
}

const char *GPUTools::MTL::GetMTLFXTemporalScalerVersionAsString(GPUTools::MTL *this, int a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;

  v2 = "Unknown";
  v3 = "MTLFXTemporalScalerVersionPrivate_TAAU";
  if (a2)
    v3 = "Private_TAAU";
  v4 = "MTLFXTemporalScalerVersionPrivate_BRNet3";
  if (a2)
    v4 = "Private_BRNet3";
  if (this != (GPUTools::MTL *)0x10000)
    v4 = "Unknown";
  if (this != (GPUTools::MTL *)65537)
    v3 = v4;
  v5 = "MTLFXTemporalScalerVersion_v1";
  if (a2)
    v5 = "_v1";
  v6 = "MTLFXTemporalScalerVersion_End";
  if (a2)
    v6 = "_End";
  if (this == (GPUTools::MTL *)1)
    v2 = v6;
  if (!this)
    v2 = v5;
  if ((uint64_t)this < 0x10000)
    return v2;
  else
    return v3;
}

void GPUTools::MTL::InstallMTLFuncEnumsStringTable(GPUTools::MTL *this)
{
  if (GPUTools::MTL::InstallMTLFuncEnumsStringTable(void)::sOnce != -1)
    dispatch_once(&GPUTools::MTL::InstallMTLFuncEnumsStringTable(void)::sOnce, &__block_literal_global_2);
}

uint64_t ___ZN8GPUTools3MTL30InstallMTLFuncEnumsStringTableEv_block_invoke()
{
  dy_add_fenum_string_tables();
  dy_add_fenum_string_tables();
  dy_add_fenum_string_tables();
  dy_add_fenum_string_tables();
  dy_add_fenum_string_tables();
  dy_add_fenum_string_tables();
  dy_add_fenum_string_tables();
  return dy_add_fenum_string_tables();
}

uint64_t GPUTools::MTL::GetFuncEnumReceiverType(GPUTools::MTL *this)
{
  uint64_t result;
  int v2;

  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)xmmword_24114EC70, (uint32x4_t)vaddq_s32(vdupq_n_s32(this), (int32x4_t)xmmword_24114EC60)))) & 1) == 0&& ((_DWORD)this + 6656) >= 5&& ((_DWORD)this + 6144) >= 0x32&& (this & 0xFFFFFFFE) != 0xFFFFCF00&& (this & 0xFFFFFFF0) != 0xFFFFE400)
  {
    return 0;
  }
  if ((int)this > -12545)
  {
    if ((int)this > -7169)
    {
      switch(this)
      {
        case 0xFFFFE800:
        case 0xFFFFE80C:
        case 0xFFFFE80E:
        case 0xFFFFE827:
        case 0xFFFFE82B:
          result = 10;
          break;
        case 0xFFFFE801:
        case 0xFFFFE803:
        case 0xFFFFE80A:
        case 0xFFFFE80B:
        case 0xFFFFE80D:
        case 0xFFFFE80F:
        case 0xFFFFE816:
        case 0xFFFFE819:
        case 0xFFFFE81C:
        case 0xFFFFE821:
        case 0xFFFFE822:
        case 0xFFFFE823:
        case 0xFFFFE830:
        case 0xFFFFE831:
LABEL_10:
          result = 36;
          break;
        case 0xFFFFE802:
        case 0xFFFFE812:
        case 0xFFFFE817:
          result = 7;
          break;
        case 0xFFFFE804:
        case 0xFFFFE807:
          result = 11;
          break;
        case 0xFFFFE805:
          result = 15;
          break;
        case 0xFFFFE806:
        case 0xFFFFE809:
        case 0xFFFFE81B:
        case 0xFFFFE81D:
          result = 8;
          break;
        case 0xFFFFE808:
        case 0xFFFFE818:
        case 0xFFFFE820:
        case 0xFFFFE824:
        case 0xFFFFE826:
          result = 5;
          break;
        case 0xFFFFE810:
        case 0xFFFFE814:
        case 0xFFFFE828:
        case 0xFFFFE829:
          result = 9;
          break;
        case 0xFFFFE811:
        case 0xFFFFE81E:
        case 0xFFFFE81F:
        case 0xFFFFE825:
          result = 6;
          break;
        case 0xFFFFE813:
        case 0xFFFFE815:
        case 0xFFFFE81A:
          result = 4;
          break;
        case 0xFFFFE82A:
        case 0xFFFFE82C:
          result = 14;
          break;
        case 0xFFFFE82D:
        case 0xFFFFE82E:
          result = 13;
          break;
        case 0xFFFFE82F:
          result = 12;
          break;
        default:
          switch(this)
          {
            case 0xFFFFE400:
            case 0xFFFFE402:
            case 0xFFFFE403:
            case 0xFFFFE404:
            case 0xFFFFE405:
            case 0xFFFFE406:
            case 0xFFFFE408:
            case 0xFFFFE409:
            case 0xFFFFE40E:
            case 0xFFFFE40F:
              result = 3;
              break;
            case 0xFFFFE401:
            case 0xFFFFE407:
            case 0xFFFFE40A:
            case 0xFFFFE40B:
            case 0xFFFFE40C:
              result = 2;
              break;
            case 0xFFFFE40D:
              result = 85;
              break;
            default:
              switch(this)
              {
                case 0xFFFFE600:
                case 0xFFFFE601:
                case 0xFFFFE602:
                case 0xFFFFE603:
                case 0xFFFFE604:
                  result = 84;
                  break;
                default:
                  return 0;
              }
              break;
          }
          break;
      }
    }
    else
    {
      v2 = (_DWORD)this + 10240;
      result = 1;
      switch(v2)
      {
        case 0:
        case 11:
        case 15:
LABEL_18:
          result = 25;
          break;
        case 1:
        case 3:
        case 7:
        case 10:
          goto LABEL_10;
        case 2:
        case 4:
        case 6:
        case 8:
        case 9:
        case 13:
        case 18:
        case 28:
        case 35:
        case 36:
        case 39:
        case 42:
        case 55:
        case 76:
LABEL_14:
          result = 80;
          break;
        case 5:
        case 12:
        case 17:
        case 19:
        case 30:
        case 37:
        case 40:
        case 53:
        case 54:
LABEL_24:
          result = 22;
          break;
        case 14:
        case 77:
LABEL_56:
          result = 75;
          break;
        case 20:
        case 41:
        case 48:
        case 56:
        case 68:
        case 75:
LABEL_21:
          result = 71;
          break;
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 31:
        case 38:
        case 74:
LABEL_31:
          result = 57;
          break;
        case 26:
        case 49:
        case 69:
        case 78:
LABEL_40:
          result = 29;
          break;
        case 27:
LABEL_42:
          result = 74;
          break;
        case 29:
        case 32:
        case 33:
LABEL_36:
          result = 50;
          break;
        case 34:
          result = 77;
          break;
        case 43:
        case 44:
        case 45:
        case 46:
        case 50:
        case 58:
        case 59:
        case 67:
        case 70:
        case 71:
        case 73:
        case 81:
        case 84:
LABEL_30:
          result = 16;
          break;
        case 47:
        case 62:
        case 63:
        case 66:
        case 80:
        case 87:
LABEL_32:
          result = 83;
          break;
        case 51:
LABEL_55:
          result = 37;
          break;
        case 52:
        case 57:
LABEL_37:
          result = 62;
          break;
        case 60:
        case 61:
        case 64:
        case 65:
        case 79:
        case 88:
LABEL_25:
          result = 60;
          break;
        case 72:
          return result;
        case 82:
        case 85:
        case 86:
LABEL_20:
          result = 17;
          break;
        case 83:
LABEL_43:
          result = 43;
          break;
        case 89:
LABEL_46:
          result = 23;
          break;
        default:
          return 0;
      }
    }
  }
  else if ((int)this <= -18431)
  {
    switch(this)
    {
      case 0xFFFFB000:
      case 0xFFFFB001:
      case 0xFFFFB002:
      case 0xFFFFB003:
      case 0xFFFFB004:
      case 0xFFFFB005:
      case 0xFFFFB006:
        result = 39;
        break;
      case 0xFFFFB007:
      case 0xFFFFB008:
      case 0xFFFFB009:
      case 0xFFFFB00A:
      case 0xFFFFB00B:
      case 0xFFFFB00C:
      case 0xFFFFB00D:
      case 0xFFFFB00E:
      case 0xFFFFB00F:
      case 0xFFFFB010:
      case 0xFFFFB011:
      case 0xFFFFB012:
      case 0xFFFFB013:
      case 0xFFFFB014:
      case 0xFFFFB015:
      case 0xFFFFB016:
      case 0xFFFFB017:
      case 0xFFFFB018:
LABEL_29:
        result = 40;
        break;
      default:
        if ((_DWORD)this != -18432 && (_DWORD)this != -18431)
          return 0;
        goto LABEL_10;
    }
  }
  else
  {
    switch(this)
    {
      case 0xFFFFC000:
      case 0xFFFFC001:
      case 0xFFFFC002:
      case 0xFFFFC003:
      case 0xFFFFC004:
      case 0xFFFFC005:
      case 0xFFFFC006:
      case 0xFFFFC007:
      case 0xFFFFC008:
      case 0xFFFFC009:
      case 0xFFFFC00A:
      case 0xFFFFC00B:
      case 0xFFFFC09A:
      case 0xFFFFC09B:
      case 0xFFFFC0AB:
      case 0xFFFFC0AC:
      case 0xFFFFC0AD:
      case 0xFFFFC0AE:
      case 0xFFFFC0AF:
      case 0xFFFFC0FD:
      case 0xFFFFC104:
      case 0xFFFFC185:
      case 0xFFFFC186:
      case 0xFFFFC187:
      case 0xFFFFC188:
      case 0xFFFFC197:
      case 0xFFFFC198:
      case 0xFFFFC1A8:
      case 0xFFFFC1A9:
      case 0xFFFFC1AA:
      case 0xFFFFC1FA:
      case 0xFFFFC1FB:
      case 0xFFFFC1FC:
      case 0xFFFFC1FD:
      case 0xFFFFC246:
      case 0xFFFFC248:
      case 0xFFFFC24A:
      case 0xFFFFC274:
      case 0xFFFFC275:
      case 0xFFFFC38E:
      case 0xFFFFC38F:
      case 0xFFFFC390:
      case 0xFFFFC391:
      case 0xFFFFC392:
      case 0xFFFFC393:
        result = 21;
        break;
      case 0xFFFFC00C:
      case 0xFFFFC00D:
      case 0xFFFFC00E:
      case 0xFFFFC00F:
      case 0xFFFFC010:
      case 0xFFFFC011:
      case 0xFFFFC012:
      case 0xFFFFC09C:
      case 0xFFFFC0B0:
      case 0xFFFFC106:
      case 0xFFFFC10F:
      case 0xFFFFC118:
      case 0xFFFFC119:
      case 0xFFFFC11A:
      case 0xFFFFC11E:
      case 0xFFFFC1D6:
      case 0xFFFFC1E0:
      case 0xFFFFC1FE:
      case 0xFFFFC268:
      case 0xFFFFC269:
      case 0xFFFFC36F:
      case 0xFFFFC370:
      case 0xFFFFC403:
        goto LABEL_24;
      case 0xFFFFC013:
      case 0xFFFFC014:
      case 0xFFFFC015:
      case 0xFFFFC016:
      case 0xFFFFC017:
      case 0xFFFFC018:
      case 0xFFFFC019:
      case 0xFFFFC01A:
      case 0xFFFFC01B:
      case 0xFFFFC01C:
      case 0xFFFFC01D:
      case 0xFFFFC01E:
      case 0xFFFFC01F:
      case 0xFFFFC020:
      case 0xFFFFC021:
      case 0xFFFFC022:
      case 0xFFFFC0B6:
      case 0xFFFFC0BD:
      case 0xFFFFC0DC:
      case 0xFFFFC0E9:
      case 0xFFFFC0FB:
      case 0xFFFFC13F:
      case 0xFFFFC140:
      case 0xFFFFC172:
      case 0xFFFFC173:
      case 0xFFFFC174:
      case 0xFFFFC189:
      case 0xFFFFC18A:
      case 0xFFFFC1A1:
      case 0xFFFFC1A2:
      case 0xFFFFC1DC:
      case 0xFFFFC1E5:
      case 0xFFFFC1E6:
      case 0xFFFFC1E7:
      case 0xFFFFC1FF:
      case 0xFFFFC200:
      case 0xFFFFC201:
      case 0xFFFFC202:
      case 0xFFFFC27B:
      case 0xFFFFC2A0:
      case 0xFFFFC2A9:
      case 0xFFFFC2C7:
      case 0xFFFFC31D:
      case 0xFFFFC31E:
      case 0xFFFFC31F:
      case 0xFFFFC320:
      case 0xFFFFC353:
      case 0xFFFFC373:
      case 0xFFFFC374:
      case 0xFFFFC3CE:
      case 0xFFFFC3FC:
      case 0xFFFFC422:
      case 0xFFFFC42A:
      case 0xFFFFC42C:
      case 0xFFFFC44A:
      case 0xFFFFC44B:
      case 0xFFFFC468:
      case 0xFFFFC469:
      case 0xFFFFC46A:
      case 0xFFFFC46B:
      case 0xFFFFC48F:
      case 0xFFFFC490:
      case 0xFFFFC491:
        goto LABEL_18;
      case 0xFFFFC023:
      case 0xFFFFC024:
      case 0xFFFFC025:
      case 0xFFFFC026:
      case 0xFFFFC027:
      case 0xFFFFC028:
      case 0xFFFFC029:
      case 0xFFFFC02A:
      case 0xFFFFC02B:
      case 0xFFFFC02C:
      case 0xFFFFC0FA:
      case 0xFFFFC23D:
      case 0xFFFFC23E:
      case 0xFFFFC23F:
      case 0xFFFFC240:
      case 0xFFFFC241:
      case 0xFFFFC242:
      case 0xFFFFC243:
      case 0xFFFFC244:
      case 0xFFFFC2AB:
      case 0xFFFFC2F8:
      case 0xFFFFC46C:
      case 0xFFFFC46D:
      case 0xFFFFC46E:
      case 0xFFFFC46F:
        result = 27;
        break;
      case 0xFFFFC02D:
      case 0xFFFFC02E:
      case 0xFFFFC02F:
      case 0xFFFFC030:
      case 0xFFFFC031:
      case 0xFFFFC032:
      case 0xFFFFC033:
      case 0xFFFFC034:
      case 0xFFFFC035:
      case 0xFFFFC036:
      case 0xFFFFC037:
      case 0xFFFFC038:
      case 0xFFFFC039:
      case 0xFFFFC03A:
      case 0xFFFFC03B:
      case 0xFFFFC03C:
      case 0xFFFFC03D:
      case 0xFFFFC03E:
      case 0xFFFFC09D:
      case 0xFFFFC09E:
      case 0xFFFFC0A4:
      case 0xFFFFC0B1:
      case 0xFFFFC0EA:
      case 0xFFFFC0EB:
      case 0xFFFFC0FE:
      case 0xFFFFC0FF:
      case 0xFFFFC11C:
      case 0xFFFFC131:
      case 0xFFFFC132:
      case 0xFFFFC151:
      case 0xFFFFC152:
      case 0xFFFFC153:
      case 0xFFFFC154:
      case 0xFFFFC16F:
      case 0xFFFFC175:
      case 0xFFFFC176:
      case 0xFFFFC177:
      case 0xFFFFC178:
      case 0xFFFFC1A3:
      case 0xFFFFC1A4:
      case 0xFFFFC1A5:
      case 0xFFFFC203:
      case 0xFFFFC276:
      case 0xFFFFC28C:
      case 0xFFFFC2A1:
      case 0xFFFFC2A2:
      case 0xFFFFC2A3:
      case 0xFFFFC2F9:
      case 0xFFFFC2FA:
      case 0xFFFFC2FB:
      case 0xFFFFC321:
      case 0xFFFFC322:
      case 0xFFFFC323:
      case 0xFFFFC324:
      case 0xFFFFC362:
      case 0xFFFFC363:
      case 0xFFFFC364:
      case 0xFFFFC365:
      case 0xFFFFC366:
      case 0xFFFFC367:
      case 0xFFFFC368:
      case 0xFFFFC369:
      case 0xFFFFC36A:
      case 0xFFFFC371:
      case 0xFFFFC44C:
      case 0xFFFFC44D:
      case 0xFFFFC44E:
      case 0xFFFFC44F:
      case 0xFFFFC450:
      case 0xFFFFC451:
      case 0xFFFFC452:
      case 0xFFFFC470:
      case 0xFFFFC471:
        result = 28;
        break;
      case 0xFFFFC03F:
      case 0xFFFFC124:
      case 0xFFFFC18B:
      case 0xFFFFC204:
      case 0xFFFFC2AC:
      case 0xFFFFC2AD:
      case 0xFFFFC2FC:
      case 0xFFFFC2FD:
      case 0xFFFFC2FE:
      case 0xFFFFC325:
      case 0xFFFFC326:
      case 0xFFFFC34B:
      case 0xFFFFC34C:
        goto LABEL_40;
      case 0xFFFFC040:
        result = 34;
        break;
      case 0xFFFFC041:
      case 0xFFFFC042:
      case 0xFFFFC043:
      case 0xFFFFC044:
      case 0xFFFFC045:
      case 0xFFFFC046:
      case 0xFFFFC047:
      case 0xFFFFC048:
      case 0xFFFFC049:
      case 0xFFFFC04A:
      case 0xFFFFC04B:
      case 0xFFFFC04C:
      case 0xFFFFC04D:
      case 0xFFFFC04E:
      case 0xFFFFC04F:
      case 0xFFFFC050:
      case 0xFFFFC051:
      case 0xFFFFC052:
      case 0xFFFFC053:
      case 0xFFFFC054:
      case 0xFFFFC055:
      case 0xFFFFC056:
      case 0xFFFFC057:
      case 0xFFFFC058:
      case 0xFFFFC059:
      case 0xFFFFC05A:
      case 0xFFFFC0B2:
      case 0xFFFFC0B3:
      case 0xFFFFC0B8:
      case 0xFFFFC0B9:
      case 0xFFFFC0BA:
      case 0xFFFFC0BB:
      case 0xFFFFC0DA:
      case 0xFFFFC0DB:
      case 0xFFFFC0DD:
      case 0xFFFFC100:
      case 0xFFFFC107:
      case 0xFFFFC108:
      case 0xFFFFC110:
      case 0xFFFFC111:
      case 0xFFFFC11B:
      case 0xFFFFC11D:
      case 0xFFFFC120:
      case 0xFFFFC121:
      case 0xFFFFC123:
      case 0xFFFFC125:
      case 0xFFFFC126:
      case 0xFFFFC127:
      case 0xFFFFC128:
      case 0xFFFFC135:
      case 0xFFFFC13E:
      case 0xFFFFC14E:
      case 0xFFFFC14F:
      case 0xFFFFC150:
      case 0xFFFFC159:
      case 0xFFFFC15B:
      case 0xFFFFC15C:
      case 0xFFFFC15D:
      case 0xFFFFC161:
      case 0xFFFFC162:
      case 0xFFFFC163:
      case 0xFFFFC16E:
      case 0xFFFFC170:
      case 0xFFFFC171:
      case 0xFFFFC182:
      case 0xFFFFC183:
      case 0xFFFFC184:
      case 0xFFFFC194:
      case 0xFFFFC195:
      case 0xFFFFC196:
      case 0xFFFFC19C:
      case 0xFFFFC19D:
      case 0xFFFFC19F:
      case 0xFFFFC1A0:
      case 0xFFFFC1D8:
      case 0xFFFFC1DB:
      case 0xFFFFC1E2:
      case 0xFFFFC1E3:
      case 0xFFFFC1E4:
      case 0xFFFFC1EC:
      case 0xFFFFC1ED:
      case 0xFFFFC208:
      case 0xFFFFC209:
      case 0xFFFFC20A:
      case 0xFFFFC20B:
      case 0xFFFFC20C:
      case 0xFFFFC20D:
      case 0xFFFFC20E:
      case 0xFFFFC20F:
      case 0xFFFFC210:
      case 0xFFFFC211:
      case 0xFFFFC212:
      case 0xFFFFC213:
      case 0xFFFFC214:
      case 0xFFFFC215:
      case 0xFFFFC216:
      case 0xFFFFC217:
      case 0xFFFFC218:
      case 0xFFFFC219:
      case 0xFFFFC21A:
      case 0xFFFFC21B:
      case 0xFFFFC21C:
      case 0xFFFFC21D:
      case 0xFFFFC21E:
      case 0xFFFFC21F:
      case 0xFFFFC220:
      case 0xFFFFC221:
      case 0xFFFFC222:
      case 0xFFFFC223:
      case 0xFFFFC224:
      case 0xFFFFC225:
      case 0xFFFFC226:
      case 0xFFFFC227:
      case 0xFFFFC228:
      case 0xFFFFC229:
      case 0xFFFFC23A:
      case 0xFFFFC23B:
      case 0xFFFFC24C:
      case 0xFFFFC24F:
      case 0xFFFFC251:
      case 0xFFFFC25C:
      case 0xFFFFC25D:
      case 0xFFFFC262:
      case 0xFFFFC271:
      case 0xFFFFC272:
      case 0xFFFFC273:
      case 0xFFFFC279:
      case 0xFFFFC27D:
      case 0xFFFFC27E:
      case 0xFFFFC287:
      case 0xFFFFC28D:
      case 0xFFFFC28E:
      case 0xFFFFC299:
      case 0xFFFFC29A:
      case 0xFFFFC29B:
      case 0xFFFFC29C:
      case 0xFFFFC2A4:
      case 0xFFFFC2A5:
      case 0xFFFFC2A6:
      case 0xFFFFC2A7:
      case 0xFFFFC2A8:
      case 0xFFFFC2AE:
      case 0xFFFFC2AF:
      case 0xFFFFC2B0:
      case 0xFFFFC2B1:
      case 0xFFFFC2B2:
      case 0xFFFFC2B3:
      case 0xFFFFC2C8:
      case 0xFFFFC2C9:
      case 0xFFFFC2FF:
      case 0xFFFFC300:
      case 0xFFFFC301:
      case 0xFFFFC302:
      case 0xFFFFC303:
      case 0xFFFFC304:
      case 0xFFFFC327:
      case 0xFFFFC328:
      case 0xFFFFC329:
      case 0xFFFFC351:
      case 0xFFFFC354:
      case 0xFFFFC355:
      case 0xFFFFC36B:
      case 0xFFFFC36E:
      case 0xFFFFC375:
      case 0xFFFFC376:
      case 0xFFFFC377:
      case 0xFFFFC378:
      case 0xFFFFC38D:
      case 0xFFFFC394:
      case 0xFFFFC395:
      case 0xFFFFC398:
      case 0xFFFFC3B5:
      case 0xFFFFC3B6:
      case 0xFFFFC3B7:
      case 0xFFFFC3B8:
      case 0xFFFFC3B9:
      case 0xFFFFC3BA:
      case 0xFFFFC3BB:
      case 0xFFFFC3BC:
      case 0xFFFFC3BD:
      case 0xFFFFC3BF:
      case 0xFFFFC3C3:
      case 0xFFFFC3C4:
      case 0xFFFFC3C5:
      case 0xFFFFC3C6:
      case 0xFFFFC3C7:
      case 0xFFFFC3D2:
      case 0xFFFFC3D3:
      case 0xFFFFC3D4:
      case 0xFFFFC3D5:
      case 0xFFFFC3D6:
      case 0xFFFFC3FD:
      case 0xFFFFC3FE:
      case 0xFFFFC3FF:
      case 0xFFFFC400:
      case 0xFFFFC401:
      case 0xFFFFC402:
      case 0xFFFFC40A:
      case 0xFFFFC40B:
      case 0xFFFFC40C:
      case 0xFFFFC40D:
      case 0xFFFFC42B:
      case 0xFFFFC42D:
      case 0xFFFFC42E:
      case 0xFFFFC43E:
      case 0xFFFFC440:
      case 0xFFFFC45A:
      case 0xFFFFC45B:
      case 0xFFFFC45C:
      case 0xFFFFC45D:
      case 0xFFFFC463:
      case 0xFFFFC464:
      case 0xFFFFC465:
      case 0xFFFFC472:
      case 0xFFFFC473:
      case 0xFFFFC492:
        goto LABEL_10;
      case 0xFFFFC05B:
      case 0xFFFFC0F9:
      case 0xFFFFC105:
      case 0xFFFFC14C:
      case 0xFFFFC14D:
      case 0xFFFFC22A:
      case 0xFFFFC29D:
      case 0xFFFFC29E:
      case 0xFFFFC29F:
      case 0xFFFFC2CA:
      case 0xFFFFC2CB:
        goto LABEL_43;
      case 0xFFFFC05C:
      case 0xFFFFC05D:
      case 0xFFFFC05E:
      case 0xFFFFC115:
      case 0xFFFFC116:
      case 0xFFFFC12D:
      case 0xFFFFC12E:
      case 0xFFFFC12F:
      case 0xFFFFC15A:
      case 0xFFFFC264:
      case 0xFFFFC307:
      case 0xFFFFC308:
      case 0xFFFFC341:
      case 0xFFFFC342:
      case 0xFFFFC381:
      case 0xFFFFC3C1:
      case 0xFFFFC425:
      case 0xFFFFC426:
        goto LABEL_37;
      case 0xFFFFC05F:
      case 0xFFFFC060:
      case 0xFFFFC061:
      case 0xFFFFC062:
      case 0xFFFFC063:
      case 0xFFFFC064:
      case 0xFFFFC065:
      case 0xFFFFC066:
      case 0xFFFFC0DE:
      case 0xFFFFC0DF:
      case 0xFFFFC0E0:
      case 0xFFFFC164:
      case 0xFFFFC165:
      case 0xFFFFC166:
        result = 65;
        break;
      case 0xFFFFC067:
      case 0xFFFFC068:
      case 0xFFFFC069:
      case 0xFFFFC06A:
      case 0xFFFFC06B:
      case 0xFFFFC06C:
      case 0xFFFFC06D:
      case 0xFFFFC06E:
      case 0xFFFFC06F:
      case 0xFFFFC070:
      case 0xFFFFC071:
      case 0xFFFFC072:
      case 0xFFFFC073:
      case 0xFFFFC074:
      case 0xFFFFC075:
      case 0xFFFFC076:
      case 0xFFFFC077:
      case 0xFFFFC078:
      case 0xFFFFC079:
      case 0xFFFFC07A:
      case 0xFFFFC07B:
      case 0xFFFFC07C:
      case 0xFFFFC07D:
      case 0xFFFFC07E:
      case 0xFFFFC07F:
      case 0xFFFFC080:
      case 0xFFFFC081:
      case 0xFFFFC082:
      case 0xFFFFC083:
      case 0xFFFFC084:
      case 0xFFFFC085:
      case 0xFFFFC086:
      case 0xFFFFC087:
      case 0xFFFFC088:
      case 0xFFFFC089:
      case 0xFFFFC08A:
      case 0xFFFFC08B:
      case 0xFFFFC08C:
      case 0xFFFFC08D:
      case 0xFFFFC09F:
      case 0xFFFFC0A0:
      case 0xFFFFC0A1:
      case 0xFFFFC0A2:
      case 0xFFFFC0A5:
      case 0xFFFFC0A6:
      case 0xFFFFC0A7:
      case 0xFFFFC0A8:
      case 0xFFFFC0A9:
      case 0xFFFFC0AA:
      case 0xFFFFC0B4:
      case 0xFFFFC0B5:
      case 0xFFFFC0B7:
      case 0xFFFFC0E1:
      case 0xFFFFC0E2:
      case 0xFFFFC0E3:
      case 0xFFFFC0E4:
      case 0xFFFFC0E5:
      case 0xFFFFC0EC:
      case 0xFFFFC0ED:
      case 0xFFFFC0EE:
      case 0xFFFFC0EF:
      case 0xFFFFC0F0:
      case 0xFFFFC0F1:
      case 0xFFFFC0F2:
      case 0xFFFFC0F3:
      case 0xFFFFC0F4:
      case 0xFFFFC0F5:
      case 0xFFFFC0F6:
      case 0xFFFFC0F7:
      case 0xFFFFC0FC:
      case 0xFFFFC102:
      case 0xFFFFC103:
      case 0xFFFFC129:
      case 0xFFFFC12A:
      case 0xFFFFC12B:
      case 0xFFFFC12C:
      case 0xFFFFC130:
      case 0xFFFFC133:
      case 0xFFFFC134:
      case 0xFFFFC136:
      case 0xFFFFC155:
      case 0xFFFFC156:
      case 0xFFFFC157:
      case 0xFFFFC158:
      case 0xFFFFC16A:
      case 0xFFFFC16B:
      case 0xFFFFC16C:
      case 0xFFFFC179:
      case 0xFFFFC17A:
      case 0xFFFFC17B:
      case 0xFFFFC17C:
      case 0xFFFFC17D:
      case 0xFFFFC18C:
      case 0xFFFFC18D:
      case 0xFFFFC18E:
      case 0xFFFFC18F:
      case 0xFFFFC190:
      case 0xFFFFC19E:
      case 0xFFFFC1A6:
      case 0xFFFFC1A7:
      case 0xFFFFC231:
      case 0xFFFFC232:
      case 0xFFFFC233:
      case 0xFFFFC234:
      case 0xFFFFC235:
      case 0xFFFFC236:
      case 0xFFFFC23C:
      case 0xFFFFC27A:
      case 0xFFFFC28F:
      case 0xFFFFC290:
      case 0xFFFFC291:
      case 0xFFFFC292:
      case 0xFFFFC293:
      case 0xFFFFC294:
      case 0xFFFFC295:
      case 0xFFFFC296:
      case 0xFFFFC297:
      case 0xFFFFC298:
      case 0xFFFFC36D:
      case 0xFFFFC382:
      case 0xFFFFC383:
      case 0xFFFFC384:
      case 0xFFFFC385:
      case 0xFFFFC386:
      case 0xFFFFC387:
      case 0xFFFFC388:
      case 0xFFFFC389:
      case 0xFFFFC38A:
      case 0xFFFFC38B:
      case 0xFFFFC38C:
      case 0xFFFFC39D:
      case 0xFFFFC39E:
      case 0xFFFFC39F:
      case 0xFFFFC3A0:
      case 0xFFFFC3A1:
      case 0xFFFFC3A2:
      case 0xFFFFC3A3:
      case 0xFFFFC3A4:
      case 0xFFFFC3A5:
      case 0xFFFFC3A6:
      case 0xFFFFC3A7:
      case 0xFFFFC3A8:
      case 0xFFFFC3A9:
      case 0xFFFFC3AA:
      case 0xFFFFC3AB:
      case 0xFFFFC3C8:
      case 0xFFFFC3C9:
      case 0xFFFFC3CA:
      case 0xFFFFC3D7:
      case 0xFFFFC3D8:
      case 0xFFFFC3D9:
      case 0xFFFFC3DA:
      case 0xFFFFC3DB:
      case 0xFFFFC3DC:
      case 0xFFFFC3DD:
      case 0xFFFFC3DE:
      case 0xFFFFC3DF:
      case 0xFFFFC3E0:
      case 0xFFFFC3E1:
      case 0xFFFFC3E2:
      case 0xFFFFC3E3:
      case 0xFFFFC3E4:
      case 0xFFFFC3E5:
      case 0xFFFFC3E6:
      case 0xFFFFC3E7:
      case 0xFFFFC3E8:
      case 0xFFFFC3E9:
      case 0xFFFFC3EA:
      case 0xFFFFC3EB:
      case 0xFFFFC43F:
      case 0xFFFFC455:
      case 0xFFFFC456:
      case 0xFFFFC457:
      case 0xFFFFC458:
      case 0xFFFFC474:
      case 0xFFFFC475:
        result = 70;
        break;
      case 0xFFFFC08E:
      case 0xFFFFC237:
      case 0xFFFFC399:
      case 0xFFFFC39A:
      case 0xFFFFC39B:
      case 0xFFFFC39C:
      case 0xFFFFC3AC:
      case 0xFFFFC3AD:
      case 0xFFFFC3AE:
      case 0xFFFFC3AF:
      case 0xFFFFC3B0:
      case 0xFFFFC3B1:
      case 0xFFFFC3B2:
      case 0xFFFFC3B3:
      case 0xFFFFC3B4:
      case 0xFFFFC3CB:
      case 0xFFFFC3EC:
      case 0xFFFFC3ED:
      case 0xFFFFC3EE:
      case 0xFFFFC3EF:
      case 0xFFFFC3F0:
      case 0xFFFFC3F1:
      case 0xFFFFC3F2:
      case 0xFFFFC3F3:
      case 0xFFFFC3F4:
      case 0xFFFFC3F5:
      case 0xFFFFC3F6:
      case 0xFFFFC3F7:
      case 0xFFFFC3F8:
      case 0xFFFFC3F9:
      case 0xFFFFC429:
      case 0xFFFFC448:
        goto LABEL_21;
      case 0xFFFFC08F:
      case 0xFFFFC191:
      case 0xFFFFC238:
        goto LABEL_56;
      case 0xFFFFC090:
      case 0xFFFFC091:
      case 0xFFFFC092:
      case 0xFFFFC093:
      case 0xFFFFC094:
      case 0xFFFFC095:
      case 0xFFFFC096:
      case 0xFFFFC097:
      case 0xFFFFC098:
      case 0xFFFFC099:
      case 0xFFFFC0A3:
      case 0xFFFFC0BC:
      case 0xFFFFC10E:
      case 0xFFFFC114:
      case 0xFFFFC122:
      case 0xFFFFC193:
      case 0xFFFFC1D7:
      case 0xFFFFC1DA:
      case 0xFFFFC1E1:
      case 0xFFFFC1EA:
      case 0xFFFFC239:
      case 0xFFFFC261:
      case 0xFFFFC26F:
      case 0xFFFFC270:
      case 0xFFFFC2B6:
      case 0xFFFFC2B7:
      case 0xFFFFC2B8:
      case 0xFFFFC352:
        goto LABEL_14;
      case 0xFFFFC0BE:
      case 0xFFFFC0BF:
      case 0xFFFFC0C0:
      case 0xFFFFC0C1:
      case 0xFFFFC0C2:
      case 0xFFFFC0C3:
      case 0xFFFFC0C4:
      case 0xFFFFC0C5:
      case 0xFFFFC0C6:
      case 0xFFFFC0C7:
      case 0xFFFFC0C8:
      case 0xFFFFC0C9:
      case 0xFFFFC0CA:
      case 0xFFFFC0CB:
      case 0xFFFFC0CC:
      case 0xFFFFC0CD:
      case 0xFFFFC0CE:
      case 0xFFFFC0CF:
      case 0xFFFFC0D0:
      case 0xFFFFC0D1:
      case 0xFFFFC0D2:
      case 0xFFFFC0D3:
      case 0xFFFFC0D4:
      case 0xFFFFC0D5:
      case 0xFFFFC0D6:
      case 0xFFFFC0D7:
      case 0xFFFFC0D8:
      case 0xFFFFC0D9:
      case 0xFFFFC0E6:
      case 0xFFFFC0E7:
      case 0xFFFFC0E8:
      case 0xFFFFC167:
      case 0xFFFFC168:
      case 0xFFFFC169:
        result = 42;
        break;
      case 0xFFFFC0F8:
      case 0xFFFFC101:
        result = 41;
        break;
      case 0xFFFFC109:
      case 0xFFFFC10A:
      case 0xFFFFC10B:
      case 0xFFFFC10C:
      case 0xFFFFC10D:
      case 0xFFFFC112:
      case 0xFFFFC113:
      case 0xFFFFC117:
      case 0xFFFFC22B:
      case 0xFFFFC22C:
      case 0xFFFFC25E:
      case 0xFFFFC25F:
      case 0xFFFFC404:
      case 0xFFFFC405:
      case 0xFFFFC406:
      case 0xFFFFC407:
      case 0xFFFFC408:
      case 0xFFFFC409:
        goto LABEL_36;
      case 0xFFFFC11F:
      case 0xFFFFC160:
        result = 81;
        break;
      case 0xFFFFC137:
      case 0xFFFFC138:
      case 0xFFFFC139:
      case 0xFFFFC13A:
        result = 24;
        break;
      case 0xFFFFC13B:
      case 0xFFFFC13C:
      case 0xFFFFC13D:
      case 0xFFFFC15E:
      case 0xFFFFC16D:
      case 0xFFFFC288:
      case 0xFFFFC289:
      case 0xFFFFC28A:
      case 0xFFFFC28B:
        goto LABEL_46;
      case 0xFFFFC141:
      case 0xFFFFC142:
      case 0xFFFFC143:
      case 0xFFFFC144:
      case 0xFFFFC145:
      case 0xFFFFC146:
      case 0xFFFFC147:
      case 0xFFFFC148:
      case 0xFFFFC149:
      case 0xFFFFC14A:
      case 0xFFFFC14B:
      case 0xFFFFC15F:
      case 0xFFFFC17E:
      case 0xFFFFC17F:
      case 0xFFFFC180:
      case 0xFFFFC181:
      case 0xFFFFC1D4:
      case 0xFFFFC1D5:
      case 0xFFFFC2F5:
      case 0xFFFFC2F6:
      case 0xFFFFC2F7:
      case 0xFFFFC343:
      case 0xFFFFC344:
      case 0xFFFFC345:
      case 0xFFFFC346:
      case 0xFFFFC34D:
      case 0xFFFFC34E:
      case 0xFFFFC34F:
      case 0xFFFFC350:
        result = 18;
        break;
      case 0xFFFFC192:
        result = 78;
        break;
      case 0xFFFFC199:
      case 0xFFFFC19A:
      case 0xFFFFC19B:
      case 0xFFFFC1D9:
      case 0xFFFFC1DD:
      case 0xFFFFC3C2:
      case 0xFFFFC427:
        result = 76;
        break;
      case 0xFFFFC1AB:
      case 0xFFFFC1AC:
      case 0xFFFFC1AD:
      case 0xFFFFC1AE:
      case 0xFFFFC1AF:
      case 0xFFFFC1B0:
      case 0xFFFFC1B1:
      case 0xFFFFC1B2:
      case 0xFFFFC1B3:
      case 0xFFFFC1B4:
      case 0xFFFFC1B5:
      case 0xFFFFC1B6:
      case 0xFFFFC1B7:
      case 0xFFFFC1B8:
      case 0xFFFFC1B9:
      case 0xFFFFC1BA:
      case 0xFFFFC1BB:
      case 0xFFFFC1BC:
      case 0xFFFFC1BD:
      case 0xFFFFC1BE:
      case 0xFFFFC1BF:
      case 0xFFFFC1C0:
      case 0xFFFFC1DE:
      case 0xFFFFC454:
      case 0xFFFFC45E:
      case 0xFFFFC45F:
      case 0xFFFFC460:
      case 0xFFFFC461:
      case 0xFFFFC462:
        result = 59;
        break;
      case 0xFFFFC1C1:
      case 0xFFFFC1C2:
      case 0xFFFFC1C3:
      case 0xFFFFC1C4:
      case 0xFFFFC1C5:
      case 0xFFFFC1C6:
      case 0xFFFFC1C7:
      case 0xFFFFC1C8:
      case 0xFFFFC1C9:
      case 0xFFFFC1CA:
      case 0xFFFFC1DF:
      case 0xFFFFC22D:
      case 0xFFFFC22E:
      case 0xFFFFC22F:
      case 0xFFFFC230:
      case 0xFFFFC263:
      case 0xFFFFC453:
        result = 58;
        break;
      case 0xFFFFC1CB:
      case 0xFFFFC1CC:
      case 0xFFFFC1CD:
      case 0xFFFFC1CE:
      case 0xFFFFC1CF:
      case 0xFFFFC1D0:
      case 0xFFFFC1D1:
      case 0xFFFFC1D2:
      case 0xFFFFC1D3:
      case 0xFFFFC1E8:
      case 0xFFFFC1E9:
      case 0xFFFFC26A:
      case 0xFFFFC26B:
      case 0xFFFFC26C:
      case 0xFFFFC26D:
      case 0xFFFFC26E:
        goto LABEL_31;
      case 0xFFFFC1EB:
        result = 64;
        break;
      case 0xFFFFC1EE:
      case 0xFFFFC1EF:
      case 0xFFFFC1F0:
      case 0xFFFFC1F1:
      case 0xFFFFC1F2:
      case 0xFFFFC1F3:
      case 0xFFFFC1F4:
      case 0xFFFFC1F5:
      case 0xFFFFC1F6:
      case 0xFFFFC1F7:
        result = 82;
        break;
      case 0xFFFFC1F8:
      case 0xFFFFC1F9:
      case 0xFFFFC423:
        result = 38;
        break;
      case 0xFFFFC205:
      case 0xFFFFC277:
        result = 31;
        break;
      case 0xFFFFC206:
      case 0xFFFFC207:
        result = 35;
        break;
      case 0xFFFFC245:
      case 0xFFFFC247:
      case 0xFFFFC249:
      case 0xFFFFC24B:
      case 0xFFFFC24D:
      case 0xFFFFC260:
      case 0xFFFFC265:
      case 0xFFFFC266:
      case 0xFFFFC3CC:
      case 0xFFFFC3CD:
        result = 68;
        break;
      case 0xFFFFC24E:
      case 0xFFFFC250:
      case 0xFFFFC252:
      case 0xFFFFC253:
      case 0xFFFFC254:
      case 0xFFFFC255:
      case 0xFFFFC256:
      case 0xFFFFC257:
      case 0xFFFFC258:
      case 0xFFFFC259:
      case 0xFFFFC25A:
      case 0xFFFFC25B:
      case 0xFFFFC459:
        goto LABEL_42;
      case 0xFFFFC267:
        result = 73;
        break;
      case 0xFFFFC278:
        result = 32;
        break;
      case 0xFFFFC27C:
        result = 30;
        break;
      case 0xFFFFC27F:
        result = 66;
        break;
      case 0xFFFFC280:
      case 0xFFFFC281:
      case 0xFFFFC282:
      case 0xFFFFC283:
      case 0xFFFFC284:
      case 0xFFFFC285:
      case 0xFFFFC286:
        result = 67;
        break;
      case 0xFFFFC2AA:
        result = 26;
        break;
      case 0xFFFFC2B4:
        result = 45;
        break;
      case 0xFFFFC2B5:
        result = 79;
        break;
      case 0xFFFFC2B9:
      case 0xFFFFC2BA:
      case 0xFFFFC2BB:
      case 0xFFFFC2BC:
      case 0xFFFFC2CC:
      case 0xFFFFC2CD:
      case 0xFFFFC2CE:
      case 0xFFFFC2CF:
      case 0xFFFFC2D0:
      case 0xFFFFC2D1:
      case 0xFFFFC2D2:
      case 0xFFFFC33D:
      case 0xFFFFC33E:
      case 0xFFFFC33F:
      case 0xFFFFC3BE:
      case 0xFFFFC3CF:
      case 0xFFFFC3D0:
      case 0xFFFFC3D1:
      case 0xFFFFC421:
        result = 19;
        break;
      case 0xFFFFC2BD:
      case 0xFFFFC2BE:
      case 0xFFFFC2BF:
      case 0xFFFFC2C0:
      case 0xFFFFC2C1:
      case 0xFFFFC2C2:
      case 0xFFFFC2C3:
        result = 20;
        break;
      case 0xFFFFC2C4:
      case 0xFFFFC2C5:
      case 0xFFFFC2C6:
      case 0xFFFFC305:
        goto LABEL_55;
      case 0xFFFFC2D3:
      case 0xFFFFC2D4:
      case 0xFFFFC2D5:
      case 0xFFFFC2D6:
      case 0xFFFFC2D7:
      case 0xFFFFC2D8:
      case 0xFFFFC2D9:
      case 0xFFFFC2DA:
      case 0xFFFFC2DB:
      case 0xFFFFC2DC:
      case 0xFFFFC2DD:
      case 0xFFFFC2DE:
      case 0xFFFFC2DF:
      case 0xFFFFC340:
        goto LABEL_30;
      case 0xFFFFC2E0:
      case 0xFFFFC2E1:
      case 0xFFFFC2E2:
      case 0xFFFFC2E3:
      case 0xFFFFC2E4:
      case 0xFFFFC2E5:
      case 0xFFFFC2E6:
      case 0xFFFFC2E7:
      case 0xFFFFC2E8:
      case 0xFFFFC2E9:
      case 0xFFFFC2EA:
      case 0xFFFFC2EB:
      case 0xFFFFC2EC:
      case 0xFFFFC2ED:
      case 0xFFFFC2EE:
      case 0xFFFFC2EF:
      case 0xFFFFC2F0:
      case 0xFFFFC2F1:
      case 0xFFFFC2F2:
      case 0xFFFFC2F3:
      case 0xFFFFC2F4:
      case 0xFFFFC315:
      case 0xFFFFC316:
      case 0xFFFFC317:
      case 0xFFFFC318:
      case 0xFFFFC319:
      case 0xFFFFC31A:
      case 0xFFFFC31B:
      case 0xFFFFC31C:
      case 0xFFFFC35C:
      case 0xFFFFC35D:
      case 0xFFFFC35E:
      case 0xFFFFC35F:
      case 0xFFFFC360:
      case 0xFFFFC361:
      case 0xFFFFC372:
      case 0xFFFFC396:
      case 0xFFFFC397:
      case 0xFFFFC3FA:
      case 0xFFFFC3FB:
      case 0xFFFFC449:
        goto LABEL_20;
      case 0xFFFFC306:
        result = 44;
        break;
      case 0xFFFFC309:
      case 0xFFFFC30A:
      case 0xFFFFC30B:
      case 0xFFFFC30C:
      case 0xFFFFC30D:
      case 0xFFFFC30E:
      case 0xFFFFC30F:
      case 0xFFFFC310:
      case 0xFFFFC311:
      case 0xFFFFC312:
      case 0xFFFFC313:
      case 0xFFFFC314:
      case 0xFFFFC32A:
      case 0xFFFFC32B:
      case 0xFFFFC349:
      case 0xFFFFC34A:
      case 0xFFFFC358:
      case 0xFFFFC359:
        goto LABEL_32;
      case 0xFFFFC32C:
      case 0xFFFFC32D:
      case 0xFFFFC32E:
      case 0xFFFFC32F:
      case 0xFFFFC330:
      case 0xFFFFC331:
      case 0xFFFFC332:
      case 0xFFFFC333:
      case 0xFFFFC334:
      case 0xFFFFC335:
      case 0xFFFFC336:
      case 0xFFFFC337:
      case 0xFFFFC338:
      case 0xFFFFC339:
      case 0xFFFFC33A:
      case 0xFFFFC33B:
      case 0xFFFFC33C:
      case 0xFFFFC347:
      case 0xFFFFC348:
      case 0xFFFFC356:
      case 0xFFFFC357:
      case 0xFFFFC35A:
      case 0xFFFFC35B:
      case 0xFFFFC466:
      case 0xFFFFC467:
        goto LABEL_25;
      case 0xFFFFC36C:
        result = 69;
        break;
      case 0xFFFFC379:
        result = 46;
        break;
      case 0xFFFFC37A:
        result = 47;
        break;
      case 0xFFFFC37B:
        result = 48;
        break;
      case 0xFFFFC37C:
        result = 49;
        break;
      case 0xFFFFC37D:
      case 0xFFFFC37E:
      case 0xFFFFC37F:
      case 0xFFFFC380:
      case 0xFFFFC3C0:
      case 0xFFFFC424:
        result = 61;
        break;
      case 0xFFFFC40E:
      case 0xFFFFC40F:
      case 0xFFFFC410:
      case 0xFFFFC411:
      case 0xFFFFC412:
      case 0xFFFFC413:
      case 0xFFFFC414:
      case 0xFFFFC415:
      case 0xFFFFC416:
      case 0xFFFFC417:
      case 0xFFFFC418:
      case 0xFFFFC419:
      case 0xFFFFC42F:
      case 0xFFFFC430:
      case 0xFFFFC431:
      case 0xFFFFC432:
      case 0xFFFFC433:
      case 0xFFFFC434:
      case 0xFFFFC441:
      case 0xFFFFC442:
      case 0xFFFFC443:
      case 0xFFFFC444:
        result = 51;
        break;
      case 0xFFFFC41A:
      case 0xFFFFC41B:
      case 0xFFFFC41C:
      case 0xFFFFC435:
      case 0xFFFFC436:
      case 0xFFFFC445:
        result = 52;
        break;
      case 0xFFFFC41D:
        result = 55;
        break;
      case 0xFFFFC41E:
      case 0xFFFFC41F:
      case 0xFFFFC43D:
        result = 56;
        break;
      case 0xFFFFC420:
      case 0xFFFFC437:
      case 0xFFFFC438:
      case 0xFFFFC439:
      case 0xFFFFC43A:
      case 0xFFFFC43B:
      case 0xFFFFC43C:
        result = 54;
        break;
      case 0xFFFFC428:
        result = 33;
        break;
      case 0xFFFFC446:
      case 0xFFFFC447:
        result = 53;
        break;
      case 0xFFFFC476:
      case 0xFFFFC477:
      case 0xFFFFC478:
      case 0xFFFFC479:
      case 0xFFFFC47A:
      case 0xFFFFC47B:
      case 0xFFFFC47C:
      case 0xFFFFC47D:
      case 0xFFFFC47E:
      case 0xFFFFC47F:
      case 0xFFFFC480:
      case 0xFFFFC481:
      case 0xFFFFC482:
      case 0xFFFFC483:
      case 0xFFFFC484:
      case 0xFFFFC485:
      case 0xFFFFC486:
      case 0xFFFFC487:
      case 0xFFFFC488:
      case 0xFFFFC489:
      case 0xFFFFC48A:
      case 0xFFFFC48B:
      case 0xFFFFC48C:
      case 0xFFFFC48D:
      case 0xFFFFC48E:
      case 0xFFFFC494:
      case 0xFFFFC495:
      case 0xFFFFC496:
      case 0xFFFFC497:
      case 0xFFFFC498:
      case 0xFFFFC499:
      case 0xFFFFC49A:
        result = 72;
        break;
      case 0xFFFFC493:
        result = 63;
        break;
      default:
        if ((_DWORD)this != -18430)
          return 0;
        goto LABEL_29;
    }
  }
  return result;
}

char *GPUTools::MTL::GetReceiverTypeString(GPUTools::MTL *this)
{
  return GPUTools::MTL::GetReceiverTypeString::receiverTypeStringList[this];
}

char *GPUTools::MTL::GetFuncEnumReceiverTypeString(GPUTools::MTL *this)
{
  return GPUTools::MTL::GetReceiverTypeString::receiverTypeStringList[GPUTools::MTL::GetFuncEnumReceiverType(this)];
}

BOOL GPUTools::MTL::GetConstructorForReceiverType(int a1, _QWORD *a2)
{
  unsigned int v4;
  unsigned int v6;
  unsigned int v7;

  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::clear(a2);
  if ((a1 - 1) > 0x54)
    return 0;
  switch(a1)
  {
    case 2:
      v7 = -7166;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -6655;
      goto LABEL_67;
    case 5:
      v7 = -6143;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -6131;
      goto LABEL_67;
    case 6:
      v4 = -6111;
      goto LABEL_67;
    case 7:
      v4 = -6109;
      goto LABEL_67;
    case 8:
      v7 = -6116;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -6129;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -6133;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -6141;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -6119;
      goto LABEL_67;
    case 9:
      v4 = -6110;
      goto LABEL_67;
    case 10:
      v4 = -6122;
      goto LABEL_67;
    case 11:
      v4 = -6134;
      goto LABEL_67;
    case 12:
      v4 = -6095;
      goto LABEL_67;
    case 14:
      v4 = -6096;
      goto LABEL_67;
    case 16:
      v7 = -15464;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15359;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15615;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15614;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15506;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15358;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15356;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15355;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15354;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15353;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15352;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15351;
      goto LABEL_67;
    case 17:
      v7 = -15673;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15364;
      goto LABEL_67;
    case 18:
      v7 = -16053;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16037;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16050;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15261;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16048;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16052;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15715;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16051;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15670;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15714;
      goto LABEL_67;
    case 19:
      v4 = -15717;
      goto LABEL_67;
    case 20:
      v4 = -15697;
      goto LABEL_67;
    case 21:
      v7 = -16354;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15587;
      goto LABEL_67;
    case 22:
      v7 = -15914;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -10237;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15850;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16312;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15706;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16313;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15851;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15707;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15509;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16163;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16314;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15849;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15705;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15972;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16117;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15829;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15778;
      goto LABEL_67;
    case 24:
      v7 = -15733;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15734;
      goto LABEL_67;
    case 25:
      v7 = -16343;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15701;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16342;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -12544;
      goto LABEL_67;
    case 27:
      v7 = -16316;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16165;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -16315;
      goto LABEL_67;
    case 28:
      v7 = -16352;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15586;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16014;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15712;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15584;
      goto LABEL_67;
    case 29:
      v7 = -15579;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15541;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15618;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16198;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16200;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16197;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16199;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16297;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16299;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16296;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16298;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16101;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15740;
      goto LABEL_67;
    case 31:
      v4 = -15848;
      goto LABEL_67;
    case 33:
      v4 = -15317;
      goto LABEL_67;
    case 34:
      v4 = -16311;
      goto LABEL_67;
    case 37:
      v7 = -15498;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15497;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15694;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15613;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15531;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15696;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15695;
      goto LABEL_67;
    case 38:
      v7 = -15997;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15269;
      goto LABEL_67;
    case 39:
      v4 = -18432;
      goto LABEL_67;
    case 40:
      v4 = -18431;
      goto LABEL_67;
    case 41:
      v4 = -16128;
      goto LABEL_67;
    case 43:
      v7 = -15430;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15429;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15428;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15427;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15731;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15730;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15830;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16038;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15609;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15608;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16290;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16106;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16107;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15772;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16081;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16082;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15550;
      goto LABEL_67;
    case 44:
      v7 = -15620;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15444;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15463;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15437;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15436;
      goto LABEL_67;
    case 50:
      v4 = -16120;
      goto LABEL_67;
    case 51:
      v7 = -15333;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15306;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -12543;
      goto LABEL_67;
    case 52:
      v4 = -15350;
      goto LABEL_67;
    case 53:
      v7 = -15260;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15259;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v6 = -15296;
      goto LABEL_41;
    case 54:
      v7 = -15296;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v6 = -15349;
LABEL_41:
      v7 = v6;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15348;
      goto LABEL_67;
    case 55:
      v4 = -15299;
      goto LABEL_67;
    case 57:
      v7 = -15969;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15972;
      goto LABEL_67;
    case 58:
      v7 = -16015;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15921;
      goto LABEL_67;
    case 59:
      v7 = -16016;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15922;
      goto LABEL_67;
    case 60:
      v7 = -15540;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15577;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15443;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15462;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15442;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15441;
      goto LABEL_67;
    case 61:
      v4 = -15496;
      goto LABEL_67;
    case 62:
      v7 = -16308;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16095;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16018;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16029;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15693;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16306;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15434;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15425;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15435;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16307;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15467;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15468;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15847;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16304;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16305;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15419;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15421;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15420;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -16039;
      goto LABEL_67;
    case 63:
      v4 = -15214;
      goto LABEL_67;
    case 64:
      v4 = -15891;
      goto LABEL_67;
    case 65:
      v4 = -16351;
      goto LABEL_67;
    case 67:
      v4 = -16075;
      goto LABEL_67;
    case 68:
      v7 = -15793;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15846;
      goto LABEL_67;
    case 70:
      v7 = -16353;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -16286;
      goto LABEL_67;
    case 71:
      v7 = -16301;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16303;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16300;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16302;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15406;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15405;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15404;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15403;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16089;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16091;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16088;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16090;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15738;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15461;
      goto LABEL_67;
    case 72:
      v4 = -15245;
      goto LABEL_67;
    case 73:
      v4 = -15900;
      goto LABEL_67;
    case 74:
      v7 = -15870;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15585;
      goto LABEL_67;
    case 75:
      v4 = -16309;
      goto LABEL_67;
    case 76:
      v7 = -15996;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15909;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15912;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15268;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15488;
      goto LABEL_67;
    case 77:
      v7 = -15488;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15907;
      goto LABEL_67;
    case 78:
      v4 = -15910;
      goto LABEL_67;
    case 80:
      v7 = -16098;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16368;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16104;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15980;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15979;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16099;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16096;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16310;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16294;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16030;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16031;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -16116;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15828;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15777;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15913;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15690;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15689;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15688;
      goto LABEL_67;
    case 81:
      v4 = -16099;
      goto LABEL_67;
    case 82:
      v4 = -16013;
      goto LABEL_67;
    case 83:
      v7 = -15578;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15612;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15440;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15369;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15368;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15439;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v7 = -15438;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      v4 = -15460;
LABEL_67:
      v7 = v4;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)a2, &v7, &v7);
      break;
    default:
      return a2[3] != 0;
  }
  return a2[3] != 0;
}

uint64_t GPUTools::MTL::GetResourcesBoundByFunction(int *a1, unint64_t **a2)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t *v50;
  unint64_t *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t *v66;
  unint64_t *v67;
  unint64_t *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  unint64_t *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t *v84;
  unint64_t *v85;
  unint64_t *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  unint64_t *v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t *v101;
  unint64_t *v102;
  unint64_t *v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  char *v108;
  unint64_t *v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t *v118;
  unint64_t *v119;
  unint64_t *v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  char *v125;
  unint64_t *v126;
  unint64_t v127;
  int v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t *v136;
  unint64_t *v137;
  unint64_t *v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  unint64_t v142;
  char *v143;
  unint64_t *v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t *v153;
  unint64_t *v154;
  unint64_t *v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  char *v160;
  unint64_t *v161;
  unint64_t v162;
  uint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  uint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t *v172;
  unint64_t *v173;
  unint64_t *v174;
  uint64_t v175;
  unint64_t v176;
  uint64_t v177;
  unint64_t v178;
  char *v179;
  unint64_t *v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  uint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t *v189;
  unint64_t *v190;
  unint64_t *v191;
  uint64_t v192;
  unint64_t v193;
  uint64_t v194;
  unint64_t v195;
  char *v196;
  unint64_t *v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t *v206;
  unint64_t *v207;
  unint64_t *v208;
  uint64_t v209;
  unint64_t v210;
  uint64_t v211;
  unint64_t v212;
  char *v213;
  unint64_t *v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  uint64_t v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t *v223;
  unint64_t *v224;
  unint64_t *v225;
  uint64_t v226;
  unint64_t v227;
  uint64_t v228;
  unint64_t v229;
  char *v230;
  unint64_t *v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unint64_t v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t *v240;
  unint64_t *v241;
  unint64_t *v242;
  uint64_t v243;
  unint64_t v244;
  uint64_t v245;
  unint64_t v246;
  char *v247;
  unint64_t *v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  uint64_t v253;
  unint64_t v254;
  unint64_t v255;
  unint64_t v256;
  unint64_t *v257;
  unint64_t *v258;
  unint64_t *v259;
  uint64_t v260;
  unint64_t v261;
  uint64_t v262;
  unint64_t v263;
  char *v264;
  unint64_t *v265;
  unint64_t v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t *v274;
  unint64_t *v275;
  unint64_t *v276;
  uint64_t v277;
  unint64_t v278;
  uint64_t v279;
  unint64_t v280;
  char *v281;
  unint64_t *v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  uint64_t v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t *v291;
  unint64_t *v292;
  unint64_t *v293;
  uint64_t v294;
  unint64_t v295;
  uint64_t v296;
  unint64_t v297;
  char *v298;
  unint64_t *v299;
  unint64_t v300;
  unint64_t v301;
  unint64_t v302;
  unint64_t v303;
  uint64_t v304;
  unint64_t v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t *v308;
  unint64_t *v309;
  unint64_t *v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t v313;
  unint64_t v314;
  char *v315;
  unint64_t *v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  uint64_t v321;
  unint64_t v322;
  unint64_t v323;
  unint64_t v324;
  unint64_t *v325;
  unint64_t *v326;
  unint64_t *v327;
  uint64_t v328;
  unint64_t v329;
  uint64_t v330;
  unint64_t v331;
  char *v332;
  unint64_t *v333;
  unint64_t v334;
  unint64_t v335;
  unint64_t v336;
  unint64_t v337;
  uint64_t v338;
  unint64_t v339;
  unint64_t v340;
  unint64_t v341;
  unint64_t *v342;
  unint64_t *v343;
  unint64_t *v344;
  uint64_t v345;
  unint64_t v346;
  uint64_t v347;
  unint64_t v348;
  char *v349;
  unint64_t *v350;
  unint64_t v351;
  unint64_t v352;
  unint64_t v353;
  unint64_t v354;
  uint64_t v355;
  unint64_t v356;
  unint64_t v357;
  unint64_t v358;
  unint64_t *v359;
  unint64_t *v360;
  unint64_t *v361;
  uint64_t v362;
  unint64_t v363;
  uint64_t v364;
  unint64_t v365;
  char *v366;
  unint64_t *v367;
  unint64_t v368;
  unint64_t v369;
  unint64_t v370;
  unint64_t v371;
  uint64_t v372;
  unint64_t v373;
  unint64_t v374;
  unint64_t v375;
  unint64_t *v376;
  unint64_t *v377;
  unint64_t *v378;
  uint64_t v379;
  unint64_t v380;
  uint64_t v381;
  unint64_t v382;
  char *v383;
  unint64_t *v384;
  unint64_t v385;
  unint64_t v386;

  v4 = 0;
  v5 = *a1;
  if (*a1 <= -16048)
  {
    if (v5 <= -16221)
    {
      if (v5 > -16279)
      {
        switch(v5)
        {
          case -16278:
          case -16276:
          case -16263:
          case -16261:
            goto LABEL_232;
          case -16277:
            v4 = 1;
            v59 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 1uLL);
            if (!v59)
              return v4;
            v60 = v59;
            v61 = 0;
            v62 = (uint64_t)(a1 + 18);
            do
            {
              v63 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v62, v61);
              v64 = v63;
              v66 = a2[1];
              v65 = (unint64_t)a2[2];
              if ((unint64_t)v66 >= v65)
              {
                v68 = *a2;
                v69 = v66 - *a2;
                v70 = v69 + 1;
                if ((unint64_t)(v69 + 1) >> 61)
                  goto LABEL_509;
                v71 = v65 - (_QWORD)v68;
                if (v71 >> 2 > v70)
                  v70 = v71 >> 2;
                if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8)
                  v72 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v72 = v70;
                if (v72)
                {
                  v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v72);
                  v68 = *a2;
                  v66 = a2[1];
                }
                else
                {
                  v73 = 0;
                }
                v74 = (unint64_t *)&v73[8 * v69];
                *v74 = v64;
                v67 = v74 + 1;
                while (v66 != v68)
                {
                  v75 = *--v66;
                  *--v74 = v75;
                }
                *a2 = v74;
                a2[1] = v67;
                a2[2] = (unint64_t *)&v73[8 * v72];
                if (v68)
                  operator delete(v68);
              }
              else
              {
                *v66 = v63;
                v67 = v66 + 1;
              }
              a2[1] = v67;
              ++v61;
              v4 = 1;
            }
            while (v61 != v60);
            return v4;
          case -16275:
            v4 = 1;
            v165 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 1uLL);
            if (!v165)
              return v4;
            v166 = v165;
            v167 = 0;
            v168 = (uint64_t)(a1 + 18);
            do
            {
              v169 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v168, v167);
              v170 = v169;
              v172 = a2[1];
              v171 = (unint64_t)a2[2];
              if ((unint64_t)v172 >= v171)
              {
                v174 = *a2;
                v175 = v172 - *a2;
                v176 = v175 + 1;
                if ((unint64_t)(v175 + 1) >> 61)
                  goto LABEL_509;
                v177 = v171 - (_QWORD)v174;
                if (v177 >> 2 > v176)
                  v176 = v177 >> 2;
                if ((unint64_t)v177 >= 0x7FFFFFFFFFFFFFF8)
                  v178 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v178 = v176;
                if (v178)
                {
                  v179 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v178);
                  v174 = *a2;
                  v172 = a2[1];
                }
                else
                {
                  v179 = 0;
                }
                v180 = (unint64_t *)&v179[8 * v175];
                *v180 = v170;
                v173 = v180 + 1;
                while (v172 != v174)
                {
                  v181 = *--v172;
                  *--v180 = v181;
                }
                *a2 = v180;
                a2[1] = v173;
                a2[2] = (unint64_t *)&v179[8 * v178];
                if (v174)
                  operator delete(v174);
              }
              else
              {
                *v172 = v169;
                v173 = v172 + 1;
              }
              a2[1] = v173;
              ++v167;
              v4 = 1;
            }
            while (v167 != v166);
            return v4;
          case -16274:
          case -16273:
          case -16272:
          case -16271:
          case -16270:
          case -16269:
          case -16268:
          case -16267:
          case -16266:
          case -16265:
          case -16264:
            return v4;
          case -16262:
            v4 = 1;
            v182 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 1uLL);
            if (!v182)
              return v4;
            v183 = v182;
            v184 = 0;
            v185 = (uint64_t)(a1 + 18);
            do
            {
              v186 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v185, v184);
              v187 = v186;
              v189 = a2[1];
              v188 = (unint64_t)a2[2];
              if ((unint64_t)v189 >= v188)
              {
                v191 = *a2;
                v192 = v189 - *a2;
                v193 = v192 + 1;
                if ((unint64_t)(v192 + 1) >> 61)
                  goto LABEL_509;
                v194 = v188 - (_QWORD)v191;
                if (v194 >> 2 > v193)
                  v193 = v194 >> 2;
                if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFF8)
                  v195 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v195 = v193;
                if (v195)
                {
                  v196 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v195);
                  v191 = *a2;
                  v189 = a2[1];
                }
                else
                {
                  v196 = 0;
                }
                v197 = (unint64_t *)&v196[8 * v192];
                *v197 = v187;
                v190 = v197 + 1;
                while (v189 != v191)
                {
                  v198 = *--v189;
                  *--v197 = v198;
                }
                *a2 = v197;
                a2[1] = v190;
                a2[2] = (unint64_t *)&v196[8 * v195];
                if (v191)
                  operator delete(v191);
              }
              else
              {
                *v189 = v186;
                v190 = v189 + 1;
              }
              a2[1] = v190;
              ++v184;
              v4 = 1;
            }
            while (v184 != v183);
            break;
          case -16260:
            v4 = 1;
            v199 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 1uLL);
            if (!v199)
              return v4;
            v200 = v199;
            v201 = 0;
            v202 = (uint64_t)(a1 + 18);
            do
            {
              v203 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v202, v201);
              v204 = v203;
              v206 = a2[1];
              v205 = (unint64_t)a2[2];
              if ((unint64_t)v206 >= v205)
              {
                v208 = *a2;
                v209 = v206 - *a2;
                v210 = v209 + 1;
                if ((unint64_t)(v209 + 1) >> 61)
LABEL_509:
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                v211 = v205 - (_QWORD)v208;
                if (v211 >> 2 > v210)
                  v210 = v211 >> 2;
                if ((unint64_t)v211 >= 0x7FFFFFFFFFFFFFF8)
                  v212 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v212 = v210;
                if (v212)
                {
                  v213 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v212);
                  v208 = *a2;
                  v206 = a2[1];
                }
                else
                {
                  v213 = 0;
                }
                v214 = (unint64_t *)&v213[8 * v209];
                *v214 = v204;
                v207 = v214 + 1;
                while (v206 != v208)
                {
                  v215 = *--v206;
                  *--v214 = v215;
                }
                *a2 = v214;
                a2[1] = v207;
                a2[2] = (unint64_t *)&v213[8 * v212];
                if (v208)
                  operator delete(v208);
              }
              else
              {
                *v206 = v203;
                v207 = v206 + 1;
              }
              a2[1] = v207;
              ++v201;
              v4 = 1;
            }
            while (v201 != v200);
            break;
          default:
            if (v5 == -16249 || v5 == -16248)
              goto LABEL_205;
            return v4;
        }
      }
      else
      {
        switch(v5)
        {
          case -16382:
          case -16381:
          case -16380:
LABEL_240:
            v164 = (uint64_t)(a1 + 18);
LABEL_363:
            v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v164, 0);
            std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
            v76 = (uint64_t)(a1 + 48);
            goto LABEL_233;
          case -16379:
          case -16378:
            goto LABEL_232;
          case -16377:
            v41 = (uint64_t)(a1 + 18);
            goto LABEL_507;
          default:
            switch(v5)
            {
              case -16336:
              case -16334:
                goto LABEL_232;
              case -16335:
                v4 = 1;
                v94 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 1uLL);
                if (!v94)
                  return v4;
                v95 = v94;
                v96 = 0;
                v97 = (uint64_t)(a1 + 18);
                do
                {
                  v98 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v97, v96);
                  v99 = v98;
                  v101 = a2[1];
                  v100 = (unint64_t)a2[2];
                  if ((unint64_t)v101 >= v100)
                  {
                    v103 = *a2;
                    v104 = v101 - *a2;
                    v105 = v104 + 1;
                    if ((unint64_t)(v104 + 1) >> 61)
                      goto LABEL_509;
                    v106 = v100 - (_QWORD)v103;
                    if (v106 >> 2 > v105)
                      v105 = v106 >> 2;
                    if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFF8)
                      v107 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v107 = v105;
                    if (v107)
                    {
                      v108 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v107);
                      v103 = *a2;
                      v101 = a2[1];
                    }
                    else
                    {
                      v108 = 0;
                    }
                    v109 = (unint64_t *)&v108[8 * v104];
                    *v109 = v99;
                    v102 = v109 + 1;
                    while (v101 != v103)
                    {
                      v110 = *--v101;
                      *--v109 = v110;
                    }
                    *a2 = v109;
                    a2[1] = v102;
                    a2[2] = (unint64_t *)&v108[8 * v107];
                    if (v103)
                      operator delete(v103);
                  }
                  else
                  {
                    *v101 = v98;
                    v102 = v101 + 1;
                  }
                  a2[1] = v102;
                  ++v96;
                  v4 = 1;
                }
                while (v96 != v95);
                return v4;
              case -16333:
                v4 = 1;
                v335 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 1uLL);
                if (!v335)
                  return v4;
                v336 = v335;
                v337 = 0;
                v338 = (uint64_t)(a1 + 18);
                break;
              default:
                return v4;
            }
            break;
        }
        do
        {
          v339 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v338, v337);
          v340 = v339;
          v342 = a2[1];
          v341 = (unint64_t)a2[2];
          if ((unint64_t)v342 >= v341)
          {
            v344 = *a2;
            v345 = v342 - *a2;
            v346 = v345 + 1;
            if ((unint64_t)(v345 + 1) >> 61)
              goto LABEL_509;
            v347 = v341 - (_QWORD)v344;
            if (v347 >> 2 > v346)
              v346 = v347 >> 2;
            if ((unint64_t)v347 >= 0x7FFFFFFFFFFFFFF8)
              v348 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v348 = v346;
            if (v348)
            {
              v349 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v348);
              v344 = *a2;
              v342 = a2[1];
            }
            else
            {
              v349 = 0;
            }
            v350 = (unint64_t *)&v349[8 * v345];
            *v350 = v340;
            v343 = v350 + 1;
            while (v342 != v344)
            {
              v351 = *--v342;
              *--v350 = v351;
            }
            *a2 = v350;
            a2[1] = v343;
            a2[2] = (unint64_t *)&v349[8 * v348];
            if (v344)
              operator delete(v344);
          }
          else
          {
            *v342 = v339;
            v343 = v342 + 1;
          }
          a2[1] = v343;
          ++v337;
          v4 = 1;
        }
        while (v337 != v336);
      }
    }
    else
    {
      if (v5 <= -16157)
      {
        switch(v5)
        {
          case -16220:
          case -16214:
          case -16213:
          case -16212:
            goto LABEL_232;
          case -16217:
            goto LABEL_205;
          case -16216:
            goto LABEL_238;
          case -16215:
            v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 0);
            std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
            v76 = (uint64_t)(a1 + 42);
            goto LABEL_233;
          case -16210:
          case -16209:
            goto LABEL_240;
          default:
            return v4;
        }
        return v4;
      }
      if (v5 <= -16088)
      {
        switch(v5)
        {
          case -16156:
          case -16155:
          case -16148:
          case -16142:
          case -16140:
            goto LABEL_232;
          case -16147:
            goto LABEL_205;
          case -16146:
            v23 = (uint64_t)(a1 + 24);
            goto LABEL_180;
          case -16145:
            goto LABEL_362;
          case -16144:
            v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
            std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
LABEL_362:
            v164 = (uint64_t)(a1 + 36);
            goto LABEL_363;
          default:
            return v4;
        }
      }
      if (v5 == -16087)
      {
        v4 = 1;
        v352 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 1uLL);
        if (v352)
        {
          v353 = v352;
          v354 = 0;
          v355 = (uint64_t)(a1 + 18);
          do
          {
            v356 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v355, v354);
            v357 = v356;
            v359 = a2[1];
            v358 = (unint64_t)a2[2];
            if ((unint64_t)v359 >= v358)
            {
              v361 = *a2;
              v362 = v359 - *a2;
              v363 = v362 + 1;
              if ((unint64_t)(v362 + 1) >> 61)
                goto LABEL_509;
              v364 = v358 - (_QWORD)v361;
              if (v364 >> 2 > v363)
                v363 = v364 >> 2;
              if ((unint64_t)v364 >= 0x7FFFFFFFFFFFFFF8)
                v365 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v365 = v363;
              if (v365)
              {
                v366 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v365);
                v361 = *a2;
                v359 = a2[1];
              }
              else
              {
                v366 = 0;
              }
              v367 = (unint64_t *)&v366[8 * v362];
              *v367 = v357;
              v360 = v367 + 1;
              while (v359 != v361)
              {
                v368 = *--v359;
                *--v367 = v368;
              }
              *a2 = v367;
              a2[1] = v360;
              a2[2] = (unint64_t *)&v366[8 * v365];
              if (v361)
                operator delete(v361);
            }
            else
            {
              *v359 = v356;
              v360 = v359 + 1;
            }
            a2[1] = v360;
            ++v354;
            v4 = 1;
          }
          while (v354 != v353);
        }
      }
      else
      {
        if (v5 != -16086)
        {
          v128 = -16079;
LABEL_208:
          if (v5 != v128)
            return v4;
          goto LABEL_232;
        }
        v4 = 1;
        v369 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 1uLL);
        if (v369)
        {
          v370 = v369;
          v371 = 0;
          v372 = (uint64_t)(a1 + 18);
          do
          {
            v373 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v372, v371);
            v374 = v373;
            v376 = a2[1];
            v375 = (unint64_t)a2[2];
            if ((unint64_t)v376 >= v375)
            {
              v378 = *a2;
              v379 = v376 - *a2;
              v380 = v379 + 1;
              if ((unint64_t)(v379 + 1) >> 61)
                goto LABEL_509;
              v381 = v375 - (_QWORD)v378;
              if (v381 >> 2 > v380)
                v380 = v381 >> 2;
              if ((unint64_t)v381 >= 0x7FFFFFFFFFFFFFF8)
                v382 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v382 = v380;
              if (v382)
              {
                v383 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v382);
                v378 = *a2;
                v376 = a2[1];
              }
              else
              {
                v383 = 0;
              }
              v384 = (unint64_t *)&v383[8 * v379];
              *v384 = v374;
              v377 = v384 + 1;
              while (v376 != v378)
              {
                v385 = *--v376;
                *--v384 = v385;
              }
              *a2 = v384;
              a2[1] = v377;
              a2[2] = (unint64_t *)&v383[8 * v382];
              if (v378)
                operator delete(v378);
            }
            else
            {
              *v376 = v373;
              v377 = v376 + 1;
            }
            a2[1] = v377;
            ++v371;
            v4 = 1;
          }
          while (v371 != v370);
        }
      }
    }
  }
  else if (v5 <= -15878)
  {
    if (v5 <= -16004)
    {
      switch(v5)
      {
        case -16047:
        case -16045:
        case -16043:
        case -16041:
          goto LABEL_232;
        case -16046:
          v42 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
          if (!v42)
            return 1;
          v43 = v42;
          v44 = 0;
          v45 = (uint64_t)(a1 + 18);
          do
          {
            v46 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v45, v44);
            v47 = v46;
            v49 = a2[1];
            v48 = (unint64_t)a2[2];
            if ((unint64_t)v49 >= v48)
            {
              v51 = *a2;
              v52 = v49 - *a2;
              v53 = v52 + 1;
              if ((unint64_t)(v52 + 1) >> 61)
                goto LABEL_509;
              v54 = v48 - (_QWORD)v51;
              if (v54 >> 2 > v53)
                v53 = v54 >> 2;
              if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
                v55 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v55 = v53;
              if (v55)
              {
                v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v55);
                v51 = *a2;
                v49 = a2[1];
              }
              else
              {
                v56 = 0;
              }
              v57 = (unint64_t *)&v56[8 * v52];
              *v57 = v47;
              v50 = v57 + 1;
              while (v49 != v51)
              {
                v58 = *--v49;
                *--v57 = v58;
              }
              *a2 = v57;
              a2[1] = v50;
              a2[2] = (unint64_t *)&v56[8 * v55];
              if (v51)
                operator delete(v51);
            }
            else
            {
              *v49 = v46;
              v50 = v49 + 1;
            }
            a2[1] = v50;
            ++v44;
            v4 = 1;
          }
          while (v44 != v43);
          return v4;
        case -16044:
          v267 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
          if (!v267)
            return 1;
          v268 = v267;
          v269 = 0;
          v270 = (uint64_t)(a1 + 18);
          do
          {
            v271 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v270, v269);
            v272 = v271;
            v274 = a2[1];
            v273 = (unint64_t)a2[2];
            if ((unint64_t)v274 >= v273)
            {
              v276 = *a2;
              v277 = v274 - *a2;
              v278 = v277 + 1;
              if ((unint64_t)(v277 + 1) >> 61)
                goto LABEL_509;
              v279 = v273 - (_QWORD)v276;
              if (v279 >> 2 > v278)
                v278 = v279 >> 2;
              if ((unint64_t)v279 >= 0x7FFFFFFFFFFFFFF8)
                v280 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v280 = v278;
              if (v280)
              {
                v281 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v280);
                v276 = *a2;
                v274 = a2[1];
              }
              else
              {
                v281 = 0;
              }
              v282 = (unint64_t *)&v281[8 * v277];
              *v282 = v272;
              v275 = v282 + 1;
              while (v274 != v276)
              {
                v283 = *--v274;
                *--v282 = v283;
              }
              *a2 = v282;
              a2[1] = v275;
              a2[2] = (unint64_t *)&v281[8 * v280];
              if (v276)
                operator delete(v276);
            }
            else
            {
              *v274 = v271;
              v275 = v274 + 1;
            }
            a2[1] = v275;
            ++v269;
            v4 = 1;
          }
          while (v269 != v268);
          return v4;
        case -16042:
          v284 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
          if (!v284)
            return 1;
          v285 = v284;
          v286 = 0;
          v287 = (uint64_t)(a1 + 18);
          do
          {
            v288 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v287, v286);
            v289 = v288;
            v291 = a2[1];
            v290 = (unint64_t)a2[2];
            if ((unint64_t)v291 >= v290)
            {
              v293 = *a2;
              v294 = v291 - *a2;
              v295 = v294 + 1;
              if ((unint64_t)(v294 + 1) >> 61)
                goto LABEL_509;
              v296 = v290 - (_QWORD)v293;
              if (v296 >> 2 > v295)
                v295 = v296 >> 2;
              if ((unint64_t)v296 >= 0x7FFFFFFFFFFFFFF8)
                v297 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v297 = v295;
              if (v297)
              {
                v298 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v297);
                v293 = *a2;
                v291 = a2[1];
              }
              else
              {
                v298 = 0;
              }
              v299 = (unint64_t *)&v298[8 * v294];
              *v299 = v289;
              v292 = v299 + 1;
              while (v291 != v293)
              {
                v300 = *--v291;
                *--v299 = v300;
              }
              *a2 = v299;
              a2[1] = v292;
              a2[2] = (unint64_t *)&v298[8 * v297];
              if (v293)
                operator delete(v293);
            }
            else
            {
              *v291 = v288;
              v292 = v291 + 1;
            }
            a2[1] = v292;
            ++v286;
            v4 = 1;
          }
          while (v286 != v285);
          return v4;
        case -16040:
          v301 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
          if (!v301)
            return 1;
          v302 = v301;
          v303 = 0;
          v304 = (uint64_t)(a1 + 18);
          do
          {
            v305 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v304, v303);
            v306 = v305;
            v308 = a2[1];
            v307 = (unint64_t)a2[2];
            if ((unint64_t)v308 >= v307)
            {
              v310 = *a2;
              v311 = v308 - *a2;
              v312 = v311 + 1;
              if ((unint64_t)(v311 + 1) >> 61)
                goto LABEL_509;
              v313 = v307 - (_QWORD)v310;
              if (v313 >> 2 > v312)
                v312 = v313 >> 2;
              if ((unint64_t)v313 >= 0x7FFFFFFFFFFFFFF8)
                v314 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v314 = v312;
              if (v314)
              {
                v315 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v314);
                v310 = *a2;
                v308 = a2[1];
              }
              else
              {
                v315 = 0;
              }
              v316 = (unint64_t *)&v315[8 * v311];
              *v316 = v306;
              v309 = v316 + 1;
              while (v308 != v310)
              {
                v317 = *--v308;
                *--v316 = v317;
              }
              *a2 = v316;
              a2[1] = v309;
              a2[2] = (unint64_t *)&v315[8 * v314];
              if (v310)
                operator delete(v310);
            }
            else
            {
              *v308 = v305;
              v309 = v308 + 1;
            }
            a2[1] = v309;
            ++v303;
            v4 = 1;
          }
          while (v303 != v302);
          return v4;
        default:
          if (v5 == -16017)
            goto LABEL_232;
          if (v5 != -16008)
            return v4;
          v129 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
          if (!v129)
            return 1;
          v130 = v129;
          v131 = 0;
          v132 = (uint64_t)(a1 + 18);
          break;
      }
      do
      {
        v133 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v132, v131);
        v134 = v133;
        v136 = a2[1];
        v135 = (unint64_t)a2[2];
        if ((unint64_t)v136 >= v135)
        {
          v138 = *a2;
          v139 = v136 - *a2;
          v140 = v139 + 1;
          if ((unint64_t)(v139 + 1) >> 61)
            goto LABEL_509;
          v141 = v135 - (_QWORD)v138;
          if (v141 >> 2 > v140)
            v140 = v141 >> 2;
          if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFF8)
            v142 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v142 = v140;
          if (v142)
          {
            v143 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v142);
            v138 = *a2;
            v136 = a2[1];
          }
          else
          {
            v143 = 0;
          }
          v144 = (unint64_t *)&v143[8 * v139];
          *v144 = v134;
          v137 = v144 + 1;
          while (v136 != v138)
          {
            v145 = *--v136;
            *--v144 = v145;
          }
          *a2 = v144;
          a2[1] = v137;
          a2[2] = (unint64_t *)&v143[8 * v142];
          if (v138)
            operator delete(v138);
        }
        else
        {
          *v136 = v133;
          v137 = v136 + 1;
        }
        a2[1] = v137;
        ++v131;
        v4 = 1;
      }
      while (v131 != v130);
    }
    else
    {
      if (v5 > -15977)
      {
        if (v5 > -15953)
        {
          switch(v5)
          {
            case -15952:
              v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 36), 0);
              std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
              v76 = (uint64_t)(a1 + 60);
              break;
            case -15887:
              v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 18), 0);
              std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
              v41 = (uint64_t)(a1 + 24);
LABEL_507:
              v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v41, 0);
              std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
LABEL_508:
              v76 = (uint64_t)(a1 + 30);
              break;
            case -15878:
              v23 = (uint64_t)(a1 + 18);
LABEL_180:
              v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v23, 0);
              std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
LABEL_205:
              v76 = (uint64_t)(a1 + 36);
              break;
            default:
              return v4;
          }
          goto LABEL_233;
        }
        if (v5 != -15976)
        {
          if (v5 != -15963 && v5 != -15961)
            return v4;
LABEL_238:
          v76 = (uint64_t)(a1 + 24);
          goto LABEL_233;
        }
        goto LABEL_232;
      }
      switch(v5)
      {
        case -16003:
          v24 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
          if (!v24)
            return 1;
          v25 = v24;
          v26 = 0;
          v27 = (uint64_t)(a1 + 18);
          break;
        case -16002:
        case -16001:
        case -16000:
        case -15999:
        case -15998:
        case -15997:
        case -15996:
          return v4;
        case -15995:
        case -15994:
        case -15993:
        case -15992:
          goto LABEL_232;
        default:
          if (v5 == -15977)
            goto LABEL_240;
          return v4;
      }
      do
      {
        v28 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v27, v26);
        v29 = v28;
        v31 = a2[1];
        v30 = (unint64_t)a2[2];
        if ((unint64_t)v31 >= v30)
        {
          v33 = *a2;
          v34 = v31 - *a2;
          v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61)
            goto LABEL_509;
          v36 = v30 - (_QWORD)v33;
          if (v36 >> 2 > v35)
            v35 = v36 >> 2;
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
            v37 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v37 = v35;
          if (v37)
          {
            v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v37);
            v33 = *a2;
            v31 = a2[1];
          }
          else
          {
            v38 = 0;
          }
          v39 = (unint64_t *)&v38[8 * v34];
          *v39 = v29;
          v32 = v39 + 1;
          while (v31 != v33)
          {
            v40 = *--v31;
            *--v39 = v40;
          }
          *a2 = v39;
          a2[1] = v32;
          a2[2] = (unint64_t *)&v38[8 * v37];
          if (v33)
            operator delete(v33);
        }
        else
        {
          *v31 = v28;
          v32 = v31 + 1;
        }
        a2[1] = v32;
        ++v26;
        v4 = 1;
      }
      while (v26 != v25);
    }
  }
  else
  {
    if (v5 > -15402)
    {
      if (v5 <= -15285)
      {
        switch(v5)
        {
          case -15401:
          case -15393:
          case -15391:
          case -15383:
            goto LABEL_232;
          case -15399:
            v4 = 1;
            v6 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 1uLL);
            if (!v6)
              return v4;
            v7 = v6;
            v8 = 0;
            v9 = (uint64_t)(a1 + 18);
            do
            {
              v10 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v9, v8);
              v11 = v10;
              v13 = a2[1];
              v12 = (unint64_t)a2[2];
              if ((unint64_t)v13 >= v12)
              {
                v15 = *a2;
                v16 = v13 - *a2;
                v17 = v16 + 1;
                if ((unint64_t)(v16 + 1) >> 61)
                  goto LABEL_509;
                v18 = v12 - (_QWORD)v15;
                if (v18 >> 2 > v17)
                  v17 = v18 >> 2;
                if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
                  v19 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v19 = v17;
                if (v19)
                {
                  v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v19);
                  v15 = *a2;
                  v13 = a2[1];
                }
                else
                {
                  v20 = 0;
                }
                v21 = (unint64_t *)&v20[8 * v16];
                *v21 = v11;
                v14 = v21 + 1;
                while (v13 != v15)
                {
                  v22 = *--v13;
                  *--v21 = v22;
                }
                *a2 = v21;
                a2[1] = v14;
                a2[2] = (unint64_t *)&v20[8 * v19];
                if (v15)
                  operator delete(v15);
              }
              else
              {
                *v13 = v10;
                v14 = v13 + 1;
              }
              a2[1] = v14;
              ++v8;
              v4 = 1;
            }
            while (v8 != v7);
            return v4;
          case -15392:
            v4 = 1;
            v216 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 1uLL);
            if (!v216)
              return v4;
            v217 = v216;
            v218 = 0;
            v219 = (uint64_t)(a1 + 18);
            do
            {
              v220 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v219, v218);
              v221 = v220;
              v223 = a2[1];
              v222 = (unint64_t)a2[2];
              if ((unint64_t)v223 >= v222)
              {
                v225 = *a2;
                v226 = v223 - *a2;
                v227 = v226 + 1;
                if ((unint64_t)(v226 + 1) >> 61)
                  goto LABEL_509;
                v228 = v222 - (_QWORD)v225;
                if (v228 >> 2 > v227)
                  v227 = v228 >> 2;
                if ((unint64_t)v228 >= 0x7FFFFFFFFFFFFFF8)
                  v229 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v229 = v227;
                if (v229)
                {
                  v230 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v229);
                  v225 = *a2;
                  v223 = a2[1];
                }
                else
                {
                  v230 = 0;
                }
                v231 = (unint64_t *)&v230[8 * v226];
                *v231 = v221;
                v224 = v231 + 1;
                while (v223 != v225)
                {
                  v232 = *--v223;
                  *--v231 = v232;
                }
                *a2 = v231;
                a2[1] = v224;
                a2[2] = (unint64_t *)&v230[8 * v229];
                if (v225)
                  operator delete(v225);
              }
              else
              {
                *v223 = v220;
                v224 = v223 + 1;
              }
              a2[1] = v224;
              ++v218;
              v4 = 1;
            }
            while (v218 != v217);
            return v4;
          case -15389:
            v4 = 1;
            v233 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 30), 1uLL);
            if (!v233)
              return v4;
            v234 = v233;
            v235 = 0;
            v236 = (uint64_t)(a1 + 18);
            do
            {
              v237 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v236, v235);
              v238 = v237;
              v240 = a2[1];
              v239 = (unint64_t)a2[2];
              if ((unint64_t)v240 >= v239)
              {
                v242 = *a2;
                v243 = v240 - *a2;
                v244 = v243 + 1;
                if ((unint64_t)(v243 + 1) >> 61)
                  goto LABEL_509;
                v245 = v239 - (_QWORD)v242;
                if (v245 >> 2 > v244)
                  v244 = v245 >> 2;
                if ((unint64_t)v245 >= 0x7FFFFFFFFFFFFFF8)
                  v246 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v246 = v244;
                if (v246)
                {
                  v247 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v246);
                  v242 = *a2;
                  v240 = a2[1];
                }
                else
                {
                  v247 = 0;
                }
                v248 = (unint64_t *)&v247[8 * v243];
                *v248 = v238;
                v241 = v248 + 1;
                while (v240 != v242)
                {
                  v249 = *--v240;
                  *--v248 = v249;
                }
                *a2 = v248;
                a2[1] = v241;
                a2[2] = (unint64_t *)&v247[8 * v246];
                if (v242)
                  operator delete(v242);
              }
              else
              {
                *v240 = v237;
                v241 = v240 + 1;
              }
              a2[1] = v241;
              ++v235;
              v4 = 1;
            }
            while (v235 != v234);
            return v4;
          case -15382:
            v4 = 1;
            v250 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 1uLL);
            if (!v250)
              return v4;
            v251 = v250;
            v252 = 0;
            v253 = (uint64_t)(a1 + 18);
            break;
          default:
            return v4;
        }
        do
        {
          v254 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v253, v252);
          v255 = v254;
          v257 = a2[1];
          v256 = (unint64_t)a2[2];
          if ((unint64_t)v257 >= v256)
          {
            v259 = *a2;
            v260 = v257 - *a2;
            v261 = v260 + 1;
            if ((unint64_t)(v260 + 1) >> 61)
              goto LABEL_509;
            v262 = v256 - (_QWORD)v259;
            if (v262 >> 2 > v261)
              v261 = v262 >> 2;
            if ((unint64_t)v262 >= 0x7FFFFFFFFFFFFFF8)
              v263 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v263 = v261;
            if (v263)
            {
              v264 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v263);
              v259 = *a2;
              v257 = a2[1];
            }
            else
            {
              v264 = 0;
            }
            v265 = (unint64_t *)&v264[8 * v260];
            *v265 = v255;
            v258 = v265 + 1;
            while (v257 != v259)
            {
              v266 = *--v257;
              *--v265 = v266;
            }
            *a2 = v265;
            a2[1] = v258;
            a2[2] = (unint64_t *)&v264[8 * v263];
            if (v259)
              operator delete(v259);
          }
          else
          {
            *v257 = v254;
            v258 = v257 + 1;
          }
          a2[1] = v258;
          ++v252;
          v4 = 1;
        }
        while (v252 != v251);
        return v4;
      }
      if (v5 <= -15276)
      {
        if (v5 != -15284)
        {
          if (v5 == -15282)
          {
            v4 = 1;
            v111 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 36), 1uLL);
            if (v111)
            {
              v112 = v111;
              v113 = 0;
              v114 = (uint64_t)(a1 + 18);
              do
              {
                v115 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v114, v113);
                v116 = v115;
                v118 = a2[1];
                v117 = (unint64_t)a2[2];
                if ((unint64_t)v118 >= v117)
                {
                  v120 = *a2;
                  v121 = v118 - *a2;
                  v122 = v121 + 1;
                  if ((unint64_t)(v121 + 1) >> 61)
                    goto LABEL_509;
                  v123 = v117 - (_QWORD)v120;
                  if (v123 >> 2 > v122)
                    v122 = v123 >> 2;
                  if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFF8)
                    v124 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v124 = v122;
                  if (v124)
                  {
                    v125 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v124);
                    v120 = *a2;
                    v118 = a2[1];
                  }
                  else
                  {
                    v125 = 0;
                  }
                  v126 = (unint64_t *)&v125[8 * v121];
                  *v126 = v116;
                  v119 = v126 + 1;
                  while (v118 != v120)
                  {
                    v127 = *--v118;
                    *--v126 = v127;
                  }
                  *a2 = v126;
                  a2[1] = v119;
                  a2[2] = (unint64_t *)&v125[8 * v124];
                  if (v120)
                    operator delete(v120);
                }
                else
                {
                  *v118 = v115;
                  v119 = v118 + 1;
                }
                a2[1] = v119;
                ++v113;
                v4 = 1;
              }
              while (v113 != v112);
            }
          }
          return v4;
        }
        goto LABEL_232;
      }
      if (v5 != -15275)
      {
        if (v5 == -15273)
        {
          v4 = 1;
          v146 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 36), 1uLL);
          if (v146)
          {
            v147 = v146;
            v148 = 0;
            v149 = (uint64_t)(a1 + 18);
            do
            {
              v150 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v149, v148);
              v151 = v150;
              v153 = a2[1];
              v152 = (unint64_t)a2[2];
              if ((unint64_t)v153 >= v152)
              {
                v155 = *a2;
                v156 = v153 - *a2;
                v157 = v156 + 1;
                if ((unint64_t)(v156 + 1) >> 61)
                  goto LABEL_509;
                v158 = v152 - (_QWORD)v155;
                if (v158 >> 2 > v157)
                  v157 = v158 >> 2;
                if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8)
                  v159 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v159 = v157;
                if (v159)
                {
                  v160 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v159);
                  v155 = *a2;
                  v153 = a2[1];
                }
                else
                {
                  v160 = 0;
                }
                v161 = (unint64_t *)&v160[8 * v156];
                *v161 = v151;
                v154 = v161 + 1;
                while (v153 != v155)
                {
                  v162 = *--v153;
                  *--v161 = v162;
                }
                *a2 = v161;
                a2[1] = v154;
                a2[2] = (unint64_t *)&v160[8 * v159];
                if (v155)
                  operator delete(v155);
              }
              else
              {
                *v153 = v150;
                v154 = v153 + 1;
              }
              a2[1] = v154;
              ++v148;
              v4 = 1;
            }
            while (v148 != v147);
          }
        }
        return v4;
      }
LABEL_232:
      v76 = (uint64_t)(a1 + 18);
LABEL_233:
      v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v76, 0);
      std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
      return 1;
    }
    if (v5 > -15757)
    {
      switch(v5)
      {
        case -15728:
        case -15726:
        case -15723:
        case -15722:
          goto LABEL_232;
        case -15727:
        case -15725:
        case -15724:
          return v4;
        default:
          if (v5 == -15756)
            goto LABEL_508;
          v128 = -15415;
          goto LABEL_208;
      }
    }
    switch(v5)
    {
      case -15821:
      case -15819:
        goto LABEL_232;
      case -15820:
        v77 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
        if (!v77)
          return 1;
        v78 = v77;
        v79 = 0;
        v80 = (uint64_t)(a1 + 18);
        do
        {
          v81 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v80, v79);
          v82 = v81;
          v84 = a2[1];
          v83 = (unint64_t)a2[2];
          if ((unint64_t)v84 >= v83)
          {
            v86 = *a2;
            v87 = v84 - *a2;
            v88 = v87 + 1;
            if ((unint64_t)(v87 + 1) >> 61)
              goto LABEL_509;
            v89 = v83 - (_QWORD)v86;
            if (v89 >> 2 > v88)
              v88 = v89 >> 2;
            if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
              v90 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v90 = v88;
            if (v90)
            {
              v91 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v90);
              v86 = *a2;
              v84 = a2[1];
            }
            else
            {
              v91 = 0;
            }
            v92 = (unint64_t *)&v91[8 * v87];
            *v92 = v82;
            v85 = v92 + 1;
            while (v84 != v86)
            {
              v93 = *--v84;
              *--v92 = v93;
            }
            *a2 = v92;
            a2[1] = v85;
            a2[2] = (unint64_t *)&v91[8 * v90];
            if (v86)
              operator delete(v86);
          }
          else
          {
            *v84 = v81;
            v85 = v84 + 1;
          }
          a2[1] = v85;
          ++v79;
          v4 = 1;
        }
        while (v79 != v78);
        return v4;
      case -15818:
        v318 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 24), 0);
        if (!v318)
          return 1;
        v319 = v318;
        v320 = 0;
        v321 = (uint64_t)(a1 + 18);
        break;
      default:
        if (v5 != -15877)
          return v4;
        v386 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>((uint64_t)(a1 + 18), 0);
        std::vector<unsigned long long>::emplace_back<unsigned long long>((uint64_t)a2, &v386);
        goto LABEL_238;
    }
    do
    {
      v322 = GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(v321, v320);
      v323 = v322;
      v325 = a2[1];
      v324 = (unint64_t)a2[2];
      if ((unint64_t)v325 >= v324)
      {
        v327 = *a2;
        v328 = v325 - *a2;
        v329 = v328 + 1;
        if ((unint64_t)(v328 + 1) >> 61)
          goto LABEL_509;
        v330 = v324 - (_QWORD)v327;
        if (v330 >> 2 > v329)
          v329 = v330 >> 2;
        if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFF8)
          v331 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v331 = v329;
        if (v331)
        {
          v332 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v331);
          v327 = *a2;
          v325 = a2[1];
        }
        else
        {
          v332 = 0;
        }
        v333 = (unint64_t *)&v332[8 * v328];
        *v333 = v323;
        v326 = v333 + 1;
        while (v325 != v327)
        {
          v334 = *--v325;
          *--v333 = v334;
        }
        *a2 = v333;
        a2[1] = v326;
        a2[2] = (unint64_t *)&v332[8 * v331];
        if (v327)
          operator delete(v327);
      }
      else
      {
        *v325 = v322;
        v326 = v325 + 1;
      }
      a2[1] = v326;
      ++v320;
      v4 = 1;
    }
    while (v320 != v319);
  }
  return v4;
}

_QWORD *std::vector<unsigned long long>::emplace_back<unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v4 = a1 + 16;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *(_QWORD **)a1;
    v9 = ((uint64_t)v6 - *(_QWORD *)a1) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v4, v12);
      v8 = *(_QWORD **)a1;
      v6 = *(_QWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = &v13[8 * v12];
    *(_QWORD *)v14 = *a2;
    v7 = v14 + 8;
    while (v6 != v8)
    {
      v16 = *--v6;
      *((_QWORD *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = *a2;
    v7 = v6 + 1;
  }
  *(_QWORD *)(a1 + 8) = v7;
  return v7 - 1;
}

unint64_t GPUTools::FD::Argument::ViewAsScalarArray<unsigned long long>(uint64_t a1, unint64_t a2)
{
  __int16 v2;
  unint64_t result;
  int v4;
  double v5;

  v2 = *(_WORD *)(a1 + 22);
  if ((v2 & 1) != 0)
  {
    if (*(unsigned __int16 *)(a1 + 20) > a2)
      goto LABEL_5;
    return 0;
  }
  if (a2)
    return 0;
LABEL_5:
  switch(*(_DWORD *)(a1 + 8))
  {
    case 1:
      return *(char *)(*(_QWORD *)a1 + a2);
    case 2:
      return *(unsigned __int8 *)(*(_QWORD *)a1 + a2);
    case 3:
      return *(__int16 *)(*(_QWORD *)a1 + 2 * a2);
    case 4:
      return *(unsigned __int16 *)(*(_QWORD *)a1 + 2 * a2);
    case 5:
      v4 = *(_DWORD *)(a1 + 12);
      result = *(int *)(*(_QWORD *)a1 + 4 * a2);
      if (v4 != 19)
        return result;
      v5 = (double)(int)result * 0.0000152587891;
LABEL_10:
      result = (unint64_t)v5;
      break;
    case 6:
      return *(unsigned int *)(*(_QWORD *)a1 + 4 * a2);
    case 7:
    case 8:
    case 0xB:
    case 0xC:
      return *(_QWORD *)(*(_QWORD *)a1 + 8 * a2);
    case 9:
      return (unint64_t)*(float *)(*(_QWORD *)a1 + 4 * a2);
    case 0xA:
      v5 = *(double *)(*(_QWORD *)a1 + 8 * a2);
      goto LABEL_10;
    case 0xD:
      if ((v2 & 0x10) == 0)
        return 0;
      return GPUTools::FD::Argument::ViewAsGLObjectName((GPUTools::FD::Argument *)a1);
    default:
      return 0;
  }
  return result;
}

const char *GPUTools::MTL::GetFuncEnumAsString(GPUTools::MTL *this)
{
  const char *result;
  int v2;

  if ((int)this > -12545)
  {
    if ((int)this > -7169)
    {
      switch(this)
      {
        case 0xFFFFE800:
          result = "kDYFEMPSExternalMatrixMultiplication_encodeToCommandBuffer_encoder_options_batchSize_resultRows_resul"
                   "tColumns_interiorColumns_alpha_beta_A_aInfo_B_bInfo_C_cInfo_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE801:
          result = "kDYFEMPSPlugin_newCNNConvolutionWithDescriptor_convolutionData";
          break;
        case 0xFFFFE802:
          result = "kDYFEMPSExternalCNNPoolingAverage_encodeBatchToCommandBuffer_computeCommandEncoder_options_sourceText"
                   "ures_sourceInfo_destinationTextures_destinationInfo_zeroPadSizeX_zeroPadSizeY_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE803:
          result = "kDYFEMPSPlugin_newCNNPoolingMaxWithKernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY";
          break;
        case 0xFFFFE804:
          result = "kDYFEMPSExternalMatrixVectorMultiplication_encodeToCommandBuffer_encoder_options_batchSize_matrix_mat"
                   "rixStructure_vector_vectorStructure_result_resultStructure_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE805:
          result = "kDYFEMPSExternalPluginBase_dealloc";
          break;
        case 0xFFFFE806:
          result = "kDYFEMPSExternalCNNUnary_maxBatchSize";
          break;
        case 0xFFFFE807:
          result = "kDYFEMPSExternalMatrixVectorMultiplication_encodeToCommandBuffer_encoder_options_batchSize_matrix_mat"
                   "rixStructure_vector_vectorStructure_result_resultStructure";
          break;
        case 0xFFFFE808:
          result = "kDYFEMPSExternalCNNConvolution_reloadWeightsAndBiasesWithCommandBuffer_encoder_weights_biases_predica"
                   "tionBuffer_predicationOffset";
          break;
        case 0xFFFFE809:
          result = "kDYFEMPSExternalCNNUnary_encodeToCommandBuffer_computeCommandEncoder_options_sourceTexture_sourceInfo"
                   "_destinationTexture_destinationInfo";
          break;
        case 0xFFFFE80A:
          result = "kDYFEMPSPlugin_newMatrixVectorMultiplicationWithTranspose_rows_columns_alpha_beta";
          break;
        case 0xFFFFE80B:
          result = "kDYFEMPSPlugin_newCNNNeuronWithNeuronType_neuronParameterA_neuronParameterB_neuronParameterC";
          break;
        case 0xFFFFE80C:
          result = "kDYFEMPSExternalMatrixMultiplication_encodeToCommandBuffer_encoder_options_batchSize_resultRows_resul"
                   "tColumns_interiorColumns_alpha_beta_A_aInfo_B_bInfo_C_cInfo";
          break;
        case 0xFFFFE80D:
          result = "kDYFEMPSPlugin_newCNNConvolutionWithDescriptor_dataSource_fullyConnected";
          break;
        case 0xFFFFE80E:
          result = "kDYFEMPSExternalMatrixMultiplication_encodeToCommandBuffer_encoder_options_batchSize_A_aInfo_B_bInfo_C_cInfo";
          break;
        case 0xFFFFE80F:
          result = "kDYFEMPSPlugin_newCNNNeuronWithNeuronType_neuronParameterAArray_count";
          break;
        case 0xFFFFE810:
          result = "kDYFEMPSExternalMatrixFullyConnected_encodeToCommandBuffer_encoder_options_batchSize_inputMatrix_inpu"
                   "tMatrixInfo_weightMatrix_weightMatrixInfo_biasVector_biasVectorInfo_resultMatrix_resultMatrixInfo_alp"
                   "ha_numberOfFeatureVectors_inputFeatureChannels_outputFeatureChannels_neuronType_neuronParameterA_neur"
                   "onParameterB_neuronParameterC";
          break;
        case 0xFFFFE811:
          result = "kDYFEMPSExternalCNNConvolutionGradient_reloadWeights";
          break;
        case 0xFFFFE812:
          result = "kDYFEMPSExternalCNNPoolingAverage_encodeToCommandBuffer_computeCommandEncoder_options_sourceTexture_s"
                   "ourceInfo_destinationTexture_destinationInfo";
          break;
        case 0xFFFFE813:
          result = "kDYFEMPSExternalCNNBinary_encodeToCommandBuffer_computeCommandEncoder_options_pluginOptions_primaryTe"
                   "xture_primaryInfo_secondaryTexture_secondaryInfo_destinationTexture_destinationInfo";
          break;
        case 0xFFFFE814:
          result = "kDYFEMPSExternalMatrixFullyConnected_encodeToCommandBuffer_encoder_options_batchSize_inputMatrix_inpu"
                   "tMatrixInfo_weightMatrix_weightMatrixInfo_biasVector_biasVectorInfo_resultMatrix_resultMatrixInfo_alp"
                   "ha_numberOfFeatureVectors_inputFeatureChannels_outputFeatureChannels_neuronType_neuronParameterA_neur"
                   "onParameterB_neuronParameterC_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE815:
          result = "kDYFEMPSExternalCNNBinary_maxBatchSize";
          break;
        case 0xFFFFE816:
          result = "kDYFEMPSPlugin_newMatrixMultiplicationWithTransposeLeft_transposeRight_resultRows_resultColumns_inter"
                   "iorColumns_alpha_beta";
          break;
        case 0xFFFFE817:
          result = "kDYFEMPSExternalCNNPoolingAverage_encodeToCommandBuffer_computeCommandEncoder_options_sourceTexture_s"
                   "ourceInfo_destinationTexture_destinationInfo_zeroPadSizeX_zeroPadSizeY";
          break;
        case 0xFFFFE818:
          result = "kDYFEMPSExternalCNNConvolution_reloadWeightsAndBiases";
          break;
        case 0xFFFFE819:
          result = "kDYFEMPSPlugin_newCNNSoftMax";
          break;
        case 0xFFFFE81A:
          result = "kDYFEMPSExternalCNNBinary_encodeBatchToCommandBuffer_computeCommandEncoder_options_pluginOptions_prim"
                   "aryTextures_primaryInfo_secondaryTextures_secondaryInfo_destinationTextures_destinationInfo_predicati"
                   "onBuffer_predicationOffset";
          break;
        case 0xFFFFE81B:
          result = "kDYFEMPSExternalCNNUnary_encodeToCommandBuffer_computeCommandEncoder_options_pluginOptions_sourceText"
                   "ure_sourceInfo_destinationTexture_destinationInfo";
          break;
        case 0xFFFFE81C:
          result = "kDYFEMPSPlugin_newCNNDilatedPoolingMaxWithKernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY_di"
                   "lationRateX_dilationRateY";
          break;
        case 0xFFFFE81D:
          result = "kDYFEMPSExternalCNNUnary_encodeBatchToCommandBuffer_computeCommandEncoder_options_pluginOptions_sourc"
                   "eTextures_sourceInfo_destinationTextures_destinationInfo_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE81E:
          result = "kDYFEMPSExternalCNNConvolutionGradient_encodeBatchToCommandBuffer_computeCommandEncoder_options_plugi"
                   "nOptions_primaryTextures_primaryInfo_secondaryTextures_secondaryInfo_weightsGradient_biasesGradient_a"
                   "ccumulate_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE81F:
          result = "kDYFEMPSExternalCNNConvolutionGradient_reloadWeightsWithCommandBuffer_encoder_weights_predicationBuff"
                   "er_predicationOffset";
          break;
        case 0xFFFFE820:
          result = "kDYFEMPSExternalCNNConvolution_exportWeightsAndBiasesWithCommandBuffer_encoder_weights_biases_predica"
                   "tionBuffer_predicationOffset";
          break;
        case 0xFFFFE821:
          result = "kDYFEMPSPlugin_newCNNConvolutionGradientWithDescriptor_convolutionData";
          break;
        case 0xFFFFE822:
          result = "kDYFEMPSPlugin_newMatrixFullyConnected";
          break;
        case 0xFFFFE823:
          result = "kDYFEMPSPlugin_newCNNPoolingAverageWithKernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY";
          break;
        case 0xFFFFE824:
          result = "kDYFEMPSExternalCNNConvolution_reloadWeightsAndBiasesWithCommandBuffer_encoder_weights_weightsDataTyp"
                   "e_biases_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE825:
          result = "kDYFEMPSExternalCNNConvolutionGradient_reloadWeightsWithCommandBuffer_encoder_weights_weightsDataType"
                   "_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE826:
          result = "kDYFEMPSExternalCNNConvolution_exportWeightsAndBiasesWithCommandBuffer_encoder_weights_weightsDataTyp"
                   "e_biases_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE827:
          result = "kDYFEMPSExternalMatrixMultiplication_encodeToCommandBuffer_encoder_options_batchSize_resultRowsAndRes"
                   "ultColumnsAndInteriorColumns_alphaAndBeta_A_aInfo_B_bInfo_C_cInfo_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE828:
          result = "kDYFEMPSExternalMatrixFullyConnected_encodeToCommandBuffer_encoder_optionsAndBatchSize_inputMatrix_in"
                   "putMatrixInfo_weightMatrix_weightMatrixInfo_biasVector_biasVectorInfo_resultMatrix_resultMatrixInfo_a"
                   "lpha_numberOfFeatureVectorsAndInputFeatureChannelsAndOutputFeatureChannels_neuronType_neuronParameters";
          break;
        case 0xFFFFE829:
          result = "kDYFEMPSExternalMatrixFullyConnected_encodeToCommandBuffer_encoder_optionsAndBatchSize_inputMatrix_in"
                   "putMatrixInfo_weightMatrix_weightMatrixInfo_biasVector_biasVectorInfo_resultMatrix_resultMatrixInfo_a"
                   "lpha_numberOfFeatureVectorsAndInputFeatureChannelsAndOutputFeatureChannelsAndNeuronTypeAndPredication"
                   "Offset_neuronParameters_predicationBuffer";
          break;
        case 0xFFFFE82A:
          result = "kDYFEMPSExternalNDArrayConvolution2DGradient_encodePrimaryGradientToCommandBuffer_encoder_options_plu"
                   "ginOptions_primary_primaryInfo_secondary_secondaryInfo_gradient_gradientInfo_destination_destinationI"
                   "nfo_accumulate_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE82B:
          result = "kDYFEMPSExternalMatrixMultiplication_encodeToCommandBuffer_encoder_options_batchSize_resultRows_resul"
                   "tColumns_interiorColumns_alpha_beta_A_aInfo_B_bInfo_C_cInfo_predicationBuffer_predicationOffset_transA_transB";
          break;
        case 0xFFFFE82C:
          result = "kDYFEMPSExternalNDArrayConvolution2DGradient_encodeSecondaryGradientToCommandBuffer_encoder_options_p"
                   "luginOptions_primary_primaryInfo_secondary_secondaryInfo_gradient_gradientInfo_destination_destinatio"
                   "nInfo_accumulate_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE82D:
          result = "kDYFEMPSExternalNDArrayBinaryGradient_encodePrimaryGradientToCommandBuffer_encoder_options_pluginOpti"
                   "ons_primaryBuffer_primaryInfo_secondaryBuffer_secondaryInfo_gradientBuffer_gradientInfo_destination_d"
                   "estinationInfo_accumulate_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE82E:
          result = "kDYFEMPSExternalNDArrayBinaryGradient_encodeSecondaryGradientToCommandBuffer_encoder_options_pluginOp"
                   "tions_primaryBuffer_primaryInfo_secondaryBuffer_secondaryInfo_gradientBuffer_gradientInfo_destination"
                   "_destinationInfo_accumulate_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE82F:
          result = "kDYFEMPSExternalNDArrayBinary_encodeToCommandBuffer_encoder_options_pluginOptions_primaryBuffer_prima"
                   "ryInfo_secondaryBuffer_secondaryInfo_destinationBuffer_destinationInfo_predicationBuffer_predicationOffset";
          break;
        case 0xFFFFE830:
          result = "kDYFEMPSPlugin_newNDArrayConvolution2DGradientWithDescriptor";
          break;
        case 0xFFFFE831:
          result = "kDYFEMPSPlugin_newNDArrayConvolution2DWithDescriptor";
          break;
        default:
          switch(this)
          {
            case 0xFFFFE400:
              result = "kDYFECAMetalLayer_setPresentsWithTransaction";
              break;
            case 0xFFFFE401:
              result = "kDYFECAMetalDrawable_texture";
              break;
            case 0xFFFFE402:
              result = "kDYFECAMetalLayer_nextDrawable";
              break;
            case 0xFFFFE403:
              result = "kDYFECAMetalLayer_setPixelFormat";
              break;
            case 0xFFFFE404:
              result = "kDYFECAMetalLayer_setDrawableSize";
              break;
            case 0xFFFFE405:
              result = "kDYFECAMetalLayer_setDevice";
              break;
            case 0xFFFFE406:
              result = "kDYFECAMetalLayer_setBounds_contentsScale";
              break;
            case 0xFFFFE407:
              result = "kDYFECAMetalDrawable_dealloc";
              break;
            case 0xFFFFE408:
              result = "kDYFECAMetalLayer_setFramebufferOnly";
              break;
            case 0xFFFFE409:
              result = "kDYFECAMetalLayer_setBounds_contentsScale_windowBounds_windowProperties";
              break;
            case 0xFFFFE40A:
              result = "kDYFECAMetalDrawable_present";
              break;
            case 0xFFFFE40B:
              result = "kDYFECAMetalDrawable_presentAtTime";
              break;
            case 0xFFFFE40C:
              result = "kDYFECAMetalDrawable_presentAfterMinimumDuration";
              break;
            case 0xFFFFE40D:
              result = "kDYFEUIScreen_setInterfaceOrientation";
              break;
            case 0xFFFFE40E:
              result = "kDYFECAMetalLayer_setWantsExtendedDynamicRangeContent";
              break;
            case 0xFFFFE40F:
              result = "kDYFECAMetalLayer_setColorspace";
              break;
            default:
              switch(this)
              {
                case 0xFFFFE600:
                  result = "kDYFENSHMDMetalSession_setDrawablePixelFormat";
                  break;
                case 0xFFFFE601:
                  result = "kDYFENSHMDMetalSession_nextDrawable";
                  break;
                case 0xFFFFE602:
                  result = "kDYFENSHMDMetalSession_initWithMetalDevice_deviceReference_hmdName";
                  break;
                case 0xFFFFE603:
                  result = "kDYFENSHMDMetalSession_setDrawableSize";
                  break;
                case 0xFFFFE604:
                  result = "kDYFENSHMDMetalSession_dealloc";
                  break;
                default:
LABEL_1384:
                  result = 0;
                  break;
              }
              break;
          }
          break;
      }
    }
    else
    {
      v2 = (_DWORD)this + 10240;
      result = "kDYFEBoundary_Frame";
      switch(v2)
      {
        case 0:
          result = "kDYFEMTLCommandBuffer_restoreMTLBufferContents";
          break;
        case 1:
          result = "kDYFEMTLDevice_deviceReference";
          break;
        case 2:
          result = "kDYFEMTLTexture_harvested_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage";
          break;
        case 3:
          result = "kDYFEMTLDevice_harvested_newBufferWithBytes_length_options";
          break;
        case 4:
          result = "kDYFEMTLTexture_harvested_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_totalBytes";
          break;
        case 5:
          result = "kDYFEMTLBuffer_resourceUsage";
          break;
        case 6:
          result = "kDYFEMTLTexture_resourceUsage";
          break;
        case 7:
          result = "kDYFEMTLDevice_setSelectedCommandQueueAddress";
          break;
        case 8:
          result = "kDYFEMTLTexture_restoreIOSurfaceData_length_forPlane";
          break;
        case 9:
          result = "kDYFEMTLTexture_mipmapInfo";
          break;
        case 10:
          result = "kDYFEMTLDevice_setCapturingCommandQueueAddress";
          break;
        case 11:
          result = "kDYFEMTLCommandBuffer_indirectArgumentBufferData";
          break;
        case 12:
          result = "kDYFEMTLBuffer_gpuVirtualAddress";
          break;
        case 13:
          result = "kDYFEMTLTexture_uniqueIdentifier";
          break;
        case 14:
          result = "kDYFEMTLSamplerState_uniqueIdentifier";
          break;
        case 15:
          result = "kDYFEMTLCommandBuffer_encodeIndirectArgumentsForBuffer_data";
          break;
        case 16:
          result = "kDYFEFrameEnd";
          break;
        case 17:
          result = "kDYFEMTLBuffer_allocatedSize";
          break;
        case 18:
          result = "kDYFEMTLTexture_allocatedSize";
          break;
        case 19:
          result = "kDYFEMTLBuffer_indirectCommandBufferData";
          break;
        case 20:
          result = "kDYFEMTLRenderPipelineState_uniqueIdentifier";
          break;
        case 21:
          result = "kDYFEMTLIndirectCommandBuffer_restoreData";
          break;
        case 22:
          result = "kDYFEMTLIndirectCommandBuffer_uniqueIdentifier";
          break;
        case 23:
          result = "kDYFEMTLIndirectCommandBuffer_indirectCommandNop";
          break;
        case 24:
          result = "kDYFEMTLIndirectCommandBuffer_restoreOptimizedRanges";
          break;
        case 25:
          result = "kDYFEMTLIndirectCommandBuffer_allocatedSize";
          break;
        case 26:
          result = "kDYFEMTLComputePipelineState_uniqueIdentifier";
          break;
        case 27:
          result = "kDYFEMTLResourceStateCommandEncoder_harvested_updateTextureMapping_mode_region_mipLevel_slice";
          break;
        case 28:
          result = "kDYFEMTLTexture_timeSinceTouched";
          break;
        case 29:
          result = "kDYFEMTLHeap_timeSinceTouched";
          break;
        case 30:
          result = "kDYFEMTLBuffer_timeSinceTouched";
          break;
        case 31:
          result = "kDYFEMTLIndirectCommandBuffer_timeSinceTouched";
          break;
        case 32:
          result = "kDYFEMTLHeap_usedSize";
          break;
        case 33:
          result = "kDYFEMTLHeap_currentAllocatedSize";
          break;
        case 34:
          result = "kDYFEMTLSharedEventHandle_dealloc";
          break;
        case 35:
          result = "kDYFEMTLTexture_compressionFeedback";
          break;
        case 36:
          result = "kDYFEMTLTexture_allocationID";
          break;
        case 37:
          result = "kDYFEMTLBuffer_allocationID";
          break;
        case 38:
          result = "kDYFEMTLIndirectCommandBuffer_allocationID";
          break;
        case 39:
          result = "kDYFEMTLTexture_saveSlice_level_zPlane_normalize_blitOption_toPath";
          break;
        case 40:
          result = "kDYFEMTLBuffer_saveContentsToPath";
          break;
        case 41:
          result = "kDYFEMTLRenderPipelineState_resourceIndex";
          break;
        case 42:
          result = "kDYFEMTLTexture_resourceIndex";
          break;
        case 43:
          result = "kDYFEMTLAccelerationStructure_allocationID";
          break;
        case 44:
          result = "kDYFEMTLAccelerationStructure_allocatedSize";
          break;
        case 45:
          result = "kDYFEMTLAccelerationStructure_resourceUsage";
          break;
        case 46:
          result = "kDYFEMTLAccelerationStructure_restoreMTLAccelerationStructure";
          break;
        case 47:
          result = "kDYFEMTLVisibleFunctionTable_uniqueIdentifier";
          break;
        case 48:
          result = "kDYFEMTLRenderPipelineState_allocatedSize";
          break;
        case 49:
          result = "kDYFEMTLComputePipelineState_allocatedSize";
          break;
        case 50:
          result = "kDYFEMTLAccelerationStructure_restoreMTLAccelerationStructure_instance";
          break;
        case 51:
          result = "kDYFEMTLDynamicLibrary_installName";
          break;
        case 52:
          result = "kDYFEMTLLibrary_libraryIdentifier";
          break;
        case 53:
          result = "kDYFEMTLBuffer_heapOffset";
          break;
        case 54:
          result = "kDYFEMTLBuffer_parentGPUAddress_parentGPUSize";
          break;
        case 55:
          result = "kDYFEMTLTexture_heapOffset";
          break;
        case 56:
          result = "kDYFEMTLRenderPipelineState_imageblockSampleLength";
          break;
        case 57:
          result = "kDYFEMTLLibrary_type";
          break;
        case 58:
          result = "kDYFEMTLAccelerationStructure_allocationInfo";
          break;
        case 59:
          result = "kDYFEMTLAccelerationStructure_uniqueIdentifier";
          break;
        case 60:
          result = "kDYFEMTLIntersectionFunctionTable_timeSinceTouched";
          break;
        case 61:
          result = "kDYFEMTLIntersectionFunctionTable_allocatedSize";
          break;
        case 62:
          result = "kDYFEMTLVisibleFunctionTable_timeSinceTouched";
          break;
        case 63:
          result = "kDYFEMTLVisibleFunctionTable_allocationID";
          break;
        case 64:
          result = "kDYFEMTLIntersectionFunctionTable_allocationID";
          break;
        case 65:
          result = "kDYFEMTLIntersectionFunctionTable_uniqueIdentifier";
          break;
        case 66:
          result = "kDYFEMTLVisibleFunctionTable_allocatedSize";
          break;
        case 67:
          result = "kDYFEMTLAccelerationStructure_timeSinceTouched";
          break;
        case 68:
          result = "kDYFEMTLRenderPipelineState_timeSinceTouched";
          break;
        case 69:
          result = "kDYFEMTLComputePipelineState_timeSinceTouched";
          break;
        case 70:
          result = "kDYFEMTLAccelerationStructure_resourceIndex";
          break;
        case 71:
          result = "kDYFEMTLAccelerationStructure_heapOffset";
          break;
        case 72:
          return result;
        case 73:
          result = "kDYFEMTLAccelerationStructure_gpuResourceID";
          break;
        case 74:
          result = "kDYFEMTLIndirectCommandBuffer_gpuResourceID";
          break;
        case 75:
          result = "kDYFEMTLRenderPipelineState_gpuResourceID";
          break;
        case 76:
          result = "kDYFEMTLTexture_gpuResourceID";
          break;
        case 77:
          result = "kDYFEMTLSamplerState_gpuResourceID";
          break;
        case 78:
          result = "kDYFEMTLComputePipelineState_gpuResourceID";
          break;
        case 79:
          result = "kDYFEMTLIntersectionFunctionTable_gpuResourceID";
          break;
        case 80:
          result = "kDYFEMTLVisibleFunctionTable_gpuResourceID";
          break;
        case 81:
          result = "kDYFEMTLAccelerationStructure_state";
          break;
        case 82:
          result = "kDYFEMTLAccelerationStructureCommandEncoder_setAccelerationStructureState";
          break;
        case 83:
          result = "kDYFEMTLFunction_setDescriptor_library";
          break;
        case 84:
          result = "kDYFEMTLAccelerationStructure_children";
          break;
        case 85:
          result = "kDYFEMTLAccelerationStructureCommandEncoder_setAccelerationStructureChildren";
          break;
        case 86:
          result = "kDYFEMTLAccelerationStructureCommandEncoder_setAccelerationStructureDescriptor";
          break;
        case 87:
          result = "kDYFEMTLVisibleFunctionTable_gpuAddress";
          break;
        case 88:
          result = "kDYFEMTLIntersectionFunctionTable_setBuffers";
          break;
        case 89:
          result = "kDYFEMTLCaptureManager_sharedCaptureManager";
          break;
        default:
          if ("kDYFEBoundary_Frame" == -12544)
          {
            result = "kDYFEMTLCommandQueue_continueCommandBuffer_retainReferences";
          }
          else
          {
            if ("kDYFEBoundary_Frame" != -12543)
              goto LABEL_1384;
            result = "kDYFEMTLIOCommandQueue_continueCommandBuffer_retainReferences";
          }
          break;
      }
    }
  }
  else if ((int)this <= -18431)
  {
    switch(this)
    {
      case 0xFFFFB000:
        result = "kDYFEMTLFXSpatialScaler_setColorTexture";
        break;
      case 0xFFFFB001:
        result = "kDYFEMTLFXSpatialScaler_setFence";
        break;
      case 0xFFFFB002:
        result = "kDYFEMTLFXSpatialScaler_setInputContentHeight";
        break;
      case 0xFFFFB003:
        result = "kDYFEMTLFXSpatialScaler_setInputContentWidth";
        break;
      case 0xFFFFB004:
        result = "kDYFEMTLFXSpatialScaler_setOutputTexture";
        break;
      case 0xFFFFB005:
        result = "kDYFEMTLFXSpatialScaler_dealloc";
        break;
      case 0xFFFFB006:
        result = "kDYFEMTLFXSpatialScaler_encodeToCommandBuffer";
        break;
      case 0xFFFFB007:
        result = "kDYFEMTLFXTemporalScaler_setColorTexture";
        break;
      case 0xFFFFB008:
        result = "kDYFEMTLFXTemporalScaler_setDepthReversed";
        break;
      case 0xFFFFB009:
        result = "kDYFEMTLFXTemporalScaler_setDepthTexture";
        break;
      case 0xFFFFB00A:
        result = "kDYFEMTLFXTemporalScaler_setExposureTexture";
        break;
      case 0xFFFFB00B:
        result = "kDYFEMTLFXTemporalScaler_setFence";
        break;
      case 0xFFFFB00C:
        result = "kDYFEMTLFXTemporalScaler_setInputContentHeight";
        break;
      case 0xFFFFB00D:
        result = "kDYFEMTLFXTemporalScaler_setInputContentWidth";
        break;
      case 0xFFFFB00E:
        result = "kDYFEMTLFXTemporalScaler_setJitterOffsetX";
        break;
      case 0xFFFFB00F:
        result = "kDYFEMTLFXTemporalScaler_setJitterOffsetY";
        break;
      case 0xFFFFB010:
        result = "kDYFEMTLFXTemporalScaler_setMotionTexture";
        break;
      case 0xFFFFB011:
        result = "kDYFEMTLFXTemporalScaler_setMotionVectorScaleX";
        break;
      case 0xFFFFB012:
        result = "kDYFEMTLFXTemporalScaler_setMotionVectorScaleY";
        break;
      case 0xFFFFB013:
        result = "kDYFEMTLFXTemporalScaler_setOutputTexture";
        break;
      case 0xFFFFB014:
        result = "kDYFEMTLFXTemporalScaler_setPreExposure";
        break;
      case 0xFFFFB015:
        result = "kDYFEMTLFXTemporalScaler_setReset";
        break;
      case 0xFFFFB016:
        result = "kDYFEMTLFXTemporalScaler_dealloc";
        break;
      case 0xFFFFB017:
        result = "kDYFEMTLFXTemporalScaler_encodeToCommandBuffer";
        break;
      case 0xFFFFB018:
        result = "kDYFEMTLFXTemporalScaler_setReactiveMaskTexture";
        break;
      default:
        if ((_DWORD)this == -18432)
        {
          result = "kDYFEMTLDevice_newSpatialScalerWithDescriptor";
        }
        else
        {
          if ((_DWORD)this != -18431)
            goto LABEL_1384;
          result = "kDYFEMTLDevice_newTemporalScalerWithDescriptor";
        }
        break;
    }
  }
  else
  {
    switch(this)
    {
      case 0xFFFFC000:
        result = "kDYFEMTLBlitCommandEncoder_setLabel";
        break;
      case 0xFFFFC001:
        result = "kDYFEMTLBlitCommandEncoder_dealloc";
        break;
      case 0xFFFFC002:
        result = "kDYFEMTLBlitCommandEncoder_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_de"
                 "stinationSlice_destinationLevel_destinationOrigin";
        break;
      case 0xFFFFC003:
        result = "kDYFEMTLBlitCommandEncoder_copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize"
                 "_toTexture_destinationSlice_destinationLevel_destinationOrigin";
        break;
      case 0xFFFFC004:
        result = "kDYFEMTLBlitCommandEncoder_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_des"
                 "tinationOffset_destinationBytesPerRow_destinationBytesPerImage";
        break;
      case 0xFFFFC005:
        result = "kDYFEMTLBlitCommandEncoder_generateMipmapsForTexture";
        break;
      case 0xFFFFC006:
        result = "kDYFEMTLBlitCommandEncoder_fillBuffer_range_value";
        break;
      case 0xFFFFC007:
        result = "kDYFEMTLBlitCommandEncoder_copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size";
        break;
      case 0xFFFFC008:
        result = "kDYFEMTLBlitCommandEncoder_endEncoding";
        break;
      case 0xFFFFC009:
        result = "kDYFEMTLBlitCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC00A:
        result = "kDYFEMTLBlitCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC00B:
        result = "kDYFEMTLBlitCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC00C:
        result = "kDYFEMTLBuffer_setLabel";
        break;
      case 0xFFFFC00D:
        result = "kDYFEMTLBuffer_setResponsibleProcess";
        break;
      case 0xFFFFC00E:
        result = "kDYFEMTLBuffer_dealloc";
        break;
      case 0xFFFFC00F:
        result = "kDYFEMTLBuffer_contents";
        break;
      case 0xFFFFC010:
        result = "kDYFEMTLBuffer_newTextureWithDescriptor_offset_bytesPerRow";
        break;
      case 0xFFFFC011:
        result = "kDYFEMTLBuffer_setPurgeableState";
        break;
      case 0xFFFFC012:
        result = "kDYFEMTLBuffer_isPurgeable";
        break;
      case 0xFFFFC013:
        result = "kDYFEMTLCommandBuffer_setLabel";
        break;
      case 0xFFFFC014:
        result = "kDYFEMTLCommandBuffer_setProfilingEnabled";
        break;
      case 0xFFFFC015:
        result = "kDYFEMTLCommandBuffer_dealloc";
        break;
      case 0xFFFFC016:
        result = "kDYFEMTLCommandBuffer_enqueue";
        break;
      case 0xFFFFC017:
        result = "kDYFEMTLCommandBuffer_commit";
        break;
      case 0xFFFFC018:
        result = "kDYFEMTLCommandBuffer_addScheduledHandler";
        break;
      case 0xFFFFC019:
        result = "kDYFEMTLCommandBuffer_presentDrawable";
        break;
      case 0xFFFFC01A:
        result = "kDYFEMTLCommandBuffer_presentDrawable_atTime";
        break;
      case 0xFFFFC01B:
        result = "kDYFEMTLCommandBuffer_waitUntilScheduled";
        break;
      case 0xFFFFC01C:
        result = "kDYFEMTLCommandBuffer_addCompletedHandler";
        break;
      case 0xFFFFC01D:
        result = "kDYFEMTLCommandBuffer_waitUntilCompleted";
        break;
      case 0xFFFFC01E:
        result = "kDYFEMTLCommandBuffer_blitCommandEncoder";
        break;
      case 0xFFFFC01F:
        result = "kDYFEMTLCommandBuffer_renderCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC020:
        result = "kDYFEMTLCommandBuffer_computeCommandEncoder";
        break;
      case 0xFFFFC021:
        result = "kDYFEMTLCommandBuffer_parallelRenderCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC022:
        result = "kDYFEMTLCommandBuffer_debugCommandEncoder";
        break;
      case 0xFFFFC023:
        result = "kDYFEMTLCommandQueue_setLabel";
        break;
      case 0xFFFFC024:
        result = "kDYFEMTLCommandQueue_setBackgroundTrackingPID";
        break;
      case 0xFFFFC025:
        result = "kDYFEMTLCommandQueue_setSkipRender";
        break;
      case 0xFFFFC026:
        result = "kDYFEMTLCommandQueue_setExecutionEnabled";
        break;
      case 0xFFFFC027:
        result = "kDYFEMTLCommandQueue_setProfilingEnabled";
        break;
      case 0xFFFFC028:
        result = "kDYFEMTLCommandQueue_dealloc";
        break;
      case 0xFFFFC029:
        result = "kDYFEMTLCommandQueue_commandBuffer";
        break;
      case 0xFFFFC02A:
        result = "kDYFEMTLCommandQueue_commandBufferWithUnretainedReferences";
        break;
      case 0xFFFFC02B:
        result = "kDYFEMTLCommandQueue_insertDebugCaptureBoundary";
        break;
      case 0xFFFFC02C:
        result = "kDYFEMTLCommandQueue_finish";
        break;
      case 0xFFFFC02D:
        result = "kDYFEMTLComputeCommandEncoder_setLabel";
        break;
      case 0xFFFFC02E:
        result = "kDYFEMTLComputeCommandEncoder_dealloc";
        break;
      case 0xFFFFC02F:
        result = "kDYFEMTLComputeCommandEncoder_setComputePipelineState";
        break;
      case 0xFFFFC030:
        result = "kDYFEMTLComputeCommandEncoder_setBuffer_offset_atIndex";
        break;
      case 0xFFFFC031:
        result = "kDYFEMTLComputeCommandEncoder_setBuffers_offsets_withRange";
        break;
      case 0xFFFFC032:
        result = "kDYFEMTLComputeCommandEncoder_setTexture_atIndex";
        break;
      case 0xFFFFC033:
        result = "kDYFEMTLComputeCommandEncoder_setTextures_withRange";
        break;
      case 0xFFFFC034:
        result = "kDYFEMTLComputeCommandEncoder_setSamplerState_atIndex";
        break;
      case 0xFFFFC035:
        result = "kDYFEMTLComputeCommandEncoder_setSamplerStates_withRange";
        break;
      case 0xFFFFC036:
        result = "kDYFEMTLComputeCommandEncoder_setSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC037:
        result = "kDYFEMTLComputeCommandEncoder_setSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC038:
        result = "kDYFEMTLComputeCommandEncoder_setThreadgroupMemoryLength_atIndex";
        break;
      case 0xFFFFC039:
        result = "kDYFEMTLComputeCommandEncoder_dispatchThreadgroups_threadsPerThreadgroup";
        break;
      case 0xFFFFC03A:
        result = "kDYFEMTLComputeCommandEncoder_executeBarrier";
        break;
      case 0xFFFFC03B:
        result = "kDYFEMTLComputeCommandEncoder_endEncoding";
        break;
      case 0xFFFFC03C:
        result = "kDYFEMTLComputeCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC03D:
        result = "kDYFEMTLComputeCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC03E:
        result = "kDYFEMTLComputeCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC03F:
        result = "kDYFEMTLComputePipelineState_dealloc";
        break;
      case 0xFFFFC040:
        result = "kDYFEMTLDepthStencilState_dealloc";
        break;
      case 0xFFFFC041:
        result = "kDYFEMTLDevice_setShaderDebugInfoCaching";
        break;
      case 0xFFFFC042:
        result = "kDYFEMTLDevice_setMetalAssertionsEnabled";
        break;
      case 0xFFFFC043:
        result = "kDYFEMTLDevice_dealloc";
        break;
      case 0xFFFFC044:
        result = "kDYFEMTLDevice_newCommandQueue";
        break;
      case 0xFFFFC045:
        result = "kDYFEMTLDevice_newCommandQueueWithMaxCommandBufferCount";
        break;
      case 0xFFFFC046:
        result = "kDYFEMTLDevice_newBufferWithLength_options";
        break;
      case 0xFFFFC047:
        result = "kDYFEMTLDevice_newBufferWithBytes_length_options";
        break;
      case 0xFFFFC048:
        result = "kDYFEMTLDevice_newBufferWithBytesNoCopy_length_options_deallocator";
        break;
      case 0xFFFFC049:
        result = "kDYFEMTLDevice_newDepthStencilStateWithDescriptor";
        break;
      case 0xFFFFC04A:
        result = "kDYFEMTLDevice_newTextureWithDescriptor";
        break;
      case 0xFFFFC04B:
        result = "kDYFEMTLDevice_newSamplerStateWithDescriptor";
        break;
      case 0xFFFFC04C:
        result = "kDYFEMTLDevice_newDefaultLibrary";
        break;
      case 0xFFFFC04D:
        result = "kDYFEMTLDevice_newLibraryWithFile_error";
        break;
      case 0xFFFFC04E:
        result = "kDYFEMTLDevice_newLibraryWithData_error";
        break;
      case 0xFFFFC04F:
        result = "kDYFEMTLDevice_newLibraryWithSource_options_error";
        break;
      case 0xFFFFC050:
        result = "kDYFEMTLDevice_newLibraryWithSource_options_completionHandler";
        break;
      case 0xFFFFC051:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithDescriptor_error";
        break;
      case 0xFFFFC052:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithDescriptor_options_reflection_error";
        break;
      case 0xFFFFC053:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithDescriptor_completionHandler";
        break;
      case 0xFFFFC054:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithDescriptor_options_completionHandler";
        break;
      case 0xFFFFC055:
        result = "kDYFEMTLDevice_newComputePipelineStateWithFunction_error";
        break;
      case 0xFFFFC056:
        result = "kDYFEMTLDevice_newComputePipelineStateWithFunction_options_reflection_error";
        break;
      case 0xFFFFC057:
        result = "kDYFEMTLDevice_newComputePipelineStateWithFunction_completionHandler";
        break;
      case 0xFFFFC058:
        result = "kDYFEMTLDevice_newComputePipelineStateWithFunction_options_completionHandler";
        break;
      case 0xFFFFC059:
        result = "kDYFEMTLDevice_unmapShaderSampleBuffer";
        break;
      case 0xFFFFC05A:
        result = "kDYFEMTLDevice_newTextureWithDescriptor_iosurface_plane";
        break;
      case 0xFFFFC05B:
        result = "kDYFEMTLFunction_dealloc";
        break;
      case 0xFFFFC05C:
        result = "kDYFEMTLLibrary_setLabel";
        break;
      case 0xFFFFC05D:
        result = "kDYFEMTLLibrary_dealloc";
        break;
      case 0xFFFFC05E:
        result = "kDYFEMTLLibrary_newFunctionWithName";
        break;
      case 0xFFFFC05F:
        result = "kDYFEMTLParallelRenderCommandEncoder_setSeparateCommits";
        break;
      case 0xFFFFC060:
        result = "kDYFEMTLParallelRenderCommandEncoder_setLabel";
        break;
      case 0xFFFFC061:
        result = "kDYFEMTLParallelRenderCommandEncoder_dealloc";
        break;
      case 0xFFFFC062:
        result = "kDYFEMTLParallelRenderCommandEncoder_renderCommandEncoder";
        break;
      case 0xFFFFC063:
        result = "kDYFEMTLParallelRenderCommandEncoder_endEncoding";
        break;
      case 0xFFFFC064:
        result = "kDYFEMTLParallelRenderCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC065:
        result = "kDYFEMTLParallelRenderCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC066:
        result = "kDYFEMTLParallelRenderCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC067:
        result = "kDYFEMTLRenderCommandEncoder_setLabel";
        break;
      case 0xFFFFC068:
        result = "kDYFEMTLRenderCommandEncoder_dealloc";
        break;
      case 0xFFFFC069:
        result = "kDYFEMTLRenderCommandEncoder_setRenderPipelineState";
        break;
      case 0xFFFFC06A:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBuffer_offset_atIndex";
        break;
      case 0xFFFFC06B:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBuffers_offsets_withRange";
        break;
      case 0xFFFFC06C:
        result = "kDYFEMTLRenderCommandEncoder_setVertexTexture_atIndex";
        break;
      case 0xFFFFC06D:
        result = "kDYFEMTLRenderCommandEncoder_setVertexTextures_withRange";
        break;
      case 0xFFFFC06E:
        result = "kDYFEMTLRenderCommandEncoder_setVertexSamplerState_atIndex";
        break;
      case 0xFFFFC06F:
        result = "kDYFEMTLRenderCommandEncoder_setVertexSamplerStates_withRange";
        break;
      case 0xFFFFC070:
        result = "kDYFEMTLRenderCommandEncoder_setVertexSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC071:
        result = "kDYFEMTLRenderCommandEncoder_setVertexSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC072:
        result = "kDYFEMTLRenderCommandEncoder_setViewport";
        break;
      case 0xFFFFC073:
        result = "kDYFEMTLRenderCommandEncoder_setFrontFacingWinding";
        break;
      case 0xFFFFC074:
        result = "kDYFEMTLRenderCommandEncoder_setCullMode";
        break;
      case 0xFFFFC075:
        result = "kDYFEMTLRenderCommandEncoder_setDepthClipMode";
        break;
      case 0xFFFFC076:
        result = "kDYFEMTLRenderCommandEncoder_setDepthBias_slopeScale_clamp";
        break;
      case 0xFFFFC077:
        result = "kDYFEMTLRenderCommandEncoder_setScissorRect";
        break;
      case 0xFFFFC078:
        result = "kDYFEMTLRenderCommandEncoder_setTriangleFillMode";
        break;
      case 0xFFFFC079:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentBuffer_offset_atIndex";
        break;
      case 0xFFFFC07A:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentBuffers_offsets_withRange";
        break;
      case 0xFFFFC07B:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentTexture_atIndex";
        break;
      case 0xFFFFC07C:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentTextures_withRange";
        break;
      case 0xFFFFC07D:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentSamplerState_atIndex";
        break;
      case 0xFFFFC07E:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentSamplerStates_withRange";
        break;
      case 0xFFFFC07F:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC080:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC081:
        result = "kDYFEMTLRenderCommandEncoder_setBlendColorRed_green_blue_alpha";
        break;
      case 0xFFFFC082:
        result = "kDYFEMTLRenderCommandEncoder_setDepthStencilState";
        break;
      case 0xFFFFC083:
        result = "kDYFEMTLRenderCommandEncoder_setStencilReferenceValue";
        break;
      case 0xFFFFC084:
        result = "kDYFEMTLRenderCommandEncoder_setVisibilityResultMode_offset";
        break;
      case 0xFFFFC085:
        result = "kDYFEMTLRenderCommandEncoder_drawPrimitives_vertexStart_vertexCount_instanceCount";
        break;
      case 0xFFFFC086:
        result = "kDYFEMTLRenderCommandEncoder_drawPrimitives_vertexStart_vertexCount";
        break;
      case 0xFFFFC087:
        result = "kDYFEMTLRenderCommandEncoder_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount";
        break;
      case 0xFFFFC088:
        result = "kDYFEMTLRenderCommandEncoder_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset";
        break;
      case 0xFFFFC089:
        result = "kDYFEMTLRenderCommandEncoder_setLineWidth";
        break;
      case 0xFFFFC08A:
        result = "kDYFEMTLRenderCommandEncoder_endEncoding";
        break;
      case 0xFFFFC08B:
        result = "kDYFEMTLRenderCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC08C:
        result = "kDYFEMTLRenderCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC08D:
        result = "kDYFEMTLRenderCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC08E:
        result = "kDYFEMTLRenderPipelineState_dealloc";
        break;
      case 0xFFFFC08F:
        result = "kDYFEMTLSamplerState_dealloc";
        break;
      case 0xFFFFC090:
        result = "kDYFEMTLTexture_setLabel";
        break;
      case 0xFFFFC091:
        result = "kDYFEMTLTexture_setResponsibleProcess";
        break;
      case 0xFFFFC092:
        result = "kDYFEMTLTexture_dealloc";
        break;
      case 0xFFFFC093:
        result = "kDYFEMTLTexture_getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice";
        break;
      case 0xFFFFC094:
        result = "kDYFEMTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage";
        break;
      case 0xFFFFC095:
        result = "kDYFEMTLTexture_getBytes_bytesPerRow_fromRegion_mipmapLevel";
        break;
      case 0xFFFFC096:
        result = "kDYFEMTLTexture_replaceRegion_mipmapLevel_withBytes_bytesPerRow";
        break;
      case 0xFFFFC097:
        result = "kDYFEMTLTexture_newTextureViewWithPixelFormat";
        break;
      case 0xFFFFC098:
        result = "kDYFEMTLTexture_setPurgeableState";
        break;
      case 0xFFFFC099:
        result = "kDYFEMTLTexture_isPurgeable";
        break;
      case 0xFFFFC09A:
        result = "kDYFEMTLBlitCommandEncoder_flushResource";
        break;
      case 0xFFFFC09B:
        result = "kDYFEMTLBlitCommandEncoder_flushTexture_slice_mipmapLevel";
        break;
      case 0xFFFFC09C:
        result = "kDYFEMTLBuffer_invalidateRange";
        break;
      case 0xFFFFC09D:
        result = "kDYFEMTLComputeCommandEncoder_setBytes_length_atIndex";
        break;
      case 0xFFFFC09E:
        result = "kDYFEMTLComputeCommandEncoder_setBufferOffset_atIndex";
        break;
      case 0xFFFFC09F:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBytes_length_atIndex";
        break;
      case 0xFFFFC0A0:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBufferOffset_atIndex";
        break;
      case 0xFFFFC0A1:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentBytes_length_atIndex";
        break;
      case 0xFFFFC0A2:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentBufferOffset_atIndex";
        break;
      case 0xFFFFC0A3:
        result = "kDYFEMTLTexture_invalidateRegion";
        break;
      case 0xFFFFC0A4:
        result = "kDYFEMTLComputeCommandEncoder_dispatchThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerThreadgroup";
        break;
      case 0xFFFFC0A5:
        result = "kDYFEMTLRenderCommandEncoder_setStencilFrontReferenceValue_backReferenceValue";
        break;
      case 0xFFFFC0A6:
        result = "kDYFEMTLRenderCommandEncoder_drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance";
        break;
      case 0xFFFFC0A7:
        result = "kDYFEMTLRenderCommandEncoder_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_i"
                 "nstanceCount_baseVertex_baseInstance";
        break;
      case 0xFFFFC0A8:
        result = "kDYFEMTLRenderCommandEncoder_drawPrimitives_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC0A9:
        result = "kDYFEMTLRenderCommandEncoder_drawIndexedPrimitives_indexType_indexBuffer_indexBufferOffset_indirectBuff"
                 "er_indirectBufferOffset";
        break;
      case 0xFFFFC0AA:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentTexture_atTextureIndex_samplerState_atSamplerIndex";
        break;
      case 0xFFFFC0AB:
        result = "kDYFEMTLBlitCommandEncoder_synchronizeResource";
        break;
      case 0xFFFFC0AC:
        result = "kDYFEMTLBlitCommandEncoder_synchronizeTexture_slice_level";
        break;
      case 0xFFFFC0AD:
        result = "kDYFEMTLBlitCommandEncoder_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_de"
                 "stinationSlice_destinationLevel_destinationOrigin_options";
        break;
      case 0xFFFFC0AE:
        result = "kDYFEMTLBlitCommandEncoder_copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize"
                 "_toTexture_destinationSlice_destinationLevel_destinationOrigin_options";
        break;
      case 0xFFFFC0AF:
        result = "kDYFEMTLBlitCommandEncoder_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_des"
                 "tinationOffset_destinationBytesPerRow_destinationBytesPerImage_options";
        break;
      case 0xFFFFC0B0:
        result = "kDYFEMTLBuffer_didModifyRange";
        break;
      case 0xFFFFC0B1:
        result = "kDYFEMTLComputeCommandEncoder_setTexture_baseLevel_atIndex";
        break;
      case 0xFFFFC0B2:
        result = "kDYFEMTLDevice_supportsFeatureSet";
        break;
      case 0xFFFFC0B3:
        result = "kDYFEMTLDevice_supportsSampleCount";
        break;
      case 0xFFFFC0B4:
        result = "kDYFEMTLRenderCommandEncoder_setVertexTexture_baseLevel_atIndex";
        break;
      case 0xFFFFC0B5:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentTexture_baseLevel_atIndex";
        break;
      case 0xFFFFC0B6:
        result = "kDYFEMTLCommandBuffer_commitAndHold";
        break;
      case 0xFFFFC0B7:
        result = "kDYFEMTLRenderCommandEncoder_textureBarrier";
        break;
      case 0xFFFFC0B8:
        result = "kDYFEMTLDevice_newComputePipelineStateWithDescriptor_error";
        break;
      case 0xFFFFC0B9:
        result = "kDYFEMTLDevice_newComputePipelineStateWithDescriptor_options_reflection_error";
        break;
      case 0xFFFFC0BA:
        result = "kDYFEMTLDevice_newComputePipelineStateWithDescriptor_completionHandler";
        break;
      case 0xFFFFC0BB:
        result = "kDYFEMTLDevice_newComputePipelineStateWithDescriptor_options_completionHandler";
        break;
      case 0xFFFFC0BC:
        result = "kDYFEMTLTexture_newTextureViewWithPixelFormat_textureType_levels_slices";
        break;
      case 0xFFFFC0BD:
        result = "kDYFEMTLCommandBuffer_fragmentRenderCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC0BE:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setLabel";
        break;
      case 0xFFFFC0BF:
        result = "kDYFEMTLFragmentRenderCommandEncoder_dealloc";
        break;
      case 0xFFFFC0C0:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setRenderPipelineState";
        break;
      case 0xFFFFC0C1:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setDepthBias_slopeScale_clamp";
        break;
      case 0xFFFFC0C2:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setScissorRect";
        break;
      case 0xFFFFC0C3:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentBytes_length_atIndex";
        break;
      case 0xFFFFC0C4:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentBuffer_offset_atIndex";
        break;
      case 0xFFFFC0C5:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentBufferOffset_atIndex";
        break;
      case 0xFFFFC0C6:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentBuffers_offsets_withRange";
        break;
      case 0xFFFFC0C7:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentTexture_atIndex";
        break;
      case 0xFFFFC0C8:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentTextures_withRange";
        break;
      case 0xFFFFC0C9:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentTexture_baseLevel_atIndex";
        break;
      case 0xFFFFC0CA:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentTexture_atTextureIndex_samplerState_atSamplerIndex";
        break;
      case 0xFFFFC0CB:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentSamplerState_atIndex";
        break;
      case 0xFFFFC0CC:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentSamplerStates_withRange";
        break;
      case 0xFFFFC0CD:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC0CE:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setFragmentSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC0CF:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setBlendColorRed_green_blue_alpha";
        break;
      case 0xFFFFC0D0:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setDepthStencilState";
        break;
      case 0xFFFFC0D1:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setStencilReferenceValue";
        break;
      case 0xFFFFC0D2:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setStencilFrontReferenceValue_backReferenceValue";
        break;
      case 0xFFFFC0D3:
        result = "kDYFEMTLFragmentRenderCommandEncoder_drawTrianglesWithPositions_vertexCount_triangleIndices_triangleCount";
        break;
      case 0xFFFFC0D4:
        result = "kDYFEMTLFragmentRenderCommandEncoder_drawTrianglesWithPositions_vertexCount_vertexVaryings_varyingCount"
                 "PerVertex_triangleIndices_triangleCount";
        break;
      case 0xFFFFC0D5:
        result = "kDYFEMTLFragmentRenderCommandEncoder_drawTrianglesWithPositions_vertexCount_vertexVaryings_varyingCountPerVertex";
        break;
      case 0xFFFFC0D6:
        result = "kDYFEMTLFragmentRenderCommandEncoder_endEncoding";
        break;
      case 0xFFFFC0D7:
        result = "kDYFEMTLFragmentRenderCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC0D8:
        result = "kDYFEMTLFragmentRenderCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC0D9:
        result = "kDYFEMTLFragmentRenderCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC0DA:
        result = "kDYFEMTLDevice_supportsTextureSampleCount";
        break;
      case 0xFFFFC0DB:
        result = "kDYFEMTLDevice_newCommandQueueWithDescriptor";
        break;
      case 0xFFFFC0DC:
        result = "kDYFEMTLCommandBuffer_setListIndex";
        break;
      case 0xFFFFC0DD:
        result = "kDYFEMTLDevice_newBufferWithIOSurface";
        break;
      case 0xFFFFC0DE:
        result = "kDYFEMTLParallelRenderCommandEncoder_setColorStoreAction_atIndex";
        break;
      case 0xFFFFC0DF:
        result = "kDYFEMTLParallelRenderCommandEncoder_setDepthStoreAction";
        break;
      case 0xFFFFC0E0:
        result = "kDYFEMTLParallelRenderCommandEncoder_setStencilStoreAction";
        break;
      case 0xFFFFC0E1:
        result = "kDYFEMTLRenderCommandEncoder_setColorStoreAction_atIndex";
        break;
      case 0xFFFFC0E2:
        result = "kDYFEMTLRenderCommandEncoder_setDepthStoreAction";
        break;
      case 0xFFFFC0E3:
        result = "kDYFEMTLRenderCommandEncoder_setStencilStoreAction";
        break;
      case 0xFFFFC0E4:
        result = "kDYFEMTLRenderCommandEncoder_setColorResolveTexture_slice_depthPlane_level_atIndex";
        break;
      case 0xFFFFC0E5:
        result = "kDYFEMTLRenderCommandEncoder_setDepthResolveTexture_slice_depthPlane_level";
        break;
      case 0xFFFFC0E6:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setColorStoreAction_atIndex";
        break;
      case 0xFFFFC0E7:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setDepthStoreAction";
        break;
      case 0xFFFFC0E8:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setStencilStoreAction";
        break;
      case 0xFFFFC0E9:
        result = "kDYFEMTLCommandBuffer_computeCommandEncoderWithParallelExecution";
        break;
      case 0xFFFFC0EA:
        result = "kDYFEMTLComputeCommandEncoder_dispatchBarrier";
        break;
      case 0xFFFFC0EB:
        result = "kDYFEMTLComputeCommandEncoder_setImageblockWidth_height";
        break;
      case 0xFFFFC0EC:
        result = "kDYFEMTLRenderCommandEncoder_setTessellationFactorBuffer_offset_instanceStride";
        break;
      case 0xFFFFC0ED:
        result = "kDYFEMTLRenderCommandEncoder_drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_"
                 "instanceCount_baseInstance";
        break;
      case 0xFFFFC0EE:
        result = "kDYFEMTLRenderCommandEncoder_drawPatches_patchIndexBuffer_patchIndexBufferOffset_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC0EF:
        result = "kDYFEMTLRenderCommandEncoder_drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBuffer"
                 "Offset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance";
        break;
      case 0xFFFFC0F0:
        result = "kDYFEMTLRenderCommandEncoder_drawIndexedPatches_patchIndexBuffer_patchIndexBufferOffset_controlPointInd"
                 "exBuffer_controlPointIndexBufferOffset_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC0F1:
        result = "kDYFEMTLRenderCommandEncoder_setTileBytes_length_atIndex";
        break;
      case 0xFFFFC0F2:
        result = "kDYFEMTLRenderCommandEncoder_setTileBuffer_offset_atIndex";
        break;
      case 0xFFFFC0F3:
        result = "kDYFEMTLRenderCommandEncoder_setTileBufferOffset_atIndex";
        break;
      case 0xFFFFC0F4:
        result = "kDYFEMTLRenderCommandEncoder_setTileTexture_atIndex";
        break;
      case 0xFFFFC0F5:
        result = "kDYFEMTLRenderCommandEncoder_setTileSamplerState_atIndex";
        break;
      case 0xFFFFC0F6:
        result = "kDYFEMTLRenderCommandEncoder_setTileSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC0F7:
        result = "kDYFEMTLRenderCommandEncoder_dispatchThreadsPerTile";
        break;
      case 0xFFFFC0F8:
        result = "kDYFEMTLFence_setLabel";
        break;
      case 0xFFFFC0F9:
        result = "kDYFEMTLFunction_functionConstantIndexByName_type";
        break;
      case 0xFFFFC0FA:
        result = "kDYFEMTLCommandQueue_setIsOpenGLQueue";
        break;
      case 0xFFFFC0FB:
        result = "kDYFEMTLCommandBuffer_presentDrawable_afterMinimumDuration";
        break;
      case 0xFFFFC0FC:
        result = "kDYFEMTLRenderCommandEncoder_setTessellationFactorScale";
        break;
      case 0xFFFFC0FD:
        result = "kDYFEMTLBlitCommandEncoder_waitForFence";
        break;
      case 0xFFFFC0FE:
        result = "kDYFEMTLComputeCommandEncoder_updateFence";
        break;
      case 0xFFFFC0FF:
        result = "kDYFEMTLComputeCommandEncoder_waitForFence";
        break;
      case 0xFFFFC100:
        result = "kDYFEMTLDevice_newFence";
        break;
      case 0xFFFFC101:
        result = "kDYFEMTLFence_dealloc";
        break;
      case 0xFFFFC102:
        result = "kDYFEMTLRenderCommandEncoder_updateFence_afterStages";
        break;
      case 0xFFFFC103:
        result = "kDYFEMTLRenderCommandEncoder_waitForFence_beforeStages";
        break;
      case 0xFFFFC104:
        result = "kDYFEMTLBlitCommandEncoder_updateFence";
        break;
      case 0xFFFFC105:
        result = "kDYFEMTLFunction_setLabel";
        break;
      case 0xFFFFC106:
        result = "kDYFEMTLBuffer_makeAliasable";
        break;
      case 0xFFFFC107:
        result = "kDYFEMTLDevice_heapTextureSizeWithDescriptor";
        break;
      case 0xFFFFC108:
        result = "kDYFEMTLDevice_newHeapWithDescriptor";
        break;
      case 0xFFFFC109:
        result = "kDYFEMTLHeap_setLabel";
        break;
      case 0xFFFFC10A:
        result = "kDYFEMTLHeap_dealloc";
        break;
      case 0xFFFFC10B:
        result = "kDYFEMTLHeap_newBufferWithLength_options";
        break;
      case 0xFFFFC10C:
        result = "kDYFEMTLHeap_newTextureWithDescriptor";
        break;
      case 0xFFFFC10D:
        result = "kDYFEMTLHeap_setPurgeableState";
        break;
      case 0xFFFFC10E:
        result = "kDYFEMTLTexture_makeAliasable";
        break;
      case 0xFFFFC10F:
        result = "kDYFEMTLBuffer_isAliasable";
        break;
      case 0xFFFFC110:
        result = "kDYFEMTLDevice_heapTextureSizeAndAlignWithDescriptor";
        break;
      case 0xFFFFC111:
        result = "kDYFEMTLDevice_heapBufferSizeAndAlignWithLength_options";
        break;
      case 0xFFFFC112:
        result = "kDYFEMTLHeap_setResponsibleProcess";
        break;
      case 0xFFFFC113:
        result = "kDYFEMTLHeap_isPurgeable";
        break;
      case 0xFFFFC114:
        result = "kDYFEMTLTexture_isAliasable";
        break;
      case 0xFFFFC115:
        result = "kDYFEMTLLibrary_newFunctionWithName_constantValues_error";
        break;
      case 0xFFFFC116:
        result = "kDYFEMTLLibrary_newFunctionWithName_constantValues_completionHandler";
        break;
      case 0xFFFFC117:
        result = "kDYFEMTLHeap_maxAvailableSizeWithAlignment";
        break;
      case 0xFFFFC118:
        result = "kDYFEMTLBuffer_newTiledTextureWithDescriptor_offset_bytesPerRow";
        break;
      case 0xFFFFC119:
        result = "kDYFEMTLBuffer_addDebugMarker_range";
        break;
      case 0xFFFFC11A:
        result = "kDYFEMTLBuffer_removeAllDebugMarkers";
        break;
      case 0xFFFFC11B:
        result = "kDYFEMTLDevice_newComputePipelineStateWithImageFilterFunctionsSPI_imageFilterFunctionInfo_error";
        break;
      case 0xFFFFC11C:
        result = "kDYFEMTLComputeCommandEncoder_setStageInRegion";
        break;
      case 0xFFFFC11D:
        result = "kDYFEMTLDevice_newTextureLayoutWithDescriptor_isHeapOrBufferBacked";
        break;
      case 0xFFFFC11E:
        result = "kDYFEMTLBuffer_newLinearTextureWithDescriptor_offset_bytesPerRow_bytesPerImage";
        break;
      case 0xFFFFC11F:
        result = "kDYFEMTLTextureLayout_dealloc";
        break;
      case 0xFFFFC120:
        result = "kDYFEMTLDevice_newTextureWithBytesNoCopy_length_descriptor_deallocator";
        break;
      case 0xFFFFC121:
        result = "kDYFEMTLDevice_newDefaultLibraryWithBundle_error";
        break;
      case 0xFFFFC122:
        result = "kDYFEMTLTexture_formattedDescription";
        break;
      case 0xFFFFC123:
        result = "kDYFEMTLDevice_minLinearTextureAlignmentForPixelFormat";
        break;
      case 0xFFFFC124:
        result = "kDYFEMTLComputePipelineState_getComputeKernelTelemetryID";
        break;
      case 0xFFFFC125:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithTileDescriptor_error";
        break;
      case 0xFFFFC126:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithTileDescriptor_options_reflection_error";
        break;
      case 0xFFFFC127:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithTileDescriptor_completionHandler";
        break;
      case 0xFFFFC128:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithTileDescriptor_options_completionHandler";
        break;
      case 0xFFFFC129:
        result = "kDYFEMTLRenderCommandEncoder_setTileBuffers_offsets_withRange";
        break;
      case 0xFFFFC12A:
        result = "kDYFEMTLRenderCommandEncoder_setTileTextures_withRange";
        break;
      case 0xFFFFC12B:
        result = "kDYFEMTLRenderCommandEncoder_setTileSamplerStates_withRange";
        break;
      case 0xFFFFC12C:
        result = "kDYFEMTLRenderCommandEncoder_setTileSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC12D:
        result = "kDYFEMTLLibrary_setOverrideTriple";
        break;
      case 0xFFFFC12E:
        result = "kDYFEMTLLibrary_newFunctionWithName_constantValues_pipelineLibrary_error";
        break;
      case 0xFFFFC12F:
        result = "kDYFEMTLLibrary_newFunctionWithName_constantValues_pipelineLibrary_completionHandler";
        break;
      case 0xFFFFC130:
        result = "kDYFEMTLRenderCommandEncoder_setThreadgroupMemoryLength_atIndex";
        break;
      case 0xFFFFC131:
        result = "kDYFEMTLComputeCommandEncoder_dispatchThreadsWithIndirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC132:
        result = "kDYFEMTLComputeCommandEncoder_dispatchThreads_threadsPerThreadgroup";
        break;
      case 0xFFFFC133:
        result = "kDYFEMTLRenderCommandEncoder_setViewports_count";
        break;
      case 0xFFFFC134:
        result = "kDYFEMTLRenderCommandEncoder_setScissorRects_count";
        break;
      case 0xFFFFC135:
        result = "kDYFEMTLDevice_newPipelineLibraryWithFilePath_error";
        break;
      case 0xFFFFC136:
        result = "kDYFEMTLRenderCommandEncoder_setThreadgroupMemoryLength_offset_atIndex";
        break;
      case 0xFFFFC137:
        result = "kDYFEMTLCaptureScope_setLabel";
        break;
      case 0xFFFFC138:
        result = "kDYFEMTLCaptureScope_dealloc";
        break;
      case 0xFFFFC139:
        result = "kDYFEMTLCaptureScope_beginScope";
        break;
      case 0xFFFFC13A:
        result = "kDYFEMTLCaptureScope_endScope";
        break;
      case 0xFFFFC13B:
        result = "kDYFEMTLCaptureManager_startCaptureWithDevice";
        break;
      case 0xFFFFC13C:
        result = "kDYFEMTLCaptureManager_startCaptureWithCommandQueue";
        break;
      case 0xFFFFC13D:
        result = "kDYFEMTLCaptureManager_stopCapture";
        break;
      case 0xFFFFC13E:
        result = "kDYFEMTLDevice_startCollectingPipelineDescriptors";
        break;
      case 0xFFFFC13F:
        result = "kDYFEMTLCommandBuffer_pushDebugGroup";
        break;
      case 0xFFFFC140:
        result = "kDYFEMTLCommandBuffer_popDebugGroup";
        break;
      case 0xFFFFC141:
        result = "kDYFEMTLArgumentEncoder_setLabel";
        break;
      case 0xFFFFC142:
        result = "kDYFEMTLArgumentEncoder_dealloc";
        break;
      case 0xFFFFC143:
        result = "kDYFEMTLArgumentEncoder_setArgumentBuffer_offset";
        break;
      case 0xFFFFC144:
        result = "kDYFEMTLArgumentEncoder_setBuffer_offset_atIndex";
        break;
      case 0xFFFFC145:
        result = "kDYFEMTLArgumentEncoder_setBuffers_offsets_withRange";
        break;
      case 0xFFFFC146:
        result = "kDYFEMTLArgumentEncoder_setTexture_atIndex";
        break;
      case 0xFFFFC147:
        result = "kDYFEMTLArgumentEncoder_setTextures_withRange";
        break;
      case 0xFFFFC148:
        result = "kDYFEMTLArgumentEncoder_setSamplerState_atIndex";
        break;
      case 0xFFFFC149:
        result = "kDYFEMTLArgumentEncoder_setSamplerStates_withRange";
        break;
      case 0xFFFFC14A:
        result = "kDYFEMTLArgumentEncoder_constantDataAtIndex";
        break;
      case 0xFFFFC14B:
        result = "kDYFEMTLArgumentEncoder_newArgumentEncoderForBufferAtIndex";
        break;
      case 0xFFFFC14C:
        result = "kDYFEMTLFunction_newArgumentEncoderWithBufferIndex";
        break;
      case 0xFFFFC14D:
        result = "kDYFEMTLFunction_newArgumentEncoderWithBufferIndex_reflection";
        break;
      case 0xFFFFC14E:
        result = "kDYFEMTLDevice_newArgumentEncoderWithArguments_count";
        break;
      case 0xFFFFC14F:
        result = "kDYFEMTLDevice_newArgumentBufferLayoutWithStructType";
        break;
      case 0xFFFFC150:
        result = "kDYFEMTLDevice_newArgumentEncoderWithLayout";
        break;
      case 0xFFFFC151:
        result = "kDYFEMTLComputeCommandEncoder_useResource_usage";
        break;
      case 0xFFFFC152:
        result = "kDYFEMTLComputeCommandEncoder_useResources_count_usage";
        break;
      case 0xFFFFC153:
        result = "kDYFEMTLComputeCommandEncoder_useHeap";
        break;
      case 0xFFFFC154:
        result = "kDYFEMTLComputeCommandEncoder_useHeaps_count";
        break;
      case 0xFFFFC155:
        result = "kDYFEMTLRenderCommandEncoder_useResource_usage";
        break;
      case 0xFFFFC156:
        result = "kDYFEMTLRenderCommandEncoder_useResources_count_usage";
        break;
      case 0xFFFFC157:
        result = "kDYFEMTLRenderCommandEncoder_useHeap";
        break;
      case 0xFFFFC158:
        result = "kDYFEMTLRenderCommandEncoder_useHeaps_count";
        break;
      case 0xFFFFC159:
        result = "kDYFEMTLDevice_newLibraryWithURL_error";
        break;
      case 0xFFFFC15A:
        result = "kDYFEMTLLibrary_newExternFunctionWithName";
        break;
      case 0xFFFFC15B:
        result = "kDYFEMTLDevice_newArgumentEncoderWithArguments";
        break;
      case 0xFFFFC15C:
        result = "kDYFEMTLDevice_indirectArgumentBufferDecodingData";
        break;
      case 0xFFFFC15D:
        result = "kDYFEMTLDevice_setIndirectArgumentBufferDecodingData";
        break;
      case 0xFFFFC15E:
        result = "kDYFEMTLCaptureManager_notifySubmissionForEyeSPI_iosurface_bounds_submitFlags";
        break;
      case 0xFFFFC15F:
        result = "kDYFEMTLArgumentEncoder_setArgumentBuffer_startOffset_arrayElement";
        break;
      case 0xFFFFC160:
        result = "kDYFEMTLTextureLayout_initializeTextureMemory";
        break;
      case 0xFFFFC161:
        result = "kDYFEMTLDevice_newTiledTextureWithBytesNoCopy_length_descriptor_offset_bytesPerRow";
        break;
      case 0xFFFFC162:
        result = "kDYFEMTLDevice_newTiledTextureWithBytesNoCopy_length_deallocator_descriptor_offset_bytesPerRow";
        break;
      case 0xFFFFC163:
        result = "kDYFEMTLDevice_newLibraryWithCIFilters_imageFilterFunctionInfo_error";
        break;
      case 0xFFFFC164:
        result = "kDYFEMTLParallelRenderCommandEncoder_setColorStoreActionOptions_atIndex";
        break;
      case 0xFFFFC165:
        result = "kDYFEMTLParallelRenderCommandEncoder_setDepthStoreActionOptions";
        break;
      case 0xFFFFC166:
        result = "kDYFEMTLParallelRenderCommandEncoder_setStencilStoreActionOptions";
        break;
      case 0xFFFFC167:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setColorStoreActionOptions_atIndex";
        break;
      case 0xFFFFC168:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setDepthStoreActionOptions";
        break;
      case 0xFFFFC169:
        result = "kDYFEMTLFragmentRenderCommandEncoder_setStencilStoreActionOptions";
        break;
      case 0xFFFFC16A:
        result = "kDYFEMTLRenderCommandEncoder_setColorStoreActionOptions_atIndex";
        break;
      case 0xFFFFC16B:
        result = "kDYFEMTLRenderCommandEncoder_setDepthStoreActionOptions";
        break;
      case 0xFFFFC16C:
        result = "kDYFEMTLRenderCommandEncoder_setStencilStoreActionOptions";
        break;
      case 0xFFFFC16D:
        result = "kDYFEMTLCaptureManager_notifyPostPresentHandoffSPI";
        break;
      case 0xFFFFC16E:
        result = "kDYFEMTLDevice_newLibraryWithCIFiltersForComputePipeline_imageFilterFunctionInfo_error";
        break;
      case 0xFFFFC16F:
        result = "kDYFEMTLComputeCommandEncoder_setStageInRegionWithIndirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC170:
        result = "kDYFEMTLDevice_newIndirectRenderCommandEncoderWithBuffer";
        break;
      case 0xFFFFC171:
        result = "kDYFEMTLDevice_newIndirectComputeCommandEncoderWithBuffer";
        break;
      case 0xFFFFC172:
        result = "kDYFEMTLCommandBuffer_computeCommandEncoderWithDispatchType";
        break;
      case 0xFFFFC173:
        result = "kDYFEMTLCommandBuffer_videoCommandEncoder";
        break;
      case 0xFFFFC174:
        result = "kDYFEMTLCommandBuffer_doCorruptCBSPI";
        break;
      case 0xFFFFC175:
        result = "kDYFEMTLComputeCommandEncoder_useComputePipelineState";
        break;
      case 0xFFFFC176:
        result = "kDYFEMTLComputeCommandEncoder_useComputePipelineStates_count";
        break;
      case 0xFFFFC177:
        result = "kDYFEMTLComputeCommandEncoder_memoryBarrierWithScope";
        break;
      case 0xFFFFC178:
        result = "kDYFEMTLComputeCommandEncoder_memoryBarrierWithResources_count";
        break;
      case 0xFFFFC179:
        result = "kDYFEMTLRenderCommandEncoder_useRenderPipelineState";
        break;
      case 0xFFFFC17A:
        result = "kDYFEMTLRenderCommandEncoder_useRenderPipelineStates_count";
        break;
      case 0xFFFFC17B:
        result = "kDYFEMTLRenderCommandEncoder_executeCommandsInBuffer_startIndex";
        break;
      case 0xFFFFC17C:
        result = "kDYFEMTLRenderCommandEncoder_memoryBarrierWithScope_afterStages_beforeStages";
        break;
      case 0xFFFFC17D:
        result = "kDYFEMTLRenderCommandEncoder_memoryBarrierWithResources_count_afterStages_beforeStages";
        break;
      case 0xFFFFC17E:
        result = "kDYFEMTLArgumentEncoder_setRenderPipelineState_atIndex";
        break;
      case 0xFFFFC17F:
        result = "kDYFEMTLArgumentEncoder_setRenderPipelineStates_withRange";
        break;
      case 0xFFFFC180:
        result = "kDYFEMTLArgumentEncoder_setComputePipelineState_atIndex";
        break;
      case 0xFFFFC181:
        result = "kDYFEMTLArgumentEncoder_setComputePipelineStates_withRange";
        break;
      case 0xFFFFC182:
        result = "kDYFEMTLDevice_minimumTextureBufferAlignmentForPixelFormat";
        break;
      case 0xFFFFC183:
        result = "kDYFEMTLDevice_newEvent";
        break;
      case 0xFFFFC184:
        result = "kDYFEMTLDevice_newSharedEvent";
        break;
      case 0xFFFFC185:
        result = "kDYFEMTLBlitCommandEncoder_optimizeContentsForGPUAccess";
        break;
      case 0xFFFFC186:
        result = "kDYFEMTLBlitCommandEncoder_optimizeContentsForGPUAccess_slice_level";
        break;
      case 0xFFFFC187:
        result = "kDYFEMTLBlitCommandEncoder_optimizeContentsForCPUAccess";
        break;
      case 0xFFFFC188:
        result = "kDYFEMTLBlitCommandEncoder_optimizeContentsForCPUAccess_slice_level";
        break;
      case 0xFFFFC189:
        result = "kDYFEMTLCommandBuffer_encodeWaitForEvent_value";
        break;
      case 0xFFFFC18A:
        result = "kDYFEMTLCommandBuffer_encodeSignalEvent_value";
        break;
      case 0xFFFFC18B:
        result = "kDYFEMTLComputePipelineState_resourceIndex";
        break;
      case 0xFFFFC18C:
        result = "kDYFEMTLRenderCommandEncoder_setPointSize";
        break;
      case 0xFFFFC18D:
        result = "kDYFEMTLRenderCommandEncoder_setClipPlane_p2_p3_p4_atIndex";
        break;
      case 0xFFFFC18E:
        result = "kDYFEMTLRenderCommandEncoder_setVertexSamplerState_lodMinClamp_lodMaxClamp_lodBias_atIndex";
        break;
      case 0xFFFFC18F:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentSamplerState_lodMinClamp_lodMaxClamp_lodBias_atIndex";
        break;
      case 0xFFFFC190:
        result = "kDYFEMTLRenderCommandEncoder_setPrimitiveRestartEnabled_index";
        break;
      case 0xFFFFC191:
        result = "kDYFEMTLSamplerState_resourceIndex";
        break;
      case 0xFFFFC192:
        result = "kDYFEMTLSharedTextureHandle_dealloc";
        break;
      case 0xFFFFC193:
        result = "kDYFEMTLTexture_newSharedHandle";
        break;
      case 0xFFFFC194:
        result = "kDYFEMTLDevice_newSharedTextureWithDescriptor";
        break;
      case 0xFFFFC195:
        result = "kDYFEMTLDevice_newSharedTextureWithHandle";
        break;
      case 0xFFFFC196:
        result = "kDYFEMTLDevice_tileSizeWithTextureType_pixelFormat_sampleCount";
        break;
      case 0xFFFFC197:
        result = "kDYFEMTLBlitCommandEncoder_getTextureAccessCounters_region_mipLevel_slice_resetCounters_countersBuffer_"
                 "countersBufferOffset";
        break;
      case 0xFFFFC198:
        result = "kDYFEMTLBlitCommandEncoder_resetTextureAccessCounters_region_mipLevel_slice";
        break;
      case 0xFFFFC199:
        result = "kDYFEMTLSharedEvent_setSignaledValue";
        break;
      case 0xFFFFC19A:
        result = "kDYFEMTLSharedEvent_setLabel";
        break;
      case 0xFFFFC19B:
        result = "kDYFEMTLSharedEvent_dealloc";
        break;
      case 0xFFFFC19C:
        result = "kDYFEMTLDevice_newIndirectCommandBufferWithDescriptor_maxCount_options";
        break;
      case 0xFFFFC19D:
        result = "kDYFEMTLDevice_reserveResourceIndicesForResourceType_indices_indexCount";
        break;
      case 0xFFFFC19E:
        result = "kDYFEMTLRenderCommandEncoder_setPrimitiveRestartEnabled";
        break;
      case 0xFFFFC19F:
        result = "kDYFEMTLDevice_newIndirectCommandBufferWithDescriptor_maxCommandCount_options";
        break;
      case 0xFFFFC1A0:
        result = "kDYFEMTLDevice_getIndirectCommandBufferHeaderSize";
        break;
      case 0xFFFFC1A1:
        result = "kDYFEMTLCommandBuffer_addPurgedResource";
        break;
      case 0xFFFFC1A2:
        result = "kDYFEMTLCommandBuffer_addPurgedHeap";
        break;
      case 0xFFFFC1A3:
        result = "kDYFEMTLComputeCommandEncoder_executeCommandsInBuffer_startIndex";
        break;
      case 0xFFFFC1A4:
        result = "kDYFEMTLComputeCommandEncoder_executeCommandsInBuffer_withRange";
        break;
      case 0xFFFFC1A5:
        result = "kDYFEMTLComputeCommandEncoder_executeCommandsInBuffer_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC1A6:
        result = "kDYFEMTLRenderCommandEncoder_executeCommandsInBuffer_withRange";
        break;
      case 0xFFFFC1A7:
        result = "kDYFEMTLRenderCommandEncoder_executeCommandsInBuffer_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC1A8:
        result = "kDYFEMTLBlitCommandEncoder_resetCommandsInBuffer_withRange";
        break;
      case 0xFFFFC1A9:
        result = "kDYFEMTLBlitCommandEncoder_copyIndirectCommandBuffer_sourceRange_destination_destinationIndex";
        break;
      case 0xFFFFC1AA:
        result = "kDYFEMTLBlitCommandEncoder_optimizeIndirectCommandBuffer_withRange";
        break;
      case 0xFFFFC1AB:
        result = "kDYFEMTLIndirectRenderCommand_dealloc";
        break;
      case 0xFFFFC1AC:
        result = "kDYFEMTLIndirectRenderCommand_setRenderPipelineState";
        break;
      case 0xFFFFC1AD:
        result = "kDYFEMTLIndirectRenderCommand_setVertexBuffer_offset_atIndex";
        break;
      case 0xFFFFC1AE:
        result = "kDYFEMTLIndirectRenderCommand_setFragmentBuffer_offset_atIndex";
        break;
      case 0xFFFFC1AF:
        result = "kDYFEMTLIndirectRenderCommand_drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset"
                 "_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorB"
                 "ufferInstanceStride_tessellationFactorBufferScale";
        break;
      case 0xFFFFC1B0:
        result = "kDYFEMTLIndirectRenderCommand_drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset"
                 "_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorB"
                 "ufferInstanceStride";
        break;
      case 0xFFFFC1B1:
        result = "kDYFEMTLIndirectRenderCommand_drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBuffe"
                 "rOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_tessellationFa"
                 "ctorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride_tessellationFactorBufferScale";
        break;
      case 0xFFFFC1B2:
        result = "kDYFEMTLIndirectRenderCommand_drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBuffe"
                 "rOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_tessellationFa"
                 "ctorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride";
        break;
      case 0xFFFFC1B3:
        result = "kDYFEMTLIndirectRenderCommand_drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance";
        break;
      case 0xFFFFC1B4:
        result = "kDYFEMTLIndirectRenderCommand_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_"
                 "instanceCount_baseVertex_baseInstance";
        break;
      case 0xFFFFC1B5:
        result = "kDYFEMTLIndirectRenderCommand_nop";
        break;
      case 0xFFFFC1B6:
        result = "kDYFEMTLIndirectRenderCommand_end";
        break;
      case 0xFFFFC1B7:
        result = "kDYFEMTLIndirectRenderCommand_setTessellationFactorBuffer_offset_instanceStride";
        break;
      case 0xFFFFC1B8:
        result = "kDYFEMTLIndirectRenderCommand_setTessellationFactorScale";
        break;
      case 0xFFFFC1B9:
        result = "kDYFEMTLIndirectRenderCommand_drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset"
                 "_instanceCount_baseInstance";
        break;
      case 0xFFFFC1BA:
        result = "kDYFEMTLIndirectRenderCommand_drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBuffe"
                 "rOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance";
        break;
      case 0xFFFFC1BB:
        result = "kDYFEMTLIndirectRenderCommand_dispatchThreadsPerTile";
        break;
      case 0xFFFFC1BC:
        result = "kDYFEMTLIndirectRenderCommand_setVertexArgument_offset_atIndex";
        break;
      case 0xFFFFC1BD:
        result = "kDYFEMTLIndirectRenderCommand_setFragmentArgument_offset_atIndex";
        break;
      case 0xFFFFC1BE:
        result = "kDYFEMTLIndirectRenderCommand_setTileArgument_offset_atIndex";
        break;
      case 0xFFFFC1BF:
        result = "kDYFEMTLIndirectRenderCommand_setThreadgroupMemoryLength_offset_atIndex";
        break;
      case 0xFFFFC1C0:
        result = "kDYFEMTLIndirectRenderCommand_endIndirectCommandBuffer";
        break;
      case 0xFFFFC1C1:
        result = "kDYFEMTLIndirectComputeCommand_dealloc";
        break;
      case 0xFFFFC1C2:
        result = "kDYFEMTLIndirectComputeCommand_setComputePipelineState";
        break;
      case 0xFFFFC1C3:
        result = "kDYFEMTLIndirectComputeCommand_setKernelBuffer_offset_atIndex";
        break;
      case 0xFFFFC1C4:
        result = "kDYFEMTLIndirectComputeCommand_dispatchThreadgroups_threadsPerThreadgroup";
        break;
      case 0xFFFFC1C5:
        result = "kDYFEMTLIndirectComputeCommand_concurrentDispatchThreadgroups_threadsPerThreadgroup";
        break;
      case 0xFFFFC1C6:
        result = "kDYFEMTLIndirectComputeCommand_nop";
        break;
      case 0xFFFFC1C7:
        result = "kDYFEMTLIndirectComputeCommand_endIndirectCommandBuffer";
        break;
      case 0xFFFFC1C8:
        result = "kDYFEMTLIndirectComputeCommand_setKernelArgument_offset_atIndex";
        break;
      case 0xFFFFC1C9:
        result = "kDYFEMTLIndirectComputeCommand_setThreadgroupMemoryLength_atIndex";
        break;
      case 0xFFFFC1CA:
        result = "kDYFEMTLIndirectComputeCommand_setStageInRegion";
        break;
      case 0xFFFFC1CB:
        result = "kDYFEMTLIndirectCommandBuffer_setLabel";
        break;
      case 0xFFFFC1CC:
        result = "kDYFEMTLIndirectCommandBuffer_setResponsibleProcess";
        break;
      case 0xFFFFC1CD:
        result = "kDYFEMTLIndirectCommandBuffer_dealloc";
        break;
      case 0xFFFFC1CE:
        result = "kDYFEMTLIndirectCommandBuffer_indirectRenderCommandAtIndex";
        break;
      case 0xFFFFC1CF:
        result = "kDYFEMTLIndirectCommandBuffer_indirectComputeCommandAtIndex";
        break;
      case 0xFFFFC1D0:
        result = "kDYFEMTLIndirectCommandBuffer_setPurgeableState";
        break;
      case 0xFFFFC1D1:
        result = "kDYFEMTLIndirectCommandBuffer_makeAliasable";
        break;
      case 0xFFFFC1D2:
        result = "kDYFEMTLIndirectCommandBuffer_isAliasable";
        break;
      case 0xFFFFC1D3:
        result = "kDYFEMTLIndirectCommandBuffer_isPurgeable";
        break;
      case 0xFFFFC1D4:
        result = "kDYFEMTLArgumentEncoder_setIndirectCommandBuffer_atIndex";
        break;
      case 0xFFFFC1D5:
        result = "kDYFEMTLArgumentEncoder_setIndirectCommandBuffers_withRange";
        break;
      case 0xFFFFC1D6:
        result = "kDYFEMTLBuffer_newRemoteBufferViewForDevice";
        break;
      case 0xFFFFC1D7:
        result = "kDYFEMTLTexture_newRemoteTextureViewForDevice";
        break;
      case 0xFFFFC1D8:
        result = "kDYFEMTLDevice_newSharedEventWithMachPort";
        break;
      case 0xFFFFC1D9:
        result = "kDYFEMTLSharedEvent_eventPort";
        break;
      case 0xFFFFC1DA:
        result = "kDYFEMTLTexture_newSharedTextureHandle";
        break;
      case 0xFFFFC1DB:
        result = "kDYFEMTLDevice_newSharedEventWithHandle";
        break;
      case 0xFFFFC1DC:
        result = "kDYFEMTLCommandBuffer_commitAndWaitUntilSubmitted";
        break;
      case 0xFFFFC1DD:
        result = "kDYFEMTLSharedEvent_newSharedEventHandle";
        break;
      case 0xFFFFC1DE:
        result = "kDYFEMTLIndirectRenderCommand_reset";
        break;
      case 0xFFFFC1DF:
        result = "kDYFEMTLIndirectComputeCommand_reset";
        break;
      case 0xFFFFC1E0:
        result = "kDYFEMTLBuffer_containsResource";
        break;
      case 0xFFFFC1E1:
        result = "kDYFEMTLTexture_containsResource";
        break;
      case 0xFFFFC1E2:
        result = "kDYFEMTLDevice_supportsPrimitiveType";
        break;
      case 0xFFFFC1E3:
        result = "kDYFEMTLDevice_startCollectingPipelineDescriptorsUsingPrefixForNames";
        break;
      case 0xFFFFC1E4:
        result = "kDYFEMTLDevice_newResourceGroupFromResources_count";
        break;
      case 0xFFFFC1E5:
        result = "kDYFEMTLCommandBuffer_sampledComputeCommandEncoderWithDispatchType_programInfoBuffer_capacity";
        break;
      case 0xFFFFC1E6:
        result = "kDYFEMTLCommandBuffer_setResourceGroups_count";
        break;
      case 0xFFFFC1E7:
        result = "kDYFEMTLCommandBuffer_dropResourceGroups_count";
        break;
      case 0xFFFFC1E8:
        result = "kDYFEMTLIndirectCommandBuffer_resetWithRange";
        break;
      case 0xFFFFC1E9:
        result = "kDYFEMTLIndirectCommandBuffer_containsResource";
        break;
      case 0xFFFFC1EA:
        result = "kDYFEMTLTexture_isShareable";
        break;
      case 0xFFFFC1EB:
        result = "kDYFEMTLMotionEstimationPipeline_dealloc";
        break;
      case 0xFFFFC1EC:
        result = "kDYFEMTLDevice_motionEstimatorCapabilities";
        break;
      case 0xFFFFC1ED:
        result = "kDYFEMTLDevice_newMotionEstimationPipelineWithDescriptor";
        break;
      case 0xFFFFC1EE:
        result = "kDYFEMTLVideoCommandEncoder_setLabel";
        break;
      case 0xFFFFC1EF:
        result = "kDYFEMTLVideoCommandEncoder_dealloc";
        break;
      case 0xFFFFC1F0:
        result = "kDYFEMTLVideoCommandEncoder_setMotionEstimationPipeline";
        break;
      case 0xFFFFC1F1:
        result = "kDYFEMTLVideoCommandEncoder_generateMotionVectorsForTexture_previousTexture_resultBuffer_bufferOffset";
        break;
      case 0xFFFFC1F2:
        result = "kDYFEMTLVideoCommandEncoder_waitForFence";
        break;
      case 0xFFFFC1F3:
        result = "kDYFEMTLVideoCommandEncoder_updateFence";
        break;
      case 0xFFFFC1F4:
        result = "kDYFEMTLVideoCommandEncoder_endEncoding";
        break;
      case 0xFFFFC1F5:
        result = "kDYFEMTLVideoCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC1F6:
        result = "kDYFEMTLVideoCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC1F7:
        result = "kDYFEMTLVideoCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC1F8:
        result = "kDYFEMTLEvent_setLabel";
        break;
      case 0xFFFFC1F9:
        result = "kDYFEMTLEvent_dealloc";
        break;
      case 0xFFFFC1FA:
        result = "kDYFEMTLBlitCommandEncoder_copyFromTexture_sourceSlice_sourceLevel_toTexture_destinationSlice_destinati"
                 "onLevel_sliceCount_levelCount";
        break;
      case 0xFFFFC1FB:
        result = "kDYFEMTLBlitCommandEncoder_copyFromTexture_toTexture";
        break;
      case 0xFFFFC1FC:
        result = "kDYFEMTLBlitCommandEncoder_resolveCountersWithIndexRange_sampleBuffer_resolvedBuffer";
        break;
      case 0xFFFFC1FD:
        result = "kDYFEMTLBlitCommandEncoder_sampleCountersInBuffer_atIndex_allowOverlap";
        break;
      case 0xFFFFC1FE:
        result = "kDYFEMTLBuffer_setResourceIndex";
        break;
      case 0xFFFFC1FF:
        result = "kDYFEMTLCommandBuffer_debugBufferContentsWithLength";
        break;
      case 0xFFFFC200:
        result = "kDYFEMTLCommandBuffer_encodeCacheControlFinalizeOperation_resourceGroups_count";
        break;
      case 0xFFFFC201:
        result = "kDYFEMTLCommandBuffer_encodeCacheControlTagOperation_resourceGroups_count";
        break;
      case 0xFFFFC202:
        result = "kDYFEMTLCommandBuffer_resourceStateCommandEncoder";
        break;
      case 0xFFFFC203:
        result = "kDYFEMTLComputeCommandEncoder_sampleCountersInBuffer_atIndex_allowOverlap";
        break;
      case 0xFFFFC204:
        result = "kDYFEMTLComputePipelineState_setResourceIndex";
        break;
      case 0xFFFFC205:
        result = "kDYFEMTLCounterSampleBuffer_dealloc";
        break;
      case 0xFFFFC206:
        result = "kDYFEMTLDeserializationContext_dealloc";
        break;
      case 0xFFFFC207:
        result = "kDYFEMTLDeserializationContext_functionWithFunctionRef";
        break;
      case 0xFFFFC208:
        result = "kDYFEMTLDevice_setCurrentUtilityBufferIndex";
        break;
      case 0xFFFFC209:
        result = "kDYFEMTLDevice_setResourceIndirectionEnabled";
        break;
      case 0xFFFFC20A:
        result = "kDYFEMTLDevice_setUtilityBuffers";
        break;
      case 0xFFFFC20B:
        result = "kDYFEMTLDevice_addBufferToGlobalResourceTable";
        break;
      case 0xFFFFC20C:
        result = "kDYFEMTLDevice_addComputePipelineStateToGlobalResourceTable";
        break;
      case 0xFFFFC20D:
        result = "kDYFEMTLDevice_addIndirectCommandBufferToGlobalResourceTable";
        break;
      case 0xFFFFC20E:
        result = "kDYFEMTLDevice_addRenderPipelineStateToGlobalResourceTable";
        break;
      case 0xFFFFC20F:
        result = "kDYFEMTLDevice_addSamplerStateToGlobalResourceTable";
        break;
      case 0xFFFFC210:
        result = "kDYFEMTLDevice_addTextureToGlobalResourceTable";
        break;
      case 0xFFFFC211:
        result = "kDYFEMTLDevice_allowLibrariesFromOtherPlatforms";
        break;
      case 0xFFFFC212:
        result = "kDYFEMTLDevice_createNewUtilityBuffer";
        break;
      case 0xFFFFC213:
        result = "kDYFEMTLDevice_describeCounter";
        break;
      case 0xFFFFC214:
        result = "kDYFEMTLDevice_indirectBufferAddressForResourceIndex_offset";
        break;
      case 0xFFFFC215:
        result = "kDYFEMTLDevice_newBufferWithBytes_length_options_atResourceIndex";
        break;
      case 0xFFFFC216:
        result = "kDYFEMTLDevice_newBufferWithBytesNoCopy_length_options_atResourceIndex_deallocator";
        break;
      case 0xFFFFC217:
        result = "kDYFEMTLDevice_newBufferWithLength_options_atResourceIndex";
        break;
      case 0xFFFFC218:
        result = "kDYFEMTLDevice_newCounterSampleBufferWithDescriptor_error";
        break;
      case 0xFFFFC219:
        result = "kDYFEMTLDevice_newLibraryWithImageFilterFunctionsSPI_imageFilterFunctionInfo_error";
        break;
      case 0xFFFFC21A:
        result = "kDYFEMTLDevice_newRasterizationRateMapWithScreenSize_layerCount_layers";
        break;
      case 0xFFFFC21B:
        result = "kDYFEMTLDevice_newRenderPipelineDescriptorWithSerializedData_deserializationContext";
        break;
      case 0xFFFFC21C:
        result = "kDYFEMTLDevice_offsetFromIndirectBufferAddress";
        break;
      case 0xFFFFC21D:
        result = "kDYFEMTLDevice_pollSampleBuffer_resolvedBuffer";
        break;
      case 0xFFFFC21E:
        result = "kDYFEMTLDevice_removeResourceFromGlobalResourceTable_resourceType";
        break;
      case 0xFFFFC21F:
        result = "kDYFEMTLDevice_requiresIndirectionForAllResourceTypes";
        break;
      case 0xFFFFC220:
        result = "kDYFEMTLDevice_resolveCountersWithIndexRange_sampleBuffer";
        break;
      case 0xFFFFC221:
        result = "kDYFEMTLDevice_resourceIndexFromIndirectBufferAddress";
        break;
      case 0xFFFFC222:
        result = "kDYFEMTLDevice_sampleCountersAtInterval_sampleBuffer_error";
        break;
      case 0xFFFFC223:
        result = "kDYFEMTLDevice_sampleTimeStamps_gpuTimeStamp";
        break;
      case 0xFFFFC224:
        result = "kDYFEMTLDevice_serializeRenderPipelineDescriptor";
        break;
      case 0xFFFFC225:
        result = "kDYFEMTLDevice_setGPUAssertionsEnabled";
        break;
      case 0xFFFFC226:
        result = "kDYFEMTLDevice_setResourcesPurgeableState_newState_oldState_count";
        break;
      case 0xFFFFC227:
        result = "kDYFEMTLDevice_useDeviceResourceTableForType";
        break;
      case 0xFFFFC228:
        result = "kDYFEMTLDevice_utilityBufferForComputeCommandEncoder";
        break;
      case 0xFFFFC229:
        result = "kDYFEMTLDevice_utilityBufferForRenderCommandEncoder";
        break;
      case 0xFFFFC22A:
        result = "kDYFEMTLFunction_newFunctionWithPluginData_bitcodeType";
        break;
      case 0xFFFFC22B:
        result = "kDYFEMTLHeap_newBufferWithLength_options_atOffset";
        break;
      case 0xFFFFC22C:
        result = "kDYFEMTLHeap_newTextureWithDescriptor_atOffset";
        break;
      case 0xFFFFC22D:
        result = "kDYFEMTLIndirectComputeCommand_clearBarrier";
        break;
      case 0xFFFFC22E:
        result = "kDYFEMTLIndirectComputeCommand_concurrentDispatchThreads_threadsPerThreadgroup";
        break;
      case 0xFFFFC22F:
        result = "kDYFEMTLIndirectComputeCommand_setBarrier";
        break;
      case 0xFFFFC230:
        result = "kDYFEMTLIndirectComputeCommand_setImageBlockWidth_height";
        break;
      case 0xFFFFC231:
        result = "kDYFEMTLRenderCommandEncoder_sampleCountersInBuffer_atIndex_allowOverlap";
        break;
      case 0xFFFFC232:
        result = "kDYFEMTLRenderCommandEncoder_setVertexAmplificationCount_viewMappings";
        break;
      case 0xFFFFC233:
        result = "kDYFEMTLRenderCommandEncoder_useHeap_stages";
        break;
      case 0xFFFFC234:
        result = "kDYFEMTLRenderCommandEncoder_useHeaps_count_stages";
        break;
      case 0xFFFFC235:
        result = "kDYFEMTLRenderCommandEncoder_useResource_usage_stages";
        break;
      case 0xFFFFC236:
        result = "kDYFEMTLRenderCommandEncoder_useResources_count_usage_stages";
        break;
      case 0xFFFFC237:
        result = "kDYFEMTLRenderPipelineState_setResourceIndex";
        break;
      case 0xFFFFC238:
        result = "kDYFEMTLSamplerState_setResourceIndex";
        break;
      case 0xFFFFC239:
        result = "kDYFEMTLTexture_setResourceIndex";
        break;
      case 0xFFFFC23A:
        result = "kDYFEMTLDevice_newComputePipelineDescriptorWithSerializedData_deserializationContext";
        break;
      case 0xFFFFC23B:
        result = "kDYFEMTLDevice_serializeComputePipelineDescriptor";
        break;
      case 0xFFFFC23C:
        result = "kDYFEMTLRenderCommandEncoder_setVertexAmplificationMode_value";
        break;
      case 0xFFFFC23D:
        result = "kDYFEMTLCommandQueue_getBackgroundGPUPriority";
        break;
      case 0xFFFFC23E:
        result = "kDYFEMTLCommandQueue_getGPUPriority";
        break;
      case 0xFFFFC23F:
        result = "kDYFEMTLCommandQueue_setBackgroundGPUPriority";
        break;
      case 0xFFFFC240:
        result = "kDYFEMTLCommandQueue_setBackgroundGPUPriority_offset";
        break;
      case 0xFFFFC241:
        result = "kDYFEMTLCommandQueue_setCompletionQueue";
        break;
      case 0xFFFFC242:
        result = "kDYFEMTLCommandQueue_setGPUPriority";
        break;
      case 0xFFFFC243:
        result = "kDYFEMTLCommandQueue_setGPUPriority_offset";
        break;
      case 0xFFFFC244:
        result = "kDYFEMTLCommandQueue_setSubmissionQueue";
        break;
      case 0xFFFFC245:
        result = "kDYFEMTLRasterizationRateMap_copyParameterDataToBuffer_atOffset";
        break;
      case 0xFFFFC246:
        result = "kDYFEMTLBlitCommandEncoder_updateTextureMapping_mode_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC247:
        result = "kDYFEMTLRasterizationRateMap_dealloc";
        break;
      case 0xFFFFC248:
        result = "kDYFEMTLBlitCommandEncoder_updateTextureMapping_mode_region_mipLevel_slice";
        break;
      case 0xFFFFC249:
        result = "kDYFEMTLRasterizationRateMap_physicalCoordinate_forLayer";
        break;
      case 0xFFFFC24A:
        result = "kDYFEMTLBlitCommandEncoder_updateTextureMappings_mode_regions_mipLevels_slices_numRegions";
        break;
      case 0xFFFFC24B:
        result = "kDYFEMTLRasterizationRateMap_physicalSizeForLayer";
        break;
      case 0xFFFFC24C:
        result = "kDYFEMTLDevice_tileSizeWithSparsePageSize_textureType_pixelFormat_sampleCount";
        break;
      case 0xFFFFC24D:
        result = "kDYFEMTLRasterizationRateMap_screenCoordinate_forLayer";
        break;
      case 0xFFFFC24E:
        result = "kDYFEMTLResourceStateCommandEncoder_setLabel";
        break;
      case 0xFFFFC24F:
        result = "kDYFEMTLDevice_newRasterizationRateMapWithDescriptor";
        break;
      case 0xFFFFC250:
        result = "kDYFEMTLResourceStateCommandEncoder_copyMappingStateFromTexture_mipLevel_slice_toBuffer_offset_numTiles";
        break;
      case 0xFFFFC251:
        result = "kDYFEMTLDevice_supportsRasterizationRateMapWithLayerCount";
        break;
      case 0xFFFFC252:
        result = "kDYFEMTLResourceStateCommandEncoder_dealloc";
        break;
      case 0xFFFFC253:
        result = "kDYFEMTLResourceStateCommandEncoder_endEncoding";
        break;
      case 0xFFFFC254:
        result = "kDYFEMTLResourceStateCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC255:
        result = "kDYFEMTLResourceStateCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC256:
        result = "kDYFEMTLResourceStateCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC257:
        result = "kDYFEMTLResourceStateCommandEncoder_updateFence";
        break;
      case 0xFFFFC258:
        result = "kDYFEMTLResourceStateCommandEncoder_updateTextureMapping_mode_indirectBuffer_indirectBufferOffset";
        break;
      case 0xFFFFC259:
        result = "kDYFEMTLResourceStateCommandEncoder_updateTextureMapping_mode_region_mipLevel_slice";
        break;
      case 0xFFFFC25A:
        result = "kDYFEMTLResourceStateCommandEncoder_updateTextureMappings_mode_regions_mipLevels_slices_numRegions";
        break;
      case 0xFFFFC25B:
        result = "kDYFEMTLResourceStateCommandEncoder_waitForFence";
        break;
      case 0xFFFFC25C:
        result = "kDYFEMTLDevice_supportsFamily";
        break;
      case 0xFFFFC25D:
        result = "kDYFEMTLDevice_supportsVersion";
        break;
      case 0xFFFFC25E:
        result = "kDYFEMTLHeap_newBufferWithLength_options_offset";
        break;
      case 0xFFFFC25F:
        result = "kDYFEMTLHeap_newTextureWithDescriptor_offset";
        break;
      case 0xFFFFC260:
        result = "kDYFEMTLRasterizationRateMap_copyParameterDataToBuffer_offset";
        break;
      case 0xFFFFC261:
        result = "kDYFEMTLTexture_newTextureViewWithPixelFormat_textureType_levels_slices_swizzle";
        break;
      case 0xFFFFC262:
        result = "kDYFEMTLDevice_newPrecompiledComputePipelineStateWithDescriptor_options_pipelineCache_completionHandler";
        break;
      case 0xFFFFC263:
        result = "kDYFEMTLIndirectComputeCommand_setImageblockWidth_height";
        break;
      case 0xFFFFC264:
        result = "kDYFEMTLLibrary_newFunctionWithName_constantValues_functionCache_error";
        break;
      case 0xFFFFC265:
        result = "kDYFEMTLRasterizationRateMap_mapPhysicalToScreenCoordinates_forLayer";
        break;
      case 0xFFFFC266:
        result = "kDYFEMTLRasterizationRateMap_mapScreenToPhysicalCoordinates_forLayer";
        break;
      case 0xFFFFC267:
        result = "kDYFEMTLResourceGroup_dealloc";
        break;
      case 0xFFFFC268:
        result = "kDYFEMTLBuffer_isComplete";
        break;
      case 0xFFFFC269:
        result = "kDYFEMTLBuffer_waitUntilComplete";
        break;
      case 0xFFFFC26A:
        result = "kDYFEMTLIndirectCommandBuffer_doesAliasAllResources_count";
        break;
      case 0xFFFFC26B:
        result = "kDYFEMTLIndirectCommandBuffer_doesAliasAnyResources_count";
        break;
      case 0xFFFFC26C:
        result = "kDYFEMTLIndirectCommandBuffer_doesAliasResource";
        break;
      case 0xFFFFC26D:
        result = "kDYFEMTLIndirectCommandBuffer_isComplete";
        break;
      case 0xFFFFC26E:
        result = "kDYFEMTLIndirectCommandBuffer_waitUntilComplete";
        break;
      case 0xFFFFC26F:
        result = "kDYFEMTLTexture_isComplete";
        break;
      case 0xFFFFC270:
        result = "kDYFEMTLTexture_waitUntilComplete";
        break;
      case 0xFFFFC271:
        result = "kDYFEMTLDevice_convertSparsePixelRegions_toTileRegions_withTileSize_alignmentMode_numRegions";
        break;
      case 0xFFFFC272:
        result = "kDYFEMTLDevice_convertSparseTileRegions_toPixelRegions_withTileSize_numRegions";
        break;
      case 0xFFFFC273:
        result = "kDYFEMTLDevice_supportsVertexAmplificationCount";
        break;
      case 0xFFFFC274:
        result = "kDYFEMTLBlitCommandEncoder_resolveCounters_inRange_destinationBuffer_destinationOffset";
        break;
      case 0xFFFFC275:
        result = "kDYFEMTLBlitCommandEncoder_sampleCountersInBuffer_atSampleIndex_withBarrier";
        break;
      case 0xFFFFC276:
        result = "kDYFEMTLComputeCommandEncoder_sampleCountersInBuffer_atSampleIndex_withBarrier";
        break;
      case 0xFFFFC277:
        result = "kDYFEMTLCounterSampleBuffer_resolveCounterRange";
        break;
      case 0xFFFFC278:
        result = "kDYFEMTLCounterSet_dealloc";
        break;
      case 0xFFFFC279:
        result = "kDYFEMTLDevice_sampleTimestamps_gpuTimestamp";
        break;
      case 0xFFFFC27A:
        result = "kDYFEMTLRenderCommandEncoder_sampleCountersInBuffer_atSampleIndex_withBarrier";
        break;
      case 0xFFFFC27B:
        result = "kDYFEMTLCommandBuffer_encodeWaitForEvent_value_timeout";
        break;
      case 0xFFFFC27C:
        result = "kDYFEMTLCounter_dealloc";
        break;
      case 0xFFFFC27D:
        result = "kDYFEMTLDevice_copyShaderCacheToPath";
        break;
      case 0xFFFFC27E:
        result = "kDYFEMTLDevice_serializeStructType_version";
        break;
      case 0xFFFFC27F:
        result = "kDYFEMTLPipelineCache_dealloc";
        break;
      case 0xFFFFC280:
        result = "kDYFEMTLPipelineLibrary_setDisableRunTimeCompilation";
        break;
      case 0xFFFFC281:
        result = "kDYFEMTLPipelineLibrary_setLabel";
        break;
      case 0xFFFFC282:
        result = "kDYFEMTLPipelineLibrary_dealloc";
        break;
      case 0xFFFFC283:
        result = "kDYFEMTLPipelineLibrary_newComputePipelineDescriptorWithName_error";
        break;
      case 0xFFFFC284:
        result = "kDYFEMTLPipelineLibrary_newComputePipelineStateWithName_options_reflection_error";
        break;
      case 0xFFFFC285:
        result = "kDYFEMTLPipelineLibrary_newRenderPipelineDescriptorWithName_error";
        break;
      case 0xFFFFC286:
        result = "kDYFEMTLPipelineLibrary_newRenderPipelineStateWithName_options_reflection_error";
        break;
      case 0xFFFFC287:
        result = "kDYFEMTLDevice_sparseTileSizeWithTextureType_pixelFormat_sampleCount";
        break;
      case 0xFFFFC288:
        result = "kDYFEMTLCaptureManager_startCaptureWithDescriptor_error";
        break;
      case 0xFFFFC289:
        result = "kDYFEMTLCaptureManager_startCaptureWithScope";
        break;
      case 0xFFFFC28A:
        result = "kDYFEMTLCaptureManager_newCaptureScopeWithDevice";
        break;
      case 0xFFFFC28B:
        result = "kDYFEMTLCaptureManager_newCaptureScopeWithCommandQueue";
        break;
      case 0xFFFFC28C:
        result = "kDYFEMTLComputeCommandEncoder_enableNullBufferBinds";
        break;
      case 0xFFFFC28D:
        result = "kDYFEMTLDevice_newFunctionWithGLIR_functionType";
        break;
      case 0xFFFFC28E:
        result = "kDYFEMTLDevice_newFunctionWithGLIR_inputsDescription_functionType";
        break;
      case 0xFFFFC28F:
        result = "kDYFEMTLRenderCommandEncoder_setAlphaTestReferenceValue";
        break;
      case 0xFFFFC290:
        result = "kDYFEMTLRenderCommandEncoder_setColorResolveTexture_slice_depthPlane_level_yInvert_atIndex";
        break;
      case 0xFFFFC291:
        result = "kDYFEMTLRenderCommandEncoder_setDepthCleared";
        break;
      case 0xFFFFC292:
        result = "kDYFEMTLRenderCommandEncoder_setDepthResolveTexture_slice_depthPlane_level_yInvert";
        break;
      case 0xFFFFC293:
        result = "kDYFEMTLRenderCommandEncoder_setProvokingVertexMode";
        break;
      case 0xFFFFC294:
        result = "kDYFEMTLRenderCommandEncoder_setStencilCleared";
        break;
      case 0xFFFFC295:
        result = "kDYFEMTLRenderCommandEncoder_setStencilResolveTexture_slice_depthPlane_level";
        break;
      case 0xFFFFC296:
        result = "kDYFEMTLRenderCommandEncoder_setStencilResolveTexture_slice_depthPlane_level_yInvert";
        break;
      case 0xFFFFC297:
        result = "kDYFEMTLRenderCommandEncoder_setTriangleFrontFillMode_backFillMode";
        break;
      case 0xFFFFC298:
        result = "kDYFEMTLRenderCommandEncoder_setViewportTransformEnabled";
        break;
      case 0xFFFFC299:
        result = "kDYFEMTLDevice_minLinearTextureBaseAddressAlignmentForDescriptor";
        break;
      case 0xFFFFC29A:
        result = "kDYFEMTLDevice_minLinearTexturePitchAlignmentForDescriptor_mustMatchExactly";
        break;
      case 0xFFFFC29B:
        result = "kDYFEMTLDevice_newBinaryArchiveWithDescriptor_error";
        break;
      case 0xFFFFC29C:
        result = "kDYFEMTLDevice_requiredLinearTextureBytesPerRowForDescriptor";
        break;
      case 0xFFFFC29D:
        result = "kDYFEMTLFunction_newArgumentEncoderWithBufferIndex_pipelineLibrary";
        break;
      case 0xFFFFC29E:
        result = "kDYFEMTLFunction_newArgumentEncoderWithBufferIndex_reflection_pipelineLibrary";
        break;
      case 0xFFFFC29F:
        result = "kDYFEMTLFunction_reflectionWithOptions_pipelineLibrary";
        break;
      case 0xFFFFC2A0:
        result = "kDYFEMTLCommandBuffer_computeCommandEncoderWithDispatchType_substreamCount";
        break;
      case 0xFFFFC2A1:
        result = "kDYFEMTLComputeCommandEncoder_setSubstream";
        break;
      case 0xFFFFC2A2:
        result = "kDYFEMTLComputeCommandEncoder_signalProgress";
        break;
      case 0xFFFFC2A3:
        result = "kDYFEMTLComputeCommandEncoder_waitForProgress";
        break;
      case 0xFFFFC2A4:
        result = "kDYFEMTLDevice_maximumComputeSubstreams";
        break;
      case 0xFFFFC2A5:
        result = "kDYFEMTLDevice_newBufferWithBytes_length_options_gpuAddress";
        break;
      case 0xFFFFC2A6:
        result = "kDYFEMTLDevice_newBufferWithBytesNoCopy_length_options_gpuAddress_deallocator";
        break;
      case 0xFFFFC2A7:
        result = "kDYFEMTLDevice_newBufferWithLength_options_gpuAddress";
        break;
      case 0xFFFFC2A8:
        result = "kDYFEMTLDevice_reserveGPUAddressRange";
        break;
      case 0xFFFFC2A9:
        result = "kDYFEMTLCommandBuffer_addLoggingForType_handler";
        break;
      case 0xFFFFC2AA:
        result = "kDYFEMTLCommandBufferEncoderInfo_dealloc";
        break;
      case 0xFFFFC2AB:
        result = "kDYFEMTLCommandQueue_commandBufferWithDescriptor";
        break;
      case 0xFFFFC2AC:
        result = "kDYFEMTLComputePipelineState_functionPointerHandleWithFunction";
        break;
      case 0xFFFFC2AD:
        result = "kDYFEMTLComputePipelineState_functionPointerHandlesWithFunctions_range";
        break;
      case 0xFFFFC2AE:
        result = "kDYFEMTLDevice_setCommandBufferErrorOptions";
        break;
      case 0xFFFFC2AF:
        result = "kDYFEMTLDevice_newBinaryLibraryWithOptions_url_error";
        break;
      case 0xFFFFC2B0:
        result = "kDYFEMTLDevice_newDynamicLibrary_computeDescriptor_error";
        break;
      case 0xFFFFC2B1:
        result = "kDYFEMTLDevice_newDynamicLibrary_error";
        break;
      case 0xFFFFC2B2:
        result = "kDYFEMTLDevice_newDynamicLibraryFromURL_error";
        break;
      case 0xFFFFC2B3:
        result = "kDYFEMTLDevice_newLibraryWithDAG_functions_error";
        break;
      case 0xFFFFC2B4:
        result = "kDYFEMTLFunctionLog_dealloc";
        break;
      case 0xFFFFC2B5:
        result = "kDYFEMTLStackTraceEntry_dealloc";
        break;
      case 0xFFFFC2B6:
        result = "kDYFEMTLTexture_newTextureViewWithPixelFormat_resourceIndex";
        break;
      case 0xFFFFC2B7:
        result = "kDYFEMTLTexture_newTextureViewWithPixelFormat_textureType_levels_slices_resourceIndex";
        break;
      case 0xFFFFC2B8:
        result = "kDYFEMTLTexture_newTextureViewWithPixelFormat_textureType_levels_slices_swizzle_resourceIndex";
        break;
      case 0xFFFFC2B9:
        result = "kDYFEMTLBinaryArchive_addComputePipelineStateWithDescriptor_error";
        break;
      case 0xFFFFC2BA:
        result = "kDYFEMTLBinaryArchive_addLibrary_computePipelineDescriptor_error";
        break;
      case 0xFFFFC2BB:
        result = "kDYFEMTLBinaryArchive_dealloc";
        break;
      case 0xFFFFC2BC:
        result = "kDYFEMTLBinaryArchive_writeToURL_error";
        break;
      case 0xFFFFC2BD:
        result = "kDYFEMTLBinaryLibrary_setLabel";
        break;
      case 0xFFFFC2BE:
        result = "kDYFEMTLBinaryLibrary_addBinaryEntry";
        break;
      case 0xFFFFC2BF:
        result = "kDYFEMTLBinaryLibrary_addComputePipelineFunctionsWithDescriptor_error";
        break;
      case 0xFFFFC2C0:
        result = "kDYFEMTLBinaryLibrary_dealloc";
        break;
      case 0xFFFFC2C1:
        result = "kDYFEMTLBinaryLibrary_getBinaryDataWithKey";
        break;
      case 0xFFFFC2C2:
        result = "kDYFEMTLBinaryLibrary_removeComputePipelineFunctionsWithDescriptor_error";
        break;
      case 0xFFFFC2C3:
        result = "kDYFEMTLBinaryLibrary_serializeToURL_error";
        break;
      case 0xFFFFC2C4:
        result = "kDYFEMTLDynamicLibrary_setLabel";
        break;
      case 0xFFFFC2C5:
        result = "kDYFEMTLDynamicLibrary_dealloc";
        break;
      case 0xFFFFC2C6:
        result = "kDYFEMTLDynamicLibrary_serializeToURL_error";
        break;
      case 0xFFFFC2C7:
        result = "kDYFEMTLCommandBuffer_accelerationStructureCommandEncoder";
        break;
      case 0xFFFFC2C8:
        result = "kDYFEMTLDevice_accelerationStructureSizesWithDescriptor";
        break;
      case 0xFFFFC2C9:
        result = "kDYFEMTLDevice_loadDynamicLibrariesForComputeDescriptor_error";
        break;
      case 0xFFFFC2CA:
        result = "kDYFEMTLFunction_newArgumentEncoderWithBufferIndex_reflection_binaryArchives";
        break;
      case 0xFFFFC2CB:
        result = "kDYFEMTLFunction_reflectionWithOptions_binaryArchives";
        break;
      case 0xFFFFC2CC:
        result = "kDYFEMTLBinaryArchive_setLabel";
        break;
      case 0xFFFFC2CD:
        result = "kDYFEMTLBinaryArchive_addBinaryEntry_forKey";
        break;
      case 0xFFFFC2CE:
        result = "kDYFEMTLBinaryArchive_addComputePipelineFunctionsWithDescriptor_error";
        break;
      case 0xFFFFC2CF:
        result = "kDYFEMTLBinaryArchive_addRenderPipelineFunctionsWithDescriptor_error";
        break;
      case 0xFFFFC2D0:
        result = "kDYFEMTLBinaryArchive_addTileRenderPipelineFunctionsWithDescriptor_error";
        break;
      case 0xFFFFC2D1:
        result = "kDYFEMTLBinaryArchive_getBinaryDataForKey";
        break;
      case 0xFFFFC2D2:
        result = "kDYFEMTLBinaryArchive_serializeToURL_error";
        break;
      case 0xFFFFC2D3:
        result = "kDYFEMTLAccelerationStructure_setLabel";
        break;
      case 0xFFFFC2D4:
        result = "kDYFEMTLAccelerationStructure_setResponsibleProcess";
        break;
      case 0xFFFFC2D5:
        result = "kDYFEMTLAccelerationStructure_dealloc";
        break;
      case 0xFFFFC2D6:
        result = "kDYFEMTLAccelerationStructure_doesAliasAllResources_count";
        break;
      case 0xFFFFC2D7:
        result = "kDYFEMTLAccelerationStructure_doesAliasAnyResources_count";
        break;
      case 0xFFFFC2D8:
        result = "kDYFEMTLAccelerationStructure_doesAliasResource";
        break;
      case 0xFFFFC2D9:
        result = "kDYFEMTLAccelerationStructure_isAliasable";
        break;
      case 0xFFFFC2DA:
        result = "kDYFEMTLAccelerationStructure_isComplete";
        break;
      case 0xFFFFC2DB:
        result = "kDYFEMTLAccelerationStructure_isPurgeable";
        break;
      case 0xFFFFC2DC:
        result = "kDYFEMTLAccelerationStructure_isWriteComplete";
        break;
      case 0xFFFFC2DD:
        result = "kDYFEMTLAccelerationStructure_makeAliasable";
        break;
      case 0xFFFFC2DE:
        result = "kDYFEMTLAccelerationStructure_setPurgeableState";
        break;
      case 0xFFFFC2DF:
        result = "kDYFEMTLAccelerationStructure_waitUntilComplete";
        break;
      case 0xFFFFC2E0:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_setLabel";
        break;
      case 0xFFFFC2E1:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_buildAccelerationStructure_descriptor_scratchBuffer_scratchBufferOffset";
        break;
      case 0xFFFFC2E2:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_copyAccelerationStructure_toAccelerationStructure";
        break;
      case 0xFFFFC2E3:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_copyAndCompactAccelerationStructure_toAccelerationStructure";
        break;
      case 0xFFFFC2E4:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_dealloc";
        break;
      case 0xFFFFC2E5:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializeAccelerationStructure_fromBuffer_offset";
        break;
      case 0xFFFFC2E6:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_endEncoding";
        break;
      case 0xFFFFC2E7:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_insertDebugSignpost";
        break;
      case 0xFFFFC2E8:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_popDebugGroup";
        break;
      case 0xFFFFC2E9:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_pushDebugGroup";
        break;
      case 0xFFFFC2EA:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_refitAccelerationStructure_descriptor_destination_scratchBu"
                 "ffer_scratchBufferOffset";
        break;
      case 0xFFFFC2EB:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_sampleCountersInBuffer_atSampleIndex_withBarrier";
        break;
      case 0xFFFFC2EC:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_serializeAccelerationStructure_toBuffer_offset";
        break;
      case 0xFFFFC2ED:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_updateFence";
        break;
      case 0xFFFFC2EE:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_useHeap";
        break;
      case 0xFFFFC2EF:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_useHeaps_count";
        break;
      case 0xFFFFC2F0:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_useResource_usage";
        break;
      case 0xFFFFC2F1:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_useResources_count_usage";
        break;
      case 0xFFFFC2F2:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_waitForFence";
        break;
      case 0xFFFFC2F3:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeCompactedAccelerationStructureSize_toBuffer_offset";
        break;
      case 0xFFFFC2F4:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeSerializedAccelerationStructureSize_toBuffer_offset";
        break;
      case 0xFFFFC2F5:
        result = "kDYFEMTLArgumentEncoder_setAccelerationStructure_atIndex";
        break;
      case 0xFFFFC2F6:
        result = "kDYFEMTLArgumentEncoder_setFunctionTable_atIndex";
        break;
      case 0xFFFFC2F7:
        result = "kDYFEMTLArgumentEncoder_setFunctionTables_withRange";
        break;
      case 0xFFFFC2F8:
        result = "kDYFEMTLCommandQueue_getSPIStats";
        break;
      case 0xFFFFC2F9:
        result = "kDYFEMTLComputeCommandEncoder_setAccelerationStructure_atBufferIndex";
        break;
      case 0xFFFFC2FA:
        result = "kDYFEMTLComputeCommandEncoder_setFunctionTable_atIndex";
        break;
      case 0xFFFFC2FB:
        result = "kDYFEMTLComputeCommandEncoder_setFunctionTables_withRange";
        break;
      case 0xFFFFC2FC:
        result = "kDYFEMTLComputePipelineState_functionHandleWithFunction";
        break;
      case 0xFFFFC2FD:
        result = "kDYFEMTLComputePipelineState_functionHandlesWithFunctions";
        break;
      case 0xFFFFC2FE:
        result = "kDYFEMTLComputePipelineState_newComputePipelineStateWithAdditionalDynamicFunctions";
        break;
      case 0xFFFFC2FF:
        result = "kDYFEMTLDevice_compileVisibleFunction_withDescriptor_completionHandler";
        break;
      case 0xFFFFC300:
        result = "kDYFEMTLDevice_compileVisibleFunction_withDescriptor_error";
        break;
      case 0xFFFFC301:
        result = "kDYFEMTLDevice_newAccelerationStructureWithDescriptor";
        break;
      case 0xFFFFC302:
        result = "kDYFEMTLDevice_newAccelerationStructureWithSize";
        break;
      case 0xFFFFC303:
        result = "kDYFEMTLDevice_newDynamicLibraryWithURL_error";
        break;
      case 0xFFFFC304:
        result = "kDYFEMTLDevice_newVisibleFunctionTableWithDescriptor";
        break;
      case 0xFFFFC305:
        result = "kDYFEMTLDynamicLibrary_serializeToURL_options_error";
        break;
      case 0xFFFFC306:
        result = "kDYFEMTLFunctionHandle_dealloc";
        break;
      case 0xFFFFC307:
        result = "kDYFEMTLLibrary_newFunctionWithDescriptor_completionHandler";
        break;
      case 0xFFFFC308:
        result = "kDYFEMTLLibrary_newFunctionWithDescriptor_error";
        break;
      case 0xFFFFC309:
        result = "kDYFEMTLVisibleFunctionTable_setLabel";
        break;
      case 0xFFFFC30A:
        result = "kDYFEMTLVisibleFunctionTable_setResponsibleProcess";
        break;
      case 0xFFFFC30B:
        result = "kDYFEMTLVisibleFunctionTable_dealloc";
        break;
      case 0xFFFFC30C:
        result = "kDYFEMTLVisibleFunctionTable_doesAliasAllResources_count";
        break;
      case 0xFFFFC30D:
        result = "kDYFEMTLVisibleFunctionTable_doesAliasAnyResources_count";
        break;
      case 0xFFFFC30E:
        result = "kDYFEMTLVisibleFunctionTable_doesAliasResource";
        break;
      case 0xFFFFC30F:
        result = "kDYFEMTLVisibleFunctionTable_isAliasable";
        break;
      case 0xFFFFC310:
        result = "kDYFEMTLVisibleFunctionTable_isPurgeable";
        break;
      case 0xFFFFC311:
        result = "kDYFEMTLVisibleFunctionTable_makeAliasable";
        break;
      case 0xFFFFC312:
        result = "kDYFEMTLVisibleFunctionTable_setFunction_atIndex";
        break;
      case 0xFFFFC313:
        result = "kDYFEMTLVisibleFunctionTable_setFunctions_withRange";
        break;
      case 0xFFFFC314:
        result = "kDYFEMTLVisibleFunctionTable_setPurgeableState";
        break;
      case 0xFFFFC315:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializeAccelerationStructure_fromBuffer_serializedBufferOffset";
        break;
      case 0xFFFFC316:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializeAccelerationStructure_primitiveAccelerationStruc"
                 "tures_fromBuffer_serializedBufferOffset";
        break;
      case 0xFFFFC317:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_serializeAccelerationStructure_toBuffer_serializedBufferOffset";
        break;
      case 0xFFFFC318:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeDeserializedAccelerationStructureSize_serializedOffset"
                 "_toBuffer_sizeBufferOffset";
        break;
      case 0xFFFFC319:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeDeserializedPrimitiveAccelerationStructureSizes_serial"
                 "izedOffset_toBuffer_sizesBufferOffset";
        break;
      case 0xFFFFC31A:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeGeometryOfAccelerationStructure_toBuffer_geometryBufferOffset";
        break;
      case 0xFFFFC31B:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeGeometrySizeOfAccelerationStructure_toBuffer_sizeBufferOffset";
        break;
      case 0xFFFFC31C:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeSerializedAccelerationStructureSize_toBuffer_sizeBufferOffset";
        break;
      case 0xFFFFC31D:
        result = "kDYFEMTLCommandBuffer_blitCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC31E:
        result = "kDYFEMTLCommandBuffer_computeCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC31F:
        result = "kDYFEMTLCommandBuffer_resourceStateCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC320:
        result = "kDYFEMTLCommandBuffer_sampledComputeCommandEncoderWithDescriptor_programInfoBuffer_capacity";
        break;
      case 0xFFFFC321:
        result = "kDYFEMTLComputeCommandEncoder_setIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC322:
        result = "kDYFEMTLComputeCommandEncoder_setIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC323:
        result = "kDYFEMTLComputeCommandEncoder_setVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC324:
        result = "kDYFEMTLComputeCommandEncoder_setVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC325:
        result = "kDYFEMTLComputePipelineState_newComputePipelineStateWithAdditionalBinaryFunctions";
        break;
      case 0xFFFFC326:
        result = "kDYFEMTLComputePipelineState_newVisibleFunctionTableWithDescriptor";
        break;
      case 0xFFFFC327:
        result = "kDYFEMTLDevice_newIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC328:
        result = "kDYFEMTLDevice_supportsCounterSampling";
        break;
      case 0xFFFFC329:
        result = "kDYFEMTLDevice_supportsTextureWriteFPRoundingMode";
        break;
      case 0xFFFFC32A:
        result = "kDYFEMTLVisibleFunctionTable_setGlobalBuffer";
        break;
      case 0xFFFFC32B:
        result = "kDYFEMTLVisibleFunctionTable_setGlobalBufferOffset";
        break;
      case 0xFFFFC32C:
        result = "kDYFEMTLIntersectionFunctionTable_setGlobalBuffer";
        break;
      case 0xFFFFC32D:
        result = "kDYFEMTLIntersectionFunctionTable_setGlobalBufferOffset";
        break;
      case 0xFFFFC32E:
        result = "kDYFEMTLIntersectionFunctionTable_setLabel";
        break;
      case 0xFFFFC32F:
        result = "kDYFEMTLIntersectionFunctionTable_setResponsibleProcess";
        break;
      case 0xFFFFC330:
        result = "kDYFEMTLIntersectionFunctionTable_dealloc";
        break;
      case 0xFFFFC331:
        result = "kDYFEMTLIntersectionFunctionTable_doesAliasAllResources_count";
        break;
      case 0xFFFFC332:
        result = "kDYFEMTLIntersectionFunctionTable_doesAliasAnyResources_count";
        break;
      case 0xFFFFC333:
        result = "kDYFEMTLIntersectionFunctionTable_doesAliasResource";
        break;
      case 0xFFFFC334:
        result = "kDYFEMTLIntersectionFunctionTable_isAliasable";
        break;
      case 0xFFFFC335:
        result = "kDYFEMTLIntersectionFunctionTable_isComplete";
        break;
      case 0xFFFFC336:
        result = "kDYFEMTLIntersectionFunctionTable_isPurgeable";
        break;
      case 0xFFFFC337:
        result = "kDYFEMTLIntersectionFunctionTable_isWriteComplete";
        break;
      case 0xFFFFC338:
        result = "kDYFEMTLIntersectionFunctionTable_makeAliasable";
        break;
      case 0xFFFFC339:
        result = "kDYFEMTLIntersectionFunctionTable_setFunction_atIndex";
        break;
      case 0xFFFFC33A:
        result = "kDYFEMTLIntersectionFunctionTable_setFunctions_withRange";
        break;
      case 0xFFFFC33B:
        result = "kDYFEMTLIntersectionFunctionTable_setPurgeableState";
        break;
      case 0xFFFFC33C:
        result = "kDYFEMTLIntersectionFunctionTable_waitUntilComplete";
        break;
      case 0xFFFFC33D:
        result = "kDYFEMTLBinaryArchive_addComputePipelineFunctionsWithDescriptor_options_error";
        break;
      case 0xFFFFC33E:
        result = "kDYFEMTLBinaryArchive_addRenderPipelineFunctionsWithDescriptor_options_error";
        break;
      case 0xFFFFC33F:
        result = "kDYFEMTLBinaryArchive_addTileRenderPipelineFunctionsWithDescriptor_options_error";
        break;
      case 0xFFFFC340:
        result = "kDYFEMTLAccelerationStructure_setDescriptor";
        break;
      case 0xFFFFC341:
        result = "kDYFEMTLLibrary_newIntersectionFunctionWithDescriptor_completionHandler";
        break;
      case 0xFFFFC342:
        result = "kDYFEMTLLibrary_newIntersectionFunctionWithDescriptor_error";
        break;
      case 0xFFFFC343:
        result = "kDYFEMTLArgumentEncoder_setIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC344:
        result = "kDYFEMTLArgumentEncoder_setIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC345:
        result = "kDYFEMTLArgumentEncoder_setVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC346:
        result = "kDYFEMTLArgumentEncoder_setVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC347:
        result = "kDYFEMTLIntersectionFunctionTable_setBuffer_offset_atIndex";
        break;
      case 0xFFFFC348:
        result = "kDYFEMTLIntersectionFunctionTable_setBuffers_offsets_withRange";
        break;
      case 0xFFFFC349:
        result = "kDYFEMTLVisibleFunctionTable_setBuffer_offset_atIndex";
        break;
      case 0xFFFFC34A:
        result = "kDYFEMTLVisibleFunctionTable_setBuffers_offsets_withRange";
        break;
      case 0xFFFFC34B:
        result = "kDYFEMTLComputePipelineState_newComputePipelineStateWithAdditionalBinaryFunctions_error";
        break;
      case 0xFFFFC34C:
        result = "kDYFEMTLComputePipelineState_newIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC34D:
        result = "kDYFEMTLArgumentEncoder_setIntersectionFunctionTable_atIndex";
        break;
      case 0xFFFFC34E:
        result = "kDYFEMTLArgumentEncoder_setIntersectionFunctionTables_withRange";
        break;
      case 0xFFFFC34F:
        result = "kDYFEMTLArgumentEncoder_setVisibleFunctionTable_atIndex";
        break;
      case 0xFFFFC350:
        result = "kDYFEMTLArgumentEncoder_setVisibleFunctionTables_withRange";
        break;
      case 0xFFFFC351:
        result = "kDYFEMTLDevice_supportsTextureWriteRoundingMode";
        break;
      case 0xFFFFC352:
        result = "kDYFEMTLTexture_didModifyData";
        break;
      case 0xFFFFC353:
        result = "kDYFEMTLCommandBuffer_setSharedIndirectionTable";
        break;
      case 0xFFFFC354:
        result = "kDYFEMTLDevice_newPrecompiledRenderPipelineStateWithDescriptor_options_pipelineCache_completionHandler";
        break;
      case 0xFFFFC355:
        result = "kDYFEMTLDevice_newDynamicLibraryWithURL_options_error";
        break;
      case 0xFFFFC356:
        result = "kDYFEMTLIntersectionFunctionTable_setOpaqueTriangleIntersectionFunctionWithSignature_atIndex";
        break;
      case 0xFFFFC357:
        result = "kDYFEMTLIntersectionFunctionTable_setOpaqueTriangleIntersectionFunctionWithSignature_withRange";
        break;
      case 0xFFFFC358:
        result = "kDYFEMTLVisibleFunctionTable_setValue_atIndex";
        break;
      case 0xFFFFC359:
        result = "kDYFEMTLVisibleFunctionTable_setValue_withRange";
        break;
      case 0xFFFFC35A:
        result = "kDYFEMTLIntersectionFunctionTable_setVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC35B:
        result = "kDYFEMTLIntersectionFunctionTable_setVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC35C:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializeInstanceAccelerationStructure_primitiveAccelerat"
                 "ionStructures_fromBuffer_serializedBufferOffset";
        break;
      case 0xFFFFC35D:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializePrimitiveAccelerationStructure_fromBuffer_serial"
                 "izedBufferOffset";
        break;
      case 0xFFFFC35E:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_serializeInstanceAccelerationStructure_primitiveAcceleratio"
                 "nStructures_toBuffer_serializedBufferOffset";
        break;
      case 0xFFFFC35F:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_serializePrimitiveAccelerationStructure_toBuffer_serializedBufferOffset";
        break;
      case 0xFFFFC360:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeGenericBVHStructureOfAccelerationStructure_headerBuffe"
                 "r_headerBufferOffset_innerNodeBuffer_innerNodeBufferOffset_leafNodeBuffer_leafNodeBufferOffset_primitiv"
                 "eBuffer_primitiveBufferOffset";
        break;
      case 0xFFFFC361:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeGenericBVHStructureSizesOfAccelerationStructure_toBuff"
                 "er_sizesBufferOffset";
        break;
      case 0xFFFFC362:
        result = "kDYFEMTLComputeCommandEncoder_encodeEndDoWhile_offset_comparison_referenceValue";
        break;
      case 0xFFFFC363:
        result = "kDYFEMTLComputeCommandEncoder_encodeEndIf";
        break;
      case 0xFFFFC364:
        result = "kDYFEMTLComputeCommandEncoder_encodeEndWhile";
        break;
      case 0xFFFFC365:
        result = "kDYFEMTLComputeCommandEncoder_encodeStartDoWhile";
        break;
      case 0xFFFFC366:
        result = "kDYFEMTLComputeCommandEncoder_encodeStartElse";
        break;
      case 0xFFFFC367:
        result = "kDYFEMTLComputeCommandEncoder_encodeStartIf_offset_comparison_referenceValue";
        break;
      case 0xFFFFC368:
        result = "kDYFEMTLComputeCommandEncoder_encodeStartWhile_offset_comparison_referenceValue";
        break;
      case 0xFFFFC369:
        result = "kDYFEMTLComputeCommandEncoder_insertCompressedTextureReinterpretationFlush";
        break;
      case 0xFFFFC36A:
        result = "kDYFEMTLComputeCommandEncoder_useResourceGroup_usage";
        break;
      case 0xFFFFC36B:
        result = "kDYFEMTLDevice_newBufferWithDescriptor";
        break;
      case 0xFFFFC36C:
        result = "kDYFEMTLRelocation_dealloc";
        break;
      case 0xFFFFC36D:
        result = "kDYFEMTLRenderCommandEncoder_useResourceGroup_usage_stages";
        break;
      case 0xFFFFC36E:
        result = "kDYFEMTLDevice_newAccelerationStructureWithSize_resourceIndex";
        break;
      case 0xFFFFC36F:
        result = "kDYFEMTLBuffer_setParentGPUAddress";
        break;
      case 0xFFFFC370:
        result = "kDYFEMTLBuffer_setParentGPUSize";
        break;
      case 0xFFFFC371:
        result = "kDYFEMTLComputeCommandEncoder_insertUncompressedToCompressedFlush";
        break;
      case 0xFFFFC372:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeCompactedAccelerationStructureSize_toBuffer_offset_sizeDataType";
        break;
      case 0xFFFFC373:
        result = "kDYFEMTLCommandBuffer_encodeDashboardFinalizeForResourceGroup_dashboard_value_forIndex";
        break;
      case 0xFFFFC374:
        result = "kDYFEMTLCommandBuffer_encodeDashboardTagForResourceGroup";
        break;
      case 0xFFFFC375:
        result = "kDYFEMTLDevice_setPluginData";
        break;
      case 0xFFFFC376:
        result = "kDYFEMTLDevice_loadDynamicLibrariesForComputeDescriptor_options_error";
        break;
      case 0xFFFFC377:
        result = "kDYFEMTLDevice_loadDynamicLibrariesForFunction_insertLibraries_options_error";
        break;
      case 0xFFFFC378:
        result = "kDYFEMTLDevice_newLateEvalEvent";
        break;
      case 0xFFFFC379:
        result = "kDYFEMTLFunctionPointerHandle_dealloc";
        break;
      case 0xFFFFC37A:
        result = "kDYFEMTLFunctionPrivateArgument_dealloc";
        break;
      case 0xFFFFC37B:
        result = "kDYFEMTLFunctionStitchingAttribute_dealloc";
        break;
      case 0xFFFFC37C:
        result = "kDYFEMTLFunctionStitchingNode_dealloc";
        break;
      case 0xFFFFC37D:
        result = "kDYFEMTLLateEvalEvent_setLabel";
        break;
      case 0xFFFFC37E:
        result = "kDYFEMTLLateEvalEvent_setSignaledValue";
        break;
      case 0xFFFFC37F:
        result = "kDYFEMTLLateEvalEvent_dealloc";
        break;
      case 0xFFFFC380:
        result = "kDYFEMTLLateEvalEvent_newSharedEventHandle";
        break;
      case 0xFFFFC381:
        result = "kDYFEMTLLibrary_setShaderValidationEnabled";
        break;
      case 0xFFFFC382:
        result = "kDYFEMTLRenderCommandEncoder_dispatchThreadsPerTile_inRegion";
        break;
      case 0xFFFFC383:
        result = "kDYFEMTLRenderCommandEncoder_setMeshAccelerationStructure_atBufferIndex";
        break;
      case 0xFFFFC384:
        result = "kDYFEMTLRenderCommandEncoder_setMeshIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC385:
        result = "kDYFEMTLRenderCommandEncoder_setMeshIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC386:
        result = "kDYFEMTLRenderCommandEncoder_setMeshVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC387:
        result = "kDYFEMTLRenderCommandEncoder_setMeshVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC388:
        result = "kDYFEMTLRenderCommandEncoder_setObjectAccelerationStructure_atBufferIndex";
        break;
      case 0xFFFFC389:
        result = "kDYFEMTLRenderCommandEncoder_setObjectIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC38A:
        result = "kDYFEMTLRenderCommandEncoder_setObjectIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC38B:
        result = "kDYFEMTLRenderCommandEncoder_setObjectVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC38C:
        result = "kDYFEMTLRenderCommandEncoder_setObjectVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC38D:
        result = "kDYFEMTLDevice_compileVisibleFunction_withDescriptor_destinationBinaryArchive_error";
        break;
      case 0xFFFFC38E:
        result = "kDYFEMTLBlitCommandEncoder_fillBuffer_range_pattern4";
        break;
      case 0xFFFFC38F:
        result = "kDYFEMTLBlitCommandEncoder_fillTexture_level_slice_region_bytes_length";
        break;
      case 0xFFFFC390:
        result = "kDYFEMTLBlitCommandEncoder_fillTexture_level_slice_region_color";
        break;
      case 0xFFFFC391:
        result = "kDYFEMTLBlitCommandEncoder_fillTexture_level_slice_region_color_pixelFormat";
        break;
      case 0xFFFFC392:
        result = "kDYFEMTLBlitCommandEncoder_invalidateCompressedTexture";
        break;
      case 0xFFFFC393:
        result = "kDYFEMTLBlitCommandEncoder_invalidateCompressedTexture_slice_level";
        break;
      case 0xFFFFC394:
        result = "kDYFEMTLDevice_newLibraryWithGraphs_functions_error";
        break;
      case 0xFFFFC395:
        result = "kDYFEMTLDevice_newLibraryWithGraphsSPI_functions_error";
        break;
      case 0xFFFFC396:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializeInstanceAccelerationStructure_primitiveAccelerat"
                 "ionStructures_fromBuffer_serializedBufferOffset_withDescriptor";
        break;
      case 0xFFFFC397:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_deserializePrimitiveAccelerationStructure_fromBuffer_serial"
                 "izedBufferOffset_withDescriptor";
        break;
      case 0xFFFFC398:
        result = "kDYFEMTLDevice_newAccelerationStructureWithBuffer_offset";
        break;
      case 0xFFFFC399:
        result = "kDYFEMTLRenderPipelineState_functionHandleWithFunction_stage";
        break;
      case 0xFFFFC39A:
        result = "kDYFEMTLRenderPipelineState_newIntersectionFunctionTableWithDescriptor_stage";
        break;
      case 0xFFFFC39B:
        result = "kDYFEMTLRenderPipelineState_newRenderPipelineStateWithAdditionalBinaryFunctions_error";
        break;
      case 0xFFFFC39C:
        result = "kDYFEMTLRenderPipelineState_newVisibleFunctionTableWithDescriptor_stage";
        break;
      case 0xFFFFC39D:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentAccelerationStructure_atBufferIndex";
        break;
      case 0xFFFFC39E:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC39F:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC3A0:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC3A1:
        result = "kDYFEMTLRenderCommandEncoder_setFragmentVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC3A2:
        result = "kDYFEMTLRenderCommandEncoder_setTileAccelerationStructure_atBufferIndex";
        break;
      case 0xFFFFC3A3:
        result = "kDYFEMTLRenderCommandEncoder_setTileIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC3A4:
        result = "kDYFEMTLRenderCommandEncoder_setTileIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC3A5:
        result = "kDYFEMTLRenderCommandEncoder_setTileVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC3A6:
        result = "kDYFEMTLRenderCommandEncoder_setTileVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC3A7:
        result = "kDYFEMTLRenderCommandEncoder_setVertexAccelerationStructure_atBufferIndex";
        break;
      case 0xFFFFC3A8:
        result = "kDYFEMTLRenderCommandEncoder_setVertexIntersectionFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC3A9:
        result = "kDYFEMTLRenderCommandEncoder_setVertexIntersectionFunctionTables_withBufferRange";
        break;
      case 0xFFFFC3AA:
        result = "kDYFEMTLRenderCommandEncoder_setVertexVisibleFunctionTable_atBufferIndex";
        break;
      case 0xFFFFC3AB:
        result = "kDYFEMTLRenderCommandEncoder_setVertexVisibleFunctionTables_withBufferRange";
        break;
      case 0xFFFFC3AC:
        result = "kDYFEMTLRenderPipelineState_fragmentFunctionHandleWithFunction";
        break;
      case 0xFFFFC3AD:
        result = "kDYFEMTLRenderPipelineState_newFragmentIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC3AE:
        result = "kDYFEMTLRenderPipelineState_newTileIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC3AF:
        result = "kDYFEMTLRenderPipelineState_newVertexIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC3B0:
        result = "kDYFEMTLRenderPipelineState_newVisibleFunctionTableFromFragmentStageWithDescriptor";
        break;
      case 0xFFFFC3B1:
        result = "kDYFEMTLRenderPipelineState_newVisibleFunctionTableFromTileStageWithDescriptor";
        break;
      case 0xFFFFC3B2:
        result = "kDYFEMTLRenderPipelineState_newVisibleFunctionTableFromVertexStageWithDescriptor";
        break;
      case 0xFFFFC3B3:
        result = "kDYFEMTLRenderPipelineState_tileFunctionHandleWithFunction";
        break;
      case 0xFFFFC3B4:
        result = "kDYFEMTLRenderPipelineState_vertexFunctionHandleWithFunction";
        break;
      case 0xFFFFC3B5:
        result = "kDYFEMTLDevice_newLibraryWithDescriptor_error";
        break;
      case 0xFFFFC3B6:
        result = "kDYFEMTLDevice_newLibraryWithDescriptorSPI_error";
        break;
      case 0xFFFFC3B7:
        result = "kDYFEMTLDevice_getBVHBuilderLock";
        break;
      case 0xFFFFC3B8:
        result = "kDYFEMTLDevice_getRawBVHBuilderPtr";
        break;
      case 0xFFFFC3B9:
        result = "kDYFEMTLDevice_setRawBVHBuilderPtr";
        break;
      case 0xFFFFC3BA:
        result = "kDYFEMTLDevice_newFunctionWithGLCoreIR_functionType";
        break;
      case 0xFFFFC3BB:
        result = "kDYFEMTLDevice_newFunctionWithGLCoreIR_inputsDescription_functionType";
        break;
      case 0xFFFFC3BC:
        result = "kDYFEMTLDevice_newFunctionWithGLESIR_functionType";
        break;
      case 0xFFFFC3BD:
        result = "kDYFEMTLDevice_newFunctionWithGLESIR_inputsDescription_functionType";
        break;
      case 0xFFFFC3BE:
        result = "kDYFEMTLBinaryArchive_addLibraryWithDescriptor_error";
        break;
      case 0xFFFFC3BF:
        result = "kDYFEMTLDevice_newLibraryWithDescriptor_completionHandler";
        break;
      case 0xFFFFC3C0:
        result = "kDYFEMTLLateEvalEvent_waitUntilSignaledValue_timeoutMS";
        break;
      case 0xFFFFC3C1:
        result = "kDYFEMTLLibrary_serializeToURL_error";
        break;
      case 0xFFFFC3C2:
        result = "kDYFEMTLSharedEvent_waitUntilSignaledValue_timeoutMS";
        break;
      case 0xFFFFC3C3:
        result = "kDYFEMTLDevice_newLibraryWithStitchedDescriptor_completionHandler";
        break;
      case 0xFFFFC3C4:
        result = "kDYFEMTLDevice_newLibraryWithStitchedDescriptor_error";
        break;
      case 0xFFFFC3C5:
        result = "kDYFEMTLDevice_newLibraryWithStitchedDescriptorSPI_error";
        break;
      case 0xFFFFC3C6:
        result = "kDYFEMTLDevice_deserializeInstanceAccelerationStructureFromBytes_primitiveAccelerationStructures_withDescriptor";
        break;
      case 0xFFFFC3C7:
        result = "kDYFEMTLDevice_deserializePrimitiveAccelerationStructureFromBytes_withDescriptor";
        break;
      case 0xFFFFC3C8:
        result = "kDYFEMTLRenderCommandEncoder_drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup";
        break;
      case 0xFFFFC3C9:
        result = "kDYFEMTLRenderCommandEncoder_drawMeshThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerObje"
                 "ctThreadgroup_threadsPerMeshThreadgroup";
        break;
      case 0xFFFFC3CA:
        result = "kDYFEMTLRenderCommandEncoder_drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup";
        break;
      case 0xFFFFC3CB:
        result = "kDYFEMTLRenderPipelineState_setUsesMeshShaderEmulation";
        break;
      case 0xFFFFC3CC:
        result = "kDYFEMTLRasterizationRateMap_formattedDescription";
        break;
      case 0xFFFFC3CD:
        result = "kDYFEMTLRasterizationRateMap_resetUsingDescriptor";
        break;
      case 0xFFFFC3CE:
        result = "kDYFEMTLCommandBuffer_encodeDashboardFinalizeForResourceGroup_dashboard_values_indices_count";
        break;
      case 0xFFFFC3CF:
        result = "kDYFEMTLBinaryArchive_addMeshRenderPipelineFunctionsWithDescriptor_error";
        break;
      case 0xFFFFC3D0:
        result = "kDYFEMTLBinaryArchive_addMeshRenderPipelineFunctionsWithDescriptor_options_error";
        break;
      case 0xFFFFC3D1:
        result = "kDYFEMTLBinaryArchive_storeMeshRenderPipelineDescriptor";
        break;
      case 0xFFFFC3D2:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithMeshDescriptor_completionHandler";
        break;
      case 0xFFFFC3D3:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithMeshDescriptor_error";
        break;
      case 0xFFFFC3D4:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithMeshDescriptor_options_completionHandler";
        break;
      case 0xFFFFC3D5:
        result = "kDYFEMTLDevice_newRenderPipelineStateWithMeshDescriptor_options_reflection_error";
        break;
      case 0xFFFFC3D6:
        result = "kDYFEMTLDevice_writeMeshShaderEmulatorDataStructureHeader_meshShaderPSO_scalingFactor";
        break;
      case 0xFFFFC3D7:
        result = "kDYFEMTLRenderCommandEncoder_setMeshBuffer_offset_atIndex";
        break;
      case 0xFFFFC3D8:
        result = "kDYFEMTLRenderCommandEncoder_setMeshBufferOffset_atIndex";
        break;
      case 0xFFFFC3D9:
        result = "kDYFEMTLRenderCommandEncoder_setMeshBuffers_offsets_withRange";
        break;
      case 0xFFFFC3DA:
        result = "kDYFEMTLRenderCommandEncoder_setMeshBytes_length_atIndex";
        break;
      case 0xFFFFC3DB:
        result = "kDYFEMTLRenderCommandEncoder_setMeshSamplerState_atIndex";
        break;
      case 0xFFFFC3DC:
        result = "kDYFEMTLRenderCommandEncoder_setMeshSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC3DD:
        result = "kDYFEMTLRenderCommandEncoder_setMeshSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC3DE:
        result = "kDYFEMTLRenderCommandEncoder_setMeshSamplerStates_withRange";
        break;
      case 0xFFFFC3DF:
        result = "kDYFEMTLRenderCommandEncoder_setMeshTexture_atIndex";
        break;
      case 0xFFFFC3E0:
        result = "kDYFEMTLRenderCommandEncoder_setMeshTextures_withRange";
        break;
      case 0xFFFFC3E1:
        result = "kDYFEMTLRenderCommandEncoder_setObjectBuffer_offset_atIndex";
        break;
      case 0xFFFFC3E2:
        result = "kDYFEMTLRenderCommandEncoder_setObjectBufferOffset_atIndex";
        break;
      case 0xFFFFC3E3:
        result = "kDYFEMTLRenderCommandEncoder_setObjectBuffers_offsets_withRange";
        break;
      case 0xFFFFC3E4:
        result = "kDYFEMTLRenderCommandEncoder_setObjectBytes_length_atIndex";
        break;
      case 0xFFFFC3E5:
        result = "kDYFEMTLRenderCommandEncoder_setObjectSamplerState_atIndex";
        break;
      case 0xFFFFC3E6:
        result = "kDYFEMTLRenderCommandEncoder_setObjectSamplerState_lodMinClamp_lodMaxClamp_atIndex";
        break;
      case 0xFFFFC3E7:
        result = "kDYFEMTLRenderCommandEncoder_setObjectSamplerStates_lodMinClamps_lodMaxClamps_withRange";
        break;
      case 0xFFFFC3E8:
        result = "kDYFEMTLRenderCommandEncoder_setObjectSamplerStates_withRange";
        break;
      case 0xFFFFC3E9:
        result = "kDYFEMTLRenderCommandEncoder_setObjectTexture_atIndex";
        break;
      case 0xFFFFC3EA:
        result = "kDYFEMTLRenderCommandEncoder_setObjectTextures_withRange";
        break;
      case 0xFFFFC3EB:
        result = "kDYFEMTLRenderCommandEncoder_setObjectThreadgroupMemoryLength_atIndex";
        break;
      case 0xFFFFC3EC:
        result = "kDYFEMTLRenderPipelineState_setEmulationMeshMaxPrimitiveCount";
        break;
      case 0xFFFFC3ED:
        result = "kDYFEMTLRenderPipelineState_setEmulationMeshMaxVertexCount";
        break;
      case 0xFFFFC3EE:
        result = "kDYFEMTLRenderPipelineState_setEmulationMeshShaderIntermediateBufferSlot";
        break;
      case 0xFFFFC3EF:
        result = "kDYFEMTLRenderPipelineState_setEmulationMeshShaderPSO";
        break;
      case 0xFFFFC3F0:
        result = "kDYFEMTLRenderPipelineState_setEmulationMeshSize";
        break;
      case 0xFFFFC3F1:
        result = "kDYFEMTLRenderPipelineState_setEmulationObjectShaderIntermediateBufferSlot";
        break;
      case 0xFFFFC3F2:
        result = "kDYFEMTLRenderPipelineState_setEmulationObjectShaderPSO";
        break;
      case 0xFFFFC3F3:
        result = "kDYFEMTLRenderPipelineState_setEmulationVertexShaderIntermediateBufferSlot";
        break;
      case 0xFFFFC3F4:
        result = "kDYFEMTLRenderPipelineState_meshFunctionHandleWithFunction";
        break;
      case 0xFFFFC3F5:
        result = "kDYFEMTLRenderPipelineState_newMeshIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC3F6:
        result = "kDYFEMTLRenderPipelineState_newObjectIntersectionFunctionTableWithDescriptor";
        break;
      case 0xFFFFC3F7:
        result = "kDYFEMTLRenderPipelineState_newVisibleFunctionTableFromMeshStageWithDescriptor";
        break;
      case 0xFFFFC3F8:
        result = "kDYFEMTLRenderPipelineState_newVisibleFunctionTableFromObjectStageWithDescriptor";
        break;
      case 0xFFFFC3F9:
        result = "kDYFEMTLRenderPipelineState_objectFunctionHandleWithFunction";
        break;
      case 0xFFFFC3FA:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_refitAccelerationStructure_descriptor_destination_scratchBu"
                 "ffer_scratchBufferOffset_options";
        break;
      case 0xFFFFC3FB:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeAccelerationStructureSerializationData_toBuffer_offset";
        break;
      case 0xFFFFC3FC:
        result = "kDYFEMTLCommandBuffer_accelerationStructureCommandEncoderWithDescriptor";
        break;
      case 0xFFFFC3FD:
        result = "kDYFEMTLDevice_deserializeInstanceAccelerationStructure_fromBytes_primitiveAccelerationStructures_withDescriptor";
        break;
      case 0xFFFFC3FE:
        result = "kDYFEMTLDevice_deserializePrimitiveAccelerationStructure_fromBytes_withDescriptor";
        break;
      case 0xFFFFC3FF:
        result = "kDYFEMTLDevice_heapAccelerationStructureSizeAndAlignWithDescriptor";
        break;
      case 0xFFFFC400:
        result = "kDYFEMTLDevice_heapAccelerationStructureSizeAndAlignWithSize";
        break;
      case 0xFFFFC401:
        result = "kDYFEMTLDevice_newAccelerationStructureWithBuffer_offset_resourceIndex";
        break;
      case 0xFFFFC402:
        result = "kDYFEMTLDevice_newAccelerationStructureWithSize_withDescriptor";
        break;
      case 0xFFFFC403:
        result = "kDYFEMTLBuffer__aneIOSurface";
        break;
      case 0xFFFFC404:
        result = "kDYFEMTLHeap_newAccelerationStructureWithDescriptor";
        break;
      case 0xFFFFC405:
        result = "kDYFEMTLHeap_newAccelerationStructureWithDescriptor_offset";
        break;
      case 0xFFFFC406:
        result = "kDYFEMTLHeap_newAccelerationStructureWithSize";
        break;
      case 0xFFFFC407:
        result = "kDYFEMTLHeap_newAccelerationStructureWithSize_offset";
        break;
      case 0xFFFFC408:
        result = "kDYFEMTLHeap_newAccelerationStructureWithSize_offset_resourceIndex";
        break;
      case 0xFFFFC409:
        result = "kDYFEMTLHeap_newAccelerationStructureWithSize_resourceIndex";
        break;
      case 0xFFFFC40A:
        result = "kDYFEMTLDevice_newIOCommandQueueWithDescriptor_error";
        break;
      case 0xFFFFC40B:
        result = "kDYFEMTLDevice_newIOHandleWithURL_compressionType_error";
        break;
      case 0xFFFFC40C:
        result = "kDYFEMTLDevice_newIOHandleWithURL_error";
        break;
      case 0xFFFFC40D:
        result = "kDYFEMTLDevice_newPerformanceStateAssertion_error";
        break;
      case 0xFFFFC40E:
        result = "kDYFEMTLIOCommandBuffer_setStatus";
        break;
      case 0xFFFFC40F:
        result = "kDYFEMTLIOCommandBuffer_addCompletedHandler";
        break;
      case 0xFFFFC410:
        result = "kDYFEMTLIOCommandBuffer_barrier";
        break;
      case 0xFFFFC411:
        result = "kDYFEMTLIOCommandBuffer_commit";
        break;
      case 0xFFFFC412:
        result = "kDYFEMTLIOCommandBuffer_copyStatusToBuffer_offset";
        break;
      case 0xFFFFC413:
        result = "kDYFEMTLIOCommandBuffer_dealloc";
        break;
      case 0xFFFFC414:
        result = "kDYFEMTLIOCommandBuffer_encodeSignalEvent_value";
        break;
      case 0xFFFFC415:
        result = "kDYFEMTLIOCommandBuffer_encodeWaitForEvent_value";
        break;
      case 0xFFFFC416:
        result = "kDYFEMTLIOCommandBuffer_loadBuffer_offset_size_handle_handleOffset";
        break;
      case 0xFFFFC417:
        result = "kDYFEMTLIOCommandBuffer_loadTexture_slice_level_size_bytesPerRow_bytesPerImage_dstOrigin_handle_handleOffset";
        break;
      case 0xFFFFC418:
        result = "kDYFEMTLIOCommandBuffer_tryCancel";
        break;
      case 0xFFFFC419:
        result = "kDYFEMTLIOCommandBuffer_waitUntilCompleted";
        break;
      case 0xFFFFC41A:
        result = "kDYFEMTLIOCommandQueue_barrier";
        break;
      case 0xFFFFC41B:
        result = "kDYFEMTLIOCommandQueue_commandBuffer";
        break;
      case 0xFFFFC41C:
        result = "kDYFEMTLIOCommandQueue_dealloc";
        break;
      case 0xFFFFC41D:
        result = "kDYFEMTLIOScratchBuffer_dealloc";
        break;
      case 0xFFFFC41E:
        result = "kDYFEMTLIOScratchBufferAllocator_allocateScratchBufferWithMinimumSize";
        break;
      case 0xFFFFC41F:
        result = "kDYFEMTLIOScratchBufferAllocator_dealloc";
        break;
      case 0xFFFFC420:
        result = "kDYFEMTLIOHandle_dealloc";
        break;
      case 0xFFFFC421:
        result = "kDYFEMTLBinaryArchive_getArchiveIDWithError";
        break;
      case 0xFFFFC422:
        result = "kDYFEMTLCommandBuffer_presentDrawable_options";
        break;
      case 0xFFFFC423:
        result = "kDYFEMTLEvent_setEnableBarrier";
        break;
      case 0xFFFFC424:
        result = "kDYFEMTLLateEvalEvent_setEnableBarrier";
        break;
      case 0xFFFFC425:
        result = "kDYFEMTLLibrary_bitCodeListForFunctions";
        break;
      case 0xFFFFC426:
        result = "kDYFEMTLLibrary_bitCodeWithHash";
        break;
      case 0xFFFFC427:
        result = "kDYFEMTLSharedEvent_setEnableBarrier";
        break;
      case 0xFFFFC428:
        result = "kDYFEMTLDeadlineProfile_dealloc";
        break;
      case 0xFFFFC429:
        result = "kDYFEMTLRenderPipelineState_setEmulationPrimitiveTopology";
        break;
      case 0xFFFFC42A:
        result = "kDYFEMTLCommandBuffer_commitWithDeadline";
        break;
      case 0xFFFFC42B:
        result = "kDYFEMTLDevice_newProfileWithExecutionSize";
        break;
      case 0xFFFFC42C:
        result = "kDYFEMTLCommandBuffer_commitAndWaitUntilSubmittedWithDeadline";
        break;
      case 0xFFFFC42D:
        result = "kDYFEMTLDevice_sparseTileSizeInBytesForSparsePageSize";
        break;
      case 0xFFFFC42E:
        result = "kDYFEMTLDevice_sparseTileSizeWithTextureType_pixelFormat_sampleCount_sparsePageSize";
        break;
      case 0xFFFFC42F:
        result = "kDYFEMTLIOCommandBuffer_setLabel";
        break;
      case 0xFFFFC430:
        result = "kDYFEMTLIOCommandBuffer_enqueue";
        break;
      case 0xFFFFC431:
        result = "kDYFEMTLIOCommandBuffer_loadBuffer_offset_size_sourceHandle_sourceHandleOffset";
        break;
      case 0xFFFFC432:
        result = "kDYFEMTLIOCommandBuffer_loadTexture_slice_level_size_sourceBytesPerRow_sourceBytesPerImage_destinationO"
                 "rigin_sourceHandle_sourceHandleOffset";
        break;
      case 0xFFFFC433:
        result = "kDYFEMTLIOCommandBuffer_signalEvent_value";
        break;
      case 0xFFFFC434:
        result = "kDYFEMTLIOCommandBuffer_waitForEvent_value";
        break;
      case 0xFFFFC435:
        result = "kDYFEMTLIOCommandQueue_setLabel";
        break;
      case 0xFFFFC436:
        result = "kDYFEMTLIOCommandQueue_commandBufferWithUnretainedReferences";
        break;
      case 0xFFFFC437:
        result = "kDYFEMTLIOHandle_setLabel";
        break;
      case 0xFFFFC438:
        result = "kDYFEMTLIOHandle_decompress_size_offset_stagingBuffer_stagingBufferSize";
        break;
      case 0xFFFFC439:
        result = "kDYFEMTLIOHandle_getHandleOffset_offset";
        break;
      case 0xFFFFC43A:
        result = "kDYFEMTLIOHandle_read_size_offset_stagingBuffer_stagingBufferSize";
        break;
      case 0xFFFFC43B:
        result = "kDYFEMTLIOHandle_readIntoStagingBuffer_offset_stagingBuffer_stagingBufferSize";
        break;
      case 0xFFFFC43C:
        result = "kDYFEMTLIOHandle_stagingBufferSize_offset";
        break;
      case 0xFFFFC43D:
        result = "kDYFEMTLIOScratchBufferAllocator_newScratchBufferWithMinimumSize";
        break;
      case 0xFFFFC43E:
        result = "kDYFEMTLDevice_getMostCompatibleArchitecture";
        break;
      case 0xFFFFC43F:
        result = "kDYFEMTLRenderCommandEncoder_dispatchThreadsPerTile_inRegion_withRenderTargetArrayIndex";
        break;
      case 0xFFFFC440:
        result = "kDYFEMTLDevice_newIOHandleWithURL_compressionMethod_error";
        break;
      case 0xFFFFC441:
        result = "kDYFEMTLIOCommandBuffer_addBarrier";
        break;
      case 0xFFFFC442:
        result = "kDYFEMTLIOCommandBuffer_loadBytes_size_sourceHandle_sourceHandleOffset";
        break;
      case 0xFFFFC443:
        result = "kDYFEMTLIOCommandBuffer_popDebugGroup";
        break;
      case 0xFFFFC444:
        result = "kDYFEMTLIOCommandBuffer_pushDebugGroup";
        break;
      case 0xFFFFC445:
        result = "kDYFEMTLIOCommandQueue_enqueueBarrier";
        break;
      case 0xFFFFC446:
        result = "kDYFEMTLIOFileHandle_setLabel";
        break;
      case 0xFFFFC447:
        result = "kDYFEMTLIOFileHandle_dealloc";
        break;
      case 0xFFFFC448:
        result = "kDYFEMTLRenderPipelineState_setEmulationPayloadMemoryLength";
        break;
      case 0xFFFFC449:
        result = "kDYFEMTLAccelerationStructureCommandEncoder_writeAccelerationStructureTraversalDepth_toBuffer_offset";
        break;
      case 0xFFFFC44A:
        result = "kDYFEMTLCommandBuffer_encodeConditionalAbortEvent";
        break;
      case 0xFFFFC44B:
        result = "kDYFEMTLCommandBuffer_encodeSignalEvent_value_agentMask";
        break;
      case 0xFFFFC44C:
        result = "kDYFEMTLComputeCommandEncoder_setBuffer_offset_attributeStride_atIndex";
        break;
      case 0xFFFFC44D:
        result = "kDYFEMTLComputeCommandEncoder_setBufferOffset_attributeStride_atIndex";
        break;
      case 0xFFFFC44E:
        result = "kDYFEMTLComputeCommandEncoder_setBuffers_offsets_attributeStrides_withRange";
        break;
      case 0xFFFFC44F:
        result = "kDYFEMTLComputeCommandEncoder_setBytes_length_attributeStride_atIndex";
        break;
      case 0xFFFFC450:
        result = "kDYFEMTLComputeCommandEncoder_setThreadgroupDistributionMode";
        break;
      case 0xFFFFC451:
        result = "kDYFEMTLComputeCommandEncoder_setThreadgroupDistributionModeWithClusterGroupIndex";
        break;
      case 0xFFFFC452:
        result = "kDYFEMTLComputeCommandEncoder_setThreadgroupPackingDisabled";
        break;
      case 0xFFFFC453:
        result = "kDYFEMTLIndirectComputeCommand_setKernelBuffer_offset_attributeStride_atIndex";
        break;
      case 0xFFFFC454:
        result = "kDYFEMTLIndirectRenderCommand_setVertexBuffer_offset_attributeStride_atIndex";
        break;
      case 0xFFFFC455:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBuffer_offset_attributeStride_atIndex";
        break;
      case 0xFFFFC456:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBufferOffset_attributeStride_atIndex";
        break;
      case 0xFFFFC457:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBuffers_offsets_attributeStrides_withRange";
        break;
      case 0xFFFFC458:
        result = "kDYFEMTLRenderCommandEncoder_setVertexBytes_length_attributeStride_atIndex";
        break;
      case 0xFFFFC459:
        result = "kDYFEMTLResourceStateCommandEncoder_moveTextureMappingsFromTexture_sourceSlice_sourceLevel_sourceOrigin"
                 "_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin";
        break;
      case 0xFFFFC45A:
        result = "kDYFEMTLDevice_setShouldMaximizeConcurrentCompilation";
        break;
      case 0xFFFFC45B:
        result = "kDYFEMTLDevice_newEventWithOptions";
        break;
      case 0xFFFFC45C:
        result = "kDYFEMTLDevice_newSharedEventWithOptions";
        break;
      case 0xFFFFC45D:
        result = "kDYFEMTLDevice_setCompilerProcessesCount";
        break;
      case 0xFFFFC45E:
        result = "kDYFEMTLIndirectRenderCommand_drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup";
        break;
      case 0xFFFFC45F:
        result = "kDYFEMTLIndirectRenderCommand_drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup";
        break;
      case 0xFFFFC460:
        result = "kDYFEMTLIndirectRenderCommand_setMeshBuffer_offset_atIndex";
        break;
      case 0xFFFFC461:
        result = "kDYFEMTLIndirectRenderCommand_setObjectBuffer_offset_atIndex";
        break;
      case 0xFFFFC462:
        result = "kDYFEMTLIndirectRenderCommand_setObjectThreadgroupMemoryLength_atIndex";
        break;
      case 0xFFFFC463:
        result = "kDYFEMTLDevice_newArgumentEncoderWithBufferBinding";
        break;
      case 0xFFFFC464:
        result = "kDYFEMTLDevice_newIOFileHandleWithURL_compressionMethod_error";
        break;
      case 0xFFFFC465:
        result = "kDYFEMTLDevice_newIOFileHandleWithURL_error";
        break;
      case 0xFFFFC466:
        result = "kDYFEMTLIntersectionFunctionTable_setOpaqueCurveIntersectionFunctionWithSignature_atIndex";
        break;
      case 0xFFFFC467:
        result = "kDYFEMTLIntersectionFunctionTable_setOpaqueCurveIntersectionFunctionWithSignature_withRange";
        break;
      case 0xFFFFC468:
        result = "kDYFEMTLCommandBuffer_setPrivateLoggingBuffer";
        break;
      case 0xFFFFC469:
        result = "kDYFEMTLCommandBuffer_setResponsibleTaskIDs_count";
        break;
      case 0xFFFFC46A:
        result = "kDYFEMTLCommandBuffer_useResidencySet";
        break;
      case 0xFFFFC46B:
        result = "kDYFEMTLCommandBuffer_useResidencySets_count";
        break;
      case 0xFFFFC46C:
        result = "kDYFEMTLCommandQueue_addResidencySet";
        break;
      case 0xFFFFC46D:
        result = "kDYFEMTLCommandQueue_addResidencySets_count";
        break;
      case 0xFFFFC46E:
        result = "kDYFEMTLCommandQueue_removeResidencySet";
        break;
      case 0xFFFFC46F:
        result = "kDYFEMTLCommandQueue_removeResidencySets_count";
        break;
      case 0xFFFFC470:
        result = "kDYFEMTLComputeCommandEncoder_useResidencySet";
        break;
      case 0xFFFFC471:
        result = "kDYFEMTLComputeCommandEncoder_useResidencySets_count";
        break;
      case 0xFFFFC472:
        result = "kDYFEMTLDevice_setWritableHeapsEnabled";
        break;
      case 0xFFFFC473:
        result = "kDYFEMTLDevice_newResidencySetWithDescriptor_error";
        break;
      case 0xFFFFC474:
        result = "kDYFEMTLRenderCommandEncoder_useResidencySet";
        break;
      case 0xFFFFC475:
        result = "kDYFEMTLRenderCommandEncoder_useResidencySets_count";
        break;
      case 0xFFFFC476:
        result = "kDYFEMTLResidencySet_addHeap";
        break;
      case 0xFFFFC477:
        result = "kDYFEMTLResidencySet_addHeaps_count";
        break;
      case 0xFFFFC478:
        result = "kDYFEMTLResidencySet_addResource";
        break;
      case 0xFFFFC479:
        result = "kDYFEMTLResidencySet_addResources_count";
        break;
      case 0xFFFFC47A:
        result = "kDYFEMTLResidencySet_commitAdds";
        break;
      case 0xFFFFC47B:
        result = "kDYFEMTLResidencySet_commitRemoves";
        break;
      case 0xFFFFC47C:
        result = "kDYFEMTLResidencySet_commitResidency";
        break;
      case 0xFFFFC47D:
        result = "kDYFEMTLResidencySet_containsHeap";
        break;
      case 0xFFFFC47E:
        result = "kDYFEMTLResidencySet_containsResource";
        break;
      case 0xFFFFC47F:
        result = "kDYFEMTLResidencySet_countForHeap";
        break;
      case 0xFFFFC480:
        result = "kDYFEMTLResidencySet_countForResource";
        break;
      case 0xFFFFC481:
        result = "kDYFEMTLResidencySet_dealloc";
        break;
      case 0xFFFFC482:
        result = "kDYFEMTLResidencySet_endResidency";
        break;
      case 0xFFFFC483:
        result = "kDYFEMTLResidencySet_removeAllHeaps";
        break;
      case 0xFFFFC484:
        result = "kDYFEMTLResidencySet_removeAllResources";
        break;
      case 0xFFFFC485:
        result = "kDYFEMTLResidencySet_removeHeap";
        break;
      case 0xFFFFC486:
        result = "kDYFEMTLResidencySet_removeHeaps_count";
        break;
      case 0xFFFFC487:
        result = "kDYFEMTLResidencySet_removeResource";
        break;
      case 0xFFFFC488:
        result = "kDYFEMTLResidencySet_removeResources_count";
        break;
      case 0xFFFFC489:
        result = "kDYFEMTLResidencySet_requestResidency";
        break;
      case 0xFFFFC48A:
        result = "kDYFEMTLResidencySet_setCurrentGeneration";
        break;
      case 0xFFFFC48B:
        result = "kDYFEMTLResidencySet_setExpiredGeneration";
        break;
      case 0xFFFFC48C:
        result = "kDYFEMTLResidencySet_commit";
        break;
      case 0xFFFFC48D:
        result = "kDYFEMTLResidencySet_generationForHeap";
        break;
      case 0xFFFFC48E:
        result = "kDYFEMTLResidencySet_generationForResource";
        break;
      case 0xFFFFC48F:
        result = "kDYFEMTLCommandBuffer_encodeSignalEventScheduled_value";
        break;
      case 0xFFFFC490:
        result = "kDYFEMTLCommandBuffer_setPrivateData";
        break;
      case 0xFFFFC491:
        result = "kDYFEMTLCommandBuffer_setPrivateDataOffset";
        break;
      case 0xFFFFC492:
        result = "kDYFEMTLDevice_newLogStateWithDescriptor_error";
        break;
      case 0xFFFFC493:
        result = "kDYFEMTLLogState_dealloc";
        break;
      case 0xFFFFC494:
        result = "kDYFEMTLResidencySet_addAllocation";
        break;
      case 0xFFFFC495:
        result = "kDYFEMTLResidencySet_addAllocations_count";
        break;
      case 0xFFFFC496:
        result = "kDYFEMTLResidencySet_containsAllocation";
        break;
      case 0xFFFFC497:
        result = "kDYFEMTLResidencySet_generationForAllocation";
        break;
      case 0xFFFFC498:
        result = "kDYFEMTLResidencySet_removeAllAllocations";
        break;
      case 0xFFFFC499:
        result = "kDYFEMTLResidencySet_removeAllocation";
        break;
      case 0xFFFFC49A:
        result = "kDYFEMTLResidencySet_removeAllocations_count";
        break;
      default:
        if ((_DWORD)this != -18430)
          goto LABEL_1384;
        result = "kDYFEMTLFXTemporalScaler_executionMode";
        break;
    }
  }
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumConstructor(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  v1 = (int)this;
  result = 1;
  if (v1 <= -15716)
  {
    if (v1 <= -16054)
    {
      if (v1 <= -16234)
      {
        switch(v1)
        {
          case -16354:
          case -16353:
          case -16352:
          case -16351:
          case -16343:
          case -16342:
          case -16316:
          case -16315:
          case -16314:
          case -16313:
          case -16312:
          case -16311:
          case -16310:
          case -16309:
          case -16308:
          case -16307:
          case -16306:
          case -16305:
          case -16304:
          case -16303:
          case -16302:
          case -16301:
          case -16300:
          case -16299:
          case -16298:
          case -16297:
          case -16296:
          case -16294:
          case -16290:
          case -16286:
            return result;
          case -16350:
          case -16349:
          case -16348:
          case -16347:
          case -16346:
          case -16345:
          case -16344:
          case -16341:
          case -16340:
          case -16339:
          case -16338:
          case -16337:
          case -16336:
          case -16335:
          case -16334:
          case -16333:
          case -16332:
          case -16331:
          case -16330:
          case -16329:
          case -16328:
          case -16327:
          case -16326:
          case -16325:
          case -16324:
          case -16323:
          case -16322:
          case -16321:
          case -16320:
          case -16319:
          case -16318:
          case -16317:
          case -16295:
          case -16293:
          case -16292:
          case -16291:
          case -16289:
          case -16288:
          case -16287:
            return 0;
          default:
            if ((v1 + 18432) < 2)
              return result;
            v7 = -16368;
            break;
        }
LABEL_49:
        if (v1 == v7)
          return result;
        return 0;
      }
      if (((v1 + 16128) > 0x35 || ((1 << v1) & 0x20C1E369601901) == 0)
        && ((v1 + 16200) > 0x31 || ((1 << (v1 + 72)) & 0x200280000001FLL) == 0))
      {
        v7 = -16233;
        goto LABEL_49;
      }
      return result;
    }
    if (v1 <= -15915)
    {
      if ((v1 + 16053) <= 0x39 && ((1 << (v1 - 75)) & 0x30001E801C1C03FLL) != 0)
        return result;
      v8 = v1 + 15981;
      if (v8 > 0x3C)
        return 0;
      v4 = 1 << v8;
      v5 = 0x1800000000001207;
    }
    else
    {
      if ((v1 + 15851) <= 0x3A && ((1 << (v1 - 21)) & 0x400002000E0007FLL) != 0
        || (v1 + 15778) <= 0x3D && ((1 << (v1 - 94)) & 0x2001B1400000005BLL) != 0)
      {
        return result;
      }
      v6 = v1 + 15914;
      if (v6 > 0x2C)
        return 0;
      v4 = 1 << v6;
      v5 = 0x10000080C027;
    }
LABEL_34:
    if ((v4 & v5) != 0)
      return result;
    return 0;
  }
  if (v1 <= -15372)
  {
    if (v1 > -15469)
    {
      switch(v1)
      {
        case -15468:
        case -15467:
        case -15464:
        case -15463:
        case -15462:
        case -15461:
        case -15460:
        case -15444:
        case -15443:
        case -15442:
        case -15441:
        case -15440:
        case -15439:
        case -15438:
        case -15437:
        case -15436:
        case -15435:
        case -15434:
        case -15430:
        case -15429:
        case -15428:
        case -15427:
        case -15425:
        case -15421:
        case -15420:
        case -15419:
        case -15418:
        case -15417:
        case -15406:
        case -15405:
        case -15404:
        case -15403:
          return result;
        default:
          return 0;
      }
      return result;
    }
    if ((v1 + 15715) <= 0x2D && ((1 << (v1 + 99)) & 0x24000E7C4703) != 0
      || (v1 + 15620) <= 0x2B && ((1 << (v1 + 4)) & 0xE1E000018E5) != 0)
    {
      return result;
    }
    v3 = v1 + 15551;
    if (v3 > 0x37)
      return 0;
    v4 = 1 << v3;
    v5 = 0x80240000180C03;
    goto LABEL_34;
  }
  if (v1 > -12545)
  {
    if (v1 <= -6656)
    {
      if ((v1 + 12544) >= 2 && (v1 + 7167) >= 2)
      {
        v7 = -10237;
        goto LABEL_49;
      }
    }
    else if ((v1 + 6143) > 0x30 || ((1 << (v1 - 1)) & 0x1800709205605) == 0)
    {
      v7 = -6655;
      goto LABEL_49;
    }
  }
  else if (((v1 + 15371) > 0x36 || ((1 << (v1 + 11)) & 0x40004000FFB08FLL) == 0)
         && ((v1 + 15306) > 0x3D || ((1 << (v1 - 54)) & 0x2000E06000000481) == 0))
  {
    v7 = -15214;
    goto LABEL_49;
  }
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumDestructor(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;

  v1 = (int)this;
  result = 1;
  if (v1 > -15802)
  {
    if (v1 <= -15509)
    {
      if ((v1 + 15706) <= 0x3E && ((1 << (v1 + 90)) & 0x400080008420C011) != 0
        || (v1 + 15801) <= 0x3B && ((1 << (v1 - 71)) & 0x922000100000801) != 0)
      {
        return result;
      }
      v9 = v1 + 15610;
      if (v9 <= 0x2A)
      {
        v6 = 1 << v9;
        v7 = 0x40000000021;
LABEL_40:
        if ((v6 & v7) != 0)
          return result;
        return 0;
      }
      return 0;
    }
    if (v1 <= -15232)
    {
      if ((v1 + 15341) > 0x34 || ((1 << (v1 - 19)) & 0x10000000203601) == 0)
      {
        v4 = v1 + 15508;
        if (v4 > 0x13 || ((1 << v4) & 0x9E001) == 0)
          return 0;
      }
      return result;
    }
    if (v1 > -7162)
    {
      if (v1 == -7161 || v1 == -6652)
        return result;
      v3 = -6139;
    }
    else
    {
      if (v1 == -15231 || v1 == -15213)
        return result;
      v3 = -10206;
    }
LABEL_45:
    if (v1 == v3)
      return result;
    return 0;
  }
  if (v1 > -16128)
  {
    if (v1 > -15983)
    {
      if ((v1 + 15893) <= 0x2B && ((1 << (v1 + 21)) & 0x8000C004011) != 0)
        return result;
      v5 = v1 + 15982;
      if (v5 <= 0x3B)
      {
        v6 = 1 << v5;
        v7 = 0x800800002000201;
        goto LABEL_40;
      }
      return 0;
    }
    if (((v1 + 16127) > 0x37 || ((1 << (v1 - 1)) & 0x80000040000201) == 0)
      && v1 != -16062)
    {
      v3 = -16030;
      goto LABEL_45;
    }
  }
  else
  {
    if (v1 > -16318)
    {
      if ((v1 + 16317) <= 0x25 && ((1 << (v1 - 67)) & 0x2045000001) != 0)
        return result;
      v8 = v1 + 16242;
      if (v8 <= 0x31)
      {
        v6 = 1 << v8;
        v7 = 0x2000000000013;
        goto LABEL_40;
      }
      return 0;
    }
    if (((v1 + 0x3FFF) > 0x3F || ((1 << (v1 - 1)) & 0xC000208000102001) == 0)
      && v1 != -20475)
    {
      v3 = -20458;
      goto LABEL_45;
    }
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumDrawCall(GPUTools::MTL *this)
{
  int v1;
  _BOOL8 result;

  v1 = (int)this;
  result = 1;
  if (((v1 + 16251) > 0x24 || ((1 << (v1 + 123)) & 0x1E0000000FLL) == 0)
    && ((v1 + 16173) > 0x1D || ((1 << (v1 + 45)) & 0x3C000007) == 0))
  {
    return (v1 + 15416) < 3;
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumIndirectDrawCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 15953) <= 0xB && ((1 << ((_BYTE)this + 81)) & 0xC3F) != 0
      || ((_DWORD)this + 15266) < 2;
}

BOOL GPUTools::MTL::IsFuncEnumIOCall(GPUTools::MTL *this)
{
  int v1;
  _BOOL8 result;

  v1 = (int)this;
  result = 1;
  if ((v1 + 15346) > 0x37 || ((1 << (v1 - 14)) & 0xF801FE00007FFFLL) == 0)
    return v1 == -12543;
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumCommitIOCommandBuffer(GPUTools::MTL *this)
{
  return (_DWORD)this == -15343;
}

BOOL GPUTools::MTL::IsFuncEnumComputeCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 16079) < 2 || (_DWORD)this == -16327 || (_DWORD)this == -16220;
}

BOOL GPUTools::MTL::IsFuncEnumIndirectComputeCall(GPUTools::MTL *this)
{
  return (_DWORD)this == -15932;
}

BOOL GPUTools::MTL::IsFuncEnumTileCall(GPUTools::MTL *this)
{
  _BOOL4 v1;

  v1 = (_DWORD)this == -15486 || (_DWORD)this == -15297;
  return (_DWORD)this == -16137 || v1;
}

uint64_t GPUTools::MTL::IsFuncEnumBlitCall(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;

  v1 = (int)this;
  result = 1;
  if (v1 <= -15879)
  {
    if (((v1 + 15995) > 0x25 || ((1 << (v1 + 123)) & 0x38000C000FLL) == 0)
      && (v1 + 16382) >= 6
      && (v1 + 16213) >= 5)
    {
      return 0;
    }
  }
  else if ((v1 + 15474) >= 6 && (v1 + 15878) >= 2 && (v1 + 15756) >= 2)
  {
    return 0;
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumSampledBlitCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 16382) < 6
      || ((_DWORD)this + 16210) < 2
      || ((_DWORD)this + 15878) < 2;
}

BOOL GPUTools::MTL::IsFuncEnumSampledBlitCallAGX(GPUTools::MTL *this)
{
  int v1;
  _BOOL8 result;

  v1 = (int)this;
  result = 1;
  if (((v1 + 15995) > 0x25 || ((1 << (v1 + 123)) & 0x38000C000FLL) == 0)
    && ((v1 + 15802) > 4 || ((1 << (v1 - 70)) & 0x15) == 0))
  {
    return (v1 + 15470) < 2;
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumResourceCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 15784) < 3;
}

BOOL GPUTools::MTL::IsFuncEnumVideoCall(GPUTools::MTL *this)
{
  return (_DWORD)this == -15887;
}

BOOL GPUTools::MTL::IsFuncEnumAccelerationEncodeCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 15647) <= 0x13 && ((1 << ((_BYTE)this + 31)) & 0xC0207) != 0
      || ((_DWORD)this + 15366) < 2;
}

BOOL GPUTools::MTL::IsFuncEnumSampleCall(GPUTools::MTL *this)
{
  int v1;
  _BOOL8 result;

  v1 = (int)this;
  result = 1;
  if (((v1 + 15876) > 0x35 || ((1 << (v1 + 4)) & 0x20005000000083) == 0)
    && ((v1 + 15756) > 6 || ((1 << (v1 - 116)) & 0x47) == 0))
  {
    return v1 == -15637;
  }
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumPushDebugGroup(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  int v3;

  v1 = (int)this;
  result = 1;
  if (v1 > -16066)
  {
    if (v1 <= -15787)
    {
      if (v1 == -16065)
        return result;
      v3 = -15882;
      goto LABEL_14;
    }
    if (v1 != -15786 && v1 != -15639)
    {
      v3 = -15292;
LABEL_14:
      if (v1 != v3)
        return 0;
    }
  }
  else
  {
    if (v1 <= -16284)
    {
      if (v1 == -16374)
        return result;
      v3 = -16323;
      goto LABEL_14;
    }
    if (v1 != -16283 && v1 != -16244)
    {
      v3 = -16168;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumPopDebugGroup(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  int v3;

  v1 = (int)this;
  result = 1;
  if (v1 > -16065)
  {
    if (v1 <= -15788)
    {
      if (v1 == -16064)
        return result;
      v3 = -15881;
      goto LABEL_14;
    }
    if (v1 != -15787 && v1 != -15640)
    {
      v3 = -15293;
LABEL_14:
      if (v1 != v3)
        return 0;
    }
  }
  else
  {
    if (v1 <= -16283)
    {
      if (v1 == -16373)
        return result;
      v3 = -16322;
      goto LABEL_14;
    }
    if (v1 != -16282 && v1 != -16243)
    {
      v3 = -16167;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumSetLabel(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  v1 = (int)this;
  result = 1;
  if (v1 > -15926)
  {
    if (v1 > -15608)
    {
      if (v1 > -15314)
      {
        v6 = v1 + 15313;
        if (v6 > 0x17 || ((1 << v6) & 0x800141) == 0)
          return 0;
        return result;
      }
      if (v1 == -15607 || v1 == -15570)
        return result;
      v7 = -15491;
      goto LABEL_31;
    }
    if (v1 <= -15684)
    {
      if ((v1 + 15925) <= 0x2D && ((1 << (v1 + 53)) & 0x200800000001) != 0
        || v1 == -15794)
      {
        return result;
      }
      v7 = -15743;
      goto LABEL_31;
    }
    v8 = v1 + 15683;
    if (v8 <= 0x23)
    {
      v4 = 1 << v8;
      v5 = 0x800408081;
LABEL_22:
      if ((v4 & v5) == 0)
        return 0;
      return result;
    }
    return 0;
  }
  if (v1 <= -16195)
  {
    if ((v1 + 0x4000) <= 0x2D && ((1 << v1) & 0x200800081001) != 0)
      return result;
    v3 = v1 + 16292;
    if (v3 <= 0x34)
    {
      v4 = 1 << v3;
      v5 = 0x10000000000811;
      goto LABEL_22;
    }
    return 0;
  }
  if (v1 <= -16124)
  {
    if (v1 == -16194)
      return result;
    v7 = -16136;
  }
  else
  {
    if ((v1 + 16123) <= 0x3C && ((1 << (v1 - 5)) & 0x1004000000000011) != 0)
      return result;
    v7 = -15974;
  }
LABEL_31:
  if (v1 != v7)
    return 0;
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumEndEncoding(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  int v3;

  v1 = (int)this;
  result = 1;
  if (v1 > -16171)
  {
    if (v1 > -15790)
    {
      if (v1 == -15789)
        return result;
      v3 = -15642;
    }
    else
    {
      if (v1 == -16170)
        return result;
      v3 = -15884;
    }
  }
  else if (v1 > -16286)
  {
    if (v1 == -16285)
      return result;
    v3 = -16246;
  }
  else
  {
    if (v1 == -16376)
      return result;
    v3 = -16325;
  }
  if (v1 != v3)
    return 0;
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumEncodeSignalEvent(GPUTools::MTL *this)
{
  int v1;
  _BOOL8 result;

  v1 = (int)this;
  result = 1;
  if ((v1 + 15340) > 0x37 || ((1 << (v1 - 20)) & 0x80000080000001) == 0)
    return v1 == -15990 || v1 == -15217;
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumEncodeWaitForEvent(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  int v3;

  v1 = (int)this;
  result = 1;
  if (v1 > -15340)
  {
    if (v1 == -15339)
      return result;
    v3 = -15308;
  }
  else
  {
    if (v1 == -15991)
      return result;
    v3 = -15749;
  }
  if (v1 != v3)
    return 0;
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumVRSubmitCall(GPUTools::MTL *this)
{
  return (_DWORD)this == -16034;
}

uint64_t GPUTools::MTL::IsFuncEnumIndirectExecuteCall(GPUTools::MTL *this)
{
  return (((_DWORD)this + 16005) < 0x2D) & (0x1F0000000001uLL >> (this - 123));
}

uint64_t GPUTools::MTL::IsFuncEnumIndirectExecuteDrawCall(GPUTools::MTL *this)
{
  return (((_DWORD)this + 16005) < 0x2D) & (0x180000000001uLL >> (this - 123));
}

BOOL GPUTools::MTL::IsFuncEnumIndirectExecuteComputeCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 15965) < 3;
}

uint64_t GPUTools::MTL::IsFuncEnumMPSEncodeCall(GPUTools::MTL *this)
{
  return (((_DWORD)this + 6144) < 0x30) & (0x8BF1EC9D5395uLL >> (char)this);
}

uint64_t GPUTools::MTL::IsFuncEnumCommitCommandBuffer(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;

  v1 = (int)this;
  result = 1;
  if (v1 > -15239)
  {
    v3 = v1 + 15238;
    if (v3 > 0x12)
      return 0;
    v4 = 1 << v3;
    v5 = 262151;
LABEL_11:
    if ((v4 & v5) != 0)
      return result;
    return 0;
  }
  if (v1 > -15344)
  {
    v6 = v1 + 15343;
    if (v6 > 0x1B)
      return 0;
    v4 = 1 << v6;
    v5 = 167772161;
    goto LABEL_11;
  }
  if (v1 != -16361 && v1 != -16202 && v1 != -15908)
    return 0;
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumFunctionTableRelatedCall(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;

  v1 = (int)this;
  result = 1;
  if (v1 > -15372)
  {
    if (((v1 + 10193) > 0x29 || ((1 << (v1 - 47)) & 0x303000FE001) == 0)
      && (v1 + 15371) >= 4
      && (v1 + 15258) >= 2)
    {
      return 0;
    }
  }
  else
  {
    switch(v1)
    {
      case -15626:
      case -15625:
      case -15622:
      case -15621:
      case -15612:
      case -15607:
      case -15606:
      case -15605:
      case -15604:
      case -15603:
      case -15602:
      case -15601:
      case -15600:
      case -15599:
      case -15598:
      case -15597:
      case -15596:
      case -15583:
      case -15582:
      case -15581:
      case -15580:
      case -15578:
      case -15577:
      case -15574:
      case -15573:
      case -15572:
      case -15571:
      case -15570:
      case -15569:
      case -15568:
      case -15567:
      case -15566:
      case -15565:
      case -15564:
      case -15563:
      case -15562:
      case -15561:
      case -15560:
      case -15559:
      case -15558:
      case -15557:
      case -15556:
      case -15549:
      case -15548:
      case -15547:
      case -15546:
      case -15545:
      case -15544:
      case -15543:
      case -15542:
      case -15540:
      case -15539:
      case -15538:
      case -15537:
      case -15536:
      case -15530:
      case -15529:
      case -15528:
      case -15527:
      case -15526:
      case -15525:
      case -15484:
      case -15483:
      case -15482:
      case -15481:
      case -15479:
      case -15478:
      case -15477:
      case -15476:
      case -15462:
      case -15460:
      case -15458:
      case -15457:
      case -15456:
      case -15455:
      case -15453:
      case -15452:
      case -15451:
      case -15450:
      case -15448:
      case -15447:
      case -15446:
      case -15445:
      case -15443:
      case -15442:
      case -15441:
      case -15440:
      case -15439:
      case -15438:
        return result;
      default:
        return 0;
    }
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumShaderDylibRelatedCall(GPUTools::MTL *this)
{
  return ((_DWORD)this + 15696) < 3 || (_DWORD)this == -15613 || (_DWORD)this == -15531;
}

uint64_t GPUTools::MTL::IsFuncEnumDisplayableCall(GPUTools::MTL *this)
{
  int v3;

  if (GPUTools::MTL::IsFuncEnumDrawCall(this)
    || ((_DWORD)this + 16079) < 2
    || (_DWORD)this == -16327
    || (_DWORD)this == -16220
    || (GPUTools::MTL::IsFuncEnumBlitCall(this) & 1) != 0)
  {
    return 1;
  }
  if ((int)this <= -15487)
  {
    if ((_DWORD)this == -16137 || (_DWORD)this == -16034)
      return 1;
    v3 = -15887;
  }
  else
  {
    if (((_DWORD)this + 6144) <= 0x2F && ((1 << (char)this) & 0x8BF1EC9D5395) != 0
      || (_DWORD)this == -15486)
    {
      return 1;
    }
    v3 = -15297;
  }
  if ((_DWORD)this == v3
    || ((_DWORD)this + 15784) < 3
    || GPUTools::MTL::IsFuncEnumAccelerationEncodeCall(this))
  {
    return 1;
  }
  return GPUTools::MTL::IsFuncEnumPresent(this);
}

uint64_t GPUTools::MTL::IsFuncEnumPresent(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;

  v1 = (int)this;
  result = 1;
  if (v1 > -7159)
  {
    if ((v1 + 7158) >= 3)
      return 0;
  }
  else if ((v1 + 16359) >= 2 && v1 != -16133 && v1 != -15326)
  {
    return 0;
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumGPUCommandCall(GPUTools::MTL *this)
{
  _BOOL8 result;

  if (GPUTools::MTL::IsFuncEnumDrawCall(this))
    return 1;
  result = 1;
  if (((_DWORD)this + 16079) >= 2 && (_DWORD)this != -16327 && (_DWORD)this != -16220)
  {
    if (GPUTools::MTL::IsFuncEnumSampledBlitCall(this) || GPUTools::MTL::IsFuncEnumSampledBlitCallAGX(this))
      return 1;
    result = 1;
    if ((_DWORD)this != -16137 && (_DWORD)this != -15486)
      return (_DWORD)this == -15297;
  }
  return result;
}

BOOL GPUTools::MTL::IsFuncEnumCreateCommandBuffer(GPUTools::MTL *this)
{
  return ((_DWORD)this + 16343) < 2 || (_DWORD)this == -15701 || (_DWORD)this == -12544;
}

BOOL GPUTools::MTL::IsFuncEnumCreateIOCommandBuffer(GPUTools::MTL *this)
{
  _BOOL4 v1;

  v1 = (_DWORD)this == -15306 || (_DWORD)this == -12543;
  return (_DWORD)this == -15333 || v1;
}

BOOL GPUTools::MTL::IsCommandEncoder(int a1)
{
  _BOOL8 result;

  result = 1;
  if ((a1 - 21) > 0x3D || ((1 << (a1 - 21)) & 0x2022100000200081) == 0)
    return a1 == 17;
  return result;
}

uint64_t GPUTools::MTL::IsFuncEnumInsertDebugSignpost(GPUTools::MTL *this)
{
  int v1;
  uint64_t result;
  int v3;

  v1 = (int)this;
  result = 1;
  if (v1 > -16170)
  {
    if (v1 > -15789)
    {
      if (v1 == -15788)
        return result;
      v3 = -15641;
    }
    else
    {
      if (v1 == -16169)
        return result;
      v3 = -15883;
    }
  }
  else if (v1 > -16285)
  {
    if (v1 == -16284)
      return result;
    v3 = -16245;
  }
  else
  {
    if (v1 == -16375)
      return result;
    v3 = -16324;
  }
  if (v1 != v3)
    return 0;
  return result;
}

_QWORD *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::clear(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;

  if (result[3])
  {
    v1 = result;
    result = (_QWORD *)result[2];
    if (result)
    {
      do
      {
        v2 = (_QWORD *)*result;
        operator delete(result);
        result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    v3 = v1[1];
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        *(_QWORD *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

_QWORD *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_241148460(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void GPUTools::MTL::InstallMTLInternalDataStringTable(GPUTools::MTL *this)
{
  if (GPUTools::MTL::InstallMTLInternalDataStringTable(void)::sOnce != -1)
    dispatch_once(&GPUTools::MTL::InstallMTLInternalDataStringTable(void)::sOnce, &__block_literal_global_3);
}

uint64_t ___ZN8GPUTools3MTL33InstallMTLInternalDataStringTableEv_block_invoke()
{
  _BYTE __dst[576];
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  memcpy(__dst, &unk_2511232B8, sizeof(__dst));
  return DYAddInternalDataNameEntries();
}

_QWORD *MTLDeviceInfo::Initialize(MTLDeviceInfo *this)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  result[2] = 0;
  result[1] = 0;
  *result = result + 1;
  MTLDeviceInfo::activeDeviceInfoMap = (uint64_t)result;
  return result;
}

uint64_t MTLDeviceInfo::MTLDeviceInfo(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  NSObject *v5;
  uint64_t *v6;
  id v8[2];

  v3 = a2;
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 8) = 0;
  DYGetMTLGuestAppClient();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "graphicsSemaphore");
  v5 = objc_claimAutoreleasedReturnValue();
  dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);

  v6 = (uint64_t *)operator new();
  std::map<MTLToolsDevice * {__strong},MTLDeviceInfo *>::map[abi:ne180100](v6, MTLDeviceInfo::activeDeviceInfoMap);
  std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__erase_unique<MTLToolsDevice * {__strong}>((uint64_t)v6, (unint64_t *)a1);
  v8[0] = *(id *)a1;
  v8[1] = (id)a1;
  std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__emplace_unique_key_args<MTLToolsDevice * {__strong},std::pair<MTLToolsDevice * const {__strong},MTLDeviceInfo *>>((uint64_t **)v6, (unint64_t *)v8, (uint64_t)v8);

  _swapDeviceInfoMap((unint64_t)v6);
  dispatch_semaphore_signal(v5);

  return a1;
}

void sub_241148F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  id *v9;
  void *v10;
  NSObject *v11;

  dispatch_semaphore_signal(v11);
  _Unwind_Resume(a1);
}

void _swapDeviceInfoMap(unint64_t a1)
{
  unint64_t v1;
  dispatch_time_t v2;
  NSObject *v3;
  _QWORD block[5];

  do
    v1 = __ldaxr((unint64_t *)&MTLDeviceInfo::activeDeviceInfoMap);
  while (__stlxr(a1, (unint64_t *)&MTLDeviceInfo::activeDeviceInfoMap));
  v2 = dispatch_time(0, 10000000000);
  dispatch_get_global_queue(-2, 0);
  v3 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZL18_swapDeviceInfoMapPNSt3__13mapIU8__strongP14MTLToolsDeviceP13MTLDeviceInfoNS_4lessIS3_EENS_9allocatorINS_4pairIU8__strongKS2_S5_EEEEEE_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v1;
  dispatch_after(v2, v3, block);

}

void MTLDeviceInfo::~MTLDeviceInfo(MTLDeviceInfo *this)
{
  void *v2;
  NSObject *v3;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t *v10;

  DYGetMTLGuestAppClient();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "graphicsSemaphore");
  v3 = objc_claimAutoreleasedReturnValue();
  dispatch_semaphore_wait(v3, 0xFFFFFFFFFFFFFFFFLL);

  v4 = *(_QWORD **)(MTLDeviceInfo::activeDeviceInfoMap + 8);
  if (!v4)
    goto LABEL_12;
  v5 = *(_QWORD *)this;
  v6 = MTLDeviceInfo::activeDeviceInfoMap + 8;
  do
  {
    v7 = v4[4];
    v8 = v7 >= v5;
    if (v7 >= v5)
      v9 = v4;
    else
      v9 = v4 + 1;
    if (v8)
      v6 = (uint64_t)v4;
    v4 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 == MTLDeviceInfo::activeDeviceInfoMap + 8 || v5 < *(_QWORD *)(v6 + 32))
LABEL_12:
    v6 = MTLDeviceInfo::activeDeviceInfoMap + 8;
  if (*(MTLDeviceInfo **)(v6 + 40) == this)
  {
    v10 = (uint64_t *)operator new();
    std::map<MTLToolsDevice * {__strong},MTLDeviceInfo *>::map[abi:ne180100](v10, MTLDeviceInfo::activeDeviceInfoMap);
    std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__erase_unique<MTLToolsDevice * {__strong}>((uint64_t)v10, (unint64_t *)this);
    _swapDeviceInfoMap((unint64_t)v10);
  }
  dispatch_semaphore_signal(v3);

}

uint64_t ___ZL18_swapDeviceInfoMapPNSt3__13mapIU8__strongP14MTLToolsDeviceP13MTLDeviceInfoNS_4lessIS3_EENS_9allocatorINS_4pairIU8__strongKS2_S5_EEEEEE_block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (v1)
  {
    std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::destroy(*(_QWORD *)(result + 32), *(_QWORD **)(v1 + 8));
    JUMPOUT(0x24268F704);
  }
  return result;
}

void std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

uint64_t *std::map<MTLToolsDevice * {__strong},MTLDeviceInfo *>::map[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<MTLToolsDevice * {__strong},MTLDeviceInfo *>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__tree_node<std::__value_type,void *> *,long>>>(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_24114920C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<MTLToolsDevice * {__strong},MTLDeviceInfo *>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__tree_node<std::__value_type,void *> *,long>>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__emplace_hint_unique_key_args<MTLToolsDevice * {__strong},std::pair<MTLToolsDevice * const {__strong},MTLDeviceInfo *> const&>(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__emplace_hint_unique_key_args<MTLToolsDevice * {__strong},std::pair<MTLToolsDevice * const {__strong},MTLDeviceInfo *> const&>(uint64_t **a1, _QWORD *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  id v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  v6 = (uint64_t **)std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__find_equal<MTLToolsDevice * {__strong}>(a1, a2, &v13, &v12, a3);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v7 = (uint64_t *)operator new(0x30uLL);
    v9 = *(id *)a4;
    v10 = *(_QWORD *)(a4 + 8);
    v7[4] = (uint64_t)v9;
    v7[5] = v10;
    std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__insert_node_at(a1, v13, v8, v7);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__find_equal<MTLToolsDevice * {__strong}>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__erase_unique<MTLToolsDevice * {__strong}>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = (uint64_t)v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_QWORD *)(v4 + 32))
    return 0;
  std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__remove_node_pointer(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

uint64_t *std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t *std::__tree<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::__map_value_compare<MTLToolsDevice * {__strong},std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>,std::less<MTLToolsDevice * {__strong}>,true>,std::allocator<std::__value_type<MTLToolsDevice * {__strong},MTLDeviceInfo *>>>::__emplace_unique_key_args<MTLToolsDevice * {__strong},std::pair<MTLToolsDevice * const {__strong},MTLDeviceInfo *>>(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;
  id v11;
  uint64_t v12;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x30uLL);
    v11 = *(id *)a3;
    v12 = *(_QWORD *)(a3 + 8);
    v10[4] = (uint64_t)v11;
    v10[5] = v12;
    std::__tree<std::__value_type<std::string,unsigned long>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned long>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned long>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x24BDBB850]();
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC1C8](allocator, propertyList, mutabilityOption);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

uint64_t DYAddInternalDataNameEntries()
{
  return MEMORY[0x24BE39058]();
}

uint64_t DYGetInterposeDylibHandle()
{
  return MEMORY[0x24BE390B8]();
}

uint64_t DYSetBlockPointer()
{
  return MEMORY[0x24BE390F0]();
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x24BDD88B0](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

size_t IOSurfaceGetBytesPerRowOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x24BDD8BE0](buffer, planeIndex);
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x24BDD8C58](buffer, planeIndex);
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x24BDDD1E0]();
}

uint64_t MTLGetTextureLevelInfoForDeviceWithOptions()
{
  return MEMORY[0x24BDDD268]();
}

uint64_t MTLPixelFormatGetInfoForDevice()
{
  return MEMORY[0x24BDDD388]();
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x24BDD1218](aSelectorName);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _DYOLog()
{
  return MEMORY[0x24BE39158]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t DYGetHostInfo(void)
{
  return MEMORY[0x24BE39160]();
}

uint64_t GPUTools::FB::VAListArgumentProvider::VAListArgumentProvider(GPUTools::FB::VAListArgumentProvider *this, char *a2)
{
  return MEMORY[0x24BE39178](this, a2);
}

void GPUTools::FB::VAListArgumentProvider::~VAListArgumentProvider(GPUTools::FB::VAListArgumentProvider *this)
{
  MEMORY[0x24BE39180](this);
}

uint64_t GPUTools::FB::Encode()
{
  return MEMORY[0x24BE39188]();
}

uint64_t GPUTools::Interpose::DYSavePointer()
{
  return MEMORY[0x24BE39220]();
}

uint64_t GPUTools::FD::Argument::ViewAsGLObjectName(GPUTools::FD::Argument *this)
{
  return MEMORY[0x24BE39238](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC58](this, __s);
}

unsigned int std::thread::hardware_concurrency(void)
{
  return MEMORY[0x24BEDB460]();
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_251122880(__p);
}

uint64_t operator delete()
{
  return off_251122888();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_251122890(__sz);
}

uint64_t operator new()
{
  return off_251122898();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x24BEDB958]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADC60](when, queue, block);
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  return (dispatch_data_t)MEMORY[0x24BDADD78](data, buffer_ptr, size_ptr);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADDB8](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x24BDADDC8]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADDF0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  MEMORY[0x24BDADEA0](predicate, context, function);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

int dlclose(void *__handle)
{
  return MEMORY[0x24BDAE060](__handle);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x24BDAE068]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

uint64_t dy_abort()
{
  return MEMORY[0x24BE39240]();
}

uint64_t dy_add_fenum_string_tables()
{
  return MEMORY[0x24BE39248]();
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x24BEDD0B0](self, _cmd, offset, atomic);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x24BEDD160]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

