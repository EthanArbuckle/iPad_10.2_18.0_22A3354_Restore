unint64_t TFSInfo::GetFlatItemCount(TFSInfo *this, int a2, const __CFString *a3)
{
  void *v4;
  void *v5;
  uint64_t v6;
  unint64_t v8;
  char v9;
  void *v10;
  void *v11;
  TString *v12;
  _BOOL4 v13;
  unint64_t FlatItemDirEntryCount;
  char v15;
  NSObject *v16;
  void *v17;
  const void *v18;
  __CFString *v19;
  __CFString *v20;
  __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  uint64_t v25;
  const void **v26;
  uint64_t *PropertyStoreName;
  TCFURLInfo *v28;
  int v29;
  const __CFString *v30;
  NSObject *v31;
  NSURL *v32;
  void *v33;
  void *v34;
  const __CFString *v36;
  const __CFString *cf2;
  void *v38;
  CFTypeRef v39;
  CFTypeRef cf1;
  TCFURLInfo *v41;
  uint64_t v42;
  _QWORD v43[3];
  _BYTE buf[12];
  __int16 v45;
  void *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 112) == 28)
  {
    TFSInfo::GetFPItem(this);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "childItemCount");
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    if (v5)
    {
      v6 = objc_msgSend(v5, "integerValue");

      return v6;
    }
    LogObj(4);
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      TFSInfo::GetFPItem(this);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v17;
      _os_log_impl(&dword_1CBC4A000, v16, OS_LOG_TYPE_ERROR, "Failed to get item count for FPv2 directory: %{public}@", buf, 0xCu);

    }
    return -2;
  }
  if ((TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AC48], a3) & 0x40000000) != 0)
  {
    TFSInfo::GetFPItem(this);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = v10;
    if (!v10)
      goto LABEL_43;
    objc_msgSend(v10, "providerDomainID");
    v12 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    *(_QWORD *)buf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)buf, v12);

    v13 = IsICloudDriveDomainID((TString *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);

    if (!v13)
    {
LABEL_43:

      LogObj(4);
      v31 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        v32 = (NSURL *)*((id *)this + 1);
        SanitizedURL(v32);
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        TFSInfo::GetFPItem(this);
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543618;
        *(_QWORD *)&buf[4] = v33;
        v45 = 2114;
        v46 = v34;
        _os_log_impl(&dword_1CBC4A000, v31, OS_LOG_TYPE_ERROR, "Failed to get item count for dataless directory: %{public}@, fpItem: %{public}@", buf, 0x16u);

      }
      return -2;
    }
    FlatItemDirEntryCount = TFSInfo::GetFlatItemDirEntryCount(this, 1);
    if (v15)
      v6 = FlatItemDirEntryCount;
    else
      v6 = -2;

  }
  else if ((a2 & 1) != 0 || (v8 = TFSInfo::GetFlatItemDirEntryCount(this, 0), !v9))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v18 = (const void *)*((_QWORD *)this + 2);
    *(_QWORD *)buf = v18;
    if (v18)
    {
      CFRetain(v18);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      v19 = (__CFString *)(id)*MEMORY[0x1E0C9B480];
      v43[0] = v19;
      v20 = (__CFString *)(id)*MEMORY[0x1E0C9B4F8];
      v43[1] = v20;
      v21 = (__CFString *)(id)*MEMORY[0x1E0C9B5A0];
      v43[2] = v21;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v43, 3);
      v38 = (void *)objc_claimAutoreleasedReturnValue();

      v42 = MEMORY[0x1D17A4DF4](*MEMORY[0x1E0C9AE00], *(_QWORD *)buf, 0, v38);
      v6 = 0;
      if (v42)
      {
        if (*MEMORY[0x1E0C9B488])
          v22 = (const __CFString *)*MEMORY[0x1E0C9B488];
        else
          v22 = &stru_1E8752DF8;
        v23 = (const __CFString *)*MEMORY[0x1E0C9B478];
        if (!*MEMORY[0x1E0C9B478])
          v23 = &stru_1E8752DF8;
        cf2 = v23;
        v24 = (const __CFString *)*MEMORY[0x1E0C9B490];
        if (!*MEMORY[0x1E0C9B490])
          v24 = &stru_1E8752DF8;
        v36 = v24;
        do
        {
          v41 = 0;
          v25 = MEMORY[0x1D17A4E00](v42, &v41, 0);
          if (v25 == 1)
          {
            v26 = TCFURLInfo::StringProperty(v41, v21, (TString *)&cf1);
            PropertyStoreName = TCFURLInfo::GetPropertyStoreName((TCFURLInfo *)v26);
            if (!CFEqual(cf1, (CFTypeRef)*PropertyStoreName)
              && (operator==((void **)&cf1, CFSTR(".localized")) & 1) == 0)
            {
              if (operator==((void **)&cf1, CFSTR("Inbox"))
                && (v28 = v41, v29 = IsAppInbox((NSURL *)v28), v28, v29))
              {
                MEMORY[0x1D17A4E0C](v42);
              }
              else
              {
                TCFURLInfo::StringProperty(v41, v19, (TString *)&v39);
                if (CFEqual(v39, v22) || CFEqual(v39, cf2) || CFEqual(v39, v36))
                {
                  if (a2)
                    v6 += TCFURLInfo::GetBooleanProperty(v41, v20, v30) ^ 1;
                  else
                    ++v6;
                }
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v39);
              }
            }
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
          }
        }
        while (v25 != 2);
      }
      TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)&v42);

    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      v6 = 0;
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
  }
  else
  {
    return v8;
  }
  return v6;
}

void sub_1CBC4BF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, ...)
{
  const void *v5;
  va_list va;
  const void *v7;
  va_list va1;
  uint64_t v9;
  const void *v10;
  va_list va2;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va3;

  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v7 = va_arg(va2, const void *);
  v9 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v10 = va_arg(va3, const void *);
  v12 = va_arg(va3, _QWORD);
  v13 = va_arg(va3, _QWORD);
  v14 = va_arg(va3, _QWORD);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)va2);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

const void **TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TNode::GetProperty(uint64_t a1, signed int a2, uint64_t a3, uint64_t a4)
{
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  int v13;
  const void **IsAlias;
  char v15;
  int v16;
  _QWORD *v17;
  _QWORD *v18;
  TNodePtr *v19;
  char v20;
  __int128 v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  FINode *fFINode;
  unint64_t *v26;
  unint64_t v27;
  FINode *v28;
  uint64_t v29;
  uint64_t Property;
  __int128 v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  FINode *v35;
  unint64_t *v36;
  unint64_t v37;
  TFSInfo *v38;
  os_unfair_lock_s *v39;
  FINode *v40;
  FINode *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  os_unfair_lock_s *v53;
  FINode *v54;
  FINode *v55;
  unint64_t *v56;
  unint64_t v57;
  char HaveOriginatorInfo;
  unint64_t *v59;
  unint64_t v60;
  __int128 v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  TFSInfo *v65;
  uint64_t v66;
  const __CFString *v67;
  char v68;
  unsigned int v69;
  void *v70;
  char v71;
  uint64_t v72;
  const __CFString *v73;
  TString v74;
  TNodePtr v75;
  TNodePtr v76[2];
  uint64_t v77;
  TString *v78;
  id v79;
  char v80;
  TFSVolumeInfo *v81[2];
  TFSInfo *v82;
  std::__shared_weak_count *v83;
  __int128 v84;
  uint64_t v85;
  const __CFString *v86;
  id v87;

  v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v8);
  v10 = *(_QWORD *)(a1 + 16);
  v9 = *(std::__shared_weak_count **)(a1 + 24);
  v82 = (TFSInfo *)v10;
  v83 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v8);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
  v13 = *(_DWORD *)(v10 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 100));
  IsAlias = (const void **)TFSInfo::IsAlias((TFSInfo *)v10);
  v15 = (char)IsAlias;
  v81[0] = 0;
  v81[1] = 0;
  if (a2 == 1802071652)
    a2 = 1802072172;
  if (a2 > 1819240306)
  {
    if (a2 > 1836016739)
    {
      if (a2 == 1836016740)
        goto LABEL_18;
      v16 = 1920167267;
    }
    else
    {
      if (a2 == 1819240307)
        goto LABEL_18;
      v16 = 1819632756;
    }
LABEL_17:
    if (a2 != v16)
      goto LABEL_28;
    goto LABEL_18;
  }
  if (a2 > 1769171298)
  {
    if (a2 == 1769171299)
      goto LABEL_18;
    v16 = 1802072172;
    goto LABEL_17;
  }
  if (a2 != 1634952036)
  {
    v16 = 1768124270;
    goto LABEL_17;
  }
LABEL_18:
  TNodePtr::TNodePtr(&v75, (const TNode *)a1);
  TempPropertiesLock();
  os_unfair_lock_lock((os_unfair_lock_t)&TempPropertiesLock(void)::sTempPropertiesLock);
  v17 = (_QWORD *)TempProperties();
  *(_QWORD *)&v84 = TNodeFromFINode(v75.fFINode);
  v18 = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(v17, &v84);
  TempProperties();
  if (v18)
  {
    LOBYTE(v84) = 1;
    std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<TTempProperties&,BOOL,0>((uint64_t)v76, (__int128 *)(v18 + 3), &v84);
  }
  else
  {
    v84 = 0uLL;
    v85 = -1;
    v86 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v87 = 0;
    LOBYTE(v74.fString.fRef) = 0;
    std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<true,0>((uint64_t)v76, &v84, &v74);

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v86);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&TempPropertiesLock(void)::sTempPropertiesLock);

  if (v80)
  {
    if (a2 <= 1819240306)
    {
      if (a2 != 1634952036)
      {
        if (a2 == 1769171299)
        {
          TPropertyReference::SetAs<ISIcon * {__strong}>(a3, &v79);
        }
        else if (a2 == 1802072172)
        {
          TPropertyReference::SetAs<TString>(a3, &v78);
        }
        goto LABEL_97;
      }
      v19 = &v76[1];
    }
    else
    {
      v19 = v76;
      if (a2 > 1836016739)
      {
        if (a2 != 1836016740)
        {
          if (a2 == 1920167267)
          {
            LOBYTE(v84) = 0;
            TPropertyReference::SetAs<BOOL>(a3, &v84);
          }
          goto LABEL_97;
        }
      }
      else
      {
        if (a2 == 1819240307)
        {
          TPropertyReference::SetAs<long long>(a3, &v77);
LABEL_97:

          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v78);
          Property = 0;
          goto LABEL_98;
        }
        if (a2 != 1819632756)
          goto LABEL_97;
      }
    }
    TPropertyReference::SetAs<double>(a3, v19);
    goto LABEL_97;
  }

  IsAlias = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v78);
LABEL_28:
  if ((v13 & 0x100) != 0)
    v20 = v15;
  else
    v20 = 1;
  if ((v20 & 1) != 0)
  {
    if (a2 == 1987273324)
      goto LABEL_55;
  }
  else
  {
    switch(a2)
    {
      case 1819240307:
        goto LABEL_41;
      case 1987273324:
LABEL_55:
        LOBYTE(v76[0].fFINode) = TNode::IsVisible((TNode *)a1);
        v29 = TPropertyReference::SetAs<BOOL>(a3, v76);
        goto LABEL_56;
      case 1885895027:
LABEL_41:
        TNode::GetVolumeInfo((TNode *)a1, v76);
        v21 = *(_OWORD *)&v76[0].fFINode;
        v76[0].fFINode = 0;
        v76[1].fFINode = 0;
        v22 = (std::__shared_weak_count *)v81[1];
        *(_OWORD *)v81 = v21;
        if (v22)
        {
          v23 = (unint64_t *)&v22->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        fFINode = v76[1].fFINode;
        if (v76[1].fFINode)
        {
          v26 = (unint64_t *)&v76[1].fFINode[1];
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            (*((void (**)(FINode *))fFINode->super.isa + 2))(fFINode);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)fFINode);
          }
        }
        v76[0].fFINode = 0;
        if (v81[0])
        {
          v28 = (FINode *)TFSVolumeInfo::VolumeSize(v81[0]);
          v76[0].fFINode = v28;
          if (v28 == (FINode *)-1)
          {
            TPropertyReference::SetAs<long long>(a3, v76);
            Property = 4294959210;
            goto LABEL_98;
          }
          if (v28 != (FINode *)-2)
          {
            v29 = TPropertyReference::SetAs<long long>(a3, v76);
LABEL_56:
            Property = v29;
            goto LABEL_98;
          }
        }
        else
        {
          v76[0].fFINode = (FINode *)-2;
        }
        TPropertyReference::SetAs<long long>(a3, v76);
        Property = 4294959222;
        goto LABEL_98;
    }
  }
  if (a2 == 1684955501 && (v13 & 0x100) != 0)
  {
    TNode::GetVolumeInfo((TNode *)a1, v76);
    v31 = *(_OWORD *)&v76[0].fFINode;
    v76[0].fFINode = 0;
    v76[1].fFINode = 0;
    v32 = (std::__shared_weak_count *)v81[1];
    *(_OWORD *)v81 = v31;
    if (v32)
    {
      v33 = (unint64_t *)&v32->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v35 = v76[1].fFINode;
    if (v76[1].fFINode)
    {
      v36 = (unint64_t *)&v76[1].fFINode[1];
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        (*((void (**)(FINode *))v35->super.isa + 2))(v35);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v35);
      }
    }
    if (!*((_BYTE *)v81[0] + 108))
    {
      LOBYTE(v74.fString.fRef) = 0;
      goto LABEL_71;
    }
LABEL_84:
    v39 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsAlias);
    os_unfair_lock_lock(v39);
    v41 = *(FINode **)(a1 + 16);
    v40 = *(FINode **)(a1 + 24);
    v76[0].fFINode = v41;
    v76[1].fFINode = v40;
    if (v40)
    {
      v42 = (unint64_t *)&v40[1];
      do
        v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
    }
    os_unfair_lock_unlock(v39);
    TFSInfo::Name((TFSInfo *)v41, &v74);
    if (v40)
    {
      v44 = (unint64_t *)&v40[1];
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        (*((void (**)(FINode *))v40->super.isa + 2))(v40);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v40);
      }
    }
    ColonsToSlashes(&v74, (TString *)&v84);
    Property = TPropertyReference::SetAs<TString>(a3, (TString **)&v84);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v84);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v74.fString.fRef);
    goto LABEL_98;
  }
  if (a2 == 1869769063)
  {
    v53 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsAlias);
    os_unfair_lock_lock(v53);
    v55 = *(FINode **)(a1 + 16);
    v54 = *(FINode **)(a1 + 24);
    v76[0].fFINode = v55;
    v76[1].fFINode = v54;
    if (v54)
    {
      v56 = (unint64_t *)&v54[1];
      do
        v57 = __ldxr(v56);
      while (__stxr(v57 + 1, v56));
    }
    os_unfair_lock_unlock(v53);
    HaveOriginatorInfo = TFSInfo::CanHaveOriginatorInfo((TFSInfo *)v55);
    if (v54)
    {
      v59 = (unint64_t *)&v54[1];
      do
        v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        (*((void (**)(FINode *))v54->super.isa + 2))(v54);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v54);
      }
    }
    if ((HaveOriginatorInfo & 1) == 0)
    {
      v76[0].fFINode = 0;
      Property = TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a3, (id *)&v76[0].fFINode);
      goto LABEL_137;
    }
  }
  else if (a2 == 1886282093)
  {
    goto LABEL_84;
  }
  if (!v81[0])
  {
    TNode::GetVolumeInfo((TNode *)a1, v76);
    v61 = *(_OWORD *)&v76[0].fFINode;
    v76[0].fFINode = 0;
    v76[1].fFINode = 0;
    v62 = (std::__shared_weak_count *)v81[1];
    *(_OWORD *)v81 = v61;
    if (v62)
    {
      v63 = (unint64_t *)&v62->__shared_owners_;
      do
        v64 = __ldaxr(v63);
      while (__stlxr(v64 - 1, v63));
      if (!v64)
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
    }
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v76);
  }
  LOBYTE(v74.fString.fRef) = 0;
  if (a2 > 1769171055)
  {
    if (a2 > 1936225391)
    {
      if (a2 != 1936225392)
      {
        if (a2 != 1969385844)
          goto LABEL_71;
        v65 = v82;
        if ((TFSInfo::GetBladeRunnerFlags(v82) & 0x80000000) != 0 && ((a4 & 0x40000) != 0 || !pthread_main_np()))
        {
          TFSInfo::FetchBladeRunnerProperties(v65, v66, v67);
          LOBYTE(v74.fString.fRef) = 1;
        }
        LODWORD(v76[0].fFINode) = TFSInfo::GetBladeRunnerFlags(v65);
        v68 = atomic_load((unsigned __int16 *)(a1 + 80));
        if ((v68 & 1) != 0)
          LODWORD(v76[0].fFINode) |= 0x1000u;
        v69 = TPropertyReference::SetAs<DSBladeRunnerFlags>(a3, v76);
        if (v69)
          Property = v69;
        else
          Property = (SLODWORD(v76[0].fFINode) >> 31) & 0xFFFFE06A;
        goto LABEL_76;
      }
    }
    else if (a2 != 1769171056 && a2 != 1819501924)
    {
      goto LABEL_71;
    }
    v38 = v82;
    if ((TFSInfo::GetBladeRunnerFlags(v82) & 0x80000000) != 0 && ((a4 & 0x40000) != 0 || !pthread_main_np()))
    {
      TNode::GetFIProvider((TNode *)a1);
      v70 = (void *)objc_claimAutoreleasedReturnValue();
      v71 = objc_msgSend(v70, "isLocalStorageDomain");

      if ((v71 & 1) == 0)
      {
        TFSInfo::FetchBladeRunnerProperties(v38, v72, v73);
        TNodePtr::TNodePtr(v76, (const TNode *)a1);
        TNode::SendNotification((const TNode *)a1, 2, (id *)&v76[0].fFINode, 1969385844, 0);

      }
    }
    if ((TFSInfo::GetBladeRunnerFlags(v38) & 0x180) == 0 && *((_BYTE *)v38 + 112) != 7)
    {
      Property = 0;
      goto LABEL_73;
    }
LABEL_72:
    Property = TFSInfo::GetProperty((uint64_t)v38, a2, a3, (uint64_t)v81, a4, (uint64_t)&v74);
LABEL_73:
    if (a2 == 1668505966 || a2 == 1634758244)
      TNode::AddToAppNapCache((TNode *)a1);
    goto LABEL_76;
  }
  if (a2 > 1718904683)
  {
    if (a2 == 1768845426)
    {
      *(_QWORD *)&v84 = TNode::CopyInlineProgress((TNode *)a1);
      v76[0].fFINode = (FINode *)v84;
      Property = TPropertyReference::SetAs<__CFDictionary const*>(a3, (id *)&v76[0].fFINode);
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&v84);
      goto LABEL_76;
    }
    goto LABEL_71;
  }
  if (a2 != 1667785588)
  {
LABEL_71:
    v38 = v82;
    goto LABEL_72;
  }
  if ((a4 & 0x40000000) != 0 && *(_QWORD *)(a1 + 56) && TNode::NeedsChildReconcile((TNode *)a1))
  {
    v76[0].fFINode = (FINode *)TChildrenList::ChildrenCount(*(TChildrenList **)(a1 + 56));
    v29 = TPropertyReference::SetAs<long long>(a3, v76);
    goto LABEL_56;
  }
  Property = TFSInfo::GetProperty((uint64_t)v82, 1667785588, a3, (uint64_t)v81, a4, (uint64_t)&v74);
LABEL_76:
  if (!(_DWORD)Property && LOBYTE(v74.fString.fRef))
  {
    TNodePtr::TNodePtr(v76, (const TNode *)a1);
    TNode::SendNotification((const TNode *)a1, 2, (id *)&v76[0].fFINode, a2, 0);
LABEL_137:

  }
LABEL_98:
  v46 = (std::__shared_weak_count *)v81[1];
  if (v81[1])
  {
    v47 = (unint64_t *)((char *)v81[1] + 8);
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  v49 = v83;
  if (v83)
  {
    v50 = (unint64_t *)&v83->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  return Property;
}

void sub_1CBC4CAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

id TFSInfo::GetFPItem(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  id v3;

  v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v3 = *((id *)this + 8);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t ICloudDriveFPFSEnabled(void)
{
  unsigned __int8 v0;

  {
    ICloudDriveFPFSEnabled(void)::enabled = UseFileProviderFramework();
  }
  return ICloudDriveFPFSEnabled(void)::enabled;
}

void sub_1CBC4CC94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::NodeFromNodeRef(TNode *this, OpaqueNodeRef *a2)
{
  void *v2;
  void *v3;
  uint64_t v4;

  +[FINode nodeFromNodeRef:](FINode, "nodeFromNodeRef:", this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<FIDSNode,FINode * {__strong}>(v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  v4 = objc_msgSend(v3, "asTNode");
  return v4;
}

void sub_1CBC4CD08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

int *TNode::InfoLock(TNode *this)
{
  unsigned __int8 v1;

  {
    TNode::InfoLock(void)::sInfoLock = 0;
  }
  return &TNode::InfoLock(void)::sInfoLock;
}

BOOL TFSInfo::IsAlias(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  return (v3 & 0x800) != 0 || (*((_BYTE *)this + 112) & 0xFB) == 3;
}

const void **TCFURLInfo::StringProperty@<X0>(TCFURLInfo *this@<X0>, const __CFString *a2@<X1>, TString *a3@<X8>)
{
  TString *v5;
  TString *propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  if (this)
  {
    CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0);
    v5 = propertyValueTypeRefPtr;
  }
  else
  {
    v5 = 0;
  }
  a3->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a3, v5);
  return TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
}

void sub_1CBC4CE54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void **v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef *TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(CFTypeRef *a1, CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  if (*a1)
    CFRelease(*a1);
  *a1 = cf;
  return a1;
}

void TString::SetStringRefAsImmutable(TString *this, TString *a2)
{
  TString *v2;
  unsigned __int16 IsMutable;
  const __CFString *v5;
  CFStringRef Copy;

  v2 = this;
  if (!a2)
  {
    v5 = &stru_1E8752DF8;
    goto LABEL_6;
  }
  IsMutable = TString::IsMutable(a2, (const __CFString *)a2);
  if (IsMutable >= 0x100u && !(_BYTE)IsMutable)
  {
    this = v2;
    v5 = (const __CFString *)a2;
LABEL_6:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, v5);
    return;
  }
  Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFStringRef)a2);
  if (v2->fString.fRef)
    CFRelease(v2->fString.fRef);
  v2->fString.fRef = (__CFString *)Copy;
}

uint64_t TString::IsMutable(TString *this, const __CFString *a2)
{
  const char *ClassName;
  _BOOL4 v3;
  int v4;

  if (!this)
  {
    v3 = 0;
    v4 = 1;
    return v3 | (v4 << 8);
  }
  ClassName = object_getClassName(this);
  if (!strcmp(ClassName, "__NSCFConstantString") || !strcmp(ClassName, "NSTaggedPointerString"))
  {
    v3 = 0;
LABEL_9:
    v4 = 1;
    return v3 | (v4 << 8);
  }
  if (!strcmp(ClassName, "__NSCFString"))
  {
    v3 = __CFStringIsMutable() != 0;
    goto LABEL_9;
  }
  v3 = 0;
  v4 = 0;
  return v3 | (v4 << 8);
}

const void **TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void TNode::GetVolumeInfo(TNode *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v5 = *((_QWORD *)this + 1);
  *a2 = *(_QWORD *)this;
  a2[1] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  os_unfair_lock_unlock(v4);
}

uint64_t TCFURLInfo::GetBooleanProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t v3;
  const void *propertyValueTypeRefPtr;

  if (!this)
    return 0;
  propertyValueTypeRefPtr = 0;
  if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0) && propertyValueTypeRefPtr)
    v3 = IsEqual(propertyValueTypeRefPtr, (const void *)*MEMORY[0x1E0C9AE50]);
  else
    v3 = 0;
  TAutoRef<__CFBoolean const*,TRetainReleasePolicy<__CFBoolean const*>>::~TAutoRef(&propertyValueTypeRefPtr);
  return v3;
}

void sub_1CBC4D0D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFBoolean const*,TRetainReleasePolicy<__CFBoolean const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFBoolean const*,TRetainReleasePolicy<__CFBoolean const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void *cf_cast<__CFURL const*,void const*>(const void *result)
{
  const void *v1;
  CFTypeID v2;
  CFTypeID v3;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFURLGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

uint64_t TFSInfo::GetBladeRunnerFlags(TFSInfo *this)
{
  void *v2;
  os_unfair_lock_s *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  if (*((_BYTE *)this + 112))
  {
    TFSInfo::GetFPItem(this);
    v2 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v2)
      return 0;
  }
  v3 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v4 = *((_QWORD *)this + 10);
  if (v4
    && (os_unfair_lock_lock((os_unfair_lock_t)(v4 + 72)),
        v5 = *(unsigned __int8 *)(v4 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 72)),
        v5 == 1))
  {
    v6 = *(unsigned int *)(v4 + 32);
  }
  else
  {
    v6 = 0x80000000;
  }
  os_unfair_lock_unlock(v3);
  return v6;
}

uint64_t TempProperties(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  {
    v2 = operator new();
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 1065353216;
    TempProperties(void)::sTempProperties = v2;
  }
  return TempProperties(void)::sTempProperties;
}

void sub_1CBC4D280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetProperty(uint64_t a1, signed int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (*v12)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  _QWORD *v13;
  uint64_t result;
  int v15;
  int v16;
  int v17;
  _BYTE v18[8];
  uint64_t (*v19)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v20;

  if (!GetPropertyRecord(a2, (uint64_t)v18))
    return 4294959245;
  v12 = v19;
  v13 = (_QWORD *)(a1 + (v20 >> 1));
  if ((v20 & 1) != 0)
    v12 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*v13 + v19);
  result = v12(v13, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    v15 = *(_DWORD *)(a1 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    if ((v15 & 0x2000000) == 0)
    {
      if (a2 == 1684955501)
        goto LABEL_8;
LABEL_7:
      if (a2 == 1668506984)
      {
LABEL_8:
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
        v16 = *(_DWORD *)(a1 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
        if ((v16 & 0x40000000) != 0)
          return 0;
        else
          return 4294959210;
      }
      return 0;
    }
    result = 4294959210;
    if (a2 <= 1819240306)
    {
      if (a2 <= 1684108402)
      {
        if (a2 == 1634952036)
          return result;
        goto LABEL_7;
      }
      if (a2 == 1684108403)
        return result;
      if (a2 == 1684955501)
        goto LABEL_8;
      v17 = 1818321516;
LABEL_26:
      if (a2 == v17)
        return result;
      return 0;
    }
    if (a2 <= 1883333731)
    {
      if (a2 == 1819240307)
        return result;
      v17 = 1836016740;
      goto LABEL_26;
    }
    if (a2 != 1883333732 && a2 != 1885895027)
    {
      v17 = 1919251315;
      goto LABEL_26;
    }
  }
  return result;
}

BOOL GetPropertyRecord(unsigned int a1, uint64_t a2)
{
  unsigned __int8 v4;
  uint64_t *v5;
  __int128 v6;
  __int128 v7;
  TPropertyRecordSet *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;

  {
    v9 = (TPropertyRecordSet *)operator new();
    TPropertyRecordSet::TPropertyRecordSet(v9);
    GetPropertyRecord(Property,TPropertyRecord &)::records = (uint64_t)v9;
  }
  v10 = a1;
  v11 = 0u;
  v12 = 0u;
  v5 = std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::find<TPropertyRecord>((_QWORD *)GetPropertyRecord(Property,TPropertyRecord &)::records, (unsigned int *)&v10);
  if (v5)
  {
    v6 = *((_OWORD *)v5 + 1);
    v7 = *((_OWORD *)v5 + 2);
    *(_QWORD *)(a2 + 32) = v5[6];
    *(_OWORD *)a2 = v6;
    *(_OWORD *)(a2 + 16) = v7;
  }
  return v5 != 0;
}

void sub_1CBC4D518(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x10A0C404A63E237);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::find<TPropertyRecord>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t TFSInfo::GetModificationDate(TFSInfo *a1, uint64_t a2)
{
  double ModificationDate;

  ModificationDate = TFSInfo::GetModificationDate(a1);
  return TPropertyReference::SetAs<double>(a2, &ModificationDate);
}

uint64_t TPropertyReference::SetAs<double>(uint64_t a1, _QWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      result = 0;
      **(_QWORD **)a1 = *a2;
      return result;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<double>(*(_QWORD *)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void TempPropertiesLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      TempPropertiesLock(void)::sTempPropertiesLock = 0;
    }
  }
}

uint64_t TPropertyReference::SetAs<TString>(uint64_t a1, TString **a2)
{
  int v2;
  TString *v3;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_45;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_45;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_45;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_45;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_45;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_45;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_45;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_45;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_45;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_45;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_45;
      v3 = *(TString **)a1;
      if (v3 != (TString *)a2)
        TString::SetStringRefAsImmutable(v3, *a2);
      return 0;
    case 12:
      if (v2 != 12)
        goto LABEL_45;
      SetAsPriv<TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>((const void **)a2, *(CFTypeRef **)a1);
      return 0;
    case 13:
      if (v2 != 13)
        goto LABEL_45;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_45;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_45;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_45;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_45;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_45;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_45;
      return TPropertyValue::SetAs<TString>(*(_QWORD *)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_45;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_45;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_45:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

CFTypeRef *SetAsPriv<TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(const void **a1, CFTypeRef *a2)
{
  const void *v3;
  CFTypeRef v4;
  const void *v5;

  v3 = RetainCF<__CFString const*>(a1);
  if (v3)
  {
    v4 = CFAutorelease(v3);
    v5 = static_cf_cast<__CFString const*,void const*>(v4);
  }
  else
  {
    v5 = 0;
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v5);
}

void ColonsToSlashes(const TString *a1@<X0>, TString *a2@<X8>)
{
  const __CFString *v4;
  CFTypeRef v5;
  char v6;
  char *i;
  TString *v8;
  TString *v9;
  char buffer[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetLength(a1->fString.fRef))
    goto LABEL_12;
  v4 = (const __CFString *)RetainCF<__CFString const*>((const void **)&a1->fString.fRef);
  if (v4)
  {
    v5 = CFAutorelease(v4);
    v4 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v5);
  }
  if (!CFStringGetCString(v4, buffer, 1024, 0x8000100u))
  {
LABEL_12:
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)a1->fString.fRef);
    return;
  }
  v6 = 0;
  for (i = buffer; *i == 58; ++i)
  {
    *i = 47;
    v6 = 1;
LABEL_10:
    ;
  }
  if (*i)
    goto LABEL_10;
  if ((v6 & 1) == 0)
    goto LABEL_12;
  v8 = (TString *)CFStringCreateWithCString(0, buffer, 0x8000100u);
  v9 = v8;
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9);
}

void sub_1CBC4DBC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  const void **v9;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void *static_cf_cast<__CFString const*,void const*>(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
      return 0;
    else
      return v1;
  }
  return result;
}

const void *RetainCF<__CFString const*>(const void **a1)
{
  const void *result;
  CFTypeRef v2;

  result = *a1;
  if (result)
  {
    v2 = CFRetain(result);
    return static_cf_cast<__CFString const*,void const*>(v2);
  }
  return result;
}

uint64_t TFSInfo::GetUTType(TFSInfo *a1, uint64_t a2, uint64_t a3, char a4, _BYTE *a5)
{
  uint64_t UTType;
  uint64_t v7;
  uint64_t v8;
  id location;

  location = 0;
  UTType = TFSInfo::GetUTType(a1, &location, a4, a5);
  v7 = UTType;
  if ((_DWORD)UTType && (_DWORD)UTType != -8086
    || (v8 = TPropertyReference::SetAs<UTType * {__strong}>(a2, &location), !(_DWORD)v8))
  {
    v8 = v7;
  }

  return v8;
}

void sub_1CBC4DCC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUTType(TFSInfo *this, id *location, char a3, _BYTE *a4)
{
  uint64_t v6;
  UTType *v7;
  void *v9;
  void *v10;
  UTType *v11;
  void *v13;
  UTType *v14;
  void *v15;
  void *v16;
  void *v17;
  UTType *v18;
  UTType *v19;
  void *v20;
  UTType *v21;
  const void *v22;

  *a4 = 0;
  v6 = 0;
  switch(*((_BYTE *)this + 112))
  {
    case 0:
      TFSInfo::GetUTType(this);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = (UTType *)*location;
      *location = v13;

      if (*location)
        return 0;
      if (a3 < 0)
      {
        TFSInfo::ApproximateUTType(this);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = (UTType *)*location;
        *location = v20;

        v19 = (UTType *)*location;
        if (*location)
          v6 = 4294959210;
        else
          v6 = 4294959222;
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        v15 = (void *)*((_QWORD *)this + 2);
        v22 = v15;
        if (v15)
          CFRetain(v15);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        TCFURLInfo::ObjectProperty((TCFURLInfo *)v15, (const __CFString *)*MEMORY[0x1E0C998E0], (const __CFString *)1);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v22);
        static_objc_cast<NSString,objc_object * {__strong}>(v16);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v18 = (UTType *)*location;
        *location = v17;

        v6 = 0;
        v19 = (UTType *)*location;
      }
      TFSInfo::SetUTType(this, v19, v6 != 0);
      return v6;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 0xB:
    case 0xC:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x1A:
    case 0x1D:
    case 0x22:
    case 0x23:
      v7 = (UTType *)*location;
      *location = 0;

      return 0;
    case 0x1B:
    case 0x1C:
      TFSInfo::GetFPItem(this);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "contentType");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = (UTType *)*location;
      *location = v10;

      return 0;
    case 0x1F:
    case 0x20:
    case 0x21:
      return v6;
    default:
      objc_storeStrong(location, (id)*MEMORY[0x1E0CEC528]);
      return 0;
  }
}

void sub_1CBC4DE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

id TFSInfo::GetUTType(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  id v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *((id *)this + 5);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TPropertyReference::SetAs<UTType * {__strong}>(uint64_t a1, id *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<UTType * {__strong}>(*(id **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TNode::Compare(TNode *this, const TString *a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t v9;
  CFTypeRef v10;
  const void *v11;
  CFTypeRef v12;
  const __CFString *v13;
  uint64_t v14;
  CFComparisonResult v15;
  const void *v16;
  CFTypeRef v17;
  const __CFString *v18;
  unint64_t *v19;
  unint64_t v20;
  CFTypeRef cf[3];

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  cf[1] = (CFTypeRef)v6;
  cf[2] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  if (v6)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    v9 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
    os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 100));
    if ((v9 & 0x100000000) == 0)
    {
      if (*(_BYTE *)(v6 + 112))
      {
        if (*(_BYTE *)(v6 + 112) == 21)
        {
          TFSInfo::Name((TFSInfo *)v6, (TString *)cf);
          if (cf[0] && (v10 = CFRetain(cf[0]), (v11 = static_cf_cast<__CFString const*,void const*>(v10)) != 0))
          {
            v12 = CFAutorelease(v11);
            v13 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v12);
          }
          else
          {
            v13 = 0;
          }
          v16 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
          if (v16)
          {
            v17 = CFAutorelease(v16);
            v18 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v17);
          }
          else
          {
            v18 = 0;
          }
          v15 = SpotlightStringCompare(v13, v18);
LABEL_21:
          v14 = v15;
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(cf);
          if (!v5)
            return v14;
          goto LABEL_22;
        }
      }
      else if (!TFSInfo::IsBootVolume((TFSInfo *)v6))
      {
        TFSInfo::Name((TFSInfo *)v6, (TString *)cf);
        v15 = TString::StringCompare((TString *)cf, a2);
        goto LABEL_21;
      }
      TFSInfo::DisplayName((TFSInfo *)v6, (TString *)cf);
      v15 = TString::StringCompare((TString *)cf, a2);
      goto LABEL_21;
    }
  }
  v14 = -1;
  if (!v5)
    return v14;
LABEL_22:
  v19 = (unint64_t *)&v5->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return v14;
}

void sub_1CBC4E1E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::LessThan(TFSInfo *this, TFSInfo **a2)
{
  int v4;
  id v5;
  id v6;
  void *v7;
  void *v8;
  uint64_t v9;
  _BOOL8 v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  int v13;
  void *v14;
  uint64_t v15;
  void *v16;
  CFComparisonResult v17;
  unint64_t VolumeIdentifier;
  unint64_t v19;
  unint64_t ObjectIdentifier;
  TFSInfo *v22;
  os_unfair_lock_s *v23;
  uint64_t v24;
  int v25;
  void *v26;
  void *v27;
  uint64_t v28;
  TString *fRef;
  TString *v30;
  TString *v31;
  CFComparisonResult v32;
  id v33;
  id v34;
  id v35;
  id v36;
  TString v37;
  TString v38;
  TString v39;
  _QWORD v40[2];
  TString v41;
  TString v42;
  TString v43[3];

  v43[2] = *(TString *)MEMORY[0x1E0C80C00];
  if (*a2 == this)
    return 0;
  v4 = *((unsigned __int8 *)this + 112);
  if (v4 == 25)
  {
    TFSInfo::GetFPItem(this);
    v5 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "itemIdentifier");
    v6 = (id)objc_claimAutoreleasedReturnValue();
    TFSInfo::GetFPItem(*a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "itemIdentifier");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v6, "compare:", v8);
    goto LABEL_4;
  }
  if ((v4 - 23) <= 1)
    return v4 == 23;
  if (v4 != 28)
  {
    if (v4 == 27)
    {
      v11 = (os_unfair_lock_s *)((char *)this + 96);
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      v12 = *((_QWORD *)this + 10);
      if (v12
        && (os_unfair_lock_lock((os_unfair_lock_t)(v12 + 72)),
            v13 = *(unsigned __int8 *)(v12 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 72)),
            v13 == 1))
      {
        v5 = *(id *)(v12 + 24);
      }
      else
      {
        v5 = 0;
      }
      os_unfair_lock_unlock(v11);
      v22 = *a2;
      v23 = (os_unfair_lock_s *)((char *)*a2 + 96);
      os_unfair_lock_lock(v23);
      v24 = *((_QWORD *)v22 + 10);
      if (v24
        && (os_unfair_lock_lock((os_unfair_lock_t)(v24 + 72)),
            v25 = *(unsigned __int8 *)(v24 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v24 + 72)),
            v25 == 1))
      {
        v6 = *(id *)(v24 + 24);
      }
      else
      {
        v6 = 0;
      }
      os_unfair_lock_unlock(v23);
      if (!v5 && v6)
      {
        v10 = 1;
        goto LABEL_5;
      }
      if (!v6)
      {
        v10 = 0;
        goto LABEL_5;
      }
      objc_msgSend(v5, "identifier");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "identifier");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v9 = objc_msgSend(v7, "compare:", v8);
LABEL_4:
      v10 = v9 == 1;

LABEL_5:
      return v10;
    }
    TFSInfo::Name(this, &v41);
    TFSInfo::Name(*a2, &v39);
    v17 = TString::StringCompare(&v41, &v39);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v41.fString.fRef);
    if (v17 == kCFCompareLessThan)
      return 1;
    if (v17 == kCFCompareEqualTo)
    {
      VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
      v19 = TFSInfo::GetVolumeIdentifier(*a2);
      if (VolumeIdentifier != v19)
        return VolumeIdentifier < v19;
      ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
      return ObjectIdentifier > TFSInfo::GetObjectIdentifier(*a2);
    }
    return 0;
  }
  TFSInfo::GetFPItem(this);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  TFSInfo::GetFPItem(*a2);
  v15 = objc_claimAutoreleasedReturnValue();
  v16 = (void *)v15;
  if (v14 || !v15)
  {
    if (v15)
    {
      TFSInfo::Name(this, &v38);
      TFSInfo::Name(*a2, &v37);
      std::pair<TString,TString>::pair[abi:ne180100]<TString,TString,0>((CFTypeRef *)&v41.fString.fRef, (CFTypeRef *)&v38.fString.fRef, (CFTypeRef *)&v37.fString.fRef);
      objc_msgSend(v14, "providerDomainID");
      v36 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "providerDomainID");
      v35 = (id)objc_claimAutoreleasedReturnValue();
      std::pair<TString,TString>::pair[abi:ne180100]<NSString * {__strong},NSString * {__strong},0>(&v42, &v36, &v35);
      objc_msgSend(v14, "itemID");
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v26, "identifier");
      v34 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "itemID");
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "identifier");
      v33 = (id)objc_claimAutoreleasedReturnValue();
      std::pair<TString,TString>::pair[abi:ne180100]<NSString * {__strong},NSString * {__strong},0>(v43, &v34, &v33);
      std::vector<std::pair<TString,TString>>::vector[abi:ne180100]((uint64_t)&v39, (TString **)&v41, 3uLL);
      v28 = 6;
      do
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40[v28 + 1]);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40[v28]);
        v28 -= 2;
      }
      while (v28 * 8);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v37.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);
      fRef = (TString *)v39.fString.fRef;
      v30 = (TString *)v40[0];
      while (1)
      {
        if (fRef == v30)
        {
LABEL_41:
          v10 = 0;
          goto LABEL_46;
        }
        v31 = fRef + 1;
        v32 = TString::StringCompare(fRef, fRef + 1);
        if (v32 == kCFCompareLessThan)
          break;
        if (v32 == kCFCompareGreaterThan)
          goto LABEL_41;
        fRef = v31 + 1;
      }
      v10 = 1;
LABEL_46:
      v41.fString.fRef = (__CFString *)&v39;
      std::vector<std::pair<TString,TString>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v41);
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    v10 = 1;
  }

  return v10;
}

void sub_1CBC4E66C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void TFSInfo::Name(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  TFSInfo::GetNameWhileLocked(this, a2);
  os_unfair_lock_unlock(v4);
}

void sub_1CBC4E840(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::GetNameWhileLocked(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 3));
}

void sub_1CBC4E890(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

CFComparisonResult TString::StringCompare(TString *this, const TString *a2)
{
  return CFStringCompare(this->fString.fRef, a2->fString.fRef, 0);
}

BOOL TFSInfo::IsBootVolume(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  _BOOL8 v4;
  __int128 v6;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x100) == 0)
    return 0;
  TFSInfo::GetVolumeID(this, (_QWORD *)&v6 + 1);
  ROSPVolumeID::BootVolumeID(&v6);
  v4 = v6 == 0;
  if (*((_QWORD *)&v6 + 1) && (_QWORD)v6)
    v4 = CFEqual(*((CFTypeRef *)&v6 + 1), (CFTypeRef)v6) != 0;
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v6);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v6 + 1);
  return v4;
}

void sub_1CBC4E958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a9);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

uint64_t TNode::IsVisible(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  TNode *v8;
  unint64_t *v9;
  unint64_t v10;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  TFSInfo *v13;
  unint64_t *v14;
  unint64_t v15;
  int IsRootItem;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  TNode *v20;
  TFSVolumeInfo *v21;
  os_unfair_lock_s *v22;
  std::__shared_weak_count *v23;
  TFSInfo *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  TString v33;
  TFSVolumeInfo *v34;
  std::__shared_weak_count *v35;
  TFSInfo *v36;
  std::__shared_weak_count *v37;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v7 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 100));
  if (!v3)
    goto LABEL_8;
  v9 = (unint64_t *)&v3->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v7 & 1) == 0)
      goto LABEL_37;
  }
  else
  {
LABEL_8:
    if ((v7 & 1) == 0)
      goto LABEL_37;
  }
  v11 = (os_unfair_lock_s *)TNode::InfoLock(v8);
  os_unfair_lock_lock(v11);
  v13 = (TFSInfo *)*((_QWORD *)this + 2);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v36 = v13;
  v37 = v12;
  if (v12)
  {
    v14 = (unint64_t *)&v12->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  os_unfair_lock_unlock(v11);
  IsRootItem = TFSInfo::IsRootItem(v13);
  v17 = IsRootItem;
  if (!v12)
    goto LABEL_16;
  v18 = (unint64_t *)&v12->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (v19)
  {
LABEL_16:
    if (IsRootItem)
      goto LABEL_17;
LABEL_37:
    LOBYTE(v17) = v7 & 1;
    return v17 & 1;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (!v17)
    goto LABEL_37;
LABEL_17:
  TNode::GetVolumeInfo(this, &v34);
  v21 = v34;
  if (v34)
  {
    v22 = (os_unfair_lock_s *)TNode::InfoLock(v20);
    os_unfair_lock_lock(v22);
    v24 = (TFSInfo *)*((_QWORD *)this + 2);
    v23 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v36 = v24;
    v37 = v23;
    if (v23)
    {
      v25 = (unint64_t *)&v23->__shared_owners_;
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
    os_unfair_lock_unlock(v22);
    TFSInfo::Name(v24, &v33);
    if (v23)
    {
      v27 = (unint64_t *)&v23->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    LOBYTE(v17) = !TFSVolumeInfo::IsHiddenFile(v21, &v33);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v33.fString.fRef);
  }
  v29 = v35;
  if (v35)
  {
    v30 = (unint64_t *)&v35->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if (!v21)
    goto LABEL_37;
  return v17 & 1;
}

void sub_1CBC4EBA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsRootItem(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  const __CFString *v4;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0 || *((_BYTE *)this + 112))
    return 0;
  else
    return TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AD38], v4);
}

uint64_t TPropertyReference::SetAs<BOOL>(uint64_t a1, _BYTE *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      result = 0;
      **(_BYTE **)a1 = *a2;
      return result;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<BOOL>(*(_QWORD *)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void std::__shared_ptr_emplace<TFSInfo>::__on_zero_shared(uint64_t a1)
{
  TFSInfo::~TFSInfo((TFSInfo *)(a1 + 24));
}

uint64_t TFSInfo::CanHaveOriginatorInfo(TFSInfo *this)
{
  void *v2;
  uint64_t v3;
  id v5;
  void *SYDocumentWorkflowsClass;
  void *v7;
  os_unfair_lock_s *v8;
  char v9;
  id location;

  if (!ReturnToSenderEnabled())
    return 0;
  TFSInfo::OriginatorInfo(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  if (v2)
    return 1;
  if (*((_BYTE *)this + 112))
    return 0;
  location = 0;
  TFSInfo::GetUTType(this, &location, 128, &v9);
  v5 = location;
  if (v5)
  {
    SYDocumentWorkflowsClass = (void *)getSYDocumentWorkflowsClass();
    objc_msgSend(v5, "identifier");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = objc_msgSend(SYDocumentWorkflowsClass, "isSupportedContentType:", v7);

  }
  else
  {
    v8 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v3 = (*(_DWORD *)((char *)this + 115) & 0x40) == 0;
    os_unfair_lock_unlock(v8);
  }

  return v3;
}

void sub_1CBC4EECC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC4EF5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOriginatorInfo(uint64_t a1, uint64_t a2, uint64_t a3, char a4, _BYTE *a5)
{
  os_unfair_lock_s *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  void *v17;
  int v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  void *v22;
  id v23;
  void *v24;
  unint64_t v26;
  char v27;
  uint64_t v28;
  id v29;

  v29 = 0;
  if ((ReturnToSenderEnabled() & 1) != 0)
  {
    TFSInfo::OriginatorInfo((TFSInfo *)a1);
    v29 = (id)objc_claimAutoreleasedReturnValue();
    v9 = (os_unfair_lock_s *)(a1 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    v10 = *(const void **)(a1 + 16);
    v28 = (uint64_t)v10;
    if (v10)
    {
      CFRetain(v10);
      v11 = (void *)v28;
    }
    else
    {
      v11 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    v13 = v11;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v28);
    if (!v13)
    {
      TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, &v29);
LABEL_24:
      v12 = 0;
LABEL_25:

      goto LABEL_26;
    }
    if (a4 < 0)
    {
      *a5 = 0;
      TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, &v29);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
      v21 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
      os_unfair_lock_unlock(v9);
      if ((v21 & 0x200000000000) != 0)
        v12 = 0;
      else
        v12 = 4294959210;
      goto LABEL_25;
    }
    objc_msgSend((id)getSYDocumentAttributesClass(), "documentAttributesForFileAtURL:", v13);
    v28 = objc_claimAutoreleasedReturnValue();
    TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, (id *)&v28);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    v14 = *(unsigned int *)(a1 + 115);
    v15 = v14 | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32) | 0x200000000000;
    *(_DWORD *)(a1 + 115) = v14;
    *(_WORD *)(a1 + 119) = WORD2(v15);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    v16 = v29 == 0;
    v17 = (void *)v28;
    v18 = v28 == 0;
    *a5 = v16 ^ v18;
    if (v16 == v18)
    {
LABEL_23:

      goto LABEL_24;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (v28 && !*(_QWORD *)(a1 + 80))
      TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
    v19 = *(_QWORD *)(a1 + 80);
    if (!v19)
    {
LABEL_22:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
      v17 = (void *)v28;
      goto LABEL_23;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 72));
    v20 = *(unsigned __int8 *)(v19 + 76);
    if (v20 == 3)
    {
      *(_BYTE *)(v19 + 76) = 2;
      *(_QWORD *)v19 = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 72));
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 72));
      if (v20 != 2)
      {
        v26 = TFSInfoOverflow::ICloud(*(_QWORD *)(a1 + 80), 0);
        if (!v27)
          goto LABEL_22;
        v22 = (void *)v28;
        v19 = v26 + 16;
        goto LABEL_21;
      }
    }
    v22 = (void *)v28;
LABEL_21:
    v23 = v22;
    v24 = *(void **)v19;
    *(_QWORD *)v19 = v23;

    goto LABEL_22;
  }
  TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, &v29);
  v12 = 0;
LABEL_26:

  return v12;
}

void sub_1CBC4F1B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10)
{
  void *v10;
  os_unfair_lock_s *v11;

  os_unfair_lock_unlock(v11);

  _Unwind_Resume(a1);
}

uint64_t ReturnToSenderEnabled(void)
{
  unsigned __int8 v0;

  {
    ReturnToSenderEnabled(void)::enabled = getSYDocumentWorkflowsClass() != 0;
  }
  return ReturnToSenderEnabled(void)::enabled;
}

void sub_1CBC4F274(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(uint64_t a1, id *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<SYDocumentAttributes * {__strong}>(*(id **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

id SYDocumentWorkflowsFunction(void)
{
  return (id)classSYDocumentWorkflows;
}

{
  return (id)classSYDocumentWorkflows;
}

uint64_t TFSInfo::GetDownloadedState(TFSInfo *a1, uint64_t a2)
{
  char v4;

  v4 = TFSInfo::GetBladeRunnerFlags(a1) & 1;
  return TPropertyReference::SetAs<BOOL>(a2, &v4);
}

uint64_t TFSInfo::SetUTType(TFSInfo *this, UTType *a2, int a3)
{
  UTType *v6;
  os_unfair_lock_s *v7;
  id *v8;
  void *v9;
  uint64_t v10;

  v6 = a2;
  v7 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v9 = (void *)*((_QWORD *)this + 5);
  v8 = (id *)((char *)this + 40);
  if ((objc_msgSend(v9, "isEqual:", v6) & 1) != 0 || a3 && *v8)
  {
    v10 = 0;
  }
  else
  {
    objc_storeStrong(v8, a2);
    v10 = 1;
  }
  os_unfair_lock_unlock(v7);

  return v10;
}

void sub_1CBC4F4D4(_Unwind_Exception *a1)
{
  void *v1;
  os_unfair_lock_s *v2;

  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetItemDecorations(TFSInfo *a1, uint64_t a2)
{
  void *v3;
  void *v4;
  uint64_t v5;
  CFTypeRef v7;

  TFSInfo::GetFPItem(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "itemDecorations");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v4;
  v5 = TPropertyReference::SetAs<__CFArray const*>(a2, &v7);

  return v5;
}

void sub_1CBC4F550(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TNodeTask>::__on_zero_shared(uint64_t a1)
{
  std::__destroy_at[abi:ne180100]<TNodeTask,0>(a1 + 24);
}

id SYDocumentAttributesFunction(void)
{
  return (id)classSYDocumentAttributes;
}

id **TNodeEventPtrs::SendNotifications(id **this)
{
  id *v1;
  id *v2;
  id **v3;
  char *v4;
  void *v5;
  TNodeEvent *v6;
  TDSNotifier *v7;
  TDSNotifier *v8;
  void **v9;
  id *i;
  id *v11;
  _QWORD *j;
  TDSNotifier *v13;
  TDSNotifier *v14[3];
  TNodePtr v15;
  __int128 v16;
  __int128 v17;
  int v18;
  TDSNotifier **v19;

  v1 = *this;
  v2 = this[1];
  if (*this != v2)
  {
    v3 = this;
    v16 = 0u;
    v17 = 0u;
    v18 = 1065353216;
    do
    {
      v15.fFINode = (FINode *)*v1;
      v4 = (char *)v1[1];
      v5 = v4;
      if (v4)
        v6 = (TNodeEvent *)(v4 + 8);
      else
        v6 = 0;
      TFSInfo::MarkAsUsed((TFSInfo *)v6->fEventKind);
      TNodeEvent::NotifyNode((TDSNotifier ***)v14, v6, &v15, 0);
      v7 = v14[0];
      v8 = v14[1];
      while (v7 != v8)
      {
        v9 = *(void ***)v7;
        v19 = (TDSNotifier **)v9;
        if (v9)
          TDSNotifier::AddPtrReference((TDSNotifier *)v9);
        std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__emplace_unique_key_args<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>((uint64_t)&v16, &v19, (TDSNotifier **)&v19);
        TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v19);
        v7 = (TDSNotifier *)((char *)v7 + 8);
      }
      v19 = v14;
      std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v19);

      v1 += 2;
    }
    while (v1 != v2);
    v11 = *v3;
    for (i = v3[1]; i != v11; std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,TNodeEventPtr>,0>(i))
      i -= 2;
    v3[1] = v11;
    for (j = (_QWORD *)v17; j; j = (_QWORD *)*j)
    {
      v13 = (TDSNotifier *)j[2];
      v14[0] = v13;
      if (v13)
      {
        TDSNotifier::AddPtrReference(v13);
        v13 = v14[0];
      }
      TDSNotifier::Tickle(v13, 0);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v14);
    }
    return (id **)std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::~__hash_table((uint64_t)&v16);
  }
  return this;
}

void sub_1CBC4F720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void TNodeEvent::NotifyNode(TDSNotifier ***__return_ptr a1@<X8>, TNodeEvent *this@<X0>, const TNodePtr *a3@<X1>, int a4@<W2>)
{
  TNode *v7;
  TNode *v8;
  TDSNotifier **v9;
  uint64_t v10;
  TDSNotifier *v11;
  TDSNotifier *v12;

  v7 = (TNode *)TNodeFromFINode(a3->fFINode);
  TNode::Notifiers(v7, a1);
  if (TNode::IsContextOpen(v8))
  {
    v9 = *a1;
    v10 = (uint64_t)a1[1];
    while (v9 != (TDSNotifier **)v10)
    {
      v11 = *v9;
      v12 = v11;
      if (v11)
        TDSNotifier::AddPtrReference(v11);
      TNodeEvent::NotifyCommon(&this->fEventKind, &v12, a4);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v12);
      ++v9;
    }
    TNodeEvent::ForwardEventToParent(this);
  }
}

void sub_1CBC4F81C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void TNode::Notifiers(TNode *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  TNotifierList *v5;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v5 = (TNotifierList *)*((_QWORD *)this + 9);
  if (v5)
  {
    TNotifierList::Notifiers(v5, a2);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  os_unfair_lock_unlock(v4);
}

void sub_1CBC4F89C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TNodeEvent::ForwardEventToParent(TNodeEvent *this)
{
  unsigned int fEventKind;
  OpaqueNodeRef *v3;
  OpaqueNodeRef *v4;
  const TNode *v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  TNode *v9;
  uint64_t v10;
  uint64_t v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  os_unfair_lock_s *v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  os_unfair_lock_s *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  BOOL v30;
  uint64_t v31;
  BOOL v32;
  int v33;
  int v34;
  unsigned int fProperty;
  TDSNotifier **v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  char *v40;
  TNodeEvent *v41;
  TNode *v42;
  TNodeEvent *v43;
  uint64_t v44[3];
  uint64_t v45[3];
  uint64_t v46[3];
  TNodePtr v47;
  FINode *v48;
  std::__shared_weak_count *v49;
  char *v50;
  TNodePtr v51;
  TNodePtr v52;

  if (!TNode::IsContextOpen((TNode *)this))
    return;
  fEventKind = this->fEventKind;
  v3 = -[FINode nodeRef](this->fFINode, "nodeRef");
  v5 = (const TNode *)TNode::NodeFromNodeRef((TNode *)v3, v4);
  TNodePtr::TNodePtr(&v52, v5);
  v6 = TNodeFromFINode(v52.fFINode);
  v7 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v6);
  os_unfair_lock_lock(v7);
  TNodePtr::TNodePtr(&v51, *(const TNode **)(v6 + 48));
  os_unfair_lock_unlock(v7);
  if (fEventKind == 2)
    v8 = 6;
  else
    v8 = 4 * (fEventKind == 1);
  v9 = (TNode *)TNodeFromFINode(v51.fFINode);
  TNode::GetSuperRootNode((uint64_t *)&v48, v9);
  v10 = TNodeFromFINode(v48);

  if (v9 == (TNode *)v10)
    goto LABEL_14;
  v11 = TNodeFromFINode(v52.fFINode);
  v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
  os_unfair_lock_lock(v12);
  v14 = *(_QWORD *)(v11 + 16);
  v13 = *(std::__shared_weak_count **)(v11 + 24);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v12);
  v17 = (os_unfair_lock_s *)(v14 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
  v18 = *(_DWORD *)(v14 + 115);
  os_unfair_lock_unlock(v17);
  if (v13)
  {
    v19 = (unint64_t *)&v13->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      if ((v18 & 0x100) == 0)
        goto LABEL_14;
LABEL_16:
      v22 = TNodeFromFINode(v52.fFINode);
      v23 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v22);
      os_unfair_lock_lock(v23);
      v25 = *(_QWORD *)(v22 + 16);
      v24 = *(std::__shared_weak_count **)(v22 + 24);
      if (v24)
      {
        v26 = (unint64_t *)&v24->__shared_owners_;
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
        os_unfair_lock_unlock(v23);
        v28 = *(unsigned __int8 *)(v25 + 112);
        do
          v29 = __ldaxr(v26);
        while (__stlxr(v29 - 1, v26));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      else
      {
        os_unfair_lock_unlock(v23);
        v28 = *(unsigned __int8 *)(v25 + 112);
      }
      if (v28)
        v30 = 0;
      else
        v30 = fEventKind == 2;
      v21 = v30;
      goto LABEL_30;
    }
  }
  if ((v18 & 0x100) != 0)
    goto LABEL_16;
LABEL_14:
  v21 = 0;
LABEL_30:
  v31 = TNodeFromFINode(v51.fFINode);
  v32 = fEventKind - 1 >= 2 || v31 == 0;
  v33 = !v32;
  if (v32)
    v34 = v21;
  else
    v34 = 1;
  if (v34 == 1)
  {
    TFSInfo::MarkAsUsed((TFSInfo *)v8);
    fProperty = this->fProperty;
    v48 = 0;
    v49 = 0;
    v47.fFINode = 0;
    TNodeEvent::CreateNodeEvent(v8, (id *)&v52.fFINode, fProperty, &this->fPropertyValue, (uint64_t *)&v48, (TDSNotifier **)&v47, &v50);
    v36 = TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v47);
    v37 = v49;
    if (v49)
    {
      v38 = (unint64_t *)&v49->__shared_owners_;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    v40 = v50;
    if (v33)
    {
      if (v50)
        v41 = (TNodeEvent *)(v50 + 8);
      else
        v41 = 0;
      TNodeEvent::NotifyNode(v46, v41, &v51, 1);
      v48 = (FINode *)v46;
      std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v48);
      v42 = (TNode *)TNodeFromFINode(v52.fFINode);
      TNode::SecondParent(v42, &v47);
      if (TNodeFromFINode(v47.fFINode))
      {
        TNodeEvent::NotifyNode(v45, v41, &v47, 1);
        v48 = (FINode *)v45;
        std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v48);
      }

    }
    if (v21)
    {
      TNode::GetSuperRootNode((uint64_t *)&v47, (TNode *)v36);
      if (v40)
        v43 = (TNodeEvent *)(v40 + 8);
      else
        v43 = 0;
      TNodeEvent::NotifyNode(v44, v43, &v47, 1);
      v48 = (FINode *)v44;
      std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v48);

    }
  }

}

void sub_1CBC4FC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  void *v19;
  uint64_t v20;

  _Unwind_Resume(a1);
}

void sub_1CBC4FCA4()
{
  JUMPOUT(0x1CBC4FC94);
}

uint64_t TNodeFromFINode(FINode *a1)
{
  void *v1;
  uint64_t v2;

  static_objc_cast<NSString,objc_object * {__strong}>(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "asTNode");

  return v2;
}

void sub_1CBC4FCE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL TNode::IsContextOpen(TNode *this)
{
  int v1;

  ContextMutex();
  TDSMutex::lock(&ContextMutex(void)::mutex);
  v1 = sContextOpenCount;
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  return v1 > 0;
}

uint64_t TDSMutex::unlock(TDSMutex *this)
{
  uint64_t result;

  result = pthread_mutex_unlock(&this->fMutex);
  if ((_DWORD)result)
    abort();
  return result;
}

uint64_t TDSMutex::lock(TDSMutex *this)
{
  uint64_t result;

  result = pthread_mutex_lock(&this->fMutex);
  if ((_DWORD)result)
    abort();
  return result;
}

int *TNode::ParentLock(TNode *this)
{
  unsigned __int8 v1;

  {
    TNode::ParentLock(void)::sParentLock = 0;
  }
  return &TNode::ParentLock(void)::sParentLock;
}

void TNodePtr::TNodePtr(TNodePtr *this, const TNode *a2)
{
  FINodeFromTNode(a2);
  this->fFINode = (FINode *)objc_claimAutoreleasedReturnValue();
}

const TNode *FIDSNodeFromTNode(TNode *a1)
{
  unsigned __int8 v1;
  int v3;
  objc_class *v4;
  objc_ivar *InstanceVariable;
  const TNode *v6;

  if (a1)
  {
    if ((v1 & 1) == 0)
    {
      v6 = a1;
      a1 = (TNode *)v6;
      if (v3)
      {
        v4 = (objc_class *)objc_opt_class();
        InstanceVariable = class_getInstanceVariable(v4, "_node");
        FIDSNodeFromTNode(TNode const*)::nodeOffset = ivar_getOffset(InstanceVariable);
        a1 = (TNode *)v6;
      }
    }
    static_objc_cast<DSFileServiceConnection,void *>((char *)a1 - FIDSNodeFromTNode(TNode const*)::nodeOffset);
    a1 = (TNode *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

void sub_1CBC4FE8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id static_objc_cast<DSFileServiceConnection,void *>(void *a1)
{
  static_objc_cast<NSString,objc_object * {__strong}>(a1);
  return (id)objc_claimAutoreleasedReturnValue();
}

id static_objc_cast<NSString,objc_object * {__strong}>(id a1)
{
  void *v1;

  if (a1)
  {
    v1 = a1;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return 0;
    a1 = v1;
  }
  return a1;
}

TDSNotifier **TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(TDSNotifier **a1, TDSNotifier **a2)
{
  TDSNotifier *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      TDSNotifier::RemovePtrReference(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

TNodeRequest **TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(TNodeRequest **a1)
{
  TNodeRequest *v2;

  v2 = *a1;
  if (v2)
    NodeDisposeRequest(v2);
  return a1;
}

TNode *GetNodeProperty(TNode *a1, OpaqueNodeRef *a2, TPropertyReference *a3, TNodeRequest *a4, unsigned int a5)
{
  uint64_t v7;
  uint64_t v8;
  const TNode *v9;
  TNode *result;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  os_unfair_lock_s *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  TNodeRequest *v20;

  v7 = (uint64_t)a2;
  v20 = a4;
  v8 = TNode::NodeFromNodeRef(a1, a2);
  result = (TNode *)TNode::WeakValidate((TNode *)v8, v9);
  if (!(_DWORD)result)
  {
    if ((_DWORD)v7 == 1684955501)
    {
      v11 = (os_unfair_lock_s *)TNode::InfoLock(result);
      os_unfair_lock_lock(v11);
      v13 = *(_QWORD *)(v8 + 16);
      v12 = *(std::__shared_weak_count **)(v8 + 24);
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v11);
      v16 = (os_unfair_lock_s *)(v13 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
      v17 = *(unsigned int *)(v13 + 115) | ((unint64_t)*(unsigned __int16 *)(v13 + 119) << 32);
      os_unfair_lock_unlock(v16);
      if (v12)
      {
        v18 = (unint64_t *)&v12->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      if ((v17 & 0x100000000) != 0)
        v7 = 1886282093;
      else
        v7 = 1684955501;
    }
    return (TNode *)TNode::GetProperty(v8, v7, a3, &v20, a5);
  }
  return result;
}

uint64_t TNode::WeakValidate(TNode *this, const TNode *a2)
{
  if (this)
    return 0;
  else
    return 4294959238;
}

uint64_t TNode::GetProperty(uint64_t a1, uint64_t a2, TPropertyReference *a3, TNodeRequest **a4, unsigned int a5)
{
  uint64_t v9;
  TNode *Property;
  TNode *v11;
  int v12;
  int v13;
  unsigned __int16 *v14;
  unsigned __int16 v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  os_unfair_lock_s *v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v26;
  os_unfair_lock_s *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  int v32;
  unint64_t v33;
  os_unfair_lock_s *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  os_unfair_lock_s *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  TNodeRequest *v43;
  TNodeRequest *v44;
  TNodeRequest *v45;
  TPropertyValue v46;
  unsigned int v47;

  v47 = a5;
  if (*a4)
    v9 = a5 | 0x82;
  else
    v9 = a5;
  Property = (TNode *)TNode::GetProperty(a1, a2, (uint64_t)a3, v9);
  v11 = Property;
  v12 = 0;
  if ((int)a2 > 1819240306)
  {
    if ((_DWORD)a2 != 1885895027)
    {
      v13 = 1819240307;
LABEL_9:
      if ((_DWORD)a2 != v13)
        goto LABEL_14;
    }
  }
  else if ((_DWORD)a2 != 1667330145)
  {
    v13 = 1718776688;
    goto LABEL_9;
  }
  Property = (TNode *)TNode::IsDeferredForSymlink(a1, (uint64_t (*)(_QWORD *))TFSInfo::IsPackage, 0);
  if ((_DWORD)Property)
  {
    v14 = (unsigned __int16 *)(a1 + 80);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 | 0x80, v14));
  }
  v12 = 1;
LABEL_14:
  if ((_DWORD)v11 == -8053)
  {
    v27 = (os_unfair_lock_s *)TNode::InfoLock(Property);
    os_unfair_lock_lock(v27);
    v29 = *(_QWORD *)(a1 + 16);
    v28 = *(std::__shared_weak_count **)(a1 + 24);
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v31 = __ldxr(p_shared_owners);
      while (__stxr(v31 + 1, p_shared_owners));
      os_unfair_lock_unlock(v27);
      v32 = *(unsigned __int8 *)(v29 + 112);
      do
        v33 = __ldaxr(p_shared_owners);
      while (__stlxr(v33 - 1, p_shared_owners));
      if (v33)
      {
        if (!v32)
          goto LABEL_42;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
        if (!v32)
          goto LABEL_42;
      }
    }
    else
    {
      os_unfair_lock_unlock(v27);
      if (!*(_BYTE *)(v29 + 112))
        goto LABEL_42;
    }
    return 4294959243;
  }
  if ((_DWORD)v11 != -8074)
  {
    if ((_DWORD)v11 != -8086)
      return (uint64_t)v11;
    if ((_DWORD)a2 == 1668506984)
      goto LABEL_20;
    if ((_DWORD)a2 == 1684955501)
    {
      if (*a4)
      {
LABEL_20:
        v16 = (os_unfair_lock_s *)TNode::InfoLock(Property);
        os_unfair_lock_lock(v16);
        v18 = *(_QWORD *)(a1 + 16);
        v17 = *(std::__shared_weak_count **)(a1 + 24);
        if (v17)
        {
          v19 = (unint64_t *)&v17->__shared_owners_;
          do
            v20 = __ldxr(v19);
          while (__stxr(v20 + 1, v19));
        }
        os_unfair_lock_unlock(v16);
        v21 = (os_unfair_lock_s *)(v18 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v18 + 100));
        v22 = *(_DWORD *)(v18 + 115);
        os_unfair_lock_unlock(v21);
        if (!v17)
          goto LABEL_27;
        v23 = (unint64_t *)&v17->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
          if ((v22 & 0x40000000) != 0)
            return 0;
        }
        else
        {
LABEL_27:
          if ((v22 & 0x40000000) != 0)
            return 0;
        }
        LODWORD(v45) = 0x80000;
        v46.fData.__impl_.__index = 0;
        std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v46, &v45);
        TNode::RequestInternalTask((const TNode *)a1, 1000, &v46, 0);
        TPropertyValue::~TPropertyValue(&v46);
        return 0;
      }
      return 0;
    }
    v26 = v47;
    if ((v47 & 0x80) != 0)
    {
      if (TPropertyReference::IsValid(a3))
        return 0;
      goto LABEL_57;
    }
    goto LABEL_43;
  }
LABEL_42:
  v26 = v47;
  if ((v47 & 0x80) != 0)
  {
LABEL_57:
    TPropertyReference::Clear((void ***)a3);
    return (uint64_t)v11;
  }
LABEL_43:
  if (*a4)
  {
    if (!v12)
      goto LABEL_54;
    v34 = (os_unfair_lock_s *)TNode::InfoLock(Property);
    os_unfair_lock_lock(v34);
    v36 = *(_QWORD *)(a1 + 16);
    v35 = *(std::__shared_weak_count **)(a1 + 24);
    if (v35)
    {
      v37 = (unint64_t *)&v35->__shared_owners_;
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    os_unfair_lock_unlock(v34);
    v39 = (os_unfair_lock_s *)(v36 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v36 + 100));
    v40 = *(_DWORD *)(v36 + 115);
    os_unfair_lock_unlock(v39);
    if (v35)
    {
      v41 = (unint64_t *)&v35->__shared_owners_;
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    if ((v40 & 0x20) != 0)
    {
      v46.fData.__impl_.__index = 0;
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v46, &v47);
      v44 = *a4;
      v45 = v44;
      if (v44)
        TNodeRequest::AddPtrReference(v44);
      TNode::RequestTask(a1, 102, a2, &v46, &v45, 0);
    }
    else
    {
LABEL_54:
      v46.fData.__impl_.__index = 0;
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v46, &v47);
      v43 = *a4;
      v45 = v43;
      if (v43)
        TNodeRequest::AddPtrReference(v43);
      TNode::RequestTask(a1, 1, a2, &v46, &v45, 0);
    }
    TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v45);
    TPropertyValue::~TPropertyValue(&v46);
    if ((_DWORD)v11 == -8053)
      return 4294959243;
    else
      return 0;
  }
  else
  {
    TNode::UpdatePropertySynchronous((TNode *)a1, a2, v26, 0);
    TPropertyReference::Clear((void ***)a3);
    return TNode::GetProperty(a1, a2, (uint64_t)a3, v26);
  }
}

void sub_1CBC505D4(_Unwind_Exception *a1, char a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a11);
  _Unwind_Resume(a1);
}

TNodeRequest **NodeDisposeRequest(TNodeRequest *a1)
{
  TNodeRequest *v2;

  v2 = a1;
  return TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v2);
}

TNodeRequest *NodeCreateNewRequest(OpaqueEventNotifier *a1)
{
  TNodeRequest *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  TNodeRequest *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  ClientNotifierFromNodeNotifier(a1, &v7);
  TNodeRequest::Make((uint64_t)&v7, (uint64_t *)&v6);
  v1 = v6;
  v6 = 0;
  TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v6);
  v2 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v1;
}

void sub_1CBC506A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

TNodeRequest **TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(TNodeRequest **a1)
{
  TNodeRequest *v2;

  v2 = *a1;
  if (v2)
    TNodeRequest::RemovePtrReference(v2);
  return a1;
}

BOOL TNodeRequest::RemovePtrReference(TNodeRequest *this)
{
  _BOOL8 result;

  result = TRefCount::Release<int>((unsigned int *)this);
  if (result)
  {
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)this + 3);
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

void TNodeEvent::~TNodeEvent(TNodeEvent *this)
{
  FINode *fFINode;

  fFINode = this->fFINode;
  this->fFINode = 0;

  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&this->fNotifier.fRef);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&this->fTask);
  TPropertyValue::~TPropertyValue(&this->fPropertyValue);

}

TDSNotifier **TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(TDSNotifier **a1)
{
  TDSNotifier *v2;

  v2 = *a1;
  if (v2)
    TDSNotifier::RemovePtrReference(v2);
  return a1;
}

BOOL TDSNotifier::RemovePtrReference(TDSNotifier *this)
{
  _BOOL8 result;

  result = TRefCount::Release<int>((unsigned int *)this + 9);
  if (this && result)
  {

    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

BOOL TRefCount::Release<int>(unsigned int *a1)
{
  void *v1;
  int v2;
  unsigned int v3;
  int v4;
  NSObject *v5;
  BOOL v6;
  __CFString *v7;
  int v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  __CFString *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load(a1);
  if (v2 < 1)
  {
    v4 = v2;
  }
  else
  {
    do
    {
      v3 = v2 - 1;
      v4 = __ldxr(a1);
      if (v4 == v2)
      {
        if (!__stlxr(v3, a1))
          return v2 == 1 && v3 == 0;
      }
      else
      {
        __clrex();
      }
      v2 = v4;
    }
    while (v4 >= 1);
  }
  LogObj(5);
  v5 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v6 = IsRedactionEnabled();
    if (v6)
    {
      v7 = &stru_1E8752DF8;
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB3978], "callStackSymbols");
      v1 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v1, "description");
      v7 = (__CFString *)objc_claimAutoreleasedReturnValue();
    }
    v10 = 136446722;
    v11 = "Release";
    v12 = 2048;
    v13 = v4;
    v14 = 2114;
    v15 = v7;
    _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_ERROR, "%{public}s overrelease -- refCount: %ld\n%{public}@", (uint8_t *)&v10, 0x20u);
    if (!v6)
    {

    }
  }

  v3 = v4 - 1;
  v2 = v4;
  return v2 == 1 && v3 == 0;
}

void sub_1CBC5099C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v2])(&v4, a1);
  *(_DWORD *)(a1 + 16) = -1;
  return a1;
}

TPropertyValue *TPropertyValue::operator=(TPropertyValue *this, TPropertyValue *a2)
{
  if (this != a2)
    TPropertyValue::CopyFrom(this, a2);
  return this;
}

TPropertyValue *TPropertyValue::CopyFrom(TPropertyValue *this, const TPropertyValue *a2)
{
  TPropertyValue *v3;
  unsigned int index;

  if (this != a2)
  {
    v3 = this;
    this = (TPropertyValue *)TPropertyValue::Release(this);
    index = a2->fData.__impl_.__index;
    if (index <= 0x17)
    {
      if (index == 9)
      {
        if (a2->fData.__impl_.__index != 9)
          std::__throw_bad_variant_access[abi:ne180100]();
        std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>((uint64_t)v3, &kEmptyBlob);
        return (TPropertyValue *)TPropertyValue::CopyBlob(v3, (const Blob *)a2);
      }
      else
      {
        return (TPropertyValue *)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v3, (uint64_t)a2);
      }
    }
  }
  return this;
}

void TPropertyValue::~TPropertyValue(TPropertyValue *this)
{
  TPropertyValue::Release(this);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)this);
}

uint64_t TPropertyValue::Release(TPropertyValue *this)
{
  unsigned int index;
  char *buffer;
  uint64_t *v4;
  const void *value;
  TReferenceCounted *v7;

  index = this->fData.__impl_.__index;
  switch((char)index)
  {
    case 9:
      if (index != 9)
        goto LABEL_28;
      buffer = this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
      if (buffer)
        MEMORY[0x1D17A53B8](buffer, 0x1000C8077774924);
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>((uint64_t)this, &kEmptyBlob);
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
    case 10:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},decltype(nullptr)>((uint64_t)this, (void **)this);
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
    case 11:
      v4 = TString::KEmptyString((TString *)this);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>((uint64_t)this, (TString **)this, (TString **)v4);
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
    case 12:
      if (index != 12)
        goto LABEL_28;
      goto LABEL_21;
    case 13:
      if (index != 13)
        goto LABEL_28;
      goto LABEL_21;
    case 14:
      if (index != 14)
        goto LABEL_28;
      goto LABEL_21;
    case 15:
      if (index != 15)
        goto LABEL_28;
      goto LABEL_21;
    case 16:
      if (index != 16)
        goto LABEL_28;
      goto LABEL_21;
    case 17:
      if (index == 17)
        goto LABEL_21;
      goto LABEL_28;
    case 18:
      if (index != 18)
        goto LABEL_28;
LABEL_21:
      value = (const void *)this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
      if (this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value)
        CFRelease(value);
      goto LABEL_23;
    case 19:
      if (index != 19)
LABEL_28:
        std::__throw_bad_variant_access[abi:ne180100]();
      v7 = (TReferenceCounted *)this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
      if (this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value)
        TReferenceCounted::RemovePtrReference(v7);
LABEL_23:
      this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = 0;
      break;
    default:
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
  }
  return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
}

uint64_t *TGlobalNodes::RootNode@<X0>(uint64_t *__return_ptr a1@<X8>)
{
  id *v3;
  uint64_t *result;
  _QWORD block[5];

  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = (id *)TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes8RootNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::RootNode(void)::onceToken != -1)
    dispatch_once(&TGlobalNodes::RootNode(void)::onceToken, block);
  result = (uint64_t *)*v3;
  *a1 = (uint64_t)result;
  return result;
}

void TNotifierList::Notifiers(TNotifierList *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__init_with_size[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>(a2, *((_QWORD *)this + 5), *((_QWORD *)this + 6), (uint64_t)(*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3);
  os_unfair_lock_unlock(v4);
}

void sub_1CBC50D4C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TNodeEvent::NotifyCommon(unsigned int *a1, TDSNotifier **a2, int a3)
{
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t v10;

  if (TNode::IsContextOpen((TNode *)a1))
  {
    v7 = *(_QWORD *)*a2;
    v6 = (std::__shared_weak_count *)*((_QWORD *)*a2 + 1);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    if (v7)
    {
      TNodeEvent::RedispatchEventToNotifier((uint64_t)a1, *a1, *(_QWORD *)(*(_QWORD *)*a2 + 40), a2);
      if (a3)
        TDSNotifier::Tickle(*a2, *a1 == 8);
    }
  }
  return 0;
}

void TNode::SecondParent(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  char v3;
  uint64_t v5;
  TNodePtr v6;
  TNodePtr *v7;

  v3 = atomic_load((unsigned __int16 *)this + 40);
  if ((v3 & 2) != 0)
  {
    v5 = TNode::FirmlinkParents(this);
    TNodePtr::TNodePtr(&v6, this);
    v7 = &v6;
    a2->fFINode = (FINode *)*((id *)std::__hash_table<std::__hash_value_type<TNodePtr,TNodePtr>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,TNodePtr>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr&&>,std::tuple<>>(v5, &v6.fFINode, (uint64_t)&std::piecewise_construct, (id **)&v7)+ 3);

  }
  else
  {
    TNodePtr::TNodePtr(a2, 0);
  }
}

void sub_1CBC50EC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNodeEvent::CreateNodeEvent(int a1@<W0>, id *a2@<X1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  TDSNotifier *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  TPropertyValue v10;

  memset(&v10, 0, sizeof(v10));
  v8 = 0;
  v9 = 0;
  v7 = 0;
  TNodeEvent::CreateNodeEvent(a1, a2, a3, &v10, &v8, &v7, a4);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v7);
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  TPropertyValue::~TPropertyValue(&v10);
}

void sub_1CBC50F64(_Unwind_Exception *a1, char a2, uint64_t a3, TPropertyValue *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TDSNotifier *a9, char a10, uint64_t a11, uint64_t a12)
{
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a12);
  _Unwind_Resume(a1);
}

void TNodeEvent::CreateNodeEvent(int a1@<W0>, id *a2@<X1>, int a3@<W2>, TPropertyValue *a4@<X3>, uint64_t *a5@<X4>, TDSNotifier **a6@<X5>, _QWORD *a7@<X8>)
{
  FINodeEvent *v14;
  TNodeEvent v15;

  v14 = [FINodeEvent alloc];
  TNodeEvent::TNodeEvent((uint64_t)&v15, a1, a2, a3, a4, a5, a6);
  *a7 = -[FINodeEvent init:](v14, "init:", &v15);
  TNodeEvent::~TNodeEvent(&v15);
}

void sub_1CBC51024(_Unwind_Exception *a1, TNodeEvent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TNodeEvent::~TNodeEvent((TNodeEvent *)&a10);
  _Unwind_Resume(a1);
}

uint64_t TNodeEvent::TNodeEvent(uint64_t a1, int a2, id *a3, int a4, TPropertyValue *a5, uint64_t *a6, TDSNotifier **a7)
{
  TPropertyValue *v12;
  _QWORD *v13;
  TDSNotifier **v14;

  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v12 = (TPropertyValue *)(a1 + 24);
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v13 = (_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 64) = 0;
  v14 = (TDSNotifier **)(a1 + 64);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)a1 = a2;
  objc_storeStrong((id *)(a1 + 8), *a3);
  *(_DWORD *)(a1 + 16) = a4;
  TPropertyValue::operator=(v12, a5);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v13, a6);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=(v14, *a7);
  return a1;
}

void sub_1CBC510E8(_Unwind_Exception *a1)
{
  id *v1;
  TPropertyValue *v2;
  uint64_t v3;
  TDSNotifier **v4;

  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v4);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v3);
  TPropertyValue::~TPropertyValue(v2);

  _Unwind_Resume(a1);
}

uint64_t TNodeEvent::RedispatchEventToNotifier(uint64_t a1, unsigned int a2, unint64_t a3, TDSNotifier **a4)
{
  int v6;
  char *v7;
  char *v8;
  char *v9;
  TDSNotifier *v10;
  TNode *v11;
  OpaqueNodeRef *v12;
  const TNode *v13;
  TNode *v14;
  const TNode *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  void *v20;
  id *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  id *v26;
  id *v27;
  id v28;
  id v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  id v34;
  char *v35;
  char *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  id *v41;
  id *v42;
  uint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  TNodePtr v46;
  _BYTE v47[128];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v6 = atomic_load((unsigned int *)*a4 + 11);
  if (v6 > 0 || a2 > 0x32 || ((1 << a2) & 0x4000000100358) == 0)
  {
    TBlockingEventQueue::EventQueueFromID(a3, &v44);
    if (v44)
    {
      v41 = 0;
      v42 = 0;
      v43 = 0;
      v7 = -[FINodeEvent init:]([FINodeEvent alloc], "init:", a1);
      v8 = v7;
      if (v7)
        v9 = v7 + 8;
      else
        v9 = 0;
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=((TDSNotifier **)v9 + 8, *a4);
      v10 = *a4;
      v46.fFINode = (FINode *)v10;
      if (v10)
        TDSNotifier::AddPtrReference(v10);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v46);
      if ((*(_DWORD *)v9 & 0xFFFFFFFD) == 4)
      {
        v11 = (TNode *)objc_msgSend(*((id *)v9 + 1), "nodeRef");
        v13 = (const TNode *)TNode::NodeFromNodeRef(v11, v12);
        TNodePtr::TNodePtr(&v46, v13);
        v14 = (TNode *)TNodeFromFINode(v46.fFINode);
        TNode::CopyReplicas(v14, v15);
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v16 = (id)objc_claimAutoreleasedReturnValue();
        v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v37, v47, 16);
        if (v17)
        {
          v18 = *(_QWORD *)v38;
          do
          {
            for (i = 0; i != v17; ++i)
            {
              if (*(_QWORD *)v38 != v18)
                objc_enumerationMutation(v16);
              v20 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * i);
              v36 = -[FINodeEvent init:]([FINodeEvent alloc], "init:", v9);
              v21 = (id *)(v36 + 8);
              if (!v36)
                v21 = 0;
              objc_storeStrong(v21 + 1, v20);
              std::vector<TNodeEventPtr>::push_back[abi:ne180100]((uint64_t *)&v41, (id *)&v36);
              v22 = v36;
              v36 = 0;

            }
            v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v37, v47, 16);
          }
          while (v17);
        }

      }
      v23 = v44;
      v24 = v8;
      v35 = v24;
      TBlockingQueue<TNodeEventPtr>::Enqueue(v23, (id *)&v35);
      v25 = v35;
      v35 = 0;

      v26 = v41;
      v27 = v42;
      while (v26 != v27)
      {
        v28 = *v26;
        v34 = v28;
        TBlockingQueue<TNodeEventPtr>::Enqueue(v23, &v34);
        v29 = v34;
        v34 = 0;

        ++v26;
      }
      v46.fFINode = (FINode *)&v41;
      std::vector<TNodeEventPtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v46);
    }
    v30 = v45;
    if (v45)
    {
      p_shared_owners = (unint64_t *)&v45->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
  }
  return 0;
}

void sub_1CBC5140C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,void **a27)
{
  void *v27;
  void *v28;

  a27 = (void **)&a22;
  std::vector<TNodeEventPtr>::__destroy_vector::operator()[abi:ne180100](&a27);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
  _Unwind_Resume(a1);
}

void sub_1CBC5156C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

TDSNotifier **TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=(TDSNotifier **a1, TDSNotifier *this)
{
  if (this)
    TDSNotifier::AddPtrReference(this);
  if (*a1)
    TDSNotifier::RemovePtrReference(*a1);
  *a1 = this;
  return a1;
}

BOOL TDSNotifier::AddPtrReference(TDSNotifier *this)
{
  return TRefCount::Retain<int>((unsigned int *)this + 9);
}

void TBlockingQueue<TNodeEventPtr>::Enqueue(uint64_t a1, id *a2)
{
  std::mutex *v4;
  uint64_t v5;

  v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  v5 = *(_QWORD *)(a1 + 40);
  std::deque<TNodeEventPtr>::push_back((_QWORD *)a1, a2);
  if (!v5)
    TConditionVariable::Signal((TConditionVariable *)(a1 + 112));
  std::mutex::unlock(v4);
}

void sub_1CBC51618(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id std::deque<TNodeEventPtr>::push_back(_QWORD *a1, id *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  id result;

  v4 = a1[1];
  v5 = a1[2];
  v6 = ((v5 - v4) << 6) - 1;
  if (v5 == v4)
    v6 = 0;
  if (v6 == a1[5] + a1[4])
  {
    std::deque<TNodeEventPtr>::__add_back_capacity(a1);
    v4 = a1[1];
    v5 = a1[2];
  }
  if (v5 == v4)
  {
    v8 = 0;
  }
  else
  {
    v7 = a1[5] + a1[4];
    v8 = (_QWORD *)(*(_QWORD *)(v4 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF));
  }
  result = *a2;
  *v8 = result;
  ++a1[5];
  return result;
}

void NodeDispatchEvent(void *a1)
{
  FINodeEvent *v1;
  unsigned int v2;
  BOOL v3;
  int v4;
  TNodeEvent *v6;
  uint64_t Monitor;
  uint64_t v8;
  TDSNotifier *v9;
  TDSNotifier *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  TDSNotifier *v15[3];
  FINodeEvent *v16;

  v1 = a1;
  NodeEventFromNodeEventRef(v1, &v16);
  v2 = *(_DWORD *)TNodeEventPtr::operator->(&v16) - 100;
  v3 = v2 > 0xB;
  v4 = (1 << v2) & 0xC1F;
  if (v3 || v4 == 0)
  {
    v8 = *(_QWORD *)(TNodeEventPtr::operator->(&v16) + 64);
    v15[0] = (TDSNotifier *)v8;
    if (v8)
      TDSNotifier::AddPtrReference((TDSNotifier *)v8);
    v9 = *(TDSNotifier **)v8;
    v10 = *(TDSNotifier **)(v8 + 8);
    v15[1] = v9;
    v15[2] = v10;
    if (v10)
    {
      v11 = (unint64_t *)((char *)v10 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    TClientChangeNotifier::DispatchEvent((TClientChangeNotifier *)v9, v1);
    if (v10)
    {
      v13 = (unint64_t *)((char *)v10 + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        (*(void (**)(TDSNotifier *))(*(_QWORD *)v10 + 16))(v10);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v10);
      }
    }
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v15);
  }
  else
  {
    v6 = (TNodeEvent *)TNodeEventPtr::operator->(&v16);
    Monitor = TNodeEvent::GetMonitor(v6);
    (*(void (**)(void))(*(_QWORD *)(Monitor + 64) + 16))();
  }
  TNodeEventPtr::~TNodeEventPtr((id *)&v16);

}

void sub_1CBC517D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TDSNotifier *a9, char a10, uint64_t a11, id a12)
{
  void *v12;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a9);
  TNodeEventPtr::~TNodeEventPtr(&a12);

  _Unwind_Resume(a1);
}

BOOL TRefCount::Retain<int>(unsigned int *a1)
{
  void *v1;
  signed int v2;
  signed int v3;
  NSObject *v4;
  BOOL v5;
  __CFString *v6;
  int v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  __CFString *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load(a1);
  if (v2 < 0)
  {
    v3 = v2;
LABEL_10:
    LogObj(5);
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = IsRedactionEnabled();
      if (v5)
      {
        v6 = &stru_1E8752DF8;
      }
      else
      {
        objc_msgSend(MEMORY[0x1E0CB3978], "callStackSymbols");
        v1 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v1, "description");
        v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
      v8 = 136446722;
      v9 = "Retain";
      v10 = 2048;
      v11 = v3;
      v12 = 2114;
      v13 = v6;
      _os_log_impl(&dword_1CBC4A000, v4, OS_LOG_TYPE_ERROR, "%{public}s on bad object. -- refCount: %ld\n%{public}@", (uint8_t *)&v8, 0x20u);
      if (!v5)
      {

      }
    }

    v2 = v3;
  }
  else
  {
    while (v2)
    {
      v3 = __ldxr(a1);
      if (v3 == v2)
      {
        if (!__stlxr(v2 + 1, a1))
          return v2 > 0;
      }
      else
      {
        __clrex();
      }
      v2 = v3;
      if (v3 < 0)
        goto LABEL_10;
    }
  }
  return v2 > 0;
}

void sub_1CBC5198C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

FINodeEvent *NodeEventFromNodeEventRef@<X0>(FINodeEvent *a1@<X0>, FINodeEvent **a2@<X8>)
{
  FINodeEvent *result;

  result = a1;
  *a2 = result;
  return result;
}

void std::function<void ()(FINodeEvent *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3;
  id v4;

  v4 = a2;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *))(*(_QWORD *)v3 + 48))(v3, &v4);

}

void sub_1CBC51A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
}

void TClientChangeNotifier::DispatchEvent(TClientChangeNotifier *this, FINodeEvent *a2)
{
  std::function<void ()(FINodeEvent *)>::operator()((uint64_t)this + 88, a2);
}

id objc_cast<FIDSNode,FINode * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

void sub_1CBC51CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, void *a14, uint64_t a15, id a16)
{
  void *v16;
  id *v17;
  void *v18;
  void *v19;

  objc_sync_exit(v19);

  TNodeEventPtr::~TNodeEventPtr(&a13);
  TNodeEventPtr::~TNodeEventPtr(v17);

  TNodeEventPtr::~TNodeEventPtr(&a16);
  _Unwind_Resume(a1);
}

void sub_1CBC52160(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  va_list va;

  va_start(va, a2);
  v6 = v5;

  TNodeEventPtr::~TNodeEventPtr((id *)va);
  _Unwind_Resume(a1);
}

uint64_t TNodeEventPtr::operator->(_QWORD *a1)
{
  if (*a1)
    return *a1 + 8;
  else
    return 0;
}

void TDSNotifier::Tickle(TDSNotifier *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t *v9;
  BOOL v10;
  uint64_t v11;
  TDSNotifier *v12;

  v4 = TTime::MicrosecondsSinceStartup((TTime *)this);
  TickleLock();
  os_unfair_lock_lock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
  if (a2)
  {
    v5 = 200000;
LABEL_13:
    *((_QWORD *)this + 8) = v4;
    *((_QWORD *)this + 9) = v5;
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
    TClientChangeNotifier::WakeUp(*(TClientChangeNotifier **)this);
    return;
  }
  v7 = *((_QWORD *)this + 8);
  v6 = *((_QWORD *)this + 9);
  if (v4 - v7 >= v6)
  {
    if (v4 - v7 >= 2 * v6)
    {
      v12 = (TDSNotifier *)(v6 >> 1);
      v10 = v6 >> 7 >= 0xC35;
      v9 = (uint64_t *)&v12;
      if (!v10)
        v9 = (uint64_t *)&kMinimumTickleDelta;
    }
    else
    {
      v12 = (TDSNotifier *)(2 * v6);
      v8 = 2 * v6 > 0x3D0900;
      v9 = (uint64_t *)&v12;
      if (v8)
        v9 = (uint64_t *)&kMaximumTickleDelta;
    }
    v5 = *v9;
    goto LABEL_13;
  }
  if (*((_BYTE *)this + 60))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
  }
  else
  {
    v11 = v6 + v7;
    *((_BYTE *)this + 60) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
    v12 = this;
    TRefCount::Retain<int>((unsigned int *)this + 9);
    TClientChangeNotifier::SetTimerToHandleTickle(*(TClientChangeNotifier **)this, this, v11);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v12);
  }
}

void sub_1CBC52350(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

uint64_t TTime::MicrosecondsSinceStartup(TTime *this)
{
  mach_timebase_info info;

  mach_timebase_info(&info);
  return mach_absolute_time() * info.numer / info.denom / 0x3E8;
}

void TickleLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      TickleLock(void)::sTickleLock = 0;
    }
  }
}

id TNode::CopyReplicas(TNode *this, const TNode *a2)
{
  TReplicaRegistry *v2;
  OpaqueNodeRef *v3;

  v2 = (TReplicaRegistry *)TNode::AsNodeRef(this, a2);
  return TReplicaRegistry::CopyReplicas(v2, v3);
}

uint64_t TNode::AsNodeRef(TNode *this, const TNode *a2)
{
  void *v2;
  uint64_t v3;

  FIDSNodeFromTNode(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "nodeRef");

  return v3;
}

void sub_1CBC52440(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id TReplicaRegistry::CopyReplicas(TReplicaRegistry *this, OpaqueNodeRef *a2)
{
  TDSMutex *Mutex;
  void *v4;

  Mutex = (TDSMutex *)TReplicaRegistry::GetMutex(this);
  TDSMutex::lock(Mutex);
  if (TReplicaRegistry::gReplicaRegistry)
  {
    TReplicaRegistry::CopyReplicaFINodes((TReplicaRegistry *)TReplicaRegistry::gReplicaRegistry, (OpaqueNodeRef *)this);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v4 = 0;
  }
  TDSMutex::unlock(Mutex);
  return v4;
}

void sub_1CBC524A8(_Unwind_Exception *a1)
{
  TDSMutex *v1;

  TDSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TReplicaRegistry::GetMutex(TReplicaRegistry *this)
{
  unsigned __int8 v1;
  TDSMutex *v3;

  if ((v1 & 1) == 0
  {
    v3 = (TDSMutex *)operator new();
    TDSMutex::TDSMutex(v3, 0);
    TReplicaRegistry::GetMutex(void)::sReplicaRegistryMutex = (uint64_t)v3;
  }
  return TReplicaRegistry::GetMutex(void)::sReplicaRegistryMutex;
}

void sub_1CBC5253C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1000C40FA0F61DDLL);
  _Unwind_Resume(a1);
}

uint64_t TNode::RequestTask(uint64_t a1, int a2, int a3, TPropertyValue *a4, uint64_t *a5, int a6)
{
  int v12;
  os_unfair_lock_s *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  os_unfair_lock_s *v18;
  int v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  FINode *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  TNodePtr v29;
  uint64_t v30;
  std::__shared_weak_count *v31;

  v12 = a2;
  if (a2 == 1)
  {
    v13 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
    os_unfair_lock_lock(v13);
    v15 = *(_QWORD *)(a1 + 16);
    v14 = *(std::__shared_weak_count **)(a1 + 24);
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v13);
    v18 = (os_unfair_lock_s *)(v15 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v15 + 100));
    v19 = *(_DWORD *)(v15 + 115);
    os_unfair_lock_unlock(v18);
    if (v14)
    {
      v20 = (unint64_t *)&v14->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v12 = 1;
    if ((v19 & 0x20) != 0)
    {
      if (a3 > 1819240306)
      {
        if (a3 != 1885895027)
        {
          v22 = 1819240307;
LABEL_16:
          if (a3 != v22)
            goto LABEL_18;
        }
      }
      else if (a3 != 1667330145)
      {
        v22 = 1718776688;
        goto LABEL_16;
      }
      v12 = 102;
    }
  }
LABEL_18:
  v23 = *(FINode **)(*a5 + 24);
  v29.fFINode = v23;
  if (v23)
    TDSNotifier::AddPtrReference((TDSNotifier *)v23);
  std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void>(&v30);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v29);
  TNodeRequest::SetTask(*a5, &v30);
  v24 = v30;
  TNodePtr::TNodePtr(&v29, (const TNode *)a1);
  TNodeTask::SetRequest(v24, (id *)&v29.fFINode, v12, a3, a4, a6);

  if (a2 == 102)
    TNode::PostFolderSizingTaskRequest(a1, (uint64_t)&v30, 0);
  else
    TNode::PostNodeTaskRequest(a1, &v30);
  v25 = v31;
  if (v31)
  {
    v26 = (unint64_t *)&v31->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  return 4294959222;
}

void sub_1CBC52784(_Unwind_Exception *a1, void *a2, ...)
{
  va_list va;

  va_start(va, a2);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNodeTask::TNodeTask(uint64_t a1, TDSNotifier **a2)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 48) = 0x3E900000000;
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=((TDSNotifier **)(a1 + 8), *a2);
  return a1;
}

void sub_1CBC52810(_Unwind_Exception *a1)
{
  TPropertyValue *v1;
  TDSNotifier **v2;

  TPropertyValue::~TPropertyValue(v1 + 1);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v2);

  _Unwind_Resume(a1);
}

TPropertyValue *TNodeTask::SetRequest(uint64_t a1, id *a2, int a3, int a4, TPropertyValue *a5, int a6)
{
  TPropertyValue *result;

  TNodeTask::ResetRequest((TNodeTask *)a1);
  objc_storeStrong((id *)a1, *a2);
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a4;
  result = TPropertyValue::operator=((TPropertyValue *)(a1 + 24), a5);
  *(_DWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 52) = 1001;
  return result;
}

void TNodeTask::ResetRequest(TNodeTask *this)
{
  TDSNotifier *v2;
  TPropertyValue v3;

  TNodePtr::TNodePtr((TNodePtr *)&v3, 0);
  TNodePtr::operator=((void **)this, (void **)&v3);

  v2 = (TDSNotifier *)*((_QWORD *)this + 1);
  if (v2)
    TDSNotifier::RemovePtrReference(v2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  memset(&v3, 0, sizeof(v3));
  TPropertyValue::operator=((TPropertyValue *)this + 1, (uint64_t)&v3);
  TPropertyValue::~TPropertyValue(&v3);
  *((_QWORD *)this + 6) = 0;
}

TPropertyValue *TPropertyValue::operator=(TPropertyValue *a1, uint64_t a2)
{
  if (a1 != (TPropertyValue *)a2)
    TPropertyValue::MoveFrom(a1, a2);
  return a1;
}

TPropertyValue *TPropertyValue::MoveFrom(TPropertyValue *result, uint64_t a2)
{
  uint64_t v3;

  if (result != (TPropertyValue *)a2)
  {
    v3 = (uint64_t)result;
    TPropertyValue::Release(result);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>>(v3, a2);
    return (TPropertyValue *)std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>(a2);
  }
  return result;
}

_QWORD *TNodeRequest::SetTask(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 8), a2);
}

_QWORD *std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__emplace_unique_key_args<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>(uint64_t a1, _QWORD *a2, TDSNotifier **a3)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  float v11;
  float v12;
  _BOOL8 v13;
  unint64_t v14;
  unint64_t v15;
  size_t v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD v20[3];

  v5 = *a2 >> 4;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v3 = *a2 >> 4;
      if (v5 >= v6)
        v3 = v5 % v6;
    }
    else
    {
      v3 = (v6 - 1) & v5;
    }
    v8 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v8)
    {
      v9 = (_QWORD *)*v8;
      if (*v8)
      {
        do
        {
          v10 = v9[1];
          if (v10 == v5)
          {
            if (v9[2] == *a2)
              return v9;
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v10 >= v6)
                v10 %= v6;
            }
            else
            {
              v10 &= v6 - 1;
            }
            if (v10 != v3)
              break;
          }
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
    }
  }
  std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__construct_node_hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>(a1, *a2 >> 4, a3, (uint64_t)v20);
  v11 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v12 = *(float *)(a1 + 32);
  if (!v6 || (float)(v12 * (float)v6) < v11)
  {
    v13 = 1;
    if (v6 >= 3)
      v13 = (v6 & (v6 - 1)) != 0;
    v14 = v13 | (2 * v6);
    v15 = vcvtps_u32_f32(v11 / v12);
    if (v14 <= v15)
      v16 = v15;
    else
      v16 = v14;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v16);
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v5 >= v6)
        v3 = v5 % v6;
      else
        v3 = v5;
    }
    else
    {
      v3 = (v6 - 1) & v5;
    }
  }
  v17 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v17)
  {
    *(_QWORD *)v20[0] = *v17;
    *v17 = v20[0];
  }
  else
  {
    *(_QWORD *)v20[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v20[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v20[0])
    {
      v18 = *(_QWORD *)(*(_QWORD *)v20[0] + 8);
      if ((v6 & (v6 - 1)) != 0)
      {
        if (v18 >= v6)
          v18 %= v6;
      }
      else
      {
        v18 &= v6 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v18) = v20[0];
    }
  }
  v9 = (_QWORD *)v20[0];
  v20[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100]((uint64_t)v20, 0);
  return v9;
}

void sub_1CBC52BD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__deallocate_node(a1, *(TDSNotifier ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__deallocate_node(uint64_t a1, TDSNotifier **a2)
{
  TDSNotifier **v2;
  TDSNotifier *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *v2;
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v2 + 2);
      operator delete(v2);
      v2 = (TDSNotifier **)v3;
    }
    while (v3);
  }
}

void TClientChangeNotifier::WakeUp(TClientChangeNotifier *this)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __CFRunLoop *Main;
  const void *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  __CFRunLoop *v21;
  unint64_t *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD v26[4];
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  _QWORD block[4];
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;

  std::shared_ptr<TClientChangeNotifier>::shared_ptr[abi:ne180100]<TClientChangeNotifier,void>(&v34, this);
  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    v26[0] = MEMORY[0x1E0C809B0];
    v26[1] = 3321888768;
    v26[2] = ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2;
    v26[3] = &__block_descriptor_48_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__1_e5_v8__0l;
    v3 = v34;
    v4 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
      v27 = v3;
      v28 = v4;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      dispatch_async(v2, v26);
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    else
    {
      v27 = v34;
      v28 = 0;
      dispatch_async(v2, v26);
    }
    v16 = v28;
    if (v28)
    {
      v17 = (unint64_t *)&v28->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      goto LABEL_31;
    }
  }
  else
  {
    Main = CFRunLoopGetMain();
    v10 = (const void *)*MEMORY[0x1E0C9B270];
    block[1] = 3321888768;
    block[2] = ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke;
    block[3] = &__block_descriptor_48_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__0_e5_v8__0l;
    v11 = v34;
    v12 = v35;
    v29 = v34;
    v30 = v35;
    block[0] = MEMORY[0x1E0C809B0];
    if (v35)
    {
      v13 = (unint64_t *)&v35->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      v32 = v11;
      v33 = v12;
      do
        v15 = __ldxr(v13);
      while (__stxr(v15 + 1, v13));
    }
    else
    {
      v32 = v34;
      v33 = 0;
    }
    CFRunLoopPerformBlock(Main, v10, block);
    if (v12)
    {
      v19 = (unint64_t *)&v12->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v21 = CFRunLoopGetMain();
    CFRunLoopWakeUp(v21);
    v16 = v33;
    if (v33)
    {
      v22 = (unint64_t *)&v33->__shared_owners_;
      do
        v18 = __ldaxr(v22);
      while (__stlxr(v18 - 1, v22));
LABEL_31:
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  v23 = v35;
  if (v35)
  {
    v24 = (unint64_t *)&v35->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_1CBC52E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v8;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v7);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v8 - 32);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,TNodeEventPtr>,0>((id *)(i - 16));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1CBC52F64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TFSInfo::SetDisplayName(TFSInfo *this, const TString *a2)
{
  os_unfair_lock_s *v4;
  __CFString *v5;
  const char *v6;
  TString *v7;
  CFIndex v8;

  v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v5 = objc_retainAutorelease(a2->fString.fRef);
  v6 = (const char *)-[__CFString UTF8String](v5, "UTF8String");
  v7 = (TString *)((char *)this + 32);
  TString::SetStringRefAsImmutable(v7, 0);
  if (v6)
  {
    v8 = strlen(v6);
    TString::SetFromUTF8(v7, (const UInt8 *)v6, v8);
  }

  os_unfair_lock_unlock(v4);
}

void sub_1CBC52FF4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::FetchProperties(TFSInfo *this, int a2)
{
  int v3;
  int v4;
  __CFError *v5;
  TString *v6;
  const __CFString *v7;
  void *v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  CFIndex Length;
  void *v13;
  CFIndex v15;
  NSObject *v16;
  NSURL *v17;
  id v18;
  void *v19;
  int v20;
  const __CFString *v21;
  int v22;
  int v23;
  _BOOL4 v24;
  int v25;
  unint64_t v26;
  int v27;
  char *v28;
  const char *v29;
  char v30;
  unsigned __int8 *v31;
  int v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unint64_t v37;
  unsigned int v38;
  unint64_t v39;
  unsigned int v40;
  unint64_t v41;
  unint64_t v42;
  char st_dev;
  char v44;
  unsigned __int8 *v45;
  int v46;
  BOOL v47;
  char v48;
  unsigned int *v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unsigned int v53;
  _BOOL4 v55;
  unint64_t v56;
  __int16 v57;
  uint64_t v58;
  char v59;
  unint64_t v60;
  int v61;
  int v62;
  int v63;
  const __CFString *v64;
  unint64_t v65;
  uint64x2_t v66;
  int8x16_t v67;
  int8x16_t v68;
  uint64_t v69;
  TString *v70;
  const __CFString *PathComponent;
  const UInt8 *BytePtr;
  double CreationDate;
  int v74;
  unint64_t v75;
  TString *v76;
  __CFString *v77;
  void *v78;
  id v79;
  __CFString *v80;
  NSObject *v81;
  int v82;
  TCFURLInfo *v83;
  CFIndex v84;
  CFIndex v85;
  const void **v86;
  __CFString *v87;
  unint64_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  BOOL v93;
  int v94;
  unint64_t v95;
  int v96;
  unint64_t v97;
  double v98;
  int v99;
  CFIndex v100;
  const char *v101;
  const char *v102;
  const char *v103;
  const char *v104;
  int v105;
  int v106;
  unint64_t v107;
  unint64_t v108;
  const char *v109;
  ssize_t v110;
  unint64_t v111;
  __CFString *v112;
  double DoubleValue;
  const char *v114;
  CFTypeRef v115;
  CFTypeRef cf1;
  const void *v117;
  const void *v118;
  CFTypeRef cf;
  uint64_t v120;
  uint64_t v121;
  TString v122;
  CFTypeRef cf2;
  stat theString[7];
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  uint64_t v133;

  v133 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v3 = *(_DWORD *)((char *)this + 115);
    *(_DWORD *)((char *)this + 115) = v3 | 0x40000000;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v3 & 0x40000000) != 0)
      return 0;
  }
  if (*((_QWORD *)this + 1))
  {
    v4 = *((unsigned __int8 *)this + 112);
    v131 = 0u;
    v132 = 0u;
    v129 = 0u;
    v130 = 0u;
    v127 = 0u;
    v128 = 0u;
    v125 = 0u;
    v126 = 0u;
    v120 = 0;
    v121 = 0;
    cf = 0;
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if (_CFURLCopyResourcePropertyValuesAndFlags())
    {
      v117 = (const void *)*((_QWORD *)&v132 + 1);
      v118 = (const void *)v125;
    }
    else
    {
      v15 = TCFURLInfo::TranslateCFError((TCFURLInfo *)cf, v5);
      if ((_DWORD)v15 == -43)
      {
        v117 = (const void *)*((_QWORD *)&v132 + 1);
        v118 = (const void *)v125;
LABEL_177:
        TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v117);
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&v118);
        TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&cf);
        return v15;
      }
      LogObj(5);
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v17 = (NSURL *)*((id *)this + 1);
        SanitizedURL(v17);
        v18 = (id)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v15);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        theString[0].st_dev = 138543618;
        *(_QWORD *)&theString[0].st_mode = v18;
        WORD2(theString[0].st_ino) = 2114;
        *(__darwin_ino64_t *)((char *)&theString[0].st_ino + 6) = (__darwin_ino64_t)v19;
        _os_log_impl(&dword_1CBC4A000, v16, OS_LOG_TYPE_DEBUG, "_CFURLCopyResourcePropertyValuesAndFlags failed %{public}@, status = %{public}@", (uint8_t *)theString, 0x16u);

      }
      v117 = (const void *)*((_QWORD *)&v132 + 1);
      v118 = (const void *)v125;
      if ((_DWORD)v15)
        goto LABEL_177;
    }
    TFSInfo::GetObjectIdentifier(this);
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFF7EDF | (32
                                                                                    * ((v120 >> 1) & 1)) & 0xFFFFFEFF | (((v120 >> 3) & 1) << 8) | (v120 >> 1) & 0x8000;
    v6 = (TString *)v125;
    cf1 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf1, v6);
    if (UseFileProviderFramework())
    {
      TFSInfo::GetFPItem(this);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v9 = v8 == 0;

      if (!v9)
        TFSInfo::FetchBladeRunnerProperties(this, v10, v7);
    }
    if ((*(_DWORD *)((char *)this + 115) & 0x120) == 0
      && (TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AC48], v7) & 0x40000000) == 0|| (os_unfair_lock_lock((os_unfair_lock_t)this + 25), v11 = *(_DWORD *)((char *)this + 115), os_unfair_lock_unlock((os_unfair_lock_t)this + 25), (v11 & 0x40000000) != 0))
    {
      v15 = 0;
      goto LABEL_32;
    }
    FileSuffix((const TString *)&cf1, (TString *)theString);
    Length = CFStringGetLength(*(CFStringRef *)&theString[0].st_dev);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    if (Length)
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      *(_DWORD *)((char *)this + 115) |= 0x40000000u;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      goto LABEL_29;
    }
    TString::TString((TString *)theString, "Documents", 9uLL);
    if (CFEqual(cf1, *(CFTypeRef *)&theString[0].st_dev))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    }
    else
    {
      TString::TString((TString *)&cf2, "BDMV", 4uLL);
      v20 = CFEqual(cf1, cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
      if (!v20)
      {
        if ((*(_DWORD *)((char *)this + 115) & 0x8000) == 0
          && TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B6D8], v21))
        {
          TFSInfo::Path(this, &cf2);
          if (CFStringGetLength((CFStringRef)cf2))
          {
            TString::TString(&v122, ".localized", 0xAuLL);
            AppendPath((const TString *)&cf2, &v122, (TString *)theString);
            TString::operator=(&cf2, (const void **)theString);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v122.fString.fRef);
            v114 = (const char *)TString::c_str((TString *)&cf2);
            if (stat(v114, theString) != -1)
              TFSInfo::SetHasLSProperties(this, 1);
            v15 = 0;
          }
          else
          {
            v15 = 4294959238;
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
          goto LABEL_30;
        }
LABEL_29:
        v15 = 0;
LABEL_30:
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        v22 = *(_DWORD *)((char *)this + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        if ((v22 & 0x40000000) != 0)
        {
          v122.fString.fRef = 0;
          cf2 = 0;
          _CFURLCopyResourcePropertyValuesAndFlags();
          v120 |= (unint64_t)cf2;
        }
LABEL_32:
        *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFBBF | ((v120 & 1) << 10) | (((v120 >> 2) & 1) << 6);
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        v23 = *(_DWORD *)((char *)this + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        if ((v23 & 0x40000000) != 0)
        {
          v36 = v120;
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          v37 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | (v36 >> 3) & 2;
          *(_WORD *)((char *)this + 119) = WORD2(v37);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          v38 = v120;
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          v39 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | (v38 >> 7) & 0x10;
          *(_WORD *)((char *)this + 119) = WORD2(v39);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          *(_WORD *)((char *)this + 119) |= 0x800u;
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          v40 = v120;
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          v41 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | (v40 >> 7) & 4;
          *(_WORD *)((char *)this + 119) = WORD2(v41);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          v24 = 0;
          v27 = 0;
          goto LABEL_62;
        }
        v24 = 0;
        v25 = *(_DWORD *)((char *)this + 115);
        v26 = v25 & 0xFFFFFFF9 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
        *(_DWORD *)((char *)this + 115) = v25 & 0xFFFFFFE9 | 0x10;
        *(_WORD *)((char *)this + 119) = WORD2(v26);
        if ((v25 & 0x40) != 0)
        {
          v27 = 0;
          goto LABEL_62;
        }
        v27 = 0;
        if (!(_QWORD)v125)
          goto LABEL_62;
        if (!CFStringGetCString((CFStringRef)v125, (char *)theString, 1024, 0x8000100u))
        {
          v24 = 0;
          goto LABEL_60;
        }
        v28 = strrchr((char *)theString, 46);
        if (!v28 || v28 == (char *)theString)
        {
          v24 = 0;
          v42 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          goto LABEL_51;
        }
        v29 = v28;
        v24 = strchr((char *)theString, 46) != v28;
        v30 = *v29;
        if (*v29)
        {
          v31 = (unsigned __int8 *)(v29 + 1);
          do
          {
            *(v31 - 1) = __tolower(v30);
            v32 = *v31++;
            v30 = v32;
          }
          while (v32);
        }
        if (!strcmp(v29, ".app"))
        {
          v34 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
        }
        else
        {
          v33 = strcmp(v29, ".service");
          v34 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          if (v33)
          {
            v35 = 0;
LABEL_50:
            v42 = v34 & 0xFFFFFFFFFFFFFFFBLL | v35;
LABEL_51:
            *(_DWORD *)((char *)this + 115) = v42;
            *(_WORD *)((char *)this + 119) = WORD2(v42);
            st_dev = theString[0].st_dev;
            if (LOBYTE(theString[0].st_dev))
            {
              v44 = 0;
              v45 = (unsigned __int8 *)&theString[0].st_dev + 1;
              do
              {
                if (st_dev < 32)
                  v44 = 1;
                v46 = *v45++;
                st_dev = v46;
                if (v46)
                  v47 = (v44 & 1) == 0;
                else
                  v47 = 0;
              }
              while (v47);
              goto LABEL_61;
            }
LABEL_60:
            v44 = 0;
LABEL_61:
            v27 = v44 & 1;
LABEL_62:
            v48 = v120;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            v49 = (unsigned int *)((char *)this + 115);
            v50 = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | (2 * (v48 & 0x40));
            *(_WORD *)((char *)this + 119) = WORD2(v50);
            os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
            v51 = v120;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            v52 = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | ((v51 & 0x20) << 11);
            *(_WORD *)((char *)this + 119) = WORD2(v52);
            os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
            v53 = v120;
            v55 = (v120 & 0x80) == 0 || v4 == 7;
            *v49 = *v49 & 0xFFFFFFFE | v55;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            v56 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFF7 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            *v49 = *v49 & 0xFFFFFFF7 | (v53 >> 5) & 8;
            *(_WORD *)((char *)this + 119) = WORD2(v56);
            os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
            v57 = v120;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            v58 = *v49;
            v59 = *v49;
            if (v57 < 0)
            {
              v60 = v58 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            }
            else
            {
              os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
              os_unfair_lock_lock((os_unfair_lock_t)this + 25);
              v60 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
              if ((v59 & 0x40) == 0)
              {
                v61 = 0;
LABEL_73:
                *(_DWORD *)((char *)this + 115) = v60 & 0xFFFFF7FF | v61;
                *(_WORD *)((char *)this + 119) = WORD2(v60);
                os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                v62 = *(_DWORD *)((char *)this + 115);
                os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                if ((v62 & 0x800) != 0)
                {
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  v63 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v63 & 0x40) == 0)
                  {
                    if (TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B6D8], v64))TFSInfo::GetAliasInfoFrom(this, (BOOL *)theString, (BOOL *)&cf2, 0, 0);
                  }
                }
                v65 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                v66 = (uint64x2_t)vdupq_lane_s64(v120, 0);
                v67 = (int8x16_t)vdupq_n_s64(1uLL);
                v68 = vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64(v66, (uint64x2_t)xmmword_1CBD13200), v67), (uint64x2_t)xmmword_1CBD13220), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64(v66, (uint64x2_t)xmmword_1CBD131F0), v67), (uint64x2_t)xmmword_1CBD13210));
                v69 = *(_QWORD *)&vorr_s8(*(int8x8_t *)v68.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)) | v65 & 0xFFFFFFFF8DFFLL;
                *(_DWORD *)((char *)this + 115) = v69;
                *(_WORD *)((char *)this + 119) = WORD2(v69);
                if (v4 != 7 && (v121 & 1) != 0)
                {
                  v70 = (TString *)v125;
                  if ((_QWORD)v125)
                  {
                    if ((v65 & 0x100) == 0)
                    {
LABEL_85:
                      *(_QWORD *)&theString[0].st_dev = &stru_1E8752DF8;
                      CFRetain(&stru_1E8752DF8);
                      TString::SetStringRefAsImmutable((TString *)theString, v70);
                      TFSInfo::SetItemName(this, (const TString *)theString);
                      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                      goto LABEL_86;
                    }
                    PathComponent = CFURLCopyLastPathComponent(*((CFURLRef *)this + 1));
                    *(_QWORD *)&theString[0].st_dev = PathComponent;
                    if (!PathComponent
                      || CFStringGetLength(PathComponent) < 1
                      || (IsEqual(*(const void **)&theString[0].st_dev, CFSTR("/")) & 1) != 0)
                    {
                      TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)theString);
                      v70 = (TString *)v125;
                      goto LABEL_85;
                    }
                    TString::TString((TString *)&cf2, *(TString **)&theString[0].st_dev);
                    TFSInfo::SetItemName(this, (const TString *)&cf2);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                    TCFURLInfo::StringProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B700], (TString *)&cf2);
                    TFSInfo::SetDisplayName(this, (const TString *)&cf2);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                    TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)theString);
                  }
                }
LABEL_86:
                *((_QWORD *)this + 13) = 0;
                if ((*(_DWORD *)((char *)this + 115) & 0x20) != 0)
                {
                  if ((*(_DWORD *)((char *)this + 115) & 2) != 0)
                  {
                    if (*((_BYTE *)this + 112)
                      || (CreationDate = TFSInfo::GetCreationDate(this), CreationDate != -534528000.0)
                      && CreationDate != -3061152000.0)
                    {
                      theString[0].st_dev = 0;
                      LODWORD(cf2) = 0;
                      if (CFBundleGetPackageInfoInDirectory(*((CFURLRef *)this + 1), (UInt32 *)theString, (UInt32 *)&cf2))
                      {
                        v74 = (int)cf2;
                        *((_DWORD *)this + 26) = theString[0].st_dev;
                        *((_DWORD *)this + 27) = v74;
                      }
                    }
                  }
                }
                else
                {
                  *(_QWORD *)&theString[0].st_dev = 0;
                  if (CFURLCopyResourcePropertyForKey(*((CFURLRef *)this + 1), (CFStringRef)*MEMORY[0x1E0C9AC60], theString, 0))
                  {
                    if (*(_QWORD *)&theString[0].st_dev)
                    {
                      if (CFDataGetLength(*(CFDataRef *)&theString[0].st_dev) == 32)
                      {
                        BytePtr = CFDataGetBytePtr(*(CFDataRef *)&theString[0].st_dev);
                        *((_DWORD *)this + 27) = *((_DWORD *)BytePtr + 1);
                        *((_DWORD *)this + 26) = *(_DWORD *)BytePtr;
                        if ((TFSInfo::HasLSProperties(this) & 1) == 0 && *((_DWORD *)this + 26) == 1095782476)
                          *(_DWORD *)((char *)this + 115) |= 4u;
                      }
                    }
                  }
                  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)theString);
                }
                os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                v75 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 30) & 1;
                os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                if ((v75 | v24 | v27) != 1)
                {
                  *(_QWORD *)&theString[0].st_dev = &stru_1E8752DF8;
                  CFRetain(&stru_1E8752DF8);
                  TString::SetStringRefAsImmutable((TString *)theString, *((TString **)this + 3));
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  v82 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v82 & 8) != 0 && (TCFURLInfo::ShowAllExtensions(v83) & 1) == 0)
                  {
                    FileSuffix((const TString *)theString, (TString *)&cf2);
                    v84 = CFStringGetLength(*(CFStringRef *)&theString[0].st_dev);
                    v85 = CFStringGetLength((CFStringRef)cf2);
                    TString::SubString((TString *)theString, 0, v84 - v85, &v122);
                    TString::operator=((const void **)theString, (const void **)&v122.fString.fRef);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v122.fString.fRef);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                  }
                  ColonsToSlashes((const TString *)theString, (TString *)&cf2);
                  TFSInfo::SetDisplayName(this, (const TString *)&cf2);
                  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                  v86 = (const void **)theString;
                  goto LABEL_122;
                }
                cf2 = 0;
                if (!CFURLCopyResourcePropertyForKey(*((CFURLRef *)this + 1), (CFStringRef)*MEMORY[0x1E0C9B580], &cf2, 0))
                {
                  v115 = &stru_1E8752DF8;
                  CFRetain(&stru_1E8752DF8);
LABEL_115:
                  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&cf2);
                  if (CFStringGetLength((CFStringRef)v115))
                  {
                    v87 = (_QWORD)v125 ? (__CFString *)v125 : &stru_1E8752DF8;
                    if (!CFEqual(v115, v87))
                      TFSInfo::SetDisplayName(this, (const TString *)&v115);
                  }
                  v86 = &v115;
LABEL_122:
                  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v86);
                  if ((*(_DWORD *)((char *)this + 115) & 0x40) != 0
                    && !CFEqual(*((CFTypeRef *)this + 4), *((CFTypeRef *)this + 3)))
                  {
                    TFSInfo::SetDisplayName(this, (const TString *)this + 3);
                  }
                  if ((v121 & 2) != 0)
                  {
                    v88 = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | ((DWORD2(v125) > 1) << 24);
                    *(_WORD *)((char *)this + 119) = WORD2(v88);
                  }
                  if (TFSInfo::IsAlias(this) && v4 != 7)
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                    v89 = *(_DWORD *)((char *)this + 115);
                    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                    if ((v89 & 0x40) == 0)
                    {
                      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                      v90 = *(_DWORD *)((char *)this + 115);
                      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                      v91 = *((unsigned __int8 *)this + 112);
                      if ((v90 & 0x40) == 0)
                      {
                        if (v91 == 21)
                          v92 = 0;
                        else
                          v92 = *((_DWORD *)this + 26);
                        v93 = v92 == 1717661793 || v92 == 1718643553;
                        v94 = 2;
                        if (!v93)
                          v94 = 0;
                        v95 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                        *(_DWORD *)((char *)this + 115) = v94 | *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD;
                        *(_WORD *)((char *)this + 119) = WORD2(v95);
                      }
                      if (v91 == 21)
                        v96 = 0;
                      else
                        v96 = 4 * (*((_DWORD *)this + 26) == 1717661793);
                      v97 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                      *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | v96;
                      *(_WORD *)((char *)this + 119) = WORD2(v97);
                    }
                  }
                  v98 = TFSInfo::GetCreationDate(this);
                  if (v98 == -534528000.0 || v98 == -3061152000.0)
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                    v99 = *(_DWORD *)((char *)this + 115);
                    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                    if ((v99 & 0x20) != 0)
                    {
                      TCFURLInfo::SourcePathForResumableCopy((TString *)theString);
                      v100 = CFStringGetLength(*(CFStringRef *)&theString[0].st_dev);
                      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                      if (v100)
                      {
                        TFSInfo::Path(this, (CFTypeRef *)theString);
                        cf2 = 0;
                        if (CFStringGetLength(*(CFStringRef *)&theString[0].st_dev))
                        {
                          v101 = (const char *)TString::c_str((TString *)theString);
                          v102 = (const char *)SourceInodeXattrName(0);
                          if (getxattr(v101, v102, &cf2, 8uLL, 0, 1) != -1
                            || (v103 = (const char *)TString::c_str((TString *)theString),
                                v104 = (const char *)SourceInodeXattrName(1),
                                getxattr(v103, v104, &cf2, 8uLL, 0, 1) != -1))
                          {
                            TFSInfo::SetIsResumableCopyTarget(this, 1);
                          }
                        }
                        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                      }
                    }
                  }
                  if (cf)
                    CFRelease(cf);
                  cf = 0;
                  if ((*(_DWORD *)((char *)this + 115) & 0x100) != 0)
                  {
                    if (TCFURLInfo::VolumeIsAll(*((TCFURLInfo **)this + 1), (const __CFURL *)0x10000))
                      v15 = 4294967253;
                    else
                      v15 = v15;
                  }
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  v105 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v105 & 0x20) == 0)
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                    *(_DWORD *)((char *)this + 115) |= 0x10000000u;
                    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  }
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  v106 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v106 & 0x40) != 0)
                  {
                    v107 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | 0x200020000;
                    *(_DWORD *)((char *)this + 115) |= 0x20000u;
                    *(_WORD *)((char *)this + 119) = WORD2(v107);
                  }
                  TFSInfo::SetIfSavedSearch(this);
                  if (*((_BYTE *)this + 112) != 21 && *((_DWORD *)this + 26) == 1651666795)
                  {
                    v108 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFDFFFFFFFFFFLL | ((unint64_t)(*((_DWORD *)this + 27) == 1095779404) << 41);
                    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
                    *(_WORD *)((char *)this + 119) = WORD2(v108);
                  }
                  if (TFSInfo::GetCreationDate(this) == -534528000.0)
                  {
                    TFSInfo::Path(this, &cf2);
                    if (CFStringGetLength((CFStringRef)cf2))
                      v15 = v15;
                    else
                      v15 = 4294959238;
                    if (!(_DWORD)v15)
                    {
                      v109 = (const char *)TString::c_str((TString *)&cf2);
                      v110 = getxattr(v109, "com.apple.progress.fractionCompleted", theString, 0x64uLL, 0, 0);
                      v111 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFDFFFFFFFFFFLL;
                      *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
                      *(_WORD *)((char *)this + 119) = (v111 | ((unint64_t)(v110 != -1) << 41)) >> 32;
                      if (v110 >= 1)
                      {
                        v112 = (__CFString *)CFStringCreateWithBytes(0, (const UInt8 *)theString, v110, 0x8000100u, 0);
                        v122.fString.fRef = v112;
                        if (v112)
                        {
                          DoubleValue = CFStringGetDoubleValue(v112);
                          TFSInfo::SetOperationFractionCompleted(this, DoubleValue);
                        }
                        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v122.fString.fRef);
                      }
                    }
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                  }
                  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
                  goto LABEL_177;
                }
                v76 = (TString *)cf2;
                v115 = &stru_1E8752DF8;
                CFRetain(&stru_1E8752DF8);
                TString::SetStringRefAsImmutable((TString *)&v115, v76);
                TString::TString((TString *)theString, "Downloads", 9uLL);
                LODWORD(v76) = CFEqual(v115, *(CFTypeRef *)&theString[0].st_dev);
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                if (!(_DWORD)v76)
                  goto LABEL_115;
                TFSInfo::GetFPItem(this);
                v77 = (__CFString *)objc_claimAutoreleasedReturnValue();
                if (!v77)
                {
                  FPItemManagerInstance();
                  v78 = (void *)objc_claimAutoreleasedReturnValue();
                  v79 = *((id *)this + 2);
                  v122.fString.fRef = 0;
                  objc_msgSend(v78, "itemForURL:error:", v79, &v122);
                  v77 = (__CFString *)objc_claimAutoreleasedReturnValue();
                  v80 = v122.fString.fRef;

                  if (!v77)
                  {
                    LogObj(4);
                    v81 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                    {
                      theString[0].st_dev = 138412290;
                      *(_QWORD *)&theString[0].st_mode = v80;
                      _os_log_impl(&dword_1CBC4A000, v81, OS_LOG_TYPE_ERROR, "Failed to get FPItem for Downloads: %@", (uint8_t *)theString, 0xCu);
                    }
                    goto LABEL_109;
                  }

                }
                -[__CFString displayName](v77, "displayName");
                v81 = (id)objc_claimAutoreleasedReturnValue();
                if (v115 != v81)
                  TString::SetStringRefAsImmutable((TString *)&v115, (TString *)v81);

                v80 = v77;
LABEL_109:

                goto LABEL_115;
              }
            }
            v61 = 2048;
            goto LABEL_73;
          }
        }
        v35 = 4;
        goto LABEL_50;
      }
    }
    TFSInfo::SetHasLSProperties(this, 1);
    goto LABEL_29;
  }
  TFSInfo::GetFPItem(this);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  if (v13)
    return TFSInfo::FetchFPItemProperties(this);
  return 4294959236;
}

void sub_1CBC542E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  const void *v6;
  va_list va1;
  const void *v8;
  va_list va2;
  const void *v10;
  va_list va3;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  va_list va4;
  va_list va5;

  va_start(va5, a3);
  va_start(va4, a3);
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v8 = va_arg(va3, const void *);
  va_copy(va4, va3);
  v10 = va_arg(va4, const void *);
  v12 = va_arg(va4, _QWORD);
  v13 = va_arg(va4, _QWORD);
  va_copy(va5, va4);
  v14 = va_arg(va5, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va1);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va2);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va3);
  _Unwind_Resume(a1);
}

const void **TFSInfo::SetItemName(TFSInfo *this, const TString *a2)
{
  __CFString *v3;
  CFIndex Length;
  TString *v5;
  CFStringRef theString;

  v3 = objc_retainAutorelease(a2->fString.fRef);
  TString::TString((TString *)&theString, (const char *)-[__CFString UTF8String](v3, "UTF8String"));

  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  Length = CFStringGetLength(theString);
  v5 = (TString *)((char *)this + 24);
  if (Length)
  {
    if (v5 != (TString *)&theString)
      TString::SetStringRefAsImmutable(v5, (TString *)theString);
  }
  else if (v5->fString.fRef != CFSTR("?"))
  {
    TString::SetStringRefAsImmutable(v5, (TString *)CFSTR("?"));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1CBC54590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, const char *a2)
{
  CFIndex v4;

  this->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1E8752DF8);
  if (a2)
  {
    v4 = strlen(a2);
    TString::SetFromUTF8(this, (const UInt8 *)a2, v4);
  }
}

void sub_1CBC54620(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, const UInt8 *a2, CFIndex a3)
{
  this->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1E8752DF8);
  if (a2)
    TString::SetFromUTF8(this, a2, a3);
}

void sub_1CBC5469C(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TString::SetFromUTF8(TString *this, const UInt8 *a2, CFIndex a3)
{
  CFStringRef v4;
  const __CFString *v5;
  CFStringRef v7;

  if (!a3)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1E8752DF8);
  v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, 0x8000100u, 0);
  v7 = v4;
  if (v4)
    v5 = v4;
  else
    v5 = &stru_1E8752DF8;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, v5);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7);
}

void sub_1CBC54734(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSInfo::SetIfSavedSearch(TFSInfo *this)
{
  unsigned __int8 v2;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  unsigned int *v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  BOOL v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  TString *v13;
  TString v14;

  {
    v13 = (TString *)operator new();
    TString::TString(v13, ".savedSearch");
    TFSInfo::SetIfSavedSearch(void)::kSavedSearchExtension = (uint64_t)v13;
  }
  if (!*((_BYTE *)this + 112))
  {
    TFSInfo::Name(this, &v14);
    v9 = TString::EndsWith(&v14, (const TString *)TFSInfo::SetIfSavedSearch(void)::kSavedSearchExtension)
      || *((_BYTE *)this + 112) != 21 && *((_DWORD *)this + 26) == 1936945525;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);
    v3 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v11 = *(_DWORD *)((char *)this + 115);
    v5 = (unsigned int *)((char *)this + 115);
    v7 = v11 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
    if (v9)
      goto LABEL_5;
LABEL_13:
    v8 = 0;
    goto LABEL_14;
  }
  v3 = (os_unfair_lock_s *)((char *)this + 100);
  v4 = (os_unfair_lock_s *)((char *)this + 100);
  if (*((_BYTE *)this + 112) != 19)
  {
    os_unfair_lock_lock(v4);
    v8 = 0;
    v10 = *(_DWORD *)((char *)this + 115);
    v5 = (unsigned int *)((char *)this + 115);
    v7 = v10 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
    goto LABEL_14;
  }
  os_unfair_lock_lock(v4);
  v6 = *(_DWORD *)((char *)this + 115);
  v5 = (unsigned int *)((char *)this + 115);
  os_unfair_lock_unlock(v3);
  os_unfair_lock_lock(v3);
  v7 = *v5 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  if ((v6 & 0x100) != 0)
    goto LABEL_13;
LABEL_5:
  v8 = 0x4000000000;
LABEL_14:
  v12 = v8 | v7 & 0xFFBFFFFFFFFFLL;
  *v5 = v12;
  *((_WORD *)v5 + 2) = WORD2(v12);
  os_unfair_lock_unlock(v3);
}

void sub_1CBC548D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

BOOL TString::EndsWith(TString *this, const TString *a2)
{
  CFIndex Length;
  CFIndex v5;
  BOOL v6;
  CFIndex v7;
  CFIndex v9;
  const void *v10;
  CFTypeRef v11;
  const __CFString *v12;
  const void *v13;
  CFTypeRef v14;
  const __CFString *v15;
  CFRange v16;

  Length = CFStringGetLength(this->fString.fRef);
  v5 = CFStringGetLength(a2->fString.fRef);
  v6 = Length < v5;
  v7 = Length - v5;
  if (v6)
    return 0;
  v9 = v5;
  v10 = RetainCF<__CFString const*>((const void **)&this->fString.fRef);
  if (v10)
  {
    v11 = CFAutorelease(v10);
    v12 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v11);
  }
  else
  {
    v12 = 0;
  }
  v13 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
  if (v13)
  {
    v14 = CFAutorelease(v13);
    v15 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v14);
  }
  else
  {
    v15 = 0;
  }
  v16.location = v7;
  v16.length = v9;
  return CFStringCompareWithOptions(v12, v15, v16, 0) == kCFCompareEqualTo;
}

void TFSInfo::SynchronizePermissions(uint64_t a1, TFSInfo **a2, uint64_t **a3)
{
  os_unfair_lock_s *v6;
  unint64_t v7;
  char *v8;
  int Owner;
  int UserGroups;
  int Mode;
  int UserAccess;
  int v13;
  int v14;
  TFSInfo *v15;
  os_unfair_lock_s *v16;
  unsigned int *v17;
  unsigned int v18;
  TFSInfo *v19;
  os_unfair_lock_s *v20;
  unint64_t v21;
  TFSInfo *v22;
  os_unfair_lock_s *v23;
  unint64_t v24;
  unint64_t v25;
  TFSInfo *v26;
  os_unfair_lock_s *v27;
  unint64_t v28;
  unint64_t v29;
  TFSInfo *v30;
  os_unfair_lock_s *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unsigned int v35;
  char *v36;
  char *__s1;
  __CFFileSecurity *v38;
  __CFFileSecurity *v39;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v7 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  os_unfair_lock_unlock(v6);
  if ((v7 & 0x2000000000) != 0)
  {
    v39 = (__CFFileSecurity *)TFSInfo::CopyPermissions((TFSInfo *)a1);
    v38 = (__CFFileSecurity *)TFSInfo::CopyPermissions(*a2);
    __s1 = CopyACLToText(v39);
    v8 = CopyACLToText(v38);
    v36 = v8;
    if ((v8 == 0) != (__s1 == 0) || __s1 && strcmp(__s1, v8))
    {
      v35 = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v35, &v35);
      v35 = 1886549619;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v35, &v35);
    }
    TACLRef<char *>::~TACLRef((void **)&v36);
    TACLRef<char *>::~TACLRef((void **)&__s1);
    TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&v38);
    TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&v39);
  }
  Owner = TFSInfo::GetOwner((TFSInfo *)a1);
  if (Owner != TFSInfo::GetOwner(*a2))
  {
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1870098034;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  UserGroups = TFSInfo::GetUserGroups((TFSInfo *)a1);
  if (UserGroups != TFSInfo::GetUserGroups(*a2))
  {
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1970497394;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  Mode = TFSInfo::GetMode((TFSInfo *)a1);
  if (Mode != TFSInfo::GetMode(*a2))
  {
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1886549619;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  UserAccess = TFSInfo::GetUserAccess((TFSInfo *)a1);
  if (UserAccess != TFSInfo::GetUserAccess(*a2))
  {
    LODWORD(v39) = 1970495843;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  os_unfair_lock_lock(v6);
  v13 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v6);
  if (v13 < 0)
  {
    os_unfair_lock_lock(v6);
    v14 = *(_DWORD *)(a1 + 115);
    os_unfair_lock_unlock(v6);
    if ((v14 & 0x20) != 0)
    {
      v15 = *a2;
      v16 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v16);
      LODWORD(v15) = *(_DWORD *)((char *)v15 + 115);
      os_unfair_lock_unlock(v16);
      if ((v15 & 0x80000000) == 0)
        TFSInfo::SetExtendedUserAccess(*a2);
      os_unfair_lock_lock(v6);
      v18 = *(_DWORD *)(a1 + 115);
      v17 = (unsigned int *)(a1 + 115);
      v34 = v18;
      os_unfair_lock_unlock(v6);
      v19 = *a2;
      v20 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v20);
      v33 = *(unsigned int *)((char *)v19 + 115);
      os_unfair_lock_unlock(v20);
      os_unfair_lock_lock(v6);
      v21 = *v17;
      os_unfair_lock_unlock(v6);
      v22 = *a2;
      v23 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v23);
      v24 = *(unsigned int *)((char *)v22 + 115);
      os_unfair_lock_unlock(v23);
      os_unfair_lock_lock(v6);
      v25 = *v17;
      os_unfair_lock_unlock(v6);
      v26 = *a2;
      v27 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v27);
      v28 = *(unsigned int *)((char *)v26 + 115);
      os_unfair_lock_unlock(v27);
      os_unfair_lock_lock(v6);
      v29 = ((unint64_t)*v17 >> 23) & 1;
      os_unfair_lock_unlock(v6);
      v30 = *a2;
      v31 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v31);
      v32 = ((unint64_t)*(unsigned int *)((char *)v30 + 115) >> 23) & 1;
      os_unfair_lock_unlock(v31);
      if ((_DWORD)v29 != (_DWORD)v32
        || ((v25 >> 22) & 1) != ((v28 >> 22) & 1)
        || ((v21 >> 21) & 1) != ((v24 >> 21) & 1)
        || ((v34 >> 20) & 1) != ((v33 >> 20) & 1))
      {
        LODWORD(v39) = 1970495843;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
        LODWORD(v39) = 1768124270;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
      }
    }
  }
}

void sub_1CBC54DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v6;
  va_list va;
  void *v8;
  va_list va1;
  const void *v10;
  va_list va2;
  va_list va3;

  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, void *);
  va_copy(va2, va1);
  v8 = va_arg(va2, void *);
  va_copy(va3, va2);
  v10 = va_arg(va3, const void *);
  TACLRef<char *>::~TACLRef((void **)va);
  TACLRef<char *>::~TACLRef((void **)va1);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOwner(TFSInfo *this)
{
  void *v1;
  uint64_t v2;
  const void *v4;
  uid_t owner;

  owner = 0;
  v1 = (void *)TFSInfo::CopyPermissions(this);
  v4 = v1;
  if (v1)
  {
    CFFileSecurityGetOwner((CFFileSecurityRef)v1, &owner);
    v2 = owner;
  }
  else
  {
    v2 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v4);
  return v2;
}

void sub_1CBC54E54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetMode(TFSInfo *this)
{
  void *v1;
  uint64_t v2;
  const void *v4;
  mode_t mode;

  mode = 0;
  v1 = (void *)TFSInfo::CopyPermissions(this);
  v4 = v1;
  if (v1)
  {
    CFFileSecurityGetMode((CFFileSecurityRef)v1, &mode);
    v2 = mode;
  }
  else
  {
    v2 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v4);
  return v2;
}

void sub_1CBC54EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TFSInfo::GetUserGroups(TFSInfo *this)
{
  void *v1;
  uint64_t v2;
  const void *v4;
  gid_t group;

  group = 0;
  v1 = (void *)TFSInfo::CopyPermissions(this);
  v4 = v1;
  if (v1)
  {
    CFFileSecurityGetGroup((CFFileSecurityRef)v1, &group);
    v2 = group;
  }
  else
  {
    v2 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v4);
  return v2;
}

void sub_1CBC54F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUserAccess(TFSInfo *this)
{
  TFSInfo *v1;
  os_unfair_lock_s *v2;
  unsigned int v3;
  unsigned int v4;

  v1 = this;
  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)v1 + 115);
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock(v2);
  v4 = *(_DWORD *)((char *)v1 + 115);
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock(v2);
  LODWORD(v1) = *(_DWORD *)((char *)v1 + 115);
  os_unfair_lock_unlock(v2);
  return (v4 >> 12) & 2 | (v3 >> 14) & 1 | (v1 >> 10) & 4;
}

void TFSInfo::~TFSInfo(TFSInfo *this)
{
  const void **v2;

  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)this + 11);
  std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100]((TFSInfoOverflow **)this + 10, 0);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)this + 2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)this + 1);
  v2 = *(const void ***)this;
  *(_QWORD *)this = 0;
  if (v2)
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)this, v2);
}

uint64_t TFSInfo::CopyPermissions(TFSInfo *this)
{
  const void *v1;
  TFSInfo *v2;
  os_unfair_lock_s *v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  const void *v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = (const void *)*((_QWORD *)this + 1);
  v8 = v1;
  if (v1)
  {
    v2 = this;
    CFRetain(v1);
    v9 = 0;
    TCFURLInfo::CopyPropertyValues((uint64_t)v1);
    v3 = (os_unfair_lock_s *)((char *)v2 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)v2 + 25);
    v4 = *(_DWORD *)((char *)v2 + 115);
    v2 = (TFSInfo *)((char *)v2 + 115);
    v5 = v4 | ((unint64_t)*((unsigned __int16 *)v2 + 2) << 32) | 0x2000000000;
    *(_DWORD *)v2 = v4;
    *((_WORD *)v2 + 2) = WORD2(v5);
    os_unfair_lock_unlock(v3);
    v6 = v9;
  }
  else
  {
    v6 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v8);
  return v6;
}

void sub_1CBC55134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void **TACLRef<char *>::~TACLRef(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
  {
    acl_free(v2);
    *a1 = 0;
  }
  return a1;
}

char *CopyACLToText(__CFFileSecurity *a1)
{
  char *v1;
  ssize_t v3;
  acl_t accessControlList;

  if (!a1)
    return 0;
  accessControlList = 0;
  if (CFFileSecurityCopyAccessControlList(a1, &accessControlList))
  {
    v3 = 0;
    v1 = acl_to_text(accessControlList, &v3);
  }
  else
  {
    v1 = 0;
  }
  TACLRef<_acl *>::~TACLRef((void **)&accessControlList);
  return v1;
}

void sub_1CBC55248(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TACLRef<_acl *>::~TACLRef((void **)va);
  _Unwind_Resume(a1);
}

void **TACLRef<_acl *>::~TACLRef(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
  {
    acl_free(v2);
    *a1 = 0;
  }
  return a1;
}

void TFSInfo::SynchronizeCatalog(TFSInfo *this, TFSInfo **a2, uint64_t **a3)
{
  int v6;
  _BOOL4 v7;
  TFSInfo *v8;
  TFSInfo *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  double ModificationDate;
  int v15;
  TFSInfo *v16;
  os_unfair_lock_s *v17;
  double DateAddedDate;
  int IsLocked;
  const __CFString *v20;
  const __CFString *v21;
  int BooleanProperty;
  const __CFString *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int HasCustomIcon;
  _BOOL4 IsAlias;
  unint64_t v29;
  TFSInfo *v30;
  os_unfair_lock_s *v31;
  unint64_t v32;
  int v33;
  TFSInfo *v34;
  os_unfair_lock_s *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  char v40;
  unint64_t v41;
  TFSInfo *v42;
  os_unfair_lock_s *v43;
  unint64_t v44;
  uint64_t VolumeIdentifier;
  uint64_t ObjectIdentifier;
  int v47;
  TFSInfo *v48;
  os_unfair_lock_s *v49;
  int v50;
  TFSInfo *v51;
  os_unfair_lock_s *v52;
  TFSInfo *v53;
  double CreationDate;
  TFSInfo *v55;
  _BOOL4 v56;
  double v57;
  uint64_t v58;
  double v59;
  double v60;
  TFSInfo *v61;
  os_unfair_lock_s *v62;
  uint64_t v63;
  int v64;
  uint64_t DataLogicalSize;
  uint64_t ResourceLogicalSize;
  uint64_t DataPhysicalSize;
  uint64_t ResourcePhysicalSize;
  unsigned int v69;

  v6 = *((unsigned __int8 *)this + 112);
  if (!*((_BYTE *)this + 112))
  {
    if (*((_DWORD *)this + 26) == 1651666795)
      goto LABEL_3;
    if (TFSInfo::GetCreationDate(this) != -534528000.0)
    {
LABEL_19:
      v6 = *((unsigned __int8 *)this + 112);
      goto LABEL_20;
    }
    if (*((_BYTE *)this + 112))
    {
      v9 = *a2;
      if (*((_BYTE *)*a2 + 112) || *((_DWORD *)v9 + 26) != 1651666795 && TFSInfo::GetCreationDate(v9) != -534528000.0)
        goto LABEL_66;
      goto LABEL_19;
    }
    if (*((_DWORD *)this + 26) == 1651666795)
LABEL_3:
      v7 = 1;
    else
      v7 = TFSInfo::GetCreationDate(this) == -534528000.0;
    v8 = *a2;
    if (*((_BYTE *)*a2 + 112))
    {
      if (!v7)
        goto LABEL_66;
    }
    else if (*((_DWORD *)v8 + 26) == 1651666795)
    {
      if (v7)
        goto LABEL_66;
    }
    else if (v7 == (TFSInfo::GetCreationDate(v8) == -534528000.0))
    {
      goto LABEL_66;
    }
    goto LABEL_19;
  }
LABEL_20:
  if (v6 == 21)
    v10 = 0;
  else
    v10 = *((_DWORD *)this + 26);
  if (*((_BYTE *)*a2 + 112) == 21)
    v11 = 0;
  else
    v11 = *((_DWORD *)*a2 + 26);
  if (v10 != v11)
  {
    v69 = 1634956409;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v69 = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v6 = *((unsigned __int8 *)this + 112);
  }
  if (v6 == 21)
    v12 = 0;
  else
    v12 = *((_DWORD *)this + 27);
  if (*((_BYTE *)*a2 + 112) == 21)
    v13 = 0;
  else
    v13 = *((_DWORD *)*a2 + 27);
  if (v12 != v13)
  {
    v69 = 1717793396;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  ModificationDate = TFSInfo::GetModificationDate(this);
  if (ModificationDate != TFSInfo::GetModificationDate(*a2))
  {
    v69 = 1836016740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v15 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v15 & 2) != 0
      || (v16 = *a2,
          v17 = (os_unfair_lock_s *)((char *)*a2 + 100),
          os_unfair_lock_lock(v17),
          LODWORD(v16) = *(_DWORD *)((char *)v16 + 115),
          os_unfair_lock_unlock(v17),
          (v16 & 2) != 0))
    {
      v69 = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
      v69 = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
  }
  DateAddedDate = TFSInfo::GetDateAddedDate(this);
  if (DateAddedDate != TFSInfo::GetDateAddedDate(*a2))
  {
    v69 = 1883333732;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  IsLocked = TFSInfo::IsLocked(this);
  if (IsLocked != TFSInfo::IsLocked(*a2))
  {
    v69 = 1634954347;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  v21 = (const __CFString *)*MEMORY[0x1E0C9ACD0];
  BooleanProperty = TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9ACD0], v20);
  if (BooleanProperty != TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)*a2 + 1), v21, v23))
  {
    v69 = 1970170987;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  TFSInfo::GetFinderInfo(this);
  v25 = (v24 >> 11) & 1;
  TFSInfo::GetFinderInfo(*a2);
  if ((_DWORD)v25 != ((v26 >> 11) & 1))
  {
    v69 = 1886613604;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  HasCustomIcon = TFSInfo::HasCustomIcon(this);
  if (HasCustomIcon != TFSInfo::HasCustomIcon(*a2))
  {
    v69 = 1667851118;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  IsAlias = TFSInfo::IsAlias(this);
  if (IsAlias != TFSInfo::IsAlias(*a2))
  {
    v69 = 1769169260;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v29 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 9) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  v30 = *a2;
  v31 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v31);
  v32 = ((unint64_t)*(unsigned int *)((char *)v30 + 115) >> 9) & 1;
  os_unfair_lock_unlock(v31);
  if ((_DWORD)v29 != (_DWORD)v32)
  {
    v69 = 1668246896;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v33 = *(_DWORD *)((char *)this + 115) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  v34 = *a2;
  v35 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v35);
  LODWORD(v34) = *(_DWORD *)((char *)v34 + 115) & 1;
  os_unfair_lock_unlock(v35);
  if (v33 != (_DWORD)v34)
  {
    v69 = 1987273324;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  if (*((_BYTE *)this + 112) == 28)
  {
    TFSInfo::GetFPItem(this);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v36, "itemID");
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    TFSInfo::GetFPItem(*a2);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "itemID");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    v40 = objc_msgSend(v37, "isEqualToItemID:", v39);

    if ((v40 & 1) != 0)
      goto LABEL_66;
LABEL_65:
    v69 = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    goto LABEL_66;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v41 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 8) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  v42 = *a2;
  v43 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v43);
  v44 = ((unint64_t)*(unsigned int *)((char *)v42 + 115) >> 8) & 1;
  os_unfair_lock_unlock(v43);
  if ((_DWORD)v41 != (_DWORD)v44)
  {
    v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    v69 = 1987013741;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
  if (VolumeIdentifier != TFSInfo::GetVolumeIdentifier(*a2))
    goto LABEL_65;
  ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
  if (ObjectIdentifier != TFSInfo::GetObjectIdentifier(*a2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v47 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v47 & 0x8000) == 0)
      goto LABEL_65;
    v48 = *a2;
    v49 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v49);
    LODWORD(v48) = *(_DWORD *)((char *)v48 + 115);
    os_unfair_lock_unlock(v49);
    if (((unsigned __int16)v48 & 0x8000) == 0)
      goto LABEL_65;
  }
LABEL_66:
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v50 = (*(unsigned __int16 *)((char *)this + 119) >> 9) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  v51 = *a2;
  v52 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v52);
  LODWORD(v51) = (*(unsigned __int16 *)((char *)v51 + 119) >> 9) & 1;
  os_unfair_lock_unlock(v52);
  if (v50 != (_DWORD)v51)
  {
    v69 = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  if (*((_BYTE *)this + 112))
  {
    v53 = *a2;
    if (*((_BYTE *)*a2 + 112))
      goto LABEL_78;
    if (*((_DWORD *)v53 + 26) != 1651666795)
    {
      CreationDate = TFSInfo::GetCreationDate(v53);
      goto LABEL_76;
    }
LABEL_77:
    v69 = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    goto LABEL_78;
  }
  if (*((_DWORD *)this + 26) == 1651666795)
  {
    v55 = *a2;
    if (*((_BYTE *)*a2 + 112))
      goto LABEL_77;
    v56 = 1;
  }
  else
  {
    CreationDate = TFSInfo::GetCreationDate(this);
    v56 = CreationDate == -534528000.0;
    v55 = *a2;
    if (*((_BYTE *)*a2 + 112))
    {
LABEL_76:
      if (CreationDate != -534528000.0)
        goto LABEL_78;
      goto LABEL_77;
    }
  }
  if (*((_DWORD *)v55 + 26) == 1651666795)
  {
    if (!v56)
      goto LABEL_77;
  }
  else if (v56 != (TFSInfo::GetCreationDate(v55) == -534528000.0))
  {
    goto LABEL_77;
  }
LABEL_78:
  v57 = TFSInfo::GetCreationDate(this);
  if (v57 != TFSInfo::GetCreationDate(*a2))
  {
    if (!*((_BYTE *)this + 112)
      && (*((_DWORD *)this + 26) == 1651666795 || TFSInfo::GetCreationDate(this) == -534528000.0))
    {
      v69 = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    v69 = 1634952036;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v58 = *((_QWORD *)this + 10);
  v59 = 0.0;
  v60 = 0.0;
  if (v58)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v58 + 72));
    v60 = *(double *)(v58 + 48);
    os_unfair_lock_unlock((os_unfair_lock_t)(v58 + 72));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  v61 = *a2;
  v62 = (os_unfair_lock_s *)((char *)*a2 + 96);
  os_unfair_lock_lock(v62);
  v63 = *((_QWORD *)v61 + 10);
  if (v63)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v63 + 72));
    v59 = *(double *)(v63 + 48);
    os_unfair_lock_unlock((os_unfair_lock_t)(v63 + 72));
  }
  os_unfair_lock_unlock(v62);
  if (v60 != v59)
  {
    v69 = 1768845426;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v64 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v64 & 0x20) == 0)
  {
    DataLogicalSize = TFSInfo::GetDataLogicalSize(this);
    if (DataLogicalSize != TFSInfo::GetDataLogicalSize(*a2))
    {
      v69 = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    ResourceLogicalSize = TFSInfo::GetResourceLogicalSize(this);
    if (ResourceLogicalSize != TFSInfo::GetResourceLogicalSize(*a2))
    {
      v69 = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    DataPhysicalSize = TFSInfo::GetDataPhysicalSize(this);
    if (DataPhysicalSize != TFSInfo::GetDataPhysicalSize(*a2))
    {
      v69 = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    ResourcePhysicalSize = TFSInfo::GetResourcePhysicalSize(this);
    if (ResourcePhysicalSize != TFSInfo::GetResourcePhysicalSize(*a2))
    {
      v69 = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
  }
}

void sub_1CBC55C74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

double TFSInfo::GetCreationDate(TFSInfo *this)
{
  double v1;
  os_unfair_lock_s *v3;
  int v4;
  void *v5;
  void *v6;

  v1 = -6.31140768e10;
  if (*((_BYTE *)this + 112) != 34)
  {
    v3 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v4 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v3);
    if ((v4 & 0x2000000) == 0)
    {
      if (*((unsigned __int8 *)this + 112) - 27 > 1)
      {
        v1 = 0.0;
        TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
      }
      else
      {
        TFSInfo::GetFPItem(this);
        v5 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "creationDate");
        v6 = (void *)objc_claimAutoreleasedReturnValue();

        if (v6)
          v1 = MEMORY[0x1D17A4A1C](v6);
        else
          v1 = -6.31140768e10;

      }
    }
  }
  return v1;
}

void sub_1CBC55DB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double TFSInfo::GetModificationDate(TFSInfo *this)
{
  double v1;
  os_unfair_lock_s *v3;
  int v4;
  int v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v1 = -6.31140768e10;
  if (*((_BYTE *)this + 112) != 34)
  {
    v3 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v4 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v3);
    if ((v4 & 0x2000000) == 0)
    {
      v5 = *((unsigned __int8 *)this + 112);
      if ((v5 - 27) >= 2)
      {
        if (v5 == 25)
        {
          if (ICloudDriveFPFSEnabled())
          {
            TFSInfo::GetFPItem(this);
            v8 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "contentModificationDate");
            v9 = (void *)objc_claimAutoreleasedReturnValue();

            if (v9)
              v1 = MEMORY[0x1D17A4A1C](v9);
            else
              v1 = -6.31140768e10;

          }
        }
        else
        {
          v1 = -6.31140768e10;
          TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
        }
      }
      else
      {
        TFSInfo::GetFPItem(this);
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v6, "contentModificationDate");
        v7 = (void *)objc_claimAutoreleasedReturnValue();

        if (v7)
          v1 = MEMORY[0x1D17A4A1C](v7);

        if (!v7)
          return -6.31140768e10;
      }
    }
  }
  return v1;
}

void sub_1CBC55F4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  v2 = v1;

  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::CopyPropertyValues(uint64_t a1)
{
  __CFError *v1;
  CFIndex v2;
  TCFURLInfo *v4[2];

  if (!a1)
    return 4294959238;
  v4[0] = 0;
  v4[1] = 0;
  if (_CFURLCopyResourcePropertyValuesAndFlags())
    v2 = 0;
  else
    v2 = TCFURLInfo::TranslateCFError(v4[0], v1);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)v4);
  return v2;
}

void sub_1CBC55FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TFSInfo::GetObjectIdentifier(TFSInfo *this)
{
  int v1;
  uint64_t result;

  v1 = TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  result = 0;
  if (!v1)
    return 0;
  return result;
}

uint64_t TFSInfo::GetVolumeIdentifier(TFSInfo *this)
{
  int v1;
  uint64_t result;

  v1 = TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  result = 0;
  if (!v1)
    return 0;
  return result;
}

unint64_t TFSInfo::IsLocked(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  unint64_t v4;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x80) != 0)
    return 1;
  os_unfair_lock_lock(v2);
  v4 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 16) & 1;
  os_unfair_lock_unlock(v2);
  return v4;
}

double TFSInfo::GetDateAddedDate(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  const __CFString *v4;

  if (*((_BYTE *)this + 112) == 34)
    return -6.31140768e10;
  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0)
    return -6.31140768e10;
  else
    return TCFURLInfo::GetDateProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B3B8], v4);
}

unint64_t TFSInfo::HasCustomIcon(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  unint64_t v4;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0)
    return 0;
  TFSInfo::GetFinderInfo(this);
  return (v4 >> 10) & 1;
}

double TCFURLInfo::GetDateProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  double v3;
  CFTypeID v4;
  const void *propertyValueTypeRefPtr;

  v3 = -*MEMORY[0x1E0C9ADE8];
  if (this)
  {
    propertyValueTypeRefPtr = 0;
    if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0))
    {
      if (propertyValueTypeRefPtr)
      {
        v4 = CFGetTypeID(propertyValueTypeRefPtr);
        if (v4 == CFDateGetTypeID())
          v3 = MEMORY[0x1D17A4A1C](propertyValueTypeRefPtr);
      }
    }
    TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&propertyValueTypeRefPtr);
  }
  return v3;
}

void sub_1CBC562DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TFSInfo::GetDataLogicalSize(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0)
    return -1;
  TFSInfo::GetFPItem(this);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v4)
  {
    TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
    return -1;
  }
  v5 = v4;
  objc_msgSend(v4, "documentSize");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (v6)
    v3 = objc_msgSend(v6, "longLongValue");

  if (v7)
    v8 = v3;
  else
    v8 = -2;

  return v8;
}

void sub_1CBC5641C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t TFSInfo::GetResourcePhysicalSize(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) == 0)
  {
    if (*((unsigned __int8 *)this + 112) - 27 <= 1)
      return TFSInfo::GetResourceLogicalSize(this);
    TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  }
  return -1;
}

uint64_t TFSInfo::GetResourceLogicalSize(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) == 0)
  {
    if (*((unsigned __int8 *)this + 112) - 27 < 2)
      return 0;
    TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  }
  return -1;
}

uint64_t TFSInfo::GetDataPhysicalSize(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) == 0)
  {
    if (*((unsigned __int8 *)this + 112) - 27 <= 1)
      return TFSInfo::GetDataLogicalSize(this);
    TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  }
  return -1;
}

unint64_t TFSInfo::HasLSProperties(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 30) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

const void **TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

BOOL TCFURLInfo::VolumeIsAll(TCFURLInfo *this, const __CFURL *a2)
{
  return _CFURLGetVolumePropertyFlags() && a2 == 0;
}

void TString::TString(TString *this, TString *a2)
{
  this->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(this, a2);
}

void sub_1CBC567DC(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TString::operator=(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a1, a2);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  }
  return a1;
}

BOOL IsExternalDeviceDomainID(const TString *this)
{
  unsigned __int8 v2;
  unsigned __int8 v3;

  {
    TString::TString(&IsExternalDeviceDomainID(TString const&)::kUSBDomainID, "com.apple.filesystems.UserFS.FileProvider", 0x29uLL);
  }
  {
    TString::TString(&IsExternalDeviceDomainID(TString const&)::kSMBDomainID, "com.apple.SMBClientProvider.FileProvider", 0x28uLL);
  }
  return TString::BeginsWith((TString *)this, &IsExternalDeviceDomainID(TString const&)::kUSBDomainID)
      || TString::BeginsWith((TString *)this, &IsExternalDeviceDomainID(TString const&)::kSMBDomainID);
}

void sub_1CBC56938(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PathEligibleForSynching(const TString *a1)
{
  unsigned __int8 v2;
  const TString *v3;
  const TString *v4;
  __CFString *v6;
  TString v7;

  if ((v2 & 1) == 0)
  {
    {
      AllowedPaths(&PathEligibleForSynching(TString const&)::allowedPaths);
    }
  }
  v6 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&v6, (TString *)a1->fString.fRef);
  v3 = (const TString *)PathEligibleForSynching(TString const&)::allowedPaths;
  v4 = *(const TString **)algn_1EDB96B10;
  v7.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v7, (TString *)v6);
  while (1)
  {
    if (v3 == v4)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6);
      return MatchesEDSContainerPattern(a1);
    }
    if (TString::BeginsWith(&v7, v3))
      break;
    ++v3;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6);
  return 1;
}

void sub_1CBC56A5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLogicalSize(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  void *v4;
  void *v5;
  char v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  const __CFString *v11;
  int v12;
  const __CFURL *NumericalProperty;
  void *v14;
  void *v15;
  int v16;
  const __CFString *v17;
  os_unfair_lock_s *v19;
  os_unfair_lock_s *v20;
  uint64_t v21[4];
  char v22;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) == 0)
  {
    TFSInfo::GetFPItem(this);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = v4;
    if (v4)
    {
      if (objc_msgSend(v4, "isCloudItem"))
      {
        v6 = (*(_DWORD *)((char *)this + 115) & 0x20) != 0
           ? objc_msgSend(v5, "isRecursivelyDownloaded")
           : objc_msgSend(v5, "isDownloaded");
        if ((v6 & 1) == 0)
        {
          os_unfair_lock_lock(v2);
          v8 = *(_DWORD *)((char *)this + 115);
          os_unfair_lock_unlock(v2);
          if ((v8 & 2) != 0
            || (os_unfair_lock_lock(v2),
                v9 = *(_DWORD *)((char *)this + 115),
                os_unfair_lock_unlock(v2),
                (v9 & 0x20) == 0))
          {
            os_unfair_lock_lock(v2);
            *(_DWORD *)((char *)this + 115) |= 0x10000000u;
            os_unfair_lock_unlock(v2);
            goto LABEL_21;
          }
        }
      }
      if (objc_msgSend(v5, "isCloudItem")
        && objc_msgSend(v5, "isDownloaded")
        && (*(_DWORD *)((char *)this + 115) & 0x20) != 0
        && TFSInfo::IsPackage(this))
      {
        TFSInfo::SetSizesFetchedValid(this, 1);
        goto LABEL_21;
      }
      os_unfair_lock_lock(v2);
      v10 = *(_DWORD *)((char *)this + 115);
      os_unfair_lock_unlock(v2);
      if ((v10 & 0x20) != 0
        && (TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AC48], v11) & 0x40000000) != 0)
      {
        v7 = -2;
        goto LABEL_26;
      }
    }
    v12 = *((unsigned __int8 *)this + 112);
    if (v12 == 28)
    {
      TFSInfo::GetFPItem(this);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "documentSize");
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = objc_msgSend(v15, "integerValue");

LABEL_26:
      return v7;
    }
    if (v12 != 27)
    {
      os_unfair_lock_lock(v2);
      v16 = *(_DWORD *)((char *)this + 115);
      os_unfair_lock_unlock(v2);
      if ((v16 & 0x20) != 0)
      {
        v19 = (os_unfair_lock_s *)((char *)this + 96);
        os_unfair_lock_lock((os_unfair_lock_t)this + 24);
        v20 = (os_unfair_lock_s *)*((_QWORD *)this + 10);
        if (v20 && (TFSInfoOverflow::FolderSizeRecord(v20, (uint64_t)v21), v22))
          v7 = v21[0];
        else
          v7 = -1;
        os_unfair_lock_unlock(v19);
        goto LABEL_26;
      }
      NumericalProperty = TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B5D8], v17);
      goto LABEL_25;
    }
LABEL_21:
    NumericalProperty = (const __CFURL *)TFSInfo::GetDataLogicalSize(this);
LABEL_25:
    v7 = (uint64_t)NumericalProperty;
    goto LABEL_26;
  }
  return -1;
}

void sub_1CBC56D08(_Unwind_Exception *a1)
{
  void *v1;
  os_unfair_lock_s *v2;

  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

BOOL IsICloudDriveDomainID(TString *a1)
{
  unsigned __int8 v2;

  if (!ICloudDriveFPFSEnabled())
    return 0;
  if ((v2 & 1) == 0)
  {
    {
      TString::TString(&IsICloudDriveDomainID(TString const&)::kICloudDriveProviderIDCommonPrefix, "com.apple.CloudDocs.iCloudDriveFileProvider", 0x2BuLL);
    }
  }
  return TString::BeginsWith(a1, &IsICloudDriveDomainID(TString const&)::kICloudDriveProviderIDCommonPrefix);
}

void sub_1CBC56DCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL TString::BeginsWith(TString *this, const TString *a2)
{
  CFIndex Length;

  Length = CFStringGetLength(a2->fString.fRef);
  if (CFStringGetLength(this->fString.fRef) < Length)
    return 0;
  if (Length)
    return CFStringHasPrefix(this->fString.fRef, a2->fString.fRef) != 0;
  return 1;
}

uint64_t TFSInfo::SynchronizeProperties(TFSInfo *this, TFSInfo **a2, uint64_t a3)
{
  void *v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  unsigned __int8 v13;
  TFSInfoOverflow *v14;
  void *v15;
  id v16;
  TFSInfoOverflow *v17;
  void *v18;
  TFSInfo *v19;
  os_unfair_lock_s *v20;
  TFSInfoOverflow *v21;
  void *v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  unsigned __int8 v26;
  unsigned __int8 v27;
  id v28;
  void *v29;
  void *v30;
  char v31;
  void *v32;
  void *v33;
  char v34;
  uint64_t v35;
  NSObject *v36;
  NSObject *v37;
  unsigned int v39;

  if (*((_BYTE *)this + 112) == 7)
    goto LABEL_35;
  TFSInfo::SynchronizeNames((uint64_t)this, a2, (uint64_t **)a3);
  TFSInfo::SynchronizeCatalog(this, a2, (uint64_t **)a3);
  TFSInfo::SynchronizeFPItemProperties(this, a2, (uint64_t **)a3);
  TFSInfo::SynchronizeFPProviderProperties((uint64_t)this, (uint64_t *)a2, (uint64_t **)a3);
  TFSInfo::OriginatorInfo(this);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  if (v6)
  {
    v39 = 1869769063;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v39, &v39);
  }
  TFSInfo::GetISIcon(this);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v7)
    goto LABEL_33;
  v8 = TFSInfo::FetchISIcon(*a2);
  TFSInfo::GetISIcon(this);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  TFSInfo::GetISIcon(*a2);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = v9;
  v12 = v10;
  if ((objc_msgSend(v11, "isEqual:", v12) & 1) != 0)
  {

    goto LABEL_11;
  }
  {
    ISIconsAreEqual(ISIcon *,ISIcon *)::disableWorkaround = PrefsBool(CFSTR("DISABLE_75276146_WORKAROUND"), 0);
  }
  if (ISIconsAreEqual(ISIcon *,ISIcon *)::disableWorkaround)
    goto LABEL_9;
  {
    NSClassFromString(CFSTR("ISCustomIcon"));
    ISIconsAreEqual(ISIcon *,ISIcon *)::customIconClass = objc_claimAutoreleasedReturnValue();
  }
  if ((v27 & 1) == 0
  {
    ISIconsAreEqual(ISIcon *,ISIcon *)::hasBookmarkSelector = objc_msgSend((id)ISIconsAreEqual(ISIcon *,ISIcon *)::customIconClass, "instancesRespondToSelector:", sel_bookmark);
  }
  if (!ISIconsAreEqual(ISIcon *,ISIcon *)::hasBookmarkSelector
    || (objc_opt_isKindOfClass() & 1) == 0
    || (objc_opt_isKindOfClass() & 1) == 0)
  {
LABEL_9:

LABEL_10:
    v39 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v39, &v39);
    goto LABEL_11;
  }
  v28 = v12;
  objc_msgSend(v11, "bookmark");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v28, "bookmark");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = objc_msgSend(v29, "isEqual:", v30);

  if ((v31 & 1) == 0)
    goto LABEL_10;
LABEL_11:
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v14 = (TFSInfoOverflow *)*((_QWORD *)this + 10);
  if (v14)
  {
    TFSInfoOverflow::GetIFSymbol(v14);
    v15 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v15 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  if (v15)
  {
    v16 = TFSInfo::FetchIFSymbol(*a2);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v17 = (TFSInfoOverflow *)*((_QWORD *)this + 10);
    if (v17)
    {
      TFSInfoOverflow::GetIFSymbol(v17);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v18 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
    v19 = *a2;
    v20 = (os_unfair_lock_s *)((char *)*a2 + 96);
    os_unfair_lock_lock(v20);
    v21 = (TFSInfoOverflow *)*((_QWORD *)v19 + 10);
    if (v21)
    {
      TFSInfoOverflow::GetIFSymbol(v21);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v22 = 0;
    }
    os_unfair_lock_unlock(v20);
    v23 = v18;
    v24 = v22;
    if (v23 | v24)
    {
      v25 = (void *)v24;
      if ((v23 == 0) != (v24 == 0))
      {

      }
      else
      {
        objc_msgSend((id)v23, "name");
        v32 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v25, "name");
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        v34 = objc_msgSend(v32, "isEqualToString:", v33);

        if ((v34 & 1) != 0)
          goto LABEL_33;
      }
      v39 = 1768323437;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v39, &v39);
      v39 = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v39, &v39);
    }
  }
LABEL_33:
  if (!*((_BYTE *)this + 112))
  {
    TFSInfo::SynchronizeLaunchServices((uint64_t)this, (os_unfair_lock_s **)a2, (uint64_t **)a3);
    TFSInfo::SynchronizePermissions((uint64_t)this, a2, (uint64_t **)a3);
    TFSInfo::SynchronizeKinds(this, a2, (uint64_t **)a3);
    TFSInfo::SynchronizeVersions((uint64_t)this, (uint64_t *)a2, (uint64_t **)a3);
    TFSInfo::SynchronizeTags(this, a2, (uint64_t **)a3);
  }
LABEL_35:
  if (*(_QWORD *)(a3 + 16))
    return 1;
  TFSInfo::GetFPItem(this);
  v36 = objc_claimAutoreleasedReturnValue();
  TFSInfo::GetFPItem(*a2);
  v37 = objc_claimAutoreleasedReturnValue();
  v35 = IsEqual(v36, v37) ^ 1;

  return v35;
}

void sub_1CBC57348(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id TFSInfo::OriginatorInfo(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  id v7;

  v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v3 = *((_QWORD *)this + 10);
  if (!v3)
    goto LABEL_6;
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 72));
  v4 = *(unsigned __int8 *)(v3 + 76);
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 72));
  if (v4 != 2)
  {
    v5 = *((_QWORD *)this + 10);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72));
    v6 = *(unsigned __int8 *)(v5 + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72));
    if (v6 == 1)
    {
      v3 = v5 + 16;
      goto LABEL_5;
    }
LABEL_6:
    v7 = 0;
    goto LABEL_7;
  }
LABEL_5:
  v7 = *(id *)v3;
LABEL_7:
  os_unfair_lock_unlock(v2);
  return v7;
}

id TFSInfo::GetISIcon(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  id v3;

  v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v3 = *((id *)this + 7);
  os_unfair_lock_unlock(v2);
  return v3;
}

void TFSInfo::SynchronizeFPProviderProperties(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  id v14;
  void *v15;
  void *v16;
  unint64_t v17;
  id v18;

  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v7 = *(_QWORD *)(a1 + 80);
  if (v7
    && (os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72)),
        v8 = *(unsigned __int8 *)(v7 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72)),
        v8 == 1))
  {
    v17 = (unint64_t)*(id *)(v7 + 24);
  }
  else
  {
    v17 = 0;
  }
  os_unfair_lock_unlock(v6);
  v9 = *a2;
  v10 = (os_unfair_lock_s *)(v9 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 96));
  v11 = *(_QWORD *)(v9 + 80);
  if (v11
    && (os_unfair_lock_lock((os_unfair_lock_t)(v11 + 72)),
        v12 = *(unsigned __int8 *)(v11 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 72)),
        v12 == 1))
  {
    v13 = (unint64_t)*(id *)(v11 + 24);
  }
  else
  {
    v13 = 0;
  }
  os_unfair_lock_unlock(v10);
  v14 = (id)v17;
  if (v17 | v13)
  {
    objc_msgSend((id)v17, "domain");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend((id)v13, "domain");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    TFSInfo::ChangesForFPDomain(v15, v16, a3);

    v14 = (id)v17;
  }
  v18 = v14;

}

void sub_1CBC57634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void TFSInfo::SynchronizeFPItemProperties(TFSInfo *a1, TFSInfo **a2, uint64_t **a3)
{
  TFSInfo *v6;
  uint64_t v7;
  FPItem *v8;
  TFSInfo *v9;
  os_unfair_lock_s *v10;
  const void *v11;
  void *v12;
  NSURL *v13;
  void *v14;
  id v15;
  NSObject *v16;
  void *v17;
  TString *v18;
  uint64_t v19;
  const __CFString *v20;
  void *v21;
  void *v22;
  BOOL v23;
  TFSInfo *v24;
  os_unfair_lock_s *v25;
  NSObject *v26;
  NSObject *v27;
  char v28;
  TFSInfo *v29;
  os_unfair_lock_s *v30;
  int v31;
  TFSInfo *v32;
  os_unfair_lock_s *v33;
  NSObject *v34;
  NSObject *v35;
  char v36;
  NSObject *v37;
  NSObject *v38;
  char v39;
  FPItem *v40;
  TString *v41;
  id v42;
  void *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  BOOL v48;
  TFSInfo *v49;
  os_unfair_lock_s *v50;
  int IsAppLibrary;
  id v52;
  void *v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  FPItem *v58;
  int v59;
  NSObject *v60;
  NSObject *v61;
  char v62;
  NSObject *v63;
  NSObject *v64;
  char v65;
  int v66;
  int v67;
  int IsTopLevelSharedItem;
  TFSInfo *v69;
  NSPersonNameComponents *v70;
  NSPersonNameComponents *v71;
  char v72;
  int v73;
  void *v74;
  void *v75;
  BOOL v76;
  TString v77;
  id v78;
  id v79[16];
  uint64_t v80;
  _BYTE buf[12];
  __int16 v82;
  _BYTE v83[10];
  _QWORD *v84;
  _BYTE v85[32];
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  TFSInfo::GetFPItem(a1);
  v6 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  TFSInfo::GetFPItem(*a2);
  v7 = objc_claimAutoreleasedReturnValue();
  v8 = (FPItem *)v7;
  if (v6 && !v7)
  {
    v9 = *a2;
    v10 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v10);
    v11 = (const void *)*((_QWORD *)v9 + 2);
    *(_QWORD *)buf = v11;
    if (v11)
    {
      CFRetain(v11);
      v12 = *(void **)buf;
    }
    else
    {
      v12 = 0;
    }
    os_unfair_lock_unlock(v10);
    v13 = v12;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
    FPItemManagerInstance();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v78 = 0;
    objc_msgSend(v14, "itemForURL:error:", v13, &v78);
    v8 = (FPItem *)objc_claimAutoreleasedReturnValue();
    v15 = v78;

    if (v15)
    {
      LogObj(4);
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        SanitizedURL(v13);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543618;
        *(_QWORD *)&buf[4] = v15;
        v82 = 2114;
        *(_QWORD *)v83 = v17;
        _os_log_impl(&dword_1CBC4A000, v16, OS_LOG_TYPE_ERROR, "itemForURL error: %{public}@ for %{public}@", buf, 0x16u);

      }
    }
    TFSInfo::SetFPItem(*a2, v8);

  }
  -[FPItem providerDomainID](v8, "providerDomainID");
  v18 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  *(_QWORD *)buf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)buf, v18);

  v76 = IsLocalStorageDomainID((const TString *)buf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);

  if (!v8)
  {
    if (!v6)
      goto LABEL_77;
LABEL_16:
    *(_DWORD *)buf = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    v24 = *a2;
    v25 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v25);
    LODWORD(v24) = *(_DWORD *)((char *)v24 + 115);
    os_unfair_lock_unlock(v25);
    if ((v24 & 0x20) != 0)
    {
      *(_DWORD *)buf = 1667785588;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    goto LABEL_18;
  }
  TFSInfo::FetchBladeRunnerProperties(*a2, v19, v20);
  if (!v6)
  {
    -[FPItem itemDecorations](v8, "itemDecorations");
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    v48 = objc_msgSend(v47, "count") == 0;

    if (!v48)
    {
      *(_DWORD *)buf = 1684366194;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      *(_DWORD *)buf = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    *(_DWORD *)buf = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    v49 = *a2;
    v50 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v50);
    LODWORD(v49) = *(_DWORD *)((char *)v49 + 115);
    os_unfair_lock_unlock(v50);
    if ((v49 & 0x20) != 0)
    {
      *(_DWORD *)buf = 1667785588;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    if (!v76)
    {
      TFSInfo::CheckiCloudFlags((uint64_t)a1, a2, a3);
      if (TFSInfo::IsTopLevelSharedItem(*a2))
      {
        *(_DWORD *)buf = 1936225392;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      }
      IsAppLibrary = TFSInfo::IsAppLibrary(a1);
      if (IsAppLibrary != TFSInfo::IsAppLibrary(*a2))
      {
        *(_DWORD *)buf = 1768124270;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      }
      *(_DWORD *)buf = 1819501924;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      *(_DWORD *)buf = 1769171056;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      *(_DWORD *)buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    goto LABEL_77;
  }
  -[TFSInfo itemIdentifier](v6, "itemIdentifier");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  -[FPItem itemIdentifier](v8, "itemIdentifier");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = objc_msgSend(v21, "compare:", v22) == 0;

  if (!v23)
    goto LABEL_16;
LABEL_18:
  if (!TFSInfo::IsFPv2(a1, 1))
  {
    -[TFSInfo fileURL](v6, "fileURL");
    v26 = objc_claimAutoreleasedReturnValue();
    -[FPItem fileURL](v8, "fileURL");
    v27 = objc_claimAutoreleasedReturnValue();
    v28 = IsEqual(v26, v27);

    if ((v28 & 1) == 0)
    {
      *(_DWORD *)buf = 1868720740;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      v29 = *a2;
      v30 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v30);
      LODWORD(v29) = *(_DWORD *)((char *)v29 + 115);
      os_unfair_lock_unlock(v30);
      if ((v29 & 0x20) != 0)
      {
        *(_DWORD *)buf = 1667785588;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      }
    }
  }
  v31 = -[TFSInfo isPending](v6, "isPending");
  if (v31 != -[FPItem isPending](v8, "isPending"))
  {
    *(_DWORD *)buf = 1886549619;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
  }
  v32 = *a2;
  v33 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v33);
  LODWORD(v32) = *(_DWORD *)((char *)v32 + 115);
  os_unfair_lock_unlock(v33);
  if ((v32 & 0x20) != 0)
  {
    -[TFSInfo childItemCount](v6, "childItemCount");
    v34 = objc_claimAutoreleasedReturnValue();
    -[FPItem childItemCount](v8, "childItemCount");
    v35 = objc_claimAutoreleasedReturnValue();
    v36 = IsEqual(v34, v35);

    if ((v36 & 1) == 0)
    {
      *(_DWORD *)buf = 1667785588;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
  }
  -[TFSInfo itemDecorations](v6, "itemDecorations");
  v37 = objc_claimAutoreleasedReturnValue();
  -[FPItem itemDecorations](v8, "itemDecorations");
  v38 = objc_claimAutoreleasedReturnValue();
  v39 = IsEqual(v37, v38);

  if ((v39 & 1) == 0)
  {
    *(_DWORD *)buf = 1684366194;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    *(_DWORD *)buf = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    FP_ItemDecorationTypeSharing();
    v41 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    v77.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v77, v41);

    -[FPItem itemDecorations](v8, "itemDecorations");
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::NSForwardIterator<NSArray<FPItemDecoration *>>::NSForwardIterator((uint64_t)buf, v75);
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::IDContainerIteratorAdaptor((uint64_t)v79, -1, v75);
    while (*(id *)buf != v79[0] || v89 != v80)
    {
      v42 = *(id *)(*(_QWORD *)&v83[2] + 8 * v88);
      objc_msgSend(v42, "type");
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      v44 = operator==((void **)&v77.fString.fRef, v43);

      if (v44)
      {

LABEL_58:
        *(_DWORD *)buf = 1819501924;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
        *(_DWORD *)buf = 1769171056;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
        goto LABEL_59;
      }
      v45 = v88;
      if (v88 >= v87 - 1)
      {
        v46 = objc_msgSend(*(id *)buf, "countByEnumeratingWithState:objects:count:", &buf[8], v85, 4);
        v45 = -1;
        v87 = v46;
        v88 = -1;
      }
      if (v86 != *v84)
      {
        objc_enumerationMutation(*(id *)buf);
        v45 = v88;
      }
      v88 = v45 + 1;
      ++v89;
    }

    -[TFSInfo itemDecorations](v6, "itemDecorations");
    v74 = (void *)objc_claimAutoreleasedReturnValue();
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::NSForwardIterator<NSArray<FPItemDecoration *>>::NSForwardIterator((uint64_t)buf, v74);
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::IDContainerIteratorAdaptor((uint64_t)v79, -1, v74);
    while (*(id *)buf != v79[0] || v89 != v80)
    {
      v52 = *(id *)(*(_QWORD *)&v83[2] + 8 * v88);
      objc_msgSend(v52, "type");
      v53 = (void *)objc_claimAutoreleasedReturnValue();
      v54 = operator==((void **)&v77.fString.fRef, v53);

      if (v54)
      {

        goto LABEL_58;
      }
      v55 = v88;
      if (v88 >= v87 - 1)
      {
        v56 = objc_msgSend(*(id *)buf, "countByEnumeratingWithState:objects:count:", &buf[8], v85, 4, v74, v75);
        v55 = -1;
        v87 = v56;
        v88 = -1;
      }
      if (v86 != *v84)
      {
        objc_enumerationMutation(*(id *)buf);
        v55 = v88;
      }
      v88 = v55 + 1;
      ++v89;
    }

LABEL_59:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v77.fString.fRef);
  }
  v57 = TFSInfo::FPItemPermissionRestrictions(v6, v40);
  v59 = TFSInfo::FPItemPermissionRestrictions((TFSInfo *)v8, v58);
  if (v57 != v59)
  {
    *(_DWORD *)buf = 1886549619;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    if (((v59 ^ v57) & 0x98801) != 0)
    {
      *(_DWORD *)buf = 1970495843;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
  }
  if (!v76)
  {
    TFSInfo::CheckiCloudFlags((uint64_t)a1, a2, a3);
    -[TFSInfo downloadingError](v6, "downloadingError");
    v60 = objc_claimAutoreleasedReturnValue();
    -[FPItem downloadingError](v8, "downloadingError");
    v61 = objc_claimAutoreleasedReturnValue();
    v62 = NSObjectsAreEqual(v60, v61);

    if ((v62 & 1) == 0)
    {
      *(_DWORD *)buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    -[TFSInfo uploadingError](v6, "uploadingError", v74);
    v63 = objc_claimAutoreleasedReturnValue();
    -[FPItem uploadingError](v8, "uploadingError");
    v64 = objc_claimAutoreleasedReturnValue();
    v65 = NSObjectsAreEqual(v63, v64);

    if ((v65 & 1) == 0)
    {
      *(_DWORD *)buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    v66 = -[TFSInfo isItemPinned](v6, "isItemPinned");
    if (v66 != -[FPItem isItemPinned](v8, "isItemPinned")
      || (v67 = -[TFSInfo isPinnedSubitem](v6, "isPinnedSubitem"),
          v67 != -[FPItem isPinnedSubitem](v8, "isPinnedSubitem")))
    {
      *(_DWORD *)buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    IsTopLevelSharedItem = TFSInfo::IsTopLevelSharedItem(a1);
    if (IsTopLevelSharedItem != TFSInfo::IsTopLevelSharedItem(*a2))
    {
      *(_DWORD *)buf = 1936225392;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    TFSInfo::CopyICloudSharePerson(a1);
    v69 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
    TFSInfo::CopyICloudSharePerson(*a2);
    v70 = (NSPersonNameComponents *)objc_claimAutoreleasedReturnValue();
    v72 = TFSInfo::PersonEqual(v69, v70, v71);

    if ((v72 & 1) == 0)
    {
      *(_DWORD *)buf = 1769171056;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    v73 = TFSInfo::IsAppLibrary(a1);
    if (v73 != TFSInfo::IsAppLibrary(*a2))
    {
      *(_DWORD *)buf = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
  }
LABEL_77:

}

void sub_1CBC58194(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t **std::__tree<Property>::__emplace_unique_key_args<Property,Property>(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void TFSInfo::FetchBladeRunnerProperties(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  int v4;
  __int16 v5;
  FPItem *v6;
  FPItem *v7;
  NSPersonNameComponents *v8;
  void *v9;
  NSPersonNameComponents *v10;
  NSPersonNameComponents *v11;

  v4 = TFSInfo::ComputeBladeRunnerFlags(this, a2, a3);
  v5 = v4;
  TFSInfo::SetBladeRunnerFlags((uint64_t)this, v4);
  if ((v5 & 0x180) != 0)
  {
    if (UseFileProviderFramework())
    {
      TFSInfo::GetFPItem(this);
      v6 = (FPItem *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      if (v6 && -[FPItem isShared](v6, "isShared"))
      {
        if ((v5 & 0x100) != 0)
        {
          v10 = 0;
        }
        else
        {
          FPSharedItemCreator(v7);
          v10 = (NSPersonNameComponents *)objc_claimAutoreleasedReturnValue();
        }
        -[FPItem mostRecentEditorNameComponents](v7, "mostRecentEditorNameComponents");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v10 = 0;
        v9 = 0;
      }

      v8 = v10;
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    v11 = v8;
    TFSInfo::SetICloudSharePerson(this, v8);

  }
}

void sub_1CBC5861C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::ComputeBladeRunnerFlags(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  void *v4;
  int v5;
  int v6;
  TString *v7;
  BOOL v8;
  void *v9;
  void *v10;
  NSObject *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const __CFAllocator *v16;
  uint64_t i;
  void *v18;
  __CFString *fRef;
  CFMutableStringRef MutableCopy;
  TString *v21;
  const __CFString *v22;
  CFMutableStringRef v23;
  void *v24;
  TString *v25;
  const __CFString *v26;
  CFMutableStringRef v27;
  id v28;
  void *v30;
  id v31;
  id v32;
  void *v33;
  unsigned int v34;
  void *v35;
  id obj;
  void *v37;
  id v38;
  unsigned __int8 v39[16];
  id v40;
  void *v41;
  TString v42;
  TString v43;
  TString v44;
  CFTypeRef cf;
  CFTypeRef v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  id v51;
  uint8_t buf[4];
  id v53;
  __int16 v54;
  id v55;
  __int16 v56;
  void *v57;
  __int16 v58;
  id v59;
  _BYTE v60[11];
  void *v61;
  void *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)&v39[7] = 0;
  v40 = 0;
  v41 = 0;
  *(_QWORD *)v39 = 0;
  if ((TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AC48], a3) & 0x40000000) != 0)v39[0] = 1;
  TFSInfo::GetFPItem(this);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = v4;
  v5 = UseFileProviderFramework();
  if (v4)
    v6 = v5;
  else
    v6 = 0;
  if (v6 == 1)
  {
    objc_msgSend(v4, "providerDomainID");
    v7 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    *(_QWORD *)v60 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)v60, v7);

    v8 = IsLocalStorageDomainID((const TString *)v60);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v60);

    if (v8)
    {
      v33 = 0;
      v34 = 0;
      goto LABEL_36;
    }
    ComputeBRFlagsFromFPItem((FPItem *)v4, (uint64_t)v60);
    v9 = v61;
    *(_QWORD *)v39 = *(_QWORD *)v60;
    *(_DWORD *)&v39[7] = *(_DWORD *)&v60[7];
    v10 = v62;
    v61 = 0;
    v62 = 0;
    v33 = v10;
    v40 = v9;
    v41 = v10;

  }
  else
  {
    v33 = 0;
  }
  v34 = BRFlagsFromState(v39);
  if ((v34 & 0x2000) != 0
    && v4
    && objc_msgSend(v4, "isCloudItem")
    && ICloudDriveFPFSEnabled())
  {
    LogObj(4);
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      TFSInfo::Name(this, (TString *)&v38);
      v31 = objc_retainAutorelease(v38);
      TFSInfo::GetFPItem(this);
      v32 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v34);
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      TFSInfo::GetFPItem(this);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v51 = &stru_1E8752DF8;
      v35 = v12;
      CFRetain(&stru_1E8752DF8);
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      objc_msgSend(v12, "itemDecorations");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v47, v60, 16);
      if (v14)
      {
        v15 = *(_QWORD *)v48;
        v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        obj = v13;
        do
        {
          for (i = 0; i != v14; ++i)
          {
            if (*(_QWORD *)v48 != v15)
              objc_enumerationMutation(obj);
            v18 = *(void **)(*((_QWORD *)&v47 + 1) + 8 * i);
            if (objc_msgSend(v18, "requiresFetchingInfoFirst"))
            {
              TString::TString(&v44, "\t", 1uLL);
              TString::TString(&v43, "{requiresFetchingInfoFirst} ", 0x1CuLL);
              fRef = v44.fString.fRef;
              cf = &stru_1E8752DF8;
              CFRetain(&stru_1E8752DF8);
              MutableCopy = CFStringCreateMutableCopy(v16, 0, fRef);
              if (cf)
                CFRelease(cf);
              cf = MutableCopy;
              TString::Append((TString *)&cf, &v43);
              v4 = v37;
              objc_msgSend(v18, "description");
              v21 = (TString *)(id)objc_claimAutoreleasedReturnValue();
              v42.fString.fRef = &stru_1E8752DF8;
              CFRetain(&stru_1E8752DF8);
              TString::SetStringRefAsImmutable(&v42, v21);

              v22 = (const __CFString *)cf;
              v46 = &stru_1E8752DF8;
              CFRetain(&stru_1E8752DF8);
              v23 = CFStringCreateMutableCopy(v16, 0, v22);
              if (v46)
                CFRelease(v46);
              v46 = v23;
              TString::Append((TString *)&v46, &v42);
              TString::Append((TString *)&v51, (const TString *)&v46);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v46);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);

              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);
            }
            else
            {
              objc_msgSend(v18, "labelsWithItem:error:", v35, 0);
              v24 = (void *)objc_claimAutoreleasedReturnValue();
              if (objc_msgSend(v24, "count"))
              {
                TString::TString((TString *)&cf, "\t", 1uLL);
                objc_msgSend(v24, "componentsJoinedByString:", CFSTR(", "));
                v25 = (TString *)(id)objc_claimAutoreleasedReturnValue();
                v44.fString.fRef = &stru_1E8752DF8;
                CFRetain(&stru_1E8752DF8);
                TString::SetStringRefAsImmutable(&v44, v25);

                v26 = (const __CFString *)cf;
                v46 = &stru_1E8752DF8;
                CFRetain(&stru_1E8752DF8);
                v27 = CFStringCreateMutableCopy(v16, 0, v26);
                if (v46)
                  CFRelease(v46);
                v46 = v27;
                TString::Append((TString *)&v46, &v44);
                v4 = v37;
                TString::Append((TString *)&v51, (const TString *)&v46);
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v46);
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);

                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
              }

            }
            TString::Append((TString *)&v51, (const __CFString *)"\n");
          }
          v13 = obj;
          v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v47, v60, 16);
        }
        while (v14);
      }

      v28 = objc_retainAutorelease(v51);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v51);
      *(_DWORD *)buf = 138544130;
      v53 = v31;
      v54 = 2114;
      v55 = v32;
      v56 = 2114;
      v57 = v30;
      v58 = 2114;
      v59 = v28;
      _os_log_impl(&dword_1CBC4A000, v11, OS_LOG_TYPE_DEBUG, "item '%{public}@' state is 'waiting to update'\nfpItem=%{public}@\nflags=%{public}@\ndecorations=[%{public}@]\n", buf, 0x2Au);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38);
    }

  }
LABEL_36:

  return v34;
}

void sub_1CBC58C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, void *a16, uint64_t a17, void *a18, const void *a19, uint64_t a20,uint64_t a21,id a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,const void *a38)
{
  void *v38;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a38);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a19);

  _Unwind_Resume(a1);
}

void TFSInfo::SetBladeRunnerFlags(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  TFSInfoOverflow *Overflow;
  int v6;
  int v7;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (a2 != 0x80000000 || *(_QWORD *)(a1 + 80))
  {
    Overflow = TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
    os_unfair_lock_lock((os_unfair_lock_t)Overflow + 18);
    if (a2 != 0x80000000)
    {
      v6 = *((unsigned __int8 *)Overflow + 76);
      if (v6 == 2)
      {
        TFSInfoOverflow::MigrateToType((uint64_t)Overflow, 1);
      }
      else if (v6 == 3)
      {
        *((_BYTE *)Overflow + 76) = 1;
        *((_QWORD *)Overflow + 4) = 0;
        *(_OWORD *)Overflow = 0u;
        *((_OWORD *)Overflow + 1) = 0u;
        *((_DWORD *)Overflow + 8) = 0x80000000;
      }
    }
    v7 = *((unsigned __int8 *)Overflow + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)Overflow + 18);
    if (v7 == 1)
      *((_DWORD *)Overflow + 8) = a2;
  }
  os_unfair_lock_unlock(v4);
}

void sub_1CBC58ED4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

TFSInfoOverflow *TFSInfo::GetOrCreateOverflow(TFSInfo *this)
{
  TFSInfoOverflow *result;
  TFSInfoOverflow **v2;
  uint64_t v3;

  v2 = (TFSInfoOverflow **)((char *)this + 80);
  result = (TFSInfoOverflow *)*((_QWORD *)this + 10);
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_DWORD *)(v3 + 72) = 0;
    *(_BYTE *)(v3 + 76) = 3;
    std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100](v2, (TFSInfoOverflow *)v3);
    return *v2;
  }
  return result;
}

uint64_t BladeRunnerOutOfSpaceError(NSError *a1)
{
  NSError *v1;
  NSError *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  v1 = a1;
  v2 = v1;
  if (!v1)
    goto LABEL_6;
  -[NSError domain](v1, "domain");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(v3, "isEqualToString:", *MEMORY[0x1E0CB28A8]))
  {

    goto LABEL_6;
  }
  v4 = -[NSError code](v2, "code");

  if (v4 != 4354)
  {
LABEL_6:
    v5 = 0;
    goto LABEL_7;
  }
  v5 = 1;
LABEL_7:

  return v5;
}

void sub_1CBC58FD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SynchronizeLaunchServices(uint64_t a1, os_unfair_lock_s **a2, uint64_t **a3)
{
  os_unfair_lock_s *v6;
  unint64_t v7;
  os_unfair_lock_s *v8;
  os_unfair_lock_s *v9;
  unint64_t v10;
  unint64_t v11;
  os_unfair_lock_s *v12;
  os_unfair_lock_s *v13;
  unint64_t v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  os_unfair_lock_s *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  os_unfair_lock_s *v21;
  os_unfair_lock_s *v22;
  unint64_t v23;
  os_unfair_lock_s *v24;
  os_unfair_lock_s *v25;
  unint64_t v26;
  uint64_t result;
  unsigned int v28;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v7 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 2) & 1;
  os_unfair_lock_unlock(v6);
  v8 = *a2;
  v9 = *a2 + 25;
  os_unfair_lock_lock(v9);
  v10 = ((unint64_t)*(unsigned int *)((char *)&v8[28]._os_unfair_lock_opaque + 3) >> 2) & 1;
  os_unfair_lock_unlock(v9);
  if ((_DWORD)v7 != (_DWORD)v10)
  {
    v28 = 1769169264;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  os_unfair_lock_lock(v6);
  v11 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 1) & 1;
  os_unfair_lock_unlock(v6);
  v12 = *a2;
  v13 = *a2 + 25;
  os_unfair_lock_lock(v13);
  v14 = ((unint64_t)*(unsigned int *)((char *)&v12[28]._os_unfair_lock_opaque + 3) >> 1) & 1;
  os_unfair_lock_unlock(v13);
  if ((_DWORD)v11 != (_DWORD)v14)
  {
    v28 = 1769173099;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    v28 = 1819240307;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    v28 = 1885895027;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  os_unfair_lock_lock(v6);
  v15 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 4) & 1;
  os_unfair_lock_unlock(v6);
  v16 = *a2;
  v17 = *a2 + 25;
  os_unfair_lock_lock(v17);
  v18 = ((unint64_t)*(unsigned int *)((char *)&v16[28]._os_unfair_lock_opaque + 3) >> 4) & 1;
  os_unfair_lock_unlock(v17);
  if ((_DWORD)v15 != (_DWORD)v18)
  {
    os_unfair_lock_lock(v6);
    v19 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
    os_unfair_lock_unlock(v6);
    if ((v19 & 0x80000000000) != 0)
    {
      v28 = 1668506984;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    }
  }
  os_unfair_lock_lock(v6);
  v20 = (*(unsigned __int16 *)(a1 + 119) >> 12) & 1;
  os_unfair_lock_unlock(v6);
  v21 = *a2;
  v22 = *a2 + 25;
  os_unfair_lock_lock(v22);
  LODWORD(v21) = (*(unsigned __int16 *)((char *)&v21[29]._os_unfair_lock_opaque + 3) >> 12) & 1;
  os_unfair_lock_unlock(v22);
  if (v20 != (_DWORD)v21)
  {
    v28 = 1920167267;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  os_unfair_lock_lock(v6);
  v23 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 3) & 1;
  os_unfair_lock_unlock(v6);
  v24 = *a2;
  v25 = *a2 + 25;
  os_unfair_lock_lock(v25);
  v26 = ((unint64_t)*(unsigned int *)((char *)&v24[28]._os_unfair_lock_opaque + 3) >> 3) & 1;
  os_unfair_lock_unlock(v25);
  if ((_DWORD)v23 != (_DWORD)v26)
  {
    v28 = 1751480436;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    v28 = 1684955501;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  result = TFSInfo::ApplicationDMFPolicy((TFSInfo *)a1);
  if (result != -1)
    BYTE1((*a2)[28]._os_unfair_lock_opaque) = result;
  return result;
}

uint64_t TFSInfo::ApplicationDMFPolicy(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v4;
  os_unfair_lock_s *v5;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 4) == 0)
    return 0;
  v5 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v4 = *((char *)this + 113);
  os_unfair_lock_unlock(v5);
  return v4;
}

const __CFURL *TCFURLInfo::GetNumericalProperty(const __CFURL *this, const __CFString *a2, const __CFString *a3)
{
  TString *Domain;
  const __CFString *v5;
  CFIndex Code;
  CFTypeRef cf1;
  CFErrorRef error;
  const __CFNumber *propertyValueTypeRefPtr;
  uint64_t valuePtr;

  valuePtr = 0;
  if (this)
  {
    error = 0;
    propertyValueTypeRefPtr = 0;
    if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, &error))
    {
      if (propertyValueTypeRefPtr)
        CFNumberGetValue(propertyValueTypeRefPtr, kCFNumberSInt64Type, &valuePtr);
      goto LABEL_14;
    }
    Domain = (TString *)CFErrorGetDomain(error);
    cf1 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf1, Domain);
    if (*MEMORY[0x1E0C9AFB8])
      v5 = (const __CFString *)*MEMORY[0x1E0C9AFB8];
    else
      v5 = &stru_1E8752DF8;
    if (CFEqual(cf1, v5))
    {
      Code = CFErrorGetCode(error);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (Code == 260)
      {
LABEL_14:
        TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
        TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
        return (const __CFURL *)valuePtr;
      }
    }
    else
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0C9ADD0]))
      valuePtr = 0;
    goto LABEL_14;
  }
  return this;
}

void sub_1CBC593F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&a10);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef(&a11);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TFSInfo::IsAppLibrary(TFSInfo *this)
{
  void *v2;
  uint64_t v3;

  if (!UseFileProviderFramework())
    return 0;
  TFSInfo::GetFPItem(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "isContainer");

  return v3;
}

void sub_1CBC594A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t UseFileProviderFramework(void)
{
  unsigned __int8 v0;

  v0 = atomic_load(sUseFileProviderFramework);
  return v0 & 1;
}

uint64_t **TFSInfo::CheckiCloudFlags(uint64_t a1, TFSInfo **a2, uint64_t **a3)
{
  int BladeRunnerFlags;
  uint64_t **result;
  int v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  int v11;
  __int16 v12;
  unsigned int v13;
  unsigned int v14;

  BladeRunnerFlags = TFSInfo::GetBladeRunnerFlags((TFSInfo *)a1);
  result = (uint64_t **)TFSInfo::GetBladeRunnerFlags(*a2);
  if (BladeRunnerFlags != (_DWORD)result)
  {
    v8 = TFSInfo::GetBladeRunnerFlags((TFSInfo *)a1);
    if (((TFSInfo::GetBladeRunnerFlags(*a2) ^ v8) & 1) != 0)
    {
      v14 = 1685548132;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v14, &v14);
      v9 = (os_unfair_lock_s *)(a1 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
      v11 = *(_DWORD *)(a1 + 115);
      v10 = a1 + 115;
      v12 = *(_WORD *)(v10 + 4);
      *(_DWORD *)v10 = v11 & 0xEFFFFFFF;
      *(_WORD *)(v10 + 4) = v12;
      os_unfair_lock_unlock(v9);
    }
    v13 = 1969385844;
    return std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v13, &v13);
  }
  return result;
}

BOOL TFSInfo::SynchronizeVersions(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  os_unfair_lock_s *v6;
  int v7;
  int v9;
  TString *v10;
  uint64_t v11;
  const void **v12;
  const void **v13;
  TString *v14;
  uint64_t v15;
  const void **v16;
  const void **v17;
  TString *v18;
  uint64_t v19;
  const void **v20;
  const void **v21;
  TString *v22;
  uint64_t v23;
  const void **v24;
  const void **v25;
  const void **v26;
  __CFString *v27;
  TString v28;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v7 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v6);
  if ((v7 & 0x20000000) == 0)
    return 0;
  v28.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v27 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  if (TFSInfo::GetShortVersion(a1, (const void **)&v28.fString.fRef, 0)
    || TFSInfo::GetShortVersion(*a2, (const void **)&v27, 0)
    || CFEqual(v28.fString.fRef, v27))
  {
    v9 = 0;
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v22 = *(TString **)a1;
    if (!*(_QWORD *)a1)
    {
      std::make_unique[abi:ne180100]<TVersionData>((uint64_t *)&v26);
      v23 = (uint64_t)v26;
      v26 = 0;
      v24 = *(const void ***)a1;
      *(_QWORD *)a1 = v23;
      if (v24)
      {
        std::default_delete<TVersionData>::operator()[abi:ne180100](a1, v24);
        v25 = v26;
        v26 = 0;
        if (v25)
          std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v26, v25);
      }
      v22 = *(TString **)a1;
    }
    if (v22 != (TString *)&v27)
      TString::SetStringRefAsImmutable(v22, (TString *)v27);
    LODWORD(v26) = 1936225906;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v26, &v26);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    v9 = 1;
  }
  if (!TFSInfo::GetLongVersion(a1, &v28, 0)
    && !TFSInfo::GetLongVersion(*a2, (TString *)&v27, 0)
    && !CFEqual(v28.fString.fRef, v27))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v10 = *(TString **)a1;
    if (!*(_QWORD *)a1)
    {
      std::make_unique[abi:ne180100]<TVersionData>((uint64_t *)&v26);
      v11 = (uint64_t)v26;
      v26 = 0;
      v12 = *(const void ***)a1;
      *(_QWORD *)a1 = v11;
      if (v12)
      {
        std::default_delete<TVersionData>::operator()[abi:ne180100](a1, v12);
        v13 = v26;
        v26 = 0;
        if (v13)
          std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v26, v13);
      }
      v10 = *(TString **)a1;
    }
    if (&v10[1] != (TString *)&v27)
      TString::SetStringRefAsImmutable(v10 + 1, (TString *)v27);
    LODWORD(v26) = 1986359923;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v26, &v26);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    v9 = 1;
  }
  if (!TFSInfo::GetSystemVersion(a1, &v28, 0)
    && !TFSInfo::GetSystemVersion(*a2, (TString *)&v27, 0)
    && !CFEqual(v28.fString.fRef, v27))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v14 = *(TString **)a1;
    if (!*(_QWORD *)a1)
    {
      std::make_unique[abi:ne180100]<TVersionData>((uint64_t *)&v26);
      v15 = (uint64_t)v26;
      v26 = 0;
      v16 = *(const void ***)a1;
      *(_QWORD *)a1 = v15;
      if (v16)
      {
        std::default_delete<TVersionData>::operator()[abi:ne180100](a1, v16);
        v17 = v26;
        v26 = 0;
        if (v17)
          std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v26, v17);
      }
      v14 = *(TString **)a1;
    }
    if (&v14[2] != (TString *)&v27)
      TString::SetStringRefAsImmutable(v14 + 2, (TString *)v27);
    LODWORD(v26) = 1937340018;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v26, &v26);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    v9 = 1;
  }
  if (!TFSInfo::GetCopyrightString(a1, &v28, 0)
    && !TFSInfo::GetCopyrightString(*a2, (TString *)&v27, 0)
    && !CFEqual(v28.fString.fRef, v27))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v18 = *(TString **)a1;
    if (!*(_QWORD *)a1)
    {
      std::make_unique[abi:ne180100]<TVersionData>((uint64_t *)&v26);
      v19 = (uint64_t)v26;
      v26 = 0;
      v20 = *(const void ***)a1;
      *(_QWORD *)a1 = v19;
      if (v20)
      {
        std::default_delete<TVersionData>::operator()[abi:ne180100](a1, v20);
        v21 = v26;
        v26 = 0;
        if (v21)
          std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v26, v21);
      }
      v18 = *(TString **)a1;
    }
    if (&v18[3] != (TString *)&v27)
      TString::SetStringRefAsImmutable(v18 + 3, (TString *)v27);
    LODWORD(v26) = 1668313715;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v26, &v26);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    v9 = 1;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v27);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v28.fString.fRef);
  return v9 != 0;
}

void sub_1CBC59958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12)
{
  os_unfair_lock_s *v12;

  os_unfair_lock_unlock(v12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);
  _Unwind_Resume(a1);
}

const void **TFSInfo::SynchronizeNames(uint64_t a1, TFSInfo **a2, uint64_t **a3)
{
  int v6;
  int v7;
  TString v9;
  TString v10;
  TString v11;

  TFSInfo::DisplayName((TFSInfo *)a1, &v11);
  TFSInfo::Name((TFSInfo *)a1, &v10);
  TFSInfo::Name(*a2, &v9);
  v6 = CFEqual(v10.fString.fRef, v9.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
  if (!v6)
  {
    LODWORD(v10.fString.fRef) = 1886282093;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v10, &v10);
  }
  if (*(_BYTE *)(a1 + 112) != 18)
  {
    TFSInfo::DisplayName(*a2, &v10);
    v7 = CFEqual(v11.fString.fRef, v10.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
    if (!v7)
    {
      LODWORD(v10.fString.fRef) = 1684955501;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v10, &v10);
    }
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
}

void sub_1CBC59AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSInfo::DisplayName(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  TFSInfo::GetDisplayNameWhileLocked(this, a2);
  os_unfair_lock_unlock(v4);
}

void sub_1CBC59B38(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::GetDisplayNameWhileLocked(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  uint64_t *v4;

  if (CFStringGetLength(*((CFStringRef *)this + 4)))
  {
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, *((TString **)this + 4));
  }
  else if (CFStringGetLength(*((CFStringRef *)this + 3)))
  {
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, *((TString **)this + 3));
  }
  else
  {
    v4 = TString::KEmptyString(0);
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)*v4);
  }
}

void sub_1CBC59BE8(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::IsPackage(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 1) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TFSInfo::IsTopLevelSharedItem(TFSInfo *this)
{
  void *v2;
  void *v3;
  uint64_t v4;

  if (!UseFileProviderFramework())
    return 0;
  TFSInfo::GetFPItem(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = objc_msgSend(v2, "isTopLevelSharedItem");

  return v4;
}

void sub_1CBC59C90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id TFSInfo::CopyICloudSharePerson(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  int v4;
  id v5;

  v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v3 = *((_QWORD *)this + 10);
  if (v3
    && (os_unfair_lock_lock((os_unfair_lock_t)(v3 + 72)),
        v4 = *(unsigned __int8 *)(v3 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 72)),
        v4 == 1))
  {
    v5 = *(id *)v3;
  }
  else
  {
    v5 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

uint64_t NSObjectsAreEqual(NSObject *a1, NSObject *a2)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
    v6 = -[NSObject isEqual:](v3, "isEqual:", v4);
  else
    v6 = v4 == 0;

  return v6;
}

void sub_1CBC59D78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TFSInfoOverflow::FolderSizeRecord(os_unfair_lock_s *this@<X0>, uint64_t a2@<X8>)
{
  os_unfair_lock_s *v4;
  _OWORD *v5;
  __int128 v6;

  v4 = this + 18;
  os_unfair_lock_lock(this + 18);
  v5 = *(_OWORD **)&this[10]._os_unfair_lock_opaque;
  if (v5)
  {
    v6 = v5[1];
    *(_OWORD *)a2 = *v5;
    *(_OWORD *)(a2 + 16) = v6;
    LOBYTE(v5) = 1;
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
  *(_BYTE *)(a2 + 32) = (_BYTE)v5;
  os_unfair_lock_unlock(v4);
}

uint64_t __destroy_helper_block_ea8_32c98_ZTSKZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEE3__0(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 48);
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

void ___ZN12TGlobalNodes28iCloudLibrariesContainerNodeEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  TNodePtr v18;
  id obj;
  uint64_t v20;
  std::__shared_weak_count *v21;

  TFSVolumeInfo::GetVolumeInfoFor(0x17u, &v20);
  TNodePtr::TNodePtr(&v18, 0);
  v2 = *(std::__shared_weak_count **)(v20 + 64);
  v16 = *(_QWORD *)(v20 + 56);
  v17 = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  v14 = 0;
  v15 = 0;
  TNode::CreateNode(&obj, &v18, &v16, &v14);
  v5 = v15;
  if (v15)
  {
    v6 = (unint64_t *)&v15->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v17;
  if (v17)
  {
    v9 = (unint64_t *)&v17->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 80), obj);
  v11 = v21;
  if (v21)
  {
    v12 = (unint64_t *)&v21->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1CBC59FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, id a13)
{
  uint64_t v13;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v13 - 32);
  _Unwind_Resume(a1);
}

void ___ZN12TGlobalNodes16AllProvidersNodeEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  TNodePtr v21;
  id obj;
  __int128 v23;

  TFSVolumeInfo::GetVolumeInfoFor(0x1Bu, &v23);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](*(_QWORD *)(a1 + 32) + 104, &v23);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  TFSVolumeInfo::GetVolumeInfoFor(0x1Au, &v23);
  TNodePtr::TNodePtr(&v21, 0);
  v5 = *(std::__shared_weak_count **)(v23 + 64);
  v19 = *(_QWORD *)(v23 + 56);
  v20 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v17 = 0;
  v18 = 0;
  TNode::CreateNode(&obj, &v21, &v19, &v17);
  v8 = v18;
  if (v18)
  {
    v9 = (unint64_t *)&v18->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v20;
  if (v20)
  {
    v12 = (unint64_t *)&v20->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 96), obj);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_1CBC5A174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, id a13)
{
  uint64_t v13;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v13 - 32);
  _Unwind_Resume(a1);
}

void TNode::SynchronizeChildren(uint64_t a1, int a2, TNodeEventPtrs *a3)
{
  os_unfair_lock_s *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int v10;
  unint64_t v11;
  void **v12;
  TString *v13;
  __CFString *fRef;
  CFMutableStringRef MutableCopy;
  char v16;
  TNode *v17;
  NSObject *v18;
  os_unfair_lock_s *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  os_unfair_lock_s *v24;
  int v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unsigned __int16 *v31;
  BOOL v32;
  int v33;
  _BOOL8 v34;
  uint64_t v35;
  int v36;
  _BOOL8 Dir;
  const TString *v38;
  unsigned __int16 v39;
  double Current;
  const __CFString *v41;
  unsigned __int16 v42;
  int Children;
  int v44;
  unsigned __int16 v46;
  double v47;
  TFSVolumeInfo *v48;
  std::__shared_weak_count *v49;
  int v50;
  char v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  FINode *v59;
  os_unfair_lock_s *v60;
  int v61;
  FINode *v62;
  os_unfair_lock_s *v63;
  int v64;
  FINode *v65;
  FINode *v66;
  unint64_t *v67;
  unint64_t v68;
  TNode *v69;
  TNode *v70;
  FINode *v71;
  uint64_t v72;
  TNode *v73;
  __int128 v74;
  FINode *v75;
  unint64_t *v76;
  unint64_t v77;
  FINode *v78;
  unint64_t *v79;
  unint64_t v80;
  uint64_t v81;
  FINode ***v82;
  FINode **v83;
  id *v84;
  uint64_t v85;
  os_unfair_lock_s *v86;
  FINode *v87;
  FINode *v88;
  unint64_t *v89;
  unint64_t v90;
  char v91;
  char v92;
  unint64_t *v93;
  unint64_t v94;
  FINode *v95;
  uint64_t v96;
  os_unfair_lock_s *v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  unint64_t *v100;
  unint64_t v101;
  int v102;
  unint64_t v103;
  unsigned __int16 v104;
  unint64_t *v105;
  unint64_t v106;
  _QWORD *v107;
  FINode *v108;
  os_unfair_lock_s *v109;
  char **v110;
  unint64_t *v111;
  unint64_t v112;
  _QWORD *v113;
  void **v114;
  FINode *v115;
  unint64_t *v116;
  unint64_t v117;
  unsigned __int16 *v118;
  unsigned __int16 v119;
  void **v120;
  FINode *v121;
  unint64_t *v122;
  unint64_t v123;
  unsigned __int16 *v124;
  unsigned __int16 v125;
  __int128 v126;
  FINode *v127;
  unint64_t *v128;
  unint64_t v129;
  FINode *v130;
  unint64_t *v131;
  unint64_t v132;
  FINode *fFINode;
  FINode *v134;
  uint64_t v135;
  FINode *v136;
  FINode *v137;
  unint64_t *v138;
  unint64_t v139;
  TNode *v140;
  os_unfair_lock_s *v141;
  uint64_t v142;
  std::__shared_weak_count *v143;
  unint64_t *v144;
  unint64_t v145;
  int v146;
  unint64_t v147;
  FINode **v148;
  FINode *v149;
  uint64_t v150;
  os_unfair_lock_s *v151;
  uint64_t v152;
  FINode **v153;
  FINode **v154;
  unsigned __int16 *v155;
  unsigned __int16 v156;
  int v157;
  FINode *v158;
  unint64_t *v159;
  unint64_t v160;
  TString *v161;
  TString *v162;
  uint64_t v163;
  _QWORD *v164;
  _QWORD *v165;
  void *v166;
  char v167;
  FINode *v168;
  unint64_t *v169;
  unint64_t v170;
  void **v171;
  void **v172;
  uint64_t *v173;
  uint64_t v174;
  os_unfair_lock_s *v175;
  FINode *v176;
  uint64_t v177;
  unint64_t *v178;
  unint64_t v179;
  int v180;
  uint64_t v181;
  os_unfair_lock_s *v182;
  uint64_t v183;
  os_unfair_lock_s *v184;
  const void *v185;
  FINode *v186;
  void *v187;
  TNode *v188;
  int v189;
  uint64_t v190;
  os_unfair_lock_s *v191;
  uint64_t v192;
  os_unfair_lock_s *v193;
  const void *v194;
  TFSInfo *v195;
  TFSInfo *v196;
  FPItem *v197;
  FINode *v198;
  void *v199;
  TNode *v200;
  uint64_t v201;
  FINode *v202;
  unint64_t *v203;
  unint64_t v204;
  id *v205;
  uint64_t v206;
  unint64_t *v207;
  unint64_t v208;
  std::__shared_weak_count *v209;
  unint64_t *v210;
  unint64_t v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  _BOOL4 v217;
  int v218;
  int v219;
  int v220;
  int v221;
  BOOL v222;
  uint64_t v223;
  BOOL v225;
  CFTypeRef cf;
  FINode **v227;
  uint64_t v228;
  TNodePtr v229;
  TNodePtr v230[4];
  TNodePtr v231[2];
  TNodePtr v232[2];
  uint64_t v233;
  void **v234[2];
  uint64_t v235;
  TString **v236;
  void **v237;
  unint64_t v238;
  TString *v239;
  void **v240;
  uint64_t v241;
  TString v242;
  uint64_t v243;
  uint64_t v244;
  std::__shared_weak_count *v245;
  std::__shared_weak_count *v246;
  uint8_t buf[8];
  std::__shared_weak_count *v248;
  int v249;
  id v250;
  std::__shared_weak_count *v251;
  TNodePtr v252;

  v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v5);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    os_unfair_lock_unlock(v5);
    v10 = *(unsigned __int8 *)(v6 + 112);
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    if (v10)
      goto LABEL_14;
  }
  else
  {
    os_unfair_lock_unlock(v5);
    if (*(_BYTE *)(v6 + 112))
      goto LABEL_14;
  }
  TNode::CFURL((TNode *)a1, &v239);
  v12 = v239;
  objc_msgSend(v12, "path");
  v13 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  v242.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v242, v13);

  fRef = v242.fString.fRef;
  *(_QWORD *)buf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, fRef);
  if (*(_QWORD *)buf)
    CFRelease(*(CFTypeRef *)buf);
  *(_QWORD *)buf = MutableCopy;
  TString::Append((TString *)buf, (const __CFString *)"/");
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v242.fString.fRef);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v239);
  v16 = PathEligibleForSynching((const TString *)buf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if ((v16 & 1) == 0)
    return;
LABEL_14:
  v17 = (TNode *)TNode::VirtualType((TNode *)a1);
  v215 = (int)v17;
  if ((_DWORD)v17 == 29)
  {
    LogObj(6);
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1CBC4A000, v18, OS_LOG_TYPE_DEFAULT, "Synching iTunes device list", buf, 2u);
    }

  }
  v19 = (os_unfair_lock_s *)TNode::InfoLock(v17);
  os_unfair_lock_lock(v19);
  v20 = *(_QWORD *)(a1 + 16);
  v21 = *(std::__shared_weak_count **)(a1 + 24);
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  os_unfair_lock_unlock(v19);
  v24 = (os_unfair_lock_s *)(v20 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v20 + 100));
  v25 = *(_DWORD *)(v20 + 115);
  os_unfair_lock_unlock(v24);
  if (!v21)
    goto LABEL_25;
  v26 = (unint64_t *)&v21->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
    if ((v25 & 0x100) != 0)
      goto LABEL_26;
  }
  else
  {
LABEL_25:
    if ((v25 & 0x100) != 0)
    {
LABEL_26:
      TNode::GetVolumeInfo((TNode *)a1, buf);
      TFSVolumeInfo::ReadHiddenListFile(*(TFSVolumeInfo **)buf);
      v28 = v248;
      if (v248)
      {
        v29 = (unint64_t *)&v248->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }
  }
  v225 = 0;
  v220 = a2 & 0xC00000;
  v216 = a2 & 0x1200000;
  v212 = a2 & 0x1C00000;
  v31 = (unsigned __int16 *)(a1 + 80);
  v221 = a2 & 0xA00000;
  v32 = (a2 & 0x1200000) == 0x200000 || (a2 & 0xA00000) == 10485760;
  v33 = v32;
  v214 = v33;
  v213 = a2;
  do
  {
    v34 = TNode::NeedsChildReconcile((TNode *)a1);
    if (v221 != 10485760 && v216 != 0x200000 && !v212 && !v34)
      return;
    v35 = TTime::MicrosecondsSinceStartup((TTime *)v34);
    TNodePtr::TNodePtr((TNodePtr *)&v242, (const TNode *)a1);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)buf, (const TNodePtr *)&v242, 0);

    v36 = v249;
    TNode::StPopulating::~StPopulating((FINode **)buf);
    if ((a2 & 0x40000000) != 0)
      TNode::SetPrefetchPropertiesOnSync((TNode *)a1);
    Dir = TFSVolumeInfo::ShouldUseReadDir(*(TFSVolumeInfo **)a1);
    if (Dir)
    {
      Dir = TNode::ShouldUseReadDir((TNode *)a1);
      v38 = (const TString *)Dir;
    }
    else
    {
      v38 = 0;
    }
    if ((TFSVolumeInfo::ShouldSkipLSProperties((TFSVolumeInfo *)Dir) & 1) == 0)
    {
      do
        v39 = __ldaxr(v31);
      while (__stlxr(v39 | 0x1000, v31));
    }
    TNodePtr::TNodePtr((TNodePtr *)&v242, (const TNode *)a1);
    TFSInfoSynchronizer::TFSInfoSynchronizer((TFSInfoSynchronizer *)buf, (const TNodePtr *)&v242);
    v223 = v35;

    Current = CFAbsoluteTimeGetCurrent();
    v41 = (const __CFString *)*(unsigned __int8 *)(*(_QWORD *)a1 + 133);
    v42 = atomic_load((unsigned __int16 *)(a1 + 80));
    Children = TFSInfoSynchronizer::FetchChildren((uint64_t)buf, (uint64_t)v38, v41, (v42 & 0x1000) == 0);
    v44 = Children;
    if (Children == -8086 || Children == 0)
    {
      v225 = Children == -8086;
      if (Children != -8086)
      {
        do
          v46 = __ldaxr(v31);
        while (__stlxr(v46 | 0x1000, v31));
      }
      v47 = CFAbsoluteTimeGetCurrent();
      if (TFSVolumeInfo::ShouldRecordIterationTimes(v48))
      {
        TNode::Path((TNode *)a1, (CFTypeRef *)&v242.fString.fRef);
        if (CFStringGetLength(v242.fString.fRef))
          TFSVolumeInfo::UpdateIterationPerfData((TFSVolumeInfo *)&v242, v38, v47 - Current, v44 == -8086, ((uint64_t)v248 - *(_QWORD *)buf) >> 4);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v242.fString.fRef);
      }
    }
    if (v44 && v44 != -8086)
    {
      v51 = 1;
      v50 = 1;
      goto LABEL_287;
    }
    v49 = (std::__shared_weak_count *)operator new(0x30uLL);
    v49->__shared_owners_ = 0;
    v49->__shared_weak_owners_ = 0;
    v49->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87508F0;
    v49[1].__vftable = 0;
    v49[1].__shared_owners_ = 0;
    v49[1].__shared_weak_owners_ = 0;
    v245 = v49 + 1;
    v246 = v49;
    v242.fString.fRef = 0;
    v243 = 0;
    v244 = 0;
    v239 = 0;
    v240 = 0;
    v241 = 0;
    v236 = 0;
    v237 = 0;
    v238 = 0;
    TNodePtr::TNodePtr(v232, (const TNode *)a1);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)v234, v232, 0);

    v222 = (_DWORD)v235 != v36;
    if ((_DWORD)v235 != v36)
    {
      TNode::StPopulating::~StPopulating((FINode **)v234);
      v50 = 4;
      goto LABEL_281;
    }
    if (v215)
    {
      v217 = 0;
    }
    else
    {
      TNode::CFURL((TNode *)a1, v232);
      v217 = URLMightBeInFileProvider((uint64_t)v232[0].fFINode) != 0;
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v232[0].fFINode);
    }
    v52 = *(_QWORD *)(a1 + 56);
    v53 = (_QWORD *)(v52 + 64);
    v32 = v52 == 0;
    v54 = &TNode::GetChildren(void)const::sEmptyList;
    if (!v32)
      v54 = v53;
    v57 = v54;
    v55 = *v54;
    v56 = v57[1];
    v58 = v56 - v55;
    if (((v56 != v55) & ~v214) != 0)
    {
      v232[0].fFINode = 0;
      v232[1].fFINode = 0;
      v233 = 0;
      TNode::UnmarkChildren((TNode *)a1);
      TFSInfoSynchronizer::Next(buf, v231);
      if (!v231[0].fFINode)
      {
LABEL_169:
        fFINode = v232[0].fFINode;
        v134 = v232[1].fFINode;
        while (fFINode != v134)
        {
          cf = 0;
          if (v225)
          {
            TNodePtr::TNodePtr(&v252, (const TNode *)a1);
            TNode::CreateNode(v135, (uint64_t)fFINode, a1, v230);
            TNodePtr::operator=((void **)&cf, (void **)&v230[0].fFINode);

            v136 = v252.fFINode;
          }
          else
          {
            TNodePtr::TNodePtr(&v229, (const TNode *)a1);
            v230[0].fFINode = 0;
            v230[1].fFINode = 0;
            TNode::CreateNode((uint64_t)&v229, (uint64_t)fFINode, (uint64_t)v230, &v252);
            TNodePtr::operator=((void **)&cf, (void **)&v252.fFINode);

            v137 = v230[1].fFINode;
            if (v230[1].fFINode)
            {
              v138 = (unint64_t *)&v230[1].fFINode[1];
              do
                v139 = __ldaxr(v138);
              while (__stlxr(v139 - 1, v138));
              if (!v139)
              {
                (*((void (**)(FINode *))v137->super.isa + 2))(v137);
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v137);
              }
            }
            v136 = v229.fFINode;
          }

          if (TNodeFromFINode((FINode *)cf))
            std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v239, (id *)&cf);

          fFINode += 2;
        }
        memset(v230, 0, 24);
        cf = 0;
        v227 = 0;
        v228 = 0;
        v219 = TNode::AddNewChildren(a1, (TNodePtr **)&v239, 0, (uint64_t)v230, (uint64_t *)&cf);
        if (!v220 && ((v219 ^ 1) & 1) == 0)
        {
          v148 = (FINode **)v230[0].fFINode;
          v149 = v230[1].fFINode;
          while (v148 != (FINode **)v149)
          {
            v150 = TNodeFromFINode(*v148);
            v151 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v150);
            os_unfair_lock_lock(v151);
            TNodePtr::TNodePtr(&v252, *(const TNode **)(v150 + 48));
            os_unfair_lock_unlock(v151);
            v152 = TNodeFromFINode(v252.fFINode);

            if (v152)
            {
              TNodePtr::TNodePtr(&v252, (const TNode *)a1);
              TNodeEvent::CreateNodeEvent(3, (id *)v148, 0, &v229);
              TNodeEventPtrs::AddEvent(a3, &v252, (id *)&v229.fFINode);
              TNodeEventPtr::~TNodeEventPtr((id *)&v229.fFINode);

            }
            ++v148;
          }
        }
        v153 = (FINode **)cf;
        v154 = v227;
        while (v153 != v154)
        {
          v155 = (unsigned __int16 *)(TNodeFromFINode(*v153) + 80);
          do
            v156 = __ldaxr(v155);
          while (__stlxr(v156 | 0x100, v155));
          ++v153;
        }
        v157 = TNode::RemoveUnmarkedChildren((TNode *)a1, a3);
        if (v217)
          TNode::UpdateFPItemsMetadata(a1, (void ***)v230);
        v252.fFINode = (FINode *)&cf;
        std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v252);
        cf = v230;
        std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&cf);
        v158 = v231[1].fFINode;
        if (v231[1].fFINode)
        {
          v159 = (unint64_t *)&v231[1].fFINode[1];
          do
            v160 = __ldaxr(v159);
          while (__stlxr(v160 - 1, v159));
          if (!v160)
          {
            (*((void (**)(FINode *))v158->super.isa + 2))(v158);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v158);
          }
        }
        v218 = v157;
        v230[0].fFINode = (FINode *)v232;
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)v230);
        goto LABEL_234;
      }
      v81 = *(_QWORD *)(a1 + 56);
      if (v81)
        v82 = (FINode ***)(v81 + 64);
      else
        v82 = (FINode ***)&TNode::GetChildren(void)const::sEmptyList;
      while (1)
      {
        v83 = TChildrenList::LowerBounds(v81, (TFSInfo **)v231);
        v84 = (id *)v83;
        if (v82[1] == v83)
          break;
        v85 = TNodeFromFINode(*v83);
        v86 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v85);
        os_unfair_lock_lock(v86);
        v87 = *(FINode **)(v85 + 16);
        v88 = *(FINode **)(v85 + 24);
        v230[0].fFINode = v87;
        v230[1].fFINode = v88;
        if (v88)
        {
          v89 = (unint64_t *)&v88[1];
          do
            v90 = __ldxr(v89);
          while (__stxr(v90 + 1, v89));
        }
        os_unfair_lock_unlock(v86);
        v91 = TFSInfo::SameIdentity((TFSInfo *)v87, (TFSInfo **)v231);
        v92 = v91;
        if (!v88)
          goto LABEL_113;
        v93 = (unint64_t *)&v88[1];
        do
          v94 = __ldaxr(v93);
        while (__stlxr(v94 - 1, v93));
        if (!v94)
        {
          (*((void (**)(FINode *))v88->super.isa + 2))(v88);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v88);
          if ((v92 & 1) == 0)
            break;
        }
        else
        {
LABEL_113:
          if ((v91 & 1) == 0)
            break;
        }
        v95 = (FINode *)*v84;
        v96 = TNodeFromFINode(v95);
        v97 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v96);
        os_unfair_lock_lock(v97);
        v98 = *(_QWORD *)(v96 + 16);
        v99 = *(std::__shared_weak_count **)(v96 + 24);
        if (v99)
        {
          v100 = (unint64_t *)&v99->__shared_owners_;
          do
            v101 = __ldxr(v100);
          while (__stxr(v101 + 1, v100));
          os_unfair_lock_unlock(v97);
          v102 = *(unsigned __int8 *)(v98 + 112);
          do
            v103 = __ldaxr(v100);
          while (__stlxr(v103 - 1, v100));
          if (!v103)
          {
            ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
            std::__shared_weak_count::__release_weak(v99);
          }
        }
        else
        {
          os_unfair_lock_unlock(v97);
          v102 = *(unsigned __int8 *)(v98 + 112);
        }
        if (v102 != 7)
        {
          v230[0].fFINode = v95;
          v230[1] = v231[0];
          v230[2] = v231[1];
          if (v231[1].fFINode)
          {
            v111 = (unint64_t *)&v231[1].fFINode[1];
            do
              v112 = __ldxr(v111);
            while (__stxr(v112 + 1, v111));
          }
          if ((unint64_t)v237 >= v238)
          {
            v120 = (void **)std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__push_back_slow_path<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>((uint64_t *)&v236, (uint64_t)v230);
            v121 = v230[2].fFINode;
            v237 = v120;
            if (v230[2].fFINode)
            {
              v122 = (unint64_t *)&v230[2].fFINode[1];
              do
                v123 = __ldaxr(v122);
              while (__stlxr(v123 - 1, v122));
              if (!v123)
              {
                (*((void (**)(FINode *))v121->super.isa + 2))(v121);
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v121);
              }
            }
          }
          else
          {
            v113 = TNodePtr::TNodePtr(v237, (id *)&v230[0].fFINode);
            *(_OWORD *)(v113 + 1) = *(_OWORD *)&v230[1].fFINode;
            v230[1].fFINode = 0;
            v230[2].fFINode = 0;
            v237 = (void **)(v113 + 3);
          }

        }
        v124 = (unsigned __int16 *)(TNodeFromFINode(v95) + 80);
        do
          v125 = __ldaxr(v124);
        while (__stlxr(v125 | 0x100, v124));

LABEL_158:
        TFSInfoSynchronizer::Next(buf, v230);
        v126 = *(_OWORD *)&v230[0].fFINode;
        v230[0].fFINode = 0;
        v230[1].fFINode = 0;
        v127 = v231[1].fFINode;
        *(_OWORD *)&v231[0].fFINode = v126;
        if (v127)
        {
          v128 = (unint64_t *)&v127[1];
          do
            v129 = __ldaxr(v128);
          while (__stlxr(v129 - 1, v128));
          if (!v129)
          {
            (*((void (**)(FINode *))v127->super.isa + 2))(v127);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v127);
          }
        }
        v130 = v230[1].fFINode;
        if (v230[1].fFINode)
        {
          v131 = (unint64_t *)&v230[1].fFINode[1];
          do
            v132 = __ldaxr(v131);
          while (__stlxr(v132 - 1, v131));
          if (!v132)
          {
            (*((void (**)(FINode *))v130->super.isa + 2))(v130);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v130);
          }
        }
        if (!v231[0].fFINode)
          goto LABEL_169;
      }
      cf = 0;
      TChildrenList::FindRenamedChild(v81, (TFSInfo **)v231, v230);
      TNodePtr::operator=((void **)&cf, (void **)&v230[0].fFINode);

      if (!TNodeFromFINode((FINode *)cf)
        || (v104 = atomic_load((unsigned __int16 *)(TNodeFromFINode((FINode *)cf) + 80)), (v104 & 0x100) != 0))
      {
        v108 = v231[0].fFINode;
        v109 = (os_unfair_lock_s *)&v231[0].fFINode[12].super.isa + 1;
        os_unfair_lock_lock((os_unfair_lock_t)&v231[0].fFINode[12].super.isa + 1);
        LODWORD(v108) = *(_DWORD *)((char *)&v108[14].super.isa + 3);
        os_unfair_lock_unlock(v109);
        if (((unsigned __int16)v108 & 0x100) != 0 && !LOBYTE(v231[0].fFINode[14].super.isa))
          v110 = (char **)&v242;
        else
          v110 = (char **)v232;
        std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100](v110, (__int128 *)v231);
      }
      else
      {
        v230[0].fFINode = (FINode *)(id)cf;
        v230[1] = v231[0];
        v230[2] = v231[1];
        if (v231[1].fFINode)
        {
          v105 = (unint64_t *)&v231[1].fFINode[1];
          do
            v106 = __ldxr(v105);
          while (__stxr(v106 + 1, v105));
        }
        if ((unint64_t)v237 >= v238)
        {
          v114 = (void **)std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__push_back_slow_path<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>((uint64_t *)&v236, (uint64_t)v230);
          v115 = v230[2].fFINode;
          v237 = v114;
          if (v230[2].fFINode)
          {
            v116 = (unint64_t *)&v230[2].fFINode[1];
            do
              v117 = __ldaxr(v116);
            while (__stlxr(v117 - 1, v116));
            if (!v117)
            {
              (*((void (**)(FINode *))v115->super.isa + 2))(v115);
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v115);
            }
          }
        }
        else
        {
          v107 = TNodePtr::TNodePtr(v237, (id *)&v230[0].fFINode);
          *(_OWORD *)(v107 + 1) = *(_OWORD *)&v230[1].fFINode;
          v230[1].fFINode = 0;
          v230[2].fFINode = 0;
          v237 = (void **)(v107 + 3);
        }

        v118 = (unsigned __int16 *)(TNodeFromFINode((FINode *)cf) + 80);
        do
          v119 = __ldaxr(v118);
        while (__stlxr(v119 | 0x100, v118));
      }

      goto LABEL_158;
    }
    TFSInfoSynchronizer::Next(buf, v232);
    while (1)
    {
      v59 = v232[0].fFINode;
      if (!v232[0].fFINode)
        break;
      v60 = (os_unfair_lock_s *)&v232[0].fFINode[12].super.isa + 1;
      os_unfair_lock_lock((os_unfair_lock_t)&v232[0].fFINode[12].super.isa + 1);
      v61 = *(_DWORD *)((char *)&v59[14].super.isa + 3);
      os_unfair_lock_unlock(v60);
      if ((v61 & 0x100) != 0)
      {
        v62 = v232[0].fFINode;
        if (!LOBYTE(v232[0].fFINode[14].super.isa))
        {
          v63 = (os_unfair_lock_s *)&v232[0].fFINode[12].super.isa + 1;
          os_unfair_lock_lock((os_unfair_lock_t)&v232[0].fFINode[12].super.isa + 1);
          v64 = *(_DWORD *)((char *)&v62[14].super.isa + 3);
          os_unfair_lock_unlock(v63);
          if ((v64 & 0x8000) == 0)
            std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)&v242, (__int128 *)v232);
        }
      }
      if (v225)
      {
        TNodePtr::TNodePtr(v230, (const TNode *)a1);
        TNode::CreateNode((uint64_t)v230, (uint64_t)v232, a1, (TNodePtr *)&cf);
        v65 = v230[0].fFINode;
      }
      else
      {
        TNodePtr::TNodePtr(v231, (const TNode *)a1);
        v230[0].fFINode = 0;
        v230[1].fFINode = 0;
        TNode::CreateNode((uint64_t)v231, (uint64_t)v232, (uint64_t)v230, (TNodePtr *)&cf);
        v66 = v230[1].fFINode;
        if (v230[1].fFINode)
        {
          v67 = (unint64_t *)&v230[1].fFINode[1];
          do
            v68 = __ldaxr(v67);
          while (__stlxr(v68 - 1, v67));
          if (!v68)
          {
            (*((void (**)(FINode *))v66->super.isa + 2))(v66);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v66);
          }
        }
        v65 = v231[0].fFINode;
      }

      if (LOBYTE(v232[0].fFINode[14].super.isa) != 25)
        goto LABEL_89;
      v69 = (TNode *)TNodeFromFINode((FINode *)cf);
      TNode::ResolveBRContainer(v69);
      v70 = (TNode *)TNodeFromFINode((FINode *)cf);
      TNode::GetAliasTarget(v70, v230);
      v71 = v230[0].fFINode;
      v72 = TNodeFromFINode(v230[0].fFINode);

      if (v72)
      {
        v73 = (TNode *)TNodeFromFINode((FINode *)cf);
        TNode::SetShouldSyncUbiquityAttributes(v73, 1);
LABEL_89:
        std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v239, (id *)&cf);
      }
      TFSInfoSynchronizer::Next(buf, v230);
      v74 = *(_OWORD *)&v230[0].fFINode;
      v230[0].fFINode = 0;
      v230[1].fFINode = 0;
      v75 = v232[1].fFINode;
      *(_OWORD *)&v232[0].fFINode = v74;
      if (v75)
      {
        v76 = (unint64_t *)&v75[1];
        do
          v77 = __ldaxr(v76);
        while (__stlxr(v77 - 1, v76));
        if (!v77)
        {
          (*((void (**)(FINode *))v75->super.isa + 2))(v75);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v75);
        }
      }
      v78 = v230[1].fFINode;
      if (v230[1].fFINode)
      {
        v79 = (unint64_t *)&v230[1].fFINode[1];
        do
          v80 = __ldaxr(v79);
        while (__stlxr(v80 - 1, v79));
        if (!v80)
        {
          (*((void (**)(FINode *))v78->super.isa + 2))(v78);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v78);
        }
      }

    }
    TNode::ReplaceChildrenWith(a1, (void ***)&v239, 0);
    if (v220)
      goto LABEL_225;
    if ((v214 & 1) == 0)
    {
      v161 = v239;
      v162 = (TString *)v240;
      while (v161 != v162)
      {
        v230[0].fFINode = (FINode *)v161->fString.fRef;
        TNodePtr::TNodePtr((TNodePtr *)&cf, (const TNode *)a1);
        TNodeEvent::CreateNodeEvent(3, (id *)&v230[0].fFINode, 0, v231);
        TNodeEventPtrs::AddEvent(a3, (const TNodePtr *)&cf, (id *)&v231[0].fFINode);
        TNodeEventPtr::~TNodeEventPtr((id *)&v231[0].fFINode);

        ++v161;
      }
    }
    v141 = (os_unfair_lock_s *)TNode::InfoLock(v140);
    os_unfair_lock_lock(v141);
    v142 = *(_QWORD *)(a1 + 16);
    v143 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v143)
    {
      os_unfair_lock_unlock(v141);
      if (!*(_BYTE *)(v142 + 112))
        goto LABEL_221;
LABEL_217:
      if (v215 != 26 && v215 != 29 && v239 != (TString *)v240)
      {
        TNodePtr::TNodePtr(v230, (const TNode *)a1);
        TNodePtr::TNodePtr(v231, (const TNode *)a1);
        TNodeEvent::CreateNodeEvent(20, (id *)&v231[0].fFINode, 0, &cf);
        TNodeEventPtrs::AddEvent(a3, v230, (id *)&cf);
        TNodeEventPtr::~TNodeEventPtr((id *)&cf);

      }
      goto LABEL_221;
    }
    v144 = (unint64_t *)&v143->__shared_owners_;
    do
      v145 = __ldxr(v144);
    while (__stxr(v145 + 1, v144));
    os_unfair_lock_unlock(v141);
    v146 = *(unsigned __int8 *)(v142 + 112);
    do
      v147 = __ldaxr(v144);
    while (__stlxr(v147 - 1, v144));
    if (!v147)
    {
      ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
      std::__shared_weak_count::__release_weak(v143);
    }
    if (v146)
      goto LABEL_217;
LABEL_221:
    v163 = *(_QWORD *)(a1 + 56);
    v164 = (_QWORD *)(v163 + 64);
    v32 = v163 == 0;
    v165 = &TNode::GetChildren(void)const::sEmptyList;
    if (!v32)
      v165 = v164;
    if (v165[1] - *v165 != v58)
    {
      TNodePtr::TNodePtr(v230, (const TNode *)a1);
      TNodePtr::TNodePtr(v231, (const TNode *)a1);
      TNodeEvent::CreatePropertyChangedNodeEvent((id *)&v231[0].fFINode, 1667785588, &cf);
      TNodeEventPtrs::AddEvent(a3, v230, (id *)&cf);
      TNodeEventPtr::~TNodeEventPtr((id *)&cf);

    }
LABEL_225:
    if (v217)
    {
      TNode::GetFIProvider((TNode *)a1);
      v166 = (void *)objc_claimAutoreleasedReturnValue();
      v167 = objc_msgSend(v166, "isLocalStorageDomain");

      if ((v167 & 1) == 0)
        TNode::UpdateFPItemsMetadata(a1, (void ***)(*(_QWORD *)(a1 + 56) + 64));
    }
    v168 = v232[1].fFINode;
    if (v232[1].fFINode)
    {
      v169 = (unint64_t *)&v232[1].fFINode[1];
      do
        v170 = __ldaxr(v169);
      while (__stlxr(v170 - 1, v169));
      if (!v170)
      {
        (*((void (**)(FINode *))v168->super.isa + 2))(v168);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v168);
      }
    }
    v219 = 0;
    v218 = 0;
LABEL_234:
    TNode::StPopulating::~StPopulating((FINode **)v234);
    v234[0] = 0;
    v234[1] = 0;
    v235 = 0;
    v171 = (void **)v236;
    v172 = v237;
    while (2)
    {
      if (v171 != v172)
      {
        v173 = (uint64_t *)(v171 + 1);
        v174 = TNodeFromFINode((FINode *)*v171);
        v175 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v174);
        os_unfair_lock_lock(v175);
        v177 = *(_QWORD *)(v174 + 16);
        v176 = *(FINode **)(v174 + 24);
        v232[0].fFINode = (FINode *)v177;
        v232[1].fFINode = v176;
        if (v176)
        {
          v178 = (unint64_t *)&v176[1];
          do
            v179 = __ldxr(v178);
          while (__stxr(v179 + 1, v178));
        }
        os_unfair_lock_unlock(v175);
        os_unfair_lock_lock((os_unfair_lock_t)(v177 + 100));
        v180 = *(_DWORD *)(v177 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(v177 + 100));
        if ((v180 & 0x2000000) == 0)
        {
          v181 = *v173;
          v182 = (os_unfair_lock_s *)(*v173 + 100);
          os_unfair_lock_lock(v182);
          LODWORD(v181) = *(_DWORD *)(v181 + 115);
          os_unfair_lock_unlock(v182);
          if ((v181 & 0x2000000) != 0)
          {
            v183 = *v173;
            v184 = (os_unfair_lock_s *)(*v173 + 100);
            os_unfair_lock_lock(v184);
            v185 = *(const void **)(v183 + 16);
            cf = v185;
            if (v185)
              CFRetain(v185);
            os_unfair_lock_unlock(v184);
            v230[0].fFINode = (FINode *)cf;
            if (cf)
              CFRetain(cf);
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf);
            if (v230[0].fFINode)
              TFSInfo::initialize(*v173, (const __CFURL *)v230[0].fFINode, 0, 1, 1, 1, 0);
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v230[0].fFINode);
          }
          os_unfair_lock_lock((os_unfair_lock_t)(v177 + 100));
          v186 = *(FINode **)(v177 + 16);
          v230[0].fFINode = v186;
          if (v186)
            CFRetain(v186);
          os_unfair_lock_unlock((os_unfair_lock_t)(v177 + 100));
          if (v230[0].fFINode)
          {
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v230[0].fFINode);
            goto LABEL_253;
          }
          TFSInfo::GetFPItem((TFSInfo *)v177);
          v187 = (void *)objc_claimAutoreleasedReturnValue();

          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v230[0].fFINode);
          if (v187)
          {
LABEL_253:
            v188 = (TNode *)TNodeFromFINode((FINode *)*v171);
            TNode::FetchAdditionalPropertiesForSync(v188, (TFSInfo **)v171 + 1, 1);
          }
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v177 + 100));
        v189 = *(_DWORD *)(v177 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(v177 + 100));
        if ((v189 & 0x40000000) != 0)
        {
          v190 = *v173;
          v191 = (os_unfair_lock_s *)(*v173 + 100);
          os_unfair_lock_lock(v191);
          LODWORD(v190) = *(_DWORD *)(v190 + 115);
          os_unfair_lock_unlock(v191);
          if ((v190 & 0x40000000) == 0)
          {
            v192 = *v173;
            v193 = (os_unfair_lock_s *)(*v173 + 100);
            os_unfair_lock_lock(v193);
            v194 = *(const void **)(v192 + 16);
            cf = v194;
            if (v194)
              CFRetain(v194);
            os_unfair_lock_unlock(v193);
            v230[0].fFINode = (FINode *)cf;
            if (cf)
              CFRetain(cf);
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf);
            v195 = (TFSInfo *)*v173;
            if (v230[0].fFINode)
            {
              TFSInfo::initialize((uint64_t)v195, (const __CFURL *)v230[0].fFINode, 0, 1, 1, 1, 0);
            }
            else if (TFSInfo::IsFPv2(v195, 0))
            {
              v196 = (TFSInfo *)*v173;
              TFSInfo::GetFPItem((TFSInfo *)*v173);
              v197 = (FPItem *)objc_claimAutoreleasedReturnValue();
              TFSInfo::Initialize(v196, v197, 0);

            }
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v230[0].fFINode);
          }
          os_unfair_lock_lock((os_unfair_lock_t)(v177 + 100));
          v198 = *(FINode **)(v177 + 16);
          v230[0].fFINode = v198;
          if (v198)
            CFRetain(v198);
          os_unfair_lock_unlock((os_unfair_lock_t)(v177 + 100));
          if (v230[0].fFINode)
          {
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v230[0].fFINode);
            goto LABEL_270;
          }
          TFSInfo::GetFPItem((TFSInfo *)v177);
          v199 = (void *)objc_claimAutoreleasedReturnValue();

          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v230[0].fFINode);
          if (v199)
          {
LABEL_270:
            v200 = (TNode *)TNodeFromFINode((FINode *)*v171);
            TNode::FetchAdditionalPropertiesForSync(v200, (TFSInfo **)v171 + 1, 1);
          }
        }
        v201 = TNodeFromFINode((FINode *)*v171);
        TNode::ReconcileInternalProperties(v201, (TFSInfo **)v171 + 1, (TNodeEventPtrs *)v234, 1);
        v202 = v232[1].fFINode;
        if (v232[1].fFINode)
        {
          v203 = (unint64_t *)&v232[1].fFINode[1];
          do
            v204 = __ldaxr(v203);
          while (__stlxr(v204 - 1, v203));
          if (!v204)
          {
            (*((void (**)(FINode *))v202->super.isa + 2))(v202);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v202);
          }
        }
        v171 += 3;
        continue;
      }
      break;
    }
    v205 = TNodeEventPtrs::AddEvents((id **)a3, v234);
    a2 = v213;
    if (!v220 && v219 | v218)
    {
      TNodePtr::TNodePtr(v232, (const TNode *)a1);
      TNodePtr::TNodePtr((TNodePtr *)&cf, (const TNode *)a1);
      TNodeEvent::CreatePropertyChangedNodeEvent((id *)&cf, 1667785588, v230);
      TNodeEventPtrs::AddEvent(a3, v232, (id *)&v230[0].fFINode);
      TNodeEventPtr::~TNodeEventPtr((id *)&v230[0].fFINode);

    }
    v206 = TTime::MicrosecondsSinceStartup((TTime *)v205);
    TChildrenList::SetLastSyncTime(*(TChildrenList **)(a1 + 56), v223);
    TChildrenList::SetLastSyncDuration(*(TChildrenList **)(a1 + 56), v206 - v223);
    v232[0].fFINode = (FINode *)v234;
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)v232);
    v50 = 0;
    v49 = v246;
LABEL_281:
    v234[0] = (void **)&v236;
    std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destroy_vector::operator()[abi:ne180100](v234);
    v236 = &v239;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v236);
    v239 = &v242;
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v239);
    if (v49)
    {
      v207 = (unint64_t *)&v49->__shared_owners_;
      do
        v208 = __ldaxr(v207);
      while (__stlxr(v208 - 1, v207));
      if (!v208)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    v51 = v222;
LABEL_287:
    v209 = v251;
    if (v251)
    {
      v210 = (unint64_t *)&v251->__shared_owners_;
      do
        v211 = __ldaxr(v210);
      while (__stlxr(v211 - 1, v210));
      if (!v211)
      {
        ((void (*)(std::__shared_weak_count *))v209->__on_zero_shared)(v209);
        std::__shared_weak_count::__release_weak(v209);
      }
    }

    v242.fString.fRef = (__CFString *)buf;
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v242);
  }
  while ((v50 | 4) == 4 && (v51 & 1) != 0);
}

void sub_1CBC5B740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,uint64_t a25,uint64_t a26,id a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void ****a33,uint64_t a34,uint64_t a35,void ***a36,uint64_t a37,uint64_t a38,void **a39)
{
  uint64_t v39;

  TNodeEventPtr::~TNodeEventPtr(&a19);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
  TNode::StPopulating::~StPopulating((FINode **)&a33);
  a33 = &a36;
  std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);
  a36 = &a39;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a36);
  a39 = (void **)(v39 - 216);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&a39);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v39 - 192);
  TFSInfoSynchronizer::~TFSInfoSynchronizer((id *)(v39 - 176));
  _Unwind_Resume(a1);
}

_QWORD *TFSInfoSynchronizer::Next@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  _QWORD *v3;

  *a2 = 0;
  a2[1] = 0;
  v2 = *((unsigned int *)this + 12);
  if (v2 < (uint64_t)(this[1] - *this) >> 4)
  {
    v3 = this;
    this = std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a2, (uint64_t *)(*this + 16 * v2));
    ++*((_DWORD *)v3 + 12);
  }
  return this;
}

FINode **TChildrenList::LowerBounds(uint64_t a1, TFSInfo **a2)
{
  FINode **result;
  FINode **v5;
  unint64_t v6;
  FINode **v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  TFSInfo *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _BOOL4 v14;
  unint64_t *v15;
  unint64_t v16;

  TChildrenList::SortListIfNeeded((TChildrenList *)a1, 0);
  v5 = *(FINode ***)(a1 + 64);
  result = *(FINode ***)(a1 + 72);
  if (result != v5)
  {
    v6 = result - v5;
    do
    {
      v7 = &v5[v6 >> 1];
      v8 = TNodeFromFINode(*v7);
      v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
      os_unfair_lock_lock(v9);
      v11 = *(TFSInfo **)(v8 + 16);
      v10 = *(std::__shared_weak_count **)(v8 + 24);
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v9);
      v14 = TFSInfo::LessThan(v11, a2);
      if (v10)
      {
        v15 = (unint64_t *)&v10->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      if (v14)
        v6 += ~(v6 >> 1);
      else
        v6 >>= 1;
      if (v14)
        v5 = v7 + 1;
    }
    while (v6);
    return v5;
  }
  return result;
}

void sub_1CBC5BC68(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;

  if (v1)
    TChildrenList::LowerBounds(v1);
  _Unwind_Resume(exception_object);
}

void TNode::CreateNode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, TNodePtr *a4@<X8>)
{
  id v8;
  TNode *v9;
  objc_class *v10;

  FIDSNodeSubclassForVirtualType(*(unsigned __int8 *)(*(_QWORD *)a2 + 112));
  v10 = (objc_class *)objc_claimAutoreleasedReturnValue();
  v8 = objc_alloc_init(v10);
  +[FINode trackNodeCreated:](FINode, "trackNodeCreated:", v8);
  v9 = (TNode *)objc_msgSend(v8, "asTNode");
  TNode::TNode(v9, a1, a2, a3);
  if (*(_BYTE *)(*(_QWORD *)a2 + 112) == 27)
    TNode::UpdateOnDiskProviderRoot(v9);
  TNodePtr::TNodePtr(a4, v9);

}

void sub_1CBC5BD34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t TNode::TNode(uint64_t a1, FINode **a2, os_unfair_lock_s **a3, uint64_t *a4)
{
  _QWORD *v7;
  unsigned __int16 *v8;
  TChildrenList **v9;
  unsigned __int16 v10;
  os_unfair_lock_s *v11;
  os_unfair_lock_s *v12;
  TChildrenList *v13;
  TNode *v14;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;

  *(_OWORD *)(a1 + 16) = 0u;
  v7 = (_QWORD *)(a1 + 16);
  *(_WORD *)(a1 + 80) = 0;
  v8 = (unsigned __int16 *)(a1 + 80);
  v9 = (TChildrenList **)(a1 + 56);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (*a4)
  {
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)a1, a4);
  }
  else
  {
    TNode::VolumeInfoFor(a2, a3, &v19);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1, &v19);
    v16 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v19 + 1))
    {
      v17 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  *(_QWORD *)(a1 + 48) = TNodeFromFINode(*a2);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v7, (uint64_t *)a3);
  do
    v10 = __ldaxr(v8);
  while (__stlxr(v10 | 0x100, v8));
  v11 = *a3;
  v12 = *a3 + 25;
  os_unfair_lock_lock(v12);
  LODWORD(v11) = *(os_unfair_lock_s *)((char *)v11 + 115);
  os_unfair_lock_unlock(v12);
  if ((v11 & 0x20) != 0)
  {
    v13 = (TChildrenList *)operator new();
    TChildrenList::TChildrenList(v13, (const TNode *)a1);
    std::unique_ptr<TChildrenList>::reset[abi:ne180100](v9, v13);
  }
  if (TNode::IsDeferredForSymlink(a1, (uint64_t (*)(_QWORD *))TFSInfo::IsApplication, 0))
    TDeviceManagementMonitor::RegisterApp((TNode *)a1, v14);
  return a1;
}

void sub_1CBC5BED0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  TChildrenList **v3;
  uint64_t v5;
  uint64_t v6;

  v5 = *(_QWORD *)(v1 + 72);
  *(_QWORD *)(v1 + 72) = 0;
  if (v5)
    std::default_delete<TNotifierList>::operator()[abi:ne180100](v1 + 72, v5);
  std::unique_ptr<TChildrenList>::reset[abi:ne180100](v3, 0);
  v6 = *(_QWORD *)(v1 + 40);
  *(_QWORD *)(v1 + 40) = 0;
  if (v6)
    MEMORY[0x1D17A53D0](v6, 0x1020C40A5B76CDFLL);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t TNode::IsDeferredForSymlink(uint64_t a1, uint64_t (*a2)(_QWORD *), uint64_t a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  os_unfair_lock_s *v11;
  int v12;
  TNode *v13;
  unint64_t *v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  TNode *v25;
  os_unfair_lock_s *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  FINode *v32;
  uint64_t v33;
  os_unfair_lock_s *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  _QWORD *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v45;
  FINode *v46;

  v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v6);
  v8 = *(_QWORD *)(a1 + 16);
  v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v6);
  v11 = (os_unfair_lock_s *)(v8 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  v12 = *(_DWORD *)(v8 + 115);
  os_unfair_lock_unlock(v11);
  if (v7)
  {
    v14 = (unint64_t *)&v7->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if ((v12 & 0x40) == 0)
        goto LABEL_9;
LABEL_20:
      TNode::GetAliasTarget((TNode *)a1, &v46);
      v26 = (os_unfair_lock_s *)TNode::InfoLock(v25);
      os_unfair_lock_lock(v26);
      v28 = *(_QWORD *)(a1 + 16);
      v27 = *(std::__shared_weak_count **)(a1 + 24);
      v45 = v27;
      if (v27)
      {
        v29 = (unint64_t *)&v27->__shared_owners_;
        do
          v30 = __ldxr(v29);
        while (__stxr(v30 + 1, v29));
      }
      os_unfair_lock_unlock(v26);
      os_unfair_lock_lock((os_unfair_lock_t)(v28 + 100));
      v31 = *(unsigned int *)(v28 + 115) | ((unint64_t)*(unsigned __int16 *)(v28 + 119) << 32);
      os_unfair_lock_unlock((os_unfair_lock_t)(v28 + 100));
      if ((v31 & 0x200000000) != 0 || (v32 = v46, !TNodeFromFINode(v46)))
      {
        v22 = 0;
        if (!v27)
        {
LABEL_42:

          return v22;
        }
      }
      else
      {
        v33 = TNodeFromFINode(v32);
        v34 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v33);
        os_unfair_lock_lock(v34);
        v36 = *(_QWORD *)(v33 + 16);
        v35 = *(std::__shared_weak_count **)(v33 + 24);
        if (v35)
        {
          v37 = (unint64_t *)&v35->__shared_owners_;
          do
            v38 = __ldxr(v37);
          while (__stxr(v38 + 1, v37));
        }
        os_unfair_lock_unlock(v34);
        v39 = (_QWORD *)(v36 + (a3 >> 1));
        if ((a3 & 1) != 0)
          a2 = *(uint64_t (**)(_QWORD *))(*v39 + a2);
        v22 = a2(v39);
        if (v35)
        {
          v40 = (unint64_t *)&v35->__shared_owners_;
          do
            v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        v27 = v45;
        if (!v45)
          goto LABEL_42;
      }
      v42 = (unint64_t *)&v27->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
      goto LABEL_42;
    }
  }
  if ((v12 & 0x40) != 0)
    goto LABEL_20;
LABEL_9:
  v16 = (os_unfair_lock_s *)TNode::InfoLock(v13);
  os_unfair_lock_lock(v16);
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(std::__shared_weak_count **)(a1 + 24);
  if (v17)
  {
    v19 = (unint64_t *)&v17->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  os_unfair_lock_unlock(v16);
  v21 = (_QWORD *)(v18 + (a3 >> 1));
  if ((a3 & 1) != 0)
    a2 = *(uint64_t (**)(_QWORD *))(*v21 + a2);
  v22 = a2(v21);
  if (v17)
  {
    v23 = (unint64_t *)&v17->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  return v22;
}

void sub_1CBC5C1F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

const void **TNode::VolumeInfoFor@<X0>(FINode **a1@<X0>, os_unfair_lock_s **a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  int v8;
  os_unfair_lock_s *v9;
  int os_unfair_lock_opaque_low;
  uint64_t v11;
  TNode *v12;
  unsigned int v13;
  os_unfair_lock_s *v15;
  os_unfair_lock_s *v16;
  os_unfair_lock_s *v17;
  os_unfair_lock_s *v18;
  TFSVolumeInfo *v19;
  const __CFURL *v20;
  TFSVolumeInfo *v21;
  const __CFURL *v22;
  const __CFURL *v23;
  TNode *v24;
  TFSVolumeInfo *v25;

  v6 = *a2;
  v7 = *a2 + 25;
  os_unfair_lock_lock(v7);
  v8 = *(uint32_t *)((char *)&v6[28]._os_unfair_lock_opaque + 3);
  os_unfair_lock_unlock(v7);
  v9 = *a2;
  os_unfair_lock_opaque_low = LOBYTE((*a2)[28]._os_unfair_lock_opaque);
  if ((v8 & 0x100) != 0)
  {
    if (LOBYTE((*a2)[28]._os_unfair_lock_opaque))
      return TFSVolumeInfo::GetVolumeInfoFor(LOBYTE((*a2)[28]._os_unfair_lock_opaque), a3);
    os_unfair_lock_lock(v9 + 25);
    v21 = *(TFSVolumeInfo **)&v9[4]._os_unfair_lock_opaque;
    v25 = v21;
    if (v21)
      CFRetain(v21);
    os_unfair_lock_unlock(v9 + 25);
    TFSVolumeInfo::GetVolumeInfoFor(v21, v22, a3);
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v25);
  }
  v11 = TNodeFromFINode(*a1);
  if (!os_unfair_lock_opaque_low)
  {
    if (v11)
    {
      v15 = *a2;
      v16 = *a2 + 25;
      os_unfair_lock_lock(v16);
      LODWORD(v15) = *(os_unfair_lock_s *)((char *)v15 + 115);
      os_unfair_lock_unlock(v16);
      if (((unsigned __int16)v15 & 0x8000) != 0)
      {
        v24 = (TNode *)TNodeFromFINode(*a1);
        TNode::CFURL(v24, &v25);
      }
      else
      {
        v17 = *a2;
        v18 = *a2 + 25;
        os_unfair_lock_lock(v18);
        v19 = *(TFSVolumeInfo **)&v17[4]._os_unfair_lock_opaque;
        v25 = v19;
        if (v19)
          CFRetain(v19);
        os_unfair_lock_unlock(v18);
      }
      TFSVolumeInfo::GetVolumeInfoFor(v25, v20, a3);
    }
    else
    {
      TCFURLInfo::BootURL(&v25);
      TFSVolumeInfo::GetVolumeInfoFor(v25, v23, a3);
    }
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v25);
  }
  if (v11)
  {
    v12 = (TNode *)TNodeFromFINode(*a1);
    v13 = TNode::VirtualType(v12);
  }
  else
  {
    v13 = LOBYTE((*a2)[28]._os_unfair_lock_opaque);
  }
  return TFSVolumeInfo::GetVolumeInfoFor(v13, a3);
}

void sub_1CBC5C3CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::IsApplication(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 2) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

const void **TFSVolumeInfo::GetVolumeInfoFor@<X0>(TFSVolumeInfo *this@<X0>, const __CFURL *a2@<X1>, _QWORD *a3@<X8>)
{
  const void **result;
  CFURLRef v6;
  void *v7;
  _BOOL4 v8;
  TCFURLInfo *v9;
  NSObject *v10;
  NSURL *v11;
  void *v12;
  void *v13;
  CFTypeRef cf;
  const __CFURL *propertyValueTypeRefPtr;
  const void *v16;
  uint8_t buf[4];
  void *v18;
  __int16 v19;
  void *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  TCFURLInfo::GetVolumeID((TCFURLInfo *)this, a2, &v16);
  TFSVolumeInfo::VolumeInfoFor(&v16, a3);
  result = TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v16);
  if (!*a3)
  {
    propertyValueTypeRefPtr = 0;
    CFURLCopyResourcePropertyForKey((CFURLRef)this, (CFStringRef)*MEMORY[0x1E0C9B7E8], &propertyValueTypeRefPtr, 0);
    if (!propertyValueTypeRefPtr)
      return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
    v6 = CFURLCreateFileReferenceURL(0, propertyValueTypeRefPtr, 0);
    cf = v6;
    if (v6)
    {
      -[__CFURL path](v6, "path");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = v7 == 0;

      if (v8)
      {
        LogObj(7);
        v10 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          v11 = propertyValueTypeRefPtr;
          v12 = (id)cf;
          SanitizedURL(v11);
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543618;
          v18 = v12;
          v19 = 2114;
          v20 = v13;
          _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_ERROR, "Can't get path of fileRefURL %{public}@ for volume %{public}@ using path url instead", buf, 0x16u);

        }
        if (cf)
          CFRelease(cf);
        cf = 0;
      }
      else
      {
        v9 = (TCFURLInfo *)cf;
        if (cf)
        {
LABEL_13:
          TFSVolumeInfo::AddVolume(v9, 0, a3);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf);
          return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
        }
      }
    }
    v9 = propertyValueTypeRefPtr;
    goto LABEL_13;
  }
  return result;
}

void sub_1CBC5C5E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  const void *v8;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v8 = va_arg(va1, const void *);
  v6 = v4;

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va1);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

CFTypeRef TCFURLInfo::GetVolumeID@<X0>(TCFURLInfo *this@<X0>, const __CFURL *a2@<X1>, _QWORD *a3@<X8>)
{
  CFTypeRef result;

  result = TCFURLInfo::GetVolumeIdentifier(this, a2);
  *a3 = result;
  if (result)
    return CFRetain(result);
  return result;
}

CFTypeRef TCFURLInfo::GetVolumeIdentifier(TCFURLInfo *this, const __CFURL *a2)
{
  CFTypeRef v2;
  CFTypeRef propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  if (!this)
    return 0;
  CFURLCopyResourcePropertyForKey(this, (CFStringRef)*MEMORY[0x1E0C9B6A0], &propertyValueTypeRefPtr, 0);
  v2 = propertyValueTypeRefPtr;
  if (propertyValueTypeRefPtr)
    CFAutorelease(propertyValueTypeRefPtr);
  return v2;
}

const void **TFSVolumeInfo::VolumeInfoFor@<X0>(const void **a1@<X0>, _QWORD *a2@<X8>)
{
  const void *v3;
  CFTypeRef v5;
  char v6;
  const void *v7;
  CFTypeRef cf;
  char v9;

  v3 = *a1;
  v7 = v3;
  if (v3)
    CFRetain(v3);
  TFSVolumeInfo::GetMapKey(&v7, 0, (uint64_t)&cf);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v7);
  v5 = cf;
  if (cf)
    CFRetain(cf);
  v6 = v9;
  TFSVolumeInfo::GetVolumeInfoForNoSync((id *)&v5, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf);
}

void sub_1CBC5C75C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void TFSVolumeInfo::GetVolumeInfoForNoSync(id *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *VolumeMap;
  _QWORD *v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;

  VolumeMap = (_QWORD *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  v5 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(VolumeMap, a1);
  v6 = v5;
  if (v5)
  {
    *a2 = 0;
    a2[1] = 0;
    v7 = (std::__shared_weak_count *)v5[5];
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      a2[1] = v8;
      if (v8)
      {
        v9 = v6[4];
        *a2 = v9;
        if (v9)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
          return;
        }
      }
    }
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)a2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  *a2 = 0;
  a2[1] = 0;
}

void sub_1CBC5C864(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  _Unwind_Resume(a1);
}

void VolumeInfoLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      VolumeInfoLock(void)::sVolumeInfoLock = 0;
    }
  }
}

uint64_t GetVolumeMap(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  {
    v2 = operator new();
    *(_QWORD *)(v2 + 32) = 0;
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 1065353216;
    GetVolumeMap(void)::map = v2;
  }
  return GetVolumeMap(void)::map;
}

void sub_1CBC5C944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(_QWORD *a1, id *this)
{
  uint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;

  v4 = ROSPVolumeID::Hash(this);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4 ^ *((unsigned __int8 *)this + 8);
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4 ^ *((unsigned __int8 *)this + 8);
    if (v6 >= *(_QWORD *)&v5)
      v9 = v6 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v6;
  }
  v10 = *(_QWORD **)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = (_QWORD *)*v10;
  if (*v10)
  {
    do
    {
      v12 = v11[1];
      if (v12 == v6)
      {
        if ((VolumeKey::operator==((uint64_t)(v11 + 2), (uint64_t)this) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v12 >= *(_QWORD *)&v5)
            v12 %= *(_QWORD *)&v5;
        }
        else
        {
          v12 &= *(_QWORD *)&v5 - 1;
        }
        if (v12 != v9)
          return 0;
      }
      v11 = (_QWORD *)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t ROSPVolumeID::Hash(id *this)
{
  return objc_msgSend(*this, "hash");
}

uint64_t VolumeKey::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t result;

  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)a2;
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
    return *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
  }
  result = CFEqual((CFTypeRef)v4, (CFTypeRef)v5);
  if ((_DWORD)result)
    return *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
  return result;
}

CFTypeRef *TFSVolumeInfo::GetMapKey@<X0>(CFTypeRef *a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  CFTypeRef *result;

  *(_QWORD *)a3 = 0;
  *(_BYTE *)(a3 + 8) = 0;
  result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a3, *a1);
  *(_BYTE *)(a3 + 8) = a2;
  return result;
}

void sub_1CBC5CAF4(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SameIdentity(TFSInfo *this, TFSInfo **a2)
{
  uint64_t v5;
  uint64_t VolumeIdentifier;
  os_unfair_lock_s *v7;
  unint64_t v8;
  TFSInfo *v9;
  os_unfair_lock_s *v10;
  unint64_t v11;
  _BOOL4 v12;
  TFSInfo *v13;
  os_unfair_lock_s *v14;
  unint64_t v15;
  TString v16;
  TString v17;

  if (*a2 == this)
    return 1;
  if (*((unsigned __int8 *)this + 112) - 27 <= 1)
    return TFSInfo::Equal(this, a2);
  VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
  if (VolumeIdentifier != TFSInfo::GetVolumeIdentifier(*a2))
    return 0;
  v7 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v8 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 5) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  v9 = *a2;
  v10 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v10);
  v11 = ((unint64_t)*(unsigned int *)((char *)v9 + 115) >> 5) & 1;
  os_unfair_lock_unlock(v10);
  if ((_DWORD)v8 != (_DWORD)v11)
    return 0;
  TFSInfo::Name(this, &v17);
  TFSInfo::Name(*a2, &v16);
  if (CFEqual(v17.fString.fRef, v16.fString.fRef))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v12 = (*(_DWORD *)((char *)this + 115) & 0x40) == 0;
    os_unfair_lock_unlock(v7);
    v13 = *a2;
    v14 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v14);
    v15 = ((unint64_t)*(unsigned int *)((char *)v13 + 115) >> 6) & 1;
    os_unfair_lock_unlock(v14);
    v5 = v12 ^ v15;
  }
  else
  {
    v5 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);
  return v5;
}

void sub_1CBC5CC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TChildrenList::TChildrenList(TChildrenList *this, const TNode *a2)
{
  uint64_t v3;

  TDSMutex::TDSMutex((TDSMutex *)this, 1);
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_QWORD *)(v3 + 96) = a2;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 120) = 0u;
  *(_OWORD *)(v3 + 136) = 0u;
  *(_OWORD *)(v3 + 152) = 0u;
  *(_OWORD *)(v3 + 168) = 0u;
  *(_OWORD *)(v3 + 184) = 0u;
  *(_WORD *)(v3 + 200) = 0;
}

void TDSMutex::TDSMutex(TDSMutex *this, int a2)
{
  pthread_mutexattr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    pthread_mutexattr_init(&v3);
    pthread_mutexattr_settype(&v3, 2);
    pthread_mutex_init(&this->fMutex, &v3);
    pthread_mutexattr_destroy(&v3);
  }
  else
  {
    pthread_mutex_init(&this->fMutex, 0);
  }
}

const void **TFSVolumeInfo::GetVolumeInfoFor@<X0>(unsigned int a1@<W0>, _QWORD *a2@<X8>)
{
  const void **result;
  const void *v5;
  char v6;
  const void *v7;

  v5 = 0;
  v6 = 0;
  v7 = 0;
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(&v5, &v7);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v7);
  v6 = a1;
  TFSVolumeInfo::GetVolumeInfoForNoSync((id *)&v5, a2);
  result = TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
  if (!*a2)
    return (const void **)TFSVolumeInfo::AddVirtualVolume(a1, a2);
  return result;
}

void sub_1CBC5CDE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

const void **TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

void TChildrenList::~TChildrenList(TChildrenList *this)
{
  void **v2;

  TChildrenList::DetachChildren(this);

  v2 = (void **)((char *)this + 64);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v2);
  TDSMutex::~TDSMutex((TDSMutex *)this);
}

void TDSMutex::~TDSMutex(TDSMutex *this)
{
  pthread_mutex_destroy(&this->fMutex);
}

{
  pthread_mutex_destroy(&this->fMutex);
}

void TChildrenList::DetachChildren(TChildrenList *this)
{
  FINode **v1;
  FINode **v2;
  uint64_t v3;
  uint64_t v4;
  os_unfair_lock_s *v5;
  FINode *v6;
  TNode *v7;

  v1 = (FINode **)*((_QWORD *)this + 8);
  v2 = (FINode **)*((_QWORD *)this + 9);
  if (v1 != v2)
  {
    v3 = *((_QWORD *)this + 12);
    do
    {
      v4 = TNodeFromFINode(*v1);
      v5 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v4);
      os_unfair_lock_lock(v5);
      if (*(_QWORD *)(v4 + 48) == v3)
        *(_QWORD *)(v4 + 48) = 0;
      os_unfair_lock_unlock(v5);
      v6 = *v1++;
      v7 = (TNode *)TNodeFromFINode(v6);
      TNode::ClearAliasTarget(v7, 0);
    }
    while (v1 != v2);
  }
}

void sub_1CBC5CFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t TNode::GetNodeFromURL(CFURLRef *a1, TNodePtr *a2, unsigned int a3)
{
  TString *v6;
  const TString *v7;
  uint64_t NodeFromFSInfo;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  TNode *v12;
  uint64_t v14;
  TNode *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  TNode *v19;
  TFSInfo *v20[2];
  CFStringRef theString;
  TString v22;
  std::__shared_weak_count *v23;
  char v24;
  TString *v25;

  TNodePtr::TNodePtr((TNodePtr *)&v22, 0);
  TNodePtr::operator=((void **)&a2->fFINode, (void **)&v22.fString.fRef);

  if (*a1)
  {
    v6 = (TString *)CFURLCopyScheme(*a1);
    v25 = v6;
    v22.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v22, v6);
    LODWORD(v6) = TFSInfo::IsNetworkScheme((TFSInfo *)&v22, v7);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
    if ((_DWORD)v6)
    {
      v24 = 0;
      v20[0] = (TFSInfo *)TFSInfo::SFNodeFromURL((uint64_t)*a1, (a3 & 2) == 0, &v24);
      if (v20[0])
      {
        std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,void>(&v24, (uint64_t *)v20, &v22);
        NodeFromFSInfo = TNode::GetNodeFromFSInfo((TFSInfo **)&v22, (void **)&a2->fFINode);
        v9 = v23;
        if (v23)
        {
          p_shared_owners = (unint64_t *)&v23->__shared_owners_;
          do
            v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }
      else
      {
        NodeFromFSInfo = 4294959236;
      }
      TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef((const void **)v20);
      if ((_DWORD)NodeFromFSInfo)
        goto LABEL_20;
    }
    else
    {
      if ((IsAppInbox((NSURL *)*a1) & 1) != 0)
      {
        NodeFromFSInfo = 4294959238;
LABEL_20:
        TNodePtr::TNodePtr((TNodePtr *)&v22, 0);
        TNodePtr::operator=((void **)&a2->fFINode, (void **)&v22.fString.fRef);

LABEL_26:
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v25);
        return NodeFromFSInfo;
      }
      TCFURLInfo::FileSystemRepresentation(*a1, (const __CFURL *)1, (TString *)&theString);
      if (CFStringGetLength(theString))
      {
        NodeFromFSInfo = TNode::GetNodeFromPath((TString *)&theString, a2, a3);
        if (!(_DWORD)NodeFromFSInfo)
        {
          if ((a3 & 0x80) != 0)
            goto LABEL_42;
          _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v22);
          v12 = (TNode *)TNodeFromFINode(a2->fFINode);
          TNode::GetFSInfo(v12, v20);
          NodeFromFSInfo = TFSInfo::initialize((uint64_t)v22.fString.fRef, *a1, 1, 1, 1, 1, 0);
          if (!(_DWORD)NodeFromFSInfo)
          {
            if ((TFSInfo::Equal((TFSInfo *)v22.fString.fRef, v20) & 1) != 0)
            {
              NodeFromFSInfo = 0;
            }
            else
            {
              v14 = TNodeFromFINode(a2->fFINode);
              NodeFromFSInfo = TNode::HandleSync(v14, 0x80000u);
            }
          }
          std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v20);
          std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v22);
          if (!(_DWORD)NodeFromFSInfo)
          {
LABEL_42:
            if (TNodeFromFINode(a2->fFINode))
            {
              v15 = (TNode *)TNodeFromFINode(a2->fFINode);
              TNode::GetFSInfo(v15, &v22);
              NodeFromFSInfo = TFSInfo::IsMountTrigger((TFSInfo *)v22.fString.fRef);
              v16 = v23;
              if (v23)
              {
                v17 = (unint64_t *)&v23->__shared_owners_;
                do
                  v18 = __ldaxr(v17);
                while (__stlxr(v18 - 1, v17));
                if (!v18)
                {
                  ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
                  std::__shared_weak_count::__release_weak(v16);
                }
              }
              if ((_DWORD)NodeFromFSInfo)
              {
                v19 = (TNode *)TNodeFromFINode(a2->fFINode);
                TNode::GetFSInfo(v19, &v22);
                NodeFromFSInfo = TFSInfo::TriggerMount((TFSInfo *)v22.fString.fRef);
                std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v22);
                if (!(_DWORD)NodeFromFSInfo)
                  NodeFromFSInfo = TNode::GetNodeFromPath((TString *)&theString, a2, a3);
              }
            }
            else
            {
              NodeFromFSInfo = 0;
            }
          }
        }
      }
      else
      {
        NodeFromFSInfo = 4294959236;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if ((_DWORD)NodeFromFSInfo)
        goto LABEL_20;
    }
    if (TNodeFromFINode(a2->fFINode))
      NodeFromFSInfo = 0;
    else
      NodeFromFSInfo = 4294959238;
    goto LABEL_26;
  }
  return 4294959236;
}

void sub_1CBC5D2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  const void *v6;
  va_list va;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, const void *);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)(v4 - 40));
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::Equal(TFSInfo *this, TFSInfo **a2)
{
  int v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  id v14;
  uint64_t ObjectIdentifier;
  uint64_t VolumeIdentifier;
  int IsSymlink;
  TFSInfo *v18;
  os_unfair_lock_s *v19;
  uint64_t v20;
  int v21;
  void *v22;
  void *v23;
  TString v25;
  TString v26;

  v4 = *((unsigned __int8 *)this + 112);
  if (v4 == 25)
  {
    TFSInfo::GetFPItem(this);
    v5 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "itemIdentifier");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    TFSInfo::GetFPItem(*a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "itemIdentifier");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v6, "compare:", v8) == 0;

LABEL_31:
    return v9;
  }
  if ((v4 - 23) <= 1)
    return v4 == *((unsigned __int8 *)*a2 + 112);
  if (v4 == 28)
  {
    TFSInfo::GetFPItem(this);
    v5 = (id)objc_claimAutoreleasedReturnValue();
    TFSInfo::GetFPItem(*a2);
    v13 = objc_claimAutoreleasedReturnValue();
    v14 = (id)v13;
    if (!v5 && v13)
    {
      v9 = 1;
LABEL_30:

      goto LABEL_31;
    }
    if (v13)
    {
      v9 = objc_msgSend(v5, "isEqualToItem:", v13);
      goto LABEL_30;
    }
LABEL_29:
    v9 = 0;
    goto LABEL_30;
  }
  if (v4 == 27)
  {
    v10 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v11 = *((_QWORD *)this + 10);
    if (v11
      && (os_unfair_lock_lock((os_unfair_lock_t)(v11 + 72)),
          v12 = *(unsigned __int8 *)(v11 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 72)),
          v12 == 1))
    {
      v5 = *(id *)(v11 + 24);
    }
    else
    {
      v5 = 0;
    }
    os_unfair_lock_unlock(v10);
    v18 = *a2;
    v19 = (os_unfair_lock_s *)((char *)v18 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)v18 + 24);
    v20 = *((_QWORD *)v18 + 10);
    if (v20
      && (os_unfair_lock_lock((os_unfair_lock_t)(v20 + 72)),
          v21 = *(unsigned __int8 *)(v20 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v20 + 72)),
          v21 == 1))
    {
      v14 = *(id *)(v20 + 24);
    }
    else
    {
      v14 = 0;
    }
    os_unfair_lock_unlock(v19);
    if ((v5 != 0) != (v14 == 0))
    {
      objc_msgSend(v5, "identifier");
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "identifier");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      v9 = objc_msgSend(v22, "compare:", v23) == 0;

      goto LABEL_30;
    }
    goto LABEL_29;
  }
  if (!*((_QWORD *)this + 1))
    return 0;
  if (!*((_QWORD *)*a2 + 1))
    return 0;
  ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
  if (ObjectIdentifier != TFSInfo::GetObjectIdentifier(*a2))
    return 0;
  VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
  if (VolumeIdentifier != TFSInfo::GetVolumeIdentifier(*a2))
    return 0;
  TFSInfo::Name(this, &v26);
  TFSInfo::Name(*a2, &v25);
  v9 = CFEqual(v26.fString.fRef, v25.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v25.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v26.fString.fRef);
  if ((_DWORD)v9)
  {
    IsSymlink = TFSInfo::IsSymlink(this);
    return IsSymlink ^ TFSInfo::IsSymlink(*a2) ^ 1;
  }
  return v9;
}

void sub_1CBC5D660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsNetworkScheme(TFSInfo *this, const TString *a2)
{
  unsigned __int8 v3;
  unsigned __int8 v4;
  TString *v6;
  TString *v7;

  if ((v3 & 1) == 0
  {
    v6 = (TString *)operator new();
    TString::TString(v6, "nwnode");
    TFSInfo::IsNetworkScheme(TString const&)::networkScheme = (uint64_t)v6;
  }
  if ((v4 & 1) == 0
  {
    v7 = (TString *)operator new();
    TString::TString(v7, "SFNode");
    TFSInfo::IsNetworkScheme(TString const&)::altNetworkScheme = (uint64_t)v7;
  }
  return CFEqual(*(CFTypeRef *)this, *(CFTypeRef *)TFSInfo::IsNetworkScheme(TString const&)::networkScheme)
      || CFEqual(*(CFTypeRef *)this, *(CFTypeRef *)TFSInfo::IsNetworkScheme(TString const&)::altNetworkScheme) != 0;
}

void sub_1CBC5D7F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t NodeEventGetNextEvent(_QWORD *a1, unint64_t a2)
{
  unsigned __int8 v4;
  TDSNotifier *v5;
  TNodeEvent *v6;
  char v7;
  int v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  id v13;
  TDSNotifier *v14;
  id v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  TBlockingEventQueue::EventQueueFromID(a2, &v16);
  v4 = 0;
  if (a1 && a2 && v16)
  {
    v4 = 0;
    while (1)
    {
      TNodeEventPtr::TNodeEventPtr((TNodeEventPtr *)&v15, 0);
      TBlockingQueue<TNodeEventPtr>::Dequeue(v16, &v15, 0);
      if (!TNodeEventPtr::operator->(&v15))
        break;
      v5 = *(TDSNotifier **)(TNodeEventPtr::operator->(&v15) + 64);
      v14 = v5;
      if (v5)
        TDSNotifier::AddPtrReference(v5);
      v6 = (TNodeEvent *)TNodeEventPtr::operator->(&v15);
      if (TNodeEvent::GetMonitor(v6) || !v14 || (v8 = atomic_load((unsigned int *)v14 + 10), v8 > 0))
      {
        v13 = v15;
        NodeEventRefFromNodeEvent(&v13);
        *a1 = (id)objc_claimAutoreleasedReturnValue();
        TNodeEventPtr::~TNodeEventPtr(&v13);
        v7 = 0;
        v4 = 1;
      }
      else
      {
        TDSNotifier::RemovePtrReference(v14);
        v14 = 0;
        v7 = 1;
      }
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v14);
      TNodeEventPtr::~TNodeEventPtr(&v15);
      if ((v7 & 1) == 0)
        goto LABEL_16;
    }
    TNodeEventPtr::~TNodeEventPtr(&v15);
  }
LABEL_16:
  v9 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v4;
}

void sub_1CBC5D9C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  id v3;
  va_list va;
  TDSNotifier *v5;
  va_list va1;
  id v7;
  va_list va2;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, id);
  va_copy(va2, va1);
  v5 = va_arg(va2, TDSNotifier *);
  va_copy(va3, va2);
  v7 = va_arg(va3, id);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va1);
  TNodeEventPtr::~TNodeEventPtr((id *)va2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va3);
  _Unwind_Resume(a1);
}

void TNodeEventPtr::~TNodeEventPtr(id *this)
{
  id v2;

  v2 = *this;
  *this = 0;

}

void TBlockingEventQueue::EventQueueFromID(unint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;

  EventQueueSpinLock();
  os_unfair_lock_lock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
  v10 = a1;
  v4 = (_QWORD *)EventQueues();
  if (std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>(v4, &v10))
  {
    v5 = EventQueues();
    v11 = &v10;
    v6 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v5, &v10, (uint64_t)&std::piecewise_construct, &v11);
    v7 = v6[4];
    *a2 = v6[3];
    a2[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
}

void sub_1CBC5DAE4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
  _Unwind_Resume(a1);
}

uint64_t EventQueues(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  {
    v2 = operator new();
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 1065353216;
    EventQueues(void)::map = v2;
  }
  return EventQueues(void)::map;
}

void sub_1CBC5DB78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[2];
  char v25;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = (_QWORD *)*v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = a1 + 16;
  v14 = operator new(0x28uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *v14 = 0;
  v14[1] = v7;
  v14[2] = **a4;
  v14[3] = 0;
  v14[4] = 0;
  v25 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v13;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8)
          v22 %= v8;
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  v11 = (_QWORD *)v24[0];
  v24[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return v11;
}

void sub_1CBC5DDD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void EventQueueSpinLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      EventQueueSpinLock(void)::sEventQueueSpinLock = 0;
    }
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

BOOL TBlockingQueue<TNodeEventPtr>::Dequeue(uint64_t a1, id *a2, int a3)
{
  std::mutex *v6;
  _BOOL8 v7;
  uint64_t v8;
  id v9;

  v6 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  if (!a3)
  {
LABEL_5:
    v7 = 1;
    goto LABEL_9;
  }
  if (a3 == 0x7FFFFFFF)
  {
    if (!*(_QWORD *)(a1 + 40))
      TConditionVariable::Wait((TConditionVariable *)(a1 + 112), v6);
    goto LABEL_5;
  }
  v8 = *(_QWORD *)(a1 + 40);
  if (!v8)
  {
    TConditionVariable::WaitWithTimeout((TConditionVariable *)(a1 + 112), v6, 1000 * a3);
    v8 = *(_QWORD *)(a1 + 40);
  }
  v7 = v8 != 0;
LABEL_9:
  if (*(_QWORD *)(a1 + 40))
  {
    objc_storeStrong(a2, *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + ((*(_QWORD *)(a1 + 32) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * (*(_QWORD *)(a1 + 32) & 0x1FFLL)));
    std::deque<TNodeEventPtr>::pop_front((int64x2_t *)a1);
  }
  else
  {
    v9 = *a2;
    *a2 = 0;

  }
  std::mutex::unlock(v6);
  return v7;
}

void sub_1CBC5DFC8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void TNodeEventPtr::TNodeEventPtr(TNodeEventPtr *this, FINodeEvent *a2)
{
  *(_QWORD *)this = a2;
}

uint64_t std::deque<TNodeEventPtr>::pop_front(int64x2_t *a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  void *v5;

  v2 = a1[2].u64[0];
  v3 = *(_QWORD *)(a1->i64[1] + ((v2 >> 6) & 0x3FFFFFFFFFFFFF8));
  v4 = v2 & 0x1FF;
  v5 = *(void **)(v3 + 8 * v4);
  *(_QWORD *)(v3 + 8 * v4) = 0;

  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1CBD12610);
  return std::deque<TNodeEventPtr>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t TNodeEvent::GetMonitor(TNodeEvent *this)
{
  return 0;
}

id NodeEventRefFromNodeEvent(id *a1)
{
  return *a1;
}

uint64_t TFSInfo::PersonEqual(TFSInfo *this, NSPersonNameComponents *a2, NSPersonNameComponents *a3)
{
  TFSInfo *v4;
  NSPersonNameComponents *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;

  v4 = this;
  v5 = a2;
  -[TFSInfo givenName](v4, "givenName");
  v6 = objc_claimAutoreleasedReturnValue();
  -[NSPersonNameComponents givenName](v5, "givenName");
  v7 = objc_claimAutoreleasedReturnValue();
  if (IsEqual(v6, v7))
  {
    -[TFSInfo familyName](v4, "familyName");
    v8 = objc_claimAutoreleasedReturnValue();
    -[NSPersonNameComponents familyName](v5, "familyName");
    v9 = objc_claimAutoreleasedReturnValue();
    if (IsEqual(v8, v9))
    {
      -[TFSInfo middleName](v4, "middleName");
      v10 = objc_claimAutoreleasedReturnValue();
      -[NSPersonNameComponents middleName](v5, "middleName");
      v11 = objc_claimAutoreleasedReturnValue();
      if (IsEqual(v10, v11))
      {
        -[TFSInfo namePrefix](v4, "namePrefix");
        v19 = objc_claimAutoreleasedReturnValue();
        -[NSPersonNameComponents namePrefix](v5, "namePrefix");
        v18 = objc_claimAutoreleasedReturnValue();
        if (IsEqual(v19, v18))
        {
          -[TFSInfo nameSuffix](v4, "nameSuffix");
          v17 = objc_claimAutoreleasedReturnValue();
          -[NSPersonNameComponents nameSuffix](v5, "nameSuffix");
          v16 = objc_claimAutoreleasedReturnValue();
          if (IsEqual(v17, v16))
          {
            -[TFSInfo nickname](v4, "nickname");
            v15 = objc_claimAutoreleasedReturnValue();
            -[NSPersonNameComponents nickname](v5, "nickname");
            v14 = objc_claimAutoreleasedReturnValue();
            v12 = IsEqual(v15, v14);

          }
          else
          {
            v12 = 0;
          }

        }
        else
        {
          v12 = 0;
        }

      }
      else
      {
        v12 = 0;
      }

    }
    else
    {
      v12 = 0;
    }

  }
  else
  {
    v12 = 0;
  }

  return v12;
}

void sub_1CBC5E278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void TNode::AttachFPItemsMetadata(id **a1, int a2, char a3)
{
  id *v4;
  id *v5;
  FINode *v7;
  TNode *v8;
  FPItem *v9;
  FPItem *v10;
  uint64_t v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  void **v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  TNode *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  TFSInfo *v25;
  std::__shared_weak_count *v26;
  id **v27;
  std::__shared_weak_count *v28;
  id *v29[3];
  char v30;

  memset(v29, 0, sizeof(v29));
  v4 = *a1;
  v5 = a1[1];
  if (*a1 != v5)
  {
    do
    {
      v7 = (FINode *)*v4;
      v8 = (TNode *)TNodeFromFINode(v7);
      TNode::GetFPItem(v8);
      v9 = (FPItem *)objc_claimAutoreleasedReturnValue();
      v10 = (FPItem *)v4[1];
      if (v9 != v10)
      {
        v11 = TNodeFromFINode(v7);
        v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
        os_unfair_lock_lock(v12);
        v14 = *(void ***)(v11 + 16);
        v13 = *(std::__shared_weak_count **)(v11 + 24);
        v27 = (id **)v14;
        v28 = v13;
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v16 = __ldxr(p_shared_owners);
          while (__stxr(v16 + 1, p_shared_owners));
        }
        os_unfair_lock_unlock(v12);
        TFSInfo::MarkAsUsed((TFSInfo *)&v30);
        std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo&,void>((const TFSInfo *)v14, &v25);
        TFSInfo::MarkAsUsed((TFSInfo *)&v30);
        TFSInfo::SetFPItem(v25, v10);
        v17 = (TNode *)TNodeFromFINode(v7);
        TNode::FetchAdditionalPropertiesForSync(v17, &v25, a2);
        v18 = TNodeFromFINode(v7);
        TNode::ReconcileInternalProperties(v18, &v25, (TNodeEventPtrs *)v29, a2);
        v19 = v26;
        if (v26)
        {
          v20 = (unint64_t *)&v26->__shared_owners_;
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
        v22 = v28;
        if (v28)
        {
          v23 = (unint64_t *)&v28->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
      }

      v4 += 2;
    }
    while (v4 != v5);
  }
  if ((a3 & 1) != 0)
    TNodeEventPtrs::SendNotifications(v29);
  v27 = v29;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
}

void sub_1CBC5E4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, char a13)
{
  a11 = (void **)&a13;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](&a11);
  _Unwind_Resume(a1);
}

const void **TFSInfo::SynchronizeKinds(TFSInfo *this, TFSInfo **a2, uint64_t **a3)
{
  void *v6;
  void *v7;
  const void **result;
  unsigned int v9;
  CFTypeRef cf1;
  char v11;
  CFTypeRef cf2;

  if (!*((_BYTE *)this + 112) && *((_QWORD *)this + 5))
  {
    cf2 = 0;
    TFSInfo::GetUTType(this, (id *)&cf2, 128, &v11);
    cf1 = 0;
    TFSInfo::GetUTType(*a2, (id *)&cf1, 0, &v11);
    v6 = (void *)cf1;
    v7 = (void *)cf2;
    if ((objc_msgSend((id)cf1, "isEqual:", cf2) & 1) == 0)
    {
      v9 = 1970566256;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v9, &v9);
      v9 = 1970563428;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v9, &v9);
    }

  }
  result = (const void **)TFSInfo::KindWithoutPlatformFetched(this);
  if ((_DWORD)result)
  {
    cf2 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TFSInfo::GetKindWithoutPlatform(this, (TString *)&cf2, 128, &v11);
    cf1 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TFSInfo::GetKindWithoutPlatform(*a2, (TString *)&cf1, 0, &v11);
    if (!CFEqual(cf1, cf2))
    {
      v9 = 1802072172;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v9, &v9);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
  }
  return result;
}

void sub_1CBC5E6C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

BOOL TFSInfo::KindWithoutPlatformFetched(TFSInfo *this)
{
  _BOOL8 v1;
  CFStringRef theString;

  if (*((_BYTE *)this + 112))
    return 0;
  TFSInfo::LocalizedTypeDescription(this, (TString *)&theString);
  v1 = CFStringGetLength(theString) != 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v1;
}

void sub_1CBC5E770(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::FetchAdditionalPropertiesForSync(TNode *this, TFSInfo **a2, int a3)
{
  void *v5;
  _BOOL4 v6;
  TFSInfo *v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t AdditionalProperties;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  TFSInfo *v17;
  std::__shared_weak_count *v18;

  if (a3)
  {
    TNode::GetFIProvider(this);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v5 != 0;

  }
  else
  {
    v6 = 0;
  }
  v7 = *a2;
  v8 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v17 = (TFSInfo *)*((_QWORD *)this + 2);
  v18 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v8);
  AdditionalProperties = TFSInfo::FetchAdditionalProperties(v7, &v17, v6);
  v13 = v18;
  if (v18)
  {
    v14 = (unint64_t *)&v18->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  return AdditionalProperties;
}

void sub_1CBC5E860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FetchAdditionalProperties(TFSInfo *this, TFSInfo **a2, int a3)
{
  int v3;
  uint64_t v7;
  int v8;
  id v9;
  char v10;
  TFSInfo *Properties;
  const __CFURL *v12;
  const __CFArray *v13;
  void *v14;
  CFIndex Length;
  int v16;
  int v17;
  TFSInfo *v18;
  os_unfair_lock_s *v19;
  TFSInfo *v20;
  os_unfair_lock_s *v21;
  unsigned int v22;
  TFSInfo *v23;
  os_unfair_lock_s *v24;
  unsigned int v25;
  TFSInfo *v26;
  os_unfair_lock_s *v27;
  unsigned int v28;
  void *v29;
  TFSInfo *v30;
  os_unfair_lock_s *v31;
  uint64_t v32;
  int v33;
  id v34;
  CFStringRef theString;

  v3 = *((unsigned __int8 *)this + 112);
  if (v3 != 7)
  {
    if (v3 != 27)
      goto LABEL_8;
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v7 = *((_QWORD *)this + 10);
    if (v7
      && (os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72)),
          v8 = *(unsigned __int8 *)(v7 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72)),
          v8 == 1))
    {
      v9 = *(id *)(v7 + 24);
    }
    else
    {
      v9 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
    v10 = objc_msgSend(v9, "isUsingFPFS");

    if ((v10 & 1) == 0)
    {
LABEL_8:
      Properties = (TFSInfo *)TFSInfo::FetchProperties(this, 1);
      v12 = (const __CFURL *)*((_QWORD *)this + 1);
      if (v12)
      {
        v13 = (const __CFArray *)TFSInfo::IterationFullSetOfPropertyKeys(Properties);
        theString = (CFStringRef)CFURLCopyResourcePropertiesForKeys(v12, v13, 0);
        TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&theString);
      }
      TFSInfo::GetUTType(this);
      v14 = (void *)objc_claimAutoreleasedReturnValue();

      TFSInfo::LocalizedTypeDescription(this, (TString *)&theString);
      Length = CFStringGetLength(theString);
      v16 = v14 != 0;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (Length)
        v17 = ((v16 & 1) << 9) | 2;
      else
        v17 = v16 << 9;
      v18 = *a2;
      v19 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v19);
      LODWORD(v18) = *(_DWORD *)((char *)v18 + 115);
      os_unfair_lock_unlock(v19);
      v20 = *a2;
      v21 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v21);
      LOWORD(v20) = *(_WORD *)((char *)v20 + 119);
      os_unfair_lock_unlock(v21);
      v22 = (v18 >> 27) & 4 | v17 | v20 & 0x20;
      v23 = *a2;
      v24 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v24);
      LODWORD(v20) = *(_DWORD *)((char *)v23 + 115);
      os_unfair_lock_unlock(v24);
      if ((v20 & 0x80000000) != 0)
      {
        os_unfair_lock_lock(v24);
        v25 = *(_DWORD *)((char *)v23 + 115);
        os_unfair_lock_unlock(v24);
        v22 |= (v25 >> 1) & 0x10;
      }
      v26 = *a2;
      v27 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v27);
      LODWORD(v26) = *(unsigned __int16 *)((char *)v26 + 119);
      os_unfair_lock_unlock(v27);
      v28 = (v26 >> 3) & 0x80 | v22;
      if ((int)TFSInfo::GetBladeRunnerFlags(*a2) >= 0)
        v28 |= 0x100u;
      if (a3)
      {
        TFSInfo::GetFPItem(*a2);
        v29 = (void *)objc_claimAutoreleasedReturnValue();
        if (v29)
        {

LABEL_25:
          v28 |= 0x800u;
LABEL_27:
          TFSInfo::Fetch(this, a2, v28);
          return 0;
        }
        v30 = *a2;
        v31 = (os_unfair_lock_s *)((char *)*a2 + 96);
        os_unfair_lock_lock(v31);
        v32 = *((_QWORD *)v30 + 10);
        if (v32
          && (os_unfair_lock_lock((os_unfair_lock_t)(v32 + 72)),
              v33 = *(unsigned __int8 *)(v32 + 76),
              os_unfair_lock_unlock((os_unfair_lock_t)(v32 + 72)),
              v33 == 1))
        {
          v34 = *(id *)(v32 + 24);
        }
        else
        {
          v34 = 0;
        }
        os_unfair_lock_unlock(v31);

        if (v34)
          goto LABEL_25;
      }
      if (v28)
        goto LABEL_27;
    }
  }
  return 0;
}

void sub_1CBC5EB14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TFSInfo::LocalizedTypeDescription(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 6));
  os_unfair_lock_unlock(v4);
}

void sub_1CBC5EB88(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TFSInfo::IterationFullSetOfPropertyKeys(TFSInfo *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    TFSInfo::IterationFullSetOfPropertyKeys(void)::fullSetOfPropertyKeys = TFSInfo::IterationFullSetOfPropertyKeys(void)::$_0::operator()();
  }
  return TFSInfo::IterationFullSetOfPropertyKeys(void)::fullSetOfPropertyKeys;
}

void sub_1CBC5EC34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL TNode::ReconcileInternalProperties(uint64_t a1, TFSInfo **a2, TNodeEventPtrs *a3, int a4)
{
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  TFSInfo *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  int v13;
  TNode *v14;
  os_unfair_lock_s *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  os_unfair_lock_s *v20;
  int v21;
  unint64_t *v22;
  unint64_t v23;
  TFSInfo *v24;
  os_unfair_lock_s *v25;
  TGlobalNodes *v26;
  uint64_t v27;
  const TNode *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  TNode *v32;
  os_unfair_lock_s *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  int v38;
  TGlobalNodes *v39;
  unint64_t *v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD **v43;
  _QWORD *v44;
  _QWORD **v45;
  unsigned int v46;
  uint64_t v47;
  os_unfair_lock_s *v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  os_unfair_lock_s *v53;
  int v54;
  TNode *NotifierList;
  unint64_t *v56;
  unint64_t v57;
  os_unfair_lock_s *v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  int v63;
  unint64_t v64;
  _BOOL8 v65;
  _QWORD *v66;
  _QWORD **v67;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD **v70;
  unsigned int v71;
  _QWORD **v72;
  _QWORD *v73;
  _QWORD **v74;
  unsigned int v75;
  _QWORD *v76;
  _QWORD *v77;
  int v78;
  os_unfair_lock_s *v79;
  _QWORD *v80;
  _QWORD **v81;
  _QWORD *v82;
  _QWORD **v83;
  unsigned int v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  os_unfair_lock_s *v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  unint64_t *v91;
  unint64_t v92;
  int v93;
  unint64_t v94;
  _QWORD *v95;
  _QWORD **v96;
  _QWORD *v97;
  _QWORD **v98;
  unsigned int v99;
  _QWORD *v100;
  TFSInfo *v101;
  os_unfair_lock_s *v102;
  TFSInfo *v103;
  os_unfair_lock_s *v104;
  char *buffer;
  unint64_t *v106;
  unint64_t v107;
  _QWORD *v108;
  _QWORD **v109;
  _QWORD *v110;
  _QWORD **v111;
  unsigned int v112;
  _QWORD *v113;
  void *v114;
  TNode *v115;
  os_unfair_lock_s *v116;
  std::__shared_weak_count *v117;
  uint64_t v118;
  unint64_t *v119;
  unint64_t v120;
  int v121;
  unint64_t v122;
  TFSInfo *v123;
  os_unfair_lock_s *v124;
  unsigned int v125;
  uint64_t v126;
  void *v127;
  uint64_t v128;
  _QWORD *v129;
  _QWORD **v130;
  _QWORD *v131;
  _QWORD **v132;
  unsigned int v133;
  _QWORD *v134;
  TNode *v135;
  _QWORD *v136;
  _QWORD **v137;
  _QWORD *v138;
  _QWORD *v139;
  _QWORD **v140;
  unsigned int v141;
  _QWORD **v142;
  _QWORD *v143;
  _QWORD *v144;
  _QWORD **v145;
  unsigned int v146;
  _QWORD **v147;
  _QWORD *v148;
  _QWORD **v149;
  unsigned int v150;
  _QWORD *v151;
  _QWORD *v152;
  TNode *v153;
  FINode **i;
  char *v155;
  const TNode *v156;
  _QWORD *v157;
  _QWORD **v158;
  _QWORD *v159;
  _QWORD **v160;
  unsigned int v161;
  std::__shared_weak_count *v162;
  unint64_t *v163;
  unint64_t v164;
  FINode *v166;
  TFSInfo *v167;
  std::__shared_weak_count *v168;
  _QWORD **v169;
  _QWORD *v170[2];
  TPropertyValue v171;
  TNodePtr v172;

  v170[0] = 0;
  v170[1] = 0;
  v169 = v170;
  v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v8);
  v10 = *(TFSInfo **)(a1 + 16);
  v9 = *(std::__shared_weak_count **)(a1 + 24);
  v167 = v10;
  v168 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v8);
  v13 = TFSInfo::SynchronizeProperties(v10, a2, (uint64_t)&v169);
  TNodePtr::TNodePtr((TNodePtr *)&v171, (const TNode *)a1);
  TNodeEventPtrs::AddPropertyChanges(a3, (TNodePtr *)&v171, &v169);

  if (v13)
  {
    v15 = (os_unfair_lock_s *)TNode::InfoLock(v14);
    os_unfair_lock_lock(v15);
    v17 = *(_QWORD *)(a1 + 16);
    v16 = *(std::__shared_weak_count **)(a1 + 24);
    if (v16)
    {
      v18 = (unint64_t *)&v16->__shared_owners_;
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
    os_unfair_lock_unlock(v15);
    v20 = (os_unfair_lock_s *)(v17 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
    v21 = *(_DWORD *)(v17 + 115);
    os_unfair_lock_unlock(v20);
    if (!v16)
      goto LABEL_12;
    v22 = (unint64_t *)&v16->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
      if ((v21 & 0x100) == 0)
        goto LABEL_22;
    }
    else
    {
LABEL_12:
      if ((v21 & 0x100) == 0)
        goto LABEL_22;
    }
    v24 = *a2;
    v25 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v25);
    LODWORD(v24) = *(_DWORD *)((char *)v24 + 115);
    os_unfair_lock_unlock(v25);
    if (((unsigned __int16)v24 & 0x100) == 0)
    {
      TGlobalNodes::RootNode((uint64_t *)&v172, v26);
      TNode::StPopulating::StPopulating((TNode::StPopulating *)&v171, &v172, 0);
      v27 = TNodeFromFINode(v172.fFINode);
      TNodePtr::TNodePtr((TNodePtr *)&v166, (const TNode *)a1);
      LODWORD(v27) = TChildrenList::RemoveChild(*(TChildrenList **)(v27 + 56), (const TNodePtr *)&v166);

      if ((_DWORD)v27)
      {
        v28 = (const TNode *)TNodeFromFINode(v172.fFINode);
        TNodePtr::TNodePtr((TNodePtr *)&v166, (const TNode *)a1);
        TNode::SendNotification(v28, 4, (id *)&v166, 0, 0);

      }
      TNode::StPopulating::~StPopulating((FINode **)&v171);

    }
LABEL_22:
    if (!*((_BYTE *)*a2 + 112) && !TFSInfo::FileSystemObjectExists(*a2))
    {
      v65 = 0;
      goto LABEL_208;
    }
    TNode::SetFSInfo(a1, (uint64_t *)a2, a4);
    v33 = (os_unfair_lock_s *)TNode::InfoLock(v32);
    os_unfair_lock_lock(v33);
    v35 = *(_QWORD *)(a1 + 16);
    v34 = *(std::__shared_weak_count **)(a1 + 24);
    if (v34)
    {
      v36 = (unint64_t *)&v34->__shared_owners_;
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
    }
    os_unfair_lock_unlock(v33);
    os_unfair_lock_lock((os_unfair_lock_t)(v35 + 100));
    v38 = *(_DWORD *)(v35 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(v35 + 100));
    if (v34)
    {
      v40 = (unint64_t *)&v34->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    if ((v38 & 0x100) != 0)
    {
      v42 = v170[0];
      if (v170[0])
      {
        v43 = v170;
        do
        {
          v44 = v42;
          v45 = v43;
          v46 = *((_DWORD *)v42 + 7);
          if (v46 >= 0x706E616D)
            v43 = (_QWORD **)v42;
          else
            ++v42;
          v42 = (_QWORD *)*v42;
        }
        while (v42);
        if (v43 != v170)
        {
          if (v46 < 0x706E616D)
            v44 = v45;
          if (*((_DWORD *)v44 + 7) < 0x706E616Eu)
          {
            TGlobalNodes::RootNode((uint64_t *)&v172, v39);
            TNode::StPopulating::StPopulating((TNode::StPopulating *)&v171, &v172, 0);
            v47 = TNodeFromFINode(v172.fFINode);
            TChildrenList::InvalidateSortOrder(*(TChildrenList **)(v47 + 56));
            TNode::StPopulating::~StPopulating((FINode **)&v171);

          }
        }
      }
    }
    v48 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v39);
    os_unfair_lock_lock(v48);
    v50 = *(_QWORD *)(a1 + 16);
    v49 = *(std::__shared_weak_count **)(a1 + 24);
    if (v49)
    {
      v51 = (unint64_t *)&v49->__shared_owners_;
      do
        v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }
    os_unfair_lock_unlock(v48);
    v53 = (os_unfair_lock_s *)(v50 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v50 + 100));
    v54 = *(_DWORD *)(v50 + 115);
    os_unfair_lock_unlock(v53);
    if (!v49)
      goto LABEL_51;
    v56 = (unint64_t *)&v49->__shared_owners_;
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
      if ((v54 & 0x20) == 0)
        goto LABEL_87;
    }
    else
    {
LABEL_51:
      if ((v54 & 0x20) == 0)
        goto LABEL_87;
    }
    v58 = (os_unfair_lock_s *)TNode::InfoLock(NotifierList);
    os_unfair_lock_lock(v58);
    v60 = *(_QWORD *)(a1 + 16);
    v59 = *(std::__shared_weak_count **)(a1 + 24);
    if (v59)
    {
      v61 = (unint64_t *)&v59->__shared_owners_;
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
      os_unfair_lock_unlock(v58);
      v63 = *(unsigned __int8 *)(v60 + 112);
      do
        v64 = __ldaxr(v61);
      while (__stlxr(v64 - 1, v61));
      if (!v64)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
      if (v63)
        goto LABEL_87;
    }
    else
    {
      os_unfair_lock_unlock(v58);
      if (*(_BYTE *)(v60 + 112))
        goto LABEL_87;
    }
    v66 = v170[0];
    if (v170[0])
    {
      v67 = v170;
      v68 = v170[0];
      do
      {
        v69 = v68;
        v70 = v67;
        v71 = *((_DWORD *)v68 + 7);
        if (v71 >= 0x6F626A64)
          v67 = (_QWORD **)v68;
        else
          ++v68;
        v68 = (_QWORD *)*v68;
      }
      while (v68);
      if (v67 == v170)
      {
        v72 = v170;
      }
      else
      {
        if (v71 < 0x6F626A64)
          v69 = v70;
        v72 = v170;
        if (*((_DWORD *)v69 + 7) < 0x6F626A65u)
        {
          TNode::HandleListeners((TNode *)a1, 256);
          TNode::HandleRecursiveListeners((TNode *)a1);
          goto LABEL_87;
        }
      }
      do
      {
        v73 = v66;
        v74 = v72;
        v75 = *((_DWORD *)v66 + 7);
        v76 = v66 + 1;
        if (v75 >= 0x706E616D)
        {
          v76 = v73;
          v72 = (_QWORD **)v73;
        }
        v66 = (_QWORD *)*v76;
      }
      while (v66);
      if (v72 != v170)
      {
        v77 = v75 >= 0x706E616D ? v73 : v74;
        if (*((_DWORD *)v77 + 7) < 0x706E616Eu)
        {
          NotifierList = (TNode *)TNode::GetNotifierList((TNode *)a1);
          v78 = atomic_load((unsigned int *)NotifierList);
          if (v78 >= 1)
            TNode::HandleListeners((TNode *)a1, 0);
        }
      }
    }
LABEL_87:
    v79 = (os_unfair_lock_s *)TNode::ParentLock(NotifierList);
    os_unfair_lock_lock(v79);
    TNodePtr::TNodePtr(&v172, *(const TNode **)(a1 + 48));
    os_unfair_lock_unlock(v79);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)&v171, &v172, 0);
    v80 = v170[0];
    if (v170[0])
    {
      v81 = v170;
      do
      {
        v82 = v80;
        v83 = v81;
        v84 = *((_DWORD *)v80 + 7);
        v85 = v80 + 1;
        if (v84 >= 0x706E616D)
        {
          v85 = v82;
          v81 = (_QWORD **)v82;
        }
        v80 = (_QWORD *)*v85;
      }
      while (v80);
      if (v81 != v170)
      {
        if (v84 < 0x706E616D)
          v82 = v83;
        if (*((_DWORD *)v82 + 7) < 0x706E616Eu)
        {
          if (*((_BYTE *)v167 + 112) == 21)
            goto LABEL_97;
          if (TNodeFromFINode(v172.fFINode))
          {
            v87 = TNodeFromFINode(v172.fFINode);
            v88 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v87);
            os_unfair_lock_lock(v88);
            v90 = *(_QWORD *)(v87 + 16);
            v89 = *(std::__shared_weak_count **)(v87 + 24);
            if (v89)
            {
              v91 = (unint64_t *)&v89->__shared_owners_;
              do
                v92 = __ldxr(v91);
              while (__stxr(v92 + 1, v91));
              os_unfair_lock_unlock(v88);
              v93 = *(unsigned __int8 *)(v90 + 112);
              do
                v94 = __ldaxr(v91);
              while (__stlxr(v94 - 1, v91));
              if (!v94)
              {
                ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
                std::__shared_weak_count::__release_weak(v89);
              }
            }
            else
            {
              os_unfair_lock_unlock(v88);
              v93 = *(unsigned __int8 *)(v90 + 112);
            }
            if (!v93)
            {
LABEL_97:
              v86 = TNodeFromFINode(v172.fFINode);
              TChildrenList::InvalidateSortOrder(*(TChildrenList **)(v86 + 56));
            }
          }
        }
      }
    }
    TNode::StPopulating::~StPopulating((FINode **)&v171);

    v95 = v170[0];
    if (v170[0])
    {
      v96 = v170;
      do
      {
        v97 = v95;
        v98 = v96;
        v99 = *((_DWORD *)v95 + 7);
        v100 = v95 + 1;
        if (v99 >= 0x6D6F6464)
        {
          v100 = v97;
          v96 = (_QWORD **)v97;
        }
        v95 = (_QWORD *)*v100;
      }
      while (v95);
      if (v96 != v170)
      {
        if (v99 < 0x6D6F6464)
          v97 = v98;
        if (*((_DWORD *)v97 + 7) < 0x6D6F6465u)
        {
          v101 = v167;
          v102 = (os_unfair_lock_s *)((char *)v167 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)v167 + 25);
          LODWORD(v101) = *(_DWORD *)((char *)v101 + 115);
          os_unfair_lock_unlock(v102);
          if ((v101 & 0x40) != 0)
          {
            TNode::ClearAliasTarget((TNode *)a1, 1);
            v103 = *a2;
            v104 = (os_unfair_lock_s *)((char *)*a2 + 100);
            os_unfair_lock_lock(v104);
            LODWORD(v103) = *(_DWORD *)((char *)v103 + 115);
            os_unfair_lock_unlock(v104);
            if ((v103 & 0x40) != 0)
            {
              v171.fData.__impl_.__data = 0uLL;
              TNodeRequest::Make((uint64_t)&v171, (uint64_t *)&v172);
              buffer = v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
              if (v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
              {
                v106 = (unint64_t *)(v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                                          + 8);
                do
                  v107 = __ldaxr(v106);
                while (__stlxr(v107 - 1, v106));
                if (!v107)
                {
                  (*(void (**)(char *))(*(_QWORD *)buffer + 16))(buffer);
                  std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buffer);
                }
              }
              LODWORD(v166) = 8;
              v171.fData.__impl_.__index = 0;
              std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v171, &v166);
              TNode::RequestTask(a1, 10, 1920167792, &v171, (uint64_t *)&v172, 0);
              TPropertyValue::~TPropertyValue(&v171);
              TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef((TNodeRequest **)&v172);
            }
          }
        }
      }
      v108 = v170[0];
      if (v170[0])
      {
        v109 = v170;
        do
        {
          v110 = v108;
          v111 = v109;
          v112 = *((_DWORD *)v108 + 7);
          v113 = v108 + 1;
          if (v112 >= 0x6F726967)
          {
            v113 = v110;
            v109 = (_QWORD **)v110;
          }
          v108 = (_QWORD *)*v113;
        }
        while (v108);
        if (v109 != v170)
        {
          if (v112 < 0x6F726967)
            v110 = v111;
          if (*((_DWORD *)v110 + 7) < 0x6F726968u)
          {
            TFSInfo::OriginatorInfo(*a2);
            v114 = (void *)objc_claimAutoreleasedReturnValue();

            if (!v114)
            {
              v116 = (os_unfair_lock_s *)TNode::InfoLock(v115);
              os_unfair_lock_lock(v116);
              v118 = *(_QWORD *)(a1 + 16);
              v117 = *(std::__shared_weak_count **)(a1 + 24);
              if (v117)
              {
                v119 = (unint64_t *)&v117->__shared_owners_;
                do
                  v120 = __ldxr(v119);
                while (__stxr(v120 + 1, v119));
                os_unfair_lock_unlock(v116);
                v121 = *(unsigned __int8 *)(v118 + 112);
                do
                  v122 = __ldaxr(v119);
                while (__stlxr(v122 - 1, v119));
                if (!v122)
                {
                  ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
                  std::__shared_weak_count::__release_weak(v117);
                }
              }
              else
              {
                os_unfair_lock_unlock(v116);
                v121 = *(unsigned __int8 *)(v118 + 112);
              }
              if (v121 == 7)
              {
                v123 = *a2;
                v124 = (os_unfair_lock_s *)((char *)*a2 + 100);
                os_unfair_lock_lock(v124);
                v125 = *(_DWORD *)((char *)v123 + 115);
                v123 = (TFSInfo *)((char *)v123 + 115);
                v126 = *((unsigned __int16 *)v123 + 2);
                *(_DWORD *)v123 = v125;
                *((_WORD *)v123 + 2) = ((v125 | (unint64_t)(v126 << 32)) & 0xFFFFDFFFFFFFFFFFLL) >> 32;
                os_unfair_lock_unlock(v124);
              }
              TFSInfo::OriginatorInfo(v167);
              v127 = (void *)objc_claimAutoreleasedReturnValue();
              TFSInfo::SetTemporaryOriginatorInfo((uint64_t)*a2, v127);

            }
          }
        }
      }
    }
    if (TNode::VirtualType((TNode *)a1) != 27)
      goto LABEL_196;
    TNode::GetFIProvider((TNode *)a1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v29, "domain");
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v29, "isUsingFPFS"))
    {
      TNode::UpdateOnDiskProviderRoot((TNode *)a1);
    }
    else
    {
      TNode::ProviderNodeForProviderDomain(v29, 0, (void **)&v166);
      if (TNodeFromFINode(v166))
      {
        v128 = TNodeFromFINode(v166);
        TNode::HandleSync(v128, 0x88000u);
        v129 = v170[0];
        if (v170[0])
        {
          v130 = v170;
          do
          {
            v131 = v129;
            v132 = v130;
            v133 = *((_DWORD *)v129 + 7);
            v134 = v129 + 1;
            if (v133 >= 0x66706175)
            {
              v134 = v131;
              v130 = (_QWORD **)v131;
            }
            v129 = (_QWORD *)*v134;
          }
          while (v129);
          if (v130 != v170)
          {
            if (v133 < 0x66706175)
              v131 = v132;
            if (*((_DWORD *)v131 + 7) < 0x66706176u && (objc_msgSend(v31, "needsAuthentication") & 1) == 0)
            {
              v135 = (TNode *)TNodeFromFINode(v166);
              TNode::RecursiveSyncOfObserveNodes(v135);
            }
          }
          v136 = v170[0];
          if (v170[0])
          {
            v137 = v170;
            v138 = v170[0];
            do
            {
              v139 = v138;
              v140 = v137;
              v141 = *((_DWORD *)v138 + 7);
              if (v141 >= 0x6E746373)
                v137 = (_QWORD **)v138;
              else
                ++v138;
              v138 = (_QWORD *)*v138;
            }
            while (v138);
            if (v137 != v170)
            {
              if (v141 < 0x6E746373)
                v139 = v140;
              if (*((_DWORD *)v139 + 7) < 0x6E746374u)
                goto LABEL_189;
            }
            v142 = v170;
            v143 = v170[0];
            do
            {
              v144 = v143;
              v145 = v142;
              v146 = *((_DWORD *)v143 + 7);
              if (v146 >= 0x66706175)
                v142 = (_QWORD **)v143;
              else
                ++v143;
              v143 = (_QWORD *)*v143;
            }
            while (v143);
            if (v142 != v170)
            {
              if (v146 < 0x66706175)
                v144 = v145;
              if (*((_DWORD *)v144 + 7) < 0x66706176u)
                goto LABEL_189;
            }
            v147 = v170;
            do
            {
              v148 = v136;
              v149 = v147;
              v150 = *((_DWORD *)v136 + 7);
              v151 = v136 + 1;
              if (v150 >= 0x7046726D)
              {
                v151 = v148;
                v147 = (_QWORD **)v148;
              }
              v136 = (_QWORD *)*v151;
            }
            while (v136);
            if (v147 != v170)
            {
              v152 = v150 >= 0x7046726D ? v148 : v149;
              if (*((_DWORD *)v152 + 7) < 0x7046726Eu)
              {
LABEL_189:
                v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 1853121395;
                std::__tree<Property>::__erase_unique<Property>((uint64_t)&v169, (unsigned int *)&v171);
                v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 1883665005;
                std::__tree<Property>::__erase_unique<Property>((uint64_t)&v169, (unsigned int *)&v171);
                v153 = (TNode *)TNodeFromFINode(v166);
                TNode::RecursiveChildrenAndSelf(v153, 1, &v171);
                v155 = v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
                for (i = (FINode **)v171.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
                      i != (FINode **)v155;
                      ++i)
                {
                  v156 = (const TNode *)TNodeFromFINode(*i);
                  TNode::SendNotification(v156, 2, (id *)i, 1969385844, 0);
                }
                v172.fFINode = (FINode *)&v171;
                std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v172);
              }
            }
          }
        }
      }

    }
    goto LABEL_194;
  }
  TFSInfo::GetFPItem(*a2);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (v29)
  {
    TFSInfo::GetFPItem(v10);
    v30 = objc_claimAutoreleasedReturnValue();
    v31 = (void *)v30;
    if (v30 && (void *)v30 != v29)
      TFSInfo::SetFPItem(v10, (FPItem *)v29);
LABEL_194:

  }
LABEL_196:
  v157 = v170[0];
  if (!v170[0])
    goto LABEL_206;
  v158 = v170;
  do
  {
    v159 = v157;
    v160 = v158;
    v161 = *((_DWORD *)v157 + 7);
    if (v161 >= 0x6F626A64)
      v158 = (_QWORD **)v157;
    else
      ++v157;
    v157 = (_QWORD *)*v157;
  }
  while (v157);
  if (v158 == v170)
    goto LABEL_206;
  if (v161 < 0x6F626A64)
    v159 = v160;
  if (*((_DWORD *)v159 + 7) > 0x6F626A64u)
LABEL_206:
    v158 = v170;
  v65 = v158 != v170;
LABEL_208:
  v162 = v168;
  if (v168)
  {
    v163 = (unint64_t *)&v168->__shared_owners_;
    do
      v164 = __ldaxr(v163);
    while (__stlxr(v164 - 1, v163));
    if (!v164)
    {
      ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
      std::__shared_weak_count::__release_weak(v162);
    }
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&v169, v170[0]);
  return v65;
}

void sub_1CBC5F898(_Unwind_Exception *a1, char a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, TPropertyValue *a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, _QWORD *a13)
{
  void *v13;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void TNodeEventPtrs::AddPropertyChanges(TNodeEventPtrs *a1, TNodePtr *a2, _QWORD *a3)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  id v10;

  v3 = a3 + 1;
  v4 = (_QWORD *)*a3;
  if ((_QWORD *)*a3 != a3 + 1)
  {
    do
    {
      TNodeEvent::CreateNodeEvent(2, (id *)&a2->fFINode, *((_DWORD *)v4 + 7), &v10);
      TNodeEventPtrs::AddEvent(a1, a2, &v10);

      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != v3);
  }
}

void sub_1CBC5FAB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNodeEventPtrs::AddEvent(TNodeEventPtrs *this, const TNodePtr *a2, id *a3)
{
  unint64_t v5;
  uint64_t v6;
  id v7;
  FINode *v8;
  id v9;

  v8 = a2->fFINode;
  v9 = *a3;
  v5 = *((_QWORD *)this + 1);
  if (v5 >= *((_QWORD *)this + 2))
  {
    v6 = std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__push_back_slow_path<std::pair<TNodePtr,TNodeEventPtr>>((uint64_t *)this, (id *)&v8);
  }
  else
  {
    TNodePtr::TNodePtr(*((_QWORD **)this + 1), (id *)&v8);
    *(_QWORD *)(v5 + 8) = v9;
    v6 = v5 + 16;
  }
  *((_QWORD *)this + 1) = v6;
  v7 = v9;
  v9 = 0;

}

void sub_1CBC5FB5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  std::pair<TNodePtr,TNodeEventPtr>::~pair(&a9);
  _Unwind_Resume(a1);
}

void TNode::StPopulating::~StPopulating(FINode **this)
{
  uint64_t v2;

  if (TNodeFromFINode(*this) && !this[1] && *(_QWORD *)(TNodeFromFINode(*this) + 56))
  {
    v2 = TNodeFromFINode(*this);
    TChildrenList::Unlock(*(TChildrenList **)(v2 + 56));
  }

}

TNode::StPopulating *TNode::StPopulating::StPopulating(TNode::StPopulating *this, const TNodePtr *a2, TNode::StPopulating *a3)
{
  FINode *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = a2->fFINode;
  *(_QWORD *)this = v5;
  *((_QWORD *)this + 1) = a3;
  v6 = TNodeFromFINode(v5);
  if (!a3 && v6 && *(_QWORD *)(TNodeFromFINode(*(FINode **)this) + 56))
  {
    v7 = TNodeFromFINode(*(FINode **)this);
    TChildrenList::Lock(*(TChildrenList **)(v7 + 56));
    v8 = TNodeFromFINode(*(FINode **)this);
    *((_DWORD *)this + 4) = TChildrenList::GenerationCount(*(TChildrenList **)(v8 + 56));
  }
  return this;
}

void sub_1CBC5FC44(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t TChildrenList::GenerationCount(TChildrenList *this)
{
  return *((unsigned int *)this + 46);
}

void TFSInfo::TFSInfo(TFSInfo *this, const TFSInfo *a2)
{
  CFTypeRef *v4;
  const TFSInfoOverflow *v5;
  TFSInfoOverflow *v6;
  int v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  TString **v40;
  TString *v41;
  const void **v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  int v46;
  unint64_t v47;
  int v48;
  unint64_t v49;
  int v50;
  unint64_t v51;
  int v52;
  unint64_t v53;
  int v54;
  unint64_t v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;

  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v4 = (CFTypeRef *)((char *)this + 16);
  TFSInfo::TFSInfo(this);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 24);
  *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v4, *((CFTypeRef *)a2 + 2));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this + 1, *((CFTypeRef *)a2 + 1));
  if (this == a2)
  {
    objc_storeStrong((id *)this + 5, *((id *)a2 + 5));
  }
  else
  {
    TString::SetStringRefAsImmutable((TString *)this + 3, *((TString **)a2 + 3));
    TString::SetStringRefAsImmutable((TString *)this + 4, *((TString **)a2 + 4));
    objc_storeStrong((id *)this + 5, *((id *)a2 + 5));
    TString::SetStringRefAsImmutable((TString *)this + 6, *((TString **)a2 + 6));
  }
  objc_storeStrong((id *)this + 8, *((id *)a2 + 8));
  objc_storeStrong((id *)this + 9, *((id *)a2 + 9));
  v5 = (const TFSInfoOverflow *)*((_QWORD *)a2 + 10);
  if (v5)
  {
    v6 = (TFSInfoOverflow *)operator new();
    TFSInfoOverflow::TFSInfoOverflow(v6, v5);
    std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100]((TFSInfoOverflow **)this + 10, v6);
  }
  objc_storeStrong((id *)this + 7, *((id *)a2 + 7));
  *((_BYTE *)this + 114) = *((_BYTE *)a2 + 114);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v7 = *(_DWORD *)((char *)a2 + 115) & 0x20;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v8 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFDF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFDF | v7;
  *(_WORD *)((char *)this + 119) = WORD2(v8);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v9 = *(_DWORD *)((char *)a2 + 115) & 0x400;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v10 = *(_DWORD *)((char *)this + 115) & 0xFFFFFBFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFBFF | v9;
  *(_WORD *)((char *)this + 119) = WORD2(v10);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v11 = *(_DWORD *)((char *)a2 + 115) & 0x40;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v12 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | v11;
  *(_WORD *)((char *)this + 119) = WORD2(v12);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v13 = *(_DWORD *)((char *)a2 + 115) & 2;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v14 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | v13;
  *(_WORD *)((char *)this + 119) = WORD2(v14);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v15 = *(_DWORD *)((char *)a2 + 115) & 4;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v16 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | v15;
  *(_WORD *)((char *)this + 119) = WORD2(v16);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v17 = *(_DWORD *)((char *)a2 + 115) & 0x80;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v18 = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v18);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v19 = *(unsigned int *)((char *)a2 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v20 = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | (((v19 >> 16) & 1) << 16);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | (((v19 >> 16) & 1) << 16);
  *(_DWORD *)((char *)this + 115) = v20 & 0xFFFFFFFE | *(_DWORD *)((char *)a2 + 115) & 1;
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 8;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v21 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFF7 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFF7 | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v21);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x100;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v22 = *(_DWORD *)((char *)this + 115) & 0xFFFFFEFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFEFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v22);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x200;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v23 = *(_DWORD *)((char *)this + 115) & 0xFFFFFDFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFDFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v23);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x800;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v24 = *(_DWORD *)((char *)this + 115) & 0xFFFFF7FF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFF7FF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v24);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x1000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v25 = *(_DWORD *)((char *)this + 115) & 0xFFFFEFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFEFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v25);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x2000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v26 = *(_DWORD *)((char *)this + 115) & 0xFFFFDFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFDFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v26);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x4000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v27 = *(_DWORD *)((char *)this + 115) & 0xFFFFBFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFBFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v27);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x100000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v28 = *(_DWORD *)((char *)this + 115) & 0xFFEFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFEFFFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v28);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x200000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v29 = *(_DWORD *)((char *)this + 115) & 0xFFDFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFDFFFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v29);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x400000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v30 = *(_DWORD *)((char *)this + 115) & 0xFFBFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFBFFFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v30);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x800000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v31 = *(_DWORD *)((char *)this + 115) & 0xFF7FFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFF7FFFFF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v31);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v19) = *(_DWORD *)((char *)a2 + 115) & 0x10;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v32 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v32);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v33 = (unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 11;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v34 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFF7FFFFFFFFFFLL | ((v33 & 1) << 43);
  *(_WORD *)((char *)this + 119) = WORD2(v34);
  *(_WORD *)((char *)this + 119) = (v34 & 0xFFFFEFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x100000000000) >> 32;
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v33) = *(_DWORD *)((char *)a2 + 115) & 0x8000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v35 = *(_DWORD *)((char *)this + 115) & 0xFFFF7FFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFF7FFF | v33;
  *(_WORD *)((char *)this + 119) = WORD2(v35);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v33) = *(_DWORD *)((char *)a2 + 115) & 0x1000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v36 = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | v33;
  *(_WORD *)((char *)this + 119) = WORD2(v36);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v33) = *(_DWORD *)((char *)a2 + 115) & 0x2000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v37 = *(_DWORD *)((char *)this + 115) & 0xFDFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFDFFFFFF | v33;
  *(_WORD *)((char *)this + 119) = WORD2(v37);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v38 = *(unsigned int *)((char *)a2 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v39 = *(_DWORD *)((char *)this + 115) & 0xFBFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | (((v38 >> 26) & 1) << 26);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFBFFFFFF | (((v38 >> 26) & 1) << 26);
  v40 = *(TString ***)a2;
  if (*(_QWORD *)a2)
  {
    v41 = (TString *)operator new();
    TVersionData::TVersionData(v41, v40);
    v42 = *(const void ***)this;
    *(_QWORD *)this = v41;
    if (v42)
      std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)this, v42);
    v39 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  }
  v43 = v39 & 0xFFFFFFFBFFFFFFFFLL | ((((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 2) & 1) << 34);
  *(_DWORD *)((char *)this + 115) = v39;
  *(_WORD *)((char *)this + 119) = WORD2(v43);
  v44 = v43 & 0xFFFFFF7FFFFFFFFFLL | ((((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 7) & 1) << 39);
  *(_DWORD *)((char *)this + 115) = v39;
  *(_WORD *)((char *)this + 119) = WORD2(v44);
  v45 = v44 & 0xFEFFFFFFFFFFLL | ((((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 8) & 1) << 40);
  *(_DWORD *)((char *)this + 115) = v39;
  *(_WORD *)((char *)this + 119) = WORD2(v45);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v46 = *(_DWORD *)((char *)a2 + 115) & 0x20000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v47 = *(_DWORD *)((char *)this + 115) & 0xFFFDFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFDFFFF | v46;
  *(_WORD *)((char *)this + 119) = WORD2(v47);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v48 = *(_DWORD *)((char *)a2 + 115) & 0x8000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v49 = *(_DWORD *)((char *)this + 115) & 0xF7FFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xF7FFFFFF | v48;
  *(_WORD *)((char *)this + 119) = WORD2(v49);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v50 = *(_DWORD *)((char *)a2 + 115) & 0x10000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v51 = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | v50;
  *(_WORD *)((char *)this + 119) = WORD2(v51);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v52 = *(_DWORD *)((char *)a2 + 115) & 0x20000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v53 = *(_DWORD *)((char *)this + 115) & 0xDFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xDFFFFFFF | v52;
  *(_WORD *)((char *)this + 119) = WORD2(v53);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v54 = *(_DWORD *)((char *)a2 + 115) & 0x40000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v55 = *(_DWORD *)((char *)this + 115) & 0xBFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xBFFFFFFF | v54;
  *(_WORD *)((char *)this + 119) = WORD2(v55);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v56 = *(_DWORD *)((char *)a2 + 115) & 0x80000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v57 = *(_DWORD *)((char *)this + 115) & 0x7FFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0x7FFFFFFF | v56;
  *(_WORD *)((char *)this + 119) = WORD2(v57);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v58 = (*(_WORD *)((char *)a2 + 119) & 1) << 32;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v59 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFFEFFFFFFFFLL | v58;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v59);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v60 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x200000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v61 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFFDFFFFFFFFLL | v60;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v61);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v62 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x800000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v63 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFF7FFFFFFFFLL | v62;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v63);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v64 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x1000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v65 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFEFFFFFFFFFLL | v64;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v65);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v64) = *(_DWORD *)((char *)a2 + 115) & 0x40000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v66 = *(_DWORD *)((char *)this + 115) & 0xFFFBFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFBFFFF | v64;
  *(_WORD *)((char *)this + 119) = WORD2(v66);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v64) = *(_DWORD *)((char *)a2 + 115) & 0x80000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v67 = *(_DWORD *)((char *)this + 115) & 0xFFF7FFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFF7FFFF | v64;
  *(_WORD *)((char *)this + 119) = WORD2(v67);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v68 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x2000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v69 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFDFFFFFFFFFLL | v68;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v69);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v70 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x4000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v71 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFBFFFFFFFFFLL | v70;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v71);
  *((_QWORD *)this + 13) = *((_QWORD *)a2 + 13);
  *((_BYTE *)this + 113) = *((_BYTE *)a2 + 113);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v72 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x20000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v73 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFDFFFFFFFFFFLL | v72;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v73);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  v74 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x40000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  v75 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFBFFFFFFFFFFLL | v74;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v75);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this + 11, *((CFTypeRef *)a2 + 11));
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 24);
}

void sub_1CBC60750(_Unwind_Exception *a1)
{
  TFSInfo *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;

  MEMORY[0x1D17A53D0](v3, 0x60C40902580DDLL);
  os_unfair_lock_unlock(v2);
  TFSInfo::~TFSInfo(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::Fetch(TFSInfo *this, TFSInfo **a2, int a3)
{
  __int16 v3;
  void *v6;
  id v7;
  TFSInfoOverflow *Overflow;
  uint64_t v9;
  int v10;
  uint64_t v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  TFSInfo *v15;
  os_unfair_lock_s *v16;
  uint64_t v17;
  int v18;
  FIProviderDomain *v19;
  id v20;
  uint64_t v21;
  int v22;
  char v24;
  id location;

  if (!a3)
    return 0;
  v3 = a3;
  if ((a3 & 1) != 0)
  {
    TFSInfo::FetchISIcon(this);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "symbol");
    v7 = (id)objc_claimAutoreleasedReturnValue();
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    if (v7)
    {
      Overflow = TFSInfo::GetOrCreateOverflow(this);
      TFSInfoOverflow::SetIFSymbol((uint64_t)Overflow, v7);
    }
    else
    {
      v9 = *((_QWORD *)this + 10);
      if (v9)
        TFSInfoOverflow::SetIFSymbol(v9, 0);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);

  }
  if ((v3 & 2) != 0)
  {
    location = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TFSInfo::GetKindWithoutPlatform(this, (TString *)&location, 0, &v24);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&location);
  }
  if ((v3 & 0x200) != 0)
  {
    location = 0;
    TFSInfo::GetUTType(this, &location, 0, &v24);

  }
  if ((v3 & 4) != 0)
  {
    location = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TFSInfo::GetShortVersion((uint64_t)this, (const void **)&location, 0x8000000);
    TFSInfo::GetLongVersion((uint64_t)this, (TString *)&location, 0x8000000);
    TFSInfo::GetSystemVersion((uint64_t)this, (TString *)&location, 0x8000000);
    TFSInfo::GetCopyrightString((uint64_t)this, (TString *)&location, 0x8000000);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&location);
  }
  if ((v3 & 0x20) == 0)
  {
    if ((v3 & 0x10) == 0)
      goto LABEL_16;
LABEL_27:
    TFSInfo::SetExtendedUserAccess(this);
    if ((v3 & 0x80) == 0)
      goto LABEL_18;
    goto LABEL_17;
  }
  location = (id)TFSInfo::CopyPermissions(this);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&location);
  if ((v3 & 0x10) != 0)
    goto LABEL_27;
LABEL_16:
  if ((v3 & 0x80) != 0)
  {
LABEL_17:
    location = TFSInfo::CopyTagsAndAttributes(this, 1);
    TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&location);
  }
LABEL_18:
  v10 = UseFileProviderFramework();
  if ((v3 & 0x800) != 0 && v10)
  {
    TFSInfo::GetFPItem(*a2);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (v13)
    {
      TFSInfo::GetFPItem(this);
      v14 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v14)
        TFSInfo::CopyFPItemIfNeeded((uint64_t)this, a2);
    }

    v15 = *a2;
    v16 = (os_unfair_lock_s *)((char *)v15 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)v15 + 24);
    v17 = *((_QWORD *)v15 + 10);
    if (v17
      && (os_unfair_lock_lock((os_unfair_lock_t)(v17 + 72)),
          v18 = *(unsigned __int8 *)(v17 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 72)),
          v18 == 1))
    {
      v19 = (FIProviderDomain *)*(id *)(v17 + 24);
    }
    else
    {
      v19 = 0;
    }
    os_unfair_lock_unlock(v16);
    if ((-[FIProviderDomain disconnectionState](v19, "disconnectionState") & 0xFFFFFFFFFFFFFFFELL) == 6)
    {
      TFSInfo::GetFPItem(this);
      v20 = (id)objc_claimAutoreleasedReturnValue();
      if (v20
        || ((os_unfair_lock_lock((os_unfair_lock_t)this + 24), (v21 = *((_QWORD *)this + 10)) == 0)
         || (os_unfair_lock_lock((os_unfair_lock_t)(v21 + 72)),
             v22 = *(unsigned __int8 *)(v21 + 76),
             os_unfair_lock_unlock((os_unfair_lock_t)(v21 + 72)),
             v22 != 1)
          ? (v20 = 0)
          : (v20 = *(id *)(v21 + 24)),
            os_unfair_lock_unlock((os_unfair_lock_t)this + 24),
            v20))
      {

      }
      else if (!-[FIProviderDomain asyncResultAvailable](v19, "asyncResultAvailable"))
      {
        TFSInfo::UpdateFileProvider(this, v19);
LABEL_40:

        goto LABEL_41;
      }
    }
    if (-[FIProviderDomain asyncResultAvailable](v19, "asyncResultAvailable"))
      TFSInfo::UpdateFileProvider(this, 0);
    goto LABEL_40;
  }
LABEL_41:
  if ((v3 & 0x900) != 0)
    TFSInfo::FetchBladeRunnerProperties(this, v11, v12);
  return 0;
}

void sub_1CBC60ACC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<__CFArray const*>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(*(CFTypeRef **)a1, *a2);
      return 0;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<__CFArray const*>(*(_QWORD *)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TNode::VirtualType(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    v7 = *(unsigned __int8 *)(v4 + 112);
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
    return *(unsigned __int8 *)(v4 + 112);
  }
  return v7;
}

BOOL TFSInfo::FileSystemObjectExists(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  void *v3;
  void *v4;
  _BOOL8 v5;
  const void *v7;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = (void *)*((_QWORD *)this + 2);
  v7 = v3;
  if (v3)
    CFRetain(v3);
  os_unfair_lock_unlock(v2);
  objc_msgSend(v3, "path");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "length") != 0;

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v7);
  return v5;
}

void sub_1CBC60DA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;
  os_unfair_lock_s *v11;

  v11 = v10;
  os_unfair_lock_unlock(v11);
  _Unwind_Resume(a1);
}

void TNode::SetFSInfo(uint64_t a1, uint64_t *a2, int a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  TFSInfo **v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  TFSInfo *v12;
  os_unfair_lock_s *v13;
  int v14;
  TFSInfo *v15;
  os_unfair_lock_s *v16;
  int v17;
  TFSInfo *v18;
  os_unfair_lock_s *v19;
  int v20;
  int v21;
  _BOOL4 v22;
  FPItem *v23;
  TFSInfo *v24;
  os_unfair_lock_s *v25;
  uint64_t v26;
  TFSInfo *v27;
  os_unfair_lock_s *v28;
  const void **v29;
  const void **v30;
  TFSInfo *v31;
  os_unfair_lock_s *v32;
  uint64_t v33;
  TFSInfo *v34;
  os_unfair_lock_s *v35;
  TChildrenList *v36;
  TFSInfo *v37;
  os_unfair_lock_s *v38;
  TFSInfoOverflow *Overflow;
  TFSInfo *v40;
  os_unfair_lock_s *v41;
  int v42;
  unint64_t v43;
  TFSInfo *v44;
  os_unfair_lock_s *v45;
  char *v46;
  unsigned int v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  TFSInfo *v52;
  os_unfair_lock_s *v53;
  const void **v54;
  const void **v55;
  TFSInfo *v56;
  os_unfair_lock_s *v57;
  unsigned int v58;
  uint64_t v59;
  CFIndex Length;
  const void **v61;
  uint64_t v62;
  void *v63;
  void *v64;
  int v65;
  FPItem *v66;
  CFStringRef theString;
  const void **v68;
  uint64_t v69;
  TString v70;

  v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v6);
  v8 = (TFSInfo **)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 16);
  v9 = (os_unfair_lock_s *)(v7 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 100));
  LODWORD(v7) = *(_DWORD *)(v7 + 115);
  os_unfair_lock_unlock(v9);
  if ((v7 & 0x100) != 0
    && (v10 = *a2,
        v11 = (os_unfair_lock_s *)(*a2 + 100),
        os_unfair_lock_lock(v11),
        LODWORD(v10) = *(_DWORD *)(v10 + 115),
        os_unfair_lock_unlock(v11),
        (v10 & 0x8000) != 0))
  {
    os_unfair_lock_unlock(v6);
    v23 = 0;
  }
  else
  {
    v65 = a3;
    TFSInfo::GetFPItem(*v8);
    v66 = (FPItem *)objc_claimAutoreleasedReturnValue();
    v12 = *v8;
    v13 = (os_unfair_lock_s *)((char *)*v8 + 100);
    os_unfair_lock_lock(v13);
    v14 = *(_DWORD *)((char *)v12 + 115);
    os_unfair_lock_unlock(v13);
    v15 = *v8;
    v16 = (os_unfair_lock_s *)((char *)*v8 + 100);
    os_unfair_lock_lock(v16);
    v17 = *(_DWORD *)((char *)v15 + 115);
    os_unfair_lock_unlock(v16);
    v18 = *v8;
    v19 = (os_unfair_lock_s *)((char *)*v8 + 100);
    os_unfair_lock_lock(v19);
    v20 = *(_DWORD *)((char *)v18 + 115);
    os_unfair_lock_unlock(v19);
    if ((v20 & 0x2000000) != 0)
    {
      v22 = 0;
    }
    else
    {
      os_unfair_lock_lock(v19);
      v21 = *(_DWORD *)((char *)v18 + 115);
      os_unfair_lock_unlock(v19);
      v22 = (v21 & 0x10000000) != 0 || *((unsigned __int8 *)v18 + 112) == 7;
    }
    TFSInfo::DisplayName(*v8, &v70);
    v69 = 0;
    v24 = *v8;
    v25 = (os_unfair_lock_s *)((char *)*v8 + 96);
    os_unfair_lock_lock(v25);
    v26 = *((_QWORD *)v24 + 10);
    if (v26)
      TFSInfoOverflow::TakeFolderSizeRecord(v26, &v69);
    else
      v69 = 0;
    os_unfair_lock_unlock(v25);
    v68 = 0;
    if ((v14 & 0x20000000) != 0)
    {
      v27 = *v8;
      v28 = (os_unfair_lock_s *)((char *)*v8 + 96);
      os_unfair_lock_lock(v28);
      v29 = *(const void ***)v27;
      *(_QWORD *)v27 = 0;
      v30 = v68;
      v68 = v29;
      if (v30)
        std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v68, v30);
      os_unfair_lock_unlock(v28);
    }
    v31 = *v8;
    v32 = (os_unfair_lock_s *)((char *)*v8 + 100);
    os_unfair_lock_lock(v32);
    v33 = *(unsigned __int16 *)((char *)v31 + 119);
    os_unfair_lock_unlock(v32);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 16), a2);
    v34 = *v8;
    v35 = (os_unfair_lock_s *)((char *)*v8 + 100);
    os_unfair_lock_lock(v35);
    LODWORD(v34) = *(_DWORD *)((char *)v34 + 115);
    os_unfair_lock_unlock(v35);
    if ((v34 & 0x20) != 0 && !*(_QWORD *)(a1 + 56))
    {
      v36 = (TChildrenList *)operator new();
      TChildrenList::TChildrenList(v36, (const TNode *)a1);
      std::unique_ptr<TChildrenList>::reset[abi:ne180100]((TChildrenList **)(a1 + 56), v36);
    }
    if (v69)
    {
      v37 = *v8;
      v38 = (os_unfair_lock_s *)((char *)*v8 + 96);
      os_unfair_lock_lock(v38);
      if (v69 || *((_QWORD *)v37 + 10))
      {
        Overflow = TFSInfo::GetOrCreateOverflow(v37);
        TFSInfoOverflow::SetFolderSizeRecord((uint64_t)Overflow, &v69);
      }
      os_unfair_lock_unlock(v38);
      v40 = *v8;
      v41 = (os_unfair_lock_s *)((char *)*v8 + 100);
      os_unfair_lock_lock(v41);
      v42 = *(_DWORD *)((char *)v40 + 115);
      v40 = (TFSInfo *)((char *)v40 + 115);
      v43 = v42 & 0xF7FFFFFF | ((unint64_t)*((unsigned __int16 *)v40 + 2) << 32);
      *(_DWORD *)v40 = v42 & 0xF7FFFFFF | v17 & 0x8000000;
      *((_WORD *)v40 + 2) = WORD2(v43);
      os_unfair_lock_unlock(v41);
      v44 = *v8;
      v45 = (os_unfair_lock_s *)((char *)*v8 + 100);
      os_unfair_lock_lock(v45);
      v47 = *(_DWORD *)((char *)v44 + 115);
      v46 = (char *)v44 + 115;
      v48 = v47 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32);
      v49 = 0x10000000;
      if (!v22)
        v49 = 0;
      v50 = v48 & 0xFFFFFFFFEFFFFFFFLL;
      *(_DWORD *)v46 = v50 | v49;
      *((_WORD *)v46 + 2) = WORD2(v50);
      os_unfair_lock_unlock(v45);
    }
    v51 = (v33 << 32) & 0x800000000;
    if (v68)
    {
      v52 = *v8;
      v53 = (os_unfair_lock_s *)((char *)*v8 + 96);
      os_unfair_lock_lock(v53);
      v54 = v68;
      v68 = 0;
      v55 = *(const void ***)v52;
      *(_QWORD *)v52 = v54;
      if (v55)
        std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)v52, v55);
      os_unfair_lock_unlock(v53);
    }
    v56 = *v8;
    v57 = (os_unfair_lock_s *)((char *)*v8 + 100);
    os_unfair_lock_lock(v57);
    v58 = *(_DWORD *)((char *)v56 + 115);
    v56 = (TFSInfo *)((char *)v56 + 115);
    v59 = *((unsigned __int16 *)v56 + 2);
    *(_DWORD *)v56 = v58 | v51;
    *((_WORD *)v56 + 2) = ((v58 | (unint64_t)(v59 << 32)) & 0xFFFFFFF7FFFFFFFFLL | v51) >> 32;
    os_unfair_lock_unlock(v57);
    if (*((_BYTE *)*v8 + 112) == 18)
    {
      TFSInfo::DisplayName(*v8, (TString *)&theString);
      Length = CFStringGetLength(theString);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (!Length)
        TFSInfo::SetDisplayName(*v8, &v70);
    }
    v61 = v68;
    v68 = 0;
    if (v61)
      std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v68, v61);
    v62 = v69;
    v69 = 0;
    v23 = v66;
    if (v62)
      MEMORY[0x1D17A53D0](v62, 0x1000C40E0EAB150);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v70.fString.fRef);
    os_unfair_lock_unlock(v6);
    if (v66 && v65)
    {
      TFSInfo::GetFPItem((TFSInfo *)*a2);
      v63 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v63)
      {
        TNode::GetFIProvider((TNode *)a1);
        v64 = (void *)objc_claimAutoreleasedReturnValue();

        if (v64)
          TFSInfo::SetFPItem((TFSInfo *)*a2, v66);
      }

    }
  }

}

void sub_1CBC61280(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  os_unfair_lock_s *v4;
  const void **v6;
  uint64_t v7;
  const void **v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v8 = va_arg(va1, const void **);
  v10 = va_arg(va1, _QWORD);
  v6 = v8;
  v8 = 0;
  if (v6)
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)va, v6);
  v7 = v10;
  v10 = 0;
  if (v7)
    MEMORY[0x1D17A53D0](v7, 0x1000C40E0EAB150);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);

  os_unfair_lock_unlock(v4);
  _Unwind_Resume(a1);
}

void sub_1CBC6138C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetTagsAndAttributes(uint64_t a1, uint64_t a2, uint64_t a3, char a4, _BYTE *a5)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  __CFArray *v15;
  __CFArray *v16;
  __CFArray *v17;

  v16 = TFSInfo::CopyTagsAndAttributes((TFSInfo *)a1, 0);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v9 = *(unsigned __int16 *)(a1 + 119);
  v10 = *(unsigned int *)(a1 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
  v15 = TFSInfo::CopyTagsAndAttributes((TFSInfo *)a1, (a4 & 0x82) == 0);
  v17 = v15;
  v11 = TPropertyReference::SetAs<__CFArray const*>(a2, (CFTypeRef *)&v17);
  v12 = (a4 & 0x82) != 0 && v11 == 0;
  if (v12)
    v13 = 0;
  else
    v13 = v11;
  if (v12 && ((v10 | (v9 << 32)) & 0x40000000000) == 0)
  {
    if (*(_BYTE *)(a1 + 112) == 7)
      v13 = 0;
    else
      v13 = 4294959222;
  }
  *a5 = IsEqual(v16, v15) ^ 1;
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v15);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v16);
  return v13;
}

void sub_1CBC61484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TFSInfo::SynchronizeTags(TFSInfo *a1, TFSInfo **a2, uint64_t **a3)
{
  unsigned int v6;
  __CFArray *v7;
  void *v8;

  v8 = TFSInfo::CopyTagsAndAttributes(a1, 0);
  v7 = TFSInfo::CopyTagsAndAttributes(*a2, 0);
  if ((IsEqual(v8, v7) & 1) == 0)
  {
    v6 = 1718903156;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v6, &v6);
  }
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v7);
  return TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v8);
}

void sub_1CBC61528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

__CFArray *TFSInfo::CopyTagsAndAttributes(TFSInfo *this, int a2)
{
  void *v3;
  id v4;
  os_unfair_lock_s *v5;
  const void *v6;
  CFTypeRef v7;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex i;
  TCFURLInfo *ValueAtIndex;
  const __CFData *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  __CFString *v19;
  __CFString *v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  char *v26;
  unsigned int v27;
  unint64_t v28;
  void *v30;
  void *v31;
  os_unfair_lock_s *lock;
  id v33;
  CFArrayRef theArray;
  const void *v35[17];
  id obj;
  __CFString *v37[8];
  _QWORD v38[5];
  uint64_t v39;
  uint64_t v40;
  char *v41;
  __int16 v42;
  _QWORD v43[2];
  _QWORD v44[4];

  v44[2] = *MEMORY[0x1E0C80C00];
  theArray = 0;
  if (a2)
  {
    lock = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v3 = (void *)*((_QWORD *)this + 2);
    obj = v3;
    if (v3)
    {
      CFRetain(v3);
      v4 = obj;
    }
    else
    {
      v4 = 0;
    }
    os_unfair_lock_unlock(lock);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&obj);
    if (v4)
    {
      v9 = (const __CFArray *)TFSInfo::CopyTagsForPath(this);
      theArray = v9;
    }
    else
    {
      TFSInfo::GetFPItem(this);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "tags");
      v31 = (void *)objc_claimAutoreleasedReturnValue();

      if (objc_msgSend(v31, "count") && objc_opt_class())
      {
        v30 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", objc_msgSend(v31, "count"));
        IDContainerIteratorAdaptor<NSArray<FPTag *>>::NSForwardIterator<NSArray<FPTag *>>::NSForwardIterator((uint64_t)&obj, v31);
        IDContainerIteratorAdaptor<NSArray<FPTag *>>::IDContainerIteratorAdaptor((uint64_t)v35, -1, v31);
        v33 = v30;
        while (obj != v35[0] || v41 != v35[16])
        {
          v16 = *(&v37[1]->isa + v40);
          objc_msgSend(v16, "label");
          v17 = (void *)objc_claimAutoreleasedReturnValue();
          if (objc_msgSend(v17, "length"))
          {
            v42 = objc_msgSend(v16, "color");
            objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v42, 2);
            v18 = (void *)objc_claimAutoreleasedReturnValue();
            v19 = CFSTR("TagName");
            v43[0] = v19;
            v44[0] = v17;
            v20 = CFSTR("TagColor");
            v43[1] = v20;
            v44[1] = v18;
            objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v44, v43, 2);
            v21 = objc_claimAutoreleasedReturnValue();

            v22 = v33;
            objc_msgSend(v22, "addObject:", v21);

            v16 = (void *)v21;
          }
          else
          {

          }
          v23 = v40;
          if (v40 >= v39 - 1)
          {
            v24 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v37, v38, 4);
            v23 = -1;
            v39 = v24;
            v40 = -1;
          }
          if ((void *)v38[4] != v37[2]->isa)
          {
            objc_enumerationMutation(obj);
            v23 = v40;
          }
          v40 = v23 + 1;
          ++v41;
        }

        theArray = (CFArrayRef)v33;
      }

      v9 = theArray;
    }
    v25 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this + 11, v9);
    os_unfair_lock_lock(lock);
    v27 = *(_DWORD *)((char *)this + 115);
    v26 = (char *)this + 115;
    v28 = v27 | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32) | 0x40000000000;
    *(_DWORD *)v26 = v27;
    *((_WORD *)v26 + 2) = WORD2(v28);
    os_unfair_lock_unlock(lock);
    os_unfair_lock_unlock(v25);
    os_unfair_lock_lock(lock);
    *((_WORD *)v26 + 2) |= 0x400u;
    os_unfair_lock_unlock(lock);
    v8 = theArray;
    if (!theArray)
      goto LABEL_32;
  }
  else
  {
    v5 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v6 = (const void *)*((_QWORD *)this + 11);
    if (v6)
    {
      v7 = CFRetain(v6);
      v8 = (const __CFArray *)static_cf_cast<__CFString const*,void const*>(v7);
    }
    else
    {
      v8 = 0;
    }
    os_unfair_lock_unlock(v5);
    theArray = v8;
    if (!v8)
    {
LABEL_32:
      Mutable = 0;
      goto LABEL_33;
    }
  }
  Count = CFArrayGetCount(v8);
  Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
  for (i = 0; i < CFArrayGetCount(theArray); ++i)
  {
    ValueAtIndex = (TCFURLInfo *)CFArrayGetValueAtIndex(theArray, i);
    TCFURLInfo::DecodeEncodedTagString(ValueAtIndex, (uint64_t *)&obj);
    if (obj)
    {
      v35[0] = TCFURLInfo::CreateTagDictionary((TCFURLInfo *)obj, v37[0], v14);
      CFArrayAppendValue(Mutable, v35[0]);
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef(v35);
    }

  }
LABEL_33:
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&theArray);
  return Mutable;
}

void sub_1CBC61994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, os_unfair_lock_t lock, uint64_t a13, uint64_t a14, const void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{

  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef(&a15);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void TCFURLInfo::DecodeEncodedTagString(TCFURLInfo *this@<X0>, uint64_t *a2@<X8>)
{
  void *v4;
  void *v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  __int16 v16;
  __int16 v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  __int16 v27;
  uint64_t v28;
  void *v29;
  void *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  void *__p;
  char *v36;
  char *v37;
  _BYTE v38[128];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  objc_cast<NSString,void const*>(this);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v4, "length") && !objc_msgSend(v4, "hasPrefix:", CFSTR("\n")))
  {
    objc_msgSend(v4, "componentsSeparatedByString:", CFSTR("\n"));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = objc_msgSend(v5, "count");
    objc_msgSend(v5, "firstObject");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    static_objc_cast<NSString,objc_object * {__strong}>(v7);
    v8 = objc_claimAutoreleasedReturnValue();

    if (v6 < 2)
    {
      v28 = 0;
    }
    else
    {
      objc_msgSend(v5, "objectAtIndexedSubscript:", 1);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      static_objc_cast<NSString,objc_object * {__strong}>(v9);
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v10, "componentsSeparatedByString:", CFSTR("."));
      v29 = v5;
      v30 = v4;
      __p = 0;
      v36 = 0;
      v37 = 0;
      v31 = 0u;
      v32 = 0u;
      v33 = 0u;
      v34 = 0u;
      v11 = (id)objc_claimAutoreleasedReturnValue();
      v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v31, v38, 16);
      if (v12)
      {
        v13 = *(_QWORD *)v32;
        do
        {
          for (i = 0; i != v12; ++i)
          {
            if (*(_QWORD *)v32 != v13)
              objc_enumerationMutation(v11);
            v15 = *(void **)(*((_QWORD *)&v31 + 1) + 8 * i);
            if (objc_msgSend(v15, "length"))
            {
              v16 = objc_msgSend(v15, "intValue");
              v17 = v16;
              v18 = v36;
              if (v36 >= v37)
              {
                v20 = (char *)__p;
                v21 = v36 - (_BYTE *)__p;
                if (v36 - (_BYTE *)__p <= -3)
                  std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                v22 = v21 >> 1;
                if (v37 - (_BYTE *)__p <= (unint64_t)((v21 >> 1) + 1))
                  v23 = v22 + 1;
                else
                  v23 = v37 - (_BYTE *)__p;
                if ((unint64_t)(v37 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFFELL)
                  v24 = 0x7FFFFFFFFFFFFFFFLL;
                else
                  v24 = v23;
                if (v24)
                {
                  v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)&v37, v24);
                  v20 = (char *)__p;
                  v18 = v36;
                }
                else
                {
                  v25 = 0;
                }
                v26 = &v25[2 * v22];
                *(_WORD *)v26 = v17;
                v19 = v26 + 2;
                while (v18 != v20)
                {
                  v27 = *((_WORD *)v18 - 1);
                  v18 -= 2;
                  *((_WORD *)v26 - 1) = v27;
                  v26 -= 2;
                }
                __p = v26;
                v36 = v19;
                v37 = &v25[2 * v24];
                if (v20)
                  operator delete(v20);
              }
              else
              {
                *(_WORD *)v36 = v16;
                v19 = v18 + 2;
              }
              v36 = v19;
            }
          }
          v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v31, v38, 16);
        }
        while (v12);
      }

      v5 = v29;
      v4 = v30;
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", __p, v36 - (_BYTE *)__p);
      v28 = objc_claimAutoreleasedReturnValue();
      if (__p)
      {
        v36 = (char *)__p;
        operator delete(__p);
      }

    }
    *a2 = v8;
    a2[1] = v28;

  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }

}

void sub_1CBC61DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

id objc_cast<NSString,void const*>(void *a1)
{
  objc_cast<NSString,objc_object * {__strong}>(a1);
  return (id)objc_claimAutoreleasedReturnValue();
}

id objc_cast<NSString,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

CFDictionaryRef TCFURLInfo::CreateTagDictionary(TCFURLInfo *this, const __CFString *a2, const __CFData *a3)
{
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  CFIndex v5;
  const void *v7[2];
  void *keys[2];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *(_OWORD *)keys = xmmword_1E8751A78;
    v7[0] = this;
    v7[1] = a2;
    v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v5 = 2;
  }
  else
  {
    keys[0] = CFSTR("TagName");
    v7[0] = this;
    v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v5 = 1;
  }
  return CFDictionaryCreate(0, (const void **)keys, v7, v5, v3, v4);
}

uint64_t std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

id objc_cast<NSData,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

id objc_cast<NSDictionary,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

uint64_t std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

id __copy_helper_block_ea8_32c98_ZTSKZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  id result;

  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  result = *(id *)(a2 + 64);
  *(_QWORD *)(a1 + 64) = result;
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  return result;
}

void sub_1CBC621E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC6224C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<OpaqueNodeRef *,TRetainReleasePolicy<OpaqueNodeRef *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TRef<OpaqueNodeRef *,TRetainReleasePolicy<OpaqueNodeRef *>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

OpaqueNodeRef *NodeIteratorNext(TNodeIterator *a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  OpaqueNodeRef *v13;
  TNodePtr v15;
  TNodePtr v16;

  v16.fFINode = 0;
  if (a1)
  {
    TNodeIterator::Next(a1, &v15);
    while (1)
    {
      TNodePtr::operator=((void **)&v16.fFINode, (void **)&v15.fFINode);

      if (!TNodeFromFINode(v16.fFINode))
        break;
      v2 = TNodeFromFINode(v16.fFINode);
      v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
      os_unfair_lock_lock(v3);
      v5 = *(_QWORD *)(v2 + 16);
      v4 = *(std::__shared_weak_count **)(v2 + 24);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v3);
      v8 = (os_unfair_lock_s *)(v5 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
      v9 = *(unsigned __int16 *)(v5 + 119);
      v10 = *(unsigned int *)(v5 + 115);
      os_unfair_lock_unlock(v8);
      if (v4)
      {
        v11 = (unint64_t *)&v4->__shared_owners_;
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      if (((v10 | (v9 << 32)) & 0x100000000) == 0)
        break;
      TNodeIterator::Next(a1, &v15);
    }
  }
  v13 = TNodePtr::CopyAsNodeRef(&v16);

  return v13;
}

void sub_1CBC623B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

OpaqueNodeRef *TNodePtr::CopyAsNodeRef(TNodePtr *this)
{
  OpaqueNodeRef *v1;
  OpaqueNodeRef *v2;

  v1 = -[FINode nodeRef](this->fFINode, "nodeRef");
  v2 = v1;
  if (v1)
    CFRetain(v1);
  return v2;
}

void TNodeIterator::Next(TNodeIterator *this@<X0>, TNodePtr *a2@<X8>)
{
  id *v4;
  FINode *v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  os_unfair_lock_s *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  while (1)
  {
    v4 = (id *)*((_QWORD *)this + 1);
    if (v4 == *((id **)this + 3))
      break;
    v5 = (FINode *)*v4;
    *((_QWORD *)this + 1) = v4 + 1;
    v6 = TNodeFromFINode(v5);
    v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v6);
    os_unfair_lock_lock(v7);
    v9 = *(_QWORD *)(v6 + 16);
    v8 = *(std::__shared_weak_count **)(v6 + 24);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v7);
    v12 = (os_unfair_lock_s *)(v9 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
    v13 = *(unsigned __int16 *)(v9 + 119);
    v14 = *(unsigned int *)(v9 + 115);
    os_unfair_lock_unlock(v12);
    if (v8)
    {
      v15 = (unint64_t *)&v8->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (((v14 | (v13 << 32)) & 0x100000000) == 0)
    {
      a2->fFINode = (FINode *)*v4;
      return;
    }
  }
  TNodePtr::TNodePtr(a2, 0);
}

uint64_t std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void sub_1CBC62A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&__p);

  _Unwind_Resume(a1);
}

void TFSInfo::SetFPItem(TFSInfo *this, FPItem *a2)
{
  FPItem *v3;
  TString *v4;
  void *v5;
  int v6;
  void *v7;
  id v8;
  _BOOL4 v9;
  NSObject *v10;
  _BOOL4 v11;
  TFSInfoOverflow *Overflow;
  os_unfair_lock_s *v13;
  int v14;
  void *v15;
  BOOL v16;
  FPProviderDomain *v17;
  id v18;
  _BYTE buf[12];
  __int16 v20;
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if ((UseFileProviderFramework() & 1) == 0)
    goto LABEL_23;
  if (!v3)
    goto LABEL_9;
  -[FPItem itemIdentifier](v3, "itemIdentifier");
  v4 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  *(_QWORD *)buf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)buf, v4);

  NS_FileProviderRootContainerItemIdentifier();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = operator==((void **)buf, v5);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if (v6)
  {
    v18 = 0;
    +[FIProviderDomain providerDomainForItem:cachePolicy:error:](FIProviderDomain, "providerDomainForItem:cachePolicy:error:", v3, 1, &v18);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v18;
    v9 = v7 != 0;
    if (!v7)
    {
      LogObj(4);
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543618;
        *(_QWORD *)&buf[4] = v3;
        v20 = 2114;
        v21 = v8;
        _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_ERROR, "Found root item identifier but unable to get provider. item: %{public}@ error: %{public}@", buf, 0x16u);
      }

      v3 = 0;
    }

  }
  else
  {
LABEL_9:
    v7 = 0;
    v9 = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  objc_storeStrong((id *)this + 8, v3);
  if (v7)
    v11 = v9;
  else
    v11 = 0;
  if (v11)
  {
    Overflow = TFSInfo::GetOrCreateOverflow(this);
    v13 = (os_unfair_lock_s *)((char *)Overflow + 72);
    os_unfair_lock_lock((os_unfair_lock_t)Overflow + 18);
    v14 = *((unsigned __int8 *)Overflow + 76);
    if (v14 == 2)
    {
      TFSInfoOverflow::MigrateToType((uint64_t)Overflow, 1);
      v14 = *((unsigned __int8 *)Overflow + 76);
    }
    else if (v14 == 3)
    {
      *((_BYTE *)Overflow + 76) = 1;
      *((_QWORD *)Overflow + 4) = 0;
      *(_OWORD *)Overflow = 0u;
      *((_OWORD *)Overflow + 1) = 0u;
      *((_DWORD *)Overflow + 8) = 0x80000000;
      os_unfair_lock_unlock(v13);
LABEL_19:
      objc_storeStrong((id *)Overflow + 3, v7);
      goto LABEL_20;
    }
    os_unfair_lock_unlock(v13);
    if (v14 == 1)
      goto LABEL_19;
  }
LABEL_20:
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  objc_msgSend(v7, "domain");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = v15 == 0;

  if (!v16)
  {
    objc_msgSend(v7, "domain");
    v17 = (FPProviderDomain *)objc_claimAutoreleasedReturnValue();
    ProviderDisplayName(v17, (TString *)buf);
    TFSInfo::SetDisplayName(this, (const TString *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);

  }
LABEL_23:

}

void sub_1CBC62E44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t operator==(void **a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = a2;
  v4 = *a1;
  if (v3)
    v5 = objc_msgSend(v4, "isEqualToString:", v3);
  else
    v5 = objc_msgSend(v4, "isEqualToString:", &stru_1E8752DF8);
  v6 = v5;

  return v6;
}

void sub_1CBC62F48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id NS_FileProviderRootContainerItemIdentifier(void)
{
  return (id)*MEMORY[0x1E0CAABA0];
}

void TChildrenList::FindNodeMatchingFPItem(TChildrenList *this@<X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  FPItem *v5;
  TString *v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  __CFString *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t ObjectIdentifier;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  TString *v19;
  TString *v20;
  _BOOL4 v21;
  TString v22;
  TString v23;
  std::__shared_weak_count *v24;
  FINode *v25;
  TString v26;

  v5 = a2;
  if (!TNode::IsFPv2(*((TNode **)this + 12), 1))
  {
    -[FPItem filename](v5, "filename");
    v6 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    v23.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v23, v6);

    SlashesToColons(&v23, &v26);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);

    TChildrenList::Find(this, &v26, (TNodePtr *)&v25);
    if (!TNodeFromFINode(v25))
      goto LABEL_15;
    v7 = TNodeFromFINode(v25);
    v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v7);
    os_unfair_lock_lock(v8);
    v10 = *(__CFString **)(v7 + 16);
    v9 = *(std::__shared_weak_count **)(v7 + 24);
    v23.fString.fRef = v10;
    v24 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v8);
    ObjectIdentifier = TFSInfo::GetObjectIdentifier((TFSInfo *)v10);
    if (v9)
    {
      v14 = (unint64_t *)&v9->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v16 = -[FPItem fileID](v5, "fileID");
    if (v16 == ObjectIdentifier)
    {
      TNodePtr::TNodePtr(a3, (id *)&v25);
LABEL_16:

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v26.fString.fRef);
      goto LABEL_17;
    }
    if (v16)
    {
LABEL_15:
      TChildrenList::FindByFileIdentifier(this, -[FPItem fileID](v5, "fileID"), a3);
      goto LABEL_16;
    }
    -[FINode fiDomain](v25, "fiDomain");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "identifier");
    v18 = (void *)objc_claimAutoreleasedReturnValue();

    v19 = v18;
    v23.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v23, v19);

    if (IsLocalStorageDomainID(&v23))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
    }
    else
    {
      v20 = v19;
      v22.fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(&v22, v20);

      v21 = IsExternalDeviceDomainID(&v22);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
      if (!v21)
      {

        goto LABEL_15;
      }
    }
    TNodePtr::TNodePtr(a3, (id *)&v25);

    goto LABEL_16;
  }
  TChildrenList::FindByFPItem(this, v5, a3);
LABEL_17:

}

void sub_1CBC631E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  const void *v5;
  va_list va;
  const void *v7;
  va_list va1;
  uint64_t v9;
  id v10;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v7 = va_arg(va2, const void *);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, id);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

void TChildrenList::Find(TChildrenList *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  int v12;
  unint64_t v13;
  FINode **v14;
  FINode **v15;
  TNode *v16;
  uint64_t v17;
  unint64_t v18;
  FINode **v19;
  FINode **v20;
  FINode *v21;
  TNode *v22;
  _BOOL4 v23;
  TNode *v24;

  v6 = *((_QWORD *)this + 12);
  v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)this);
  os_unfair_lock_lock(v7);
  v9 = *(_QWORD *)(v6 + 16);
  v8 = *(std::__shared_weak_count **)(v6 + 24);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    os_unfair_lock_unlock(v7);
    v12 = *(unsigned __int8 *)(v9 + 112);
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    if (v12)
      goto LABEL_9;
  }
  else
  {
    os_unfair_lock_unlock(v7);
    if (*(_BYTE *)(v9 + 112))
    {
LABEL_9:
      v14 = (FINode **)*((_QWORD *)this + 8);
      v15 = (FINode **)*((_QWORD *)this + 9);
      if (v14 == v15)
        goto LABEL_27;
      while (1)
      {
        v16 = (TNode *)TNodeFromFINode(*v14);
        if (TNode::Equal(v16, a2))
          break;
        if (++v14 == v15)
        {
          v14 = v15;
          break;
        }
      }
      if (v14 == *((FINode ***)this + 9))
        goto LABEL_27;
LABEL_26:
      a3->fFINode = *v14;
      return;
    }
  }
  TChildrenList::SortListIfNeeded(this, 0);
  v14 = (FINode **)*((_QWORD *)this + 8);
  v17 = *((_QWORD *)this + 9) - (_QWORD)v14;
  if (v17)
  {
    v18 = v17 >> 3;
    do
    {
      v19 = &v14[v18 >> 1];
      v21 = *v19;
      v20 = v19 + 1;
      v22 = (TNode *)TNodeFromFINode(v21);
      v23 = TNode::LessThan(v22, a2);
      if (v23)
        v18 += ~(v18 >> 1);
      else
        v18 >>= 1;
      if (v23)
        v14 = v20;
    }
    while (v18);
    if (v14 != *((FINode ***)this + 9))
    {
      v24 = (TNode *)TNodeFromFINode(*v14);
      if (TNode::Equal(v24, a2))
        goto LABEL_26;
    }
  }
LABEL_27:
  TNodePtr::TNodePtr(a3, 0);
}

BOOL TNode::LessThan(TNode *this, const TString *a2)
{
  return TNode::Compare(this, a2) == -1;
}

void TChildrenList::SortListIfNeeded(TChildrenList *this, unint64_t a2)
{
  char *v2;
  FINode **v3;
  unint64_t v4;
  void **v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  FINode **v10;
  FINode **v11;
  _BOOL4 v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  void **v17;
  void **v18;
  void **v19;
  void **v20;
  uint64_t v21;
  FINode **v22;
  FINode **v23;
  FINode **v24;
  FINode **v25;
  void *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  void **v32;

  v2 = (char *)this + 64;
  v3 = (FINode **)*((_QWORD *)this + 8);
  v4 = *((_QWORD *)this + 19);
  v5 = (void **)*((_QWORD *)this + 9);
  v6 = ((char *)v5 - (char *)v3) >> 3;
  v7 = v6 - v4;
  v8 = v6 != v4 && (unint64_t)((char *)v5 - (char *)v3) >= 0x10;
  if (v8
    && (a2 < 2
     || (float)((float)(log2f((float)(unint64_t)v6) + 1.0) * (float)a2) < (float)((float)a2
                                                                                       * (float)(unint64_t)v6)))
  {
    v10 = &v3[v4];
    if (v7 == 1)
    {
      if (v4)
      {
        do
        {
          v11 = &v3[v4 >> 1];
          v12 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v11, v10);
          if (v12)
            v4 += ~(v4 >> 1);
          else
            v4 >>= 1;
          if (v12)
            v3 = v11 + 1;
        }
        while (v4);
      }
      else
      {
        v3 += v4;
      }
      if (v10 != v3)
      {
        v21 = (uint64_t)v3 - *((_QWORD *)this + 8);
        v22 = v10 + 1;
        *(_QWORD *)&v30 = *v10;
        v23 = (FINode **)*((_QWORD *)this + 9);
        if (v10 + 1 != v23)
        {
          do
          {
            v24 = v10 + 1;
            TNodePtr::operator=((void **)v10, (void **)v10 + 1);
            v25 = v10 + 2;
            ++v10;
          }
          while (v25 != v23);
          v22 = (FINode **)*((_QWORD *)this + 9);
          v10 = v24;
        }
        while (v22 != v10)
        {
          v26 = *--v22;

        }
        *((_QWORD *)this + 9) = v10;
        std::vector<TNodePtr>::insert((uint64_t)v2, (id *)(*((_QWORD *)this + 8) + 8 * (v21 >> 3)), (id *)&v30);

      }
    }
    else
    {
      v13 = 126 - 2 * __clz(((char *)v5 - (char *)v10) >> 3);
      if (v5 == (void **)v10)
        v14 = 0;
      else
        v14 = v13;
      std::__introsort<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,false>((id *)&v3[v4], v5, v14, 1);
      std::vector<TNodePtr>::vector(&v30, (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 3);
      v15 = *((_QWORD *)this + 19);
      v16 = (void **)*((_QWORD *)this + 8);
      v17 = (void **)*((_QWORD *)this + 9);
      v18 = &v16[v15];
      v19 = (void **)v30;
      if (v15)
      {
        v20 = &v16[v15];
        while (v20 != v17)
        {
          if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v20, (FINode **)v16))
            TNodePtr::operator=(v19, v20++);
          else
            TNodePtr::operator=(v19, v16++);
          ++v19;
          if (v16 == v18)
            goto LABEL_38;
        }
        v27 = 0;
        do
        {
          TNodePtr::operator=(&v19[v27], &v16[v27]);
          ++v27;
        }
        while (&v16[v27] != v18);
      }
      else
      {
        v20 = (void **)*((_QWORD *)this + 8);
LABEL_38:
        while (v20 != v17)
          TNodePtr::operator=(v19++, v20++);
      }
      v28 = *((_OWORD *)this + 4);
      *((_OWORD *)this + 4) = v30;
      v30 = v28;
      v29 = *((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = v31;
      v31 = v29;
      v32 = (void **)&v30;
      std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v32);
    }
    *((_QWORD *)this + 19) = (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 3;
  }
}

void sub_1CBC63724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

BOOL TNode::Equal(TNode *this, const TString *a2)
{
  return TNode::Compare(this, a2) == 0;
}

void SlashesToColons(const TString *a1@<X0>, TString *a2@<X8>)
{
  const __CFString *v4;
  CFTypeRef v5;
  char v6;
  char *i;
  TString *v8;
  TString *v9;
  char buffer[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetLength(a1->fString.fRef))
    goto LABEL_12;
  v4 = (const __CFString *)RetainCF<__CFString const*>((const void **)&a1->fString.fRef);
  if (v4)
  {
    v5 = CFAutorelease(v4);
    v4 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v5);
  }
  if (!CFStringGetCString(v4, buffer, 1024, 0x8000100u))
  {
LABEL_12:
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)a1->fString.fRef);
    return;
  }
  v6 = 0;
  for (i = buffer; *i == 47; ++i)
  {
    *i = 58;
    v6 = 1;
LABEL_10:
    ;
  }
  if (*i)
    goto LABEL_10;
  if ((v6 & 1) == 0)
    goto LABEL_12;
  v8 = (TString *)CFStringCreateWithCString(0, buffer, 0x8000100u);
  v9 = v8;
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9);
}

void sub_1CBC63894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  const void **v9;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

_QWORD *TNodePtr::TNodePtr(_QWORD *a1, id *a2)
{
  id v4;

  *a1 = *a2;
  v4 = *a2;
  *a2 = 0;

  return a1;
}

void ProviderDisplayName(FPProviderDomain *a1@<X0>, TString *a2@<X8>)
{
  TString *v3;

  -[FPProviderDomain domainFullDisplayName](a1, "domainFullDisplayName");
  v3 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, v3);

}

void sub_1CBC63970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  const void **v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);

  _Unwind_Resume(a1);
}

id TFSInfo::FetchISIcon(TFSInfo *this)
{
  void *v2;
  void *v3;
  const void *v4;
  void *v5;
  void *v7;
  const void *v8;
  TFSInfo *v9;

  TFSInfo::GetISIcon(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
    return v2;
  v9 = this;
  if (!TFSInfo::IsFPv2(this, 1))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v4 = (const void *)*((_QWORD *)this + 2);
    v8 = v4;
    if (v4)
    {
      CFRetain(v4);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      if (!*((_BYTE *)this + 112) || *((_BYTE *)this + 112) == 7)
      {
        if (((*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0x400000000) != 0)
        {
          TFSInfo::ISIconRefFromTypeInfo(this);
          v5 = (void *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D3A820]), "initWithURL:", v8);
        }
        v7 = v5;
        TFSInfo::FetchISIcon(void)const::$_0::operator()(&v9, v5);
        v2 = (void *)objc_claimAutoreleasedReturnValue();

        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v8);
        goto LABEL_13;
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v8);
    return 0;
  }
  TFSInfo::ISIconRefFromTypeInfo(this);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  TFSInfo::FetchISIcon(void)const::$_0::operator()(&v9, v3);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_13:
  TFSInfo::SetISIcon((uint64_t)this, v2);
  return v2;
}

void sub_1CBC63ADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<TNodePtr>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1CBC63B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void **TNodePtr::operator=(void **a1, void **a2)
{
  void *v3;
  void *v4;

  if (a1 != a2)
  {
    v3 = *a2;
    *a2 = 0;
    v4 = *a1;
    *a1 = v3;

  }
  return a1;
}

uint64_t TFSInfoSynchronizer::FetchChildren(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4)
{
  uint64_t v5;
  TFSInfo **v6;
  unsigned int v7;
  DIR *v8;
  dirent *m;
  unsigned int d_type;
  unint64_t v11;
  _OWORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  int64x2_t v24;
  _OWORD *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  TNode *v30;
  uint64_t NotifierList;
  std::__shared_weak_count *v32;
  uint64_t v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  id v36;
  unint64_t *v37;
  unint64_t v38;
  _QWORD *f_bavail;
  uint64_t v40;
  TNode *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t i;
  FPItem *v48;
  std::__shared_weak_count *f_blocks;
  unint64_t *v50;
  unint64_t v51;
  void *v53;
  dispatch_time_t v54;
  NSObject *v55;
  id v56;
  TFSInfo *v57;
  os_unfair_lock_s *v58;
  const void *v59;
  CFIndex v60;
  TCFURLInfo *v61;
  NSObject *v62;
  const char *v63;
  int v64;
  __CFError *v65;
  char v66;
  uint64_t v67;
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t k;
  FPItem *v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  NSObject *v77;
  TFSInfo *v78;
  const __CFArray *v79;
  CFIndex Count;
  CFIndex j;
  unint64_t v82;
  _OWORD *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  uint64_t v89;
  char *v90;
  char *v91;
  char *v92;
  char *v93;
  __int128 v94;
  int64x2_t v95;
  _OWORD *v96;
  uint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  void *v101;
  id v102;
  uint64_t v103;
  unint64_t v104;
  _OWORD *v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  char *v110;
  uint64_t v111;
  char *v112;
  _QWORD *v113;
  _QWORD *v114;
  char *v115;
  __int128 v116;
  int64x2_t v117;
  _OWORD *v118;
  uint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  TFSInfo *v123;
  os_unfair_lock_s *v124;
  const void *v125;
  TFSInfo *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  TNode *v130;
  void *v131;
  uint64_t v132;
  os_unfair_lock_s *v133;
  unint64_t v134;
  std::__shared_weak_count *v135;
  unint64_t *v136;
  unint64_t v137;
  unint64_t v138;
  _OWORD *v139;
  _OWORD *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  uint64_t v146;
  char *v147;
  char *v148;
  char *v149;
  char *v150;
  __int128 v151;
  int64x2_t v152;
  uint64_t v153;
  std::__shared_weak_count *v154;
  unint64_t *v155;
  unint64_t v156;
  int *v157;
  int v158;
  const char *v159;
  unsigned int v160;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  unsigned __int8 v170;
  FPItem *v171;
  FIProviderDomain *v172;
  __int128 v173;
  uint64_t v174[2];
  CFArrayRef theArray[4];
  void *v176;
  id v177;
  _QWORD block[4];
  id v179;
  unsigned __int8 v180;
  unsigned __int8 v181;
  _BYTE v182[24];
  uint64_t v183;
  uint64_t v184;
  _BYTE v185[128];
  _BYTE v186[128];
  statfs v187;
  char __dst[16];
  const void *v189[129];

  v189[126] = *(const void **)MEMORY[0x1E0C80C00];
  v181 = a3;
  v6 = (TFSInfo **)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 32);
  if (!v5)
    return 0;
  v180 = *(_BYTE *)(v5 + 112);
  if (v180 == 26)
  {
    v30 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 24));
    NotifierList = TNode::GetNotifierList(v30);
    v33 = *(_QWORD *)(NotifierList + 24);
    v32 = *(std::__shared_weak_count **)(NotifierList + 32);
    if (v32)
    {
      p_shared_owners = (unint64_t *)&v32->__shared_owners_;
      do
        v35 = __ldxr(p_shared_owners);
      while (__stxr(v35 + 1, p_shared_owners));
    }
    os_unfair_lock_lock((os_unfair_lock_t)v33);
    v36 = *(id *)(v33 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v33);
    if (v32)
    {
      v37 = (unint64_t *)&v32->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    if ((objc_msgSend(v36, "populated") & 1) == 0)
    {
      LogObj(4);
      v77 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v187.f_bsize) = 0;
        _os_log_impl(&dword_1CBC4A000, v77, OS_LOG_TYPE_DEBUG, "FPProviders not fetched", (uint8_t *)&v187, 2u);
      }

      return 4294959279;
    }
    objc_msgSend(v36, "providers");
    v176 = (void *)objc_claimAutoreleasedReturnValue();
    *(_QWORD *)__dst = 0x4008000000000000;
    v187.f_bavail = 0;
    TNode::RootFPItemsForDomainsWithTimeout(v176, (double *)__dst, (uint64_t)&v187, (uint64_t)theArray);
    f_bavail = (_QWORD *)v187.f_bavail;
    if ((statfs *)v187.f_bavail == &v187)
    {
      v40 = 4;
      f_bavail = &v187;
    }
    else
    {
      if (!v187.f_bavail)
        goto LABEL_121;
      v40 = 5;
    }
    (*(void (**)(void))(*f_bavail + 8 * v40))();
LABEL_121:
    v174[0] = (uint64_t)&v176;
    v174[1] = (uint64_t)theArray;
    iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::begin((uint64_t)v174, (uint64_t)&v187);
    iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::end((uint64_t)v174, (uint64_t)__dst);
    while (1)
    {
      v101 = *(void **)&v187.f_bsize;
      if (*(_QWORD *)&v187.f_bsize == *(_QWORD *)__dst && *(const void **)&v187.f_mntonname[40] == v189[13])
        break;
      if (*(const void **)&v187.f_mntonname[48] == v189[14])
      {
        v101 = *(void **)__dst;
        break;
      }
      v102 = *(id *)(v187.f_bfree + 8 * *(_QWORD *)&v187.f_mntonname[32]);
      v103 = *(_QWORD *)&v187.f_mntonname[48];
      +[FIProviderDomain providerDomainForDomain:](FIProviderDomain, "providerDomainForDomain:", v102);
      v172 = (FIProviderDomain *)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)v182 = 0;
      fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::value_or<decltype(nullptr)>(v103);
      v171 = (FPItem *)objc_claimAutoreleasedReturnValue();
      v170 = 0;
      std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},FPItem * {__strong},BOOL,void>(&v172, &v171, &v170, &v173);

      v105 = *(_OWORD **)(a1 + 8);
      v104 = *(_QWORD *)(a1 + 16);
      if ((unint64_t)v105 >= v104)
      {
        v106 = ((uint64_t)v105 - *(_QWORD *)a1) >> 4;
        v107 = v106 + 1;
        if ((unint64_t)(v106 + 1) >> 60)
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        v108 = v104 - *(_QWORD *)a1;
        if (v108 >> 3 > v107)
          v107 = v108 >> 3;
        if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFF0)
          v109 = 0xFFFFFFFFFFFFFFFLL;
        else
          v109 = v107;
        v184 = a1 + 16;
        v110 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v109);
        v112 = &v110[16 * v106];
        *(_OWORD *)v112 = v173;
        v173 = 0uLL;
        v114 = *(_QWORD **)a1;
        v113 = *(_QWORD **)(a1 + 8);
        if (v113 == *(_QWORD **)a1)
        {
          v117 = vdupq_n_s64((unint64_t)v113);
          v115 = &v110[16 * v106];
        }
        else
        {
          v115 = &v110[16 * v106];
          do
          {
            v116 = *((_OWORD *)v113 - 1);
            v113 -= 2;
            *((_OWORD *)v115 - 1) = v116;
            v115 -= 16;
            *v113 = 0;
            v113[1] = 0;
          }
          while (v113 != v114);
          v117 = *(int64x2_t *)a1;
        }
        v118 = v112 + 16;
        *(_QWORD *)a1 = v115;
        *(_QWORD *)(a1 + 8) = v112 + 16;
        *(int64x2_t *)&v182[8] = v117;
        v119 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = &v110[16 * v111];
        v183 = v119;
        *(_QWORD *)v182 = v117.i64[0];
        std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((uint64_t)v182);
        v120 = (std::__shared_weak_count *)*((_QWORD *)&v173 + 1);
        *(_QWORD *)(a1 + 8) = v118;
        if (v120)
        {
          v121 = (unint64_t *)&v120->__shared_owners_;
          do
            v122 = __ldaxr(v121);
          while (__stlxr(v122 - 1, v121));
          if (!v122)
          {
            ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
            std::__shared_weak_count::__release_weak(v120);
          }
        }
      }
      else
      {
        *v105 = v173;
        *(_QWORD *)(a1 + 8) = v105 + 1;
      }

      iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::operator++((uint64_t)&v187);
    }

    *(_QWORD *)&v187.f_bsize = theArray;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v187);

    return 0;
  }
  if (v180)
  {
    v41 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 24));
    if (TNode::IsFPv2(v41, 1))
    {
      v42 = TNodeFromFINode(*(FINode **)(a1 + 24));
      TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(v42 + 56));
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      v168 = 0u;
      v169 = 0u;
      v166 = 0u;
      v167 = 0u;
      objc_msgSend(v43, "fpItems");
      v44 = (void *)objc_claimAutoreleasedReturnValue();
      v45 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v166, v186, 16);
      if (v45)
      {
        v46 = *(_QWORD *)v167;
        do
        {
          for (i = 0; i != v45; ++i)
          {
            if (*(_QWORD *)v167 != v46)
              objc_enumerationMutation(v44);
            v48 = *(FPItem **)(*((_QWORD *)&v166 + 1) + 8 * i);
            if ((-[FPItem isTrashed](v48, "isTrashed") & 1) == 0)
            {
              _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v187);
              if (!TFSInfo::Initialize(*(TFSInfo **)&v187.f_bsize, v48, 0))
                std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)a1, (__int128 *)&v187);
              f_blocks = (std::__shared_weak_count *)v187.f_blocks;
              if (v187.f_blocks)
              {
                v50 = (unint64_t *)(v187.f_blocks + 8);
                do
                  v51 = __ldaxr(v50);
                while (__stlxr(v51 - 1, v50));
                if (!v51)
                {
                  ((void (*)(std::__shared_weak_count *))f_blocks->__on_zero_shared)(f_blocks);
                  std::__shared_weak_count::__release_weak(f_blocks);
                }
              }
            }
          }
          v45 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v166, v186, 16);
        }
        while (v45);
      }

    }
    else if (v180 - 23 > 1)
    {
      v78 = (TFSInfo *)TFSInfo::CopySFBrowserRef(*v6);
      *(_QWORD *)v182 = v78;
      if (v78 && TFSInfo::IsBrowserOpen(v78))
      {
        v79 = (const __CFArray *)SFBrowserCopyChildren();
        theArray[0] = v79;
        if (v79)
        {
          Count = CFArrayGetCount(v79);
          std::vector<std::shared_ptr<TFSInfo>>::reserve((char **)a1, Count);
          if (Count >= 1)
          {
            for (j = 0; j != Count; ++j)
            {
              v174[0] = 0;
              v174[0] = (uint64_t)CFArrayGetValueAtIndex(theArray[0], j);
              if (v174[0])
              {
                std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType const&,__SFNode *&,void>((char *)&v180, v174, __dst);
                TFSInfo::MarkAsUsed(*(TFSInfo **)__dst);
                v83 = *(_OWORD **)(a1 + 8);
                v82 = *(_QWORD *)(a1 + 16);
                if ((unint64_t)v83 >= v82)
                {
                  v84 = ((uint64_t)v83 - *(_QWORD *)a1) >> 4;
                  v85 = v84 + 1;
                  if ((unint64_t)(v84 + 1) >> 60)
                    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                  v86 = v82 - *(_QWORD *)a1;
                  if (v86 >> 3 > v85)
                    v85 = v86 >> 3;
                  if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF0)
                    v87 = 0xFFFFFFFFFFFFFFFLL;
                  else
                    v87 = v85;
                  v187.f_files = a1 + 16;
                  v88 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v87);
                  v90 = &v88[16 * v84];
                  *(_OWORD *)v90 = *(_OWORD *)__dst;
                  memset(__dst, 0, sizeof(__dst));
                  v92 = *(char **)a1;
                  v91 = *(char **)(a1 + 8);
                  if (v91 == *(char **)a1)
                  {
                    v95 = vdupq_n_s64((unint64_t)v91);
                    v93 = &v88[16 * v84];
                  }
                  else
                  {
                    v93 = &v88[16 * v84];
                    do
                    {
                      v94 = *((_OWORD *)v91 - 1);
                      v91 -= 16;
                      *((_OWORD *)v93 - 1) = v94;
                      v93 -= 16;
                      *(_QWORD *)v91 = 0;
                      *((_QWORD *)v91 + 1) = 0;
                    }
                    while (v91 != v92);
                    v95 = *(int64x2_t *)a1;
                  }
                  v96 = v90 + 16;
                  *(_QWORD *)a1 = v93;
                  *(_QWORD *)(a1 + 8) = v90 + 16;
                  *(int64x2_t *)&v187.f_blocks = v95;
                  v97 = *(_QWORD *)(a1 + 16);
                  *(_QWORD *)(a1 + 16) = &v88[16 * v89];
                  v187.f_bavail = v97;
                  *(_QWORD *)&v187.f_bsize = v95.i64[0];
                  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((uint64_t)&v187);
                  v98 = *(std::__shared_weak_count **)&__dst[8];
                  *(_QWORD *)(a1 + 8) = v96;
                  if (v98)
                  {
                    v99 = (unint64_t *)&v98->__shared_owners_;
                    do
                      v100 = __ldaxr(v99);
                    while (__stlxr(v100 - 1, v99));
                    if (!v100)
                    {
                      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
                      std::__shared_weak_count::__release_weak(v98);
                    }
                  }
                }
                else
                {
                  *v83 = *(_OWORD *)__dst;
                  *(_QWORD *)(a1 + 8) = v83 + 1;
                }
              }
            }
          }
        }
        TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)theArray);
      }
      TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)v182);
    }
    else if (ICloudDriveFPFSEnabled())
    {
      v67 = TNodeFromFINode(*(FINode **)(a1 + 24));
      TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(v67 + 56));
      v68 = (void *)objc_claimAutoreleasedReturnValue();
      v164 = 0u;
      v165 = 0u;
      v162 = 0u;
      v163 = 0u;
      objc_msgSend(v68, "fpItems");
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      v70 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v162, v185, 16);
      if (v70)
      {
        v71 = *(_QWORD *)v163;
        do
        {
          for (k = 0; k != v70; ++k)
          {
            if (*(_QWORD *)v163 != v71)
              objc_enumerationMutation(v69);
            v73 = *(FPItem **)(*((_QWORD *)&v162 + 1) + 8 * k);
            _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v187);
            if (!TFSInfo::Initialize(*(TFSInfo **)&v187.f_bsize, v73, 1))
              std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)a1, (__int128 *)&v187);
            v74 = (std::__shared_weak_count *)v187.f_blocks;
            if (v187.f_blocks)
            {
              v75 = (unint64_t *)(v187.f_blocks + 8);
              do
                v76 = __ldaxr(v75);
              while (__stlxr(v76 - 1, v75));
              if (!v76)
              {
                ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
                std::__shared_weak_count::__release_weak(v74);
              }
            }
          }
          v70 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v162, v185, 16);
        }
        while (v70);
      }

    }
    return 0;
  }
  if ((_DWORD)a2)
  {
    v7 = TFSInfo::CopyPathToCBuffer((TFSInfo *)v5, __dst, 1024);
    if (!v7)
    {
      v8 = opendir(__dst);
      if (v8)
      {
        statfs(__dst, &v187);
        strlcat(__dst, "/", 0x400uLL);
        *__error() = 0;
        for (m = readdir(v8); m; m = readdir(v8))
        {
          LOBYTE(v174[0]) = 0;
          LOBYTE(v173) = 0;
          d_type = m->d_type;
          if (d_type > 0xE)
            goto LABEL_16;
          if (((1 << d_type) & 0x5047) == 0)
          {
            if (d_type != 4)
            {
              LOBYTE(v173) = d_type == 10;
LABEL_16:
              std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,void>((os_unfair_lock_s **)v6, __dst, m->d_name, (uint64_t *)&v187.f_fsid, (uint64_t *)m, &v181, (unsigned __int8 *)v174, theArray, (char *)&v173);
              v12 = *(_OWORD **)(a1 + 8);
              v11 = *(_QWORD *)(a1 + 16);
              if ((unint64_t)v12 >= v11)
              {
                v13 = ((uint64_t)v12 - *(_QWORD *)a1) >> 4;
                v14 = v13 + 1;
                if ((unint64_t)(v13 + 1) >> 60)
                  std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                v15 = v11 - *(_QWORD *)a1;
                if (v15 >> 3 > v14)
                  v14 = v15 >> 3;
                if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0)
                  v16 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v16 = v14;
                v184 = a1 + 16;
                v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v16);
                v19 = &v17[16 * v13];
                *(_OWORD *)v19 = *(_OWORD *)theArray;
                theArray[0] = 0;
                theArray[1] = 0;
                v21 = *(char **)a1;
                v20 = *(char **)(a1 + 8);
                if (v20 == *(char **)a1)
                {
                  v24 = vdupq_n_s64((unint64_t)v20);
                  v22 = &v17[16 * v13];
                }
                else
                {
                  v22 = &v17[16 * v13];
                  do
                  {
                    v23 = *((_OWORD *)v20 - 1);
                    v20 -= 16;
                    *((_OWORD *)v22 - 1) = v23;
                    v22 -= 16;
                    *(_QWORD *)v20 = 0;
                    *((_QWORD *)v20 + 1) = 0;
                  }
                  while (v20 != v21);
                  v24 = *(int64x2_t *)a1;
                }
                v25 = v19 + 16;
                *(_QWORD *)a1 = v22;
                *(_QWORD *)(a1 + 8) = v19 + 16;
                *(int64x2_t *)&v182[8] = v24;
                v26 = *(_QWORD *)(a1 + 16);
                *(_QWORD *)(a1 + 16) = &v17[16 * v18];
                v183 = v26;
                *(_QWORD *)v182 = v24.i64[0];
                std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((uint64_t)v182);
                v27 = (std::__shared_weak_count *)theArray[1];
                *(_QWORD *)(a1 + 8) = v25;
                if (v27)
                {
                  v28 = (unint64_t *)&v27->__shared_owners_;
                  do
                    v29 = __ldaxr(v28);
                  while (__stlxr(v29 - 1, v28));
                  if (!v29)
                  {
                    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                    std::__shared_weak_count::__release_weak(v27);
                  }
                }
              }
              else
              {
                *v12 = *(_OWORD *)theArray;
                *(_QWORD *)(a1 + 8) = v12 + 1;
              }
              goto LABEL_10;
            }
            LOBYTE(v174[0]) = 1;
            if (strcmp(m->d_name, ".") && strcmp(m->d_name, ".."))
              goto LABEL_16;
          }
LABEL_10:
          *__error() = 0;
        }
        closedir(v8);
        v7 = -8086;
      }
      else
      {
        v157 = __error();
        v160 = TCFURLInfo::TranslateXAttrError(*v157, v158, v159);
        if (v160 == -5000)
          v7 = 0;
        else
          v7 = v160;
      }
    }
    goto LABEL_189;
  }
  if (!TFSInfo::IsDataless((TFSInfo *)v5, a2, a3))
    goto LABEL_149;
  NewFileCoordinator();
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = dispatch_time(0, 10000000000);
  dispatch_get_global_queue(0, 0);
  v55 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN19TFSInfoSynchronizer13FetchChildrenEbb12LSProperties_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c65_ZTSKZN19TFSInfoSynchronizer13FetchChildrenEbb12LSPropertiesE3__0_e5_v8__0l;
  v56 = v53;
  v179 = v56;
  dispatch_after(v54, v55, block);

  v57 = *v6;
  v58 = (os_unfair_lock_s *)((char *)*v6 + 100);
  os_unfair_lock_lock(v58);
  v59 = (const void *)*((_QWORD *)v57 + 2);
  *(_QWORD *)&v187.f_bsize = v59;
  if (v59)
    CFRetain(v59);
  os_unfair_lock_unlock(v58);
  v60 = (CFIndex)*(id *)&v187.f_bsize;
  v177 = 0;
  objc_msgSend(v56, "coordinateReadingItemAtURL:options:error:byAccessor:", v60, 1, &v177, &__block_literal_global_4);
  v61 = (TCFURLInfo *)v177;

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v187);
  if (!v61)
    goto LABEL_147;
  LogObj(4);
  v62 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
  {
    v187.f_bsize = 138412290;
    *(_QWORD *)&v187.f_iosize = v61;
    _os_log_impl(&dword_1CBC4A000, v62, OS_LOG_TYPE_ERROR, "Synchronizer coordinateReadingItemAtURL error: %@", (uint8_t *)&v187, 0xCu);
  }

  TFSInfo::InitializeAndGetPath((uint64_t *)__dst, *v6);
  v63 = (const char *)TString::c_str((TString *)__dst);
  v60 = stat(v63, (stat *)&v187);
  v64 = *(_DWORD *)&v187.f_mntonname[28];
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)__dst);
  if (!(_DWORD)v60 && (v64 & 0x40000000) != 0)
  {
    v60 = TCFURLInfo::TranslateCFError(v61, v65);
    v66 = 0;
  }
  else
  {
LABEL_147:
    v66 = 1;
  }

  if ((v66 & 1) != 0)
  {
LABEL_149:
    v123 = *v6;
    v124 = (os_unfair_lock_s *)((char *)*v6 + 100);
    os_unfair_lock_lock(v124);
    v125 = (const void *)*((_QWORD *)v123 + 2);
    *(_QWORD *)&v187.f_bsize = v125;
    if (v125)
      CFRetain(v125);
    os_unfair_lock_unlock(v124);
    v127 = *(_QWORD *)&v187.f_bsize;
    if ((_DWORD)a4)
      v128 = TFSInfo::IterationInfoPropertyKeys(v126);
    else
      v128 = TFSInfo::IterationFullSetOfPropertyKeys(v126);
    v129 = v128;
    v130 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 24));
    TNode::GetFIProvider(v130);
    v131 = (void *)objc_claimAutoreleasedReturnValue();
    TFSIterator::TFSIterator(__dst, v127, v129, a4, v131 != 0);

    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v187);
    do
    {
      while (1)
      {
        _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(v182);
        v7 = TFSIterator::Next((uint64_t)__dst, (uint64_t *)v182);
        if (!v7)
        {
          v132 = *(_QWORD *)v182;
          v133 = (os_unfair_lock_s *)(*(_QWORD *)v182 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)v182 + 100));
          v134 = *(unsigned int *)(v132 + 115) | ((unint64_t)*(unsigned __int16 *)(v132 + 119) << 32);
          os_unfair_lock_unlock(v133);
          if ((v134 & 0x20000000000) != 0)
          {
            v187.f_blocks = 0;
            *(_QWORD *)&v187.f_bsize = 0;
            TFSInfo::Fetch(*(TFSInfo **)v182, (TFSInfo **)&v187, 1);
            v135 = (std::__shared_weak_count *)v187.f_blocks;
            if (v187.f_blocks)
            {
              v136 = (unint64_t *)(v187.f_blocks + 8);
              do
                v137 = __ldaxr(v136);
              while (__stlxr(v137 - 1, v136));
              if (!v137)
              {
                ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
                std::__shared_weak_count::__release_weak(v135);
              }
            }
          }
          v139 = *(_OWORD **)(a1 + 8);
          v138 = *(_QWORD *)(a1 + 16);
          if ((unint64_t)v139 >= v138)
          {
            v141 = ((uint64_t)v139 - *(_QWORD *)a1) >> 4;
            if ((unint64_t)(v141 + 1) >> 60)
              std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
            v142 = v138 - *(_QWORD *)a1;
            v143 = v142 >> 3;
            if (v142 >> 3 <= (unint64_t)(v141 + 1))
              v143 = v141 + 1;
            if ((unint64_t)v142 >= 0x7FFFFFFFFFFFFFF0)
              v144 = 0xFFFFFFFFFFFFFFFLL;
            else
              v144 = v143;
            v187.f_files = a1 + 16;
            v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v144);
            v147 = &v145[16 * v141];
            *(_OWORD *)v147 = *(_OWORD *)v182;
            *(_QWORD *)v182 = 0;
            *(_QWORD *)&v182[8] = 0;
            v149 = *(char **)a1;
            v148 = *(char **)(a1 + 8);
            if (v148 == *(char **)a1)
            {
              v152 = vdupq_n_s64((unint64_t)v148);
              v150 = &v145[16 * v141];
            }
            else
            {
              v150 = &v145[16 * v141];
              do
              {
                v151 = *((_OWORD *)v148 - 1);
                v148 -= 16;
                *((_OWORD *)v150 - 1) = v151;
                v150 -= 16;
                *(_QWORD *)v148 = 0;
                *((_QWORD *)v148 + 1) = 0;
              }
              while (v148 != v149);
              v152 = *(int64x2_t *)a1;
            }
            v140 = v147 + 16;
            *(_QWORD *)a1 = v150;
            *(_QWORD *)(a1 + 8) = v147 + 16;
            *(int64x2_t *)&v187.f_blocks = v152;
            v153 = *(_QWORD *)(a1 + 16);
            *(_QWORD *)(a1 + 16) = &v145[16 * v146];
            v187.f_bavail = v153;
            *(_QWORD *)&v187.f_bsize = v152.i64[0];
            std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((uint64_t)&v187);
          }
          else
          {
            *v139 = *(_OWORD *)v182;
            v140 = v139 + 1;
            *(_QWORD *)v182 = 0;
            *(_QWORD *)&v182[8] = 0;
          }
          *(_QWORD *)(a1 + 8) = v140;
        }
        v154 = *(std::__shared_weak_count **)&v182[8];
        if (*(_QWORD *)&v182[8])
        {
          v155 = (unint64_t *)(*(_QWORD *)&v182[8] + 8);
          do
            v156 = __ldaxr(v155);
          while (__stlxr(v156 - 1, v155));
          if (!v156)
            break;
        }
        if (v7)
          goto LABEL_184;
      }
      ((void (*)(std::__shared_weak_count *))v154->__on_zero_shared)(v154);
      std::__shared_weak_count::__release_weak(v154);
    }
    while (!v7);
LABEL_184:
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v189);
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)&__dst[8]);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)__dst);
LABEL_189:
    if (v7 == -1417)
      return 0;
    else
      return v7;
  }
  return v60;
}

void sub_1CBC64A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,const void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,const void *a47)
{
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef(&a35);
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(&a47);
  _Unwind_Resume(a1);
}

void TFSInfo::TFSInfo(TFSInfo *this)
{
  __int16 v2;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = &stru_1E8752DF8;
  *(_QWORD *)this = 0;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 4) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *(_OWORD *)((char *)this + 97) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_WORD *)((char *)this + 113) = 255;
  v2 = *(_WORD *)((char *)this + 119);
  *(_DWORD *)((char *)this + 115) = 67108872;
  *(_WORD *)((char *)this + 119) = v2 & 0xC000;
}

void sub_1CBC64D48(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void **v2;
  const void **v3;
  const void **v4;
  const void **v5;
  const void **v7;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v2);
  v7 = *(const void ***)v1;
  *(_QWORD *)v1 = 0;
  if (v7)
    std::default_delete<TVersionData>::operator()[abi:ne180100](v1, v7);
  _Unwind_Resume(a1);
}

uint64_t TFSIterator::Next(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  os_unfair_lock_s *v6;
  int v7;
  int v8;
  int v9;

  if (!*(_QWORD *)(a1 + 8))
    return TFSIterator::First(a1, (uint64_t)a2);
  while (1)
  {
    result = TFSIterator::NextRaw(a1, a2);
    if (!(_DWORD)result)
      break;
LABEL_7:
    if ((_DWORD)result != -8062)
      return result;
  }
  v5 = *a2;
  v6 = (os_unfair_lock_s *)(*a2 + 100);
  os_unfair_lock_lock(v6);
  v7 = *(_DWORD *)(v5 + 115);
  os_unfair_lock_unlock(v6);
  if ((v7 & 0x20) == 0)
  {
    os_unfair_lock_lock(v6);
    v8 = *(_DWORD *)(v5 + 115);
    os_unfair_lock_unlock(v6);
    if ((v8 & 0x400) == 0)
    {
      os_unfair_lock_lock(v6);
      v9 = *(_DWORD *)(v5 + 115);
      os_unfair_lock_unlock(v6);
      if ((v9 & 0x40) == 0)
      {
        result = 4294959234;
        goto LABEL_7;
      }
    }
  }
  return 0;
}

uint64_t TFSIterator::NextRaw(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  __CFError *v5;
  int v6;
  NSObject *v7;
  NSURL *v8;
  void *v9;
  int v10;
  int v11;
  NSURL *v12;
  void *v13;
  uint64_t v14;
  TCFURLInfo *v16;
  NSURL *v17;
  uint8_t buf[4];
  void *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17 = 0;
  v4 = MEMORY[0x1D17A4E00](*(_QWORD *)(a1 + 8), &v17, &v16);
  if (v4 == 1)
  {
    v10 = *(unsigned __int8 *)(a1 + 37);
    if ((IsAppInbox(v17) & 1) != 0)
      goto LABEL_14;
    v11 = TFSInfo::initialize(*a2, (const __CFURL *)v17, *(_DWORD *)(a1 + 32), 1, v10 != 0, 1, 0);
    if (v11)
    {
      if (!*(_BYTE *)(a1 + 36) || TCFURLInfo::VolumeIsAll((TCFURLInfo *)v17, (const __CFURL *)0x10000))
        goto LABEL_14;
      LogObj(4);
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        NodeEventRefFromNodeEvent((id *)&v17);
        v12 = (NSURL *)objc_claimAutoreleasedReturnValue();
        SanitizedURL(v12);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543618;
        v19 = v13;
        v20 = 1024;
        v21 = v11;
        _os_log_impl(&dword_1CBC4A000, v7, OS_LOG_TYPE_INFO, "TFSIterator initialize failed, skipping %{public}@, status = %d", buf, 0x12u);

      }
      goto LABEL_13;
    }
LABEL_16:
    v14 = 0;
    goto LABEL_17;
  }
  if (v4 != 3)
  {
    v14 = 4294965879;
    goto LABEL_17;
  }
  v6 = TCFURLInfo::TranslateCFError(v16, v5);
  if (!v6)
    goto LABEL_16;
  if (*(_BYTE *)(a1 + 36))
  {
    LogObj(4);
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = v17;
      SanitizedURL(v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543618;
      v19 = v9;
      v20 = 1024;
      v21 = v6;
      _os_log_impl(&dword_1CBC4A000, v7, OS_LOG_TYPE_INFO, "kCFURLEnumeratorError for %{public}@, status = %d", buf, 0x12u);

    }
LABEL_13:

  }
LABEL_14:
  v14 = 4294959234;
LABEL_17:
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v16);
  return v14;
}

void sub_1CBC65094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  void *v9;
  void *v10;

  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void TFSInfoOverflow::~TFSInfoOverflow(TFSInfoOverflow *this)
{
  int v2;
  uint64_t v3;

  v2 = *((unsigned __int8 *)this + 76);
  if (v2 == 2)
    goto LABEL_6;
  if (v2 == 1)
  {

LABEL_6:
    goto LABEL_7;
  }
  if (!*((_BYTE *)this + 76))
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this);
LABEL_7:

  std::unique_ptr<TFileDescriptor>::reset[abi:ne180100]((TFileDescriptor **)this + 7, 0);
  v3 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
    MEMORY[0x1D17A53D0](v3, 0x1000C40E0EAB150);
}

id DefaultContainerOfDomainWithID(const TString *a1)
{
  __CFString *v1;
  NSURL *v2;
  id v3;
  NSObject *v4;
  void *v5;
  NSURL *v6;
  NSObject *v7;
  void *v8;
  NSObject *v9;
  void *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  void *v15;
  NSURL *v16;
  id v17;
  uint8_t buf[4];
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1->fString.fRef;
  v17 = 0;
  +[FIProviderDomain rootURLForProviderDomainID:cachePolicy:error:](FIProviderDomain, "rootURLForProviderDomainID:cachePolicy:error:", v1, 1, &v17);
  v2 = (NSURL *)objc_claimAutoreleasedReturnValue();
  v3 = v17;

  if (v2)
  {
    if (IsDatalessDomain(v2, 1))
    {
      LogObj(4);
      v4 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        SanitizedURL(v2);
        v5 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        v19 = v5;
        _os_log_impl(&dword_1CBC4A000, v4, OS_LOG_TYPE_DEFAULT, "Root of iCloud Drive is dataless: %{public}@", buf, 0xCu);

      }
    }
    -[NSURL URLByAppendingPathComponent:isDirectory:](v2, "URLByAppendingPathComponent:isDirectory:", CFSTR("com~apple~CloudDocs"), 1);
    v6 = (NSURL *)objc_claimAutoreleasedReturnValue();

    if (IsDatalessDomain(v6, 0))
    {
      LogObj(4);
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        SanitizedURL(v6);
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        v19 = v8;
        _os_log_impl(&dword_1CBC4A000, v7, OS_LOG_TYPE_DEFAULT, "com~apple~CloudDocs is dataless: %{public}@", buf, 0xCu);

      }
      dispatch_get_global_queue(-2, 0);
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = MEMORY[0x1E0C809B0];
      v13 = 3321888768;
      v14 = ___ZL30DefaultContainerOfDomainWithIDRK7TString_block_invoke;
      v15 = &__block_descriptor_40_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0_e5_v8__0l;
      v16 = v6;
      dispatch_async(v9, &v12);

    }
    +[FINode fiNodeFromURL:](FINode, "fiNodeFromURL:", v6, v12, v13, v14, v15);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    LogObj(4);
    v6 = (NSURL *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(&v6->super, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1CBC4A000, &v6->super, OS_LOG_TYPE_ERROR, "No iCloud container because no domain storageURL", buf, 2u);
    }
    v10 = 0;
  }

  return v10;
}

void sub_1CBC65450(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void TNode::FindOrCreateChild(TNode *a1@<X0>, TFSInfo **a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v6;
  FINode *fFINode;
  TNode *v8;
  uint64_t v9;
  char *buffer;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  os_unfair_lock_s *v19;
  int v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  os_unfair_lock_s *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  os_unfair_lock_s *v32;
  char *v33;
  TFSInfo *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  TNode *v39;
  TGlobalNodes *v40;
  const TNode *v41;
  const void *v42;
  id v43;
  TNodePtr v44;
  uint64_t v45;
  uint64_t v46;
  TPropertyValue v47;
  FINode *v48;

  TNodePtr::TNodePtr(&v44, a1);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v47, &v44, 0);

  TChildrenList::FindRenamedChild(*((_QWORD *)a1 + 7), a2, a3);
  v6 = TNodeFromFINode(a3->fFINode);
  fFINode = a3->fFINode;
  if (v6)
  {
    v8 = (TNode *)TNodeFromFINode(fFINode);
    TNode::FetchAdditionalPropertiesForSync(v8, a2, 1);
    v44.fFINode = 0;
    v45 = 0;
    v46 = 0;
    v9 = TNodeFromFINode(a3->fFINode);
    TNode::ReconcileInternalProperties(v9, a2, &v44, 1);
    TNodeEventPtrs::SendNotifications((id **)&v44);
    v48 = (FINode *)&v44;
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v48);
    TNode::StPopulating::~StPopulating((FINode **)&v47);
    return;
  }

  TNode::StPopulating::~StPopulating((FINode **)&v47);
  TNodePtr::TNodePtr(&v44, a1);
  v47.fData.__impl_.__data = 0uLL;
  TNode::CreateNode(a3, &v44, a2, &v47);
  buffer = v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
  if (v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
  {
    v11 = (unint64_t *)(v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                             + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      (*(void (**)(char *))(*(_QWORD *)buffer + 16))(buffer);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buffer);
    }
  }

  TNode::AddChild(a1, a3);
  v13 = TNodeFromFINode(a3->fFINode);
  v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
  os_unfair_lock_lock(v14);
  v16 = *(_QWORD *)(v13 + 16);
  v15 = *(std::__shared_weak_count **)(v13 + 24);
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v14);
  v19 = (os_unfair_lock_s *)(v16 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v16 + 100));
  v20 = *(_DWORD *)(v16 + 115);
  os_unfair_lock_unlock(v19);
  if (!v15)
    goto LABEL_16;
  v21 = (unint64_t *)&v15->__shared_owners_;
  do
    v22 = __ldaxr(v21);
  while (__stlxr(v22 - 1, v21));
  if (!v22)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    if ((v20 & 0x100) == 0)
      goto LABEL_17;
  }
  else
  {
LABEL_16:
    if ((v20 & 0x100) == 0)
    {
LABEL_17:
      v23 = TNodeFromFINode(a3->fFINode);
      v24 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v23);
      os_unfair_lock_lock(v24);
      v26 = *(_QWORD *)(v23 + 16);
      v25 = *(std::__shared_weak_count **)(v23 + 24);
      if (v25)
      {
        v27 = (unint64_t *)&v25->__shared_owners_;
        do
          v28 = __ldxr(v27);
        while (__stxr(v28 + 1, v27));
        os_unfair_lock_unlock(v24);
        v29 = *(unsigned __int8 *)(v26 + 112);
        do
          v30 = __ldaxr(v27);
        while (__stlxr(v30 - 1, v27));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      else
      {
        os_unfair_lock_unlock(v24);
        v29 = *(unsigned __int8 *)(v26 + 112);
      }
      if (v29)
      {
        v39 = (TNode *)TNodeFromFINode(a3->fFINode);
        v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = 0;
        v40 = (TGlobalNodes *)TNode::CopyURL(v39, (const __CFURL **)&v47);
        v44.fFINode = (FINode *)v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
        TGlobalNodes::RootNode((uint64_t *)&v48, v40);
        v41 = (const TNode *)TNodeFromFINode(v48);
        TPropertyValue::TPropertyValue<__CFURL const*>((uint64_t)&v47, (const void **)&v44.fFINode);
        TNode::RequestInternalTask(v41, 1001, &v47, 0);
        TPropertyValue::~TPropertyValue(&v47);

        TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v44.fFINode);
      }
      return;
    }
  }
  v31 = TNodeFromFINode(a3->fFINode);
  v32 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v31);
  os_unfair_lock_lock(v32);
  v34 = *(TFSInfo **)(v31 + 16);
  v33 = *(char **)(v31 + 24);
  v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v34;
  v47.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v33;
  if (v33)
  {
    v35 = (unint64_t *)(v33 + 8);
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  os_unfair_lock_unlock(v32);
  TFSInfo::GetVolumeID(v34, &v42);
  TNode::GetVolumeNode(&v43, &v42, 0);

  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v42);
  if (v33)
  {
    v37 = (unint64_t *)(v33 + 8);
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      (*(void (**)(char *))(*(_QWORD *)v33 + 16))(v33);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v33);
    }
  }
}

void sub_1CBC6583C(_Unwind_Exception *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, TPropertyValue *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  id *v15;
  uint64_t v16;

  TPropertyValue::~TPropertyValue((TPropertyValue *)&a15);

  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a12);
  _Unwind_Resume(a1);
}

const void **TFSInfo::GetVolumeID@<X0>(TFSInfo *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  void *v5;
  const __CFURL *v6;
  CFTypeRef VolumeIdentifier;
  const void **result;
  const void *v9;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = (void *)*((_QWORD *)this + 2);
  v9 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier((TCFURLInfo *)v5, v6);
    *a2 = VolumeIdentifier;
    if (VolumeIdentifier)
      CFRetain(VolumeIdentifier);
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    result = TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
    *a2 = 0;
  }
  return result;
}

void sub_1CBC6598C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

void TNode::AddChild(TNode *this, TNodePtr *a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  int v11;
  FIProviderDomain *v12;
  void *v13;
  TNode *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  TNode *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  TNodePtr v26;
  TNodePtr v27;
  std::__shared_weak_count *v28;
  FPItem *v29;
  FINode *v30;
  FIProviderDomain *v31;
  FINode *v32;
  std::__shared_weak_count *v33;
  BOOL v34;

  v34 = 0;
  TNodePtr::TNodePtr(&v27, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v32, &v27, 0);

  TNode::AddNewChild((uint64_t *)&v27, this, a2, &v34, 0, 0);
  TNodePtr::operator=((void **)&a2->fFINode, (void **)&v27.fFINode);

  TNode::StPopulating::~StPopulating(&v32);
  if (!v34)
    return;
  v4 = TNodeFromFINode(a2->fFINode);
  v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  v6 = *(_QWORD *)(v4 + 16);
  v7 = *(std::__shared_weak_count **)(v4 + 24);
  v32 = (FINode *)v6;
  v33 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v5);
  if (*(_BYTE *)(v6 + 112) != 27)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 96));
    v10 = *(_QWORD *)(v6 + 80);
    if (v10
      && (os_unfair_lock_lock((os_unfair_lock_t)(v10 + 72)),
          v11 = *(unsigned __int8 *)(v10 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 72)),
          v11 == 1))
    {
      v12 = (FIProviderDomain *)*(id *)(v10 + 24);
    }
    else
    {
      v12 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 96));
    v31 = v12;
    if (!v12)
      goto LABEL_28;
    if (-[FIProviderDomain isUsingFPFS](v12, "isUsingFPFS"))
    {
      -[FIProviderDomain rootURL](v12, "rootURL");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v13)
      {
LABEL_27:

LABEL_28:
        v7 = v33;
        goto LABEL_29;
      }

    }
    TGlobalNodes::AllProvidersNode(&v30);
    v14 = (TNode *)TNodeFromFINode(v30);
    if ((TNode::IsInitialPopulating(v14) & 1) == 0)
    {
      TFSInfo::GetFPItem((TFSInfo *)v6);
      v29 = (FPItem *)objc_claimAutoreleasedReturnValue();
      LOBYTE(v26.fFINode) = 1;
      std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,void>(&v31, &v29, (unsigned __int8 *)&v26, &v27);
      v24 = 0;
      v25 = 0;
      TNode::CreateNode(&v26, &v30, &v27, &v24);
      v15 = v25;
      if (v25)
      {
        v16 = (unint64_t *)&v25->__shared_owners_;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      v18 = (TNode *)TNodeFromFINode(v30);
      TNode::AddChild(v18, &v26);

      v19 = v28;
      if (v28)
      {
        v20 = (unint64_t *)&v28->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }

    }
    v12 = v31;
    goto LABEL_27;
  }
LABEL_29:
  if (v7)
  {
    v22 = (unint64_t *)&v7->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v34)
    TNode::SendNotification(this, 3, (id *)&a2->fFINode, 0, 0);
}

void sub_1CBC65C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14, id a15, id a16, char a17)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a12);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void TNode::SendNotification(const TNode *a1, int a2, id *a3, int a4, int a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  TNodeEvent *v12;
  TDSNotifier **v13[3];
  TDSNotifier *v14;
  TNodePtr v15;
  std::__shared_weak_count *v16;
  TPropertyValue v17;
  id v18;
  int v19;

  v19 = a5;
  v17.fData.__impl_.__index = 0;
  std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<int const&,0,int,4ul,0>(&v17, &v19);
  v15.fFINode = 0;
  v16 = 0;
  v14 = 0;
  TNodeEvent::CreateNodeEvent(a2, a3, a4, &v17, (uint64_t *)&v15, &v14, &v18);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v14);
  v9 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  TPropertyValue::~TPropertyValue(&v17);
  v12 = (TNodeEvent *)TNodeEventPtr::operator->(&v18);
  TNodePtr::TNodePtr(&v15, a1);
  TNodeEvent::NotifyNode(v13, v12, &v15, 1);
  v17.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v13;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);

  TNodeEventPtr::~TNodeEventPtr(&v18);
}

void sub_1CBC65E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  uint64_t v14;

  TNodeEventPtr::~TNodeEventPtr((id *)(v14 - 48));
  _Unwind_Resume(a1);
}

void TNode::AddNewChild(FINode **__return_ptr a1@<X8>, TChildrenList **this@<X0>, const TNodePtr *a3@<X1>, BOOL *a4@<X2>, char a5@<W4>)
{
  uint64_t v9;
  TNode *v10;
  NSObject *v11;
  FINode *v12;
  TNode *v13;
  _QWORD block[4];
  FINode *v15;

  TChildrenList::AddNewChild(this[7], a3, a4, a1);
  if (*a4)
    goto LABEL_11;
  v9 = TNodeFromFINode(*a1);
  if (v9 != TNodeFromFINode(a3->fFINode))
  {
    v10 = (TNode *)TNodeFromFINode(a3->fFINode);
    TNode::RemoveSelf(v10, 0);
  }
  if (*a4)
  {
LABEL_11:
    if (pthread_main_np())
    {
      v11 = sFPItemsFetchingFromMainQueue;
      if (sFPItemsFetchingFromMainQueue)
      {
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3321888768;
        block[2] = ___ZN5TNode11AddNewChildERK8TNodePtrRbbb_block_invoke;
        block[3] = &__block_descriptor_40_ea8_32c47_ZTSKZN5TNode11AddNewChildERK8TNodePtrRbbbE3__0_e5_v8__0l;
        v15 = a3->fFINode;
        v12 = v15;
        dispatch_async(v11, block);

      }
    }
    else
    {
      v13 = (TNode *)TNodeFromFINode(a3->fFINode);
      TNode::AttachCreateFPItemIfNeeded(v13, a5);
    }
  }
}

void sub_1CBC65F54(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void TNode::AttachCreateFPItemIfNeeded(TNode *this, char a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  unint64_t v10;
  void *v11;
  uint64_t v12;
  TNodePtr v13;
  id v14[2];

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (!v5)
  {
    os_unfair_lock_unlock(v4);
    if (*(_BYTE *)(v6 + 112))
      return;
    goto LABEL_11;
  }
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  os_unfair_lock_unlock(v4);
  v9 = *(unsigned __int8 *)(v6 + 112);
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (!v9)
  {
LABEL_11:
    if (FPProviderDomainClass() && UseFileProviderFramework())
    {
      TNode::GetFPItem(this);
      v11 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v11)
      {
        TNodePtr::TNodePtr(&v13, this);
        v12 = 0x4014000000000000;
        TNode::UpdateFPItemIfNeeded((id *)&v13.fFINode, (double *)&v12, 1, 1, a2, v14);

      }
    }
  }
}

void sub_1CBC66088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t FPProviderDomainClass(void)
{
  return objc_opt_class();
}

void TChildrenList::AddNewChild(TChildrenList *this@<X0>, const TNodePtr *a2@<X1>, BOOL *a3@<X2>, _QWORD *a4@<X8>)
{
  id **v7;
  void **v8[3];
  void **v9[3];
  void **v10[3];
  _QWORD v11[3];
  void ***v12;

  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  std::vector<TNodePtr>::vector(v8, 1uLL, (id *)&a2->fFINode);
  *a3 = TChildrenList::AddNewChildren((uint64_t)this, (TNodePtr **)v8, 1, (uint64_t)v11, (uint64_t *)v10, (uint64_t *)v9);
  v12 = v8;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v12);
  if (*a3)
    v7 = (id **)v11;
  else
    v7 = v9;
  *a4 = **v7;
  v8[0] = (void **)v9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v8);
  v9[0] = (void **)v10;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v9);
  v10[0] = (void **)v11;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v10);
}

void sub_1CBC66190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void ****a10, uint64_t a11, uint64_t a12, void ***a13, uint64_t a14, uint64_t a15, void **a16, uint64_t a17, uint64_t a18, char a19)
{
  uint64_t v19;
  uint64_t v20;

  *(_QWORD *)(v20 - 72) = v19;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)(v20 - 72));
  a10 = &a13;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  a13 = &a16;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  a16 = (void **)&a19;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<TNodePtr>::vector(_QWORD *a1, unint64_t a2, id *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1CBC66260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::GetPermissions(uint64_t a1, int *a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  TNode *v9;
  os_unfair_lock_s *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  TFSInfo *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t IsLocked;
  std::__shared_weak_count *v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  os_unfair_lock_s *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  TFSInfo *v32;
  char v33;
  TFSInfo *v34;
  _BOOL4 v35;
  os_unfair_lock_s *v36;
  std::__shared_weak_count *v37;
  TFSInfo *v38;
  unint64_t *v39;
  unint64_t v40;
  int v41;
  unint64_t *v42;
  unint64_t v43;
  TGlobalNodes *v44;
  uint64_t v45;
  os_unfair_lock_s *v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  os_unfair_lock_s *v51;
  int v52;
  unint64_t *v53;
  unint64_t v54;
  int v55;
  os_unfair_lock_s *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  os_unfair_lock_s *v61;
  int v62;
  unint64_t *v63;
  unint64_t v64;
  char v65;
  os_unfair_lock_s *v66;
  std::__shared_weak_count *v67;
  uint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  os_unfair_lock_s *v71;
  int v72;
  unint64_t *v73;
  unint64_t v74;
  TFSInfo *v75;
  int v76;
  int v77;
  int v78;
  int CanAddFile;
  int v80;
  int v81;
  int v82;
  int v83;
  os_unfair_lock_s *v84;
  std::__shared_weak_count *v85;
  uint64_t v86;
  unint64_t *v87;
  unint64_t v88;
  os_unfair_lock_s *v89;
  int v90;
  uint64_t v91;
  const __CFString *v92;
  unint64_t *v93;
  unint64_t v94;
  int v95;
  int Property;
  BOOL v97;
  os_unfair_lock_s *v98;
  std::__shared_weak_count *v99;
  uint64_t v100;
  unint64_t *v101;
  unint64_t v102;
  os_unfair_lock_s *v103;
  int v104;
  unint64_t *v105;
  unint64_t v106;
  char v107;
  int v108;
  TNode *v109;
  TNode *v110;
  TNode *v111;
  TNode *v112;
  int IsSticky;
  TFSInfo *v114;
  _BOOL4 IsRoot;
  int v116;
  TNode *v117;
  os_unfair_lock_s *v118;
  std::__shared_weak_count *v119;
  uint64_t v120;
  unint64_t *v121;
  unint64_t v122;
  os_unfair_lock_s *v123;
  int v124;
  unint64_t *v125;
  unint64_t v126;
  TFSInfo *v127;
  uint64_t v128;
  const __CFString *v129;
  TNode *v130;
  int v131;
  TNode *v132;
  TNode *v133;
  TFSInfo *IsLocalVolume;
  _BOOL4 v135;
  TNode *v136;
  TNode *v137;
  TFSInfo *v138[2];
  uint64_t v139;
  TNodePtr v140;
  TFSInfo *v141;
  std::__shared_weak_count *v142;
  TFSInfo *v143;
  std::__shared_weak_count *v144;

  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  v141 = (TFSInfo *)v6;
  v142 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v10 = (os_unfair_lock_s *)TNode::ParentLock(v9);
  os_unfair_lock_lock(v10);
  TNodePtr::TNodePtr(&v140, *(const TNode **)(a1 + 48));
  os_unfair_lock_unlock(v10);
  v11 = *(unsigned __int8 *)(v6 + 112);
  if (v11 == 34 || v11 == 29 || v11 == 26)
  {
    v12 = *a2;
    v13 = 2147462040;
LABEL_8:
    v14 = v12 & v13;
    goto LABEL_9;
  }
  TNode::GetVolumeInfo((TNode *)a1, &v143);
  v21 = v144;
  v22 = *((unsigned __int8 *)v143 + 104);
  if (!v144)
    goto LABEL_22;
  v23 = (unint64_t *)&v144->__shared_owners_;
  do
    v24 = __ldaxr(v23);
  while (__stlxr(v24 - 1, v23));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
    if (v22)
      goto LABEL_23;
  }
  else
  {
LABEL_22:
    if (v22)
    {
LABEL_23:
      v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
      os_unfair_lock_lock(v25);
      v26 = *(std::__shared_weak_count **)(a1 + 24);
      if (v26)
      {
        v27 = (unint64_t *)&v26->__shared_owners_;
        do
          v28 = __ldxr(v27);
        while (__stxr(v28 + 1, v27));
        os_unfair_lock_unlock(v25);
        do
          v29 = __ldaxr(v27);
        while (__stlxr(v29 - 1, v27));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      else
      {
        os_unfair_lock_unlock(v25);
      }
      v12 = *a2;
      v13 = 2145978372;
      goto LABEL_8;
    }
  }
  if ((*a2 & 0x10000) != 0)
  {
    IsLocked = TNode::UserCanRead((TNode *)a1);
    if ((_DWORD)IsLocked)
      v30 = 0x10000;
    else
      v30 = 0;
    if ((*a2 & 0x2000) == 0)
      goto LABEL_33;
  }
  else
  {
    v30 = 0;
    if ((*a2 & 0x2000) == 0)
    {
LABEL_33:
      v31 = 0;
      goto LABEL_45;
    }
  }
  IsLocked = TFSInfo::IsLocked(v141);
  if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (IsLocked & 1) != 0))
  {
    v31 = 0x2000;
  }
  else
  {
    IsLocked = TNode::UserCanChangePermissions((TNode *)a1);
    v31 = 0;
    if ((_DWORD)IsLocked)
      v30 |= 0x2000u;
  }
LABEL_45:
  if ((*(_BYTE *)a2 & 8) != 0)
  {
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (_DWORD)IsLocked))
    {
      v31 |= 8u;
    }
    else
    {
      IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
      if ((_DWORD)IsLocked)
        v30 |= 8u;
    }
  }
  if ((*((_BYTE *)a2 + 2) & 0x10) != 0)
  {
    v32 = v141;
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0
      || (IsLocked = TFSInfo::LowLevelIsLockFile(v32), (IsLocked & 1) != 0)
      || (IsLocked = IsRunningInFinder(), (IsLocked & 1) != 0)
      || (v33 = atomic_load((unsigned __int16 *)(a1 + 80)), (v33 & 2) != 0))
    {
      v31 |= 0x100000u;
    }
    else
    {
      IsLocked = TNode::IsSymlink((TNode *)a1);
      if ((IsLocked & 1) == 0)
      {
        if (TNode::UserCanWriteDataFork((TNode *)a1))
        {
          IsLocked = TNode::IsVolume((TNode *)a1);
          if (!(_DWORD)IsLocked || (IsLocked = TNode::IsLocalVolume((TNode *)a1), (_DWORD)IsLocked))
            v30 |= 0x100000u;
        }
        else
        {
          IsLocked = TNode::IsLocalVolume((TNode *)a1);
          if ((_DWORD)IsLocked)
            v30 |= 0x100000u;
        }
      }
    }
  }
  if ((*(_BYTE *)a2 & 0x10) != 0)
  {
    v34 = v141;
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (_DWORD)IsLocked))
    {
      v31 |= 0x10u;
    }
    else if (*((_BYTE *)v34 + 112) == 21
           || (IsLocked = TNode::IsSymlink((TNode *)a1), (IsLocked & 1) == 0)
           && (IsLocked = TNode::UserCanWriteDataFork((TNode *)a1), (_DWORD)IsLocked)
           && ((IsLocked = TNode::IsVolume((TNode *)a1), !(_DWORD)IsLocked)
            || (IsLocked = TNode::IsLocalVolume((TNode *)a1), (_DWORD)IsLocked)))
    {
      v30 |= 0x10u;
    }
  }
  if ((*(_BYTE *)a2 & 0x20) != 0)
  {
    TNode::GetVolumeInfo((TNode *)a1, &v143);
    if (*((_BYTE *)v143 + 136))
    {
      v35 = TFSInfo::UserCanChangeLock(v141);
      IsLocked = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v143);
      if (v35)
        v30 |= 0x20u;
    }
    else
    {
      IsLocked = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v143);
    }
  }
  if ((*((_BYTE *)a2 + 1) & 2) != 0)
  {
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (_DWORD)IsLocked))
    {
      v31 |= 0x200u;
    }
    else
    {
      IsLocked = TNode::IsDeferredForSymlink(a1, (uint64_t (*)(_QWORD *))TFSInfo::IsApplication, 0);
      if ((IsLocked & 1) == 0)
      {
        IsLocked = TNode::IsAlias((TNode *)a1);
        if ((IsLocked & 1) == 0)
        {
          IsLocked = TNode::IsContainer((TNode *)a1);
          if ((IsLocked & 1) == 0)
          {
            IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
            if ((_DWORD)IsLocked)
              v30 |= 0x200u;
          }
        }
      }
    }
  }
  if ((*((_BYTE *)a2 + 2) & 2) != 0)
  {
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (_DWORD)IsLocked))
    {
      v31 |= 0x20000u;
    }
    else
    {
      IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
      if ((_DWORD)IsLocked)
        v30 |= 0x20000u;
    }
  }
  if ((*((_BYTE *)a2 + 1) & 1) != 0)
  {
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (_DWORD)IsLocked))
    {
      v31 |= 0x100u;
    }
    else
    {
      IsLocked = TNode::IsDeferredForSymlink(a1, (uint64_t (*)(_QWORD *))TFSInfo::IsApplication, 0);
      if ((_DWORD)IsLocked)
      {
        IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
        if ((_DWORD)IsLocked)
          v30 |= 0x100u;
      }
    }
  }
  if ((*((_BYTE *)a2 + 1) & 0x80) != 0)
  {
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0 || (IsLocked = IsRunningInFinder(), (_DWORD)IsLocked))
    {
      v31 |= 0x8000u;
    }
    else
    {
      IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
      if ((_DWORD)IsLocked)
        v30 |= 0x8000u;
    }
  }
  if ((*((_BYTE *)a2 + 1) & 4) != 0)
  {
    v36 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v36);
    v38 = *(TFSInfo **)(a1 + 16);
    v37 = *(std::__shared_weak_count **)(a1 + 24);
    v143 = v38;
    v144 = v37;
    if (v37)
    {
      v39 = (unint64_t *)&v37->__shared_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
    }
    os_unfair_lock_unlock(v36);
    IsLocked = TFSInfo::IsAlias(v38);
    v41 = IsLocked;
    if (v37)
    {
      v42 = (unint64_t *)&v37->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    if (v41)
    {
      IsLocked = TNode::IsSymlink((TNode *)a1);
      if ((IsLocked & 1) == 0)
      {
        IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
        if ((_DWORD)IsLocked)
        {
          IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
          if ((_DWORD)IsLocked)
            v30 |= 0x400u;
        }
      }
    }
  }
  if ((*(_BYTE *)a2 & 0x40) != 0)
  {
    IsLocked = TFSInfo::IsLocked(v141);
    if ((IsLocked & 1) != 0
      || (v44 = (TGlobalNodes *)IsRunningInFinder(), (_DWORD)v44)
      && (TGlobalNodes::BootNode((uint64_t *)&v143, v44),
          v45 = TNodeFromFINode((FINode *)v143),
          v143,
          v45 != a1))
    {
      v31 |= 0x40u;
    }
    else
    {
      IsLocked = TNode::IsContainer((TNode *)a1);
      if ((_DWORD)IsLocked)
      {
        v30 |= 0x40u;
      }
      else
      {
        IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
        if ((_DWORD)IsLocked)
        {
          IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
          if ((_DWORD)IsLocked)
            v30 |= 0x40u;
        }
      }
    }
  }
  if ((*((_BYTE *)a2 + 1) & 8) != 0)
  {
    v46 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v46);
    v48 = *(_QWORD *)(a1 + 16);
    v47 = *(std::__shared_weak_count **)(a1 + 24);
    if (v47)
    {
      v49 = (unint64_t *)&v47->__shared_owners_;
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }
    os_unfair_lock_unlock(v46);
    v51 = (os_unfair_lock_s *)(v48 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v48 + 100));
    v52 = *(_DWORD *)(v48 + 115);
    os_unfair_lock_unlock(v51);
    if (v47)
    {
      v53 = (unint64_t *)&v47->__shared_owners_;
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    if ((v52 & 0x20) != 0 || (IsLocked = TNode::AliasIsContainer((TNode *)a1), (_DWORD)IsLocked))
    {
      IsLocked = TNode::UserCanBrowse((TNode *)a1);
      if ((_DWORD)IsLocked)
        v30 |= 0x800u;
    }
  }
  v55 = *a2;
  if ((*a2 & 0x80000) != 0)
  {
    v56 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v56);
    v58 = *(_QWORD *)(a1 + 16);
    v57 = *(std::__shared_weak_count **)(a1 + 24);
    if (v57)
    {
      v59 = (unint64_t *)&v57->__shared_owners_;
      do
        v60 = __ldxr(v59);
      while (__stxr(v60 + 1, v59));
    }
    os_unfair_lock_unlock(v56);
    v61 = (os_unfair_lock_s *)(v58 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v58 + 100));
    v62 = *(_DWORD *)(v58 + 115);
    os_unfair_lock_unlock(v61);
    if (v57)
    {
      v63 = (unint64_t *)&v57->__shared_owners_;
      do
        v64 = __ldaxr(v63);
      while (__stlxr(v64 - 1, v63));
      if (!v64)
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
    }
    if ((v62 & 0x20) != 0 || (IsLocked = TNode::AliasIsContainer((TNode *)a1), (_DWORD)IsLocked))
    {
      IsLocked = TNode::UserCanListContent((TNode *)a1);
      if ((_DWORD)IsLocked)
        v30 |= 0x80000u;
    }
    v55 = *a2;
  }
  if ((v55 & 0x5004) != 0)
  {
    if (v55 < 0)
    {
      IsLocked = IsRunningInFinder();
      v65 = IsLocked ^ 1;
    }
    else
    {
      v65 = 0;
    }
    v66 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v66);
    v68 = *(_QWORD *)(a1 + 16);
    v67 = *(std::__shared_weak_count **)(a1 + 24);
    if (v67)
    {
      v69 = (unint64_t *)&v67->__shared_owners_;
      do
        v70 = __ldxr(v69);
      while (__stxr(v70 + 1, v69));
    }
    os_unfair_lock_unlock(v66);
    v71 = (os_unfair_lock_s *)(v68 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v68 + 100));
    v72 = *(_DWORD *)(v68 + 115);
    os_unfair_lock_unlock(v71);
    if (v67)
    {
      v73 = (unint64_t *)&v67->__shared_owners_;
      do
        v74 = __ldaxr(v73);
      while (__stlxr(v74 - 1, v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
    }
    if ((v72 & 0x20) != 0 || (IsLocked = TNode::AliasIsContainer((TNode *)a1), (_DWORD)IsLocked))
    {
      v75 = v141;
      IsLocked = TFSInfo::IsLocked(v141);
      if ((IsLocked & 1) == 0)
      {
        IsLocked = IsRunningInFinder();
        if ((IsLocked & 1) == 0 && *((_BYTE *)v75 + 112) != 5)
        {
          IsLocked = TFSInfo::IsResumableCopyTarget(v75);
          if ((IsLocked & 1) == 0)
          {
            v76 = *a2 & 0x1000;
            v77 = *a2 & 0x4000;
            v78 = *a2 & 4;
            if ((v65 & 1) != 0)
            {
              IsLocked = TNode::IsLocalVolume((TNode *)a1);
              if (!(_DWORD)IsLocked)
                v31 |= 0x5004u;
            }
            else
            {
              IsLocked = TNode::FetchExtendedUserAccess((TNode *)a1);
              if ((_DWORD)IsLocked)
              {
                if (TNode::IsContainer((TNode *)a1))
                  CanAddFile = TFSInfo::UserCanAddFile(v75);
                else
                  CanAddFile = 0;
                IsLocked = TNode::IsContainer((TNode *)a1);
                if ((_DWORD)IsLocked)
                  IsLocked = TFSInfo::UserCanAddFolder(v75);
                v80 = CanAddFile & IsLocked;
                if (!v76)
                  v80 = 1;
                if (v80)
                  v81 = v31;
                else
                  v81 = v31 | 0x1000;
                if (v77)
                  v82 = IsLocked;
                else
                  v82 = 1;
                if (!v82)
                  v81 |= 0x4000u;
                if (v78)
                  v83 = CanAddFile;
                else
                  v83 = 1;
                if (v83)
                  v31 = v81;
                else
                  v31 = v81 | 4;
              }
            }
            v30 |= v76 | v77 | v78;
            if (v77 && (v31 & 0x4000) == 0 || v78 && (v31 & 4) == 0)
            {
              IsLocked = TNode::IsInTrash((TNode *)a1);
              if ((_DWORD)IsLocked)
                v31 |= 0x4004u;
            }
          }
        }
      }
    }
  }
  if ((*((_BYTE *)a2 + 2) & 0x60) != 0)
  {
    v84 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v84);
    v86 = *(_QWORD *)(a1 + 16);
    v85 = *(std::__shared_weak_count **)(a1 + 24);
    if (v85)
    {
      v87 = (unint64_t *)&v85->__shared_owners_;
      do
        v88 = __ldxr(v87);
      while (__stxr(v88 + 1, v87));
    }
    v30 |= 0x600000u;
    os_unfair_lock_unlock(v84);
    v89 = (os_unfair_lock_s *)(v86 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v86 + 100));
    v90 = *(_DWORD *)(v86 + 115);
    os_unfair_lock_unlock(v89);
    if (v85)
    {
      v93 = (unint64_t *)&v85->__shared_owners_;
      do
        v94 = __ldaxr(v93);
      while (__stlxr(v94 - 1, v93));
      if (!v94)
      {
        ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
        std::__shared_weak_count::__release_weak(v85);
      }
    }
    if ((v90 & 0x100) != 0 || (IsLocked = TFSInfo::IsNoUnlinkEffective(v141, v91, v92), (_DWORD)IsLocked))
      v31 |= 0x600000u;
  }
  v95 = *a2;
  if ((*a2 & 0x800000) != 0)
  {
    v138[0] = 0;
    LODWORD(v144) = 12;
    v143 = (TFSInfo *)v138;
    v139 = 0;
    Property = TNode::GetProperty(a1, 1886675532, &v143, &v139, 0);
    if (v138[0])
      v97 = Property == 0;
    else
      v97 = 0;
    if (v97)
      v30 |= 0x800000u;
    IsLocked = (uint64_t)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v138);
    v95 = *a2;
  }
  if ((v95 & 1) != 0)
  {
    v98 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v98);
    v100 = *(_QWORD *)(a1 + 16);
    v99 = *(std::__shared_weak_count **)(a1 + 24);
    if (v99)
    {
      v101 = (unint64_t *)&v99->__shared_owners_;
      do
        v102 = __ldxr(v101);
      while (__stxr(v102 + 1, v101));
    }
    os_unfair_lock_unlock(v98);
    v103 = (os_unfair_lock_s *)(v100 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v100 + 100));
    v104 = *(_DWORD *)(v100 + 115);
    os_unfair_lock_unlock(v103);
    if (v99)
    {
      v105 = (unint64_t *)&v99->__shared_owners_;
      do
        v106 = __ldaxr(v105);
      while (__stlxr(v106 - 1, v105));
      if (!v106)
      {
        ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
        std::__shared_weak_count::__release_weak(v99);
      }
    }
    if ((v104 & 0x100) != 0)
    {
      TNode::GetVolumeInfo((TNode *)a1, &v143);
      v108 = *((unsigned __int8 *)v143 + 111);
      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v143);
      v31 |= v108;
    }
    else if ((TFSInfo::IsLocked(v141) & 1) != 0
           || TNode::LowLevelIsLockFile((TNode *)a1)
           || (v107 = atomic_load((unsigned __int16 *)(a1 + 80)), (v107 & 2) != 0))
    {
      v31 |= 1u;
    }
    v30 |= 1u;
    if ((*a2 & 0x80000000) == 0 || (TNode::IsLocalVolume((TNode *)a1) & 1) == 0)
    {
      if (!TNode::UserCanDelete((TNode *)a1)
        || TNode::IsContainer((TNode *)a1) && (TFSInfo::UserCanWrite(v141) & 1) == 0)
      {
        v116 = TNode::IsLocalVolume((TNode *)a1) ^ 1;
LABEL_260:
        v31 |= v116;
        goto LABEL_261;
      }
      if (TNodeFromFINode(v140.fFINode))
      {
        v109 = (TNode *)TNodeFromFINode(v140.fFINode);
        if (TNode::FetchExtendedUserAccess(v109))
        {
          v110 = (TNode *)TNodeFromFINode(v140.fFINode);
          TNode::GetFSInfo(v110, &v143);
          if ((TFSInfo::UserCanAddDeleteChild(v143) & 1) != 0)
          {
            v111 = (TNode *)TNodeFromFINode(v140.fFINode);
            TNode::GetFSInfo(v111, v138);
            if ((TFSInfo::IsLocked(v138[0]) & 1) == 0 && TNode::IsLocalVolume((TNode *)a1))
            {
              v112 = (TNode *)TNodeFromFINode(v140.fFINode);
              IsSticky = TNode::IsSticky(v112);
              std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v138);
              v114 = (TFSInfo *)std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v143);
              if (!IsSticky)
                goto LABEL_261;
              IsRoot = TFSInfo::UserIsRoot(v114);
              v116 = (IsRoot | TNode::UserIsOwner((TNode *)a1)) ^ 1;
              goto LABEL_260;
            }
            std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v138);
          }
          std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v143);
        }
      }
    }
  }
LABEL_261:
  if ((*(_BYTE *)a2 & 2) != 0)
  {
    v117 = (TNode *)TNodeFromFINode(v140.fFINode);
    v30 |= 2u;
    if (!v117)
      goto LABEL_283;
    v118 = (os_unfair_lock_s *)TNode::InfoLock(v117);
    os_unfair_lock_lock(v118);
    v120 = *(_QWORD *)(a1 + 16);
    v119 = *(std::__shared_weak_count **)(a1 + 24);
    if (v119)
    {
      v121 = (unint64_t *)&v119->__shared_owners_;
      do
        v122 = __ldxr(v121);
      while (__stxr(v122 + 1, v121));
    }
    os_unfair_lock_unlock(v118);
    v123 = (os_unfair_lock_s *)(v120 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v120 + 100));
    v124 = *(_DWORD *)(v120 + 115);
    os_unfair_lock_unlock(v123);
    if (v119)
    {
      v125 = (unint64_t *)&v119->__shared_owners_;
      do
        v126 = __ldaxr(v125);
      while (__stlxr(v126 - 1, v125));
      if (!v126)
      {
        ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
        std::__shared_weak_count::__release_weak(v119);
      }
    }
    if ((v124 & 0x100) != 0)
      goto LABEL_283;
    v127 = v141;
    if ((TFSInfo::IsLocked(v141) & 1) != 0)
      goto LABEL_283;
    if ((IsRunningInFinder() & 1) != 0)
      goto LABEL_283;
    if ((TFSInfo::IsNoUnlinkEffective(v127, v128, v129) & 1) != 0)
      goto LABEL_283;
    v130 = (TNode *)TNodeFromFINode(v140.fFINode);
    TNode::GetFSInfo(v130, &v143);
    v131 = TFSInfo::IsLocked(v143);
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v143);
    if (v131)
      goto LABEL_283;
    if (*a2 < 0)
    {
      if (!TNode::IsLocalVolume((TNode *)a1))
        v31 |= 2u;
      goto LABEL_284;
    }
    if (!TNode::UserCanDelete((TNode *)a1)
      || (v132 = (TNode *)TNodeFromFINode(v140.fFINode), (TNode::UserCanDeleteChild(v132) & 1) == 0))
    {
LABEL_283:
      v31 |= 2u;
    }
    else
    {
      v133 = (TNode *)TNodeFromFINode(v140.fFINode);
      if (TNode::IsSticky(v133))
      {
        IsLocalVolume = (TFSInfo *)TNode::IsLocalVolume((TNode *)a1);
        if ((_DWORD)IsLocalVolume)
        {
          v135 = TFSInfo::UserIsRoot(IsLocalVolume);
          if (!(v135 | TNode::UserIsOwner((TNode *)a1)))
            v31 |= 2u;
        }
      }
    }
  }
LABEL_284:
  if ((*((_BYTE *)a2 + 2) & 4) != 0)
  {
    if (TNodeFromFINode(v140.fFINode))
    {
      v136 = (TNode *)TNodeFromFINode(v140.fFINode);
      if (TNode::UserCanDeleteChild(v136))
      {
        v137 = (TNode *)TNodeFromFINode(v140.fFINode);
        if (TNode::IsSticky(v137))
        {
          if (TNode::UserCanDelete((TNode *)a1))
            v31 |= 0x40000u;
        }
      }
    }
  }
  v14 = v30 & ~v31 & *a2;
LABEL_9:
  *a2 = v14;
  *a2 = TNode::ApplyFPItemRestrictions(a1, v14);
  v15 = v141;
  if (TFSInfo::IsReadOnlyShare(v141))
  {
    *a2 &= 0xFFDF2FFF;
    if ((TFSInfo::IsTopLevelSharedItem(v15) & 1) == 0)
      *a2 &= 0xFFADFDDC;
  }
  TNode::ModifyPermissionsIfBusy(a1, a2);
  *a2 &= ~0x80000000;

  v16 = v142;
  if (v142)
  {
    v17 = (unint64_t *)&v142->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return 0;
}

void sub_1CBC67108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, ...)
{
  va_list va;

  va_start(va, a5);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsReadOnlyShare(TFSInfo *this)
{
  void *v2;
  void *v3;
  TString *v4;
  int v5;
  uint64_t v6;
  TString v8;
  CFStringRef theString;

  if (!UseFileProviderFramework())
    return 0;
  TFSInfo::GetFPItem(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v2)
    return 0;
  v3 = v2;
  objc_msgSend(v2, "sharingPermissions");
  v4 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&theString, v4);

  v5 = objc_msgSend(v3, "isSharedByCurrentUser");
  if (CFStringGetLength(theString))
  {
    FileProviderSharedItemPermissionsReadOnly(&v8);
    if (CFEqual(theString, v8.fString.fRef))
      v6 = v5 ^ 1u;
    else
      v6 = 0;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
  }
  else
  {
    v6 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);

  return v6;
}

void sub_1CBC672B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  void *v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

void TNode::ModifyPermissionsIfBusy(uint64_t a1, _DWORD *a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  TNode *v9;
  int v10;
  unint64_t v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  TFSInfo *v14;
  unint64_t *v15;
  unint64_t v16;
  int Type;
  unint64_t *v18;
  unint64_t v19;

  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v5)
  {
    os_unfair_lock_unlock(v4);
    if (*(_BYTE *)(v6 + 112))
      return;
    goto LABEL_11;
  }
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  os_unfair_lock_unlock(v4);
  v10 = *(unsigned __int8 *)(v6 + 112);
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (!v10)
  {
LABEL_11:
    v12 = (os_unfair_lock_s *)TNode::InfoLock(v9);
    os_unfair_lock_lock(v12);
    v14 = *(TFSInfo **)(a1 + 16);
    v13 = *(std::__shared_weak_count **)(a1 + 24);
    if (v13)
    {
      v15 = (unint64_t *)&v13->__shared_owners_;
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    os_unfair_lock_unlock(v12);
    Type = TFSInfo::GetType(v14);
    if (v13)
    {
      v18 = (unint64_t *)&v13->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (Type == 1651666795 || (Type & 0xFFFFFFE0) == 0x627A7920)
      *a2 &= 0xFFFC081A;
  }
}

void sub_1CBC6746C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::ApplyFPItemRestrictions(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  FPItem *v9;
  TFSInfo *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  NSObject *v15;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(TFSInfo **)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  *(_QWORD *)&v17 = v6;
  *((_QWORD *)&v17 + 1) = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  TFSInfo::GetFPItem(v6);
  v10 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  if (v5)
  {
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v13 = a2 & ~TFSInfo::FPItemPermissionRestrictions(v10, v9);
  if ((a2 & 0x10000) != 0 && (v13 & 0x10000) == 0)
  {
    -[TFSInfo creationDate](v10, "creationDate", v17);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v14, "isEqualToDate:", TCFURLInfo::GetMagicBusyCreationDate((TCFURLInfo *)v14)))
    {
      LogObj(2);
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v17) = 138412290;
        *(_QWORD *)((char *)&v17 + 4) = v10;
        _os_log_impl(&dword_1CBC4A000, v15, OS_LOG_TYPE_DEFAULT, "Unreadable FPItem found with busy creation date, forcing read capability to match local file: %@", (uint8_t *)&v17, 0xCu);
      }

      v13 = v13 | 0x10000;
    }
    else
    {

    }
  }

  return v13;
}

void sub_1CBC675F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t FPItemManagerInstance(void)
{
  return objc_msgSend((id)objc_opt_class(), "defaultManager");
}

id FP_ActionModifyFlags(void)
{
  return (id)*MEMORY[0x1E0CAA688];
}

id FP_ActionImportHere(void)
{
  return (id)*MEMORY[0x1E0CAA680];
}

id FP_ActionReparent(void)
{
  return (id)*MEMORY[0x1E0CAA698];
}

id FP_ActionUntrash(void)
{
  return (id)*MEMORY[0x1E0CAA6B0];
}

id FP_ActionRename(void)
{
  return (id)*MEMORY[0x1E0CAA690];
}

id FP_ActionDelete(void)
{
  return (id)*MEMORY[0x1E0CAA678];
}

id FP_ActionTrash(void)
{
  return (id)*MEMORY[0x1E0CAA6A8];
}

id FP_ActionCopy(void)
{
  return (id)*MEMORY[0x1E0CAA670];
}

id FP_ActionTag(void)
{
  return (id)*MEMORY[0x1E0CAA6A0];
}

uint64_t TFSInfo::GetType(TFSInfo *this)
{
  if (*((_BYTE *)this + 112) == 21)
    return 0;
  else
    return *((unsigned int *)this + 26);
}

unint64_t TNode::UserCanRead(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v3)
  {
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return (v8 >> 12) & 1;
}

BOOL IsLocalStorageDomainID(const TString *a1)
{
  unsigned __int8 v2;

  if ((v2 & 1) == 0
  {
    TString::TString((TString *)&IsLocalStorageDomainID(TString const&)::kLocalStorageID, "com.apple.FileProvider.LocalStorage");
  }
  return CFEqual(a1->fString.fRef, (CFTypeRef)IsLocalStorageDomainID(TString const&)::kLocalStorageID) != 0;
}

void sub_1CBC67824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TChildrenList::FindRenamedChild(uint64_t a1@<X0>, TFSInfo **a2@<X1>, TNodePtr *a3@<X8>)
{
  TFSInfo *v5;
  _BOOL4 IsFPv2;
  TFSInfo *v8;
  const void *v9;
  FINode **v10;
  FINode **v11;
  uint64_t v12;
  os_unfair_lock_s *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  const void *v18;
  unint64_t *v19;
  unint64_t v20;
  os_unfair_lock_s *v21;
  uint64_t v22;
  int v23;
  id v24;
  FINode **v25;
  FINode **v26;
  TNode *v27;
  void *v28;
  void *v29;
  int v30;
  unint64_t *v31;
  unint64_t v32;
  FPProviderDomain *v33;
  CFTypeRef cf1;
  const void *v35[2];

  v5 = *a2;
  if (!*((_BYTE *)*a2 + 112))
  {
    os_unfair_lock_lock((os_unfair_lock_t)v5 + 25);
    v9 = (const void *)*((_QWORD *)v5 + 2);
    v35[0] = v9;
    if (v9)
    {
      CFRetain(v9);
      os_unfair_lock_unlock((os_unfair_lock_t)v5 + 25);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v35);
      v10 = *(FINode ***)(a1 + 64);
      v11 = *(FINode ***)(a1 + 72);
      while (v10 != v11)
      {
        v12 = TNodeFromFINode(*v10);
        v13 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v12);
        os_unfair_lock_lock(v13);
        v15 = *(_QWORD *)(v12 + 16);
        v14 = *(std::__shared_weak_count **)(v12 + 24);
        v35[0] = (const void *)v15;
        v35[1] = v14;
        if (v14)
        {
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            v17 = __ldxr(p_shared_owners);
          while (__stxr(v17 + 1, p_shared_owners));
        }
        os_unfair_lock_unlock(v13);
        os_unfair_lock_lock((os_unfair_lock_t)(v15 + 100));
        v18 = *(const void **)(v15 + 16);
        cf1 = v18;
        if (v18)
          CFRetain(v18);
        os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 100));
        if (cf1 && CFEqual(cf1, v9))
        {
          a3->fFINode = *v10;
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf1);
          if (v14)
          {
            v31 = (unint64_t *)&v14->__shared_owners_;
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
          return;
        }
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf1);
        if (v14)
        {
          v19 = (unint64_t *)&v14->__shared_owners_;
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        ++v10;
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v5 + 25);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v35);
    }
    goto LABEL_34;
  }
  IsFPv2 = TFSInfo::IsFPv2(*a2, 1);
  v8 = *a2;
  if (!IsFPv2)
  {
    if (*((_BYTE *)v8 + 112) == 27)
    {
      v21 = (os_unfair_lock_s *)((char *)v8 + 96);
      os_unfair_lock_lock((os_unfair_lock_t)v8 + 24);
      v22 = *((_QWORD *)v8 + 10);
      if (v22
        && (os_unfair_lock_lock((os_unfair_lock_t)(v22 + 72)),
            v23 = *(unsigned __int8 *)(v22 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v22 + 72)),
            v23 == 1))
      {
        v24 = *(id *)(v22 + 24);
      }
      else
      {
        v24 = 0;
      }
      os_unfair_lock_unlock(v21);
      objc_msgSend(v24, "domain");
      v33 = (FPProviderDomain *)objc_claimAutoreleasedReturnValue();

      if (-[FPProviderDomain isiCloudDriveProvider](v33, "isiCloudDriveProvider"))
      {
        v25 = *(FINode ***)(a1 + 64);
        v26 = *(FINode ***)(a1 + 72);
        while (v25 != v26)
        {
          v27 = (TNode *)TNodeFromFINode(*v25);
          TNode::GetFIProvider(v27);
          v28 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v28, "domain");
          v29 = (void *)objc_claimAutoreleasedReturnValue();

          if (objc_msgSend(v29, "isiCloudDriveProvider"))
          {
            v30 = IsDefaultFPDomain(v33);
            if (v30 != IsDefaultFPDomain((FPProviderDomain *)v29))
            {
              a3->fFINode = *v25;

              goto LABEL_4;
            }
          }

          ++v25;
        }
      }

    }
LABEL_34:
    TNodePtr::TNodePtr(a3, 0);
    return;
  }
  TFSInfo::GetFPItem(*a2);
  v33 = (FPProviderDomain *)objc_claimAutoreleasedReturnValue();
  TChildrenList::FindByFPItem((TChildrenList *)a1, v33, a3);
LABEL_4:

}

void sub_1CBC67B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, char a10, int a11, __int16 a12, char a13, char a14)
{

  _Unwind_Resume(a1);
}

uint64_t IsDatalessDomain(NSURL *a1, int a2)
{
  const __CFString *v3;
  const __CFString *v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  NSObject *v8;
  void *v9;
  id v10;
  const __CFString *v11;
  id v12;
  NSObject *v13;
  void *v14;
  void *v15;
  void *v16;
  _QWORD v18[5];
  id v19;
  NSURL *v20;
  uint8_t buf[4];
  void *v22;
  __int16 v23;
  id v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v20 = a1;
  v3 = (const __CFString *)*MEMORY[0x1E0C9AC48];
  if ((TCFURLInfo::GetNumericalProperty((const __CFURL *)v20, (const __CFString *)*MEMORY[0x1E0C9AC48], v4) & 0x40000000) != 0)
  {
    LogObj(4);
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      SanitizedURL(v20);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      v22 = v7;
      _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_DEFAULT, "Root of domain is dataless %{public}@", buf, 0xCu);

    }
    if (!a2)
    {
      v5 = 1;
      goto LABEL_20;
    }
    LogObj(4);
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      SanitizedURL(v20);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      v22 = v9;
      _os_log_impl(&dword_1CBC4A000, v8, OS_LOG_TYPE_DEFAULT, "Forcing materialization of domain %{public}@", buf, 0xCu);

    }
    v10 = objc_alloc_init(MEMORY[0x1E0CB3600]);
    v19 = 0;
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3321888768;
    v18[2] = ___Z16IsDatalessDomainP5NSURLb_block_invoke;
    v18[3] = &__block_descriptor_40_ea8_32c37_ZTSKZ16IsDatalessDomainP5NSURLbE3__0_e15_v16__0__NSURL_8l;
    v18[4] = &v20;
    objc_msgSend(v10, "coordinateReadingItemAtURL:options:error:byAccessor:", v20, 1, &v19, v18);
    v12 = v19;
    if (v12)
    {
      LogObj(4);
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        SanitizedURL(v20);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543618;
        v22 = v14;
        v23 = 2114;
        v24 = v12;
        _os_log_impl(&dword_1CBC4A000, v13, OS_LOG_TYPE_ERROR, "Failed to materialize domain root %{public}@ with error: %{public}@", buf, 0x16u);

      }
    }
    else
    {
      if ((TCFURLInfo::GetNumericalProperty((const __CFURL *)v20, v3, v11) & 0x40000000) == 0)
      {
        LogObj(4);
        v13 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          SanitizedURL(v20);
          v15 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543362;
          v22 = v15;
          _os_log_impl(&dword_1CBC4A000, v13, OS_LOG_TYPE_DEFAULT, "Materialized domain %{public}@", buf, 0xCu);

        }
        v5 = 0;
        goto LABEL_19;
      }
      LogObj(4);
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        SanitizedURL(v20);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        v22 = v16;
        _os_log_impl(&dword_1CBC4A000, v13, OS_LOG_TYPE_DEFAULT, "Failed to materialize domain %{public}@ without error", buf, 0xCu);

      }
    }
    v5 = 1;
LABEL_19:

    goto LABEL_20;
  }
  v5 = 0;
LABEL_20:

  return v5;
}

void sub_1CBC67EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

unint64_t TNode::IsInitialPopulating(TNode *this)
{
  char v1;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  os_unfair_lock_s *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v1 = atomic_load((unsigned __int16 *)this + 40);
  if ((v1 & 8) == 0)
    return 0;
  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v9 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  v10 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
  os_unfair_lock_unlock(v9);
  if (v5)
  {
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return (v10 >> 5) & 1;
}

void TNode::GetVolumeNode(const void **a1@<X0>, TNodePtr *a2@<X8>)
{
  uint64_t v4;
  FINode ***v5;
  FINode **v6;
  FINode **v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  TFSInfo *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  TNode *v16;
  unint64_t v17;
  CFTypeRef cf1;
  FINode *v19[3];
  TNodePtr v20;

  TGlobalNodes::RootNode((uint64_t *)&v20);
  if (TNodeFromFINode(v20.fFINode))
  {
    TNode::StPopulating::StPopulating((TNode::StPopulating *)v19, &v20, 0);
    v4 = *(_QWORD *)(TNodeFromFINode(v20.fFINode) + 56);
    if (v4)
      v5 = (FINode ***)(v4 + 64);
    else
      v5 = (FINode ***)&TNode::GetChildren(void)const::sEmptyList;
    v6 = *v5;
    v7 = v5[1];
    while (1)
    {
      if (v6 == v7)
      {
        TNode::StPopulating::~StPopulating(v19);
        break;
      }
      v8 = TNodeFromFINode(*v6);
      v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
      os_unfair_lock_lock(v9);
      v11 = *(TFSInfo **)(v8 + 16);
      v10 = *(std::__shared_weak_count **)(v8 + 24);
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v9);
      TFSInfo::GetVolumeID(v11, &cf1);
      if (v10)
      {
        v14 = (unint64_t *)&v10->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      v16 = (TNode *)TNodeFromFINode(*v6);
      if (!TNode::VirtualType(v16))
      {
        v17 = (unint64_t)*a1;
        if (cf1 && v17)
        {
          if (CFEqual(cf1, (CFTypeRef)v17))
            goto LABEL_25;
        }
        else if (!((unint64_t)cf1 | v17))
        {
LABEL_25:
          a2->fFINode = *v6;
          TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf1);
          TNode::StPopulating::~StPopulating(v19);
          goto LABEL_24;
        }
      }
      TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf1);
      ++v6;
    }
  }
  TNodePtr::TNodePtr(a2, 0);
LABEL_24:

}

void sub_1CBC681CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, FINode *a13, uint64_t a14, uint64_t a15, id a16)
{
  TNode::StPopulating::~StPopulating(&a13);

  _Unwind_Resume(a1);
}

id TGlobalNodes::AllProvidersNode@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  id result;
  _QWORD block[5];

  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes16AllProvidersNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::AllProvidersNode(void)::onceToken != -1)
    dispatch_once(&TGlobalNodes::AllProvidersNode(void)::onceToken, block);
  result = *(id *)(v3 + 96);
  *a1 = result;
  return result;
}

void TNode::RemoveSelf(TNode *this, TNodeEventPtrs *a2)
{
  os_unfair_lock_s *v4;
  TNode *v5;
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  os_unfair_lock_s *v11;
  unint64_t v12;
  TNode *v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  FINode *v16;
  unint64_t *v17;
  unint64_t v18;
  _BOOL4 IsAlias;
  _BOOL4 v20;
  unint64_t *v21;
  unint64_t v22;
  TNode *v23;
  os_unfair_lock_s *v24;
  int v25;
  TNode *v26;
  TNode *v27;
  os_unfair_lock_s *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  os_unfair_lock_s *v33;
  uint64_t v34;
  unsigned int v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  void *v39;
  void *v40;
  TGlobalNodes *v41;
  TNode *v42;
  os_unfair_lock_s *v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  os_unfair_lock_s *v48;
  int v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  unsigned __int8 v53;
  NSObject *v54;
  FINode *v55;
  uint64_t v56;
  _BOOL4 v57;
  _BOOL4 v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  NSObject *v62;
  TNodePtr v63;
  TNodePtr v64;
  _QWORD block[4];
  FINode *v66;
  BOOL v67;
  TNodePtr v68;
  FINode *v69;
  uint64_t v70;
  std::__shared_weak_count *v71;
  FINode *v72[3];
  TNodePtr v73;
  TNodePtr v74;
  std::__shared_weak_count *v75;

  v4 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v4);
  TNodePtr::TNodePtr(&v73, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v4);
  v5 = (TNode *)TNode::StPopulating::StPopulating((TNode::StPopulating *)v72, &v73, 0);
  v6 = (os_unfair_lock_s *)TNode::InfoLock(v5);
  os_unfair_lock_lock(v6);
  v8 = *((_QWORD *)this + 2);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v70 = v8;
  v71 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v6);
  v11 = (os_unfair_lock_s *)(v8 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  v12 = *(unsigned int *)(v8 + 115) | ((unint64_t)*(unsigned __int16 *)(v8 + 119) << 32);
  os_unfair_lock_unlock(v11);
  if ((v12 & 0x100000000) != 0)
    goto LABEL_47;
  TNodePtr::TNodePtr(&v74, this);

  v14 = (os_unfair_lock_s *)TNode::InfoLock(v13);
  os_unfair_lock_lock(v14);
  v16 = (FINode *)*((_QWORD *)this + 2);
  v15 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v74.fFINode = v16;
  v75 = v15;
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v14);
  IsAlias = TFSInfo::IsAlias((TFSInfo *)v16);
  v20 = IsAlias;
  if (!v15)
    goto LABEL_12;
  v21 = (unint64_t *)&v15->__shared_owners_;
  do
    v22 = __ldaxr(v21);
  while (__stlxr(v22 - 1, v21));
  if (v22)
  {
LABEL_12:
    if (!IsAlias)
      goto LABEL_14;
    goto LABEL_13;
  }
  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
  std::__shared_weak_count::__release_weak(v15);
  if (v20)
LABEL_13:
    TNode::ClearAliasTarget(this, 0);
LABEL_14:
  TNodePtr::TNodePtr(&v74, 0);
  v24 = (os_unfair_lock_s *)TNode::ParentLock(v23);
  os_unfair_lock_lock(v24);
  *((_QWORD *)this + 6) = TNodeFromFINode(v74.fFINode);
  os_unfair_lock_unlock(v24);

  os_unfair_lock_lock((os_unfair_lock_t)(v70 + 100));
  v25 = *(_DWORD *)(v70 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v70 + 100));
  if ((v25 & 4) != 0)
    TDeviceManagementMonitor::UnRegisterApp(this, v27);
  v28 = (os_unfair_lock_s *)TNode::InfoLock(v26);
  os_unfair_lock_lock(v28);
  v30 = *((_QWORD *)this + 2);
  v29 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v29)
  {
    v31 = (unint64_t *)&v29->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  os_unfair_lock_unlock(v28);
  if (!*(_BYTE *)(v30 + 112))
  {
    v33 = (os_unfair_lock_s *)(v30 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v30 + 100));
    v35 = *(_DWORD *)(v30 + 115);
    v34 = v30 + 115;
    v36 = v35 | ((unint64_t)*(unsigned __int16 *)(v34 + 4) << 32) | 0x100000000;
    *(_DWORD *)v34 = v35;
    *(_WORD *)(v34 + 4) = WORD2(v36);
    os_unfair_lock_unlock(v33);
  }
  if (v29)
  {
    v37 = (unint64_t *)&v29->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if (TNodeFromFINode(v73.fFINode))
  {
    TNodePtr::TNodePtr(&v74, this);
    +[FIPresentationNodeMap shared](FIPresentationNodeMap, "shared");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    FINodeFromTNode(this);
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v39, "unregisterAllForPresentationNode:", v40);

    v42 = (TNode *)TGlobalNodes::RootNode((uint64_t *)&v69, v41);
    v43 = (os_unfair_lock_s *)TNode::InfoLock(v42);
    os_unfair_lock_lock(v43);
    v45 = *((_QWORD *)this + 2);
    v44 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    if (v44)
    {
      v46 = (unint64_t *)&v44->__shared_owners_;
      do
        v47 = __ldxr(v46);
      while (__stxr(v47 + 1, v46));
    }
    os_unfair_lock_unlock(v43);
    v48 = (os_unfair_lock_s *)(v45 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v45 + 100));
    v49 = *(_DWORD *)(v45 + 115);
    os_unfair_lock_unlock(v48);
    if (!v44)
      goto LABEL_34;
    v50 = (unint64_t *)&v44->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
      if ((v49 & 0x100) != 0)
      {
LABEL_35:
        v52 = TNodeFromFINode(v73.fFINode);
        if (v52 != TNodeFromFINode(v69))
        {
          if ((v53 & 1) == 0
          {
            dispatch_get_global_queue(-32768, 0);
            v62 = objc_claimAutoreleasedReturnValue();
            TNode::RemoveSelf(TNodeEventPtrs *)::sRemoveVolumeQueue = (uint64_t)dispatch_queue_create_with_target_V2("RemoveVolumeQueue", 0, v62);

          }
          TNodePtr::TNodePtr(&v68, this);
          v54 = TNode::RemoveSelf(TNodeEventPtrs *)::sRemoveVolumeQueue;
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3321888768;
          block[2] = ___ZN5TNode10RemoveSelfEP14TNodeEventPtrs_block_invoke;
          block[3] = &__block_descriptor_48_ea8_32c48_ZTSKZN5TNode10RemoveSelfEP14TNodeEventPtrsE3__0_e5_v8__0l;
          v66 = v68.fFINode;
          v67 = a2 != 0;
          v55 = v66;
          dispatch_async(v54, block);

        }
      }
    }
    else
    {
LABEL_34:
      if ((v49 & 0x100) != 0)
        goto LABEL_35;
    }
    v56 = TNodeFromFINode(v73.fFINode);
    TNodePtr::TNodePtr(&v68, this);
    v57 = TChildrenList::RemoveChild(*(TChildrenList **)(v56 + 56), &v68);

    if (a2)
      v58 = v57;
    else
      v58 = 0;
    if (v58)
    {
      TNodePtr::TNodePtr(&v64, this);
      TNodeEvent::CreateNodeEvent(4, (id *)&v64.fFINode, 0, &v68);
      TNodeEventPtrs::AddEvent(a2, &v73, (id *)&v68.fFINode);
      TNodeEventPtr::~TNodeEventPtr((id *)&v68.fFINode);

      TNodePtr::TNodePtr(&v68, this);
      TNodePtr::TNodePtr(&v63, this);
      TNodeEvent::CreateNodeEvent(1, (id *)&v63.fFINode, 0, &v64);
      TNodeEventPtrs::AddEvent(a2, &v68, (id *)&v64.fFINode);
      TNodeEventPtr::~TNodeEventPtr((id *)&v64.fFINode);

    }
  }
LABEL_47:
  v59 = v71;
  if (v71)
  {
    v60 = (unint64_t *)&v71->__shared_owners_;
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  TNode::StPopulating::~StPopulating(v72);

}

void sub_1CBC68840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  TNode::StPopulating::~StPopulating((FINode **)va1);

  _Unwind_Resume(a1);
}

uint64_t FowlerNollVoHash::hash(TString *this, const TString *a2)
{
  uint64_t v2;
  const char *v3;
  size_t i;
  uint64_t v5;

  v2 = 0xCBF29CE484222325;
  v3 = (const char *)TString::c_str(this);
  for (i = strlen(v3); i; --i)
  {
    v5 = *v3++;
    v2 = 0x100000001B3 * (v2 ^ v5);
  }
  return v2;
}

unint64_t UserDefaultsKey_(const __CFString *a1)
{
  const __CFString *v1;
  unint64_t v2;
  CFPropertyListRef v4;

  v4 = CFPreferencesCopyAppValue(a1, CFSTR("com.apple.desktopservices"));
  v1 = (const __CFString *)cf_cast<__CFString const*,void const*>(v4);
  v2 = (unint64_t)v1;
  if (v1)
    v2 = CFStringCompare(v1, CFSTR("true"), 1uLL) == kCFCompareEqualTo
      || CFStringCompare((CFStringRef)v2, CFSTR("1"), 1uLL) == kCFCompareEqualTo
      || CFStringCompare((CFStringRef)v2, CFSTR("YES"), 1uLL) == kCFCompareEqualTo;
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&v4);
  return v2;
}

void sub_1CBC68A4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::InitializeVirtualVolume(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t RootNode;
  CFTypeRef SFBrowser;
  __int128 v13;

  v13 = 0uLL;
  v4 = a1 + 56;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 56, &v13);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  *(_BYTE *)(a1 + 48) = a2;
  if (a2 > 0x21)
    goto LABEL_17;
  if (((1 << a2) & 0x5800000) != 0)
  {
    TFSVolumeInfo::SetRootDirectoryForSidebarInfo(a1, a2);
    *(_BYTE *)(a1 + 132) = 1;
    goto LABEL_18;
  }
  if (((1 << a2) & 0x380000000) == 0)
  {
LABEL_17:
    TFSVolumeInfo::SetRootDirectoryForSidebarInfo(a1, a2);
    goto LABEL_18;
  }
  SFBrowser = TFSInfo::CreateSFBrowser(a2);
  if (!SFBrowser)
    abort();
  RootNode = SFBrowserGetRootNode();
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,__SFNode *&,void>((char *)(a1 + 48), &RootNode, &v13);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v4, &v13);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(&SFBrowser);
LABEL_18:
  TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)a1);
}

void sub_1CBC68BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFolderSizingThread::TFolderSizingThread(TFolderSizingThread *this, const TFSVolumeInfo *a2)
{
  TFSInfo *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  TString *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  const char *v12;
  size_t v13;
  _QWORD *v14;
  void **v15;
  dispatch_queue_t v16;
  void *v17;
  NSObject *v18;
  NSObject *v19;
  _QWORD *v20;
  const char *v21;
  size_t v22;
  _QWORD *v23;
  void **v24;
  dispatch_queue_t v25;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31[2];
  char v32;
  void *__p[2];
  uint64_t v34;
  _QWORD v35[10];
  char v36;
  uint64_t v37;
  _QWORD v38[2];
  uint64_t v39;
  _QWORD v40[10];
  char v41;
  uint64_t v42;
  TString v43;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v43.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v4 = (TFSInfo *)*((_QWORD *)a2 + 7);
  v5 = (std::__shared_weak_count *)*((_QWORD *)a2 + 8);
  v38[0] = v4;
  v38[1] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  if (v4)
  {
    TFSInfo::Path(v4, (CFTypeRef *)__p);
    SanitizedPath((TString *)__p);
    v8 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    if ((TString *)v43.fString.fRef != v8)
      TString::SetStringRefAsImmutable(&v43, v8);

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)__p);
  }
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v38);
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v39, (uint64_t)"Slow TFolderSizingThread::GetFolderSizingQueue: '", 49);
  v12 = (const char *)TString::c_str(&v43);
  v13 = strlen(v12);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v12, v13);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"'", 1);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v40, __p);
  if (v34 >= 0)
    v15 = __p;
  else
    v15 = (void **)__p[0];
  v16 = dispatch_queue_create((const char *)v15, 0);
  v17 = *(void **)this;
  *(_QWORD *)this = v16;

  if (SHIBYTE(v34) < 0)
    operator delete(__p[0]);
  v18 = *(NSObject **)this;
  dispatch_get_global_queue(-32768, 0);
  v19 = objc_claimAutoreleasedReturnValue();
  dispatch_set_target_queue(v18, v19);

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__p);
  v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"Fast TFolderSizingThread::GetFolderSizingQueue: '", 49);
  v21 = (const char *)TString::c_str(&v43);
  v22 = strlen(v21);
  v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)v21, v22);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"'", 1);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v35, v31);
  if (v32 >= 0)
    v24 = v31;
  else
    v24 = (void **)v31[0];
  v25 = dispatch_queue_create((const char *)v24, 0);
  v26 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v25;

  if (v32 < 0)
    operator delete(v31[0]);
  v27 = (void *)*MEMORY[0x1E0DE4F50];
  __p[0] = v27;
  v28 = *(void **)(MEMORY[0x1E0DE4F50] + 64);
  v29 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(void **)((char *)__p + *((_QWORD *)v27 - 3)) = v28;
  v30 = MEMORY[0x1E0DE4FB8] + 16;
  v34 = v29;
  v35[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v36 < 0)
    operator delete((void *)v35[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D17A5364](&v37);
  v38[0] = v27;
  *(_QWORD *)((char *)v38 + *((_QWORD *)v27 - 3)) = v28;
  v39 = v29;
  v40[0] = v30;
  if (v41 < 0)
    operator delete((void *)v40[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D17A5364](&v42);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
}

void sub_1CBC68EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  id *v48;
  void *v49;
  uint64_t v50;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a13);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a48);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v50 - 96));

  _Unwind_Resume(a1);
}

TString *TFSInfo::CopyTagsForPath(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  void *v3;
  TString *v4;
  const char *v5;
  ssize_t v6;
  unsigned __int8 v7;
  void *v8;
  uint64_t v9;
  const __CFData *v10;
  void *v11;
  id v12;
  TString *v13;
  char v14;
  NSObject *v15;
  TString *v16;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  const __CFData *v23;
  UInt8 *bytes;
  UInt8 *v25;
  CFStringRef theString;
  CFPropertyListRef v27;
  void *v28;
  uint8_t buf[4];
  id v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = (void *)*((_QWORD *)this + 2);
  v28 = v3;
  if (v3)
  {
    CFRetain(v3);
    os_unfair_lock_unlock(v2);
    v27 = 0;
    if ((objc_msgSend(v28, "isFileURL") & 1) == 0)
    {
      v4 = 0;
      goto LABEL_24;
    }
    objc_msgSend(v28, "path");
    v4 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&theString, v4);

    if (!CFStringGetLength(theString))
    {
LABEL_20:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      v16 = (TString *)cf_cast<__CFArray const*,void const*>(v27);
      v4 = v16;
      if (v16)
        CFRetain(v16);
      bytes = 0;
      TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&bytes);
      goto LABEL_24;
    }
    std::vector<unsigned char>::vector(&bytes, 0x100uLL);
    v5 = (const char *)TString::c_str((TString *)&theString);
    v6 = getxattr(v5, "com.apple.metadata:_kMDItemUserTags", bytes, v25 - bytes, 0, 1);
    if (v6 >= 1)
    {
      v4 = (TString *)*MEMORY[0x1E0C9AE00];
      v23 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, v6, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      v27 = CFPropertyListCreateWithData((CFAllocatorRef)v4, v23, 0, 0, 0);
      if (cf_cast<__CFDictionary const*,void const*>(v27))
      {
        {
          v18 = (void *)MEMORY[0x1E0C99E60];
          v19 = objc_opt_class();
          v20 = objc_opt_class();
          v21 = objc_opt_class();
          objc_msgSend(v18, "setWithObjects:", v19, v20, v21, objc_opt_class(), 0);
          TFSInfo::CopyTagsForPath(void)const::classes = objc_claimAutoreleasedReturnValue();
        }
        v8 = (void *)MEMORY[0x1E0CB3710];
        v9 = TFSInfo::CopyTagsForPath(void)const::classes;
        v10 = v23;
        v22 = 0;
        objc_msgSend(v8, "unarchivedObjectOfClasses:fromData:error:", v9, v10, &v22);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v12 = v22;
        objc_cast<NSArray,objc_object * {__strong}>(v11);
        v4 = (TString *)objc_claimAutoreleasedReturnValue();

        if (v4)
        {
          TFSInfo::WriteTagsForPath(this, (const __CFArray *)v4);
          v13 = v4;
        }
        else
        {
          LogObj(5);
          v15 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v30 = v12;
            _os_log_impl(&dword_1CBC4A000, v15, OS_LOG_TYPE_ERROR, "Failed to unarchive tag array: %@", buf, 0xCu);
          }

        }
        TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v23);
        v14 = 0;
        goto LABEL_17;
      }
      TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v23);
    }
    v14 = 1;
LABEL_17:
    if (bytes)
    {
      v25 = bytes;
      operator delete(bytes);
    }
    if ((v14 & 1) != 0)
      goto LABEL_20;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
LABEL_24:
    TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&v27);
    goto LABEL_25;
  }
  os_unfair_lock_unlock(v2);
  v4 = 0;
LABEL_25:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v28);
  return v4;
}

void sub_1CBC692F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, uint64_t a17, const void *a18, const void *a19, const void *a20)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a14);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a18);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&a19);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a20);
  _Unwind_Resume(a1);
}

uint64_t TString::c_str(TString *this)
{
  return -[__CFString UTF8String](objc_retainAutorelease(objc_retainAutorelease(this->fString.fRef)), "UTF8String");
}

const void **TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void *cf_cast<__CFArray const*,void const*>(const void *result)
{
  const void *v1;
  CFTypeID v2;
  CFTypeID v3;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFArrayGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

void TFSVolumeInfo::SetDeviceThreads(TFSVolumeInfo *this)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  const TFSVolumeInfo *v51;
  TFSVolumeInfo *v52;
  std::__shared_weak_count *v53;
  __int128 v54;
  const TFSVolumeInfo *v55;
  std::__shared_weak_count *v56;

  if (!TFSVolumeInfo::gFullEnvironment)
    return;
  if (!*((_BYTE *)this + 48))
  {
    if (*((_BYTE *)this + 107))
    {
      TFSVolumeInfo::CopyVolumeInfos(this, (uint64_t)&v54);
      v11 = (_QWORD *)v54;
      if ((_QWORD)v54 != *((_QWORD *)&v54 + 1))
      {
        while (!*(_BYTE *)(*v11 + 107) || *(unsigned __int8 *)(*v11 + 48) != *((unsigned __int8 *)this + 48))
        {
          v11 += 2;
          if (v11 == *((_QWORD **)&v54 + 1))
            goto LABEL_59;
        }
      }
      if (v11 == *((_QWORD **)&v54 + 1))
      {
LABEL_59:
        v55 = 0;
        v56 = 0;
        v52 = (TFSVolumeInfo *)&v54;
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
      }
      else
      {
        v13 = *v11;
        v12 = (std::__shared_weak_count *)v11[1];
        if (v12)
        {
          p_shared_owners = (unint64_t *)&v12->__shared_owners_;
          do
            v15 = __ldxr(p_shared_owners);
          while (__stxr(v15 + 1, p_shared_owners));
        }
        v55 = (const TFSVolumeInfo *)v13;
        v56 = v12;
        v52 = (TFSVolumeInfo *)&v54;
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
        if (v13)
        {
          v16 = *(_QWORD *)(v13 + 328);
          *(_QWORD *)&v54 = *(_QWORD *)(v13 + 320);
          *((_QWORD *)&v54 + 1) = v16;
          if (v16)
          {
            v17 = (unint64_t *)(v16 + 8);
            do
              v18 = __ldxr(v17);
            while (__stxr(v18 + 1, v17));
          }
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 320, &v54);
          v19 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
          if (*((_QWORD *)&v54 + 1))
          {
            v20 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
            do
              v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
          if (!*((_QWORD *)this + 40))
          {
            v52 = this;
            std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v52, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kSynchingQueueName, &v54);
            std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 320, &v54);
            v45 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
            if (*((_QWORD *)&v54 + 1))
            {
              v46 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
              do
                v47 = __ldaxr(v46);
              while (__stlxr(v47 - 1, v46));
              if (!v47)
              {
                ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                std::__shared_weak_count::__release_weak(v45);
              }
            }
          }
          v22 = *((_QWORD *)v55 + 43);
          *(_QWORD *)&v54 = *((_QWORD *)v55 + 42);
          *((_QWORD *)&v54 + 1) = v22;
          if (v22)
          {
            v23 = (unint64_t *)(v22 + 8);
            do
              v24 = __ldxr(v23);
            while (__stxr(v24 + 1, v23));
          }
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 336, &v54);
          v25 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
          if (*((_QWORD *)&v54 + 1))
          {
            v26 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
            do
              v27 = __ldaxr(v26);
            while (__stlxr(v27 - 1, v26));
            if (!v27)
            {
              ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
              std::__shared_weak_count::__release_weak(v25);
            }
          }
          if (!*((_QWORD *)this + 42))
          {
            v52 = this;
            std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v52, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kPropertyQueueName, &v54);
            std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 336, &v54);
            v48 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
            if (*((_QWORD *)&v54 + 1))
            {
              v49 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
              do
                v50 = __ldaxr(v49);
              while (__stlxr(v50 - 1, v49));
              if (!v50)
              {
                ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
                std::__shared_weak_count::__release_weak(v48);
              }
            }
          }
          v28 = *((_QWORD *)v55 + 45);
          *(_QWORD *)&v54 = *((_QWORD *)v55 + 44);
          *((_QWORD *)&v54 + 1) = v28;
          if (v28)
          {
            v29 = (unint64_t *)(v28 + 8);
            do
              v30 = __ldxr(v29);
            while (__stxr(v30 + 1, v29));
          }
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 352, &v54);
          v31 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
          if (*((_QWORD *)&v54 + 1))
          {
            v32 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
            do
              v33 = __ldaxr(v32);
            while (__stlxr(v33 - 1, v32));
            if (!v33)
            {
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
            }
          }
          if (*((_QWORD *)this + 44))
            goto LABEL_76;
          v52 = this;
          std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>((const TFSVolumeInfo **)&v52, &v54);
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 352, &v54);
          v34 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
          if (!*((_QWORD *)&v54 + 1))
            goto LABEL_76;
          v35 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
          do
            v36 = __ldaxr(v35);
          while (__stlxr(v36 - 1, v35));
          goto LABEL_74;
        }
      }
    }
    else
    {
      v55 = 0;
      v56 = 0;
    }
    v52 = this;
    std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v52, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kSynchingQueueName, &v54);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 320, &v54);
    v37 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
    if (*((_QWORD *)&v54 + 1))
    {
      v38 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    v52 = this;
    std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v52, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kPropertyQueueName, &v54);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 336, &v54);
    v40 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
    if (*((_QWORD *)&v54 + 1))
    {
      v41 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
    v52 = this;
    std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>((const TFSVolumeInfo **)&v52, &v54);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 352, &v54);
    v34 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
    if (!*((_QWORD *)&v54 + 1))
      goto LABEL_76;
    v43 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v36 = __ldaxr(v43);
    while (__stlxr(v36 - 1, v43));
LABEL_74:
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
LABEL_76:
    v8 = v56;
    if (!v56)
      return;
    v44 = (unint64_t *)&v56->__shared_owners_;
    do
      v10 = __ldaxr(v44);
    while (__stlxr(v10 - 1, v44));
    goto LABEL_79;
  }
  v55 = this;
  std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>(&v55, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kSynchingQueueName, &v54);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)this + 40, (uint64_t *)&v54);
  v52 = this;
  std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v52, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kPropertyQueueName, &v55);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)this + 42, (uint64_t *)&v55);
  v51 = this;
  std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>(&v51, &v52);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)this + 44, (uint64_t *)&v52);
  v2 = v53;
  if (v53)
  {
    v3 = (unint64_t *)&v53->__shared_owners_;
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = v56;
  if (v56)
  {
    v6 = (unint64_t *)&v56->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
  if (*((_QWORD *)&v54 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
LABEL_79:
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_1CBC69A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void TVolumeSyncThread::TVolumeSyncThread(TVolumeSyncThread *this, const TFSVolumeInfo *a2, const char *a3)
{
  TFSInfo *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  TString *v10;
  unint64_t *v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t v15;
  void *v16;
  size_t v17;
  _QWORD *v18;
  const char *v19;
  uint64_t v20;
  _QWORD *v21;
  const char *v22;
  size_t v23;
  _QWORD *v24;
  void **v25;
  dispatch_queue_t v26;
  void *v27;
  uint64_t v28;
  void *__p[2];
  char v30;
  _QWORD v31[2];
  uint64_t v32;
  _QWORD v33[10];
  char v34;
  uint64_t v35;
  TString v36;

  *(_DWORD *)((char *)this + 7) = 0;
  *(_QWORD *)this = 0;
  *((_BYTE *)this + 8) = *((_BYTE *)a2 + 48);
  *((_BYTE *)this + 10) = *((_BYTE *)a2 + 120);
  v36.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v6 = (TFSInfo *)*((_QWORD *)a2 + 7);
  v7 = (std::__shared_weak_count *)*((_QWORD *)a2 + 8);
  v31[0] = v6;
  v31[1] = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  if (v6)
  {
    TFSInfo::Path(v6, (CFTypeRef *)__p);
    SanitizedPath((TString *)__p);
    v10 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    if ((TString *)v36.fString.fRef != v10)
      TString::SetStringRefAsImmutable(&v36, v10);

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)__p);
  }
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v13 = *((unsigned __int8 *)this + 8);
  if (v13 > 0x21 || ((1 << v13) & 0x39DE00000) == 0)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v31);
    v17 = strlen(a3);
    v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v32, (uint64_t)a3, v17);
    if (*((_BYTE *)this + 10))
      v19 = " (boot) '";
    else
      v19 = " '";
    if (*((_BYTE *)this + 10))
      v20 = 9;
    else
      v20 = 2;
    v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v19, v20);
    v22 = (const char *)TString::c_str(&v36);
    v23 = strlen(v22);
    v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v22, v23);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"'", 1);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v33, __p);
    if (v30 >= 0)
      v25 = __p;
    else
      v25 = (void **)__p[0];
    v26 = dispatch_queue_create((const char *)v25, 0);
    v27 = *(void **)this;
    *(_QWORD *)this = v26;

    if (v30 < 0)
      operator delete(__p[0]);
    v31[0] = *MEMORY[0x1E0DE4F50];
    v28 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    *(_QWORD *)((char *)v31 + *(_QWORD *)(v31[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v32 = v28;
    v33[0] = MEMORY[0x1E0DE4FB8] + 16;
    if (v34 < 0)
      operator delete((void *)v33[8]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1D17A5364](&v35);
  }
  else
  {
    TFSVolumeInfo::GetDedicatedGCDQueue(v13);
    v15 = objc_claimAutoreleasedReturnValue();
    v16 = *(void **)this;
    *(_QWORD *)this = v15;

  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v36.fString.fRef);
}

void sub_1CBC69CC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  id *v4;
  uint64_t v5;
  va_list va;

  va_start(va, a4);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v5 - 64));

  _Unwind_Resume(a1);
}

const void **TFSInfo::Path@<X0>(TFSInfo *this@<X0>, CFTypeRef *a2@<X8>)
{
  TString v4;
  const void *v5[2];

  TFSInfo::GetPath(this, (uint64_t)v5);
  TString::TString(&v4, "", 0);
  fstd::optional_err<TString,int>::value_or<TString>((uint64_t)v5, (CFTypeRef *)&v4.fString.fRef, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
}

void sub_1CBC69D94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

const void **TFSInfo::GetPath@<X0>(TFSInfo *this@<X0>, uint64_t a2@<X8>)
{
  os_unfair_lock_s *v4;
  void *v5;
  int v7;
  TString v8;
  CFStringRef theString;
  const void *v10;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = (void *)*((_QWORD *)this + 2);
  v10 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    TCFURLInfo::FileSystemRepresentation((TCFURLInfo *)v5, (const __CFURL *)1, (TString *)&theString);
    if (CFStringGetLength(theString))
    {
      fstd::optional_err<TString,int>::optional_err(a2, (TString **)&theString);
    }
    else
    {
      TString::TString(&v8, "");
      v7 = -43;
      fstd::optional_err<TString,int>::optional_err(a2, (CFTypeRef *)&v8.fString.fRef, &v7);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    TString::TString((TString *)&theString, "");
    LODWORD(v8.fString.fRef) = -8058;
    fstd::optional_err<TString,int>::optional_err(a2, (CFTypeRef *)&theString, &v8);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v10);
}

void sub_1CBC69EB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

CFTypeRef *fstd::optional_err<TString,int>::value_or<TString>@<X0>(uint64_t a1@<X0>, CFTypeRef *a2@<X1>, CFTypeRef *a3@<X8>)
{
  if (*(_DWORD *)(a1 + 8))
  {
    *a3 = *a2;
    *a2 = 0;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  }
  else
  {
    *a3 = *(CFTypeRef *)a1;
    *(_QWORD *)a1 = 0;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, &stru_1E8752DF8);
  }
}

TString *TCFURLInfo::FileSystemRepresentation@<X0>(TCFURLInfo *this@<X0>, const __CFURL *a2@<X1>, TString *a3@<X8>)
{
  char v5[1033];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (TCFURLInfo::GetFileSystemRepresentation(this, a2, (UInt8 *)v5, (unsigned __int8 *)0x409))
    return TString::TString(a3, v5);
  a3->fString.fRef = &stru_1E8752DF8;
  return (TString *)CFRetain(&stru_1E8752DF8);
}

uint64_t TCFURLInfo::GetFileSystemRepresentation(TCFURLInfo *this, const __CFURL *a2, UInt8 *a3, unsigned __int8 *a4)
{
  Boolean v6;
  uint64_t result;

  v6 = a2;
  result = _CFURLIsFileURL();
  if ((_DWORD)result)
    return CFURLGetFileSystemRepresentation(this, v6, a3, (CFIndex)a4) != 0;
  return result;
}

uint64_t fstd::optional_err<TString,int>::optional_err(uint64_t a1, TString **a2)
{
  *(_QWORD *)a1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void sub_1CBC6A060(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t fstd::optional_err<TString,int>::optional_err(uint64_t a1, CFTypeRef *a2, _DWORD *a3)
{
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  *(_DWORD *)(a1 + 8) = *a3;
  return a1;
}

__CFString *SanitizedPath(TString *a1)
{
  TString *v1;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  TString *v9;
  uint64_t **v10;
  TString *v11;
  id v12;
  TString *v14;
  TString v15;
  id v16;
  id v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!IsRedactionEnabled())
    return objc_retainAutorelease(a1->fString.fRef);
  v14 = a1;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  -[__CFString pathComponents](objc_retainAutorelease(v14->fString.fRef), "pathComponents");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v19;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v19 != v6)
          objc_enumerationMutation(v4);
        v8 = *(void **)(*((_QWORD *)&v18 + 1) + 8 * i);
        AcceptableNames();
        v9 = v8;
        v17 = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable((TString *)&v17, v9);

        v10 = std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(AcceptableNames(void)::sNames, (TString *)&v17);
        if (!v10)
        {
          v11 = v9;
          v15.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v15, v11);

          RedactedStr(&v15, (TString *)&v16);
          v1 = (TString *)objc_retainAutorelease(v16);
          v9 = v1;
        }
        objc_msgSend(v3, "addObject:", v9);
        if (!v10)
        {

          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
    }
    while (v5);
  }

  if (objc_msgSend(v3, "count"))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "pathWithComponents:", v3);
    v12 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    RedactedStr(v14, (TString *)&v17);
    v12 = objc_retainAutorelease(v17);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
  }

  return (__CFString *)v12;
}

void sub_1CBC6A328(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void FormatDetails<std::string>(__int128 *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  unint64_t v5;
  std::string *v6;
  std::string::size_type size;
  std::string *v8;
  std::string v9;
  __int128 v10;
  std::string v11;

  memset(&v11, 0, sizeof(v11));
  v10 = *a1;
  do
  {
    v5 = FormatOneDetails<std::string>((const std::string::value_type **)&v10, &v11, a2);
    if ((_DWORD)v5)
    {
      *((_BYTE *)&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v5) == 7);
  FormatDetails(&v10, &v9);
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v11;
  else
    v6 = (std::string *)v11.__r_.__value_.__r.__words[0];
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v11.__r_.__value_.__r.__words[2]);
  else
    size = v11.__r_.__value_.__l.__size_;
  v8 = std::string::insert(&v9, 0, (const std::string::value_type *)v6, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
LABEL_13:
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
}

void sub_1CBC6A4A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v15 - 17) < 0)
    operator delete(*(void **)(v15 - 40));
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<std::string>(const std::string::value_type **a1, std::string *this, uint64_t a3)
{
  const std::string::value_type *v3;
  const std::string::value_type *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t i;
  uint64_t v12;
  unint64_t v13;
  const std::string::value_type *v14;
  BOOL v15;
  const std::string::value_type *v16;
  size_t v17;
  const void *v18;
  std::string *p_dst;
  const void *v20;
  std::string *v21;
  std::string *v22;
  std::string::size_type v23;
  uint64_t v24;
  uint64_t v25;
  std::string *v26;
  std::string::size_type size;
  uint64_t v28;
  uint64_t v29;
  std::string::size_type v30;
  std::string *v31;
  void *v32;
  const void *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  std::string *p_p;
  std::string::size_type v38;
  void *v39;
  const std::string::value_type *v40;
  const std::string::value_type *v41;
  void *v43[2];
  unint64_t v44;
  std::string __p;
  std::string __dst;
  std::string v47;
  const void *v48;
  unint64_t v49;
  unsigned int v50;

  v3 = a1[1];
  if (v3)
  {
    v7 = *a1;
    v8 = (unsigned __int8 *)&v3[(_QWORD)*a1];
    v9 = 1;
    v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1CBD2B109[i])
        {
          v12 = 0;
          v9 = 1;
          if (v10 != v8)
          {
            v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              v14 = a1[1];
              v15 = (unint64_t)v14 >= v13;
              v16 = &v14[-v13];
              if (!v15)
LABEL_102:
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&v48);
              v17 = v49;
              if (v49)
              {
                switch(v50)
                {
                  case 1u:
                  case 2u:
                  case 3u:
                    goto LABEL_99;
                  case 4u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
                      goto LABEL_103;
                    v18 = v48;
                    if (v49 >= 0x17)
                    {
                      v24 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v24 = v49 | 7;
                      v25 = v24 + 1;
                      p_dst = (std::string *)operator new(v24 + 1);
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                      __dst.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    p_dst->__r_.__value_.__s.__data_[v17] = 0;
                    std::string::basic_string[abi:ne180100]<0>(&v47, "??? (hex)");
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v26 = &v47;
                    else
                      v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    else
                      size = v47.__r_.__value_.__l.__size_;
                    goto LABEL_94;
                  case 5u:
                    if (*(char *)(a3 + 23) < 0)
                      std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
                    else
                      __dst = *(std::string *)a3;
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v26 = &v47;
                    else
                      v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    else
                      size = v47.__r_.__value_.__l.__size_;
                    goto LABEL_94;
                  case 6u:
                    if (*(char *)(a3 + 23) < 0)
                      std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
                    else
                      __dst = *(std::string *)a3;
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v26 = &v47;
                    else
                      v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    else
                      size = v47.__r_.__value_.__l.__size_;
                    goto LABEL_94;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&v48, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v22 = &v47;
                    else
                      v22 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v23 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    else
                      v23 = v47.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v22, v23);
                    goto LABEL_71;
                  case 8u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
LABEL_103:
                      std::string::__throw_length_error[abi:ne180100]();
                    v20 = v48;
                    if (v49 >= 0x17)
                    {
                      v28 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v28 = v49 | 7;
                      v29 = v28 + 1;
                      v21 = (std::string *)operator new(v28 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v29 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
                      v21 = &__dst;
                    }
                    memmove(v21, v20, v17);
                    v21->__r_.__value_.__s.__data_[v17] = 0;
                    ExtractEmbeddedFormat(&__dst, &v47);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    v30 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    v31 = &v47;
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      v30 = v47.__r_.__value_.__l.__size_;
                      v31 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v31;
                    __p.__r_.__value_.__l.__size_ = v30;
                    FormatDetails<std::string>(&__dst, &__p, a3);
                    v32 = (void *)v49;
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v33 = v48;
                    if (v49 >= 0x17)
                    {
                      v35 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v35 = v49 | 7;
                      v36 = v35 + 1;
                      v34 = operator new(v35 + 1);
                      v43[1] = v32;
                      v44 = v36 | 0x8000000000000000;
                      v43[0] = v34;
                    }
                    else
                    {
                      HIBYTE(v44) = v49;
                      v34 = v43;
                      if (!v49)
                        goto LABEL_59;
                    }
                    memmove(v34, v33, (size_t)v32);
LABEL_59:
                    *((_BYTE *)v32 + (_QWORD)v34) = 0;
                    ExtendedFormatAdaptor((char *)v43, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v38 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      v38 = __p.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)p_p, v38);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__p.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v44) < 0)
                      operator delete(v43[0]);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_71:
                    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
                    {
                      v39 = (void *)v47.__r_.__value_.__r.__words[0];
LABEL_98:
                      operator delete(v39);
                    }
LABEL_99:
                    v40 = a1[1];
                    v41 = &v40[-v49];
                    if ((unint64_t)v40 < v49)
                      goto LABEL_102;
                    v9 = 0;
                    *a1 += v49;
                    a1[1] = v41;
                    v12 = v50;
                    break;
                  default:
                    if (*(char *)(a3 + 23) < 0)
                      std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
                    else
                      __dst = *(std::string *)a3;
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v26 = &v47;
                    else
                      v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    else
                      size = v47.__r_.__value_.__l.__size_;
LABEL_94:
                    std::string::append(this, (const std::string::value_type *)v26, size);
                    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v47.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_99;
                    v39 = (void *)__dst.__r_.__value_.__r.__words[0];
                    goto LABEL_98;
                }
              }
              else
              {
                v12 = 0;
                v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8)
        continue;
      break;
    }
    v12 = 0;
  }
  else
  {
    v12 = 0;
    v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1CBC6A9FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a20 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a26 < 0)
    operator delete(a21);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

void RedactForPrivacy(uint64_t *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  if (IsRedactionEnabled() && std::string_view::find[abi:ne180100](a1, "%{public}", 9, 0))
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "<private>");
  }
  else if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
}

BOOL PrefsBool(const __CFString *a1, _BOOL8 a2)
{
  const __CFString *v3;
  CFTypeID v4;
  BOOL v5;
  CFTypeID v6;
  CFTypeID v7;
  CFStringRef theString1;

  v3 = (const __CFString *)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.desktopservices"));
  theString1 = v3;
  if (v3)
  {
    v4 = CFGetTypeID(v3);
    if (v4 == CFStringGetTypeID())
    {
      if (CFStringCompare(theString1, CFSTR("true"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare(theString1, CFSTR("1"), 1uLL) == kCFCompareEqualTo)
      {
        a2 = 1;
        goto LABEL_14;
      }
      v5 = CFStringCompare(theString1, CFSTR("YES"), 1uLL) == kCFCompareEqualTo;
    }
    else
    {
      v6 = CFGetTypeID(theString1);
      if (v6 == CFBooleanGetTypeID())
      {
        a2 = CFEqual(theString1, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
        goto LABEL_14;
      }
      v7 = CFGetTypeID(theString1);
      if (v7 != CFNumberGetTypeID())
        goto LABEL_14;
      v5 = CFEqual(theString1, &unk_1E875ADA0) == 0;
    }
    a2 = v5;
  }
LABEL_14:
  TRef<void const*,TRetainReleasePolicy<void const*>>::~TRef((const void **)&theString1);
  return a2;
}

void sub_1CBC6AC5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<void const*,TRetainReleasePolicy<void const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TRef<void const*,TRetainReleasePolicy<void const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

BOOL IsRedactionEnabled(void)
{
  unsigned __int8 v0;

  {
    IsRedactionEnabled(void)::isAppleInternal = os_variant_has_internal_ui();
  }
  if (!IsRedactionEnabled(void)::isAppleInternal)
    return 1;
  if (TCFURLInfo::gDSHelperRunning)
    return 0;
  return PrefsBool(CFSTR("EnableRedactionOnInternal"), 0);
}

void sub_1CBC6AD40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void FormatDetails(__int128 *a1@<X0>, std::string *a2@<X8>)
{
  const std::string::value_type *v3;
  std::string::size_type v4;
  unsigned __int8 *v5;
  const std::string::value_type *v6;
  uint64_t v7;
  unint64_t v8;
  size_t size;
  std::string *p_p;
  std::string::size_type v11;
  void *v12;
  const void *v13;
  void **p_dst;
  uint64_t v15;
  uint64_t v16;
  const std::string::value_type *v17;
  std::string::size_type v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  std::string::size_type v24;
  uint64_t v25;
  std::string *p_src;
  uint64_t v27;
  uint64_t v28;
  std::string *v29;
  std::string::size_type v30;
  std::string *v31;
  void *v32;
  std::string *v33;
  std::string::size_type v34;
  std::string *v35;
  __int128 v36;
  size_t v37;
  const void *v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  const std::string::value_type *v42;
  std::string::size_type v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  std::string::value_type __s[8];
  char v48;
  void **__dst;
  size_t v50;
  int64_t v51;
  std::string v52;
  std::string v53;
  std::string __p;
  std::string __src;
  __int128 v56;
  std::string v57;

  memset(&v57, 0, sizeof(v57));
  v56 = *a1;
  *((_BYTE *)&__src.__r_.__value_.__s + 23) = 3;
  LODWORD(__src.__r_.__value_.__l.__data_) = 8223525;
  v4 = *((_QWORD *)&v56 + 1);
  v3 = (const std::string::value_type *)v56;
  if (!*((_QWORD *)&v56 + 1))
    goto LABEL_53;
  while (2)
  {
    v5 = (unsigned __int8 *)&v3[v4];
    v6 = v3;
LABEL_3:
    v7 = 0;
    while (*(unsigned __int8 *)v6 != __src.__r_.__value_.__s.__data_[v7])
    {
      if (++v7 == 3)
      {
        if (++v6 != (const std::string::value_type *)v5)
          goto LABEL_3;
        goto LABEL_53;
      }
    }
    if (v6 == (const std::string::value_type *)v5)
      goto LABEL_53;
    v8 = v6 - v3;
    if (v6 - v3 == -1)
      goto LABEL_53;
    std::string::append(&v57, v3, v6 - v3);
    if (*((_QWORD *)&v56 + 1) < v8)
      std::__throw_out_of_range[abi:ne180100]("string_view::substr");
    *(_QWORD *)&v56 = v56 + v8;
    *((_QWORD *)&v56 + 1) -= v8;
    ParseFormat(&v56, (uint64_t)&__src);
    size = __src.__r_.__value_.__l.__size_;
    if (__src.__r_.__value_.__l.__size_)
    {
      if (LODWORD(__src.__r_.__value_.__r.__words[2]) == 7)
      {
        DeEscapeFormatFragment((uint64_t)&__src, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v11 = __p.__r_.__value_.__l.__size_;
        std::string::append(&v57, (const std::string::value_type *)p_p, v11);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          v12 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_50:
          operator delete(v12);
        }
      }
      else
      {
        v52.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v52.__r_.__value_.__r.__words[1] = xmmword_1CBD15380;
        strcpy(v52.__r_.__value_.__l.__data_, "(extra format specifier '");
        if (size > 0x7FFFFFFFFFFFFFF7)
          std::string::__throw_length_error[abi:ne180100]();
        v13 = (const void *)__src.__r_.__value_.__r.__words[0];
        if (size >= 0x17)
        {
          v15 = (size & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((size | 7) != 0x17)
            v15 = size | 7;
          v16 = v15 + 1;
          p_dst = (void **)operator new(v15 + 1);
          v50 = size;
          v51 = v16 | 0x8000000000000000;
          __dst = p_dst;
        }
        else
        {
          HIBYTE(v51) = size;
          p_dst = (void **)&__dst;
        }
        memmove(p_dst, v13, size);
        *((_BYTE *)p_dst + size) = 0;
        if (v51 >= 0)
          v17 = (const std::string::value_type *)&__dst;
        else
          v17 = (const std::string::value_type *)__dst;
        if (v51 >= 0)
          v18 = HIBYTE(v51);
        else
          v18 = v50;
        v19 = std::string::append(&v52, v17, v18);
        v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        v48 = 2;
        strcpy(__s, "')");
        v21 = std::string::append(&v53, __s, 2uLL);
        v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v22;
        v21->__r_.__value_.__l.__size_ = 0;
        v21->__r_.__value_.__r.__words[2] = 0;
        v21->__r_.__value_.__r.__words[0] = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v23 = &__p;
        else
          v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v24 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v24 = __p.__r_.__value_.__l.__size_;
        std::string::append(&v57, (const std::string::value_type *)v23, v24);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v48 < 0)
          operator delete(*(void **)__s);
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v53.__r_.__value_.__l.__data_);
        if (SHIBYTE(v51) < 0)
          operator delete(__dst);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
        {
          v12 = (void *)v52.__r_.__value_.__r.__words[0];
          goto LABEL_50;
        }
      }
      v25 = *((_QWORD *)&v56 + 1);
      if (*((_QWORD *)&v56 + 1) < __src.__r_.__value_.__l.__size_)
        std::__throw_out_of_range[abi:ne180100]("string_view::substr");
      v3 = (const std::string::value_type *)(v56 + __src.__r_.__value_.__l.__size_);
      *((_BYTE *)&__src.__r_.__value_.__s + 23) = 3;
      LODWORD(__src.__r_.__value_.__l.__data_) = 8223525;
      v4 = *((_QWORD *)&v56 + 1) - __src.__r_.__value_.__l.__size_;
      *(_QWORD *)&v56 = v56 + __src.__r_.__value_.__l.__size_;
      *((_QWORD *)&v56 + 1) -= __src.__r_.__value_.__l.__size_;
      if (v25 != __src.__r_.__value_.__l.__size_)
        continue;
LABEL_53:
      if (v4 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      if (v4 >= 0x17)
      {
        v27 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v4 | 7) != 0x17)
          v27 = v4 | 7;
        v28 = v27 + 1;
        p_src = (std::string *)operator new(v27 + 1);
        __src.__r_.__value_.__l.__size_ = v4;
        __src.__r_.__value_.__r.__words[2] = v28 | 0x8000000000000000;
        __src.__r_.__value_.__r.__words[0] = (std::string::size_type)p_src;
      }
      else
      {
        *((_BYTE *)&__src.__r_.__value_.__s + 23) = v4;
        p_src = &__src;
        if (!v4)
        {
LABEL_61:
          p_src->__r_.__value_.__s.__data_[v4] = 0;
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v29 = &v57;
          else
            v29 = (std::string *)v57.__r_.__value_.__r.__words[0];
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v30 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          else
            v30 = v57.__r_.__value_.__l.__size_;
          v31 = std::string::insert(&__src, 0, (const std::string::value_type *)v29, v30);
          *a2 = *v31;
          v31->__r_.__value_.__l.__size_ = 0;
          v31->__r_.__value_.__r.__words[2] = 0;
          v31->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
          {
            v32 = (void *)__src.__r_.__value_.__r.__words[0];
LABEL_69:
            operator delete(v32);
          }
          goto LABEL_70;
        }
      }
      memmove(p_src, v3, v4);
      goto LABEL_61;
    }
    break;
  }
  v52.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
  *(_OWORD *)&v52.__r_.__value_.__r.__words[1] = xmmword_1CBD15390;
  strcpy(v52.__r_.__value_.__l.__data_, "(invalid & extra format specifier: '");
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v33 = &v57;
  else
    v33 = (std::string *)v57.__r_.__value_.__r.__words[0];
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v34 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
  else
    v34 = v57.__r_.__value_.__l.__size_;
  v35 = std::string::insert(&v52, 0, (const std::string::value_type *)v33, v34);
  v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  v37 = *((_QWORD *)&v56 + 1);
  if (*((_QWORD *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL)
    std::string::__throw_length_error[abi:ne180100]();
  v38 = (const void *)v56;
  if (*((_QWORD *)&v56 + 1) >= 0x17uLL)
  {
    v40 = (*((_QWORD *)&v56 + 1) & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((*((_QWORD *)&v56 + 1) | 7) != 0x17)
      v40 = *((_QWORD *)&v56 + 1) | 7;
    v41 = v40 + 1;
    v39 = (void **)operator new(v40 + 1);
    v50 = v37;
    v51 = v41 | 0x8000000000000000;
    __dst = v39;
    goto LABEL_86;
  }
  HIBYTE(v51) = BYTE8(v56);
  v39 = (void **)&__dst;
  if (*((_QWORD *)&v56 + 1))
LABEL_86:
    memmove(v39, v38, v37);
  *((_BYTE *)v39 + v37) = 0;
  if (v51 >= 0)
    v42 = (const std::string::value_type *)&__dst;
  else
    v42 = (const std::string::value_type *)__dst;
  if (v51 >= 0)
    v43 = HIBYTE(v51);
  else
    v43 = v50;
  v44 = std::string::append(&v53, v42, v43);
  v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  v48 = 2;
  strcpy(__s, "')");
  v46 = std::string::append(&__p, __s, 2uLL);
  *a2 = *v46;
  v46->__r_.__value_.__l.__size_ = 0;
  v46->__r_.__value_.__r.__words[2] = 0;
  v46->__r_.__value_.__r.__words[0] = 0;
  if (v48 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v51) < 0)
    operator delete(__dst);
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v53.__r_.__value_.__l.__data_);
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
  {
    v32 = (void *)v52.__r_.__value_.__r.__words[0];
    goto LABEL_69;
  }
LABEL_70:
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v57.__r_.__value_.__l.__data_);
}

void sub_1CBC6B318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  uint64_t v48;

  if (a17 < 0)
    operator delete(__p);
  if (a42 < 0)
    operator delete(a37);
  if (a23 < 0)
    operator delete(a18);
  if (a35 < 0)
    operator delete(a30);
  if (a29 < 0)
    operator delete(a24);
  if (*(char *)(v48 - 89) < 0)
    operator delete(*(void **)(v48 - 112));
  _Unwind_Resume(exception_object);
}

void ParseFormat(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  uint64_t v13;
  std::match_results<const char *>::value_type *p_unmatched;
  unsigned __int8 v15;
  int v16;
  uint64_t v17;
  std::match_results<const char *>::value_type *v18;
  unsigned __int8 v19;
  uint64_t v20;
  std::match_results<const char *>::value_type *v21;
  unsigned __int8 v22;
  uint64_t v23;
  std::match_results<const char *>::value_type *v24;
  unsigned __int8 v25;
  uint64_t v26;
  std::match_results<const char *>::value_type *v27;
  unsigned __int8 v28;
  void *v29;
  uint64_t v30;
  int v31;
  const char *p_p;
  unsigned __int8 v33;
  uint64_t v34;
  std::match_results<const char *>::value_type *v35;
  unsigned __int8 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *__p;
  uint64_t v43;
  unsigned __int8 v44;
  std::match_results<const char *> v45;

  if (std::string_view::starts_with[abi:ne180100](a1, "%s", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "%@", 2uLL))
  {
    *(_QWORD *)a2 = *a1;
    *(_QWORD *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 16) = 0;
    return;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%x", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "%p", 2uLL))
  {
    *(_QWORD *)a2 = *a1;
    *(_QWORD *)(a2 + 8) = 2;
    v4 = 4;
LABEL_7:
    *(_DWORD *)(a2 + 16) = v4;
    return;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%d", 2uLL))
  {
    *(_QWORD *)a2 = *a1;
    *(_QWORD *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 16) = 2;
    return;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%f", 2uLL))
  {
    *(_QWORD *)a2 = *a1;
    *(_QWORD *)(a2 + 8) = 2;
    v4 = 1;
    goto LABEL_7;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%-@", 3uLL))
  {
    *(_QWORD *)a2 = *a1;
    *(_QWORD *)(a2 + 8) = 3;
LABEL_20:
    v4 = 5;
    goto LABEL_7;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{public}-@", 0xBuLL))
  {
    v5 = 11;
    *(_QWORD *)a2 = "%{public}-@";
LABEL_19:
    *(_QWORD *)(a2 + 8) = v5;
    goto LABEL_20;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{private}-@", 0xCuLL))
  {
    v5 = 12;
    *(_QWORD *)a2 = "%{private}-@";
    goto LABEL_19;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%l@", 3uLL))
  {
    v6 = 3;
    *(_QWORD *)a2 = "%-@";
LABEL_27:
    *(_QWORD *)(a2 + 8) = v6;
    v4 = 6;
    goto LABEL_7;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{public}l@", 0xBuLL))
  {
    v6 = 11;
    *(_QWORD *)a2 = "%{public}-@";
    goto LABEL_27;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{private}l@", 0xCuLL))
  {
    v6 = 12;
    *(_QWORD *)a2 = "%{private}-@";
    goto LABEL_27;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%%", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "{{", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "}}", 2uLL))
  {
    *(_QWORD *)a2 = *a1;
    *(_QWORD *)(a2 + 8) = 2;
    v4 = 7;
    goto LABEL_7;
  }
  memset(&v45.__prefix_, 0, 17);
  memset(&v45.__suffix_, 0, 17);
  v45.__ready_ = 0;
  v45.__position_start_ = 0;
  memset(&v45, 0, 41);
  if ((v7 & 1) == 0
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::extendedFormatPattern, "([{][^{}]*[}])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::extendedFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))
  {
    if (!v45.__suffix_.matched)
    {
      v13 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v45.__matches_.__end_ - (char *)v45.__matches_.__begin_) >> 3) <= 1)
        p_unmatched = &v45.__unmatched_;
      else
        p_unmatched = v45.__matches_.__begin_ + 1;
      std::sub_match<char const*>::str[abi:ne180100](p_unmatched, &__p);
      v15 = v44;
      if ((char)v44 < 0)
      {
        v29 = __p;
        v30 = v43;
        *(_QWORD *)a2 = v13;
        *(_QWORD *)(a2 + 8) = v30;
        v31 = 8;
        goto LABEL_103;
      }
      *(_QWORD *)a2 = v13;
      *(_QWORD *)(a2 + 8) = v15;
      v16 = 8;
      goto LABEL_81;
    }
    v45.__matches_.__end_ = v45.__matches_.__begin_;
  }
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::hexFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?[0-9]*(hh|h|ll|l|j|z|t)?[xXp])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::hexFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))
  {
    if (!v45.__suffix_.matched)
    {
      v17 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v45.__matches_.__end_ - (char *)v45.__matches_.__begin_) >> 3) <= 1)
        v18 = &v45.__unmatched_;
      else
        v18 = v45.__matches_.__begin_ + 1;
      std::sub_match<char const*>::str[abi:ne180100](v18, &__p);
      v19 = v44;
      if ((char)v44 < 0)
      {
        v29 = __p;
        v37 = v43;
        *(_QWORD *)a2 = v17;
        *(_QWORD *)(a2 + 8) = v37;
        v31 = 4;
        goto LABEL_103;
      }
      *(_QWORD *)a2 = v17;
      *(_QWORD *)(a2 + 8) = v19;
      v16 = 4;
      goto LABEL_81;
    }
    v45.__matches_.__end_ = v45.__matches_.__begin_;
  }
  if ((v9 & 1) == 0
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::floatFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[fFeEgGaA])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::floatFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))
  {
    if (!v45.__suffix_.matched)
    {
      v20 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v45.__matches_.__end_ - (char *)v45.__matches_.__begin_) >> 3) <= 1)
        v21 = &v45.__unmatched_;
      else
        v21 = v45.__matches_.__begin_ + 1;
      std::sub_match<char const*>::str[abi:ne180100](v21, &__p);
      v22 = v44;
      if ((char)v44 < 0)
      {
        v29 = __p;
        v38 = v43;
        *(_QWORD *)a2 = v20;
        *(_QWORD *)(a2 + 8) = v38;
        v31 = 1;
        goto LABEL_103;
      }
      *(_QWORD *)a2 = v20;
      *(_QWORD *)(a2 + 8) = v22;
      v16 = 1;
      goto LABEL_81;
    }
    v45.__matches_.__end_ = v45.__matches_.__begin_;
  }
  if ((v10 & 1) == 0
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::integralFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[diu])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::integralFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))
  {
    if (v45.__suffix_.matched)
    {
      v45.__matches_.__end_ = v45.__matches_.__begin_;
      goto LABEL_48;
    }
    v23 = *a1;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v45.__matches_.__end_ - (char *)v45.__matches_.__begin_) >> 3) <= 1)
      v24 = &v45.__unmatched_;
    else
      v24 = v45.__matches_.__begin_ + 1;
    std::sub_match<char const*>::str[abi:ne180100](v24, &__p);
    v25 = v44;
    if ((char)v44 < 0)
    {
      v29 = __p;
      v39 = v43;
      *(_QWORD *)a2 = v23;
      *(_QWORD *)(a2 + 8) = v39;
      v31 = 2;
      goto LABEL_103;
    }
    *(_QWORD *)a2 = v23;
    *(_QWORD *)(a2 + 8) = v25;
    v16 = 2;
LABEL_81:
    *(_DWORD *)(a2 + 16) = v16;
    goto LABEL_105;
  }
LABEL_48:
  if ((v11 & 1) == 0
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::altIntegralFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[oc])(.|\\n)*", 0);
  }
  if (!std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::altIntegralFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))goto LABEL_52;
  if (!v45.__suffix_.matched)
  {
    v26 = *a1;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v45.__matches_.__end_ - (char *)v45.__matches_.__begin_) >> 3) <= 1)
      v27 = &v45.__unmatched_;
    else
      v27 = v45.__matches_.__begin_ + 1;
    std::sub_match<char const*>::str[abi:ne180100](v27, &__p);
    v28 = v44;
    if (((char)v44 & 0x80000000) == 0)
    {
      *(_QWORD *)a2 = v26;
      *(_QWORD *)(a2 + 8) = v28;
      v16 = 3;
      goto LABEL_81;
    }
    v29 = __p;
    v40 = v43;
    *(_QWORD *)a2 = v26;
    *(_QWORD *)(a2 + 8) = v40;
    v31 = 3;
LABEL_103:
    *(_DWORD *)(a2 + 16) = v31;
    goto LABEL_104;
  }
  v45.__matches_.__end_ = v45.__matches_.__begin_;
LABEL_52:
  if ((v12 & 1) == 0
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::restrictedStringPattern, "%[0-9]*\\.[0-9]+s", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::restrictedStringPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))
  {
    if (v45.__suffix_.matched)
    {
      v45.__matches_.__end_ = v45.__matches_.__begin_;
    }
    else
    {
      std::match_results<char const*>::str[abi:ne180100](&v45, 0, &__p);
      if ((v44 & 0x80u) == 0)
        p_p = (const char *)&__p;
      else
        p_p = (const char *)__p;
      printf("ASSERT: Invalid format specifier '%s'\n", p_p);
      if ((char)v44 < 0)
        operator delete(__p);
    }
  }
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::formatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[diuoxXfFeEgGaAcspn@])(.|\\n)*", 0);
  }
  if (!std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::formatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v45, 4160))goto LABEL_92;
  if (v45.__suffix_.matched)
  {
    v45.__matches_.__end_ = v45.__matches_.__begin_;
LABEL_92:
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
LABEL_93:
    *(_DWORD *)(a2 + 16) = 0;
    goto LABEL_105;
  }
  v34 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)v45.__matches_.__end_ - (char *)v45.__matches_.__begin_) >> 3) <= 1)
    v35 = &v45.__unmatched_;
  else
    v35 = v45.__matches_.__begin_ + 1;
  std::sub_match<char const*>::str[abi:ne180100](v35, &__p);
  v36 = v44;
  if (((char)v44 & 0x80000000) == 0)
  {
    *(_QWORD *)a2 = v34;
    *(_QWORD *)(a2 + 8) = v36;
    goto LABEL_93;
  }
  v29 = __p;
  v41 = v43;
  *(_QWORD *)a2 = v34;
  *(_QWORD *)(a2 + 8) = v41;
  *(_DWORD *)(a2 + 16) = 0;
LABEL_104:
  operator delete(v29);
LABEL_105:
  if (v45.__matches_.__begin_)
  {
    v45.__matches_.__end_ = v45.__matches_.__begin_;
    operator delete(v45.__matches_.__begin_);
  }
}

void sub_1CBC6BCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

id TFSVolumeInfo::GetDedicatedGCDQueue(int a1)
{
  char v2;

  if (TFSVolumeInfo::GetDedicatedGCDQueue(FSInfoVirtualType)::once != -1)
    dispatch_once(&TFSVolumeInfo::GetDedicatedGCDQueue(FSInfoVirtualType)::once, &__block_literal_global_6);
  v2 = a1 - 21;
  if ((a1 - 21) >= 0xD || ((0x1CEFu >> v2) & 1) == 0)
    abort();
  return (id)*off_1E8752B18[v2];
}

const void *cf_cast<__CFString const*,void const*>(const void *result)
{
  const void *v1;
  CFTypeID v2;
  CFTypeID v3;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFStringGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

void TFSVolumeInfo::CopyVolumeInfos(TFSVolumeInfo *this@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  __int128 v8;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  v3 = *(_QWORD **)(GetVolumeMap() + 16);
  if (v3)
  {
    while (1)
    {
      *(_QWORD *)&v8 = 0;
      v4 = (std::__shared_weak_count *)v3[5];
      if (v4)
        break;
LABEL_13:
      v3 = (_QWORD *)*v3;
      if (!v3)
        goto LABEL_14;
    }
    v5 = std::__shared_weak_count::lock(v4);
    *((_QWORD *)&v8 + 1) = v5;
    if (v5)
    {
      *(_QWORD *)&v8 = v3[4];
      if (!(_QWORD)v8)
        goto LABEL_8;
    }
    else if (!(_QWORD)v8)
    {
LABEL_8:
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
      goto LABEL_13;
    }
    std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)a2, &v8);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
    goto LABEL_8;
  }
LABEL_14:
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
}

void sub_1CBC6BF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::SetAs<UTType * {__strong}>(id *location, id *a2)
{
  int v2;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},UTType * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void TPropertyRecordSet::TPropertyRecordSet(TPropertyRecordSet *this)
{
  uint64_t i;
  _BYTE v3[3080];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  memcpy(v3, "manp", sizeof(v3));
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>((uint64_t)this, 0x4DuLL);
  for (i = 0; i != 3080; i += 40)
    std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::__emplace_unique_key_args<TPropertyRecord,TPropertyRecord const&>((uint64_t)this, (unsigned int *)&v3[i], (uint64_t)&v3[i]);
}

void sub_1CBC6C164(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::__emplace_unique_key_args<TPropertyRecord,TPropertyRecord const&>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  __int128 v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x38uLL);
  *v10 = 0;
  v10[1] = v6;
  v12 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v10 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v10 + 2) = v12;
  v10[6] = *(_QWORD *)(a3 + 32);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 40);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v10 = *v20;
LABEL_38:
    *v20 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v21 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1CBC6C38C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void TFSInfoOverflow::TFSInfoOverflow(TFSInfoOverflow *this, const TFSInfoOverflow *a2)
{
  char *v4;
  int v5;
  _OWORD *v6;
  _OWORD *v7;
  __int128 v8;
  uint64_t v9;

  *((_QWORD *)this + 7) = 0;
  v4 = (char *)this + 56;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)this + 8) = *((id *)a2 + 8);
  *((_DWORD *)v4 + 4) = 0;
  v4[20] = 3;
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 18);
  v5 = *((unsigned __int8 *)a2 + 76);
  v4[20] = v5;
  v6 = (_OWORD *)*((_QWORD *)a2 + 5);
  if (v6)
  {
    v7 = (_OWORD *)operator new();
    v8 = v6[1];
    *v7 = *v6;
    v7[1] = v8;
    v9 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = v7;
    if (v9)
      MEMORY[0x1D17A53D0](v9, 0x1000C40E0EAB150);
    v5 = *((unsigned __int8 *)this + 76);
  }
  switch(v5)
  {
    case 2:
      *(_QWORD *)this = *(id *)a2;
      break;
    case 1:
      *(_QWORD *)this = *(id *)a2;
      *((_QWORD *)this + 1) = *((id *)a2 + 1);
      *((_QWORD *)this + 2) = *((id *)a2 + 2);
      *((_QWORD *)this + 3) = *((id *)a2 + 3);
      *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
      break;
    case 0:
      if (*(_QWORD *)a2)
      {
        std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,TNWNode&,void>(*(_QWORD *)a2, this);
      }
      else
      {
        *(_QWORD *)this = 0;
        *((_QWORD *)this + 1) = 0;
      }
      break;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 18);
}

void sub_1CBC6C4F0(_Unwind_Exception *a1)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  TFileDescriptor **v3;
  uint64_t v5;

  os_unfair_lock_unlock(v2);

  std::unique_ptr<TFileDescriptor>::reset[abi:ne180100](v3, 0);
  v5 = *(_QWORD *)(v1 + 40);
  *(_QWORD *)(v1 + 40) = 0;
  if (v5)
    MEMORY[0x1D17A53D0](v5, 0x1000C40E0EAB150);
  _Unwind_Resume(a1);
}

void sub_1CBC6C5BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TFSVolumeInfo::SetRootDirectoryForSidebarInfo(uint64_t a1, unsigned __int8 a2)
{
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  __int128 v6;
  unsigned __int8 v7;

  v7 = a2;
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,void>(&v7, &v6);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 56, &v6);
  v3 = (std::__shared_weak_count *)*((_QWORD *)&v6 + 1);
  if (*((_QWORD *)&v6 + 1))
  {
    v4 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  TString *v11;
  TString v13;
  TString v14;

  VirtualContainerName(a2, (const void **)&v14.fString.fRef);
  if (a2 == 26)
    v4 = 67109121;
  else
    v4 = 117440769;
  LODWORD(v13.fString.fRef) = v4;
  TFSInfo::TFSInfo(a1, a2, &v14, (unsigned __int8 *)&v13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);
  if ((a2 - 23) < 2u)
  {
    if (a2 == 23)
    {
      TString::TString(&v13, "");
      GetICloudContainerURL(&v13, (CFURLRef *)&v14);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>((const void **)(a1 + 16), (const void **)&v14.fString.fRef);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v14.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
    }
    if (ICloudDriveFPFSEnabled())
    {
      iCloudDriveDomainIDForDataSeparated(a2 == 24);
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = (void *)v5;
      if (a2 == 24 && v5)
      {
        +[FIProviderDomain providerDomainForID:cachePolicy:error:](FIProviderDomain, "providerDomainForID:cachePolicy:error:", v5, 1, 0);
        v7 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v7, "domain");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "identifier");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        v10 = v9;
        if (!v9)
        {
          objc_msgSend(v6, "lastPathComponent");
          v10 = (void *)objc_claimAutoreleasedReturnValue();
        }
        v11 = v10;
        v13.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v13, v11);

        GetICloudContainerURL(&v13, (CFURLRef *)&v14);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>((const void **)(a1 + 16), (const void **)&v14.fString.fRef);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v14.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
        if (!v9)

      }
    }
  }
  return a1;
}

void sub_1CBC6C80C(_Unwind_Exception *a1)
{
  TFSInfo *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  TFSInfo::~TFSInfo(v1);
  _Unwind_Resume(a1);
}

void sub_1CBC6C900(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, char a2, const TString *a3, unsigned __int8 *a4)
{
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)a1);
  *(_BYTE *)(v8 + 112) = a2;
  *(_DWORD *)(v8 + 115) |= 0x40000000u;
  TFSInfo::SetItemName((TFSInfo *)v8, a3);
  v9 = *(_DWORD *)(a1 + 115) & 0xFFFFFFDF | (32 * *a4);
  *(_DWORD *)(a1 + 115) = v9;
  v10 = v9 & 0xFFFFFEFF | (a4[1] << 8);
  *(_DWORD *)(a1 + 115) = v10;
  v11 = v10 & 0xFFFFF7FF | (a4[2] << 11);
  *(_DWORD *)(a1 + 115) = v11;
  *(_BYTE *)(a1 + 114) = a4[3];
  *(_DWORD *)(a1 + 115) = v11 | 1;
  TFSInfo::SetIfVirtualAlias((TFSInfo *)a1);
  return a1;
}

void sub_1CBC6C9D0(_Unwind_Exception *a1)
{
  TFSInfo *v1;

  TFSInfo::~TFSInfo(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::SetIfVirtualAlias(TFSInfo *this)
{
  unsigned int v1;
  BOOL v2;
  int v3;
  os_unfair_lock_s *v6;

  v1 = *((unsigned __int8 *)this + 112);
  v2 = v1 > 7;
  v3 = (1 << v1) & 0xA8;
  if (!v2 && v3 != 0)
  {
    v6 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    *(_DWORD *)((char *)this + 115) |= 0x800u;
    os_unfair_lock_unlock(v6);
  }
}

const void **VirtualContainerName@<X0>(int a1@<W0>, const void **a2@<X8>)
{
  CFTypeRef v4;
  CFTypeRef cf;

  *a2 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  switch(a1)
  {
    case 6:
      TString::TString((TString *)&cf, "Hits container");
      if (&cf != a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1E8752DF8);
        v4 = cf;
        if (!cf)
          goto LABEL_45;
        goto LABEL_44;
      }
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 25:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      goto LABEL_9;
    case 17:
      TString::TString((TString *)&cf, "Devices");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 18:
      TString::TString((TString *)&cf, "Places");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 19:
      TString::TString((TString *)&cf, "Searches");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 20:
      TString::TString((TString *)&cf, "Published Folders");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 21:
      TString::TString((TString *)&cf, "Sidebar Tags");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 22:
      TString::TString((TString *)&cf, "All Tags");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 23:
      TString::TString((TString *)&cf, "iCloud app libraries");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 24:
      TString::TString((TString *)&cf, "DataSeparated iCloud app libraries");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 26:
      TString::TString((TString *)&cf, "Cloud Storage");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 34:
      TString::TString((TString *)&cf, "Recent Documents");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    case 35:
      TString::TString((TString *)&cf, "iCloud Drive");
      if (&cf == a2)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      v4 = cf;
      if (cf)
        goto LABEL_44;
      goto LABEL_45;
    default:
      if (a1 == 1)
      {
        TString::TString((TString *)&cf, "Computer");
        if (&cf == a2)
          return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1E8752DF8);
        v4 = cf;
        if (cf)
LABEL_44:
          CFRelease(v4);
      }
      else
      {
LABEL_9:
        TString::TString((TString *)&cf, "virtual");
        if (&cf == a2)
          return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1E8752DF8);
        v4 = cf;
        if (cf)
          goto LABEL_44;
      }
LABEL_45:
      cf = &stru_1E8752DF8;
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
}

void sub_1CBC6CEA8(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

void *std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::__emplace_unique_key_args<FINode * {__strong},FINode * {__strong}>(uint64_t a1, id *a2, uint64_t *a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v7 = objc_msgSend(*a2, "hash");
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v8)
        {
          if ((std::equal_to<FINode * {__strong}>::operator()(a1 + 32, *((void **)i + 2), *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x18uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v8;
  v16 = *a3;
  *a3 = 0;
  *((_QWORD *)i + 2) = v16;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    v19 = 1;
    if (v9 >= 3)
      v19 = (v9 & (v9 - 1)) != 0;
    v20 = v19 | (2 * v9);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *(_QWORD *)i = *v24;
LABEL_38:
    *v24 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v15;
  *v15 = i;
  *(_QWORD *)(v23 + 8 * v3) = v15;
  if (*(_QWORD *)i)
  {
    v25 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9)
        v25 %= v9;
    }
    else
    {
      v25 &= v9 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBC6D1B8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<TNodePtr,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

unint64_t TNode::IsPopulated(TNode *this)
{
  char v1;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  os_unfair_lock_s *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v1 = atomic_load((unsigned __int16 *)this + 40);
  if ((v1 & 0x10) == 0)
    return 0;
  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v9 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  v10 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
  os_unfair_lock_unlock(v9);
  if (v5)
  {
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return (v10 >> 5) & 1;
}

uint64_t TFSVolumeInfo::AddVolume(TCFURLInfo *a1, char a2, _QWORD *a3)
{
  const __CFURL *v6;
  uint64_t v7;
  _QWORD *VolumeMap;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *p_shared_weak_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  __int128 v27;
  CFTypeRef v28;
  id v29[2];
  CFTypeRef v30;
  CFTypeRef cf;
  uint64_t v32;
  std::__shared_weak_count *v33;

  _ZNSt3__115allocate_sharedB8ne180100I13TFSVolumeInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v32);
  TCFURLInfo::GetVolumeID(a1, v6, &cf);
  v30 = cf;
  if (cf)
    CFRetain(cf);
  v7 = TFSVolumeInfo::InitializeFileSystemVolume();
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v30);
  if ((_DWORD)v7)
  {
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a3, &v32);
  }
  else
  {
    v28 = cf;
    if (cf)
      CFRetain(cf);
    TFSVolumeInfo::GetMapKey(&v28, a2, (uint64_t)v29);
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v28);
    VolumeMap = (_QWORD *)GetVolumeMap();
    VolumeInfoLock();
    os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
    v9 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(VolumeMap, v29);
    v27 = 0uLL;
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a3, &v27);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
    if (*((_QWORD *)&v27 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if (v9)
    {
      v27 = 0uLL;
      v13 = (std::__shared_weak_count *)v9[5];
      if (v13)
      {
        *((_QWORD *)&v27 + 1) = std::__shared_weak_count::lock(v13);
        if (*((_QWORD *)&v27 + 1))
          *(_QWORD *)&v27 = v9[4];
      }
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a3, &v27);
      v14 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
      if (*((_QWORD *)&v27 + 1))
      {
        v15 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
    }
    if (!*a3)
    {
      *(_QWORD *)&v27 = v29;
      v17 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__emplace_unique_key_args<VolumeKey,std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>((uint64_t)VolumeMap, v29, (uint64_t)&std::piecewise_construct, (uint64_t *)&v27);
      v19 = v32;
      v18 = v33;
      if (v33)
      {
        p_shared_weak_owners = (unint64_t *)&v33->__shared_weak_owners_;
        do
          v21 = __ldxr(p_shared_weak_owners);
        while (__stxr(v21 + 1, p_shared_weak_owners));
      }
      v22 = (std::__shared_weak_count *)v17[5];
      v17[4] = v19;
      v17[5] = v18;
      if (v22)
        std::__shared_weak_count::__release_weak(v22);
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a3, &v32);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)v29);
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf);
  v23 = v33;
  if (v33)
  {
    p_shared_owners = (unint64_t *)&v33->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return v7;
}

void sub_1CBC6D4F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  const void *v8;
  va_list va;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, const void *);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::AddVirtualVolume(unsigned int a1, _QWORD *a2)
{
  _QWORD *VolumeMap;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  __int128 v23;
  const void *v24;
  char v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  _ZNSt3__115allocate_sharedB8ne180100I13TFSVolumeInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v26);
  TFSVolumeInfo::InitializeVirtualVolume(v26, a1);
  v24 = 0;
  v25 = 0;
  *(_QWORD *)&v23 = 0;
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(&v24, (const void **)&v23);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v23);
  v25 = a1;
  VolumeMap = (_QWORD *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  v5 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(VolumeMap, (id *)&v24);
  v23 = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v23);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v5)
  {
    v23 = 0uLL;
    v9 = (std::__shared_weak_count *)v5[5];
    if (v9)
    {
      *((_QWORD *)&v23 + 1) = std::__shared_weak_count::lock(v9);
      if (*((_QWORD *)&v23 + 1))
        *(_QWORD *)&v23 = v5[4];
    }
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v23);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  if (!*a2)
  {
    *(_QWORD *)&v23 = &v24;
    v13 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__emplace_unique_key_args<VolumeKey,std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>((uint64_t)VolumeMap, (id *)&v24, (uint64_t)&std::piecewise_construct, (uint64_t *)&v23);
    v15 = v26;
    v14 = v27;
    if (v27)
    {
      p_shared_weak_owners = (unint64_t *)&v27->__shared_weak_owners_;
      do
        v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
    }
    v18 = (std::__shared_weak_count *)v13[5];
    v13[4] = v15;
    v13[5] = v14;
    if (v18)
      std::__shared_weak_count::__release_weak(v18);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a2, &v26);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v24);
  v19 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return 0;
}

void sub_1CBC6D754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  const void *v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, const void *);
  v7 = va_arg(va1, _QWORD);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::TFSVolumeInfo(TFSVolumeInfo *this)
{
  *(_BYTE *)this = 0;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 48) = 0;
  *((_QWORD *)this + 10) = &stru_1E8752DF8;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 11) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 12) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_BYTE *)this + 192) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_BYTE *)this + 216) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_QWORD *)((char *)this + 133) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 44) = 0;
  TDSMutex::TDSMutex((TDSMutex *)((char *)this + 224), 0);
  *((_BYTE *)this + 288) = 0;
  *((_BYTE *)this + 296) = 0;
  *((_BYTE *)this + 304) = 0;
  *((_DWORD *)this + 78) = 0;
  *((_QWORD *)this + 47) = 0;
  *((_BYTE *)this + 384) = 0;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_WORD *)this + 184) = 0;
  *((_QWORD *)this + 49) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_BYTE *)this + 400) = 0;
  *((_BYTE *)this + 408) = 0;
  *((_QWORD *)this + 52) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
}

void sub_1CBC6D8BC(_Unwind_Exception *a1, const void **a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  const void **v4;
  const void **v5;
  const void **v6;
  TDSMutex *v7;
  const void **v8;
  const void **v9;
  va_list va;

  va_start(va, a2);
  if (*(_BYTE *)(v2 + 408))
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v8);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2 + 352);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2 + 336);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2 + 320);
  if (*(_BYTE *)(v2 + 304))
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v2 + 296));
  TDSMutex::~TDSMutex(v7);
  if (*(_BYTE *)(v2 + 216))
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v3);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(a2);
  if (*(_BYTE *)(v2 + 32))
  {
    if (*(char *)(v2 + 23) < 0)
      operator delete(*(void **)v2);
  }
  _Unwind_Resume(a1);
}

void sub_1CBC6D98C()
{
  JUMPOUT(0x1CBC6D95CLL);
}

_QWORD *std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__emplace_unique_key_args<VolumeKey,std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>(uint64_t a1, id *this, uint64_t a3, uint64_t *a4)
{
  unint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = ROSPVolumeID::Hash(this);
  v9 = *((unsigned __int8 *)this + 8);
  v10 = v8 ^ v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v8 ^ v9;
      if (v10 >= v11)
        v4 = v10 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
    v14 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      v15 = (_QWORD *)*v14;
      if (*v14)
      {
        do
        {
          v16 = v15[1];
          if (v16 == v10)
          {
            if ((VolumeKey::operator==((uint64_t)(v15 + 2), (uint64_t)this) & 1) != 0)
              return v15;
          }
          else
          {
            if (v13 > 1)
            {
              if (v16 >= v11)
                v16 %= v11;
            }
            else
            {
              v16 &= v11 - 1;
            }
            if (v16 != v4)
              break;
          }
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
    }
  }
  std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  v15 = (_QWORD *)v26[0];
  v26[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return v15;
}

void sub_1CBC6DC08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

CFTypeRef std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  CFTypeRef result;

  v7 = a1 + 16;
  v8 = operator new(0x30uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = *a3;
  result = *(CFTypeRef *)v9;
  v8[2] = *(_QWORD *)v9;
  if (result)
    result = CFRetain(result);
  *((_BYTE *)v8 + 24) = *(_BYTE *)(v9 + 8);
  v8[4] = 0;
  v8[5] = 0;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBC6DC98(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t TFSVolumeInfo::InitializeFileSystemVolume()
{
  uint64_t v0;
  const __CFURL *v1;
  CFTypeRef *v2;
  char v3;
  uint64_t v4;
  CFTypeRef *v5;
  const __CFURL *v6;
  uint64_t *v7;
  std::__shared_weak_count *f_blocks;
  unint64_t *v9;
  unint64_t v10;
  CFIndex VolumeInfoRecord;
  __CFError *v12;
  unint64_t v13;
  const __CFURL *v14;
  _BOOL4 v15;
  const __CFString *v16;
  unint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  int v20;
  const char *v21;
  int v22;
  NSObject *v23;
  void *v24;
  const void **v25;
  __int128 v26;
  __int16 f_bsize;
  unsigned int v28;
  char v29;
  const void *v30;
  BOOL v31;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  const void *v36;
  std::string v37;
  void *v38[2];
  char v39;
  TCFURLInfo *v40;
  unint64_t v41;
  statfs __p;
  TString __dst[128];
  char __source[1024];
  statfs v45;
  uint64_t v46;

  v0 = MEMORY[0x1E0C80A78]();
  v4 = v0;
  v46 = *MEMORY[0x1E0C80C00];
  if (!*v2)
  {
    TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)v0);
    return 4294967261;
  }
  v5 = v2;
  v6 = v1;
  *(_BYTE *)(v0 + 48) = v3;
  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v45);
  v7 = (uint64_t *)(v4 + 56);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v4 + 56, (__int128 *)&v45);
  f_blocks = (std::__shared_weak_count *)v45.f_blocks;
  if (v45.f_blocks)
  {
    v9 = (unint64_t *)(v45.f_blocks + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))f_blocks->__on_zero_shared)(f_blocks);
      std::__shared_weak_count::__release_weak(f_blocks);
    }
  }
  VolumeInfoRecord = TFSInfo::initialize(*v7, v6, 0, 1, 1, 0, 0);
  if ((_DWORD)VolumeInfoRecord)
  {
    TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)v4);
    return VolumeInfoRecord;
  }
  v40 = 0;
  v41 = 0;
  if (_CFURLGetVolumePropertyFlags())
  {
    v13 = v41;
    *(_BYTE *)(v4 + 108) = (v41 & 2) != 0;
    *(_BYTE *)(v4 + 109) = (v13 & 0x40) != 0;
    *(_BYTE *)(v4 + 107) = v13 & 1;
    *(_BYTE *)(v4 + 111) = (v13 & 0x20000000000) == 0;
    *(_BYTE *)(v4 + 112) = (v13 & 0x80000000000) != 0;
    *(_BYTE *)(v4 + 113) = (v13 & 0x2000000000000) != 0;
    *(_BYTE *)(v4 + 114) = (v13 & 4) != 0;
    *(_BYTE *)(v4 + 115) = (v13 & 0x100000000000000) == 0;
    *(_BYTE *)(v4 + 116) = (v13 & 0x400000000000) != 0;
    *(_BYTE *)(v4 + 134) = (v13 & 0x2000000000000000) != 0;
    v14 = objc_retainAutorelease(v6);
    v15 = statfs((const char *)-[__CFURL fileSystemRepresentation](v14, "fileSystemRepresentation"), &v45) == 0;

    if (v15)
      *(_BYTE *)(v4 + 135) = (v45.f_flags & 0x80) != 0;
    VolumeInfoRecord = 0;
    v17 = v41;
    v18 = (v41 >> 57) & 1;
    if (*(_BYTE *)(v4 + 108))
      LOBYTE(v18) = 0;
    *(_BYTE *)(v4 + 126) = v18;
    *(_BYTE *)(v4 + 117) = (v17 & 0x80) != 0;
    *(_BYTE *)(v4 + 118) = (v17 & 0x800000000000) != 0;
    *(_BYTE *)(v4 + 104) = (v17 & 8) != 0;
    *(_BYTE *)(v4 + 110) = (v17 & 0x20000000000000) != 0;
    *(_BYTE *)(v4 + 119) = (v17 & 0x200) != 0;
  }
  else
  {
    VolumeInfoRecord = TCFURLInfo::TranslateCFError(v40, v12);
  }
  *(_BYTE *)(v4 + 136) = TCFURLInfo::GetBooleanProperty(v6, (const __CFString *)*MEMORY[0x1E0C9B780], v16);
  *(_BYTE *)(v4 + 137) = TCFURLInfo::GetBooleanProperty(v6, (const __CFString *)*MEMORY[0x1E0C9B730], v19);
  if (!(_DWORD)VolumeInfoRecord)
  {
    v20 = TFSInfo::CopyPathToCBuffer((TFSInfo *)*v7, __source, 1024);
    if (v20 || statfs(__source, &v45))
      goto LABEL_48;
    if ((v45.f_flags & 0x40000000) != 0)
      *(_BYTE *)(v4 + 138) = 1;
    *(_QWORD *)&__p.f_bsize = &v45;
    TFSVolumeInfo::InitializeFileSystemVolume(__CFURL const*,ROSPVolumeID,FSInfoVirtualType)::$_0::operator()((uint64_t *)&__p, v38);
    *(_BYTE *)(v4 + 127) = std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v38, "autofs");
    if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v38, "apfs"))
    {
      *(_DWORD *)(v4 + 72) = 20;
      std::string::basic_string[abi:ne180100]<0>(&v37, v45.f_mntfromname);
      ParseDeviceName(&v37, (std::string *)&__p);
      std::__optional_storage_base<std::pair<std::string,unsigned char>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::pair<std::string,unsigned char>,false>>(v4, (__n128 *)&__p);
      if (LOBYTE(__p.f_files) && SHIBYTE(__p.f_bfree) < 0)
        operator delete(*(void **)&__p.f_bsize);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v37.__r_.__value_.__l.__data_);
      if (*(_BYTE *)(v4 + 32))
      {
        *(_QWORD *)&__p.f_bsize = 0;
        __p.f_blocks = 0;
        uuid_clear((unsigned __int8 *)&__p);
        v21 = (const char *)v4;
        if (*(char *)(v4 + 23) < 0)
          v21 = *(const char **)v4;
        TString::operator=((TString *)(v4 + 80), v21);
      }
      else
      {
        LogObj(5);
        v23 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          TString::TString(__dst, v45.f_mntfromname);
          SanitizedStr(__dst);
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          __p.f_bsize = 138543362;
          *(_QWORD *)&__p.f_iosize = v24;
          _os_log_impl(&dword_1CBC4A000, v23, OS_LOG_TYPE_ERROR, "Couldn't find device for %{public}@", (uint8_t *)&__p, 0xCu);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__dst[0].fString.fRef);

        }
      }
      goto LABEL_42;
    }
    if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v38, "exfat"))
    {
      v22 = 21;
    }
    else if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v38, "msdos"))
    {
      v22 = 8;
    }
    else
    {
      if (!std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v38, "smbfs"))
        goto LABEL_42;
      v22 = 22;
    }
    *(_DWORD *)(v4 + 72) = v22;
LABEL_42:
    if (*(_BYTE *)(v4 + 119))
    {
      strlcpy((char *)__dst, __source, 0x400uLL);
      if (strlcat((char *)__dst, "/Backups.backupdb", 0x400uLL) <= 0x3FF && !statfs((const char *)__dst, &__p))
        *(_BYTE *)(v4 + 130) = 1;
    }
    if (v39 < 0)
      operator delete(v38[0]);
LABEL_48:
    TFSVolumeInfo::CreateHiddenList((TFSVolumeInfo *)v4);
    *(_QWORD *)(v4 + 376) = TFSInfo::GetParentObjectIdentifier((TFSInfo *)*v7);
    v25 = (const void **)(v4 + 40);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(v4 + 40), *v5);
    *(_QWORD *)&v26 = -1;
    *((_QWORD *)&v26 + 1) = -1;
    *(_OWORD *)(v4 + 144) = v26;
    *(_OWORD *)(v4 + 160) = v26;
    atomic_store(0, (unsigned int *)(v4 + 176));
    *(_QWORD *)(v4 + 184) = 0;
    *(_WORD *)(v4 + 123) = 256;
    *(_BYTE *)(v4 + 128) = 0;
    VolumeInfoRecord = TCFURLInfo::GetVolumeInfoRecord(v6, &v45);
    if ((_DWORD)VolumeInfoRecord)
    {
LABEL_69:
      if (!v20)
      {
        TFSInfo::VolumeUUID((TFSInfo *)*v7, (TString *)&__p);
        if ((statfs *)(v4 + 392) != &__p)
        {
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(v4 + 392), (const void **)&__p);
          CFRetain(&stru_1E8752DF8);
          if (*(_QWORD *)&__p.f_bsize)
            CFRelease(*(CFTypeRef *)&__p.f_bsize);
          *(_QWORD *)&__p.f_bsize = &stru_1E8752DF8;
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__p);
      }
      goto LABEL_75;
    }
    f_bsize = v45.f_bsize;
    *(_BYTE *)(v4 + 129) = (v45.f_bsize & 0x800) != 0;
    if ((f_bsize & 0x800) != 0)
      *(_BYTE *)(v4 + 126) = 0;
    if (*(_BYTE *)(v4 + 107))
    {
      v28 = *(_DWORD *)(v4 + 72);
      if (v28 <= 0x15 && ((1 << v28) & 0x240101) != 0)
      {
        *(_BYTE *)(v4 + 132) = 0;
        goto LABEL_60;
      }
      v29 = 1;
    }
    else
    {
      if (TFSVolumeInfo::LoadPrefs(void)::once != -1)
        dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_15);
      v29 = TFSVolumeInfo::gNoNetworkPropertyStores ^ 1;
    }
    *(_BYTE *)(v4 + 132) = v29;
LABEL_60:
    TFSVolumeInfo::SetMountPoint((TFSVolumeInfo *)v4);
    *(_BYTE *)(v4 + 133) = (v45.f_bsize & 0x4000) != 0;
    ROSPVolumeID::BootVolumeID(&__p);
    v30 = *v25;
    v31 = (*(_QWORD *)&__p.f_bsize | (unint64_t)*v25) == 0;
    if (*(_QWORD *)&__p.f_bsize && v30)
      v31 = CFEqual(*(CFTypeRef *)&__p.f_bsize, v30) != 0;
    *(_BYTE *)(v4 + 121) = v31;
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&__p);
    if (*(_BYTE *)(v4 + 121))
      *(_BYTE *)(v4 + 120) = 1;
    *(_BYTE *)(v4 + 122) = 0;
    *(_BYTE *)(v4 + 131) = 0;
    *(int64x2_t *)(v4 + 144) = vdupq_n_s64(0xFFFFFFFFFFFFFFFELL);
    *(_QWORD *)(v4 + 168) = -2;
    if (IsRunningInFinder())
      TFSVolumeInfo::RecalculateFreeSpaceAndCapacity((TFSVolumeInfo *)v4, 0);
    if (*(_BYTE *)(v4 + 121))
      TFSVolumeInfo::SystemBuildVersion((TFSVolumeInfo *)v4);
    goto LABEL_69;
  }
LABEL_75:
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v40);
  TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)v4);
  if (!(_DWORD)VolumeInfoRecord)
  {
    if (!*(_BYTE *)(v4 + 120) && !*(_BYTE *)(v4 + 48))
    {
      ROSPVolumeID::BootVolumeID(&v36);
      TFSVolumeInfo::VolumeInfoFor(&v36, &v45);
      TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v36);
      *(_BYTE *)(v4 + 120) = TFSVolumeInfo::SamePhysicalDevice(*(TFSVolumeInfo **)&v45.f_bsize, (const TFSVolumeInfo *)v4);
      v33 = (std::__shared_weak_count *)v45.f_blocks;
      if (v45.f_blocks)
      {
        v34 = (unint64_t *)(v45.f_blocks + 8);
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
    }
    return 0;
  }
  return VolumeInfoRecord;
}

void sub_1CBC6E618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *__p, uint64_t a8, int a9, __int16 a10, char a11, char a12, ...)
{
  void *v12;
  va_list va;

  va_start(va, a12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&STACK[0x8D0]);

  if (a12 < 0)
    operator delete(__p);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef ROSPVolumeID::BootVolumeID@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v3;
  CFTypeRef result;

  {
    ROSPVolumeID::BootVolumeID(void)::$_0::operator()();
  }
  result = (CFTypeRef)ROSPVolumeID::BootVolumeID(void)::sBootDeviceID;
  *a1 = ROSPVolumeID::BootVolumeID(void)::sBootDeviceID;
  if (result)
    return CFRetain(result);
  return result;
}

void sub_1CBC6E754(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *TFSVolumeInfo::InitializeFileSystemVolume(__CFURL const*,ROSPVolumeID,FSInfoVirtualType)::$_0::operator()@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  char *v4;
  _QWORD v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  v6[1] = 0;
  v4 = (char *)v6;
  if (_FSGetTypeInfoFromStatfs(*a1, (char *)v6, 0x10uLL, 0))
    v4 = (char *)(*a1 + 72);
  return std::string::basic_string[abi:ne180100]<0>(a2, v4);
}

uint64_t TFSInfo::GetParentObjectIdentifier(TFSInfo *this)
{
  uint64_t ObjectIdentifier;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TFSInfo *v7;
  std::__shared_weak_count *v8;

  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v7);
  if (TFSInfo::GetParent((uint64_t)this, (uint64_t *)&v7) || !v7)
    ObjectIdentifier = 0;
  else
    ObjectIdentifier = TFSInfo::GetObjectIdentifier(v7);
  v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return ObjectIdentifier;
}

void sub_1CBC6E890(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetParent(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  int v5;
  const void *v6;
  int v7;
  os_unfair_lock_s *v8;
  CFIndex v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 v17;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v5 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x100) == 0)
  {
    os_unfair_lock_lock(v4);
    v6 = *(const void **)(a1 + 16);
    *(_QWORD *)&v17 = v6;
    if (v6)
    {
      CFRetain(v6);
      os_unfair_lock_unlock(v4);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v17);
      os_unfair_lock_lock(v4);
      v7 = *(_DWORD *)(a1 + 115);
      os_unfair_lock_unlock(v4);
      if ((v7 & 0x100) == 0)
      {
        v8 = TFSInfo::CopyParentPathURL((TFSInfo *)a1);
        *(_QWORD *)&v17 = v8;
        if (v8)
          v9 = TFSInfo::initialize(*a2, (const __CFURL *)v8, 1, 1, 1, 1, 0);
        else
          v9 = 4294959224;
        TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v17);
        return v9;
      }
      v17 = 0uLL;
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v17);
      v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
      if (*((_QWORD *)&v17 + 1))
      {
        v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
    }
    else
    {
      os_unfair_lock_unlock(v4);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v17);
    }
    return 4294959224;
  }
  v17 = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v17);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return 0;
}

void sub_1CBC6EA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::CopyPathToCBuffer(TFSInfo *this, char *a2, CFIndex a3)
{
  uint64_t v5;
  const __CFString *v6;
  CFTypeRef v7;
  CFTypeRef v8;
  CFTypeRef cf;
  unsigned int v11;

  TFSInfo::GetPath(this, (uint64_t)&cf);
  v5 = v11;
  if (!v11)
  {
    v6 = (const __CFString *)cf;
    if (cf)
    {
      v7 = CFRetain(cf);
      v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v7);
      if (v6)
      {
        v8 = CFAutorelease(v6);
        v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v8);
      }
    }
    if (CFStringGetCString(v6, a2, a3, 0x8000100u))
      v5 = v11;
    else
      v5 = 4294959236;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  return v5;
}

void sub_1CBC6EAEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void **TFSInfo::VolumeUUID@<X0>(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  return TCFURLInfo::StringProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B7F0], a2);
}

TString *TString::operator=(TString *a1, const char *a2)
{
  CFIndex v4;

  TString::SetStringRefAsImmutable(a1, 0);
  if (a2)
  {
    v4 = strlen(a2);
    TString::SetFromUTF8(a1, (const UInt8 *)a2, v4);
  }
  return a1;
}

const void **TFSVolumeInfo::CreateHiddenList(TFSVolumeInfo *this)
{
  const void **result;
  uint64_t i;
  char *v4;
  uint64_t v5;
  char *v6;
  char **v7;
  char v8;
  TString v9;
  TString v10;
  TString v11;
  TString v12;
  TString v13;
  TString v14;
  TString v15;
  TString v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = (const void **)TFSVolumeInfo::MayHaveHiddenList(this);
  if ((_DWORD)result)
  {
    TString::TString(&v9, "mach (Mac OS 9)", 0xFuLL);
    TString::TString(&v10, "mach.sym (Mac OS 9)", 0x13uLL);
    TString::TString(&v11, "mach", 4uLL);
    TString::TString(&v12, "mach.sym", 8uLL);
    TString::TString(&v13, "automount", 9uLL);
    TString::TString(&v14, "Network Trash Folder", 0x14uLL);
    TString::TString(&v15, "TheVolumeSettingsFolder", 0x17uLL);
    TString::TString(&v16, "Temporary Items", 0xFuLL);
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = &v4;
    v8 = 0;
    v4 = (char *)operator new(0x40uLL);
    v5 = (uint64_t)v4;
    v6 = v4 + 64;
    v5 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString const*,TString const*,TString*>((uint64_t)&v6, (uint64_t)&v9, (uint64_t)&v17, (uint64_t)v4);
    std::optional<std::vector<TString>>::operator=[abi:ne180100]<std::vector<TString>,void>((uint64_t)this + 192, (uint64_t)&v4);
    v7 = &v4;
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
    for (i = 56; i != -8; i -= 8)
      result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)((char *)&v9.fString.fRef + i));
  }
  return result;
}

void sub_1CBC6ED04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, char a14)
{
  uint64_t i;

  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&a12);
  for (i = 56; i != -8; i -= 8)
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(&a14 + i));
  _Unwind_Resume(a1);
}

BOOL TFSVolumeInfo::MayHaveHiddenList(TFSVolumeInfo *this)
{
  uint64_t v1;
  const void *v3;
  _BOOL8 v4;
  const void *v6;

  v1 = *((_QWORD *)this + 7);
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 100));
    v3 = *(const void **)(v1 + 16);
    v6 = v3;
    if (v3)
    {
      CFRetain(v3);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 100));
      if (!*((_BYTE *)this + 127) && !*((_BYTE *)this + 108))
      {
        v4 = *((_BYTE *)this + 48) == 0;
LABEL_9:
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v6);
        return v4;
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 100));
    }
    v4 = 0;
    goto LABEL_9;
  }
  return 0;
}

void sub_1CBC6EE0C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void **TFSVolumeInfo::SetMountPoint(TFSVolumeInfo *this)
{
  TFSInfo *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  CFURLRef CFURLRef;
  unint64_t *v7;
  unint64_t v8;
  TString *propertyValueTypeRefPtr;
  const void *v11[3];
  CFErrorRef error;

  v2 = (TFSInfo *)*((_QWORD *)this + 7);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  v11[1] = v2;
  v11[2] = v3;
  error = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  if (v2)
  {
    CFURLRef = TFSInfo::CreateCFURLRef(v2);
    v11[0] = CFURLRef;
    if (CFURLRef)
    {
      propertyValueTypeRefPtr = 0;
      if (CFURLCopyResourcePropertyForKey(CFURLRef, (CFStringRef)*MEMORY[0x1E0C9ADC8], &propertyValueTypeRefPtr, &error))
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 78);
        if (*((TString **)this + 11) != propertyValueTypeRefPtr)
          TString::SetStringRefAsImmutable((TString *)this + 11, propertyValueTypeRefPtr);
        if (*((_BYTE *)this + 408))
        {
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 50);
          *((_BYTE *)this + 408) = 0;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
      }
      TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(v11);
  }
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
}

void sub_1CBC6EF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16)
{
  os_unfair_lock_s *v16;

  os_unfair_lock_unlock(v16);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&a10);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a11);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&a16);
  _Unwind_Resume(a1);
}

CFURLRef TFSInfo::CreateCFURLRef(TFSInfo *this)
{
  const __CFURL *v1;

  v1 = (const __CFURL *)*((_QWORD *)this + 1);
  if (v1)
    return CFURLCreateFileReferenceURL(0, v1, 0);
  else
    return 0;
}

uint64_t TCFURLInfo::GetVolumeInfoRecord(void *a1, _QWORD *a2)
{
  id v3;
  int *v4;
  const char *v5;
  unsigned int v6;
  unsigned int v7;
  CFIndex v8;
  unsigned int f_blocks;
  id v10;
  const char *v11;
  int *v12;
  const char *v13;
  unsigned int v14;
  unsigned int f_bavail;
  __CFError *v16;
  __CFError *v17;
  const __CFNumber *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t valuePtr;
  unint64_t v23;
  CFErrorRef error;
  uint64_t v25;
  uint64_t v26;
  statfs propertyValueTypeRefPtr;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1)
  {
    v3 = objc_retainAutorelease(a1);
    memset(&propertyValueTypeRefPtr, 0, 36);
    v26 = 0;
    error = (CFErrorRef)5;
    v25 = 0x20000;
    if (getattrlist((const char *)objc_msgSend(v3, "fileSystemRepresentation"), &error, &propertyValueTypeRefPtr, 0x24uLL, 0))
    {
      v4 = __error();
      v6 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v4, 0, v5);

      if (v6)
      {
        v7 = *(_DWORD *)a2 & 0xFFF9FFFF;
LABEL_15:
        *(_DWORD *)a2 = v7;
LABEL_16:
        *(_DWORD *)a2 = v7 & 0xFFFFF6FF;
        v23 = 0;
        error = 0;
        if (!_CFURLGetVolumePropertyFlags())
        {
          v8 = TCFURLInfo::TranslateCFError(error, v16);
LABEL_28:
          TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
          return v8;
        }
        *(_DWORD *)a2 = ((v23 >> 29) & 0x80 | *(_DWORD *)a2 & 0xFFFF9905 | (v23 >> 37) & 0x4000 | (v23 >> 34) & 0x200 | (v23 >> 35) & 8 | (v23 >> 57) & 0x10 | (v23 >> 44) & 0x20 | (v23 >> 37) & 0x400 | (v23 >> 43) & 0x2000 | (2 * (v23 & 1)) | (v23 >> 52) & 0x40) ^ 0x2000;
        *(_QWORD *)&propertyValueTypeRefPtr.f_bsize = 0;
        if (!CFURLCopyResourcePropertyForKey((CFURLRef)v3, (CFStringRef)*MEMORY[0x1E0C9B690], &propertyValueTypeRefPtr, &error)|| (v18 = *(const __CFNumber **)&propertyValueTypeRefPtr.f_bsize) == 0)
        {
          v8 = TCFURLInfo::TranslateCFError(error, v17);
          goto LABEL_27;
        }
        a2[1] = 4096;
        valuePtr = 0;
        CFNumberGetValue(v18, kCFNumberSInt64Type, &valuePtr);
        v19 = valuePtr;
        v20 = a2[1];
        if (!__CFADD__(valuePtr, v20))
        {
          if (!v20)
          {
LABEL_25:
            v8 = 0;
            a2[2] = v20;
LABEL_27:
            TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
            goto LABEL_28;
          }
          v19 = valuePtr + v20 - 1;
        }
        v20 *= v19 / v20;
        goto LABEL_25;
      }
      f_blocks = 0;
    }
    else
    {
      f_blocks = propertyValueTypeRefPtr.f_blocks;

    }
    v7 = *(_DWORD *)a2 & 0xFFFDFFFF | (((f_blocks >> 6) & 1) << 17);
    *(_DWORD *)a2 = v7;
    if ((f_blocks & 2) == 0)
      goto LABEL_16;
    v10 = objc_retainAutorelease(v3);
    v11 = (const char *)objc_msgSend(v10, "fileSystemRepresentation");
    memset(&propertyValueTypeRefPtr, 0, 44);
    v26 = 0;
    error = (CFErrorRef)5;
    v25 = 0x40000000;
    if (getattrlist(v11, &error, &propertyValueTypeRefPtr, 0x2CuLL, 0x21u))
    {
      v12 = __error();
      v14 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v12, 0, v13);

      if (v14)
      {
        v7 = *(_DWORD *)a2 & 0xFFFBFFFF;
        goto LABEL_15;
      }
      f_bavail = 0;
    }
    else
    {
      f_bavail = propertyValueTypeRefPtr.f_bavail;

    }
    v7 = *(_DWORD *)a2 & 0xFFFBFFFF | (((f_bavail >> 28) & 1) << 18);
    goto LABEL_15;
  }
  return 4294959238;
}

void sub_1CBC6F30C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t IsRunningInFinder(void)
{
  return 0;
}

void ParseDeviceName(std::string *this@<X0>, std::string *a2@<X8>)
{
  std::string::size_type v4;
  std::string *v5;
  std::string::size_type size;
  char *v7;
  int v8;
  std::string::size_type v9;
  std::string::size_type v10;
  std::string::size_type v11;
  std::string::size_type v12;
  unint64_t v13;
  std::string __p;
  std::string v15;

  v4 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    v5 = (std::string *)this->__r_.__value_.__r.__words[0];
    size = this->__r_.__value_.__l.__size_;
  }
  else
  {
    v5 = this;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  }
  v7 = (char *)&v5[-1].__r_.__value_.__r.__words[2] + 7;
  do
  {
    if (!size)
      goto LABEL_13;
    v8 = v7[size--];
  }
  while (v8 != 47);
  if (size == -1)
  {
LABEL_13:
    v10 = 0;
    goto LABEL_14;
  }
  v9 = size + 1;
  if ((v4 & 0x80) != 0)
    v4 = this->__r_.__value_.__l.__size_;
  if (v9 >= v4)
    v10 = 0;
  else
    v10 = v9;
LABEL_14:
  v11 = std::string::find(this, 115, v10 + 3);
  if (v11 == -1)
    goto LABEL_18;
  v12 = v11;
  std::string::basic_string(&__p, this, v11 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v15);
  v13 = std::stoul(&__p, 0, 10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v13 > 0xFF)
  {
LABEL_18:
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2[1].__r_.__value_.__s.__data_[8] = 0;
  }
  else
  {
    std::string::basic_string(&v15, this, v10, v12 - v10, (std::allocator<char> *)&__p);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&__p, v15.__r_.__value_.__l.__data_, v15.__r_.__value_.__l.__size_);
    else
      __p = v15;
    *a2 = __p;
    a2[1].__r_.__value_.__s.__data_[0] = v13;
    a2[1].__r_.__value_.__s.__data_[8] = 1;
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v15.__r_.__value_.__l.__data_);
  }
}

void sub_1CBC6F4D4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _BYTE *v22;

  if (a22 < 0)
    operator delete(__p);
  __cxa_begin_catch(a1);
  *v22 = 0;
  v22[32] = 0;
  __cxa_end_catch();
  JUMPOUT(0x1CBC6F4BCLL);
}

uint64_t _FSGetTypeInfoFromStatfs(uint64_t a1, char *a2, size_t a3, _DWORD *a4)
{
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t result;
  char __source[16];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!check_mntfromname((const char *)(a1 + 72)))
  {
    __strlcpy_chk();
    if (!a2)
      goto LABEL_10;
    goto LABEL_9;
  }
  v8 = a1 + 1112;
  v9 = strstr((char *)(a1 + 1112), "://");
  if (!v9)
    return 22;
  if ((unint64_t)&v9[-v8] >= 0xF)
    v10 = 15;
  else
    v10 = (uint64_t)&v9[-v8];
  __memcpy_chk();
  __source[v10] = 0;
  if (a2)
LABEL_9:
    strlcpy(a2, __source, a3);
LABEL_10:
  result = 0;
  if (a4)
    *a4 = *(_DWORD *)(a1 + 68);
  return result;
}

BOOL check_mntfromname(const char *a1)
{
  return !strcmp(a1, "lifs") || strcmp(a1, "fskit") == 0;
}

BOOL TFSVolumeInfo::SamePhysicalDevice(TFSVolumeInfo *this, const TFSVolumeInfo *a2)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v3 = *((_QWORD *)this + 40);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 41);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *((_QWORD *)a2 + 40);
  v6 = (std::__shared_weak_count *)*((_QWORD *)a2 + 41);
  if (!v6)
    goto LABEL_9;
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  do
    v10 = __ldaxr(v8);
  while (__stlxr(v10 - 1, v8));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v2)
      return v3 == v7;
  }
  else
  {
LABEL_9:
    if (!v2)
      return v3 == v7;
  }
  v11 = (unint64_t *)&v2->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return v3 == v7;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FINode *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBC6F7A8(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBC6F868(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC6F910(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

id iCloudDriveDomainIDForDataSeparated(char a1)
{
  void *v2;
  NSObject *v3;
  uint8_t v5[16];

  if (!ICloudDriveFPFSEnabled())
    return 0;
  if ((a1 & 1) != 0)
  {
    objc_msgSend((id)objc_opt_class(), "br_getProviderDomainIDForDataSeparated:", 1);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v2)
    {
      LogObj(4);
      v3 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)v5 = 0;
        _os_log_impl(&dword_1CBC4A000, v3, OS_LOG_TYPE_DEBUG, "Failed to get domain ID for data separated iCloud Drive account", v5, 2u);
      }

    }
  }
  else
  {
    objc_msgSend((id)objc_opt_class(), "mainICloudDriveDomainID");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
  }
  return v2;
}

CFTypeRef TCFURLInfo::BootURL@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v3;
  CFTypeRef result;

  {
    TCFURLInfo::BootURL(void)::$_0::operator()();
  }
  result = (CFTypeRef)TCFURLInfo::BootURL(void)::rootURL;
  *a1 = TCFURLInfo::BootURL(void)::rootURL;
  if (result)
    return CFRetain(result);
  return result;
}

void sub_1CBC6FA74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

TString *TFSVolumeInfo::SystemBuildVersion(TFSVolumeInfo *this)
{
  TString *v1;
  unsigned int v3;
  TFSInfo *v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  NSString *v14;
  void *v15;
  void *v16;
  TString *v17;
  TString v19;
  TString v20;
  TString v21;
  TString v22;
  TString v23;
  const void *v24[2];

  v1 = (TString *)((char *)this + 296);
  if (!*((_BYTE *)this + 304))
  {
    v24[0] = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    std::optional<TString>::operator=[abi:ne180100]<TString,void>((uint64_t)v1, v24);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v24);
    if (!*((_BYTE *)this + 127) && !*((_BYTE *)this + 108) && !*((_BYTE *)this + 48))
    {
      v3 = *((_DWORD *)this + 18);
      if (v3 <= 0x14 && ((1 << v3) & 0x10000C) != 0)
      {
        v4 = (TFSInfo *)*((_QWORD *)this + 7);
        v5 = (unint64_t *)*((_QWORD *)this + 8);
        v24[0] = v4;
        v24[1] = v5;
        if (v5)
        {
          v6 = v5 + 1;
          do
            v7 = __ldxr(v6);
          while (__stxr(v7 + 1, v6));
        }
        v8 = (void *)MEMORY[0x1E0C99E98];
        TFSInfo::CFURL(v4, &v23);
        NodeEventRefFromNodeEvent((id *)&v23.fString.fRef);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "fileURLWithPath:isDirectory:relativeToURL:", CFSTR("System/Library/CoreServices/SystemVersion.plist"), 0, v9);
        v10 = (void *)objc_claimAutoreleasedReturnValue();

        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v23.fString.fRef);
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithContentsOfURL:error:", v10, 0);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        if (v11)
        {
          NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ABA0]);
          v12 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v11, "objectForKeyedSubscript:", v12);
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          objc_cast<NSString,objc_object * {__strong}>(v13);
          v14 = (NSString *)objc_claimAutoreleasedReturnValue();

          TString::TString(&v23, v14);
          TString::Append(v1, &v23);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
          if (v14 && os_variant_has_internal_ui())
          {
            NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AB90]);
            v15 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v11, "objectForKeyedSubscript:", v15);
            v16 = (void *)objc_claimAutoreleasedReturnValue();
            v17 = (TString *)static_cf_cast<__CFString const*,void const*>(v16);

            TString::TString(&v21, " (", 2uLL);
            TString::TString(&v20, v17);
            TString::operator+((const __CFString **)&v21.fString.fRef, &v20, &v22);
            TString::TString(&v19, ")", 1uLL);
            TString::operator+((const __CFString **)&v22.fString.fRef, &v19, &v23);
            TString::Append(v1, &v23);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
          }

        }
        std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v24);
      }
    }
  }
  return v1;
}

void sub_1CBC6FD50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  const void *v6;
  va_list va;
  const void *v8;
  va_list va1;
  const void *v10;
  va_list va2;
  const void *v12;
  va_list va3;
  const void *v14;
  va_list va4;
  va_list va5;

  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v10 = va_arg(va3, const void *);
  va_copy(va4, va3);
  v12 = va_arg(va4, const void *);
  va_copy(va5, va4);
  v14 = va_arg(va5, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va5);
  _Unwind_Resume(a1);
}

void TFSInfo::CFURL(TFSInfo *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  const void *v5;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = (const void *)*((_QWORD *)this + 2);
  *a2 = v5;
  if (v5)
    CFRetain(v5);
  os_unfair_lock_unlock(v4);
}

void sub_1CBC6FE94(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, NSString *a2)
{
  TString *v3;

  v3 = a2;
  this->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(this, v3);

}

void sub_1CBC6FF00(_Unwind_Exception *a1)
{
  void *v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

void TCFURLInfo::PropertyToString(signed int a1@<W0>, TString *a2@<X8>)
{
  signed int v3;
  std::string v4;
  std::string __p;

  if (a1 <= 1819501923)
  {
    if (a1 > 1718641012)
    {
      if (a1 <= 1769169259)
      {
        if (a1 > 1752458087)
        {
          if (a1 > 1768323436)
          {
            if (a1 <= 1768387183)
            {
              if (a1 == 1768323437)
              {
                OSTypeAsString(0x6966796Du, &v4);
                Format<std::string>("prIFSymbol (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              if (a1 == 1768386423)
              {
                OSTypeAsString(0x69676F77u, &v4);
                Format<std::string>("prIgnoreOwnership (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            if (a1 != 1768387184)
            {
              if (a1 == 1768845426)
              {
                OSTypeAsString(0x696E7072u, &v4);
                Format<std::string>("prInlineProgress (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x69677270u, &v4);
            Format<std::string>("prItemGroupID (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
          }
          else
          {
            if (a1 <= 1768123491)
            {
              if (a1 == 1752458088)
              {
                OSTypeAsString(0x68746368u, &v4);
                Format<std::string>("prAttributeChanged (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              if (a1 == 1768120688)
              {
                OSTypeAsString(0x69636170u, &v4);
                Format<std::string>("prIsiCloudLibraryInSidebar (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            if (a1 == 1768123492)
            {
              OSTypeAsString(0x69636C64u, &v4);
              Format<std::string>("prIsiCloudInSidebar (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 != 1768124270)
              goto LABEL_405;
            OSTypeAsString(0x69636F6Eu, &v4);
            Format<std::string>("prIconRef (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 <= 1718904683)
        {
          if (a1 <= 1718776687)
          {
            if (a1 == 1718641013)
            {
              OSTypeAsString(0x66706175u, &v4);
              Format<std::string>("prFPAuthenticated (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1718645604)
            {
              OSTypeAsString(0x66707364u, &v4);
              Format<std::string>("prIsFileProviderInSidebar (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 != 1718776688)
          {
            if (a1 == 1718903156)
            {
              OSTypeAsString(0x66746174u, &v4);
              Format<std::string>("prFinderTagAndAttrs (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x66727370u, &v4);
          Format<std::string>("prFreeSpace (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 <= 1751480435)
        {
          if (a1 == 1718904684)
          {
            OSTypeAsString(0x6674676Cu, &v4);
            Format<std::string>("prFinderTagAttrsLabel (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1735287668)
          {
            OSTypeAsString(0x676E6374u, &v4);
            Format<std::string>("prGenerationCount (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 == 1751480436)
        {
          OSTypeAsString(0x68657874u, &v4);
          Format<std::string>("prIsExtensionHidden (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1752392562)
        {
          OSTypeAsString(0x68736372u, &v4);
          Format<std::string>("prHasScriptingTerminology (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
      else if (a1 <= 1769173874)
      {
        if (a1 > 1769171055)
        {
          if (a1 <= 1769171298)
          {
            if (a1 == 1769171056)
            {
              OSTypeAsString(0x69736870u, &v4);
              Format<std::string>("prICloudSharePerson (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1769171059)
            {
              OSTypeAsString(0x69736873u, &v4);
              Format<std::string>("prICloudSharePersonString (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 == 1769171299)
          {
            OSTypeAsString(0x69736963u, &v4);
            Format<std::string>("prISIcon (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1769173099)
          {
            OSTypeAsString(0x6973706Bu, &v4);
            Format<std::string>("prIsPackage (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
        else if (a1 > 1769170539)
        {
          if (a1 == 1769170540)
          {
            OSTypeAsString(0x6973666Cu, &v4);
            Format<std::string>("prIsFolder (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1769170547)
          {
            OSTypeAsString(0x69736673u, &v4);
            Format<std::string>("prIsFileShare (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 == 1769169260)
          {
            OSTypeAsString(0x6973616Cu, &v4);
            Format<std::string>("prIsAlias (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1769169264)
          {
            OSTypeAsString(0x69736170u, &v4);
            Format<std::string>("prIsApplication (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
      }
      else if (a1 <= 1818321515)
      {
        if (a1 > 1802071651)
        {
          if (a1 == 1802071652)
          {
            OSTypeAsString(0x6B696E64u, &v4);
            Format<std::string>("prKind (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1802072172)
          {
            OSTypeAsString(0x6B69706Cu, &v4);
            Format<std::string>("prKindWithoutPlatform (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 == 1769173875)
          {
            OSTypeAsString(0x69737373u, &v4);
            Format<std::string>("prIsScreenShare (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1769370466)
          {
            OSTypeAsString(0x69767362u, &v4);
            Format<std::string>("prHideInFinderSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
      }
      else
      {
        if (a1 <= 1819240274)
        {
          if (a1 != 1818321516)
          {
            if (a1 == 1818702163)
            {
              OSTypeAsString(0x6C673153u, &v4);
              Format<std::string>("prCachedLogicalSize (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x6C61626Cu, &v4);
          Format<std::string>("prLabel (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        switch(a1)
        {
          case 1819240275:
            OSTypeAsString(0x6C6F6753u, &v4);
            Format<std::string>("prObsoleteCachedLogicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          case 1819240307:
            OSTypeAsString(0x6C6F6773u, &v4);
            Format<std::string>("prLogicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          case 1819243362:
            OSTypeAsString(0x6C6F7362u, &v4);
            Format<std::string>("prLockedInSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
        }
      }
    }
    else if (a1 <= 1668313714)
    {
      if (a1 > 1634956408)
      {
        if (a1 > 1667851117)
        {
          if (a1 > 1668246895)
          {
            if (a1 != 1668246896)
            {
              if (a1 == 1668247156)
              {
                OSTypeAsString(0x636F6E74u, &v4);
                Format<std::string>("prICloudContainer (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x636F6D70u, &v4);
            Format<std::string>("prIsSystemCompressed (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
          }
          else
          {
            if (a1 != 1667851118)
            {
              if (a1 == 1668115828)
              {
                OSTypeAsString(0x636D6D74u, &v4);
                Format<std::string>("prFinderComment (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x6369636Eu, &v4);
            Format<std::string>("prHasCustomIcon (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 > 1667330144)
        {
          if (a1 != 1667330145)
          {
            if (a1 == 1667785588)
            {
              OSTypeAsString(0x63686374u, &v4);
              Format<std::string>("prChildCount (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x63617061u, &v4);
          Format<std::string>("prCapacity (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1634956409)
        {
          OSTypeAsString(0x61737479u, &v4);
          Format<std::string>("prType (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1635085684)
        {
          OSTypeAsString(0x61756D74u, &v4);
          Format<std::string>("prIsAboutToUnmount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
      else if (a1 > 1634758243)
      {
        if (a1 > 1634952035)
        {
          if (a1 == 1634952036)
          {
            OSTypeAsString(0x61736364u, &v4);
            Format<std::string>("prCreationDate (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1634954347)
          {
            OSTypeAsString(0x61736C6Bu, &v4);
            Format<std::string>("prIsLocked (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 == 1634758244)
          {
            OSTypeAsString(0x61706E64u, &v4);
            Format<std::string>("prAppNapIsDisabled (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1634758765)
          {
            OSTypeAsString(0x6170706Du, &v4);
            Format<std::string>("prIsApplicationManaged (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
      }
      else
      {
        if (a1 <= 1634497638)
        {
          if (a1)
          {
            if (a1 == 1231843171)
            {
              OSTypeAsString(0x496C6F63u, &v4);
              Format<std::string>("prIconSpatialLocation (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0, &v4);
          Format<std::string>("prNullProperty (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1634497639)
        {
          OSTypeAsString(0x616C7467u, &v4);
          Format<std::string>("prAliasTargetChanged (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1634755444)
        {
          OSTypeAsString(0x61706374u, &v4);
          Format<std::string>("prAppCategories (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
    }
    else
    {
      if (a1 > 1684366193)
      {
        if (a1 <= 1685287795)
        {
          if (a1 <= 1684893816)
          {
            if (a1 == 1684366194)
            {
              OSTypeAsString(0x64656372u, &v4);
              Format<std::string>("prItemDecorations (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1684630627)
            {
              OSTypeAsString(0x64696C63u, &v4);
              Format<std::string>("prDesktopIconSpatialLocation (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 == 1684893817)
          {
            OSTypeAsString(0x646D7079u, &v4);
            Format<std::string>("prApplicationDeviceManagementPolicy (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1684955501)
            goto LABEL_405;
          OSTypeAsString(0x646E616Du, &v4);
          Format<std::string>("prDisplayName (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
        }
        else if (a1 <= 1685548131)
        {
          if (a1 == 1685287796)
          {
            OSTypeAsString(0x64737374u, &v4);
            Format<std::string>("prDSStoreStatus (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1685480308)
            goto LABEL_405;
          OSTypeAsString(0x64766374u, &v4);
          Format<std::string>("prDeepVisibleItemCount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
        }
        else
        {
          switch(a1)
          {
            case 1685548132:
              OSTypeAsString(0x64776C64u, &v4);
              Format<std::string>("prProviderDownloadedState (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_408;
              break;
            case 1701277813:
              OSTypeAsString(0x65677075u, &v4);
              Format<std::string>("prPrefersExternalGPU (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            case 1717793396:
              OSTypeAsString(0x66637274u, &v4);
              Format<std::string>("prCreator (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_408;
              break;
            default:
              goto LABEL_405;
          }
        }
        goto LABEL_404;
      }
      if (a1 > 1684107378)
      {
        if (a1 > 1684237411)
        {
          if (a1 == 1684237412)
          {
            OSTypeAsString(0x64636C64u, &v4);
            Format<std::string>("prIsDataSeparatedICloudInSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1684237940)
            goto LABEL_405;
          OSTypeAsString(0x64636E74u, &v4);
          Format<std::string>("prDeepItemCount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1684107379)
        {
          OSTypeAsString(0x64617073u, &v4);
          Format<std::string>("prDataForkPhysicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1684108403)
        {
          OSTypeAsString(0x64617473u, &v4);
          Format<std::string>("prDataForkLogicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
      else
      {
        if (a1 > 1668506983)
        {
          if (a1 != 1668506984)
          {
            if (a1 == 1668507504)
            {
              OSTypeAsString(0x63736770u, &v4);
              Format<std::string>("prCanSetPrefersExternalGPU (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x63736568u, &v4);
          Format<std::string>("prCanSetExtensionHidden (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1668313715)
        {
          OSTypeAsString(0x63707273u, &v4);
          Format<std::string>("prCopyrightString (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1668505966)
        {
          OSTypeAsString(0x6373616Eu, &v4);
          Format<std::string>("prCanSetAppNapState (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
    }
  }
  else if (a1 <= 1919251314)
  {
    if (a1 <= 1870098033)
    {
      if (a1 > 1836282479)
      {
        if (a1 > 1869375854)
        {
          if (a1 > 1869379186)
          {
            if (a1 != 1869379187)
            {
              if (a1 == 1869769063)
              {
                OSTypeAsString(0x6F726967u, &v4);
                Format<std::string>("prOriginatorInfo (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x6F6C7673u, &v4);
            Format<std::string>("prOldViewStyle (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1869375855)
          {
            OSTypeAsString(0x6F6C696Fu, &v4);
            Format<std::string>("prOldIconOrigin (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1869377379)
          {
            OSTypeAsString(0x6F6C6F63u, &v4);
            Format<std::string>("prOldLocation (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 > 1853318003)
          {
            if (a1 != 1853318004)
            {
              if (a1 == 1868720740)
              {
                OSTypeAsString(0x6F626A64u, &v4);
                Format<std::string>("prObjectIdentifier (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x6E776374u, &v4);
            Format<std::string>("prNetworkComment (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1836282480)
          {
            OSTypeAsString(0x6D737270u, &v4);
            Format<std::string>("prIsMountedSharepoint (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
          if (a1 == 1853121395)
          {
            OSTypeAsString(0x6E746373u, &v4);
            Format<std::string>("prNetworkConnectionState (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_408;
            goto LABEL_404;
          }
        }
      }
      else
      {
        if (a1 > 1835295091)
        {
          if (a1 <= 1836016707)
          {
            if (a1 == 1835295092)
            {
              OSTypeAsString(0x6D646174u, &v4);
              Format<std::string>("prMDAttributes (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1836008516)
            {
              OSTypeAsString(0x6D6F4444u, &v4);
              Format<std::string>("prCachedLogicalTimeStamp (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 == 1836016708)
          {
            OSTypeAsString(0x6D6F6444u, &v4);
            Format<std::string>("prCachedPhysicalTimeStamp (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1836016740)
            goto LABEL_405;
          OSTypeAsString(0x6D6F6464u, &v4);
          Format<std::string>("prModificationDate (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 <= 1819632755)
        {
          if (a1 == 1819501924)
          {
            OSTypeAsString(0x6C736564u, &v4);
            Format<std::string>("prICloudLastShareEditor (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1819503973)
          {
            OSTypeAsString(0x6C736D65u, &v4);
            Format<std::string>("prICloudLastChangedByMe (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 == 1819632756)
        {
          OSTypeAsString(0x6C756474u, &v4);
          Format<std::string>("prLastUsedDate (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1835291497)
        {
          OSTypeAsString(0x6D645369u, &v4);
          Format<std::string>("prMDSortIdentifier (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
    }
    else if (a1 <= 1885895026)
    {
      if (a1 > 1885626994)
      {
        if (a1 > 1885876562)
        {
          if (a1 == 1885876563)
          {
            OSTypeAsString(0x70683153u, &v4);
            Format<std::string>("prCachedPhysicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1885894995)
          {
            OSTypeAsString(0x70687953u, &v4);
            Format<std::string>("prObsoleteCachedPhysicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
        }
        else
        {
          if (a1 == 1885626995)
          {
            OSTypeAsString(0x70646273u, &v4);
            Format<std::string>("prIsDeviceBusy (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1885627244)
          {
            OSTypeAsString(0x7064636Cu, &v4);
            Format<std::string>("prIsDeviceOperationCancellable (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
        }
        goto LABEL_405;
      }
      if (a1 > 1883665004)
      {
        if (a1 == 1883665005)
        {
          OSTypeAsString(0x7046726Du, &v4);
          Format<std::string>("prIsFullyFormed (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1885434984)
          goto LABEL_405;
        OSTypeAsString(0x70617468u, &v4);
        Format<std::string>("prPath (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      if (a1 == 1870098034)
      {
        OSTypeAsString(0x6F776E72u, &v4);
        Format<std::string>("prOwner (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      if (a1 == 1883333732)
      {
        OSTypeAsString(0x70416464u, &v4);
        Format<std::string>("prDateAdded (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
    }
    else if (a1 <= 1886613603)
    {
      if (a1 > 1886540642)
      {
        if (a1 == 1886540643)
        {
          OSTypeAsString(0x70725363u, &v4);
          Format<std::string>("prSecurityRef (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1886549619)
        {
          OSTypeAsString(0x70727673u, &v4);
          Format<std::string>("prPermissions (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
      else
      {
        if (a1 == 1885895027)
        {
          OSTypeAsString(0x70687973u, &v4);
          Format<std::string>("prPhysicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
        if (a1 == 1886282093)
        {
          OSTypeAsString(0x706E616Du, &v4);
          Format<std::string>("prName (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        }
      }
    }
    else
    {
      if (a1 <= 1886675533)
      {
        if (a1 != 1886613604)
        {
          if (a1 == 1886675532)
          {
            OSTypeAsString(0x7074624Cu, &v4);
            Format<std::string>("prTrashItemOriginalLocation (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x70737064u, &v4);
        Format<std::string>("prIsStationery (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      switch(a1)
      {
        case 1886675534:
          OSTypeAsString(0x7074624Eu, &v4);
          Format<std::string>("prTrashItemOriginalName (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        case 1919250547:
          OSTypeAsString(0x72657073u, &v4);
          Format<std::string>("prResourceForkPhysicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
        case 1919251312:
          OSTypeAsString(0x72657370u, &v4);
          Format<std::string>("prReclaimableSpace (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
          goto LABEL_404;
      }
    }
  }
  else if (a1 > 1952740194)
  {
    if (a1 <= 1970497393)
    {
      if (a1 <= 1969386593)
      {
        if (a1 <= 1969385825)
        {
          if (a1 == 1952740195)
          {
            OSTypeAsString(0x74647363u, &v4);
            Format<std::string>("prTagIsDiscovered (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1953718898)
          {
            OSTypeAsString(0x74736272u, &v4);
            Format<std::string>("prTagShowsInSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 == 1969385826)
        {
          OSTypeAsString(0x75627162u, &v4);
          Format<std::string>("prUbiquityTotalBytes (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1969385844)
          goto LABEL_405;
        OSTypeAsString(0x75627174u, &v4);
        Format<std::string>("prUbiquityStatus (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      if (a1 <= 1970170986)
      {
        if (a1 != 1969386594)
        {
          if (a1 == 1969646708)
          {
            OSTypeAsString(0x75666C74u, &v4);
            Format<std::string>("prIsUbiquityFault (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x75627462u, &v4);
        Format<std::string>("prUbiquityTransferredBytes (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      if (a1 == 1970170987)
      {
        OSTypeAsString(0x756E6C6Bu, &v4);
        Format<std::string>("prIsNoUnlink (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        goto LABEL_406;
      }
      if (a1 == 1970495843)
      {
        OSTypeAsString(0x75736163u, &v4);
        Format<std::string>("prUserAccess (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
    }
    else
    {
      if (a1 > 1986424179)
      {
        if (a1 <= 1987273323)
        {
          if (a1 != 1986424180)
          {
            if (a1 == 1987013741)
            {
              OSTypeAsString(0x766F6C6Du, &v4);
              Format<std::string>("prIsVolume (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x76666D74u, &v4);
          Format<std::string>("prVolumeFormat (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_408;
        }
        else
        {
          switch(a1)
          {
            case 1987273324:
              OSTypeAsString(0x7673626Cu, &v4);
              Format<std::string>("prIsVisible (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_408;
              break;
            case 1987277938:
              OSTypeAsString(0x76737472u, &v4);
              Format<std::string>("prVolumeFormatString (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_408;
              break;
            case 1987406180:
              OSTypeAsString(0x76756964u, &v4);
              Format<std::string>("prVolumeUUID (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            default:
              goto LABEL_405;
          }
        }
        goto LABEL_404;
      }
      if (a1 > 1970566255)
      {
        if (a1 == 1970566256)
        {
          OSTypeAsString(0x75747470u, &v4);
          Format<std::string>("prUTType (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1986359923)
          goto LABEL_405;
        OSTypeAsString(0x76657273u, &v4);
        Format<std::string>("prLongVersion (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      if (a1 == 1970497394)
      {
        OSTypeAsString(0x75736772u, &v4);
        Format<std::string>("prUserGroups (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
      if (a1 == 1970563428)
      {
        OSTypeAsString(0x75746964u, &v4);
        Format<std::string>("prTypeIdentifier (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
        goto LABEL_404;
      }
    }
  }
  else
  {
    if (a1 <= 1936225905)
    {
      if (a1 > 1935829346)
      {
        if (a1 <= 1936221803)
        {
          if (a1 == 1935829347)
          {
            OSTypeAsString(0x73626963u, &v4);
            Format<std::string>("prSidebarIconRef (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1935829368)
          {
            OSTypeAsString(0x73626978u, &v4);
            Format<std::string>("prSidebarIndex (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 != 1936221804)
        {
          if (a1 == 1936225392)
          {
            OSTypeAsString(0x73687470u, &v4);
            Format<std::string>("prIsTopLevelSharedItem (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x7368666Cu, &v4);
        Format<std::string>("prIsPublishedFolder (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
      }
      else
      {
        if (a1 > 1920167266)
        {
          if (a1 == 1920167267)
          {
            OSTypeAsString(0x72736D63u, &v4);
            Format<std::string>("prIsResumableCopyTarget (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1920167792)
          {
            OSTypeAsString(0x72736F70u, &v4);
            Format<std::string>("prResolveOptions (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 != 1919251315)
        {
          if (a1 == 1920103284)
          {
            OSTypeAsString(0x72727374u, &v4);
            Format<std::string>("prRegionRestrictions (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x72657373u, &v4);
        Format<std::string>("prResourceForkLogicalSize (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
      }
      goto LABEL_404;
    }
    if (a1 <= 1937143149)
    {
      if (a1 > 1936484459)
      {
        if (a1 == 1936484460)
        {
          OSTypeAsString(0x736C686Cu, &v4);
          Format<std::string>("prSLHighlight (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1937008498)
          goto LABEL_405;
        OSTypeAsString(0x73746772u, &v4);
        Format<std::string>("prSortingGroup (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
      }
      else
      {
        if (a1 != 1936225906)
        {
          if (a1 == 1936484457)
          {
            OSTypeAsString(0x736C6869u, &v4);
            Format<std::string>("prSLHighlightID (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x73687672u, &v4);
        Format<std::string>("prShortVersion (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_408;
      }
      goto LABEL_404;
    }
    if (a1 > 1937339249)
    {
      if (a1 == 1937339250)
      {
        OSTypeAsString(0x73797372u, &v4);
        Format<std::string>("prIsSystemRestricted (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        goto LABEL_406;
      }
      if (a1 != 1937340018)
      {
        if (a1 == 1952673396)
        {
          OSTypeAsString(0x74636E74u, &v4);
          Format<std::string>("prTagInstancesCount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        goto LABEL_405;
      }
      OSTypeAsString(0x73797672u, &v4);
      Format<std::string>("prSystemVersion (%s)", (uint64_t)&v4, &__p);
      TString::TString(a2, (uint64_t)&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_408;
LABEL_404:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_408;
    }
    if (a1 == 1937143150)
    {
      OSTypeAsString(0x7376756Eu, &v4);
      Format<std::string>("prServerUserName (%s)", (uint64_t)&v4, &__p);
      TString::TString(a2, (uint64_t)&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_408;
      goto LABEL_404;
    }
    if (a1 == 1937334902)
    {
      OSTypeAsString(0x73796276u, &v4);
      Format<std::string>("prSystemBuildVersion (%s)", (uint64_t)&v4, &__p);
      TString::TString(a2, (uint64_t)&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_408;
      goto LABEL_404;
    }
  }
LABEL_405:
  v3 = a1;
  OSTypeAsString(a1, &v4);
  Format<unsigned int,std::string>("0x%x (%s)", (unsigned int *)&v3, (uint64_t)&v4, &__p);
  TString::TString(a2, (uint64_t)&__p);
LABEL_406:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_408:
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v4.__r_.__value_.__l.__data_);
}

void sub_1CBC72A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  if (a16 < 0)
    operator delete(a11);
  _Unwind_Resume(exception_object);
}

TString *TString::TString(TString *a1, uint64_t a2)
{
  int v4;
  const UInt8 *v5;
  CFIndex v6;

  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = (const UInt8 *)a2;
  else
    v5 = *(const UInt8 **)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  TString::SetFromUTF8(a1, v5, v6);
  return a1;
}

void sub_1CBC73134(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void Format<std::string>(const char *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  __int128 v5;

  *(_QWORD *)&v5 = a1;
  *((_QWORD *)&v5 + 1) = strlen(a1);
  FormatDetails<std::string>(&v5, a2, a3);
}

void OSTypeAsString(unsigned int a1@<W0>, std::string *a2@<X8>)
{
  uint64_t v3;
  unint64_t v4;
  std::string::value_type v5;
  unsigned int v6;

  v3 = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  v6 = bswap32(a1);
  do
  {
    v4 = *((unsigned __int8 *)&v6 + v3);
    if (v4 == 37)
    {
      v5 = 37;
      std::string::push_back(a2, 37);
    }
    else
    {
      v5 = *((_BYTE *)&v6 + v3);
      if ((char)v4 <= 32)
      {
        std::string::push_back(a2, 37);
        std::string::push_back(a2, OSTypeAsString::digits[v4 >> 4]);
        v5 = OSTypeAsString::digits[v4 & 0xF];
      }
    }
    std::string::push_back(a2, v5);
    ++v3;
  }
  while (v3 != 4);
}

void sub_1CBC73248(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

_QWORD *AllowedPaths@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v2;

  {
    AllowedPaths(void)::$_0::operator()();
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<TString>::__init_with_size[abi:ne180100]<TString*,TString*>(a1, AllowedPaths(void)::allowedPaths, qword_1EDB96AC0, (qword_1EDB96AC0 - AllowedPaths(void)::allowedPaths) >> 3);
}

void sub_1CBC732D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFTypeRef *std::vector<TString>::__swap_out_circular_buffer(CFTypeRef *result, _QWORD *a2)
{
  uint64_t *v3;
  CFTypeRef *v4;
  CFTypeRef *v5;
  CFTypeRef *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (uint64_t *)result;
  v5 = (CFTypeRef *)*result;
  v4 = (CFTypeRef *)result[1];
  v6 = (CFTypeRef *)a2[1];
  while (v4 != v5)
    result = std::construct_at[abi:ne180100]<TString,TString,TString*>(--v6, --v4);
  a2[1] = v6;
  v7 = *v3;
  *v3 = (uint64_t)v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<TString>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBC7342C(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBC734EC(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TString::SubStringFrom(TString *this@<X0>, uint64_t a2@<X1>, TString *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;

  if (a2 == -1)
    v5 = 0;
  else
    v5 = a2;
  v6 = CFStringGetLength(this->fString.fRef) - v5;
  TString::SubString(this, v5, v6, a3);
}

const void **TRef<__SecTask *,CFRetainReleasePolicy>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

id CloudDocsRootURL(void)
{
  void *v0;
  id v1;
  id v3;
  _QWORD v4[5];

  v3 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3321888768;
  v4[2] = ___ZZ16CloudDocsRootURLvENK3__0cvU13block_pointerFvP5NSURLP7NSErrorEEv_block_invoke;
  v4[3] = &__block_descriptor_40_ea8_32c30_ZTSKZ16CloudDocsRootURLvE3__0_e27_v24__0__NSURL_8__NSError_16l;
  v4[4] = &v3;
  v0 = (void *)MEMORY[0x1D17A5A30](v4);
  BRGetCloudDocsRootURL();

  v1 = v3;
  return v1;
}

void sub_1CBC735FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

const void **GetICloudContainerURL@<X0>(const TString *a1@<X0>, CFURLRef *a2@<X8>)
{
  CFTypeRef v4;
  const void *v5;
  CFTypeRef v6;
  const __CFString *v7;
  TString v9;
  CFTypeRef cf;

  TString::TString(&v9, "x-apple-finder:icloud", 0x15uLL);
  AppendPath(&v9, a1, (TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  if (cf && (v4 = CFRetain(cf), (v5 = static_cf_cast<__CFString const*,void const*>(v4)) != 0))
  {
    v6 = CFAutorelease(v5);
    v7 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v6);
  }
  else
  {
    v7 = 0;
  }
  *a2 = CFURLCreateWithString(0, v7, 0);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1CBC736A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void **AppendPath@<X0>(const TString *a1@<X0>, const TString *a2@<X1>, TString *a3@<X8>)
{
  BOOL v6;
  const __CFString *v7;
  CFMutableStringRef MutableCopy;
  TString v10;
  CFStringRef theString;

  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&theString, (TString *)a1->fString.fRef);
  if (CFStringGetLength(a2->fString.fRef))
  {
    if (CFStringGetLength(theString))
    {
      TString::TString(&v10, "/", 1uLL);
      v6 = TString::EndsWith((TString *)&theString, &v10);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
      if (!v6)
        TString::Append((TString *)&theString, (const __CFString *)(unsigned __int16)TPathName::kPOSIXPathNameSeparator);
    }
  }
  v7 = theString;
  a3->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v7);
  CFRelease(&stru_1E8752DF8);
  a3->fString.fRef = MutableCopy;
  TString::Append(a3, a2);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1CBC737C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

TString *TString::Append(TString *this, const __CFString *a2)
{
  __CFString *v3;
  UniChar chars;

  chars = (unsigned __int16)a2;
  v3 = (__CFString *)TString::MutableRef(this, a2);
  CFStringAppendCharacters(v3, &chars, 1);
  return this;
}

{
  __CFString *v4;

  v4 = (__CFString *)TString::MutableRef(this, a2);
  CFStringAppendCString(v4, (const char *)a2, 0x8000100u);
  return this;
}

id TFSInfo::ApproximateUTType(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  __CFString *v3;
  void *v4;
  void *v5;
  char v6;
  int v7;
  _QWORD *v8;
  id v9;
  CFStringRef theString;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = (__CFString *)*((_QWORD *)this + 2);
  theString = v3;
  if (v3)
    CFRetain(v3);
  os_unfair_lock_unlock(v2);
  TCFURLInfo::ObjectProperty((TCFURLInfo *)v3, (const __CFString *)*MEMORY[0x1E0C998E0], 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  static_objc_cast<NSString,objc_object * {__strong}>(v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&theString);
  if (!v5)
  {
    TFSInfo::ActualSuffix(this, (TString *)&theString);
    os_unfair_lock_lock(v2);
    v6 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v2);
    os_unfair_lock_lock(v2);
    v7 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v2);
    if (CFStringGetLength(theString))
    {
      if ((v7 & 2) != 0)
        v8 = (_QWORD *)MEMORY[0x1E0CEC588];
      else
        v8 = (_QWORD *)MEMORY[0x1E0CEC4A0];
      objc_msgSend(MEMORY[0x1E0CEC3F8], "typeWithFilenameExtension:conformingToType:", theString, *v8);
      v9 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v5 = 0;
      if ((v6 & 0x20) == 0 || (v7 & 2) != 0)
        goto LABEL_13;
      v9 = (id)*MEMORY[0x1E0CEC4F0];
    }
    v5 = v9;
LABEL_13:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  return v5;
}

void sub_1CBC73988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _Unwind_Resume(exception_object);
}

const void **TFSInfo::ActualSuffix@<X0>(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  TString *v3;
  TString v5;

  TFSInfo::Name(this, &v5);
  -[__CFString pathExtension](v5.fString.fRef, "pathExtension");
  v3 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, v3);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
}

void sub_1CBC73A4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  const void **v3;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **FileSuffix@<X0>(const TString *a1@<X0>, TString *a2@<X8>)
{
  TString *v3;
  __CFString *fRef;
  CFMutableStringRef MutableCopy;
  TString v7;
  CFStringRef theString;

  -[__CFString pathExtension](a1->fString.fRef, "pathExtension");
  v3 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&theString, v3);

  if (CFStringGetLength(theString))
  {
    TString::TString(&v7, ".", 1uLL);
    fRef = v7.fString.fRef;
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, fRef);
    CFRelease(&stru_1E8752DF8);
    a2->fString.fRef = MutableCopy;
    TString::Append(a2, (const TString *)&theString);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  }
  else
  {
    a2->fString.fRef = (__CFString *)theString;
    theString = 0;
    CFRetain(&stru_1E8752DF8);
    if (theString)
      CFRelease(theString);
    theString = &stru_1E8752DF8;
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1CBC73BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  const void **v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

TString *TString::Append(TString *this, const TString *a2)
{
  const __CFString *v4;
  unsigned int IsMutable;
  __CFString *v6;
  __CFString *MutableCopy;

  if (CFStringGetLength(this->fString.fRef))
    goto LABEL_5;
  IsMutable = (unsigned __int16)TString::IsMutable((TString *)this->fString.fRef, v4);
  if (IsMutable <= 0x100)
    LOBYTE(IsMutable) = 0;
  if ((_BYTE)IsMutable)
  {
LABEL_5:
    v6 = (__CFString *)TString::MutableRef(this, v4);
    CFStringAppend(v6, a2->fString.fRef);
  }
  else
  {
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a2->fString.fRef);
    if (this->fString.fRef)
      CFRelease(this->fString.fRef);
    this->fString.fRef = MutableCopy;
  }
  return this;
}

const void *TString::MutableRef(TString *this, const __CFString *a2)
{
  unsigned int IsMutable;
  __CFString *fRef;

  IsMutable = (unsigned __int16)TString::IsMutable((TString *)this->fString.fRef, a2);
  if (IsMutable <= 0x100)
    LOBYTE(IsMutable) = 0;
  fRef = this->fString.fRef;
  if (!(_BYTE)IsMutable)
  {
    fRef = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, this->fString.fRef);
    if (this->fString.fRef)
      CFRelease(this->fString.fRef);
    this->fString.fRef = fRef;
  }
  return static_cf_cast<__CFString const*,void const*>(fRef);
}

void ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke(uint64_t a1)
{
  id v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[4];
  id v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  char v22;

  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3321888768;
  v16[2] = ___ZZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEENK3__0clEv_block_invoke;
  v16[3] = &__block_descriptor_73_ea8_32c13_ZTS8TNodePtr40c47_ZTSRKNSt3__110shared_ptrI17TVolumeSyncThreadEE56c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE_e5_v8__0l;
  v22 = *(_BYTE *)(a1 + 72);
  v2 = *(id *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(std::__shared_weak_count **)(a1 + 40);
  v17 = v2;
  v18 = v3;
  v19 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *(std::__shared_weak_count **)(a1 + 56);
  v20 = *(_QWORD *)(a1 + 48);
  v21 = v7;
  if (v7)
  {
    v8 = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  ExceptionSafeBlock(v16);
  v10 = v21;
  if (v21)
  {
    v11 = (unint64_t *)&v21->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v19;
  if (v19)
  {
    v14 = (unint64_t *)&v19->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

}

void sub_1CBC73E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  std::__shared_weak_count **v17;

  if (a17)
    ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke_cold_2(a17);
  ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke_cold_1(v17);

  _Unwind_Resume(a1);
}

void ExceptionSafeBlock(void *a1)
{
  void *v1;
  void (**v2)(void);

  v2 = a1;
  v1 = (void *)MEMORY[0x1D17A5880]();
  v2[2]();
  objc_autoreleasePoolPop(v1);

}

TNodeTask *TNode::HandleNodeRequest(id **a1)
{
  id *v2;
  int v3;
  FINode *v4;
  int v5;
  int v6;
  int Property;
  TNode *v8;
  TNodePtr v10;

  v2 = *a1;
  if (v2 && *((_DWORD *)v2 + 13) != 1003)
  {
    TNodeTask::SetRequestStatus((TNodeTask *)v2, 1002);
    v4 = (FINode *)**a1;
    v3 = 0;
    v10.fFINode = v4;
    v5 = *((_DWORD *)*a1 + 4);
    v6 = 1;
    switch(v5)
    {
      case 1000:
        TNode::HandleSync(a1, &v10.fFINode);
        goto LABEL_27;
      case 1001:
        v6 = 0;
        goto LABEL_15;
      case 1002:
      case 1004:
      case 1005:
      case 1006:
      case 1013:
      case 1014:
      case 1015:
      case 1016:
      case 1017:
      case 1018:
      case 1020:
      case 1022:
      case 1025:
      case 1026:
      case 1027:
        break;
      case 1003:
        TNode::HandleRegisterForNotification((TNodeTask **)a1, &v10.fFINode);
        goto LABEL_27;
      case 1007:
        TNode::HandleMarkAsUsed((uint64_t)v4, &v10.fFINode);
        goto LABEL_27;
      case 1008:
        Property = TNode::HandleSubscribeWithKQueue((uint64_t)v4, &v10.fFINode);
        goto LABEL_32;
      case 1009:
        Property = TNode::HandleUnsubscribeWithKQueue((uint64_t)v4, &v10.fFINode);
        goto LABEL_32;
      case 1010:
        Property = TNode::HandleVolumeDeleted((uint64_t)v4, &v10.fFINode);
        goto LABEL_32;
      case 1011:
        TNodeFromFINode(v4);
        goto LABEL_27;
      case 1012:
        TFSInfo::MarkAsUsed(0);
        v3 = 0;
        break;
      case 1019:
        v8 = (TNode *)TNodeFromFINode(v4);
        TNode::DoExternalUnRegistration(v8);
        goto LABEL_27;
      case 1021:
        TNode::HandleRegisterInternalNotificationTask((uint64_t)v4, &v10.fFINode);
        goto LABEL_27;
      case 1023:
        TNode::HandleSyncComputerName((TNode *)v4);
        goto LABEL_27;
      case 1024:
LABEL_15:
        Property = TNode::HandleVolumeAdded((uint64_t)a1, v6);
LABEL_32:
        v3 = Property;
        break;
      case 1028:
        TNode::HandleFPProviderError((uint64_t)v4, &v10.fFINode);
LABEL_27:
        v3 = 0;
        break;
      default:
        switch(v5)
        {
          case 1:
            Property = TNode::HandleFetchProperty((uint64_t)a1, &v10.fFINode);
            goto LABEL_32;
          case 2:
            Property = TNode::HandleStoreProperty((uint64_t)a1, &v10.fFINode);
            goto LABEL_32;
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 9:
            goto LABEL_33;
          case 8:
            Property = TNode::HandleFetchBookmarkData((uint64_t *)a1, &v10);
            goto LABEL_32;
          case 10:
            Property = TNode::HandleResolveAlias(a1, &v10.fFINode);
            goto LABEL_32;
          case 11:
            Property = TNode::HandleFetchNodeRequest(a1);
            goto LABEL_32;
          default:
            switch(v5)
            {
              case ' ':
                Property = TNode::HandleOpenScreenShareRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '!':
                Property = TNode::HandleOpenServerRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '"':
                Property = TNode::HandleDisconnectShareRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '#':
                Property = TNode::HandleAddServerToSidebarRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '$':
                Property = TNode::HandleRemoveServerFromSidebarRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              default:
                goto LABEL_33;
            }
        }
    }
LABEL_33:

    v2 = *a1;
  }
  else
  {
    v3 = -128;
  }
  return TNodeTask::SetRequestStatus((TNodeTask *)v2, v3);
}

void sub_1CBC7415C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

TNodeTask *TNodeTask::SetRequestStatus(TNodeTask *this, int a2)
{
  if (*((int *)this + 13) >= 1)
    *((_DWORD *)this + 13) = a2;
  return this;
}

void TNode::PostNodeTaskRequest(uint64_t a1, _QWORD *a2)
{
  TFSVolumeInfo *v4;
  int v5;
  TFSVolumeInfo *VolumeSyncThread;
  __int128 v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  os_unfair_lock_s *v19;
  int v20;
  unint64_t *v21;
  unint64_t v22;
  __int128 v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  uint64_t *v28;
  uint64_t *v29;
  const __CFString *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unsigned __int8 v37;
  NSObject *v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  _QWORD block[4];
  uint64_t v50;
  std::__shared_weak_count *v51;
  int v52;
  __int128 v53;
  __int128 v54;
  TFSVolumeInfo *v55;
  std::__shared_weak_count *v56;

  TNode::GetVolumeInfo((TNode *)a1, &v55);
  v4 = v55;
  if (!v55)
    goto LABEL_42;
  v5 = *(_DWORD *)(*a2 + 16);
  VolumeSyncThread = TFSVolumeInfo::GetVolumeSyncThread(v55, &v54);
  if ((v5 & 0xFFFFFFFD) == 1)
  {
    TFSVolumeInfo::GetPropertyUpdateThread(v4, &v53);
    v7 = v53;
    v53 = 0uLL;
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
    v54 = v7;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = (std::__shared_weak_count *)*((_QWORD *)&v53 + 1);
    if (*((_QWORD *)&v53 + 1))
    {
      v12 = (unint64_t *)(*((_QWORD *)&v53 + 1) + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      goto LABEL_11;
    }
    goto LABEL_35;
  }
  if (v5 != 1024 && v5 != 1001)
  {
    if (v5 == 1000)
    {
      v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)VolumeSyncThread);
      os_unfair_lock_lock(v14);
      v16 = *(_QWORD *)(a1 + 16);
      v15 = *(std::__shared_weak_count **)(a1 + 24);
      if (v15)
      {
        v17 = (unint64_t *)&v15->__shared_owners_;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      os_unfair_lock_unlock(v14);
      v19 = (os_unfair_lock_s *)(v16 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v16 + 100));
      v20 = *(_DWORD *)(v16 + 115);
      os_unfair_lock_unlock(v19);
      if (v15)
      {
        v21 = (unint64_t *)&v15->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      if ((v20 & 0x20) == 0)
      {
        TFSVolumeInfo::GetPropertyUpdateThread(v55, &v53);
        v23 = v53;
        v53 = 0uLL;
        v24 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
        v54 = v23;
        if (v24)
        {
          v25 = (unint64_t *)&v24->__shared_owners_;
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
        v11 = (std::__shared_weak_count *)*((_QWORD *)&v53 + 1);
        if (*((_QWORD *)&v53 + 1))
        {
          v27 = (unint64_t *)(*((_QWORD *)&v53 + 1) + 8);
          do
            v13 = __ldaxr(v27);
          while (__stlxr(v13 - 1, v27));
LABEL_11:
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
      }
    }
LABEL_35:
    if ((_QWORD)v54)
      TNodeTask::PostNodeTaskRequest((uint64_t)a2, (uint64_t)&v54);
    v31 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
    if (*((_QWORD *)&v54 + 1))
    {
      v32 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      goto LABEL_40;
    }
    goto LABEL_42;
  }
  v28 = (uint64_t *)(*a2 + 24);
  *(_QWORD *)&v53 = 0;
  v29 = TPropertyValue::As<__CFURL const*>(v28, (uint64_t **)&v53);
  if ((TCFURLInfo::GetBooleanProperty((TCFURLInfo *)v29, (const __CFString *)*MEMORY[0x1E0C9B6D8], v30) & 1) != 0)
    goto LABEL_35;
  if ((v37 & 1) == 0
  {
    TNode::PostNodeTaskRequest(std::shared_ptr<TNodeTask> const&)const::remoteMountQueue = (uint64_t)dispatch_queue_create("Remote Volumes Mounts", 0);
  }
  v38 = TNode::PostNodeTaskRequest(std::shared_ptr<TNodeTask> const&)const::remoteMountQueue;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEE_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c75_ZTSKZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEEE3__0_e5_v8__0l;
  v39 = *a2;
  v40 = (std::__shared_weak_count *)a2[1];
  if (v40)
  {
    v41 = (unint64_t *)&v40->__shared_owners_;
    do
      v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
    v50 = v39;
    v51 = v40;
    do
      v43 = __ldxr(v41);
    while (__stxr(v43 + 1, v41));
    v52 = v5;
    dispatch_async(v38, block);
    do
      v44 = __ldaxr(v41);
    while (__stlxr(v44 - 1, v41));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  else
  {
    v50 = v39;
    v51 = 0;
    v52 = v5;
    dispatch_async((dispatch_queue_t)TNode::PostNodeTaskRequest(std::shared_ptr<TNodeTask> const&)const::remoteMountQueue, block);
  }
  v45 = v51;
  if (v51)
  {
    v46 = (unint64_t *)&v51->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
  if (*((_QWORD *)&v54 + 1))
  {
    v48 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v33 = __ldaxr(v48);
    while (__stlxr(v33 - 1, v48));
LABEL_40:
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
LABEL_42:
  v34 = v56;
  if (v56)
  {
    v35 = (unint64_t *)&v56->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_1CBC74578(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1 - 64);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1 - 48);
  _Unwind_Resume(a1);
}

TFSVolumeInfo *TFSVolumeInfo::GetVolumeSyncThread@<X0>(TFSVolumeInfo *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *((_QWORD *)this + 41);
  *a2 = *((_QWORD *)this + 40);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

void TNodeTask::PostNodeTaskRequest(uint64_t a1, uint64_t a2)
{
  FINode *v4;
  id *v5;
  int v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  os_unfair_lock_s *v13;
  int v14;
  unint64_t *v15;
  unint64_t v16;
  char v17;
  NSObject *v18;
  std::__shared_weak_count *v19;
  id *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  id *v24;
  unint64_t *v25;
  unint64_t v26;
  FINode *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  _QWORD block[5];
  std::__shared_weak_count *v44;
  id *v45;
  std::__shared_weak_count *v46;
  FINode *v47;
  char v48;
  unsigned int v49;

  if ((TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)a2) & 1) == 0)
  {
    v4 = (FINode *)**(id **)a1;
    v5 = *(id **)a1;
    if (*(_DWORD *)(*(_QWORD *)a1 + 16) != 1000)
      goto LABEL_13;
    v49 = 0;
    v6 = TPropertyValue::As<NodeRequestOptions>((unsigned int *)v5 + 6, &v49);
    if ((v6 & 0x80000) != 0)
      goto LABEL_13;
    v7 = TNodeFromFINode(v4);
    v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v7);
    os_unfair_lock_lock(v8);
    v10 = *(_QWORD *)(v7 + 16);
    v9 = *(std::__shared_weak_count **)(v7 + 24);
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v8);
    v13 = (os_unfair_lock_s *)(v10 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
    v14 = *(_DWORD *)(v10 + 115);
    os_unfair_lock_unlock(v13);
    if (v9)
    {
      v15 = (unint64_t *)&v9->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if ((v14 & 0x20) != 0)
    {
      v42 = TNodeFromFINode(v4);
      if ((TNode::RedundantSync(v42, v6) & 1) != 0)
      {
LABEL_47:

        return;
      }
      v17 = 1;
    }
    else
    {
LABEL_13:
      v17 = 0;
    }
    NodeEventRefFromNodeEvent(*(id **)a2);
    v18 = objc_claimAutoreleasedReturnValue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke;
    block[3] = &__block_descriptor_80_ea8_32c98_ZTSKZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEE3__0_e5_v8__0l;
    v20 = *(id **)a2;
    v19 = *(std::__shared_weak_count **)(a2 + 8);
    if (v19)
    {
      v21 = (unint64_t *)&v19->__shared_owners_;
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    v24 = *(id **)a1;
    v23 = *(std::__shared_weak_count **)(a1 + 8);
    if (v23)
    {
      v25 = (unint64_t *)&v23->__shared_owners_;
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
    v27 = v4;
    block[4] = v20;
    v44 = v19;
    if (v19)
    {
      v28 = (unint64_t *)&v19->__shared_owners_;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    v45 = v24;
    v46 = v23;
    if (v23)
    {
      v30 = (unint64_t *)&v23->__shared_owners_;
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
    }
    v47 = v27;
    v48 = v17;
    dispatch_async(v18, block);
    if (v23)
    {
      v32 = (unint64_t *)&v23->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    if (v19)
    {
      v34 = (unint64_t *)&v19->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    v36 = v46;
    if (v46)
    {
      v37 = (unint64_t *)&v46->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v44;
    if (v44)
    {
      v40 = (unint64_t *)&v44->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    goto LABEL_47;
  }
}

void sub_1CBC748B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TVolumeSyncThread::SynchingCanceled(TVolumeSyncThread *this)
{
  return *((unsigned __int8 *)this + 9);
}

TFSVolumeInfo *TFSVolumeInfo::GetPropertyUpdateThread@<X0>(TFSVolumeInfo *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *((_QWORD *)this + 43);
  *a2 = *((_QWORD *)this + 42);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t TNode::HandleFetchProperty(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  TNode *v6;
  uint64_t Property;
  uint64_t v8;
  TNodeRequest *v10;
  TPropertyValue *v11;
  int v12;
  TPropertyValue v13;

  v3 = *(unsigned int *)(*(_QWORD *)a1 + 20);
  v4 = (unsigned int *)(*(_QWORD *)a1 + 24);
  v13.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 0;
  v5 = TPropertyValue::As<NodeRequestOptions>(v4, (unsigned int *)&v13) & 0xFFFFFFFD;
  v6 = (TNode *)TNodeFromFINode(*a2);
  TNode::UpdatePropertySynchronous(v6, v3, v5, 1);
  Property = 0;
  if ((_DWORD)v3 != 1718903156)
  {
    v13.fData.__impl_.__index = 0;
    v12 = 19;
    v11 = &v13;
    v8 = TNodeFromFINode(*a2);
    v10 = 0;
    Property = TNode::GetProperty(v8, v3, (TPropertyReference *)&v11, &v10, v5);
    TPropertyValue::~TPropertyValue(&v13);
  }
  return Property;
}

void sub_1CBC749BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, TPropertyValue *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a12);
  _Unwind_Resume(a1);
}

unint64_t TPropertyValue::As<NodeRequestOptions>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unint64_t v4;

  v2 = a1[4];
  v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_47;
      v3 = *a2;
      v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1)
        goto LABEL_47;
      goto LABEL_42;
    case 2:
      if (v2 != 2)
        goto LABEL_47;
      goto LABEL_42;
    case 3:
      if (v2 != 3)
        goto LABEL_47;
      goto LABEL_42;
    case 4:
      if (v2 != 4)
        goto LABEL_47;
      goto LABEL_44;
    case 5:
      if (v2 != 5)
        goto LABEL_47;
      goto LABEL_44;
    case 6:
      if (v2 != 6)
        goto LABEL_47;
      goto LABEL_42;
    case 7:
      if (v2 != 7)
        goto LABEL_47;
      goto LABEL_42;
    case 8:
      if (v2 != 8)
        goto LABEL_47;
      goto LABEL_42;
    case 9:
      goto LABEL_42;
    case 10:
      if (v2 != 10)
        goto LABEL_47;
      goto LABEL_42;
    case 11:
      if (v2 != 11)
        goto LABEL_47;
      goto LABEL_42;
    case 12:
      if (v2 != 12)
        goto LABEL_47;
      goto LABEL_42;
    case 13:
      if (v2 != 13)
        goto LABEL_47;
      goto LABEL_42;
    case 14:
      if (v2 != 14)
        goto LABEL_47;
      goto LABEL_42;
    case 15:
      if (v2 != 15)
        goto LABEL_47;
      goto LABEL_42;
    case 16:
      if (v2 != 16)
        goto LABEL_47;
      goto LABEL_42;
    case 17:
      if (v2 != 17)
        goto LABEL_47;
      goto LABEL_42;
    case 18:
      if (v2 != 18)
        goto LABEL_47;
      goto LABEL_42;
    case 19:
      if (v2 != 19)
        goto LABEL_47;
      goto LABEL_42;
    case 20:
      if (v2 != 20)
        goto LABEL_47;
LABEL_42:
      v4 = 0xFFFFE08E00000000;
      v3 = *a2;
      break;
    case 21:
      if (v2 == 21)
        goto LABEL_44;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_47;
      goto LABEL_44;
    case 23:
      if (v2 != 23)
LABEL_47:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_44:
      v4 = 0;
      v3 = *a1;
      break;
    default:
      v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

uint64_t TNode::UpdatePropertySynchronous(TNode *this, int a2, char a3, int a4)
{
  os_unfair_lock_s *v7;
  char v8;
  std::__shared_weak_count *v9;
  FINode *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t Property;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  os_unfair_lock_s *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  os_unfair_lock_s *v28;
  int v29;
  unint64_t *v30;
  unint64_t v31;
  FINode *v32;
  uint64_t v33;
  FINode *v34;
  os_unfair_lock_s *v35;
  char v36;
  std::__shared_weak_count *v37;
  FINode *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  os_unfair_lock_s *v47;
  std::__shared_weak_count *v48;
  FINode *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  FINode *v54;
  os_unfair_lock_s *v55;
  int v56;
  __int16 v57;
  os_unfair_lock_s *v58;
  std::__shared_weak_count *v59;
  FINode *v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  unint64_t *v65;
  os_unfair_lock_s *v66;
  std::__shared_weak_count *v67;
  uint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  os_unfair_lock_s *v71;
  int v72;
  CFIndex IsLockFile;
  unint64_t *v74;
  unint64_t v75;
  __CFString **v76;
  os_unfair_lock_s *v77;
  std::__shared_weak_count *v78;
  FINode *v79;
  unint64_t *p_shared_owners;
  unint64_t v81;
  uint64_t v82;
  unint64_t *v83;
  unint64_t v84;
  __CFString *v85;
  os_unfair_lock_s *v86;
  std::__shared_weak_count *v87;
  FINode *v88;
  unint64_t *v89;
  unint64_t v90;
  int refreshed;
  unint64_t *v92;
  unint64_t v93;
  char v94;
  unint64_t *v95;
  unint64_t v96;
  os_unfair_lock_s *v97;
  std::__shared_weak_count *v98;
  uint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  os_unfair_lock_s *v102;
  int v103;
  unint64_t *v104;
  unint64_t v105;
  FINode *v107;
  std::__shared_weak_count *v108;
  uint64_t v109;
  uint64_t v110;
  std::__shared_weak_count *v111;
  char v112;
  FINode *v113;
  TNodePtr v114;
  std::__shared_weak_count *v115;
  uint64_t *v116;
  _QWORD *v117;
  uint64_t v118;
  int v119;

  v119 = a2;
  v117 = 0;
  v118 = 0;
  v116 = (uint64_t *)&v117;
  if (a2 <= 1819240306)
  {
    if (a2 <= 1717793395)
    {
      if (a2 > 1667851117)
      {
        if (a2 > 1684893816)
        {
          if (a2 == 1684893817)
          {
            v77 = (os_unfair_lock_s *)TNode::InfoLock(this);
            os_unfair_lock_lock(v77);
            v79 = (FINode *)*((_QWORD *)this + 2);
            v78 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
            v107 = v79;
            v108 = v78;
            if (v78)
            {
              p_shared_owners = (unint64_t *)&v78->__shared_owners_;
              do
                v81 = __ldxr(p_shared_owners);
              while (__stxr(v81 + 1, p_shared_owners));
            }
            os_unfair_lock_unlock(v77);
            v82 = TFSInfo::ApplicationDMFPolicy((TFSInfo *)v79);
            if (v82 != TFSInfo::FetchApplicationDMFPolicy((TFSInfo *)v79))
            {
              LODWORD(v114.fFINode) = 1684893817;
              std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v116, (unsigned int *)&v114, &v114);
            }
            if (v78)
            {
              v83 = (unint64_t *)&v78->__shared_owners_;
              do
                v84 = __ldaxr(v83);
              while (__stlxr(v84 - 1, v83));
              if (!v84)
              {
                ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
                std::__shared_weak_count::__release_weak(v78);
              }
            }
            goto LABEL_174;
          }
          v22 = 1684955501;
          goto LABEL_92;
        }
        if (a2 == 1667851118)
          goto LABEL_93;
        v21 = 1668313715;
        goto LABEL_98;
      }
      if (a2 == 1634952036 || a2 == 1634956409)
        goto LABEL_93;
      v20 = 1667330145;
    }
    else
    {
      if (a2 > 1752392561)
      {
        if (a2 <= 1802072171)
        {
          if (a2 == 1752392562)
            goto LABEL_93;
          if (a2 != 1769170540)
            goto LABEL_156;
          v23 = (os_unfair_lock_s *)TNode::InfoLock(this);
          os_unfair_lock_lock(v23);
          v25 = *((_QWORD *)this + 2);
          v24 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
          if (v24)
          {
            v26 = (unint64_t *)&v24->__shared_owners_;
            do
              v27 = __ldxr(v26);
            while (__stxr(v27 + 1, v26));
          }
          os_unfair_lock_unlock(v23);
          v28 = (os_unfair_lock_s *)(v25 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v25 + 100));
          v29 = *(_DWORD *)(v25 + 115);
          os_unfair_lock_unlock(v28);
          if (v24)
          {
            v30 = (unint64_t *)&v24->__shared_owners_;
            do
              v31 = __ldaxr(v30);
            while (__stlxr(v31 - 1, v30));
            if (!v31)
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }
          }
          if ((v29 & 0x40) != 0)
          {
            TNode::GetAliasTarget(this, &v107);
            v32 = v107;
            v33 = TNodeFromFINode(v107);

            if (!v33)
            {
              v107 = 0;
              v114.fFINode = 0;
              Property = TNode::FollowAlias((_BOOL8)this, (TNodePtr *)&v107, (TNodeRequest **)&v114, 8);
              if (!(_DWORD)Property)
                std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v116, (unsigned int *)&v119, &v119);
              v34 = v107;
              goto LABEL_80;
            }
          }
          goto LABEL_174;
        }
        if (a2 != 1802072172)
        {
          v22 = 1818321516;
          goto LABEL_92;
        }
        goto LABEL_131;
      }
      if (a2 > 1718903155)
      {
        if (a2 == 1718903156)
        {
          v114.fFINode = 0;
          LODWORD(v108) = 17;
          v107 = (FINode *)&v114;
          Property = TNode::GetProperty((uint64_t)this, 1718903156, (uint64_t)&v107, 0);
          TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&v114.fFINode);
          goto LABEL_175;
        }
        v22 = 1751480436;
        goto LABEL_92;
      }
      if (a2 == 1717793396)
        goto LABEL_93;
      v20 = 1718776688;
    }
    if (a2 != v20)
      goto LABEL_156;
    TNode::RecalculateFreeSpaceAndCapacity(this, 1);
    goto LABEL_174;
  }
  if (a2 <= 1886613603)
  {
    if (a2 <= 1870098033)
    {
      if (a2 <= 1836016739)
      {
        if (a2 != 1819240307)
        {
          if (a2 == 1819632756)
          {
            v113 = 0;
            LODWORD(v108) = 7;
            v107 = (FINode *)&v113;
            v112 = 0;
            v7 = (os_unfair_lock_s *)TNode::InfoLock(this);
            v8 = a3 & 0x7D;
            os_unfair_lock_lock(v7);
            v10 = (FINode *)*((_QWORD *)this + 2);
            v9 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
            v114.fFINode = v10;
            v115 = v9;
            if (v9)
            {
              v11 = (unint64_t *)&v9->__shared_owners_;
              do
                v12 = __ldxr(v11);
              while (__stxr(v12 + 1, v11));
            }
            os_unfair_lock_unlock(v7);
            v110 = 0;
            v111 = 0;
            Property = TFSInfo::GetLastUsedDate((uint64_t)v10, (uint64_t)&v107, (uint64_t)&v110, v8, &v112);
            v14 = v111;
            if (v111)
            {
              v15 = (unint64_t *)&v111->__shared_owners_;
              do
                v16 = __ldaxr(v15);
              while (__stlxr(v16 - 1, v15));
              if (!v16)
              {
                ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
                std::__shared_weak_count::__release_weak(v14);
              }
            }
            if (v112)
              std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v116, (unsigned int *)&v119, &v119);
            v17 = v115;
            if (v115)
            {
              v18 = (unint64_t *)&v115->__shared_owners_;
              do
                v19 = __ldaxr(v18);
              while (__stlxr(v19 - 1, v18));
              goto LABEL_120;
            }
            goto LABEL_175;
          }
LABEL_156:
          Property = 4294959245;
          goto LABEL_175;
        }
        goto LABEL_122;
      }
      if (a2 != 1836016740)
      {
        if (a2 != 1869769063)
          goto LABEL_156;
        v113 = 0;
        LODWORD(v108) = 10;
        v107 = (FINode *)&v113;
        v112 = 0;
        v35 = (os_unfair_lock_s *)TNode::InfoLock(this);
        v36 = a3 & 0x7D;
        os_unfair_lock_lock(v35);
        v38 = (FINode *)*((_QWORD *)this + 2);
        v37 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
        v114.fFINode = v38;
        v115 = v37;
        if (v37)
        {
          v39 = (unint64_t *)&v37->__shared_owners_;
          do
            v40 = __ldxr(v39);
          while (__stxr(v40 + 1, v39));
        }
        os_unfair_lock_unlock(v35);
        v110 = 0;
        v111 = 0;
        Property = TFSInfo::GetOriginatorInfo((uint64_t)v38, (uint64_t)&v107, (uint64_t)&v110, v36, &v112);
        v41 = v111;
        if (v111)
        {
          v42 = (unint64_t *)&v111->__shared_owners_;
          do
            v43 = __ldaxr(v42);
          while (__stlxr(v43 - 1, v42));
          if (!v43)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }
        if (v112)
        {
          LODWORD(v110) = 1869769063;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v116, (unsigned int *)&v110, &v110);
        }
        v44 = v115;
        if (v115)
        {
          v45 = (unint64_t *)&v115->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }
        v34 = v113;
LABEL_80:

        goto LABEL_175;
      }
LABEL_93:
      if (!TNode::LowLevelIsLockFile(this))
        TNode::HandleSync((uint64_t)this, 0x10080000u);
      Property = 4294959239;
      goto LABEL_175;
    }
    if (a2 > 1885895026)
    {
      if (a2 == 1885895027)
      {
LABEL_122:
        v66 = (os_unfair_lock_s *)TNode::InfoLock(this);
        os_unfair_lock_lock(v66);
        v68 = *((_QWORD *)this + 2);
        v67 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
        v107 = (FINode *)v68;
        v108 = v67;
        if (v67)
        {
          v69 = (unint64_t *)&v67->__shared_owners_;
          do
            v70 = __ldxr(v69);
          while (__stxr(v70 + 1, v69));
        }
        os_unfair_lock_unlock(v66);
        v71 = (os_unfair_lock_s *)(v68 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v68 + 100));
        v72 = *(_DWORD *)(v68 + 115);
        os_unfair_lock_unlock(v71);
        if ((v72 & 0x2000000) != 0)
        {
          IsLockFile = TNode::LowLevelIsLockFile(this);
          v94 = IsLockFile;
          if (v67)
          {
            v95 = (unint64_t *)&v67->__shared_owners_;
            do
              v96 = __ldaxr(v95);
            while (__stlxr(v96 - 1, v95));
            if (!v96)
            {
              ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
              std::__shared_weak_count::__release_weak(v67);
            }
          }
          if ((v94 & 1) == 0)
            IsLockFile = TNode::HandleSync((uint64_t)this, 0x10080000u);
        }
        else if (v67)
        {
          v74 = (unint64_t *)&v67->__shared_owners_;
          do
            v75 = __ldaxr(v74);
          while (__stlxr(v75 - 1, v74));
          if (!v75)
          {
            ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
            std::__shared_weak_count::__release_weak(v67);
          }
        }
        v97 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLockFile);
        os_unfair_lock_lock(v97);
        v99 = *((_QWORD *)this + 2);
        v98 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
        if (v98)
        {
          v100 = (unint64_t *)&v98->__shared_owners_;
          do
            v101 = __ldxr(v100);
          while (__stxr(v101 + 1, v100));
        }
        os_unfair_lock_unlock(v97);
        v102 = (os_unfair_lock_s *)(v99 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v99 + 100));
        v103 = *(_DWORD *)(v99 + 115);
        os_unfair_lock_unlock(v102);
        if (v98)
        {
          v104 = (unint64_t *)&v98->__shared_owners_;
          do
            v105 = __ldaxr(v104);
          while (__stlxr(v105 - 1, v104));
          if (!v105)
          {
            ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
            std::__shared_weak_count::__release_weak(v98);
          }
        }
        if ((v103 & 0x20) != 0)
          TNode::UpdateSizeInfo(this);
        goto LABEL_174;
      }
      v22 = 1886549619;
    }
    else
    {
      if (a2 == 1870098034)
        goto LABEL_93;
      v22 = 1883333732;
    }
LABEL_92:
    if (a2 != v22)
      goto LABEL_156;
    goto LABEL_93;
  }
  if (a2 <= 1970497393)
  {
    if (a2 <= 1937340017)
    {
      if (a2 == 1886613604)
        goto LABEL_93;
      v21 = 1936225906;
      goto LABEL_98;
    }
    if (a2 == 1937340018)
      goto LABEL_99;
    if (a2 != 1969385844)
      goto LABEL_156;
LABEL_174:
    Property = 0;
    goto LABEL_175;
  }
  if (a2 <= 1970566255)
  {
    if (a2 == 1970497394)
      goto LABEL_93;
    if (a2 != 1970563428)
      goto LABEL_156;
LABEL_131:
    v76 = (__CFString **)MEMORY[0x1E0C9B5E0];
    if (a2 != 1970563428)
      v76 = (__CFString **)MEMORY[0x1E0C9B588];
    goto LABEL_146;
  }
  if (a2 == 1970566256)
  {
    v76 = (__CFString **)MEMORY[0x1E0C998E0];
LABEL_146:
    v85 = *v76;
    v86 = (os_unfair_lock_s *)TNode::InfoLock(this);
    os_unfair_lock_lock(v86);
    v88 = (FINode *)*((_QWORD *)this + 2);
    v87 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v107 = v88;
    v108 = v87;
    if (v87)
    {
      v89 = (unint64_t *)&v87->__shared_owners_;
      do
        v90 = __ldxr(v89);
      while (__stxr(v90 + 1, v89));
    }
    os_unfair_lock_unlock(v86);
    refreshed = TFSInfo::RefreshUTTypeProperty((TFSInfo *)v88, v85);
    if (v87)
    {
      v92 = (unint64_t *)&v87->__shared_owners_;
      do
        v93 = __ldaxr(v92);
      while (__stlxr(v93 - 1, v92));
      if (!v93)
      {
        ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
        std::__shared_weak_count::__release_weak(v87);
      }
    }
    if (refreshed)
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v116, (unsigned int *)&v119, &v119);
    goto LABEL_174;
  }
  v21 = 1986359923;
LABEL_98:
  if (a2 != v21)
    goto LABEL_156;
LABEL_99:
  v47 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v47);
  v49 = (FINode *)*((_QWORD *)this + 2);
  v48 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v114.fFINode = v49;
  v115 = v48;
  if (v48)
  {
    v50 = (unint64_t *)&v48->__shared_owners_;
    do
      v51 = __ldxr(v50);
    while (__stxr(v51 + 1, v50));
  }
  os_unfair_lock_unlock(v47);
  TFSInfo::CopyFSInfo((TFSInfo *)v49, (uint64_t *)&v107);
  if (v48)
  {
    v52 = (unint64_t *)&v48->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v54 = v107;
  v55 = (os_unfair_lock_s *)&v107[12].super.isa + 1;
  os_unfair_lock_lock((os_unfair_lock_t)&v107[12].super.isa + 1);
  v56 = *(_DWORD *)((char *)&v54[14].super.isa + 3);
  v54 = (FINode *)((char *)v54 + 115);
  v57 = WORD2(v54->super.isa);
  LODWORD(v54->super.isa) = v56 & 0xDFFFFFFF;
  WORD2(v54->super.isa) = v57;
  os_unfair_lock_unlock(v55);
  Property = TFSInfo::FetchVersionMetaData((uint64_t)v107, 0x8000000);
  v58 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)Property);
  os_unfair_lock_lock(v58);
  v60 = (FINode *)*((_QWORD *)this + 2);
  v59 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v114.fFINode = v60;
  v115 = v59;
  if (v59)
  {
    v61 = (unint64_t *)&v59->__shared_owners_;
    do
      v62 = __ldxr(v61);
    while (__stxr(v62 + 1, v61));
  }
  os_unfair_lock_unlock(v58);
  TFSInfo::SynchronizeVersionsForce((uint64_t)v60, (uint64_t *)&v107, &v116);
  if (v59)
  {
    v63 = (unint64_t *)&v59->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  if (a4)
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v116, (unsigned int *)&v119, &v119);
  v17 = v108;
  if (v108)
  {
    v65 = (unint64_t *)&v108->__shared_owners_;
    do
      v19 = __ldaxr(v65);
    while (__stlxr(v19 - 1, v65));
LABEL_120:
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
LABEL_175:
  if (v118)
  {
    v107 = 0;
    v108 = 0;
    v109 = 0;
    TNodePtr::TNodePtr(&v114, this);
    TNodeEventPtrs::AddPropertyChanges((TNodeEventPtrs *)&v107, &v114, &v116);

    TNodeEventPtrs::SendNotifications((id **)&v107);
    v114.fFINode = (FINode *)&v107;
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v114);
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&v116, v117);
  return Property;
}

void sub_1CBC75660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, _QWORD *a20)
{

  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&a19, a20);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::RefreshUTTypeProperty(TFSInfo *this, __CFString *a2)
{
  __CFString *v3;
  const __CFString *v4;
  uint64_t v5;
  int v6;
  __CFString *v7;
  void *v8;
  UTType *v9;
  void *v10;
  const void *v12;
  TString v13;

  if (!*((_QWORD *)this + 1))
    return 0;
  v3 = a2;
  v4 = (const __CFString *)*MEMORY[0x1E0C998E0];
  if (-[__CFString isEqualToString:](v3, "isEqualToString:", *MEMORY[0x1E0C998E0]))
  {

LABEL_6:
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v7 = (__CFString *)*((_QWORD *)this + 2);
    v13.fString.fRef = v7;
    if (v7)
      CFRetain(v7);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    TCFURLInfo::ObjectProperty((TCFURLInfo *)v7, v4, (const __CFString *)1);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    static_objc_cast<NSString,objc_object * {__strong}>(v8);
    v9 = (UTType *)objc_claimAutoreleasedReturnValue();

    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v13.fString.fRef);
    v5 = TFSInfo::SetUTType(this, v9, 0);

    return v5;
  }
  v6 = -[__CFString isEqualToString:](v3, "isEqualToString:", *MEMORY[0x1E0C9B5E0]);

  if (v6)
    goto LABEL_6;
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v10 = (void *)*((_QWORD *)this + 2);
  v12 = v10;
  if (v10)
    CFRetain(v10);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  TCFURLInfo::StringProperty((TCFURLInfo *)v10, v3, &v13);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v12);
  v5 = TFSInfo::SetLocalizedTypeDescription(this, &v13, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  return v5;
}

void sub_1CBC758C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

id TCFURLInfo::ObjectProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  id v3;
  id propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  if (this)
  {
    if ((_DWORD)a3)
      CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0);
    else
      _CFURLCopyResourcePropertyForKeyFromCache();
  }
  v3 = propertyValueTypeRefPtr;

  return v3;
}

void sub_1CBC7598C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void ___ZZN21TClientChangeNotifier6WakeUpEvENK3__1clEv_block_invoke(uint64_t a1)
{
  TClientChangeNotifier::HandleEvents(*(TClientChangeNotifier **)(a1 + 32));
}

void TClientChangeNotifier::HandleEvents(TClientChangeNotifier *this)
{
  unint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  std::__shared_weak_count *v9;

  v2 = *((_QWORD *)this + 5);
  TBlockingEventQueue::EventQueueFromID(v2, &v8);
  v4 = v8;
  v3 = v9;
  if (!v9)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if (!v4)
      return;
  }
  else
  {
LABEL_5:
    if (!v4)
      return;
  }
  v8 = v2;
  v7 = *((_QWORD *)this + 10);
  if (!v7)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)v7 + 48))(v7, &v8);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
}

void TNodeEvent::HandleInternalEvent(unint64_t a1)
{
  char *i;
  int NextEvent;
  char *v4;
  char *v5;
  char *v6;
  TDSNotifier *v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  os_unfair_lock_s *v17;
  char *v18;
  TFSInfo *v19;
  unint64_t *v20;
  unint64_t v21;
  _BOOL4 IsAlias;
  _BOOL4 v23;
  unint64_t *v24;
  unint64_t v25;
  TNode *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  os_unfair_lock_s *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  os_unfair_lock_s *v35;
  int v36;
  unint64_t *v37;
  unint64_t v38;
  FINode *fFINode;
  uint64_t v40;
  os_unfair_lock_s *v41;
  char *v42;
  TFSInfo *v43;
  unint64_t *v44;
  unint64_t v45;
  _BOOL4 v46;
  _BOOL4 v47;
  unint64_t *v48;
  unint64_t v49;
  TNode *v50;
  TNode *v51;
  _BOOL4 v52;
  TNode *v53;
  TNode *v54;
  int v55;
  const TNode *v56;
  const TNode *v57;
  TPropertyValue v58;
  TDSNotifier *v59;
  TNodePtr v60;
  char *v61;

  for (i = 0; ; i)
  {
    v61 = i;
    NextEvent = NodeEventGetNextEvent(&v61, a1);
    v4 = v61;

    if (!NextEvent)
      break;
    v5 = v4;
    i = v5;
    if (v5)
      v6 = v5 + 8;
    else
      v6 = 0;
    v7 = (TDSNotifier *)*((_QWORD *)v6 + 8);
    v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v7;
    if (v7
      && (TDSNotifier::AddPtrReference(v7), v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value))
    {
      v59 = (TDSNotifier *)*((_QWORD *)v6 + 8);
      TDSNotifier::AddPtrReference(v59);
      v60.fFINode = (FINode *)*((id *)v59 + 3);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v59);
    }
    else
    {
      TNodePtr::TNodePtr(&v60, 0);
    }
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v58);
    if (!TNodeFromFINode(v60.fFINode))
      goto LABEL_54;
    v8 = TNodeFromFINode(v60.fFINode);
    v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    v11 = *(_QWORD *)(v8 + 16);
    v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      os_unfair_lock_unlock(v9);
      v14 = *(unsigned __int8 *)(v11 + 112);
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      if (!v14)
      {
LABEL_21:
        v16 = TNodeFromFINode(v60.fFINode);
        v17 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v16);
        os_unfair_lock_lock(v17);
        v19 = *(TFSInfo **)(v16 + 16);
        v18 = *(char **)(v16 + 24);
        v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v19;
        v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v18;
        if (v18)
        {
          v20 = (unint64_t *)(v18 + 8);
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        os_unfair_lock_unlock(v17);
        IsAlias = TFSInfo::IsAlias(v19);
        v23 = IsAlias;
        if (!v18)
          goto LABEL_28;
        v24 = (unint64_t *)(v18 + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          (*(void (**)(char *))(*(_QWORD *)v18 + 16))(v18);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v18);
          if (!v23)
            goto LABEL_54;
        }
        else
        {
LABEL_28:
          if (!IsAlias)
            goto LABEL_54;
        }
      }
    }
    else
    {
      os_unfair_lock_unlock(v9);
      if (!*(_BYTE *)(v11 + 112))
        goto LABEL_21;
    }
    v26 = (TNode *)TNodeFromFINode(v60.fFINode);
    TNode::GetAliasTarget(v26, &v58);
    v27 = TNodeFromFINode((FINode *)v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);

    if (!v27)
      goto LABEL_54;
    v28 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == 1 || v28 == 4)
    {
      v54 = (TNode *)TNodeFromFINode(v60.fFINode);
      TNode::ClearAliasTarget(v54, 0);
    }
    else if (v28 == 5)
    {
      v29 = TNodeFromFINode(v60.fFINode);
      v30 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v29);
      os_unfair_lock_lock(v30);
      v32 = *(_QWORD *)(v29 + 16);
      v31 = *(std::__shared_weak_count **)(v29 + 24);
      if (v31)
      {
        v33 = (unint64_t *)&v31->__shared_owners_;
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }
      os_unfair_lock_unlock(v30);
      v35 = (os_unfair_lock_s *)(v32 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v32 + 100));
      v36 = *(_DWORD *)(v32 + 115);
      os_unfair_lock_unlock(v35);
      if (v31)
      {
        v37 = (unint64_t *)&v31->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      fFINode = v60.fFINode;
      if ((v36 & 0x40) != 0)
        goto LABEL_52;
      v40 = TNodeFromFINode(v60.fFINode);
      v41 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v40);
      os_unfair_lock_lock(v41);
      v43 = *(TFSInfo **)(v40 + 16);
      v42 = *(char **)(v40 + 24);
      v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v43;
      v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v42;
      if (v42)
      {
        v44 = (unint64_t *)(v42 + 8);
        do
          v45 = __ldxr(v44);
        while (__stxr(v45 + 1, v44));
      }
      os_unfair_lock_unlock(v41);
      v46 = TFSInfo::IsAlias(v43);
      v47 = v46;
      if (!v42)
        goto LABEL_49;
      v48 = (unint64_t *)(v42 + 8);
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (v49)
      {
LABEL_49:
        if (!v46)
          goto LABEL_54;
LABEL_50:
        v50 = (TNode *)TNodeFromFINode(v60.fFINode);
        TNode::GetAliasTarget(v50, &v58);
        v51 = (TNode *)TNodeFromFINode((FINode *)v58.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);
        v52 = TNode::IsInTrash(v51);

        if (!v52)
          goto LABEL_54;
        fFINode = v60.fFINode;
LABEL_52:
        v53 = (TNode *)TNodeFromFINode(fFINode);
        TNode::ClearAliasTarget(v53, 1);
        goto LABEL_54;
      }
      (*(void (**)(char *))(*(_QWORD *)v42 + 16))(v42);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v42);
      if (v47)
        goto LABEL_50;
    }
    else
    {
      v55 = *((_DWORD *)v6 + 4);
      LODWORD(v59) = v55;
      if (v55)
      {
        if (v55 == 1936225392)
        {
          v56 = (const TNode *)TNodeFromFINode(v60.fFINode);
          TNode::SendNotification(v56, 2, (id *)&v60.fFINode, 1768124270, 0);
        }
        else
        {
          v57 = (const TNode *)TNodeFromFINode(v60.fFINode);
          v58.fData.__impl_.__index = 0;
          std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Property const&,0,Property,20ul,0>(&v58, &v59);
          TNode::RequestInternalTask(v57, 1011, &v58, 0);
          TPropertyValue::~TPropertyValue(&v58);
        }
      }
    }
LABEL_54:

  }
}

void sub_1CBC75E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);

  _Unwind_Resume(a1);
}

BOOL TChildrenList::RemoveChild(TChildrenList *this, const TNodePtr *a2)
{
  FINode *v3;
  void **v4;
  FINode *v5;
  _BOOL8 v6;
  void **v8;
  void **v9;
  void **v10;
  _QWORD v11[3];
  void ***v12;
  char v13;

  memset(v11, 0, sizeof(v11));
  v3 = a2->fFINode;
  v9 = 0;
  v10 = 0;
  v8 = 0;
  v12 = &v8;
  v13 = 0;
  v4 = (void **)operator new(8uLL);
  v8 = v4;
  v9 = v4;
  v10 = v4 + 1;
  v5 = v3;
  *v4 = v5;
  v9 = v4 + 1;
  v6 = TChildrenList::RemoveChildren((uint64_t)this, (FINode ***)&v8, (uint64_t)v11);
  v12 = &v8;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v12);

  v8 = (void **)v11;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v8);
  return v6;
}

void sub_1CBC75FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void **a15)
{
  void *v15;

  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a15);

  a9 = (void **)&a12;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

BOOL TChildrenList::RemoveChildren(uint64_t a1, FINode ***a2, uint64_t a3)
{
  uint64_t v3;
  FINode **v6;
  FINode **v7;
  FINode **v9;
  FINode **v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL8 v14;
  uint64_t v16;
  uint64_t v17;
  os_unfair_lock_s *v18;
  FINode **i;
  uint64_t v20;
  uint64_t v21;
  os_unfair_lock_s *v22;
  unint64_t v23;
  int64_t v24;
  uint64_t v25;
  _QWORD v26[5];

  v3 = a1 + 64;
  if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
    return 0;
  v6 = *a2;
  v7 = a2[1];
  if (v6 == v7)
    return 0;
  std::unordered_set<TNodePtr>::unordered_set<std::__wrap_iter<TNodePtr const*>>((uint64_t)v26, v6, v7);
  std::vector<TNodePtr>::reserve(a3, v26[3]);
  v9 = *(FINode ***)(a1 + 64);
  v10 = *(FINode ***)(a1 + 72);
  v24 = (char *)v10 - (char *)v9;
  if (v10 == v9)
  {
LABEL_7:
    v12 = 0;
  }
  else
  {
    v11 = 1;
    while (!std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::find<TNodePtr>(v26, v9))
    {
      ++v9;
      ++v11;
      if (v9 == v10)
        goto LABEL_7;
    }
    v16 = TNodeFromFINode(*v9);
    v17 = *(_QWORD *)(a1 + 96);
    v18 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v16);
    v25 = a3;
    os_unfair_lock_lock(v18);
    if (*(_QWORD *)(v16 + 48) == v17)
      *(_QWORD *)(v16 + 48) = 0;
    os_unfair_lock_unlock(v18);
    v12 = v11 - 1 < *(_QWORD *)(a1 + 152);
    std::vector<TNodePtr>::push_back[abi:ne180100](a3, (id *)v9);
    if (v9 != v10)
    {
      for (i = v9 + 1; i != v10; ++i)
      {
        if (std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::find<TNodePtr>(v26, i))
        {
          v20 = TNodeFromFINode(*i);
          v21 = *(_QWORD *)(a1 + 96);
          v22 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v20);
          os_unfair_lock_lock(v22);
          if (*(_QWORD *)(v20 + 48) == v21)
            *(_QWORD *)(v20 + 48) = 0;
          os_unfair_lock_unlock(v22);
          v23 = *(_QWORD *)(a1 + 152);
          std::vector<TNodePtr>::push_back[abi:ne180100](v25, (id *)i);
          if (v11 < v23)
            ++v12;
        }
        else
        {
          TNodePtr::operator=((void **)v9++, (void **)i);
        }
        ++v11;
      }
      goto LABEL_9;
    }
  }
  v9 = v10;
LABEL_9:
  std::vector<TNodePtr>::erase(v3, (void **)v9, *(void ***)(a1 + 72));
  *(_QWORD *)(a1 + 152) -= v12;
  v13 = *(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64);
  v14 = v24 != v13;
  if (v24 != v13)
  {
    atomic_store(v13 >> 3, (unint64_t *)(a1 + 160));
    ++*(_DWORD *)(a1 + 184);
  }
  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table((uint64_t)v26);
  return v14;
}

void sub_1CBC76204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void **std::vector<TNodePtr>::erase(uint64_t a1, void **a2, void **a3)
{
  void **v5;
  void **v6;
  uint64_t v7;
  void **v8;
  void *v9;

  if (a2 != a3)
  {
    v5 = a3;
    v6 = *(void ***)(a1 + 8);
    if (a3 == v6)
    {
      v8 = a2;
    }
    else
    {
      v7 = a3 - a2;
      v8 = a2;
      do
      {
        TNodePtr::operator=(v8, &v8[v7]);
        ++v8;
      }
      while (&v8[v7] != v6);
      v5 = *(void ***)(a1 + 8);
    }
    while (v5 != v8)
    {
      v9 = *--v5;

    }
    *(_QWORD *)(a1 + 8) = v8;
  }
  return a2;
}

uint64_t std::unordered_set<TNodePtr>::unordered_set<std::__wrap_iter<TNodePtr const*>>(uint64_t a1, FINode **a2, FINode **a3)
{
  FINode **v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    v5 = a2;
    do
    {
      std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__emplace_unique_key_args<TNodePtr,TNodePtr const&>(a1, v5, (id *)v5);
      ++v5;
    }
    while (v5 != a3);
  }
  return a1;
}

void sub_1CBC76328(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void *std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__emplace_unique_key_args<TNodePtr,TNodePtr const&>(uint64_t a1, FINode **a2, id *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v9;
  unint64_t v10;
  void **v11;
  void *i;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v6 = (unint64_t)*a2 >> 2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v9.i16[0] = vaddlv_u8(v9);
    v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      v3 = (unint64_t)*a2 >> 2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v11 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = *(void **)i)
      {
        v13 = *((_QWORD *)i + 1);
        if (v13 == v6)
        {
          v14 = TNodeFromFINode(*((FINode **)i + 2));
          if (v14 == TNodeFromFINode(*a2))
            return i;
        }
        else
        {
          if (v10 > 1)
          {
            if (v13 >= v7)
              v13 %= v7;
          }
          else
          {
            v13 &= v7 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x18uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v6;
  *((_QWORD *)i + 2) = *a3;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v7 || (float)(v17 * (float)v7) < v16)
  {
    v18 = 1;
    if (v7 >= 3)
      v18 = (v7 & (v7 - 1)) != 0;
    v19 = v18 | (2 * v7);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v23)
  {
    *(_QWORD *)i = *v23;
LABEL_38:
    *v23 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v3) = v15;
  if (*(_QWORD *)i)
  {
    v24 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7)
        v24 %= v7;
    }
    else
    {
      v24 &= v7 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBC765C0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<TNodePtr,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t **std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::find<TNodePtr>(_QWORD *a1, FINode **a2)
{
  int8x8_t v2;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t ***v8;
  uint64_t **i;
  unint64_t v10;
  uint64_t v11;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v4 = (unint64_t)*a2 >> 2;
  v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    v7 = (unint64_t)*a2 >> 2;
    if (v4 >= *(_QWORD *)&v2)
      v7 = v4 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v4;
  }
  v8 = *(uint64_t ****)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  for (i = *v8; i; i = (uint64_t **)*i)
  {
    v10 = (unint64_t)i[1];
    if (v4 == v10)
    {
      v11 = TNodeFromFINode((FINode *)i[2]);
      if (v11 == TNodeFromFINode(*a2))
        return i;
    }
    else
    {
      if (v6 > 1)
      {
        if (v10 >= *(_QWORD *)&v2)
          v10 %= *(_QWORD *)&v2;
      }
      else
      {
        v10 &= *(_QWORD *)&v2 - 1;
      }
      if (v10 != v7)
        return 0;
    }
  }
  return i;
}

void TNodeIterator::GetVisibleChildrenAndSortProperties(const TNodePtr *a1@<X1>, int a2@<W2>, int a3@<W3>, uint64_t a4@<X8>)
{
  TNode *v9;
  uint64_t v10;
  TNode *v11;
  FINode **v12;
  FINode **v13;
  TNode *v14;
  int IsVisible;
  int v16;
  TNode *v17;
  std::__shared_weak_count *v18;
  int v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  uint64_t v22;
  os_unfair_lock_s *v23;
  std::__shared_weak_count *v24;
  TFSInfo *v25;
  unint64_t *v26;
  unint64_t v27;
  int Index;
  int v29;
  std::vector<int>::pointer end;
  int *v31;
  std::vector<int>::pointer begin;
  int64_t v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  char *v37;
  int *v38;
  int v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  os_unfair_lock_s *v43;
  std::__shared_weak_count *v44;
  TFSInfo *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  TString v51;
  _BYTE v52[24];
  std::vector<int> v53;
  void **v54[3];
  void **v55[3];
  FINode *v56;
  FINode *v57;
  TFSInfo *v58;
  std::__shared_weak_count *v59;

  v9 = (TNode *)TNodeFromFINode(a1->fFINode);
  TNode::GetSuperRootNode((uint64_t *)&v56, v9);
  v10 = TNodeFromFINode(v56);

  v11 = (TNode *)TNodeFromFINode(a1->fFINode);
  TNode::CopyChildren(v11, (uint64_t)&v56);
  memset(v55, 0, sizeof(v55));
  std::vector<TNodePtr>::reserve((uint64_t)v55, v57 - v56);
  memset(v54, 0, sizeof(v54));
  memset(&v53, 0, sizeof(v53));
  if (a2)
  {
    std::vector<TString>::reserve((uint64_t)v54, v57 - v56);
    std::vector<int>::reserve(&v53, v57 - v56);
  }
  v50 = a4;
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v52, a1, 0);
  v13 = (FINode **)v56;
  v12 = (FINode **)v57;
  if (v56 != v57)
  {
    while (a3)
    {
      v14 = (TNode *)TNodeFromFINode(*v13);
      IsVisible = TNode::IsVisible(v14);
      if (v9 == (TNode *)v10)
        v16 = IsVisible;
      else
        v16 = 0;
      if (v16 == 1)
      {
        v17 = (TNode *)TNodeFromFINode(*v13);
        TNode::GetVolumeInfo(v17, &v58);
        v18 = v59;
        v19 = *((unsigned __int8 *)v58 + 114);
        if (!v59)
          goto LABEL_13;
        p_shared_owners = (unint64_t *)&v59->__shared_owners_;
        do
          v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
          if (!v19)
            break;
        }
        else
        {
LABEL_13:
          if (!v19)
            break;
        }
      }
      else if ((IsVisible & 1) != 0)
      {
        break;
      }
LABEL_50:
      if (++v13 == v12)
        goto LABEL_54;
    }
    std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)v55, (id *)v13);
    if (a2)
    {
      v22 = TNodeFromFINode(*v13);
      v23 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v22);
      os_unfair_lock_lock(v23);
      v25 = *(TFSInfo **)(v22 + 16);
      v24 = *(std::__shared_weak_count **)(v22 + 24);
      v58 = v25;
      v59 = v24;
      if (v24)
      {
        v26 = (unint64_t *)&v24->__shared_owners_;
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
      }
      os_unfair_lock_unlock(v23);
      Index = TFSInfo::GetIndex(v25);
      v29 = Index;
      end = v53.__end_;
      if (v53.__end_ >= v53.__end_cap_.__value_)
      {
        begin = v53.__begin_;
        v33 = v53.__end_ - v53.__begin_;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 62)
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        v35 = (char *)v53.__end_cap_.__value_ - (char *)v53.__begin_;
        if (((char *)v53.__end_cap_.__value_ - (char *)v53.__begin_) >> 1 > v34)
          v34 = v35 >> 1;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL)
          v36 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (v36)
        {
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v53.__end_cap_, v36);
          begin = v53.__begin_;
          end = v53.__end_;
        }
        else
        {
          v37 = 0;
        }
        v38 = (int *)&v37[4 * v33];
        *v38 = v29;
        v31 = v38 + 1;
        while (end != begin)
        {
          v39 = *--end;
          *--v38 = v39;
        }
        v53.__begin_ = v38;
        v53.__end_ = v31;
        v53.__end_cap_.__value_ = (int *)&v37[4 * v36];
        if (begin)
          operator delete(begin);
      }
      else
      {
        *v53.__end_ = Index;
        v31 = end + 1;
      }
      v53.__end_ = v31;
      if (v24)
      {
        v40 = (unint64_t *)&v24->__shared_owners_;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      v42 = TNodeFromFINode(*v13);
      v43 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v42);
      os_unfair_lock_lock(v43);
      v45 = *(TFSInfo **)(v42 + 16);
      v44 = *(std::__shared_weak_count **)(v42 + 24);
      v58 = v45;
      v59 = v44;
      if (v44)
      {
        v46 = (unint64_t *)&v44->__shared_owners_;
        do
          v47 = __ldxr(v46);
        while (__stxr(v47 + 1, v46));
      }
      os_unfair_lock_unlock(v43);
      TFSInfo::Name(v45, &v51);
      if (v44)
      {
        v48 = (unint64_t *)&v44->__shared_owners_;
        do
          v49 = __ldaxr(v48);
        while (__stlxr(v49 - 1, v48));
        if (!v49)
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
      }
      std::vector<TString>::push_back[abi:ne180100]((uint64_t)v54, (CFTypeRef *)&v51.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v51.fString.fRef);
    }
    goto LABEL_50;
  }
LABEL_54:
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorI8TNodePtrNS_9allocatorIS4_EEEENS3_I7TStringNS5_IS8_EEEENS3_IiNS5_IiEEEEEEC2B8ne180100IJLm0ELm1ELm2EEJS7_SA_SC_EJEJEJRS7_RSA_RSC_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSJ_IJDpT2_EEEDpOT3_(v50, v55, (uint64_t *)v54, (uint64_t)&v53);
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v52);
  if (v53.__begin_)
  {
    v53.__end_ = v53.__begin_;
    operator delete(v53.__begin_);
  }
  v53.__begin_ = (std::vector<int>::pointer)v54;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)&v53);
  v54[0] = (void **)v55;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v54);
  v55[0] = (void **)&v56;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v55);
}

void sub_1CBC76ADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t ***__p, uint64_t ***a18, uint64_t a19, uint64_t **a20,uint64_t a21,uint64_t a22,uint64_t *a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)&a12);
  if (__p)
  {
    a18 = __p;
    operator delete(__p);
  }
  __p = &a20;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a20 = &a23;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  a23 = &a26;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  _Unwind_Resume(a1);
}

uint64_t TChildrenList::AddNewChildren(uint64_t a1, TNodePtr **a2, int a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  void **v11;
  void **i;
  void *v13;
  uint64_t v14;
  uint64_t j;
  void *v16;
  uint64_t v17;
  uint64_t k;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  TNodePtr *v22;
  TNodePtr *v23;
  FINode **v24;
  FINode **v25;
  uint64_t v26;
  os_unfair_lock_s *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  uint64_t v32;
  os_unfair_lock_s *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  int v37;
  _BOOL4 v38;
  const void *v39;
  os_unfair_lock_s *v40;
  os_unfair_lock_s *v41;
  const void *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  TNode *v51;
  os_unfair_lock_s *v52;
  void **v53;
  const void *v56;
  const void *v57;
  os_unfair_lock_s *v58;
  std::__shared_weak_count *v59;
  TNodePtr v60;
  std::__shared_weak_count *v61;

  v11 = *(void ***)a4;
  for (i = *(void ***)(a4 + 8); i != v11; --i)
  {
    v13 = *(i - 1);

  }
  *(_QWORD *)(a4 + 8) = v11;
  v14 = *a6;
  for (j = a6[1]; j != v14; j -= 8)
  {
    v16 = *(void **)(j - 8);

  }
  a6[1] = v14;
  v17 = *a5;
  for (k = a5[1]; k != v17; k -= 8)
  {
    v19 = *(void **)(k - 8);

  }
  a5[1] = v17;
  if (*a2 == a2[1])
    return 0;
  v20 = *(_QWORD *)(a1 + 96);
  TNode::GetSuperRootNode((uint64_t *)&v60, (TNode *)a1);
  v21 = TNodeFromFINode(v60.fFINode);

  if (v20 == v21)
    a3 = 0;
  std::vector<TNodePtr>::reserve(a1 + 64, a2[1] - *a2 + ((uint64_t)(*(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64)) >> 3));
  std::vector<TNodePtr>::reserve(a4, a2[1] - *a2);
  v23 = *a2;
  v22 = a2[1];
  while (v23 != v22)
  {
    v24 = TChildrenList::LowerBounds((TChildrenList *)a1, v23);
    if (*(FINode ***)(a1 + 72) != v24)
    {
      v25 = v24;
      v26 = TNodeFromFINode(v23->fFINode);
      v27 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v26);
      os_unfair_lock_lock(v27);
      v29 = *(_QWORD *)(v26 + 16);
      v28 = *(std::__shared_weak_count **)(v26 + 24);
      v60.fFINode = (FINode *)v29;
      v61 = v28;
      if (v28)
      {
        p_shared_owners = (unint64_t *)&v28->__shared_owners_;
        do
          v31 = __ldxr(p_shared_owners);
        while (__stxr(v31 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v27);
      v32 = TNodeFromFINode(*v25);
      v33 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v32);
      os_unfair_lock_lock(v33);
      v34 = *(std::__shared_weak_count **)(v32 + 24);
      v58 = *(os_unfair_lock_s **)(v32 + 16);
      v59 = v34;
      if (v34)
      {
        v35 = (unint64_t *)&v34->__shared_owners_;
        do
          v36 = __ldxr(v35);
        while (__stxr(v36 + 1, v35));
      }
      os_unfair_lock_unlock(v33);
      if (TFSInfo::Equal((TFSInfo *)v29, (TFSInfo **)&v58))
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v29 + 100));
        v37 = *(_DWORD *)(v29 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(v29 + 100));
        if ((v37 & 0x1000000) != 0)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v29 + 100));
          v39 = *(const void **)(v29 + 16);
          v57 = v39;
          if (v39)
            CFRetain(v39);
          os_unfair_lock_unlock((os_unfair_lock_t)(v29 + 100));
          v40 = v58;
          v41 = v58 + 25;
          os_unfair_lock_lock(v58 + 25);
          v42 = *(const void **)&v40[4]._os_unfair_lock_opaque;
          v56 = v42;
          if (v42)
            CFRetain(v42);
          os_unfair_lock_unlock(v41);
          v38 = v57 != v56;
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v56);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v57);
        }
        else
        {
          v38 = 0;
        }
      }
      else
      {
        v38 = 1;
      }
      v43 = v59;
      if (v59)
      {
        v44 = (unint64_t *)&v59->__shared_owners_;
        do
          v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }
      v46 = v61;
      if (!v61)
        goto LABEL_40;
      v47 = (unint64_t *)&v61->__shared_owners_;
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
        if (!v38)
        {
LABEL_44:
          std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)a6, (id *)v25);
          v49 = (uint64_t)a5;
          goto LABEL_45;
        }
      }
      else
      {
LABEL_40:
        if (!v38)
          goto LABEL_44;
      }
    }
    v49 = a4;
    if (a3)
    {
      v50 = TNodeFromFINode(v23->fFINode);
      TNodePtr::TNodePtr(&v60, *(const TNode **)(a1 + 96));
      v52 = (os_unfair_lock_s *)TNode::ParentLock(v51);
      os_unfair_lock_lock(v52);
      *(_QWORD *)(v50 + 48) = TNodeFromFINode(v60.fFINode);
      os_unfair_lock_unlock(v52);

      v49 = a4;
    }
LABEL_45:
    std::vector<TNodePtr>::push_back[abi:ne180100](v49, (id *)&v23->fFINode);
    ++v23;
  }
  v53 = *(void ***)(a4 + 8);
  if (*(void ***)a4 != v53)
  {
    std::vector<TNodePtr>::__insert_with_size[abi:ne180100]<std::__wrap_iter<TNodePtr*>,std::__wrap_iter<TNodePtr*>>(a1 + 64, *(id **)(a1 + 72), *(void ***)a4, v53, ((uint64_t)v53 - *(_QWORD *)a4) >> 3);
    atomic_store((uint64_t)(*(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64)) >> 3, (unint64_t *)(a1 + 160));
    ++*(_DWORD *)(a1 + 184);
    return 1;
  }
  return 0;
}

void sub_1CBC76F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{

  _Unwind_Resume(a1);
}

uint64_t std::vector<TNodePtr>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = *(_QWORD *)(a1 + 16);
  result = a1 + 16;
  if (a2 > (v4 - *(_QWORD *)a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 8 * v6;
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, v7);
    return std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1CBC7701C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

id *std::vector<TNodePtr>::__swap_out_circular_buffer(id **a1, _QWORD *a2)
{
  id *v4;
  id *v5;
  id *result;
  id *v7;
  id *v8;
  id *v9;

  v5 = *a1;
  v4 = a1[1];
  result = (id *)a2[1];
  while (v4 != v5)
    result = (id *)TNodePtr::TNodePtr(result - 1, --v4);
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = (id *)a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = (id *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<TNodePtr>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

FINode **TChildrenList::LowerBounds(TChildrenList *this, const TNodePtr *a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  FINode **v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  TFSInfo *v13;
  std::__shared_weak_count *v14;

  v3 = TNodeFromFINode(a2->fFINode);
  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  v5 = *(std::__shared_weak_count **)(v3 + 24);
  v13 = *(TFSInfo **)(v3 + 16);
  v14 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v8 = TChildrenList::LowerBounds((uint64_t)this, &v13);
  v9 = v14;
  if (v14)
  {
    v10 = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v8;
}

void sub_1CBC771BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const void **TSystemNotificationTask::HandleFSEvent(const void **this, const char **a2, int *a3, const unsigned int *a4)
{
  const void **v6;
  const __CFAllocator *v7;
  int v8;
  int v9;
  BOOL v10;
  BOOL v11;
  __CFString *fRef;
  CFMutableStringRef MutableCopy;
  CFTypeRef cf;
  TString v15;

  if (this)
  {
    v6 = this;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      v9 = *a3++;
      v8 = v9;
      if (v9 != 64)
      {
        TString::TString(&v15, *a2);
        TString::TString((TString *)&cf, "/private/var/tmp/com.apple.chrono/");
        v10 = TString::BeginsWith(&v15, (const TString *)&cf);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        if (!v10)
        {
          TString::TString((TString *)&cf, "/");
          v11 = TString::EndsWith(&v15, (const TString *)&cf);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (!v11)
          {
            fRef = v15.fString.fRef;
            cf = &stru_1E8752DF8;
            CFRetain(&stru_1E8752DF8);
            MutableCopy = CFStringCreateMutableCopy(v7, 0, fRef);
            if (cf)
              CFRelease(cf);
            cf = MutableCopy;
            TString::Append((TString *)&cf, (const __CFString *)"/");
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v15.fString.fRef, &cf);
            CFRetain(&stru_1E8752DF8);
            if (cf)
              CFRelease(cf);
            cf = &stru_1E8752DF8;
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          }
          TNode::HandleChange(&v15, (4 * v8) & 0x200 | (((v8 & 0xF) != 0) << 24));
        }
        this = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
      }
      ++a2;
      v6 = (const void **)((char *)v6 - 1);
    }
    while (v6);
  }
  return this;
}

void sub_1CBC77358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TNode::HandleChange(const TString *a1, int a2)
{
  TGlobalNodes *v4;
  _QWORD *v5;
  TNode *v6;
  uint64_t v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  os_unfair_lock_s *v14;
  int v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  os_unfair_lock_s *v19;
  TGlobalNodes *v20;
  uint64_t v21;
  TNode *v22;
  uint64_t v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  os_unfair_lock_s *v30;
  int v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  FINode *v35;
  uint64_t v36;
  os_unfair_lock_s *v37;
  std::__shared_weak_count *v38;
  FINode *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  TNode *v44;
  uint64_t v45;
  os_unfair_lock_s *v46;
  std::__shared_weak_count *v47;
  FINode *v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  TNode *v55;
  uint64_t v56;
  os_unfair_lock_s *v57;
  std::__shared_weak_count *v58;
  uint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  os_unfair_lock_s *v62;
  int v63;
  unint64_t *v64;
  unint64_t v65;
  TNode *v66;
  uint64_t v67;
  os_unfair_lock_s *v68;
  TGlobalNodes *v69;
  uint64_t i;
  uint64_t v71;
  FINode *v72;
  TNode *v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  CFTypeRef cf1;
  CFTypeRef cf2;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  FINode *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  TNodePtr v90;
  std::__shared_weak_count *v91;
  TString v92;

  if (!PathEligibleForSynching(a1))
    return;
  v88 = 0;
  v89 = 0;
  v4 = TPathName::TPathName((TPathName *)&v83, a1, TPathName::kPOSIXPathNameSeparator);
  TGlobalNodes::BootNode((uint64_t *)&v82, v4);
  v79 = 0;
  v80 = 0;
  v81 = 0;
  if (v85 != v84)
  {
    v5 = (_QWORD *)(v84 + 8 * (v86 >> 9));
    v6 = (TNode *)(*v5 + 8 * (v86 & 0x1FF));
    v7 = *(_QWORD *)(v84 + (((v87 + v86) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v87 + v86) & 0x1FF);
    while (1)
    {
      if (v6 == (TNode *)v7 || !TNodeFromFINode(v82))
        goto LABEL_55;
      v8 = TNodeFromFINode(v82);
      v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
      os_unfair_lock_lock(v9);
      v11 = *(_QWORD *)(v8 + 16);
      v10 = *(std::__shared_weak_count **)(v8 + 24);
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v9);
      v14 = (os_unfair_lock_s *)(v11 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
      v15 = *(_DWORD *)(v11 + 115);
      os_unfair_lock_unlock(v14);
      if (v10)
      {
        v16 = (unint64_t *)&v10->__shared_owners_;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      if ((v15 & 0x20) == 0)
        break;
      std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v79, (id *)&v82);
      v18 = TNodeFromFINode(v82);
      v19 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v18);
      os_unfair_lock_lock(v19);
      TNodePtr::TNodePtr(&v90, *(const TNode **)(v18 + 48));
      os_unfair_lock_unlock(v19);
      v20 = (TGlobalNodes *)TNodeFromFINode(v90.fFINode);
      TGlobalNodes::BootNode((uint64_t *)&v92, v20);
      v21 = TNodeFromFINode((FINode *)v92.fString.fRef);

      if (v20 != (TGlobalNodes *)v21)
        break;
      v36 = TNodeFromFINode(v82);
      v37 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v36);
      os_unfair_lock_lock(v37);
      v39 = *(FINode **)(v36 + 16);
      v38 = *(std::__shared_weak_count **)(v36 + 24);
      v90.fFINode = v39;
      v91 = v38;
      if (v38)
      {
        v40 = (unint64_t *)&v38->__shared_owners_;
        do
          v41 = __ldxr(v40);
        while (__stxr(v41 + 1, v40));
      }
      os_unfair_lock_unlock(v37);
      TFSInfo::Name((TFSInfo *)v39, &v92);
      if (v38)
      {
        v42 = (unint64_t *)&v38->__shared_owners_;
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
      TPathName::UsersDirectory((TString *)&cf2);
      if (CFEqual(v92.fString.fRef, cf2))
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v92.fString.fRef);
      }
      else
      {
        v45 = TNodeFromFINode(v82);
        v46 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v45);
        os_unfair_lock_lock(v46);
        v48 = *(FINode **)(v45 + 16);
        v47 = *(std::__shared_weak_count **)(v45 + 24);
        v90.fFINode = v48;
        v91 = v47;
        if (v47)
        {
          v49 = (unint64_t *)&v47->__shared_owners_;
          do
            v50 = __ldxr(v49);
          while (__stxr(v50 + 1, v49));
        }
        os_unfair_lock_unlock(v46);
        TFSInfo::Name((TFSInfo *)v48, (TString *)&cf1);
        if (v47)
        {
          v51 = (unint64_t *)&v47->__shared_owners_;
          do
            v52 = __ldaxr(v51);
          while (__stlxr(v52 - 1, v51));
          if (!v52)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }
        TPathName::VolumesDirectory((TString *)&v90);
        v53 = CFEqual(cf1, v90.fFINode);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v90.fFINode);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v92.fString.fRef);
        if (!v53)
          break;
      }
      if ((a2 & 0x200) != 0)
      {
        v54 = TNodeFromFINode(v82);
        TNode::HandleSync(v54, 0x1000000u);
      }
      v55 = (TNode *)TNodeFromFINode(v82);
      TNode::FindChild(v55, v6, 0, 0, (void **)&v90.fFINode);
LABEL_17:
      TNodePtr::operator=((void **)&v82, (void **)&v90.fFINode);

      v23 = TNodeFromFINode(v82);
      if (v23 != TNodeFromFINode(0))
      {
        v24 = TNodeFromFINode(v82);
        v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
        os_unfair_lock_lock(v25);
        v27 = *(_QWORD *)(v24 + 16);
        v26 = *(std::__shared_weak_count **)(v24 + 24);
        if (v26)
        {
          v28 = (unint64_t *)&v26->__shared_owners_;
          do
            v29 = __ldxr(v28);
          while (__stxr(v29 + 1, v28));
        }
        os_unfair_lock_unlock(v25);
        v30 = (os_unfair_lock_s *)(v27 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v27 + 100));
        v31 = *(_DWORD *)(v27 + 115);
        os_unfair_lock_unlock(v30);
        if (v26)
        {
          v32 = (unint64_t *)&v26->__shared_owners_;
          do
            v33 = __ldaxr(v32);
          while (__stlxr(v33 - 1, v32));
          if (!v33)
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
          }
        }
        if ((v31 & 0x40) != 0)
        {
          v90.fFINode = 0;
          v34 = TNodeFromFINode(v82);
          v92.fString.fRef = 0;
          if (TNode::FollowAlias(v34, &v90, &v92, 8))
            v35 = 0;
          else
            v35 = v90.fFINode;
          v92.fString.fRef = (__CFString *)v35;
          TNodePtr::operator=((void **)&v82, (void **)&v92.fString.fRef);

        }
      }
      v6 = (TNode *)((char *)v6 + 8);
      if ((TNode *)((char *)v6 - *v5) == (TNode *)4096)
      {
        v44 = (TNode *)v5[1];
        ++v5;
        v6 = v44;
      }
    }
    v22 = (TNode *)TNodeFromFINode(v82);
    TNode::FindChildButDontSynchronize(v22, v6, (void **)&v90.fFINode);
    goto LABEL_17;
  }
LABEL_55:
  if (TNodeFromFINode(v82))
  {
    v56 = TNodeFromFINode(v82);
    v57 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v56);
    os_unfair_lock_lock(v57);
    v59 = *(_QWORD *)(v56 + 16);
    v58 = *(std::__shared_weak_count **)(v56 + 24);
    if (v58)
    {
      v60 = (unint64_t *)&v58->__shared_owners_;
      do
        v61 = __ldxr(v60);
      while (__stxr(v61 + 1, v60));
    }
    os_unfair_lock_unlock(v57);
    v62 = (os_unfair_lock_s *)(v59 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v59 + 100));
    v63 = *(_DWORD *)(v59 + 115);
    os_unfair_lock_unlock(v62);
    if (!v58)
      goto LABEL_63;
    v64 = (unint64_t *)&v58->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
      if ((v63 & 0x20) == 0)
      {
LABEL_65:
        if ((a2 & 0x200) != 0)
        {
          v67 = TNodeFromFINode(v82);
          v68 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v67);
          os_unfair_lock_lock(v68);
          TNodePtr::TNodePtr(&v90, *(const TNode **)(v67 + 48));
          os_unfair_lock_unlock(v68);
          if (TNodeFromFINode(v90.fFINode))
          {
            v69 = (TGlobalNodes *)TNodeFromFINode(v90.fFINode);
            TNode::RequestSynchronize(v69, 0x1000000);
          }

        }
        else
        {
          v66 = (TNode *)TNodeFromFINode(v82);
          TNode::HandleListeners(v66, a2);
        }
        goto LABEL_70;
      }
    }
    else
    {
LABEL_63:
      if ((v63 & 0x20) == 0)
        goto LABEL_65;
    }
    std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v79, (id *)&v82);
    goto LABEL_65;
  }
LABEL_70:
  v71 = v79;
  for (i = v80; i != v71; i -= 8)
  {
    v72 = *(FINode **)(i - 8);
    v73 = (TNode *)TNodeFromFINode(v72);
    TNode::HandleRecursiveListeners(v73);
  }
  v90.fFINode = (FINode *)&v79;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v90);

  std::deque<TString>::~deque[abi:ne180100](&v83);
  v74 = v89;
  if (v89)
  {
    v75 = (unint64_t *)&v89->__shared_owners_;
    do
      v76 = __ldaxr(v75);
    while (__stlxr(v76 - 1, v75));
    if (!v76)
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
  }
}

void sub_1CBC779D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  os_unfair_lock_s *v28;
  uint64_t v29;

  os_unfair_lock_unlock(v28);
  *(_QWORD *)(v29 - 72) = &a16;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)(v29 - 72));

  std::deque<TString>::~deque[abi:ne180100](&a22);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a28);
  _Unwind_Resume(a1);
}

FINode *TGlobalNodes::BootNode@<X0>(FINode **__return_ptr a1@<X8>, TNode *this@<X0>)
{
  const TNodePtr *v3;
  TChildrenList **v4;
  FINode *result;
  void *v6;
  BOOL v7;
  _BYTE v8[24];
  TNodePtr v9;
  _QWORD block[6];
  char v11;

  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = (const TNodePtr *)TGlobalNodes::gGlobalNodes;
  v11 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12TGlobalNodes8BootNodeEv_block_invoke;
  block[3] = &__block_descriptor_48_ea8_32c37_ZTSKZN12TGlobalNodes8BootNodeEvE3__0_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  block[5] = &v11;
  if (TGlobalNodes::BootNode(void)::onceToken != -1)
    dispatch_once(&TGlobalNodes::BootNode(void)::onceToken, block);
  if (v11)
  {
    TNode::GetSuperRootNode((uint64_t *)&v9, this);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)v8, &v9, 0);
    v7 = 0;
    v4 = (TChildrenList **)TNodeFromFINode(v9.fFINode);
    TNode::AddNewChild((FINode **)&v6, v4, v3 + 1, &v7, 1);
    TNodePtr::operator=((void **)&v3[1].fFINode, &v6);

    TNode::StPopulating::~StPopulating((TNode::StPopulating *)v8);
  }
  result = v3[1].fFINode;
  *a1 = result;
  return result;
}

void sub_1CBC77C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{

  _Unwind_Resume(a1);
}

void TNode::FindChildButDontSynchronize(TNode *this@<X0>, TNode *a2@<X1>, void **a3@<X8>)
{
  TNode *v6;
  TNode *v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  os_unfair_lock_s *v13;
  int v14;
  unint64_t *v15;
  unint64_t v16;
  TChildrenList *v17;
  TNodePtr v18;
  FINode *v19[3];

  *a3 = 0;
  TGlobalNodes::RootNode((uint64_t *)v19, (TGlobalNodes *)this);
  v6 = (TNode *)TNodeFromFINode(v19[0]);

  if (v6 == this)
  {
    TNode::GetVolume(a2, (TNodePtr *)v19);
    TNodePtr::operator=(a3, (void **)v19);

  }
  else
  {
    v8 = (os_unfair_lock_s *)TNode::InfoLock(v7);
    os_unfair_lock_lock(v8);
    v10 = *((_QWORD *)this + 2);
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v8);
    v13 = (os_unfair_lock_s *)(v10 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
    v14 = *(_DWORD *)(v10 + 115);
    os_unfair_lock_unlock(v13);
    if (!v9)
      goto LABEL_9;
    v15 = (unint64_t *)&v9->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
      if ((v14 & 0x20) == 0)
        return;
    }
    else
    {
LABEL_9:
      if ((v14 & 0x20) == 0)
        return;
    }
    if (CFStringGetLength(*(CFStringRef *)a2) >= 1)
    {
      TNodePtr::TNodePtr(&v18, this);
      TNode::StPopulating::StPopulating((TNode::StPopulating *)v19, &v18, 0);

      v17 = (TChildrenList *)*((_QWORD *)this + 7);
      if (v17)
      {
        TChildrenList::Find(v17, (const TString *)a2, &v18);
        TNodePtr::operator=(a3, (void **)&v18.fFINode);

      }
      TNode::StPopulating::~StPopulating(v19);
    }
  }
}

void sub_1CBC77DBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  id *v2;
  va_list va;

  va_start(va, a2);
  TNode::StPopulating::~StPopulating((FINode **)va);

  _Unwind_Resume(a1);
}

void TNode::HandleRecursiveListeners(TNode *this)
{
  os_unfair_lock_s *v2;
  TNode *v3;
  signed int v4;
  BOOL v5;
  int v6;
  char v7;
  int v8;
  unsigned int v9;
  TNode *v10;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  os_unfair_lock_s *v16;
  unsigned int v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  char *buffer;
  unint64_t *v22;
  unint64_t v23;
  TDSNotifier *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  TPropertyValue v29;
  TNodePtr v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  TNodeRequest *v33;
  TNodePtr v34;

  v2 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v2);
  TNodePtr::TNodePtr(&v34, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v2);
  if (TNodeFromFINode(v34.fFINode))
  {
    v3 = (TNode *)TNodeFromFINode(v34.fFINode);
    v4 = atomic_load((unsigned int *)(TNode::GetNotifierList(v3) + 4));
    v5 = v4 > 0;
  }
  else
  {
    v5 = 0;
  }
  v6 = atomic_load((unsigned int *)(TNode::GetNotifierList(this) + 4));
  v7 = v6 > 0 || v5;
  if ((v7 & 1) != 0)
  {
    LOBYTE(v8) = 1;
  }
  else
  {
    v9 = atomic_load((unsigned __int16 *)this + 40);
    v8 = (v9 >> 7) & 1;
  }
  TNode::SetSizesAreValid(this, 0);
  v11 = (os_unfair_lock_s *)TNode::InfoLock(v10);
  os_unfair_lock_lock(v11);
  v13 = *((_QWORD *)this + 2);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v11);
  v16 = (os_unfair_lock_s *)(v13 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
  v17 = *(_DWORD *)(v13 + 115);
  os_unfair_lock_unlock(v16);
  v18 = v8 & (v17 >> 27);
  if (!v12)
    goto LABEL_17;
  v19 = (unint64_t *)&v12->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if (!v18)
      goto LABEL_31;
  }
  else
  {
LABEL_17:
    if (!v18)
      goto LABEL_31;
  }
  v29.fData.__impl_.__data = 0uLL;
  TNodeRequest::Make((uint64_t)&v29, (uint64_t *)&v33);
  buffer = v29.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
  if (v29.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
  {
    v22 = (unint64_t *)(v29.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                             + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      (*(void (**)(char *))(*(_QWORD *)buffer + 16))(buffer);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buffer);
    }
  }
  v24 = (TDSNotifier *)*((_QWORD *)v33 + 3);
  v29.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v24;
  if (v24)
    TDSNotifier::AddPtrReference(v24);
  std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void>(&v31);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v29);
  TNodeRequest::SetTask((uint64_t)v33, &v31);
  v25 = v31;
  TNodePtr::TNodePtr(&v30, this);
  memset(&v29, 0, sizeof(v29));
  TNodeTask::SetRequest(v25, (id *)&v30.fFINode, 102, 1819240307, &v29, 0);
  TPropertyValue::~TPropertyValue(&v29);

  TNode::PostFolderSizingTaskRequest((uint64_t)this, (uint64_t)&v31, 0);
  v26 = v32;
  if (v32)
  {
    v27 = (unint64_t *)&v32->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v33);
LABEL_31:

}

void sub_1CBC78074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, TNodeRequest *a15, id a16)
{
  TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&a15);

  _Unwind_Resume(a1);
}

uint64_t TNode::GetNotifierList(TNode *this)
{
  os_unfair_lock_s *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v5 = *((_QWORD *)this + 9);
  v3 = (uint64_t *)((char *)this + 72);
  v4 = v5;
  if (!v5)
  {
    v4 = operator new();
    *(_QWORD *)(v4 + 64) = 0;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    v6 = operator new(0x28uLL);
    v6[2] = 0;
    *v6 = &unk_1E87506F8;
    v6[1] = 0;
    v6[4] = 0;
    v6[3] = 0;
    *(_QWORD *)(v4 + 24) = v6 + 3;
    *(_QWORD *)(v4 + 32) = v6;
    *(_QWORD *)(v4 + 48) = 0;
    *(_QWORD *)(v4 + 56) = 0;
    *(_QWORD *)(v4 + 40) = 0;
    *(_DWORD *)(v4 + 64) = 0;
    v7 = *v3;
    *v3 = v4;
    if (v7)
    {
      std::default_delete<TNotifierList>::operator()[abi:ne180100]((uint64_t)v3, v7);
      v4 = *v3;
    }
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

void sub_1CBC781C0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;

  MEMORY[0x1D17A53D0](v2, 0x1020C40F61775ADLL);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TNode::SetSizesAreValid(TNode *this, int a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  int v20;
  unint64_t v21;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    os_unfair_lock_unlock(v4);
    v9 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    v11 = *(_DWORD *)(v6 + 115);
    v10 = v6 + 115;
    v12 = v11 | ((unint64_t)*(unsigned __int16 *)(v10 + 4) << 32);
    v13 = 0x10000000;
    if (!a2)
      v13 = 0;
    v14 = v12 & 0xFFFFFFFFEFFFFFFFLL;
    *(_DWORD *)v10 = v14 | v13;
    *(_WORD *)(v10 + 4) = WORD2(v14);
    os_unfair_lock_unlock(v9);
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    v16 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    v18 = *(_DWORD *)(v6 + 115);
    v17 = v6 + 115;
    v19 = v18 | ((unint64_t)*(unsigned __int16 *)(v17 + 4) << 32);
    v20 = 0x10000000;
    if (!a2)
      v20 = 0;
    v21 = v19 & 0xFFFFFFFFEFFFFFFFLL;
    *(_DWORD *)v17 = v21 | v20;
    *(_WORD *)(v17 + 4) = WORD2(v21);
    os_unfair_lock_unlock(v16);
  }
}

uint64_t TNode::GetNodeFromPath(TString *a1, TNodePtr *a2, unsigned int a3)
{
  TNode *v5;
  TNode **v6;
  TNode *v7;
  TNode *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  TNode *v17;
  uint64_t v18;
  os_unfair_lock_s *v19;
  std::__shared_weak_count *v20;
  __CFString *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  os_unfair_lock_s *v29;
  std::__shared_weak_count *v30;
  __CFString *v31;
  unint64_t *v32;
  unint64_t v33;
  _BOOL4 IsAlias;
  _BOOL4 v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  TNode *v40;
  uint64_t v41;
  os_unfair_lock_s *v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  os_unfair_lock_s *v47;
  int v48;
  unint64_t *v49;
  unint64_t v50;
  TNode *v51;
  uint64_t v52;
  TNode *v53;
  uint64_t v54;
  os_unfair_lock_s *v55;
  std::__shared_weak_count *v56;
  __CFString *v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  TNode *v64;
  CFTypeRef cf1;
  FINode *v67;
  id obj;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  _QWORD v74[6];
  TString v75;
  std::__shared_weak_count *v76;

  TPathName::TPathName((TPathName *)v74, a1, TPathName::kPOSIXPathNameSeparator);
  v5 = (TNode *)std::deque<TString>::deque((uint64_t)&v69, v74);
  TGlobalNodes::BootNode((FINode **)&v75, v5);
  TNodePtr::operator=((void **)&a2->fFINode, (void **)&v75.fString.fRef);

  if (v71 == v70
    || (v6 = (TNode **)(v70 + 8 * (v72 >> 9)),
        v7 = *v6,
        v8 = (TNode *)((char *)*v6 + 8 * (v72 & 0x1FF)),
        v9 = *(_QWORD *)(v70 + (((v73 + v72) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v73 + v72) & 0x1FF),
        v8 == (TNode *)v9))
  {
    v10 = 0;
    goto LABEL_69;
  }
  v10 = 0;
  while (1)
  {
    v11 = v8 - v7;
    v12 = (v8 - v7) >> 3;
    if (v11 < -7)
      v13 = (uint64_t)v6[-((unint64_t)(510 - v12) >> 9)] + 8 * (~(510 - (unsigned __int16)v12) & 0x1FF);
    else
      v13 = *(uint64_t *)((char *)v6 + (((unint64_t)(v12 + 1) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((v12 + 1) & 0x1FF);
    v14 = v13 == v9;
    if ((a3 & 0x200) != 0)
    {
      v15 = TNodeFromFINode(a2->fFINode);
      v16 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v15);
      os_unfair_lock_lock(v16);
      TNodePtr::TNodePtr((TNodePtr *)&obj, *(const TNode **)(v15 + 48));
      os_unfair_lock_unlock(v16);
      v17 = (TNode *)TNodeFromFINode((FINode *)obj);
      TGlobalNodes::BootNode(&v67, v17);
      if (v17 == (TNode *)TNodeFromFINode(v67))
      {
        v18 = TNodeFromFINode(a2->fFINode);
        v19 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v18);
        os_unfair_lock_lock(v19);
        v21 = *(__CFString **)(v18 + 16);
        v20 = *(std::__shared_weak_count **)(v18 + 24);
        v75.fString.fRef = v21;
        v76 = v20;
        if (v20)
        {
          p_shared_owners = (unint64_t *)&v20->__shared_owners_;
          do
            v23 = __ldxr(p_shared_owners);
          while (__stxr(v23 + 1, p_shared_owners));
        }
        os_unfair_lock_unlock(v19);
        TFSInfo::Name((TFSInfo *)v21, (TString *)&cf1);
        if (v20)
        {
          v24 = (unint64_t *)&v20->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        TPathName::VolumesDirectory(&v75);
        v26 = CFEqual(cf1, v75.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v75.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);

        if (v26)
        {
          v27 = TNodeFromFINode(a2->fFINode);
          TNode::HandleSync(v27, 0x1000000u);
        }
      }
      else
      {

      }
    }
    v28 = TNodeFromFINode(a2->fFINode);
    v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
    os_unfair_lock_lock(v29);
    v31 = *(__CFString **)(v28 + 16);
    v30 = *(std::__shared_weak_count **)(v28 + 24);
    v75.fString.fRef = v31;
    v76 = v30;
    if (v30)
    {
      v32 = (unint64_t *)&v30->__shared_owners_;
      do
        v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
    }
    os_unfair_lock_unlock(v29);
    IsAlias = TFSInfo::IsAlias((TFSInfo *)v31);
    v35 = IsAlias;
    if (!v30)
      goto LABEL_27;
    v36 = (unint64_t *)&v30->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (v37)
    {
LABEL_27:
      if (!IsAlias)
        goto LABEL_29;
LABEL_28:
      v38 = TNodeFromFINode(a2->fFINode);
      v75.fString.fRef = 0;
      v10 = TNode::FollowAlias(v38, a2, (TNodeRequest **)&v75, 8);
      goto LABEL_29;
    }
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
    if (v35)
      goto LABEL_28;
LABEL_29:
    if ((_DWORD)v10)
      goto LABEL_60;
    if ((a3 & 0x40000) != 0)
    {
      v39 = TNodeFromFINode(a2->fFINode);
      TNode::HandleSync(v39, 0x11000000u);
    }
    v40 = (TNode *)TNodeFromFINode(a2->fFINode);
    TNode::FindChild(v40, v8, v14 & (a3 >> 13), 0, &obj);
    if (!TNodeFromFINode((FINode *)obj))
      goto LABEL_58;
    v41 = TNodeFromFINode((FINode *)obj);
    v42 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v41);
    os_unfair_lock_lock(v42);
    v44 = *(_QWORD *)(v41 + 16);
    v43 = *(std::__shared_weak_count **)(v41 + 24);
    if (v43)
    {
      v45 = (unint64_t *)&v43->__shared_owners_;
      do
        v46 = __ldxr(v45);
      while (__stxr(v46 + 1, v45));
    }
    os_unfair_lock_unlock(v42);
    v47 = (os_unfair_lock_s *)(v44 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v44 + 100));
    v48 = *(_DWORD *)(v44 + 115);
    os_unfair_lock_unlock(v47);
    if (v43)
    {
      v49 = (unint64_t *)&v43->__shared_owners_;
      do
        v50 = __ldaxr(v49);
      while (__stlxr(v50 - 1, v49));
      if (!v50)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
    if ((v48 & 0x8000) == 0)
    {
      if ((a3 & 0x80) == 0)
      {
        v51 = (TNode *)TNodeFromFINode((FINode *)obj);
        if (!TNode::ValidateURL(v51))
        {
          v52 = TNodeFromFINode((FINode *)obj);
          TNode::HandleSync(v52, 0x80000u);
          v53 = (TNode *)TNodeFromFINode((FINode *)obj);
          if (TNode::ValidateURL(v53))
            v10 = 0;
          else
            v10 = 4294959236;
          goto LABEL_59;
        }
      }
      goto LABEL_58;
    }
    v54 = TNodeFromFINode((FINode *)obj);
    v55 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v54);
    os_unfair_lock_lock(v55);
    v57 = *(__CFString **)(v54 + 16);
    v56 = *(std::__shared_weak_count **)(v54 + 24);
    v75.fString.fRef = v57;
    v76 = v56;
    if (v56)
    {
      v58 = (unint64_t *)&v56->__shared_owners_;
      do
        v59 = __ldxr(v58);
      while (__stxr(v59 + 1, v58));
    }
    os_unfair_lock_unlock(v55);
    v60 = TFSInfo::TriggerMount((TFSInfo *)v57);
    v10 = v60;
    if (v56)
    {
      v61 = (unint64_t *)&v56->__shared_owners_;
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
        if ((_DWORD)v10)
          goto LABEL_59;
LABEL_57:
        v63 = TNodeFromFINode((FINode *)obj);
        TNode::HandleSync(v63, 0x80000u);
LABEL_58:
        v10 = 0;
        goto LABEL_59;
      }
    }
    if (!(_DWORD)v60)
      goto LABEL_57;
LABEL_59:
    objc_storeStrong((id *)&a2->fFINode, obj);

LABEL_60:
    if (!TNodeFromFINode(a2->fFINode))
      break;
    v8 = (TNode *)((char *)v8 + 8);
    v7 = *v6;
    if (v8 - *v6 == 4096)
    {
      v64 = v6[1];
      ++v6;
      v7 = v64;
      v8 = v64;
    }
    if (v8 == (TNode *)v9)
      goto LABEL_69;
  }
  v10 = 4294959236;
LABEL_69:
  if (TNodeFromFINode(a2->fFINode))
    TNodeFromFINode(a2->fFINode);
  else
    v10 = 4294959236;
  std::deque<TString>::~deque[abi:ne180100](&v69);
  std::deque<TString>::~deque[abi:ne180100](v74);
  return v10;
}

void sub_1CBC78864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, ...)
{
  uint64_t v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v5 - 96);

  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va);
  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

BOOL TNode::ValidateURL(TNode *this)
{
  _BOOL8 v1;
  void *__p;
  _BYTE *v4;
  CFURLRef url;

  __p = 0;
  TNode::CopyURL(this, (const __CFURL **)&__p);
  url = (CFURLRef)__p;
  if (__p)
  {
    std::vector<unsigned char>::vector(&__p, 0x400uLL);
    v1 = CFURLGetFileSystemRepresentation(url, 1u, (UInt8 *)__p, v4 - (_BYTE *)__p) != 0;
    if (__p)
    {
      v4 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v1 = 1;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&url);
  return v1;
}

void sub_1CBC789B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, const void *a12)
{
  if (__p)
    operator delete(__p);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a12);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1CBC78A34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::CopyURL(TNode *this, const __CFURL **a2)
{
  TNode *v4;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  TNode *v9;
  unint64_t v10;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  TFSInfo *v13;
  unint64_t *v14;
  unint64_t v15;
  const __CFURL *URL;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  const __CFString *v21;

  *a2 = 0;
  v21 = &stru_1E8752DF8;
  v4 = (TNode *)CFRetain(&stru_1E8752DF8);
  v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    os_unfair_lock_unlock(v5);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    os_unfair_lock_unlock(v5);
  }
  v11 = (os_unfair_lock_s *)TNode::InfoLock(v9);
  os_unfair_lock_lock(v11);
  v13 = (TFSInfo *)*((_QWORD *)this + 2);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v12)
  {
    v14 = (unint64_t *)&v12->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  os_unfair_lock_unlock(v11);
  URL = (const __CFURL *)TFSInfo::MakeURL(v13);
  *a2 = URL;
  if (v12)
  {
    v17 = (unint64_t *)&v12->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    URL = *a2;
  }
  if (URL)
  {
    _CFURLCacheSetAutoFlushingEnabled();
    if (*a2)
      v19 = 0;
    else
      v19 = 4294959236;
  }
  else
  {
    v19 = 4294959236;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21);
  return v19;
}

void sub_1CBC78BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *TFSInfo::MakeURL(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  const void *v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  int v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  CFTypeRef cf;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = (const void *)*((_QWORD *)this + 2);
  cf = v3;
  if (v3)
  {
    CFRetain(v3);
    os_unfair_lock_unlock(v2);
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*((_BYTE *)this + 112) == 27)
    {
      v4 = (os_unfair_lock_s *)((char *)this + 96);
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      v5 = *((_QWORD *)this + 10);
      if (v5
        && (os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72)),
            v6 = *(unsigned __int8 *)(v5 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72)),
            v6 == 1))
      {
        v7 = *(id *)(v5 + 24);
      }
      else
      {
        v7 = 0;
      }
      os_unfair_lock_unlock(v4);
      if (v7)
      {
        if ((objc_msgSend(v7, "isUsingFPFS") & 1) != 0)
        {
          objc_msgSend(v7, "rootURL");
          v8 = (void *)objc_claimAutoreleasedReturnValue();
          static_objc_cast<NSString,objc_object * {__strong}>(v8);
          v9 = (void *)objc_claimAutoreleasedReturnValue();

          v10 = v9;
          v3 = static_cf_cast<__CFString const*,void const*>(v10);

        }
        else
        {
          v3 = cf;
        }
      }
      else
      {
        v3 = 0;
      }

    }
    else
    {
      v3 = 0;
    }
  }
  cf = 0;
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf);
  return v3;
}

void sub_1CBC78D10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::FindChild(TNode *this@<X0>, TNode *a2@<X1>, int a3@<W2>, char a4@<W3>, void **a5@<X8>)
{
  TNode *v10;
  TNode *v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  os_unfair_lock_s *v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  TChildrenList *v21;
  TNode *v22;
  os_unfair_lock_s *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  os_unfair_lock_s *v30;
  TNode *v31;
  os_unfair_lock_s *v32;
  TNode *v33;
  int v34;
  TNode *v35;
  FINode *fFINode;
  os_unfair_lock_s *v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  int v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  TFSInfo *v51[2];
  TNodePtr v52;
  std::__shared_weak_count *v53;
  TNodePtr v54;
  TFSInfo *v55;

  *a5 = 0;
  TGlobalNodes::RootNode((uint64_t *)&v54, (TGlobalNodes *)this);
  v10 = (TNode *)TNodeFromFINode(v54.fFINode);

  if (v10 == this)
  {
    TNode::GetVolume(a2, &v54);
    TNodePtr::operator=(a5, (void **)&v54.fFINode);

    return;
  }
  v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
  os_unfair_lock_lock(v12);
  v14 = *((_QWORD *)this + 2);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v12);
  v17 = (os_unfair_lock_s *)(v14 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
  v18 = *(_DWORD *)(v14 + 115);
  os_unfair_lock_unlock(v17);
  if (!v13)
    goto LABEL_9;
  v19 = (unint64_t *)&v13->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if ((v18 & 0x20) == 0)
      return;
  }
  else
  {
LABEL_9:
    if ((v18 & 0x20) == 0)
      return;
  }
  if (CFStringGetLength(*(CFStringRef *)a2) < 1)
    return;
  TNodePtr::TNodePtr(&v52, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v54, &v52, 0);

  v21 = (TChildrenList *)*((_QWORD *)this + 7);
  if (v21)
  {
    TChildrenList::Find(v21, (const TString *)a2, &v52);
    TNodePtr::operator=(a5, (void **)&v52.fFINode);

  }
  TNode::StPopulating::~StPopulating(&v54.fFINode);
  v22 = (TNode *)TNodeFromFINode((FINode *)*a5);
  if (v22 || (a4 & 1) != 0)
  {
    if (!a3)
      return;
    v30 = (os_unfair_lock_s *)TNode::ParentLock(v22);
    os_unfair_lock_lock(v30);
    TNodePtr::TNodePtr(&v54, *((const TNode **)this + 6));
    os_unfair_lock_unlock(v30);
    v31 = (TNode *)TNodeFromFINode(v54.fFINode);
    if (v31)
    {
      v32 = (os_unfair_lock_s *)TNode::ParentLock(v31);
      os_unfair_lock_lock(v32);
      TNodePtr::TNodePtr(&v52, *((const TNode **)this + 6));
      os_unfair_lock_unlock(v32);
      v33 = (TNode *)TNodeFromFINode(v52.fFINode);
      v34 = atomic_load((unsigned int *)TNode::GetNotifierList(v33));

      if (v34 > 0)
        return;
    }
    else
    {

    }
    v50 = TNodeFromFINode((FINode *)*a5);
    TNode::HandleSync(v50, 0x10080000u);
    return;
  }
  v23 = (os_unfair_lock_s *)TNode::InfoLock(0);
  os_unfair_lock_lock(v23);
  v25 = *((_QWORD *)this + 2);
  v24 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v24)
  {
    v26 = (unint64_t *)&v24->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    os_unfair_lock_unlock(v23);
    v28 = *(unsigned __int8 *)(v25 + 112);
    do
      v29 = __ldaxr(v26);
    while (__stlxr(v29 - 1, v26));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  else
  {
    os_unfair_lock_unlock(v23);
    v28 = *(unsigned __int8 *)(v25 + 112);
  }
  if (!v28
    && (CFStringGetLength(*(CFStringRef *)a2) != 1
     || CFStringGetLength(*(CFStringRef *)a2) < 1
     || CFStringGetCharacterAtIndex(*(CFStringRef *)a2, 0) != 46)
    && (CFStringGetLength(*(CFStringRef *)a2) != 2
     || TString::GetUniChar((TString *)a2, 0) != 46
     || TString::GetUniChar((TString *)a2, 1) != 46))
  {
    v35 = (TNode *)_ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v54);
    fFINode = v54.fFINode;
    v37 = (os_unfair_lock_s *)TNode::InfoLock(v35);
    os_unfair_lock_lock(v37);
    v38 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v52.fFINode = (FINode *)*((_QWORD *)this + 2);
    v53 = v38;
    if (v38)
    {
      v39 = (unint64_t *)&v38->__shared_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
    }
    os_unfair_lock_unlock(v37);
    v41 = TFSInfo::Initialize((TFSInfo *)fFINode, (os_unfair_lock_s **)&v52, (const TString *)a2);
    v42 = v53;
    if (v53)
    {
      v43 = (unint64_t *)&v53->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    if (!v41)
    {
      TFSInfo::FetchEnumeratorProperties((TFSInfo *)v54.fFINode);
      v51[0] = (TFSInfo *)v54.fFINode;
      v51[1] = v55;
      if (v55)
      {
        v45 = (unint64_t *)((char *)v55 + 8);
        do
          v46 = __ldxr(v45);
        while (__stxr(v46 + 1, v45));
      }
      TNode::FindOrCreateChild(this, v51, &v52);
      TNodePtr::operator=(a5, (void **)&v52.fFINode);

      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v51);
    }
    v47 = (std::__shared_weak_count *)v55;
    if (v55)
    {
      v48 = (unint64_t *)((char *)v55 + 8);
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
  }
}

void sub_1CBC79180(_Unwind_Exception *a1, uint64_t a2, ...)
{
  id *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<TNodeEventPtr *>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
    operator delete(v4);
  return a1;
}

void TNode::GetFSInfo(TNode *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v5 = *((_QWORD *)this + 3);
  *a2 = *((_QWORD *)this + 2);
  a2[1] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  os_unfair_lock_unlock(v4);
}

TFSInfo *TFSInfo::FetchEnumeratorProperties(TFSInfo *this)
{
  const __CFURL *v1;
  const __CFArray *v2;
  CFDictionaryRef v3;

  v1 = (const __CFURL *)*((_QWORD *)this + 1);
  if (v1)
  {
    if (!*((_BYTE *)this + 112))
    {
      v2 = (const __CFArray *)TFSInfo::IterationFullSetOfPropertyKeys(this);
      v3 = CFURLCopyResourcePropertiesForKeys(v1, v2, 0);
      return (TFSInfo *)TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef((const void **)&v3);
    }
  }
  return this;
}

CFIndex TFSInfo::Initialize(TFSInfo *a1, os_unfair_lock_s **a2, const TString *a3)
{
  return TFSInfo::Initialize(a1, *a2, a3);
}

CFIndex TFSInfo::Initialize(TFSInfo *this, os_unfair_lock_s *a2, const TString *a3)
{
  os_unfair_lock_s *v6;
  const void *v7;
  CFURLRef v8;
  CFURLRef URLAppendingNameToDirectoryURL;
  CFIndex v10;
  CFURLRef v12;
  CFURLRef v13;
  const void *v14;

  if (!a2)
    return 4294959224;
  v6 = a2 + 25;
  os_unfair_lock_lock(a2 + 25);
  v7 = *(const void **)&a2[4]._os_unfair_lock_opaque;
  v14 = v7;
  if (v7)
  {
    CFRetain(v7);
    os_unfair_lock_unlock(v6);
    v8 = CFURLCreateFilePathURL(0, (CFURLRef)v7, 0);
    v13 = v8;
    if (v8)
    {
      URLAppendingNameToDirectoryURL = TCFURLInfo::CreateURLAppendingNameToDirectoryURL(v8, (const void **)&a3->fString.fRef, 0);
      v12 = URLAppendingNameToDirectoryURL;
      if (URLAppendingNameToDirectoryURL)
        v10 = TFSInfo::initialize((uint64_t)this, URLAppendingNameToDirectoryURL, 0, 1, 1, 1, 0);
      else
        v10 = 4294959238;
      TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v12);
    }
    else
    {
      v10 = 4294959238;
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v13);
  }
  else
  {
    os_unfair_lock_unlock(v6);
    v10 = 4294959224;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v14);
  return v10;
}

void sub_1CBC79434(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

CFURLRef TCFURLInfo::CreateURLAppendingNameToDirectoryURL(TCFURLInfo *this, const void **a2, const TString *a3)
{
  Boolean v3;
  const __CFString *v5;
  CFTypeRef v6;
  CFIndex v8;
  char __source[1024];
  UInt8 buffer[1024];
  uint64_t v11;

  v3 = a3;
  v11 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(this, 1u, buffer, 1024))
    return 0;
  v5 = (const __CFString *)RetainCF<__CFString const*>(a2);
  if (v5)
  {
    v6 = CFAutorelease(v5);
    v5 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v6);
  }
  if (!CFStringGetCString(v5, __source, 1024, 0x8000100u)
    || strlen((const char *)buffer) >= 2 && strlcat((char *)buffer, "/", 0x400uLL) > 0x3FF
    || strlcat((char *)buffer, __source, 0x400uLL) > 0x3FF)
  {
    return 0;
  }
  v8 = strlen((const char *)buffer);
  return CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], buffer, v8, v3);
}

uint64_t std::deque<TString>::deque(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  TString **v8;
  unint64_t v9;
  char *v10;
  TString **v11;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  v4 = a2[4];
  v5 = a2[1];
  v6 = a2[2];
  v7 = (char *)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    v8 = 0;
    v11 = 0;
    v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    v8 = (TString **)(*(_QWORD *)v7 + 8 * (v4 & 0x1FF));
    v9 = a2[5] + v4;
    v10 = (char *)(v5 + 8 * (v9 >> 9));
    v11 = (TString **)(*(_QWORD *)v10 + 8 * (v9 & 0x1FF));
  }
  std::deque<TString>::__append<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>,0>((_QWORD *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_1CBC79680(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__split_buffer<TNodeEventPtr *>::~__split_buffer(v1);
  _Unwind_Resume(a1);
}

uint64_t TNode::FollowAlias(_BOOL8 IsAlias, TNodePtr *a2, TNodeRequest **a3, signed int a4)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  char *v8;
  TFSInfo *v9;
  unint64_t *v10;
  unint64_t v11;
  BOOL v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  TGlobalNodes *v21;
  int v22;
  unint64_t v23;
  os_unfair_lock_s *v24;
  char *v25;
  TFSInfo *v26;
  unint64_t *v27;
  unint64_t v28;
  _BOOL4 v29;
  _BOOL4 v30;
  unint64_t *v31;
  unint64_t v32;
  TNode *v33;
  const TNode *v34;
  TNode *v35;
  char *buffer;
  int v37;
  unint64_t *v38;
  unint64_t v39;
  _BOOL4 v41;
  uint64_t v42;
  os_unfair_lock_s *v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  int v48;
  unint64_t v49;
  TNodeRequest *v50;
  TNodeRequest *v52;
  TPropertyValue v53;
  id obj;
  signed int v55;

  v6 = IsAlias;
  v55 = a4;
  if ((a4 & 0x20000) == 0)
    goto LABEL_13;
  IsAlias = TNode::IsInTrash((TNode *)IsAlias);
  if (!IsAlias)
    goto LABEL_13;
  v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsAlias);
  os_unfair_lock_lock(v7);
  v9 = *(TFSInfo **)(v6 + 16);
  v8 = *(char **)(v6 + 24);
  v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v9;
  v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v8;
  if (v8)
  {
    v10 = (unint64_t *)(v8 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v7);
  IsAlias = TFSInfo::IsAlias(v9);
  v12 = IsAlias;
  if (v8)
  {
    v13 = (unint64_t *)(v8 + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      (*(void (**)(char *))(*(_QWORD *)v8 + 16))(v8);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v8);
      if (v12)
        return 4294959232;
LABEL_13:
      v16 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsAlias);
      os_unfair_lock_lock(v16);
      v18 = *(_QWORD *)(v6 + 16);
      v17 = *(std::__shared_weak_count **)(v6 + 24);
      if (v17)
      {
        p_shared_owners = (unint64_t *)&v17->__shared_owners_;
        do
          v20 = __ldxr(p_shared_owners);
        while (__stxr(v20 + 1, p_shared_owners));
        os_unfair_lock_unlock(v16);
        v22 = *(unsigned __int8 *)(v18 + 112);
        do
          v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      else
      {
        os_unfair_lock_unlock(v16);
        v22 = *(unsigned __int8 *)(v18 + 112);
      }
      if (v22 == 1)
      {
        TGlobalNodes::RootNode(&v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value, v21);
        TNodePtr::operator=((void **)&a2->fFINode, (void **)&v53);

        TNode::SetAliasTarget((TNode *)v6, a2, 1);
        return 0;
      }
      v24 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v21);
      os_unfair_lock_lock(v24);
      v26 = *(TFSInfo **)(v6 + 16);
      v25 = *(char **)(v6 + 24);
      v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v26;
      v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v25;
      if (v25)
      {
        v27 = (unint64_t *)(v25 + 8);
        do
          v28 = __ldxr(v27);
        while (__stxr(v28 + 1, v27));
      }
      os_unfair_lock_unlock(v24);
      v29 = TFSInfo::IsAlias(v26);
      v30 = v29;
      if (!v25)
        goto LABEL_30;
      v31 = (unint64_t *)(v25 + 8);
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        (*(void (**)(char *))(*(_QWORD *)v25 + 16))(v25);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v25);
        if (v30)
          goto LABEL_31;
      }
      else
      {
LABEL_30:
        if (v29)
        {
LABEL_31:
          TNode::GetAliasTarget((TNode *)v6, &obj);
          if (TNodeFromFINode((FINode *)obj))
          {
            v33 = (TNode *)TNodeFromFINode((FINode *)obj);
            if (TNode::Validate(v33, v34))
            {
              v35 = (TNode *)TNodeFromFINode((FINode *)obj);
              TNode::GetVolumeInfo(v35, &v53);
              buffer = v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
              v37 = *(unsigned __int8 *)(v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value + 123);
              if (v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
              {
                v38 = (unint64_t *)(v53.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                                         + 8);
                do
                  v39 = __ldaxr(v38);
                while (__stlxr(v39 - 1, v38));
                if (!v39)
                {
                  (*(void (**)(char *))(*(_QWORD *)buffer + 16))(buffer);
                  std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buffer);
                }
              }
              if (!v37)
              {
                TNode::ClearAliasTarget((TNode *)v6, 0);
                TNodePtr::TNodePtr((TNodePtr *)&v53, 0);
                TNodePtr::operator=(&obj, (void **)&v53);

              }
            }
          }
          if ((v55 & 0x40000) != 0)
          {
            TNodePtr::TNodePtr((TNodePtr *)&v53, 0);
            TNodePtr::operator=(&obj, (void **)&v53);

            v41 = 0;
          }
          else
          {
            v41 = v55 < 0 || *a3 != 0;
            if ((v55 & 0x40000000) != 0)
            {
              if (TNodeFromFINode((FINode *)obj))
                v15 = 0;
              else
                v15 = 4294959232;
LABEL_72:
              objc_storeStrong((id *)&a2->fFINode, obj);

              return v15;
            }
          }
          if (!TNodeFromFINode((FINode *)obj))
            goto LABEL_65;
          v42 = TNodeFromFINode((FINode *)obj);
          v43 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v42);
          os_unfair_lock_lock(v43);
          v45 = *(_QWORD *)(v42 + 16);
          v44 = *(std::__shared_weak_count **)(v42 + 24);
          if (v44)
          {
            v46 = (unint64_t *)&v44->__shared_owners_;
            do
              v47 = __ldxr(v46);
            while (__stxr(v47 + 1, v46));
            os_unfair_lock_unlock(v43);
            v48 = *(unsigned __int8 *)(v45 + 112);
            do
              v49 = __ldaxr(v46);
            while (__stlxr(v49 - 1, v46));
            if (!v49)
            {
              ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
              std::__shared_weak_count::__release_weak(v44);
            }
          }
          else
          {
            os_unfair_lock_unlock(v43);
            v48 = *(unsigned __int8 *)(v45 + 112);
          }
          if (v48 != 16)
          {
            v15 = 0;
          }
          else
          {
LABEL_65:
            if (v41)
            {
              v55 = v55 & 0xFFFBFFFD | 0x40000;
              TNode::SetUnresolvedTarget((TNode *)v6);
              v53.fData.__impl_.__index = 0;
              std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v53, &v55);
              v50 = *a3;
              v52 = v50;
              if (v50)
                TNodeRequest::AddPtrReference(v50);
              TNode::RequestTask(v6, 10, 1920167792, &v53, &v52, 0);
              TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v52);
              TPropertyValue::~TPropertyValue(&v53);
              v15 = 0;
            }
            else
            {
              v15 = TNode::FollowAlias(v6, v55);
            }
            TNode::GetAliasTarget((TNode *)v6, &v53);
            TNodePtr::operator=(&obj, (void **)&v53);

          }
          goto LABEL_72;
        }
      }
      TNodePtr::TNodePtr((TNodePtr *)&v53, (const TNode *)v6);
      TNodePtr::operator=((void **)&a2->fFINode, (void **)&v53);

      return 0;
    }
  }
  if (!IsAlias)
    goto LABEL_13;
  return 4294959232;
}

void sub_1CBC79B08(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a10);

  _Unwind_Resume(a1);
}

void TNode::GetAliasTarget(TNode *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  *a2 = *((id *)this + 4);
  os_unfair_lock_unlock(v4);
}

void TPathName::TPathName(TPathName *this, TString *a2, int a3)
{
  CFIndex Length;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int CharacterAtIndex;
  CFStringRef theString;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  Length = CFStringGetLength(a2->fString.fRef);
  if (Length >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = 1;
    while (1)
    {
      if (CFStringGetLength(a2->fString.fRef) <= v9 - 1)
        CharacterAtIndex = 0;
      else
        CharacterAtIndex = CFStringGetCharacterAtIndex(a2->fString.fRef, v9 - 1);
      if (CharacterAtIndex == a3)
      {
        if (v7)
        {
          TString::SubString(a2, v8, v7, (TString *)&theString);
          if (CFStringGetLength(theString) == 1
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            || CFStringGetLength(theString) == 2
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            && CFStringGetLength(theString) >= 2
            && CFStringGetCharacterAtIndex(theString, 1) == 46)
          {
            goto LABEL_32;
          }
          std::deque<TString>::push_back(this, (TString **)&theString);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
          v7 = 0;
        }
        v8 = v9;
      }
      else
      {
        ++v7;
        if (Length == v9 && v7)
        {
          TString::SubString(a2, v8, v7, (TString *)&theString);
          if (CFStringGetLength(theString) == 1
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            || CFStringGetLength(theString) == 2
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            && CFStringGetLength(theString) >= 2
            && CFStringGetCharacterAtIndex(theString, 1) == 46)
          {
LABEL_32:
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
            return;
          }
          std::deque<TString>::push_back(this, (TString **)&theString);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
          v7 = 0;
          v8 = Length;
        }
      }
      if (Length > v9)
      {
        ++v9;
        if (v7 < 256)
          continue;
      }
      return;
    }
  }
}

void sub_1CBC79DF8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::deque<TString>::~deque[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void TString::SubString(TString *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, TString *a4@<X8>)
{
  CFIndex v6;
  CFIndex v7;
  CFIndex Length;
  uint64_t *v9;
  TString *v10;
  TString *v11;
  CFRange v12;

  v6 = a2 & ~(a2 >> 63);
  v7 = a3 + v6 - 1;
  Length = CFStringGetLength(this->fString.fRef);
  if (Length - 1 < v7)
    v7 = Length - 1;
  if (v7 >= v6)
  {
    Length = CFStringGetCharacterAtIndex(this->fString.fRef, v6);
    if ((Length & 0xFC00) == 0xDC00)
      ++v6;
  }
  if (v7 >= v6)
  {
    Length = CFStringGetCharacterAtIndex(this->fString.fRef, v7);
    v7 -= (Length & 0xFC00) == 55296;
  }
  if (v6 || (Length = CFStringGetLength(this->fString.fRef), v7 != Length - 1))
  {
    if (v7 >= v6)
    {
      v12.length = v7 - v6 + 1;
      v12.location = v6;
      v10 = (TString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], this->fString.fRef, v12);
      v11 = v10;
      a4->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a4, v10);
      TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v11);
    }
    else
    {
      v9 = TString::KEmptyString((TString *)Length);
      a4->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a4, (TString *)*v9);
    }
  }
  else
  {
    a4->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a4, (TString *)this->fString.fRef);
  }
}

void sub_1CBC79F78(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

TString *std::deque<TString>::push_back(_QWORD *a1, TString **a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  TString *v8;
  TString *result;

  v4 = a1[1];
  v5 = a1[2];
  v6 = ((v5 - v4) << 6) - 1;
  if (v5 == v4)
    v6 = 0;
  if (v6 == a1[5] + a1[4])
  {
    std::deque<TString>::__add_back_capacity(a1);
    v4 = a1[1];
    v5 = a1[2];
  }
  if (v5 == v4)
  {
    v8 = 0;
  }
  else
  {
    v7 = a1[5] + a1[4];
    v8 = (TString *)(*(_QWORD *)(v4 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF));
  }
  result = std::construct_at[abi:ne180100]<TString,TString const&,TString*>(v8, a2);
  ++a1[5];
  return result;
}

void std::deque<TString>::__add_back_capacity(_QWORD *a1, unint64_t a2)
{
  char *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  int64_t v26;
  char *v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  _QWORD *v39;
  char *v40;
  int64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  char *v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t i;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  _QWORD *v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  int64_t v76;
  char *v77;
  unint64_t v78;
  char *v79;
  uint64_t v80;
  char *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  char *v87;
  void *v88;
  void *__p[2];
  __int128 v90;
  _QWORD *v91;

  v3 = (char *)a1[2];
  v4 = (uint64_t)&v3[-a1[1]];
  if (v4)
    v5 = a2;
  else
    v5 = a2 + 1;
  if ((v5 & 0x1FF) != 0)
    v6 = (v5 >> 9) + 1;
  else
    v6 = v5 >> 9;
  v7 = a1[4];
  if (v6 >= v7 >> 9)
    v8 = v7 >> 9;
  else
    v8 = v6;
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      v16 = (_QWORD *)a1[1];
      v19 = *v16;
      v17 = (char *)(v16 + 1);
      v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1)
            v28 = 1;
          else
            v28 = (uint64_t)&v3[-*a1] >> 2;
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v28);
          v31 = &v29[8 * (v28 >> 2)];
          v32 = (uint64_t *)a1[1];
          v3 = v31;
          v33 = a1[2] - (_QWORD)v32;
          if (v33)
          {
            v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            v34 = 8 * (v33 >> 3);
            v35 = &v29[8 * (v28 >> 2)];
            do
            {
              v36 = *v32++;
              *(_QWORD *)v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            v3 = (char *)a1[2];
          }
        }
        else
        {
          v21 = v20 >> 3;
          v22 = v20 >> 3 < -1;
          v23 = (v20 >> 3) + 2;
          if (v22)
            v24 = v23;
          else
            v24 = v21 + 1;
          v25 = &v17[-8 * (v24 >> 1)];
          v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            v3 = (char *)a1[1];
          }
          v27 = &v3[-8 * (v24 >> 1)];
          v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(_QWORD *)v3 = v18;
      v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    v9 = v6 - v8;
    v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          std::__split_buffer<TNodeEventPtr *>::push_back(a1, __p);
          --v6;
          if (!--v9)
            goto LABEL_75;
        }
        for (i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8)
            v64 = 511;
          else
            v64 = 512;
          v65 = v64 + a1[4];
          a1[4] = v65;
        }
        v8 = v6;
      }
      else
      {
LABEL_75:
        v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        v66 = (char *)a1[2];
        do
        {
          v67 = (_QWORD *)a1[1];
          v70 = *v67;
          v68 = (char *)(v67 + 1);
          v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1)
                v78 = 1;
              else
                v78 = (uint64_t)&v66[-*a1] >> 2;
              v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v78);
              v81 = &v79[8 * (v78 >> 2)];
              v82 = (uint64_t *)a1[1];
              v66 = v81;
              v83 = a1[2] - (_QWORD)v82;
              if (v83)
              {
                v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                v84 = 8 * (v83 >> 3);
                v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  v86 = *v82++;
                  *(_QWORD *)v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                v66 = (char *)a1[2];
              }
            }
            else
            {
              v72 = v71 >> 3;
              v22 = v71 >> 3 < -1;
              v73 = (v71 >> 3) + 2;
              if (v22)
                v74 = v73;
              else
                v74 = v72 + 1;
              v75 = &v68[-8 * (v74 >> 1)];
              v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                v66 = (char *)a1[1];
              }
              v77 = &v66[-8 * (v74 >> 1)];
              v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(_QWORD *)v66 = v69;
          v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      v11 = v4 >> 3;
      v12 = v10 >> 2;
      if (v12 <= v9 + v11)
        v13 = v9 + v11;
      else
        v13 = v12;
      v14 = v11 - v8;
      v91 = a1 + 3;
      if (v13)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v13);
      else
        v15 = 0;
      v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&v90 = __p[1];
      *((_QWORD *)&v90 + 1) = &v15[8 * v13];
      do
      {
        v88 = operator new(0x1000uLL);
        std::__split_buffer<TNodeEventPtr *>::push_back(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        v39 = (_QWORD *)a1[1];
        v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0])
                v48 = 1;
              else
                v48 = (v40 - (char *)__p[0]) >> 2;
              v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v91, v48);
              v51 = (uint64_t *)__p[1];
              v40 = &v49[8 * (v48 >> 2)];
              v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                v53 = 8 * (v52 >> 3);
                v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  v55 = *v51++;
                  *(_QWORD *)v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(_QWORD *)&v90 = v40;
              *((_QWORD *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                v40 = (char *)v90;
              }
            }
            else
            {
              v42 = v41 >> 3;
              v22 = v41 >> 3 < -1;
              v43 = (v41 >> 3) + 2;
              if (v22)
                v44 = v43;
              else
                v44 = v42 + 1;
              v45 = (char *)__p[1] - 8 * (v44 >> 1);
              v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                v40 = (char *)__p[1];
              }
              v47 = &v40[-8 * (v44 >> 1)];
              v40 = &v45[v46];
              __p[1] = v47;
              *(_QWORD *)&v90 = &v45[v46];
            }
          }
          *(_QWORD *)v40 = *v39;
          v40 = (char *)(v90 + 8);
          *(_QWORD *)&v90 = v90 + 8;
          v39 = (_QWORD *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      v57 = (_QWORD *)a1[2];
      v58 = -7 - (_QWORD)v57;
      while (v57 != (_QWORD *)a1[1])
      {
        --v57;
        v58 += 8;
        std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)__p, v57);
      }
      v59 = (char *)*a1;
      v60 = *(_OWORD *)__p;
      v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      v90 = v62;
      a1[4] -= v38;
      if (v57 != (_QWORD *)v62)
        *(_QWORD *)&v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      if (v59)
        operator delete(v59);
    }
  }
}

void sub_1CBC7A558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::deque<TString>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1CBC7A894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<TNodeEventPtr *>::push_back(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;

  v5 = (char *)a1[3];
  v4 = (uint64_t)(a1 + 3);
  v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    v7 = (char *)a1[1];
    v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v18 = 1;
      else
        v18 = (uint64_t)&v6[-*a1] >> 2;
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v18);
      v21 = &v19[8 * (v18 >> 2)];
      v22 = (uint64_t *)a1[1];
      v6 = v21;
      v23 = a1[2] - (_QWORD)v22;
      if (v23)
      {
        v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        v24 = 8 * (v23 >> 3);
        v25 = &v19[8 * (v18 >> 2)];
        do
        {
          v26 = *v22++;
          *(_QWORD *)v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        v6 = (char *)a1[2];
      }
    }
    else
    {
      v9 = v8 >> 3;
      v10 = v8 >> 3 < -1;
      v11 = (v8 >> 3) + 2;
      if (v10)
        v12 = v11;
      else
        v12 = v9 + 1;
      v13 = -(v12 >> 1);
      v14 = v12 >> 1;
      v15 = &v7[-8 * v14];
      v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        v6 = (char *)a1[1];
      }
      v17 = &v6[8 * v13];
      v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(_QWORD *)v6 = *a2;
  a1[2] += 8;
}

uint64_t TNode::Validate(TNode *this, const TNode *a2)
{
  TNode *v3;
  uint64_t v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  unint64_t v8;

  v3 = (TNode *)TNode::WeakValidate(this, a2);
  if ((_DWORD)v3)
    return 4294959238;
  v5 = (os_unfair_lock_s *)TNode::InfoLock(v3);
  os_unfair_lock_lock(v5);
  v6 = *((_QWORD *)this + 2);
  v4 = 4294959238;
  if (v6)
  {
    v7 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    v8 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
    os_unfair_lock_unlock(v7);
    if ((v8 & 0x100000000) != 0)
      v4 = 4294959238;
    else
      v4 = 0;
  }
  os_unfair_lock_unlock(v5);
  return v4;
}

{
  const TNode *v3;

  if (TNode::WeakValidate(this, a2))
    return 4294959238;
  else
    return TNode::Validate(this, v3);
}

BOOL operator==(CFTypeRef *a1, const char *a2)
{
  _BOOL8 v3;
  CFTypeRef cf2;

  TString::TString((TString *)&cf2, a2);
  v3 = CFEqual(*a1, cf2) != 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
  return v3;
}

void sub_1CBC7AAC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TPathName::VolumesDirectory(TString *a1@<X8>)
{
  unsigned __int8 v3;
  TString **v4;
  TString *v5;

  {
    v5 = (TString *)operator new();
    TString::TString(v5, "Volumes");
    TPathName::VolumesDirectory(void)::volumes = (uint64_t)v5;
  }
  v4 = (TString **)TPathName::VolumesDirectory(void)::volumes;
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *v4);
}

void sub_1CBC7AB78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void TPathName::UsersDirectory(TString *a1@<X8>)
{
  unsigned __int8 v3;
  TString **v4;
  TString *v5;

  {
    v5 = (TString *)operator new();
    TString::TString(v5, "Users");
    TPathName::UsersDirectory(void)::users = (uint64_t)v5;
  }
  v4 = (TString **)TPathName::UsersDirectory(void)::users;
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *v4);
}

void sub_1CBC7AC64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__1(uint64_t a1)
{
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 32);
}

const void **__destroy_helper_block_ea8_32c44_ZTSKZN12TBusyFolders14StartObservingEvE3__0(uint64_t a1)
{
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(a1 + 40));
}

uint64_t MatchesEDSContainerPattern(const TString *a1)
{
  void *v2;
  uint64_t v3;
  BOOL v4;
  CFIndex v5;
  BOOL v6;
  CFIndex v7;
  TString v9;
  CFTypeRef cf;
  TString v11;

  v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E98]), "initFileURLWithPath:", a1->fString.fRef);
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v3 = objc_msgSend(v2, "fp_matchesEDSLocation");
  }
  else
  {
    v11.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v11, (TString *)a1->fString.fRef);
    TString::TString((TString *)&cf, "/private", 8uLL);
    RemovePrefix((const TString *)&cf, &v11);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    TString::TString((TString *)&cf, "/var/PersonaVolumes/", 0x14uLL);
    v4 = RemovePrefix((const TString *)&cf, &v11);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (!v4)
      goto LABEL_13;
    TString::TString((TString *)&cf, "/");
    v5 = TString::IndexOf(&v11, (const TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v5 < 1)
      goto LABEL_13;
    TString::SubStringFrom(&v11, v5, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v11.fString.fRef, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    TString::TString((TString *)&cf, "/Containers/Data/InternalDaemon/", 0x20uLL);
    v6 = RemovePrefix((const TString *)&cf, &v11);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (!v6)
      goto LABEL_13;
    TString::TString((TString *)&cf, "/");
    v7 = TString::IndexOf(&v11, (const TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v7 >= 1)
    {
      TString::SubStringFrom(&v11, v7, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v11.fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TString::TString((TString *)&cf, "/Library/Mobile Documents", 0x19uLL);
      if (RemovePrefix((const TString *)&cf, &v11))
      {
        v3 = 1;
      }
      else
      {
        TString::TString(&v9, "/Library/CloudStorage", 0x15uLL);
        v3 = RemovePrefix(&v9, &v11);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    else
    {
LABEL_13:
      v3 = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
  }

  return v3;
}

void sub_1CBC7AF28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  const void *v4;
  va_list va;
  const void *v6;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v6 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  _Unwind_Resume(a1);
}

const void **TSystemNotificationTask::HandleAllFileChanges(TSystemNotificationTask *this, const __FSEventStream *a2, const void **a3, const char **a4, int *a5, const unsigned int *a6, const unint64_t *a7)
{
  return TSystemNotificationTask::HandleFSEvent(a3, a4, a5, 0);
}

uint64_t __copy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__1(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

CFTypeRef __copy_helper_block_ea8_32c44_ZTSKZN12TBusyFolders14StartObservingEvE3__0(uint64_t a1, uint64_t a2)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = result;
  if (result)
    return CFRetain(result);
  return result;
}

double ___ZN12TGlobalNodes11GlobalNodesEv_block_invoke()
{
  _OWORD *v0;
  double result;

  v0 = (_OWORD *)operator new();
  result = 0.0;
  *v0 = 0u;
  v0[1] = 0u;
  v0[2] = 0u;
  v0[3] = 0u;
  v0[4] = 0u;
  v0[5] = 0u;
  v0[6] = 0u;
  v0[7] = 0u;
  TGlobalNodes::gGlobalNodes = (uint64_t)v0;
  return result;
}

void sub_1CBC7B0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

id TGlobalNodes::iCloudLibrariesContainerNode@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  id result;
  _QWORD block[5];

  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes28iCloudLibrariesContainerNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::iCloudLibrariesContainerNode(void)::onceToken != -1)
    dispatch_once(&TGlobalNodes::iCloudLibrariesContainerNode(void)::onceToken, block);
  result = *(id *)(v3 + 80);
  *a1 = result;
  return result;
}

void ___ZN10TNodeEvent25GetInternalClientNotifierEv_block_invoke()
{
  TNode *EventQueue;
  FINode *v1;
  TSystemNotificationTask *v2;
  void *v3;
  TNode *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  TDSNotifier *v8;
  id v9;
  FINode *v10[3];
  __int128 v11;

  EventQueue = (TNode *)TNodeEvent::CreateEventQueue(0);
  TNode::GetSuperRootNode((uint64_t *)v10, EventQueue);
  v1 = (FINode *)TNodeFromFINode(v10[0]);

  v10[1] = 0;
  v10[2] = 0;
  v10[0] = v1;
  TSystemNotificationTask::SystemNotificationQueue(v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  TClientChangeNotifier::Make(v10, (uint64_t)EventQueue, (uint64_t)TNodeEvent::HandleInternalEvent, v3, 0, (uint64_t)&v11);

  TNode::GetSuperRootNode((uint64_t *)&v9, v4);
  TDSNotifier::Make((uint64_t)&v11, (uint64_t)&v9, (uint64_t)&v9, (uint64_t *)&v8);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(&TNodeEvent::gInternalNotifier, &v8);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v8);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)&TNodeEvent::gInternalClientChangeNotifier, &v11);

  v5 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBC7B2B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  uint64_t v11;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;

  v13 = *(std::__shared_weak_count **)(v11 - 24);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  _Unwind_Resume(a1);
}

id TSystemNotificationTask::SystemNotificationQueue(TSystemNotificationTask *this)
{
  return (id)gSystemNotificationGCDQueue;
}

void TClientChangeNotifier::Make(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X4>, uint64_t a6@<X8>)
{
  id v11;
  TDSNotifier *v12;
  TDSMutex *RegistrationLock;
  _QWORD *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  uint64_t v21;
  std::__shared_weak_count *shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t *p_shared_weak_owners;
  unint64_t v28;
  unint64_t v29;
  uint64_t i;
  uint64_t v31;
  char v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;

  v11 = a4;
  v12 = a5;
  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock(v12);
  TDSMutex::lock(RegistrationLock);
  if (*a1)
  {
    v14 = (_QWORD *)TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList;
    v15 = qword_1EF9B9C18;
    while (1)
    {
      if (v14 == (_QWORD *)v15)
        goto LABEL_14;
      *(_QWORD *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 0;
      v16 = (std::__shared_weak_count *)v14[1];
      if (v16)
      {
        v17 = std::__shared_weak_count::lock(v16);
        *(_QWORD *)(a6 + 8) = v17;
        if (v17)
        {
          v18 = (_QWORD *)*v14;
          *(_QWORD *)a6 = *v14;
          if (!v18)
            goto LABEL_12;
        }
        else
        {
          v18 = *(_QWORD **)a6;
          if (!*(_QWORD *)a6)
            goto LABEL_12;
        }
        if (v18[2] == *a1 && v18[5] == a2 && (id)v18[6] == v11)
          goto LABEL_33;
      }
LABEL_12:
      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a6);
      v14 += 2;
    }
  }
  *a1 = ++TClientChangeNotifier::Make(NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::sListenerSerialID;
LABEL_14:
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v19 = (std::__shared_weak_count *)operator new(0x90uLL);
  v19->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v19->__shared_owners_;
  v19->__shared_weak_owners_ = 0;
  v19->__vftable = (std::__shared_weak_count_vtbl *)&off_1E874EFC8;
  v37 = *(_OWORD *)a1;
  v38 = a1[2];
  *(_QWORD *)&v33 = TClientChangeNotifier::TClientChangeNotifier((uint64_t)&v19[1], v21, (uint64_t)&v37, a2, a3, v11, v12);
  *((_QWORD *)&v33 + 1) = v19;
  shared_owners = (std::__shared_weak_count *)v19[1].__shared_owners_;
  if (!shared_owners)
  {
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v28 = __ldxr(p_shared_weak_owners);
    while (__stxr(v28 + 1, p_shared_weak_owners));
    v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
    v19[1].__shared_owners_ = (uint64_t)v19;
    do
LABEL_24:
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    goto LABEL_27;
  }
  if (shared_owners->__shared_owners_ == -1)
  {
    do
      v23 = __ldxr(p_shared_owners);
    while (__stxr(v23 + 1, p_shared_owners));
    v24 = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
    v19[1].__shared_owners_ = (uint64_t)v19;
    std::__shared_weak_count::__release_weak(shared_owners);
    goto LABEL_24;
  }
LABEL_27:
  for (i = v34; i != v35; i += 32)
  {
    v31 = *(_QWORD *)(i + 24);
    if (!v31)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 48))(v31);
  }
  *(_OWORD *)a6 = v33;
  *(_QWORD *)&v37 = &v34;
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v37);
  if (a2)
    std::vector<std::weak_ptr<TClientChangeNotifier>>::emplace_back<std::shared_ptr<TClientChangeNotifier> &>(&TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList, (__int128 *)a6);
LABEL_33:
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v32);

}

void sub_1CBC7B594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void *v13;
  void *v14;
  uint64_t v15;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v15);
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&a13);

  _Unwind_Resume(a1);
}

void std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::destroy(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;

}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  *a2 = &unk_1E874FF20;
  result = MEMORY[0x1D17A5A30](*(_QWORD *)(a1 + 8));
  a2[1] = result;
  return result;
}

uint64_t TNodeEvent::CreateEventQueue(void *a1)
{
  uint64_t v1;
  _QWORD *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  __int128 v8;
  id v9;
  uint64_t *v10;

  v9 = a1;
  EventQueueSpinLock();
  os_unfair_lock_lock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
  ++sEventQueueSerial;
  std::allocate_shared[abi:ne180100]<TBlockingEventQueue,std::allocator<TBlockingEventQueue>,void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,void>(&v9, &sEventQueueSerial, &v8);
  v1 = EventQueues();
  v10 = &sEventQueueSerial;
  v2 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v1, (unint64_t *)&sEventQueueSerial, (uint64_t)&std::piecewise_construct, &v10);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)(v2 + 3), &v8);
  v3 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v4 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = sEventQueueSerial;
  os_unfair_lock_unlock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);

  return v6;
}

void sub_1CBC7B728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);

  _Unwind_Resume(a1);
}

uint64_t TBlockingEventQueue::TBlockingEventQueue(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  _QWORD *v6;

  v5 = a2;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 48) = 850045863;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 1018212795;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  v6 = operator new(0x58uLL);
  v6[2] = 0;
  *v6 = &unk_1E8750880;
  v6[1] = 0;
  v6[3] = 850045863;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  v6[10] = 0;
  *(_QWORD *)(a1 + 160) = v6 + 3;
  *(_QWORD *)(a1 + 168) = v6;
  *(_DWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  if (v5)
  {
    *(_QWORD *)(a1 + 184) = &unk_1E874FF20;
    *(_QWORD *)(a1 + 192) = MEMORY[0x1D17A5A30](v5);
    *(_QWORD *)(a1 + 208) = a1 + 184;
  }
  *(_QWORD *)(a1 + 216) = a3;

  return a1;
}

void sub_1CBC7B84C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  std::mutex *v3;
  std::condition_variable *v4;

  std::condition_variable::~condition_variable(v4);
  std::mutex::~mutex(v3);
  std::deque<TNodeEventPtr>::~deque[abi:ne180100](v1);

  _Unwind_Resume(a1);
}

void NodeContextOpen()
{
  const TString *v0;
  void *v1;
  uint8_t *v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  TSystemNotificationTask *v6;
  TNode *v7;
  _QWORD v8[5];
  TString v9;
  TString v10;
  os_signpost_id_t v11;
  std::mutex v12;
  os_signpost_id_t SignpostID;
  _QWORD v14[5];
  uint8_t buf[8];
  os_signpost_id_t *v16;
  uint8_t *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  TString::TString(&v10, "DS Context");
  TString::TString(&v9, "Open");
  StSignpostMacroHelper::GetOrCreateFinderLog(&v10, v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  ISignpostInterval::ISignpostInterval((uint64_t)&v12, v1);

  SignpostID = ISignpostInterval::MakeSignpostID((ISignpostInterval *)&v12, 0);
  v14[0] = &off_1E874E9A0;
  v14[3] = v14;
  v14[4] = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  std::mutex::lock(&v12);
  v11 = SignpostID;
  *(_QWORD *)buf = &off_1E874ED10;
  v16 = &v11;
  v17 = buf;
  ISignpostInterval::BeginPriv((uint64_t)&v12, SignpostID, (uint64_t)buf);
  v2 = v17;
  if (v17 == buf)
  {
    v3 = 4;
    v2 = buf;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  std::mutex::unlock(&v12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
  if (gNodeContextCloseAsyncGroup)
  {
    std::mutex::lock(&gNodeContextCloseAsyncSignpostLock);
    if (gNodeContextCloseAsyncSignpost)
      AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(gNodeContextCloseAsyncSignpost, (uint64_t)"Waiting for previous context close to complete");
    std::mutex::unlock(&gNodeContextCloseAsyncSignpostLock);
    dispatch_group_wait((dispatch_group_t)gNodeContextCloseAsyncGroup, 0xFFFFFFFFFFFFFFFFLL);
  }
  ContextMutex();
  TDSMutex::lock(&ContextMutex(void)::mutex);
  v4 = sContextOpenCount++;
  if (v4 <= 0)
  {
    LogObj(5);
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_DEFAULT, "DS Opened", buf, 2u);
    }

    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3321888768;
    v8[2] = __NodeContextOpen_block_invoke;
    v8[3] = &__block_descriptor_33_ea8_32c28_ZTSKZ15NodeContextOpenE3__2_e5_v8__0l;
    if (NodeContextOpen::once != -1)
      dispatch_once(&NodeContextOpen::once, v8);
    TSystemNotificationTask::MakeSystemNotificationTask(v6);
    TNode::SynchronizeVolumes(v7);
  }
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&v12);
}

void sub_1CBC7BAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, int a7, __int16 a8, char a9, char a10, uint64_t a11, std::mutex *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&a18);
  _Unwind_Resume(a1);
}

void TNode::SynchronizeVolumes(TNode *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  FINode *v4;
  BOOL v5;

  TGlobalNodes::RootNode((uint64_t *)&v4);
  v1 = TNodeFromFINode(v4);
  v5 = 0;
  v2 = TNode::HandleSyncStarted(v1, 285212672, &v5);
  v3 = TNodeFromFINode(v4);
  TNode::HandleSyncCompleted(v3, v2);

}

void sub_1CBC7BC6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

uint64_t TNode::HandleSyncStarted(uint64_t a1, int a2, BOOL *a3)
{
  TNode *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  os_unfair_lock_s *v12;
  int v13;
  unint64_t *v14;
  unint64_t v15;
  BOOL v16;
  unsigned __int16 *v17;
  unsigned __int16 v18;
  TNodePtr v20;

  *a3 = 0;
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v20);
  v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  v9 = *(_QWORD *)(a1 + 16);
  v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v7);
  v12 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  v13 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v12);
  if (v8)
  {
    v14 = (unint64_t *)&v8->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v16 = 0;
  if ((a2 & 0x1800000) != 0 && (v13 & 0x20) != 0)
  {
    v17 = (unsigned __int16 *)(a1 + 80);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 | 8, v17));
    v16 = (v18 & 8) == 0;
  }
  *a3 = v16;
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v20);
  if (*a3)
  {
    TNodePtr::TNodePtr(&v20, (const TNode *)a1);
    TNode::SendNotification((const TNode *)a1, 9, (id *)&v20.fFINode, 0, 0);
  }
  else
  {
    if ((a2 & 0x800000) != 0)
      return a2 & 0xFF7FFFFF;
    TNodePtr::TNodePtr(&v20, (const TNode *)a1);
  }

  if (*a3)
    return a2 | 0x4800000u;
  return a2 & 0xFF7FFFFF;
}

void sub_1CBC7BDEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNode::HandleSyncCompleted(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  char IsDatalessNow;
  char v10;
  unint64_t *v11;
  unint64_t v12;
  TNode *v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  os_unfair_lock_s *v19;
  int v20;
  unint64_t *v21;
  unint64_t v22;
  int v23;
  int v24;
  uint64_t NotifierList;
  std::__shared_weak_count *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  id v30;
  unint64_t *v31;
  unint64_t v32;
  NSObject *v33;
  id v34;
  unsigned __int16 *v35;
  unsigned __int16 v36;
  id v37;
  int v38;
  int v39;
  int v40;
  int v41;
  void *v42;
  NSObject *v43;
  void *v44;
  NSObject *v45;
  _BOOL8 v46;
  os_unfair_lock_s *v47;
  std::__shared_weak_count *v48;
  TFSInfo *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  void *v54;
  unsigned __int16 *v55;
  unsigned __int16 v56;
  unsigned __int16 v57;
  unsigned __int16 *v58;
  unsigned __int16 v59;
  NSObject *v60;
  void *v61;
  unsigned __int16 *v62;
  unsigned __int16 v63;
  void *v64;
  TString v65;
  char v66;
  _BYTE v67[12];
  __int128 buf;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(TFSInfo **)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  *(_QWORD *)&buf = v6;
  *((_QWORD *)&buf + 1) = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  IsDatalessNow = TFSInfo::IsDatalessNow(v6);
  v10 = IsDatalessNow;
  if (!v5)
    goto LABEL_8;
  v11 = (unint64_t *)&v5->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if ((v10 & 1) != 0)
      goto LABEL_85;
  }
  else
  {
LABEL_8:
    if ((IsDatalessNow & 1) != 0)
    {
LABEL_85:
      TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);

      return;
    }
  }
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v66);
  if ((a2 & 0xC00000) == 0)
    goto LABEL_18;
  v14 = (os_unfair_lock_s *)TNode::InfoLock(v13);
  os_unfair_lock_lock(v14);
  v16 = *(_QWORD *)(a1 + 16);
  v15 = *(std::__shared_weak_count **)(a1 + 24);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v14);
  v19 = (os_unfair_lock_s *)(v16 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v16 + 100));
  v20 = *(_DWORD *)(v16 + 115);
  os_unfair_lock_unlock(v19);
  if (!v15)
    goto LABEL_17;
  v21 = (unint64_t *)&v15->__shared_owners_;
  do
    v22 = __ldaxr(v21);
  while (__stlxr(v22 - 1, v21));
  if (!v22)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    if ((v20 & 0x20) == 0)
      goto LABEL_18;
  }
  else
  {
LABEL_17:
    if ((v20 & 0x20) == 0)
    {
LABEL_18:
      v23 = 0;
      goto LABEL_23;
    }
  }
  v23 = TNode::IsPopulated((TNode *)a1) ^ 1;
LABEL_23:
  if (TNode::VirtualType((TNode *)a1) == 26)
    v24 = v23;
  else
    v24 = 0;
  if (v24 == 1)
  {
    NotifierList = TNode::GetNotifierList((TNode *)a1);
    v27 = *(_QWORD *)(NotifierList + 24);
    v26 = *(std::__shared_weak_count **)(NotifierList + 32);
    if (v26)
    {
      v28 = (unint64_t *)&v26->__shared_owners_;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    os_unfair_lock_lock((os_unfair_lock_t)v27);
    v30 = *(id *)(v27 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v27);
    if (v26)
    {
      v31 = (unint64_t *)&v26->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v23 = objc_msgSend(v30, "populated");
    if (v23)
    {
      LogObj(4);
      v33 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        Description(26, (TString *)v67);
        v34 = objc_retainAutorelease(*(id *)v67);
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v34;
        _os_log_impl(&dword_1CBC4A000, v33, OS_LOG_TYPE_INFO, "Deferred All Providers Node open sync is now complete: %{public}@", (uint8_t *)&buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v67);

      }
    }
    else
    {
      v35 = (unsigned __int16 *)(a1 + 80);
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 | 0x20, v35));
      if ((v36 & 0x20) != 0)
        goto LABEL_44;
      LogObj(4);
      v33 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        Description(26, (TString *)v67);
        v37 = objc_retainAutorelease(*(id *)v67);
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v37;
        _os_log_impl(&dword_1CBC4A000, v33, OS_LOG_TYPE_INFO, "Deferring All Providers Node open sync: %{public}@", (uint8_t *)&buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v67);

      }
    }

LABEL_44:
  }
  v38 = TNode::VirtualType((TNode *)a1);
  if (!v23)
  {
LABEL_84:
    StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v66);
    goto LABEL_85;
  }
  v39 = v38;
  v40 = ICloudDriveFPFSEnabled();
  if ((v39 - 23) < 2)
    v41 = v40;
  else
    v41 = 0;
  if (v41 == 1)
  {
    TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(a1 + 56));
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    if (!objc_msgSend(v42, "isPopulated"))
    {
      v58 = (unsigned __int16 *)(a1 + 80);
      do
        v59 = __ldaxr(v58);
      while (__stlxr(v59 | 0x20, v58));
      if ((v59 & 0x20) != 0)
        goto LABEL_83;
      LogObj(4);
      v60 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
      {
        Description(v39, (TString *)v67);
        TString::AsNSString((TString *)v67);
        v61 = (void *)objc_claimAutoreleasedReturnValue();
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v61;
        _os_log_impl(&dword_1CBC4A000, v60, OS_LOG_TYPE_INFO, "Deferring App Library Collection open sync: %{public}@", (uint8_t *)&buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v67);

      }
      goto LABEL_82;
    }
    LogObj(4);
    v43 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      Description(v39, (TString *)v67);
      TString::AsNSString((TString *)v67);
      v44 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v44;
      _os_log_impl(&dword_1CBC4A000, v43, OS_LOG_TYPE_INFO, "Deferred App Library Collection open sync is now complete: %{public}@", (uint8_t *)&buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v67);

    }
  }
  if (!TNode::IsFPv2((TNode *)a1, 1))
    goto LABEL_67;
  TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(a1 + 56));
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(v42, "isPopulated"))
  {
    v62 = (unsigned __int16 *)(a1 + 80);
    do
      v63 = __ldaxr(v62);
    while (__stlxr(v63 | 0x20, v62));
    if ((v63 & 0x20) != 0)
      goto LABEL_83;
    LogObj(4);
    v60 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
    {
      TNode::Name((TNode *)a1, (TString *)v67);
      SanitizedStr((TString *)v67);
      v64 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v64;
      _os_log_impl(&dword_1CBC4A000, v60, OS_LOG_TYPE_INFO, "Deferring FPv2 open sync: %{public}@", (uint8_t *)&buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v67);

    }
LABEL_82:

LABEL_83:
    goto LABEL_84;
  }
  LogObj(4);
  v45 = objc_claimAutoreleasedReturnValue();
  v46 = os_log_type_enabled(v45, OS_LOG_TYPE_INFO);
  if (v46)
  {
    v47 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v46);
    os_unfair_lock_lock(v47);
    v49 = *(TFSInfo **)(a1 + 16);
    v48 = *(std::__shared_weak_count **)(a1 + 24);
    *(_QWORD *)&buf = v49;
    *((_QWORD *)&buf + 1) = v48;
    if (v48)
    {
      v50 = (unint64_t *)&v48->__shared_owners_;
      do
        v51 = __ldxr(v50);
      while (__stxr(v51 + 1, v50));
    }
    os_unfair_lock_unlock(v47);
    TFSInfo::Name(v49, &v65);
    if (v48)
    {
      v52 = (unint64_t *)&v48->__shared_owners_;
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
    }
    SanitizedStr(&v65);
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v67 = 138543362;
    *(_QWORD *)&v67[4] = v54;
    _os_log_impl(&dword_1CBC4A000, v45, OS_LOG_TYPE_INFO, "Deferred FPv2 open sync is now complete: %{public}@", v67, 0xCu);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v65.fString.fRef);

  }
LABEL_67:
  v55 = (unsigned __int16 *)(a1 + 80);
  do
    v56 = __ldaxr(v55);
  while (__stlxr(v56 | 0x10, v55));
  if ((v56 & 0x10) != 0)
    goto LABEL_84;
  do
    v57 = __ldaxr(v55);
  while (__stlxr(v57 & 0xFFDF, v55));
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v66);
  TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
  TNode::SendNotification((const TNode *)a1, 8, (id *)&buf, 0, 0);

}

void sub_1CBC7C4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, const void *a14)
{
  void *v14;
  void *v15;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a14);

  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&a13);
  _Unwind_Resume(a1);
}

void StRegistrationLock::StRegistrationLock(StRegistrationLock *this)
{
  TDSMutex *RegistrationLock;

  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock((TDSNotifier *)this);
  TDSMutex::lock(RegistrationLock);
}

unint64_t TFSInfo::IsDatalessNow(TFSInfo *this)
{
  const __CFURL *v1;
  CFURLRef v2;
  const __CFString *v3;
  unint64_t v4;
  CFURLRef v6;

  v1 = (const __CFURL *)*((_QWORD *)this + 1);
  if (!v1)
    return 0;
  v2 = CFURLCreateFilePathURL(0, v1, 0);
  v6 = v2;
  if (v2)
    v4 = ((unint64_t)TCFURLInfo::GetNumericalProperty(v2, (const __CFString *)*MEMORY[0x1E0C9AC48], v3) >> 30) & 1;
  else
    v4 = 0;
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v6);
  return v4;
}

void sub_1CBC7C690(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TSystemNotificationTask::MakeSystemNotificationTask(TSystemNotificationTask *this)
{
  TBusyFolders *v1;
  uint64_t v2;

  std::mutex::lock(&gBusyFoldersLock);
  if (!TSystemNotificationTask::gBusyFolders)
  {
    v1 = (TBusyFolders *)operator new();
    TBusyFolders::TBusyFolders(v1);
    TSystemNotificationTask::gBusyFolders = (uint64_t)v1;
  }
  v2 = operator new();
  TBusyFolders::StartObserving((TBusyFolders *)TSystemNotificationTask::gBusyFolders);
  TSystemNotificationTask::gSystemNotificationTask = v2;
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1CBC7C728(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  v2 = v1;
  MEMORY[0x1D17A53D0](v2, 0x10A0C4035A50E9BLL);
  std::mutex::unlock(&gBusyFoldersLock);
  _Unwind_Resume(a1);
}

void TBusyFolders::TBusyFolders(TBusyFolders *this)
{
  TString v2;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  TString::TString(&v2, "/dev/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/mobile/tmp/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/db/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/tmp/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/mobile/Library/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/logs/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
}

void sub_1CBC7C8B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t TBusyFolders::AddPath(TBusyFolders *this, TString **a2, char a3)
{
  uint64_t result;
  TString **v7;

  result = CFStringGetLength((CFStringRef)*a2);
  if (result)
  {
    v7 = a2;
    result = (uint64_t)std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)this, (TString *)a2, (uint64_t)&std::piecewise_construct, &v7);
    *(_QWORD *)(result + 24) = 0;
    *(_DWORD *)(result + 32) = 0;
    *(_BYTE *)(result + 36) = a3;
  }
  return result;
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = FowlerNollVoHash::hash(this, this);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef))
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, (__CFString *)v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1CBC7CBD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

TString *std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  TString *v8;
  TString *result;

  v7 = a1 + 16;
  v8 = (TString *)operator new(0x28uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  v8->fString.fRef = 0;
  v8[1].fString.fRef = a2;
  result = std::pair<TString const,TBusyFolders::TSpecialFolderStream>::pair[abi:ne180100]<TString const&>(v8 + 2, *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBC7CC40(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

const void **TBusyFolders::StartObserving(TBusyFolders *this)
{
  NSObject *v2;
  __CFArray *v3;
  __CFArray *v5;
  _QWORD block[5];
  __CFArray *v7;

  v2 = (id)gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders14StartObservingEv_block_invoke;
  block[3] = &__block_descriptor_48_ea8_32c44_ZTSKZN12TBusyFolders14StartObservingEvE3__0_e5_v8__0l;
  v3 = TBusyFolders::CopyBusyFolders(this);
  v5 = v3;
  block[4] = this;
  v7 = v3;
  if (v3)
    CFRetain(v3);
  dispatch_async(v2, block);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&v5);

  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&v7);
}

void sub_1CBC7CD0C(_Unwind_Exception *a1)
{
  void *v1;
  const void **v2;

  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

void StRegistrationLock::~StRegistrationLock(TDSNotifier *this)
{
  TDSMutex *RegistrationLock;

  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock(this);
  TDSMutex::unlock(RegistrationLock);
}

uint64_t TDSNotifier::GetRegistrationLock(TDSNotifier *this)
{
  unsigned __int8 v1;
  TDSMutex *v3;

  if ((v1 & 1) == 0
  {
    v3 = (TDSMutex *)operator new();
    TDSMutex::TDSMutex(v3, 1);
    TDSNotifier::GetRegistrationLock(void)::gRegistrationLock = (uint64_t)v3;
  }
  return TDSNotifier::GetRegistrationLock(void)::gRegistrationLock;
}

void sub_1CBC7CDD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1000C40FA0F61DDLL);
  _Unwind_Resume(a1);
}

void TNotifierList::AddNotifier(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  uint64_t *v5;
  uint64_t v6;
  char *v7;

  v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v5 = *(uint64_t **)(a1 + 48);
  if ((unint64_t)v5 >= *(_QWORD *)(a1 + 56))
  {
    v7 = std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__push_back_slow_path<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>((char **)(a1 + 40), a2);
  }
  else
  {
    v6 = *a2;
    *v5 = *a2;
    if (v6)
      TRefCount::Retain<int>((unsigned int *)(v6 + 36));
    v7 = (char *)(v5 + 1);
    *(_QWORD *)(a1 + 48) = v5 + 1;
  }
  *(_QWORD *)(a1 + 48) = v7;
  os_unfair_lock_unlock(v4);
}

void sub_1CBC7CE7C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)(v2 + 48) = v3;
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

TChildrenList *TChildrenList::IncrementRegisteredChildrenCount(TChildrenList *this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)((char *)this + 192);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

void LogDSPath(void)
{
  int v0;
  NSObject *v1;
  NSObject *v2;
  const char *v3;
  NSObject *v4;
  os_log_type_t v5;
  uint32_t v6;
  Dl_info v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  const char *dli_fname;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v0 = dladdr("Release", &v7);
  LogObj(5);
  v1 = objc_claimAutoreleasedReturnValue();
  v2 = v1;
  if (v0)
  {
    if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v9 = "Release";
      v10 = 2082;
      dli_fname = v7.dli_fname;
      v3 = "%{public}s DS loaded at %{public}s";
      v4 = v2;
      v5 = OS_LOG_TYPE_INFO;
      v6 = 22;
LABEL_6:
      _os_log_impl(&dword_1CBC4A000, v4, v5, v3, buf, v6);
    }
  }
  else if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    v3 = "dladdr failed";
    v4 = v2;
    v5 = OS_LOG_TYPE_ERROR;
    v6 = 2;
    goto LABEL_6;
  }

}

void _NodeContextOpenExtended()
{
  const TString *v0;
  void *v1;
  uint8_t *v2;
  uint64_t v3;
  const void **v4;
  NSObject *v5;
  TString v6;
  TString v7;
  os_signpost_id_t v8;
  std::mutex v9;
  os_signpost_id_t SignpostID;
  _QWORD v11[5];
  uint8_t buf[8];
  os_signpost_id_t *v13;
  uint8_t *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  TString::TString(&v7, "DS Context");
  TString::TString(&v6, "Open Extended");
  StSignpostMacroHelper::GetOrCreateFinderLog(&v7, v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  ISignpostInterval::ISignpostInterval((uint64_t)&v9, v1);

  SignpostID = ISignpostInterval::MakeSignpostID((ISignpostInterval *)&v9, 0);
  v11[0] = &off_1E874EA50;
  v11[3] = v11;
  v11[4] = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  std::mutex::lock(&v9);
  v8 = SignpostID;
  *(_QWORD *)buf = &off_1E874EE70;
  v13 = &v8;
  v14 = buf;
  ISignpostInterval::BeginPriv((uint64_t)&v9, SignpostID, (uint64_t)buf);
  v2 = v14;
  if (v14 == buf)
  {
    v3 = 4;
    v2 = buf;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  std::mutex::unlock(&v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  v4 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  TSystemNotificationTask::gHandleFolderManager = 1;
  sOpenDSStoreOnEnumeration = 1;
  sManageSidebar = 1;
  TFSInfo::MarkAsUsed((TFSInfo *)v4);
  NodeContextOpen();
  if (UseFileProviderFramework())
  {
    LogObj(4);
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_DEFAULT, "FileProvider enabled", buf, 2u);
    }

  }
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&v9);
}

void sub_1CBC7D1D0(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, std::mutex *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&a13);
  _Unwind_Resume(a1);
}

os_log_t LogObj(int a1)
{
  const char *v1;

  if ((a1 - 1) > 7)
    v1 = "ArchiveService";
  else
    v1 = off_1E8751490[a1 - 1];
  return os_log_create("com.apple.DesktopServices", v1);
}

void TFSInfo::Validate(TFSInfo *this)
{
  os_unfair_lock_s *v1;

  v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  if (__PAIR128__(TFSInfo::gAirDropBrowserRef, TFSInfo::gNetworkNearbyBrowserRef) != 0)
    abort();
  os_unfair_lock_unlock(v1);
}

void sub_1CBC7D3F0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

int *TFSInfo::NetworkLock(TFSInfo *this)
{
  unsigned __int8 v1;

  {
    TFSInfo::NetworkLock(void)::gNetworkLock = 0;
  }
  return &TFSInfo::NetworkLock(void)::gNetworkLock;
}

void TNode::Initialize(TNode *this)
{
  TNode *v1;
  NSObject *v2;
  dispatch_queue_t v3;
  void *v4;
  FINode *v5;
  id v6;

  TGlobalNodes::RootNode((uint64_t *)&v6);

  TGlobalNodes::BootNode(&v5, v1);
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = dispatch_queue_create("FPItemFromMain", v2);
  v4 = (void *)sFPItemsFetchingFromMainQueue;
  sFPItemsFetchingFromMainQueue = (uint64_t)v3;

}

void TSystemNotificationTask::MakeNotificationQueue(TSystemNotificationTask *this)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("TSystemNotificationTask", 0);
  v2 = (void *)gSystemNotificationGCDQueue;
  gSystemNotificationGCDQueue = (uint64_t)v1;

}

void TSystemNotificationTask::MakeStreamQueue(TSystemNotificationTask *this)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("TSystemNotificationStreamTask", 0);
  v2 = (void *)gSystemNotificationStreamGCDQueue;
  gSystemNotificationStreamGCDQueue = (uint64_t)v1;

}

void TClientChangeNotifier::ValidateNotifierList(TDSNotifier *this)
{
  TDSMutex *RegistrationLock;
  char v2;

  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock(this);
  TDSMutex::lock(RegistrationLock);
  if (TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList != qword_1EF9B9C18)
    abort();
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v2);
}

void sub_1CBC7D570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&a13);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::SetFullEnvironment(TFSVolumeInfo *this)
{
  TFSVolumeInfo::gFullEnvironment = 1;
}

void TCFURLInfo::Initialize(TCFURLInfo *this)
{
  TCFURLInfo::gShowAllExtensions = 0;
  TCFURLInfo::gRootlessEnabled = 0;
  TCFURLInfo::gHasUnifiedVolumeGroup = 0;
  TCFURLInfo::gROSPState = 0;
}

__FSEventStream *CreateFSEventStreamForPath(TString *a1, void (__cdecl *a2)(ConstFSEventStreamRef, void *, size_t, void *, const FSEventStreamEventFlags *, const FSEventStreamEventId *), const __CFArray *a3)
{
  const __CFAllocator *v6;
  __FSEventStream *v7;
  const __CFString *v8;
  int v9;
  NSObject *v10;
  void *v11;
  TString v13;
  CFArrayRef pathsToWatch;
  _BYTE cf1[12];
  __int16 v16;
  __FSEventStream *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  pathsToWatch = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
  CFArraySetValueAtIndex(pathsToWatch, 0, a1);
  v7 = FSEventStreamCreate(v6, a2, 0, pathsToWatch, 0xFFFFFFFFFFFFFFFFLL, 0.5, 2u);
  TString::TString((TString *)cf1, "/", 1uLL);
  if (a1)
    v8 = (const __CFString *)a1;
  else
    v8 = &stru_1E8752DF8;
  v9 = CFEqual(*(CFTypeRef *)cf1, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)cf1);
  if (!v9)
  {
    LogObj(5);
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v13.fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(&v13, a1);
      SanitizedPath(&v13);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)cf1 = 138543618;
      *(_QWORD *)&cf1[4] = v11;
      v16 = 2048;
      v17 = v7;
      _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_DEFAULT, "Creating FSEvent Stream for %{public}@ = %p", cf1, 0x16u);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);

    }
  }
  if (a3)
    FSEventStreamSetExclusionPaths(v7, a3);
  FSEventStreamSetDispatchQueue(v7, (dispatch_queue_t)gSystemNotificationGCDQueue);
  FSEventStreamStart(v7);
  TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)&pathsToWatch);
  return v7;
}

void sub_1CBC7D778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  void *v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef(&a10);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void sub_1CBC7D91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, id a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v13 - 24));
  _Unwind_Resume(a1);
}

void TFSInfo::ChangesForFPDomain(void *a1, void *a2, uint64_t **a3)
{
  TFSInfo *v5;
  TFSInfo *v6;
  int v7;
  int v8;
  int v9;
  FPProviderDomain *v10;
  _BOOL4 IsDisconnectedDomain;
  FPProviderDomain *v12;
  void *v13;
  void *v14;
  char v15;
  TString *v16;
  BOOL v17;
  TString v18;

  v5 = a1;
  v6 = a2;
  v7 = -[TFSInfo isEnabled](v5, "isEnabled");
  if (v7 == -[TFSInfo isEnabled](v6, "isEnabled"))
  {
    v8 = -[TFSInfo isHidden](v5, "isHidden");
    if (v8 == -[TFSInfo isHidden](v6, "isHidden"))
    {
      v9 = -[TFSInfo needsAuthentication](v5, "needsAuthentication");
      if (v9 == -[TFSInfo needsAuthentication](v6, "needsAuthentication"))
      {
        IsDisconnectedDomain = TFSInfo::IsDisconnectedDomain(v5, v10);
        if (IsDisconnectedDomain != TFSInfo::IsDisconnectedDomain(v6, v12))
        {
          LODWORD(v18.fString.fRef) = 1987273324;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
          LODWORD(v18.fString.fRef) = 1886549619;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
          LODWORD(v18.fString.fRef) = 1853121395;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
        }
      }
      else
      {
        LODWORD(v18.fString.fRef) = 1987273324;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
        LODWORD(v18.fString.fRef) = 1718641013;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
      }
    }
    else
    {
      LODWORD(v18.fString.fRef) = 1987273324;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
    }
  }
  else
  {
    LODWORD(v18.fString.fRef) = 1987273324;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
    LODWORD(v18.fString.fRef) = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
  }
  -[TFSInfo identifier](v5, "identifier");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  -[TFSInfo identifier](v6, "identifier");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = objc_msgSend(v13, "isEqualToString:", v14);

  if ((v15 & 1) == 0)
  {
    LODWORD(v18.fString.fRef) = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
  }
  if (v5 != v6)
  {
    -[TFSInfo identifier](v6, "identifier");
    v16 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    v18.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v18, v16);

    v17 = IsLocalStorageDomainID(&v18);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);

    if (!v17)
    {
      LODWORD(v18.fString.fRef) = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
    }
  }

}

void sub_1CBC7DBD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN7TFSInfo14LSPropertyKeysEv_block_invoke()
{
  TFSInfo::LSPropertyKeys(void)::LSPropertyKeys = (uint64_t)CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E0C9B580]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E0C9B4D8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E0C9B508]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E0C9ABF8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E0C9ABD8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E0C9ABD0]);
}

void ___ZN13TFSVolumeInfo20GetDedicatedGCDQueueE17FSInfoVirtualType_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  dispatch_queue_t v2;
  void *v3;
  dispatch_queue_t v4;
  void *v5;
  dispatch_queue_t v6;
  void *v7;
  dispatch_queue_t v8;
  void *v9;

  v0 = dispatch_queue_create("NetworkNearbyQueue", 0);
  v1 = (void *)TFSVolumeInfo::gNetworkNearbyQueue;
  TFSVolumeInfo::gNetworkNearbyQueue = (uint64_t)v0;

  v2 = dispatch_queue_create("AirDropQueue", 0);
  v3 = (void *)TFSVolumeInfo::gAirDropQueue;
  TFSVolumeInfo::gAirDropQueue = (uint64_t)v2;

  v4 = dispatch_queue_create("TagsSharedListQueue", 0);
  v5 = (void *)TFSVolumeInfo::gTagsSharedListQueue;
  TFSVolumeInfo::gTagsSharedListQueue = (uint64_t)v4;

  v6 = dispatch_queue_create("Cloud Containers", 0);
  v7 = (void *)TFSVolumeInfo::gAllCloudLibsQueue;
  TFSVolumeInfo::gAllCloudLibsQueue = (uint64_t)v6;

  v8 = dispatch_queue_create("FPitems", 0);
  v9 = (void *)TFSVolumeInfo::gFPItemQueue;
  TFSVolumeInfo::gFPItemQueue = (uint64_t)v8;

}

uint64_t TNode::FollowAlias(uint64_t a1, uint64_t a2)
{
  uint64_t NodeFromFSInfo;
  FINode *v5;
  TNode *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  TNode *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  TNodePtr v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  FINode *v22;
  std::__shared_weak_count *v23;

  if ((a2 & 0x20000) != 0 && TNode::IsInTrash((TNode *)a1))
  {
    NodeFromFSInfo = 4294959232;
LABEL_29:
    TNode::ClearAliasTarget((TNode *)a1, 1);
    return NodeFromFSInfo;
  }
  if (TNode::ResolveFPProvider((TNode *)a1))
  {
    TNode::GetAliasTarget((TNode *)a1, &v22);
    v5 = v22;
    if (TNodeFromFINode(v22))
      NodeFromFSInfo = 0;
    else
      NodeFromFSInfo = 4294959232;

  }
  else
  {
    v6 = (TNode *)_ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v22);
    v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
    os_unfair_lock_lock(v7);
    v9 = *(_QWORD *)(a1 + 16);
    v8 = *(std::__shared_weak_count **)(a1 + 24);
    v20 = v9;
    v21 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v7);
    NodeFromFSInfo = TFSInfo::FollowAlias(v9, a2, (uint64_t *)&v22);
    v19.fFINode = 0;
    if (!(_DWORD)NodeFromFSInfo)
    {
      NodeFromFSInfo = TNode::GetNodeFromFSInfo((TFSInfo **)&v22, (void **)&v19.fFINode);
      if (!(_DWORD)NodeFromFSInfo)
      {
        if ((a2 & 0x20000) != 0 && (v12 = (TNode *)TNodeFromFINode(v19.fFINode), TNode::IsInTrash(v12)))
        {
          NodeFromFSInfo = 4294959232;
        }
        else
        {
          TNode::SetAliasTarget((TNode *)a1, &v19, 1);
          NodeFromFSInfo = 0;
        }
      }
    }

    if (v8)
    {
      v13 = (unint64_t *)&v8->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v15 = v23;
    if (v23)
    {
      v16 = (unint64_t *)&v23->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    if ((_DWORD)NodeFromFSInfo)
      goto LABEL_29;
  }
  return NodeFromFSInfo;
}

void sub_1CBC7DF5C(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void TNode::~TNode(TNode *this, const TNode *a2)
{
  uint64_t v3;
  char *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  void (*v8)(uint64_t, _QWORD);
  uint64_t v9;
  const TNodePtr *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  TNodePtr v15;

  v3 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v4 = (char *)this + 16;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  if (v3)
  {
    v8 = (void (*)(uint64_t, _QWORD))sReleaseCustomNodeCallback;
    if (sReleaseCustomNodeCallback && *((_QWORD *)this + 8))
    {
      v9 = TNode::AsNodeRef(this, a2);
      v8(v9, *((_QWORD *)this + 8));
    }
    TNodePtr::TNodePtr(&v15, 0);
    TNode::SetAliasTarget(this, &v15, 0);

    TNodePtr::TNodePtr(&v15, this);
    TProgressMap::RemoveSubscriberForExternalProgress(&v15, v10);

  }
  if (v5)
  {
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v13 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v13)
    std::default_delete<TNotifierList>::operator()[abi:ne180100]((uint64_t)this + 72, v13);
  std::unique_ptr<TChildrenList>::reset[abi:ne180100]((TChildrenList **)this + 7, 0);
  v14 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v14)
    MEMORY[0x1D17A53D0](v14, 0x1020C40A5B76CDFLL);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v4);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void TNode::SetAliasTarget(TNode *this, const TNodePtr *a2, int a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  FINode *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _BOOL4 IsAlias;
  _BOOL4 v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  TNode *v16;
  os_unfair_lock_s *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  TNodeEvent *v24;
  os_unfair_lock_s *v25;
  uint64_t v26;
  os_unfair_lock_s *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  TNode *v34;
  TNode *v35;
  os_unfair_lock_s *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  os_unfair_lock_s *v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  os_unfair_lock_s *v47;
  int v48;
  unint64_t *v49;
  unint64_t v50;
  os_unfair_lock_s *v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  TNode *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  os_unfair_lock_s *v59;
  std::__shared_weak_count *v60;
  uint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  uint64_t v64;
  int IsDeferredForSymlink;
  os_unfair_lock_s *v66;
  uint64_t v67;
  unsigned int v68;
  unint64_t v69;
  int v70;
  unint64_t v71;
  TNode *v72;
  unint64_t *v73;
  unint64_t v74;
  os_unfair_lock_s *v75;
  std::__shared_weak_count *v76;
  uint64_t v77;
  unint64_t *v78;
  unint64_t v79;
  int v80;
  unint64_t v81;
  TNodeEvent *v82;
  uint64_t v83;
  os_unfair_lock_s *v84;
  std::__shared_weak_count *v85;
  uint64_t v86;
  unint64_t *v87;
  unint64_t v88;
  int v89;
  unint64_t v90;
  FINode *v91;
  TNodePtr v92;
  std::__shared_weak_count *v93;

  v6 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v6);
  v8 = (FINode *)*((_QWORD *)this + 2);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v92.fFINode = v8;
  v93 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v6);
  IsAlias = TFSInfo::IsAlias((TFSInfo *)v8);
  v12 = IsAlias;
  if (!v7)
    goto LABEL_8;
  v13 = (unint64_t *)&v7->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v12)
      return;
  }
  else
  {
LABEL_8:
    if (!IsAlias)
      return;
  }
  TNode::GetAliasTarget(this, &v91);
  v15 = TNodeFromFINode(v91);
  if (v15 != TNodeFromFINode(a2->fFINode))
  {
    v16 = (TNode *)TNodeFromFINode(v91);
    if (v16)
    {
      v17 = (os_unfair_lock_s *)TNode::InfoLock(v16);
      os_unfair_lock_lock(v17);
      v19 = *((_QWORD *)this + 2);
      v18 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
      if (v18)
      {
        v20 = (unint64_t *)&v18->__shared_owners_;
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
        os_unfair_lock_unlock(v17);
        v22 = *(unsigned __int8 *)(v19 + 112);
        do
          v23 = __ldaxr(v20);
        while (__stlxr(v23 - 1, v20));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      else
      {
        os_unfair_lock_unlock(v17);
        v22 = *(unsigned __int8 *)(v19 + 112);
      }
      if (v22 != 7)
      {
        v24 = (TNodeEvent *)TNodeFromFINode(v91);
        TNodePtr::TNodePtr(&v92, this);
        TNode::UnRegisterForInternalNotifications(v24, &v92.fFINode, 1);

      }
      TNode::GetAliasTarget(this, &v92);
      TNodePtr::operator=((void **)&v91, (void **)&v92.fFINode);

    }
    v25 = (os_unfair_lock_s *)TNode::InfoLock(v16);
    os_unfair_lock_lock(v25);
    objc_storeStrong((id *)this + 4, a2->fFINode);
    os_unfair_lock_unlock(v25);
    if (TNodeFromFINode(v91))
    {
      v26 = TNodeFromFINode(v91);
      v27 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v26);
      os_unfair_lock_lock(v27);
      v29 = *(_QWORD *)(v26 + 16);
      v28 = *(std::__shared_weak_count **)(v26 + 24);
      if (v28)
      {
        v30 = (unint64_t *)&v28->__shared_owners_;
        do
          v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
        os_unfair_lock_unlock(v27);
        v32 = *(unsigned __int8 *)(v29 + 112);
        do
          v33 = __ldaxr(v30);
        while (__stlxr(v33 - 1, v30));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      else
      {
        os_unfair_lock_unlock(v27);
        v32 = *(unsigned __int8 *)(v29 + 112);
      }
      if (v32 == 16)
      {
        v34 = (TNode *)TNodeFromFINode(v91);
        TNode::RemoveSelf(v34, 0);
      }
    }
    v35 = (TNode *)TNodeFromFINode(a2->fFINode);
    if (v35)
    {
      v36 = (os_unfair_lock_s *)TNode::InfoLock(v35);
      os_unfair_lock_lock(v36);
      v38 = *((_QWORD *)this + 2);
      v37 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
      v92.fFINode = (FINode *)v38;
      v93 = v37;
      if (v37)
      {
        v39 = (unint64_t *)&v37->__shared_owners_;
        do
          v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
      }
      os_unfair_lock_unlock(v36);
      v41 = TNodeFromFINode(a2->fFINode);
      v42 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v41);
      os_unfair_lock_lock(v42);
      v44 = *(_QWORD *)(v41 + 16);
      v43 = *(std::__shared_weak_count **)(v41 + 24);
      if (v43)
      {
        v45 = (unint64_t *)&v43->__shared_owners_;
        do
          v46 = __ldxr(v45);
        while (__stxr(v46 + 1, v45));
      }
      os_unfair_lock_unlock(v42);
      v47 = (os_unfair_lock_s *)(v44 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v44 + 100));
      v48 = *(_DWORD *)(v44 + 115);
      os_unfair_lock_unlock(v47);
      if (v43)
      {
        v49 = (unint64_t *)&v43->__shared_owners_;
        do
          v50 = __ldaxr(v49);
        while (__stlxr(v50 - 1, v49));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }
      v51 = (os_unfair_lock_s *)(v38 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v38 + 100));
      v53 = *(_DWORD *)(v38 + 115);
      v52 = v38 + 115;
      v54 = v53 & 0xFFFDFFFF | ((unint64_t)*(unsigned __int16 *)(v52 + 4) << 32);
      *(_DWORD *)v52 = v53 & 0xFFFDFFFF | (v48 << 12) & 0x20000;
      *(_WORD *)(v52 + 4) = WORD2(v54);
      os_unfair_lock_unlock(v51);
      v56 = v93;
      if (v93)
      {
        v57 = (unint64_t *)&v93->__shared_owners_;
        do
          v58 = __ldaxr(v57);
        while (__stlxr(v58 - 1, v57));
        if (!v58)
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
      }
      v59 = (os_unfair_lock_s *)TNode::InfoLock(v55);
      os_unfair_lock_lock(v59);
      v61 = *((_QWORD *)this + 2);
      v60 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
      v92.fFINode = (FINode *)v61;
      v93 = v60;
      if (v60)
      {
        v62 = (unint64_t *)&v60->__shared_owners_;
        do
          v63 = __ldxr(v62);
        while (__stxr(v63 + 1, v62));
      }
      os_unfair_lock_unlock(v59);
      v64 = TNodeFromFINode(a2->fFINode);
      IsDeferredForSymlink = TNode::IsDeferredForSymlink(v64, (uint64_t (*)(_QWORD *))TFSInfo::IsPackage, 0);
      v66 = (os_unfair_lock_s *)(v61 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v61 + 100));
      v68 = *(_DWORD *)(v61 + 115);
      v67 = v61 + 115;
      v69 = v68 | ((unint64_t)*(unsigned __int16 *)(v67 + 4) << 32);
      v70 = 2;
      if (!IsDeferredForSymlink)
        v70 = 0;
      v71 = v69 & 0xFFFFFFFFFFFFFFFDLL;
      *(_DWORD *)v67 = v71 | v70;
      *(_WORD *)(v67 + 4) = WORD2(v71);
      os_unfair_lock_unlock(v66);
      if (v60)
      {
        v73 = (unint64_t *)&v60->__shared_owners_;
        do
          v74 = __ldaxr(v73);
        while (__stlxr(v74 - 1, v73));
        if (!v74)
        {
          ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
          std::__shared_weak_count::__release_weak(v60);
        }
      }
      v75 = (os_unfair_lock_s *)TNode::InfoLock(v72);
      os_unfair_lock_lock(v75);
      v77 = *((_QWORD *)this + 2);
      v76 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
      if (v76)
      {
        v78 = (unint64_t *)&v76->__shared_owners_;
        do
          v79 = __ldxr(v78);
        while (__stxr(v79 + 1, v78));
        os_unfair_lock_unlock(v75);
        v80 = *(unsigned __int8 *)(v77 + 112);
        do
          v81 = __ldaxr(v78);
        while (__stlxr(v81 - 1, v78));
        if (!v81)
        {
          ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
          std::__shared_weak_count::__release_weak(v76);
        }
      }
      else
      {
        os_unfair_lock_unlock(v75);
        v80 = *(unsigned __int8 *)(v77 + 112);
      }
      if (v80 != 7)
      {
        v82 = (TNodeEvent *)TNodeFromFINode(a2->fFINode);
        TNodePtr::TNodePtr(&v92, this);
        TNode::RegisterForInternalNotifications(v82, &v92.fFINode, 1);

      }
    }
    if (a3)
    {
      if (!TNodeFromFINode(a2->fFINode))
        goto LABEL_83;
      v83 = TNodeFromFINode(a2->fFINode);
      v84 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v83);
      os_unfair_lock_lock(v84);
      v86 = *(_QWORD *)(v83 + 16);
      v85 = *(std::__shared_weak_count **)(v83 + 24);
      if (v85)
      {
        v87 = (unint64_t *)&v85->__shared_owners_;
        do
          v88 = __ldxr(v87);
        while (__stxr(v88 + 1, v87));
        os_unfair_lock_unlock(v84);
        v89 = *(unsigned __int8 *)(v86 + 112);
        do
          v90 = __ldaxr(v87);
        while (__stlxr(v90 - 1, v87));
        if (!v90)
        {
          ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
          std::__shared_weak_count::__release_weak(v85);
        }
      }
      else
      {
        os_unfair_lock_unlock(v84);
        v89 = *(unsigned __int8 *)(v86 + 112);
      }
      if (v89 != 16)
      {
LABEL_83:
        TNodePtr::TNodePtr(&v92, this);
        TNode::SendNotification(this, 2, (id *)&v92.fFINode, 1634497639, 0);

      }
    }
  }

}

void sub_1CBC7E6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{

  _Unwind_Resume(a1);
}

uint64_t TNode::TestAndSetRegisteredForExternalProgress(TNode *this, char a2)
{
  unsigned __int16 *v2;
  unsigned int v3;

  v2 = (unsigned __int16 *)((char *)this + 80);
  if ((a2 & 1) != 0)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 | 0x200, v2));
  }
  else
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 & 0xFDFF, v2));
  }
  return (v3 >> 9) & 1;
}

uint64_t TFSInfo::FollowAlias(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  os_unfair_lock_s *v6;
  const void *v7;
  CFIndex v8;
  uint64_t v9;
  const void *v11;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v7 = *(const void **)(a1 + 16);
  v11 = v7;
  if (v7)
  {
    CFRetain(v7);
    os_unfair_lock_unlock(v6);
    if (*(_BYTE *)(a1 + 112) == 7)
      v8 = TFSInfo::initialize(*a3, (const __CFURL *)v7, 0, 1, 1, 1, 0);
    else
      v8 = TFSInfo::FollowAliasOrSymlinkDeep(a1, a2, a3, 0);
    v9 = v8;
  }
  else
  {
    os_unfair_lock_unlock(v6);
    v9 = 4294959232;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v11);
  return v9;
}

void sub_1CBC7E844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::FollowAliasOrSymlinkDeep(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  os_unfair_lock_s *v8;
  const void *v9;
  int v10;
  const __CFString *v11;
  const __CFString *v12;
  int BooleanProperty;
  CFIndex v14;
  const char *v16;
  CFIndex v17;
  const __CFURL *v18;
  unint64_t v19;
  const __CFString *v20;
  void *v21;
  const void *v22;
  CFTypeID v23;
  char v24;
  uint64_t v25;
  NSObject *v26;
  void *v27;
  void *v28;
  NSURL *v29;
  uint64_t v30;
  __CFError *v31;
  TString *v32;
  const TString *v33;
  uint64_t v34;
  os_unfair_lock_s *v35;
  int v36;
  unsigned int *v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  TString *v42;
  TFSInfo *v43;
  CFTypeRef *v44;
  int v45;
  const void *v46;
  char v47;
  uint64_t v48;
  _QWORD v49[5];
  char v50;
  CFURLRef anURL;
  CFStringRef theString;
  const void *v53;
  _BYTE buf[12];
  __int16 v55;
  void *v56;
  char __s[8];
  char *v58;
  uint64_t v59;
  uint64_t (*v60)(uint64_t, uint64_t);
  const void **(*v61)(uint64_t);
  const char *v62;
  const void *v63[124];

  v63[123] = *(const void **)MEMORY[0x1E0C80C00];
  v8 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v9 = *(const void **)(a1 + 16);
  v53 = v9;
  if (v9)
  {
    CFRetain(v9);
    os_unfair_lock_unlock(v8);
    if (TFSInfo::IsAlias((TFSInfo *)a1) && !*(_BYTE *)(a1 + 112))
    {
      os_unfair_lock_lock(v8);
      v10 = *(_DWORD *)(a1 + 115);
      os_unfair_lock_unlock(v8);
      if ((v10 & 0x40) == 0)
      {
        os_unfair_lock_lock(v8);
        v11 = *(const __CFString **)(a1 + 16);
        theString = v11;
        if (v11)
          CFRetain(v11);
        os_unfair_lock_unlock(v8);
        anURL = 0;
        if ((a2 & 2) != 0)
          BooleanProperty = TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)(a1 + 8), (const __CFString *)*MEMORY[0x1E0C9B6D8], v12);
        else
          BooleanProperty = 1;
        *(_QWORD *)__s = 0;
        v58 = __s;
        v59 = 0x3812000000;
        v60 = __Block_byref_object_copy_;
        v61 = __Block_byref_object_dispose_;
        v62 = "";
        v63[0] = 0;
        if (BooleanProperty)
        {
          os_unfair_lock_lock(v8);
          v19 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
          os_unfair_lock_unlock(v8);
          if ((v19 & 0x400000000) != 0
            || (TCFURLInfo::GetNumericalProperty(*(const __CFURL **)(a1 + 8), (const __CFString *)*MEMORY[0x1E0C9AC48], v20) & 0x40000000) != 0)
          {
            NewFileCoordinator();
            v21 = (void *)objc_claimAutoreleasedReturnValue();
            v49[0] = MEMORY[0x1E0C809B0];
            v49[1] = 3221225472;
            v49[2] = ___ZNK7TFSInfo24FollowAliasOrSymlinkDeepE18NodeRequestOptionsRNSt3__110shared_ptrIS_EEi_block_invoke;
            v49[3] = &unk_1E87526D8;
            v49[4] = __s;
            v50 = BooleanProperty;
            objc_msgSend(v21, "coordinateReadingItemAtURL:options:error:byAccessor:", theString, 1, 0, v49);

          }
          else
          {
            *(_QWORD *)buf = MEMORY[0x1D17A4D88](0, theString, 0);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)v58 + 6, *(CFTypeRef *)buf);
            TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)buf);
          }
        }
        if (!*((_QWORD *)v58 + 6))
          goto LABEL_56;
        if ((a2 & 2) != 0)
        {
          v22 = (const void *)MEMORY[0x1D17A4DD0](0, *MEMORY[0x1E0C9B6D8]);
          *(_QWORD *)buf = v22;
          if (v22 && (v23 = CFGetTypeID(v22), v23 == CFBooleanGetTypeID()))
          {
            v24 = IsEqual(*(const void **)buf, (const void *)*MEMORY[0x1E0C9AE40]);
            TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)buf);
            if ((v24 & 1) != 0)
              goto LABEL_56;
          }
          else
          {
            TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)buf);
          }
        }
        if ((a2 & 1) != 0)
          v30 = 0;
        else
          v30 = 768;
        *(_QWORD *)buf = 0;
        LOBYTE(v46) = 0;
        anURL = (CFURLRef)MEMORY[0x1D17A4D94](0, *((_QWORD *)v58 + 6), v30, theString, 0, &v46, buf);
        if (anURL)
          v14 = 0;
        else
          v14 = 4294959232;
        if (*(_QWORD *)buf)
        {
          v14 = TCFURLInfo::TranslateCFError(*(TCFURLInfo **)buf, v31);
          if ((_DWORD)v14 == 60)
          {
            TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)buf);
            if ((a2 & 1) != 0)
            {
              v14 = 4294967168;
LABEL_57:
              _Block_object_dispose(__s, 8);
              TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v63);
              TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&anURL);
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&theString);
              goto LABEL_11;
            }
            goto LABEL_56;
          }
        }
        if (!(_BYTE)v46 || (_DWORD)v14)
        {
          TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)buf);
          if ((_DWORD)v14 == -128)
            goto LABEL_57;
          if ((_DWORD)v14)
          {
LABEL_56:
            v14 = 4294959232;
            goto LABEL_57;
          }
        }
        else
        {
          v48 = MEMORY[0x1D17A4D7C](0, anURL, 1024, 0, theString, 0);
          MEMORY[0x1D17A4E60](v48, theString, 0, 0);
          TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&v48);
          TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)buf);
        }
        if (!anURL)
          goto LABEL_56;
        v32 = (TString *)CFURLCopyScheme(anURL);
        v48 = (uint64_t)v32;
        *(_QWORD *)buf = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable((TString *)buf, v32);
        LODWORD(v32) = TFSInfo::IsNetworkScheme((TFSInfo *)buf, v33);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
        if ((_DWORD)v32)
        {
          if ((a2 & 2) == 0)
          {
            v47 = 0;
            v46 = TFSInfo::SFNodeFromURL((uint64_t)anURL, 1, &v47);
            if (v46)
            {
              std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,__SFNode *&,void>(&v47, (uint64_t *)&v46, buf);
              std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a3, (__int128 *)buf);
              std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)buf);
            }
            goto LABEL_71;
          }
          goto LABEL_72;
        }
        v42 = (TString *)v48;
        *(_QWORD *)buf = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable((TString *)buf, v42);
        v44 = (CFTypeRef *)TFSInfo::FileScheme(v43);
        v45 = CFEqual(*(CFTypeRef *)buf, *v44);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
        if (!v45)
        {
          v14 = 4294967168;
          goto LABEL_74;
        }
        v14 = TFSInfo::initialize(*a3, anURL, 0, 1, 1, 1, 0);
        if (!(_DWORD)v14)
        {
          if ((a2 & 8) == 0 || !TFSInfo::IsAlias((TFSInfo *)*a3))
          {
LABEL_71:
            v14 = 0;
            goto LABEL_74;
          }
          if (a4 > 8)
          {
LABEL_72:
            v14 = 4294959232;
            goto LABEL_74;
          }
          v14 = TFSInfo::FollowAliasOrSymlinkDeep(a1, a2, a3, (a4 + 1));
        }
LABEL_74:
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v48);
        goto LABEL_57;
      }
      TFSInfo::Path((TFSInfo *)a1, (CFTypeRef *)&theString);
      if (CFStringGetLength(theString))
      {
        v16 = (const char *)TString::c_str((TString *)&theString);
        if (realpath_DARWIN_EXTSN(v16, __s))
        {
          v17 = strlen(__s);
          v18 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__s, v17, 1u);
          *(_QWORD *)buf = v18;
          if (v18)
            v14 = TFSInfo::initialize(*a3, v18, 0, 1, 1, 1, 0);
          else
            v14 = 4294959236;
          TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)buf);
        }
        else
        {
          v25 = *__error();
          LogObj(4);
          v26 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            SanitizedPath((TString *)&theString);
            v27 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB2FE0], v25, 0);
            v28 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v27;
            v55 = 2114;
            v56 = v28;
            _os_log_impl(&dword_1CBC4A000, v26, OS_LOG_TYPE_ERROR, "realpath error: %{public}@: %{public}@", buf, 0x16u);

          }
          if ((_DWORD)v25 != 11)
          {
            v14 = 4294959236;
            goto LABEL_63;
          }
          NodeEventRefFromNodeEvent((id *)&v53);
          v29 = (NSURL *)objc_claimAutoreleasedReturnValue();
          MyFPResolveSymlink(v29, (uint64_t)buf);

          v14 = *(unsigned int *)&buf[8];
          if (!*(_DWORD *)&buf[8])
            v14 = TFSInfo::initialize(*a3, *(const __CFURL **)buf, 0, 1, 1, 1, 0);

        }
        if (!(_DWORD)v14)
        {
          v34 = *a3;
          v35 = (os_unfair_lock_s *)(*a3 + 100);
          os_unfair_lock_lock(v35);
          LODWORD(v34) = *(_DWORD *)(v34 + 115);
          os_unfair_lock_unlock(v35);
          os_unfair_lock_lock(v8);
          v36 = ((_DWORD)v34 << 12) & 0x20000;
LABEL_64:
          v38 = *(_DWORD *)(a1 + 115);
          v37 = (unsigned int *)(a1 + 115);
          v39 = v38 & 0xFFFDFFFF | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32);
          *v37 = v38 & 0xFFFDFFFF | v36;
          *((_WORD *)v37 + 2) = WORD2(v39);
          os_unfair_lock_unlock(v8);
          os_unfair_lock_lock(v8);
          v40 = *v37;
          v41 = (v40 | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32)) & 0xFFFFFFFDFFFFFFFFLL;
          *v37 = v40;
          *((_WORD *)v37 + 2) = WORD2(v41);
          os_unfair_lock_unlock(v8);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
          goto LABEL_11;
        }
      }
      else
      {
        v14 = 4294959238;
      }
LABEL_63:
      os_unfair_lock_lock(v8);
      v36 = 0;
      goto LABEL_64;
    }
  }
  else
  {
    os_unfair_lock_unlock(v8);
  }
  v14 = 4294959238;
LABEL_11:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v53);
  return v14;
}

void sub_1CBC7EFA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, const void *a20,const void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  const void **v27;

  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&a12);
  _Block_object_dispose(&a27, 8);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v27);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a19);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a20);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a21);
  _Unwind_Resume(a1);
}

unint64_t TNode::ResolveFPProvider(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  TFSInfo *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  os_unfair_lock_s *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  int v24;
  os_unfair_lock_s *v25;
  int v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  TNodePtr v31;
  TNodePtr v32;
  TString v33;
  TFSInfo *v34;
  std::__shared_weak_count *v35;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = (TFSInfo *)*((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v34 = v4;
  v35 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock((os_unfair_lock_t)v4 + 25);
  v7 = *(unsigned int *)((char *)v4 + 115) | ((unint64_t)*(unsigned __int16 *)((char *)v4 + 119) << 32);
  os_unfair_lock_unlock((os_unfair_lock_t)v4 + 25);
  if ((v7 & 0x8000000000) != 0)
  {
    if (!TNodeFromFINode(*((FINode **)this + 4)))
    {
LABEL_16:
      TFSInfo::ObjectIdentifier(v4, &v33);
      TNode::FPItemNodeFromObjectID((TNode *)&v33, &v32);
      TNode::SetAliasTarget(this, &v32, 1);
      if (TNodeFromFINode(*((FINode **)this + 4)))
      {
        v16 = TNodeFromFINode(*((FINode **)this + 4));
        v17 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v16);
        os_unfair_lock_lock(v17);
        v19 = *(_QWORD *)(v16 + 16);
        v18 = *(std::__shared_weak_count **)(v16 + 24);
        if (v18)
        {
          v20 = (unint64_t *)&v18->__shared_owners_;
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
          os_unfair_lock_unlock(v17);
          v22 = *(unsigned __int8 *)(v19 + 112);
          do
            v23 = __ldaxr(v20);
          while (__stlxr(v23 - 1, v20));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
        else
        {
          os_unfair_lock_unlock(v17);
          v22 = *(unsigned __int8 *)(v19 + 112);
        }
        v24 = v22 != 16;
        v4 = v34;
      }
      else
      {
        v24 = 0;
      }
      v25 = (os_unfair_lock_s *)((char *)v4 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)v4 + 25);
      v26 = *(_DWORD *)((char *)v4 + 115) & 1;
      os_unfair_lock_unlock(v25);
      if (v24 != v26)
      {
        TFSInfo::SetIsInvisible(v34, v24 ^ 1);
        TNodePtr::TNodePtr(&v31, this);
        TNode::SendNotification(this, 2, (id *)&v31.fFINode, 1987273324, 0);

      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v33.fString.fRef);
      goto LABEL_30;
    }
    v8 = TNodeFromFINode(*((FINode **)this + 4));
    v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    v11 = *(_QWORD *)(v8 + 16);
    v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10)
    {
      v12 = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
      os_unfair_lock_unlock(v9);
      v14 = *(unsigned __int8 *)(v11 + 112);
      do
        v15 = __ldaxr(v12);
      while (__stlxr(v15 - 1, v12));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    else
    {
      os_unfair_lock_unlock(v9);
      v14 = *(unsigned __int8 *)(v11 + 112);
    }
    if (v14 == 16)
    {
      v4 = v34;
      goto LABEL_16;
    }
  }
LABEL_30:
  v27 = v35;
  if (v35)
  {
    v28 = (unint64_t *)&v35->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  return (v7 >> 39) & 1;
}

void sub_1CBC7F3A8(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, ...)
{
  const void *v5;
  va_list va;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, const void *);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void TNode::RegisterForInternalNotifications(TNodeEvent *a1, FINode **a2, uint64_t a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  TNodePtr v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  TNodeEvent::GetInternalClientNotifier(a1, &v10);
  if (v10)
  {
    TNodePtr::TNodePtr(&v9, (const TNode *)a1);
    TDSNotifier::Register((TDSNotifier *)&v10, &v9.fFINode, a2, a3);

  }
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1CBC7F49C(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_list va;

  va_start(va, a3);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::GetNodeFromFSInfo(TFSInfo **a1, void **a2)
{
  TFSInfo *v4;
  uint64_t NodeFromURL;
  FINode *v6;
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  os_unfair_lock_s *v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  TNode *v21;
  TNode *v22;
  std::__shared_weak_count *v23;
  FINode *fFINode;
  FINode *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  os_unfair_lock_s *v32;
  uint64_t v33;
  os_unfair_lock_s *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  os_unfair_lock_s *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  TFSInfo *v44;
  os_unfair_lock_s *v45;
  FINode *v46;
  FINode *v48;
  std::__shared_weak_count *v49;
  TNodePtr v50;
  std::__shared_weak_count *v51;
  TNodePtr v52;

  TNodePtr::TNodePtr(&v50, 0);
  TNodePtr::operator=(a2, (void **)&v50.fFINode);

  v4 = *a1;
  if (*((_BYTE *)*a1 + 112))
  {
    if (*((_BYTE *)*a1 + 112) == 23)
    {
      TGlobalNodes::iCloudLibrariesContainerNode(&v50);
      TNodePtr::operator=(a2, (void **)&v50.fFINode);

      return 0;
    }
    else
    {
      return 4294959238;
    }
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)v4 + 25);
    v6 = (FINode *)*((_QWORD *)v4 + 2);
    v48 = v6;
    if (v6)
      CFRetain(v6);
    os_unfair_lock_unlock((os_unfair_lock_t)v4 + 25);
    v50.fFINode = v48;
    NodeFromURL = TNode::GetNodeFromURL(&v50, a2, 0);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v48);
    if (TNodeFromFINode((FINode *)*a2) && (TFSInfo::IsLocalVolume(*a1, v7, v8) & 1) == 0)
    {
      v9 = TNodeFromFINode((FINode *)*a2);
      v10 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v9);
      os_unfair_lock_lock(v10);
      TNodePtr::TNodePtr(&v52, *(const TNode **)(v9 + 48));
      os_unfair_lock_unlock(v10);
      while (TNodeFromFINode(v52.fFINode))
      {
        v11 = TNodeFromFINode(v52.fFINode);
        v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
        os_unfair_lock_lock(v12);
        v14 = *(_QWORD *)(v11 + 16);
        v13 = *(std::__shared_weak_count **)(v11 + 24);
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v16 = __ldxr(p_shared_owners);
          while (__stxr(v16 + 1, p_shared_owners));
        }
        os_unfair_lock_unlock(v12);
        v17 = (os_unfair_lock_s *)(v14 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
        v18 = *(_DWORD *)(v14 + 115);
        os_unfair_lock_unlock(v17);
        if (v13)
        {
          v19 = (unint64_t *)&v13->__shared_owners_;
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        if ((v18 & 0x100) != 0)
          break;
        v21 = (TNode *)TNodeFromFINode(v52.fFINode);
        TNode::GetVolumeInfo(v21, &v50);
        v22 = (TNode *)TNodeFromFINode((FINode *)*a2);
        TNode::GetVolumeInfo(v22, &v48);
        v23 = v49;
        fFINode = v50.fFINode;
        v25 = v48;
        if (v49)
        {
          v26 = (unint64_t *)&v49->__shared_owners_;
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
        v28 = v51;
        if (v51)
        {
          v29 = (unint64_t *)&v51->__shared_owners_;
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        if (fFINode != v25)
          break;
        v31 = TNodeFromFINode(v52.fFINode);
        v32 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v31);
        os_unfair_lock_lock(v32);
        TNodePtr::TNodePtr(&v50, *(const TNode **)(v31 + 48));
        os_unfair_lock_unlock(v32);
        TNodePtr::operator=((void **)&v52.fFINode, (void **)&v50.fFINode);

      }
      if (TNodeFromFINode(v52.fFINode))
      {
        v33 = TNodeFromFINode(v52.fFINode);
        v34 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v33);
        os_unfair_lock_lock(v34);
        v36 = *(_QWORD *)(v33 + 16);
        v35 = *(std::__shared_weak_count **)(v33 + 24);
        if (v35)
        {
          v37 = (unint64_t *)&v35->__shared_owners_;
          do
            v38 = __ldxr(v37);
          while (__stxr(v38 + 1, v37));
        }
        os_unfair_lock_unlock(v34);
        v39 = (os_unfair_lock_s *)(v36 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v36 + 100));
        v40 = *(_DWORD *)(v36 + 115);
        os_unfair_lock_unlock(v39);
        if (v35)
        {
          v41 = (unint64_t *)&v35->__shared_owners_;
          do
            v42 = __ldaxr(v41);
          while (__stlxr(v42 - 1, v41));
          if (!v42)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        if ((v40 & 0x100) == 0)
        {
          v43 = TNodeFromFINode(v52.fFINode);
          TNode::HandleSync(v43, 0x80000u);
          v44 = *a1;
          v45 = (os_unfair_lock_s *)((char *)*a1 + 100);
          os_unfair_lock_lock(v45);
          v46 = (FINode *)*((_QWORD *)v44 + 2);
          v48 = v46;
          if (v46)
            CFRetain(v46);
          os_unfair_lock_unlock(v45);
          v50.fFINode = v46;
          NodeFromURL = TNode::GetNodeFromURL(&v50, a2, 0);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v48);
        }
      }

    }
    if (!(_DWORD)NodeFromURL)
    {
      if (TNodeFromFINode((FINode *)*a2))
        return 0;
      else
        return 4294959238;
    }
  }
  return NodeFromURL;
}

void sub_1CBC7F88C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void *a14)
{
  os_unfair_lock_s *v14;

  os_unfair_lock_unlock(v14);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsLocalVolume(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B6D8], a3);
}

void TNodeEvent::GetInternalClientNotifier(TNodeEvent *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN10TNodeEvent25GetInternalClientNotifierEv_block_invoke;
  block[3] = &__block_descriptor_33_ea8_32c53_ZTSKZN10TNodeEvent25GetInternalClientNotifierEvE3__0_e5_v8__0l;
  if (TNodeEvent::GetInternalClientNotifier(void)::internalClientChangeNotifierOnce != -1)
    dispatch_once(&TNodeEvent::GetInternalClientNotifier(void)::internalClientChangeNotifierOnce, block);
  v3 = *(_QWORD *)algn_1EDB96918;
  *a2 = TNodeEvent::gInternalClientChangeNotifier;
  a2[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
}

void ___ZN12TGlobalNodes8BootNodeEv_block_invoke(uint64_t a1)
{
  int v2;
  void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  const void *v18;
  std::__shared_weak_count *v19;
  TNodePtr v20;
  void *v21;
  void *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;

  v23 = 0;
  v24 = 0;
  TCFURLInfo::BootURL(&v18);
  v2 = TFSVolumeInfo::AddVolume(v18, 0, &v23);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v18);
  v3 = 0;
  v22 = 0;
  if (!v2)
  {
    TNodePtr::TNodePtr(&v20, 0);
    v4 = *(std::__shared_weak_count **)(v23 + 64);
    v18 = *(const void **)(v23 + 56);
    v19 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v16 = 0;
    v17 = 0;
    TNode::CreateNode(&v21, &v20, &v18, &v16);
    TNodePtr::operator=(&v22, &v21);

    v7 = v17;
    if (v17)
    {
      v8 = (unint64_t *)&v17->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = v19;
    if (v19)
    {
      v11 = (unint64_t *)&v19->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    **(_BYTE **)(a1 + 40) = 1;
    v3 = v22;
  }
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 8), v3);

  v13 = v24;
  if (v24)
  {
    v14 = (unint64_t *)&v24->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1CBC7FB54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  std::__shared_weak_count **v2;
  uint64_t v3;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  va_list va;
  std::__shared_weak_count *v10;
  uint64_t v11;
  va_list va1;
  uint64_t v13;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, std::__shared_weak_count *);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  if (v10)
    TOperationSizer::ComputeSizeWithTimeout(v10);
  ___ZN12TGlobalNodes8BootNodeEv_block_invoke_cold_1((uint64_t)va, v2, (uint64_t)va1, (id *)va2);
  v5 = *(std::__shared_weak_count **)(v3 - 24);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  _Unwind_Resume(a1);
}

void ___ZN7TFSInfo25IterationInfoPropertyKeysEv_block_invoke()
{
  TFSInfo::IterationInfoPropertyKeys(void)::basicKeys = (uint64_t)CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B5A0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9ADD0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AC50]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AC58]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AC40]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AC60]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AC88]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B4A8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B420]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B408]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B400]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B3B8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B3C0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B568]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B570]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B4C8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B550]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B4F8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B548]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B538]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9ACA8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B530]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B4E0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B520]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B4D0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B518]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B558]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B4F0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AD38]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9ACC8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9ACC0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9AC48]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E0C9B6D8]);
}

void ___ZN5TNode31SetShouldSyncUbiquityAttributesEb_block_invoke(uint64_t a1)
{
  int v1;
  uint64_t v2;
  TChildrenList *v3;

  v1 = *(unsigned __int8 *)(a1 + 40);
  v2 = TNodeFromFINode(*(FINode **)(a1 + 32));
  if (v1)
  {
    TNode::RegisterForUbiquityAttributes((TNode *)v2);
  }
  else
  {
    v3 = *(TChildrenList **)(v2 + 56);
    if (v3)
      TChildrenList::ClearCollectionStatusObserver(v3);
  }
}

void ___ZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEE_block_invoke(uint64_t a1)
{
  void *v2;
  FINode ***v3;
  uint64_t v4;
  uint64_t v5[3];
  void **v6;

  v2 = *(void **)(a1 + 32);
  v3 = (FINode ***)(a1 + 40);
  if (v2)
  {
    objc_msgSend(v2, "updateNodesFPItemsFromCollection:", v3);
  }
  else
  {
    v4 = 0x4024000000000000;
    TNode::UpdateFPItemsIfNeeded(v3, (double *)&v4, 1, 1, 1, v5);
    v6 = (void **)v5;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
}

void ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_2(uint64_t a1)
{
  TDSNotifier::HandleDeferredTickle(*(TDSNotifier **)(a1 + 32));
}

void ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke(uint64_t a1)
{
  _QWORD v2[5];

  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_2;
  v2[3] = &__block_descriptor_40_e5_v8__0l;
  v2[4] = *(_QWORD *)(a1 + 40);
  ExceptionSafeBlock(v2);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
}

BOOL ___ZN13TFSVolumeInfo9LoadPrefsEv_block_invoke()
{
  _BOOL8 result;

  TFSVolumeInfo::gNoNetworkPropertyStores = PrefsBool(CFSTR("DSDontWriteNetworkStores"), 0);
  TFSVolumeInfo::gCanUseReadDir = PrefsBool(CFSTR("UseBareEnumeration"), 1);
  TFSVolumeInfo::gTimeIterations = PrefsBool(CFSTR("RecordIterationTimes"), 0);
  result = PrefsBool(CFSTR("SkipLSProperties"), 1);
  TFSVolumeInfo::gSkipLSProperties = result;
  return result;
}

void sub_1CBC800F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(uint64_t a1, _QWORD *a2, id *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2[1];
  v7 = a1 + 16;
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>>(a1 + 16, (uint64_t)a3, (uint64_t)a3, *(_QWORD *)a1, *(_QWORD *)a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*>(v7, a3, *(id **)(a1 + 8), (_QWORD *)a2[2]);
  v9 = *(_QWORD *)a1;
  *(_QWORD *)a1 = a2[1];
  a2[1] = v9;
  v10 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[2];
  a2[2] = v10;
  v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

void std::vector<TNodePtr>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  void *v5;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = (void *)*((_QWORD *)v3 - 1);
        v3 -= 8;

      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::deque<TNodeEventPtr>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1CBC80554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<TNodePtr>>::__on_zero_shared(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 24);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void std::__shared_ptr_emplace<TFolderSizingThread>::__on_zero_shared(uint64_t a1)
{

}

void std::__shared_ptr_emplace<TVolumeSyncThread>::__on_zero_shared(uint64_t a1)
{

}

void std::__shared_ptr_emplace<TFSVolumeInfo>::__on_zero_shared(uint64_t a1)
{
  TFSVolumeInfo::~TFSVolumeInfo((TFSVolumeInfo *)(a1 + 24));
}

uint64_t std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::__construct_at_end_with_size<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(_QWORD *result, id *a2, uint64_t a3)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v6;

  v3 = result;
  v4 = (_QWORD *)result[2];
  if (a3)
  {
    v6 = &v4[2 * a3];
    do
    {
      *v4 = *a2;
      result = a2[1];
      v4[1] = result;
      v4 += 2;
      a2 += 2;
    }
    while (v4 != v6);
    v4 = v6;
  }
  v3[2] = v4;
  return result;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

uint64_t std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  id *v3;
  void *__p;
  char v6;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6)

    operator delete(v3);
  }
  return v2;
}

uint64_t **std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>(_QWORD *a1, id *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **v11;
  uint64_t v12;
  unint64_t v13;

  v4 = objc_msgSend(*a2, "hash");
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = (unint64_t)v11[1];
      if (v13 == v6)
      {
        if ((std::equal_to<FINode * {__strong}>::operator()(v12, v11[2], *a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t *std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::__erase_unique<FINode * {__strong}>(_QWORD *a1, id *a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>(a1, a2);
  if (result)
  {
    std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&v5);
  v3 = v5;
  v5 = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

uint64_t **std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::find<TNodePtr>(_QWORD *a1, FINode **a2)
{
  int8x8_t v2;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t ***v8;
  uint64_t **i;
  unint64_t v10;
  uint64_t v11;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v4 = (unint64_t)*a2 >> 2;
  v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    v7 = (unint64_t)*a2 >> 2;
    if (v4 >= *(_QWORD *)&v2)
      v7 = v4 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v4;
  }
  v8 = *(uint64_t ****)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  for (i = *v8; i; i = (uint64_t **)*i)
  {
    v10 = (unint64_t)i[1];
    if (v10 == v4)
    {
      v11 = TNodeFromFINode((FINode *)i[2]);
      if (v11 == TNodeFromFINode(*a2))
        return i;
    }
    else
    {
      if (v6 > 1)
      {
        if (v10 >= *(_QWORD *)&v2)
          v10 %= *(_QWORD *)&v2;
      }
      else
      {
        v10 &= *(_QWORD *)&v2 - 1;
      }
      if (v10 != v7)
        return 0;
    }
  }
  return i;
}

char *std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(uint64_t a1, FINode **a2, uint64_t a3, id **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v7 = (unint64_t)*a2 >> 2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v4 = (unint64_t)*a2 >> 2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          v14 = *((_QWORD *)v13 + 1);
          if (v14 == v7)
          {
            v15 = TNodeFromFINode(*((FINode **)v13 + 2));
            if (v15 == TNodeFromFINode(*a2))
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v8)
                v14 %= v8;
            }
            else
            {
              v14 &= v8 - 1;
            }
            if (v14 != v4)
              break;
          }
          v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  v13 = (char *)operator new(0x60uLL);
  *(_QWORD *)v13 = 0;
  *((_QWORD *)v13 + 1) = v7;
  *((_QWORD *)v13 + 2) = **a4;
  *((_DWORD *)v13 + 6) = 0;
  *((_QWORD *)v13 + 4) = 850045863;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *((_QWORD *)v13 + 11) = 0;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    v19 = 1;
    if (v8 >= 3)
      v19 = (v8 & (v8 - 1)) != 0;
    v20 = v19 | (2 * v8);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v13 = *v24;
LABEL_38:
    *v24 = v13;
    goto LABEL_39;
  }
  *(_QWORD *)v13 = *v16;
  *v16 = v13;
  *(_QWORD *)(v23 + 8 * v4) = v16;
  if (*(_QWORD *)v13)
  {
    v25 = *(_QWORD *)(*(_QWORD *)v13 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v25 >= v8)
        v25 %= v8;
    }
    else
    {
      v25 &= v8 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v13;
}

void sub_1CBC80D14(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__erase_unique<TNodePtr>(_QWORD *a1, FINode **a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::find<TNodePtr>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

TDSNotifier *std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__construct_node_hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, TDSNotifier **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  TDSNotifier *result;

  v7 = a1 + 16;
  v8 = operator new(0x18uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = *a3;
  v8[2] = *a3;
  if (result)
    result = (TDSNotifier *)TDSNotifier::AddPtrReference(result);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBC80DC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 40));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__do_rehash<true>(a1, prime);
  }
}

TDSNotifier *std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, TDSNotifier **a2)
{
  TDSNotifier *result;

  result = *a2;
  if (*a2)
    return (TDSNotifier *)TDSNotifier::RemovePtrReference(result);
  return result;
}

void std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::destroy(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;

}

uint64_t std::equal_to<FINode * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;

  v4 = a2;
  v5 = a3;
  if (v4 == v5)
    v6 = 1;
  else
    v6 = objc_msgSend(v4, "isEqual:", v5);

  return v6;
}

void sub_1CBC80F38(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  *a2 = &unk_1E874FEC8;
  result = MEMORY[0x1D17A5A30](*(_QWORD *)(a1 + 8));
  a2[1] = result;
  return result;
}

TDSNotifier **TNodeTask::GetClientChangeNotifier@<X0>(TNodeTask *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  __int128 v10;
  TDSNotifier *v11;

  *a2 = 0;
  a2[1] = 0;
  TNodeTask::GetNotifier(this, &v11);
  if (v11)
  {
    v3 = *((_QWORD *)v11 + 1);
    *(_QWORD *)&v10 = *(_QWORD *)v11;
    *((_QWORD *)&v10 + 1) = v3;
    if (v3)
    {
      v4 = (unint64_t *)(v3 + 8);
      do
        v5 = __ldxr(v4);
      while (__stxr(v5 + 1, v4));
    }
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v10);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
    if (*((_QWORD *)&v10 + 1))
    {
      v7 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v11);
}

void sub_1CBC81028(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t TNodeTask::GetNotificationOptions(TNodeTask *this)
{
  TPropertyValue *v1;
  uint64_t v2;
  TDSNotifier *v4[2];

  v1 = (TPropertyValue *)((char *)this + 24);
  if (TPropertyValue::DataType((TPropertyValue *)this + 1) != 1919247971
    || TPropertyValue::ReferenceCountedType(v1) != 1852798054)
  {
    return 0;
  }
  TPropertyValue::As<TDSNotifier *>(v1, (uint64_t)v4);
  v2 = *((unsigned int *)v4[0] + 8);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v4);
  return v2;
}

TDSNotifier **TNodeTask::GetNotifier@<X0>(TNodeTask *this@<X0>, TDSNotifier **a2@<X8>)
{
  TPropertyValue *v3;
  TDSNotifier **result;
  TDSNotifier *v5[2];

  *a2 = 0;
  v3 = (TPropertyValue *)((char *)this + 24);
  result = (TDSNotifier **)TPropertyValue::DataType((TPropertyValue *)this + 1);
  if ((_DWORD)result == 1919247971)
  {
    result = (TDSNotifier **)TPropertyValue::ReferenceCountedType(v3);
    if ((_DWORD)result == 1852798054)
    {
      TPropertyValue::As<TDSNotifier *>(v3, (uint64_t)v5);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(a2, v5);
      return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v5);
    }
  }
  return result;
}

void sub_1CBC81134(_Unwind_Exception *a1)
{
  TDSNotifier **v1;

  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v1);
  _Unwind_Resume(a1);
}

TString *TString::operator+@<X0>(const __CFString **a1@<X0>, const __CFString *a2@<X1>, TString *a3@<X8>)
{
  const __CFString *v5;
  CFMutableStringRef MutableCopy;

  v5 = *a1;
  a3->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v5);
  if (a3->fString.fRef)
    CFRelease(a3->fString.fRef);
  a3->fString.fRef = MutableCopy;
  return TString::Append(a3, a2);
}

void sub_1CBC811C0(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

__CFString *TString::AsNSString(TString *this)
{
  return this->fString.fRef;
}

uint64_t TFSInfo::SetHasLSProperties(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v6 = *(_DWORD *)((char *)this + 115);
  v5 = (char *)this + 115;
  v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  v8 = (v7 >> 30) & 1;
  v9 = 0x40000000;
  if (!a2)
    v9 = 0;
  v10 = v7 & 0xFFFFFFFFBFFFFFFFLL;
  *(_DWORD *)v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

BOOL TFSInfo::LowLevelIsLockFile(TFSInfo *this)
{
  if (*((_BYTE *)this + 112))
    return 0;
  if (*((_DWORD *)this + 26) == 1651666795)
    return 1;
  return TFSInfo::GetCreationDate(this) == -534528000.0;
}

uint64_t TFSInfo::GetFlatItemCount(TFSInfo *a1, uint64_t a2, const __CFString *a3, unsigned int a4)
{
  unint64_t FlatItemCount;

  FlatItemCount = TFSInfo::GetFlatItemCount(a1, (a4 >> 2) & 1, a3);
  return TPropertyReference::SetAs<long long>(a2, &FlatItemCount);
}

uint64_t TFSInfo::IsIndexSorted(TFSInfo *this)
{
  return (*((unsigned __int8 *)this + 112) < 0x24uLL) & (0xF803E0000uLL >> *((_BYTE *)this + 112));
}

unint64_t TFSInfo::IsDataless(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  return ((unint64_t)TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AC48], a3) >> 30) & 1;
}

id TNode::GetFPItem(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  TFSInfo *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;
  unint64_t *v8;
  unint64_t v9;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = (TFSInfo *)*((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::GetFPItem(v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3)
  {
    v8 = (unint64_t *)&v3->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v7;
}

void sub_1CBC813E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const void **TNode::GetPath@<X0>(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  TGlobalNodes *v6;
  TNode *v7;
  FINode *v9;
  TString v10;
  _QWORD v11[6];
  int FullPOSIXPathDetails;
  TString v13;

  v13.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  FullPOSIXPathDetails = TNode::GetFullPOSIXPathDetails(a1, &v13);
  if (!FullPOSIXPathDetails && (a2 & 1) == 0)
  {
    v6 = TPathName::TPathName((TPathName *)v11, &v13, TPathName::kPOSIXPathNameSeparator);
    TGlobalNodes::BootNode((uint64_t *)&v9, v6);
    v7 = (TNode *)TNodeFromFINode(v9);
    TNode::DisplayName(v7, &v10);
    FullPOSIXPathDetails = TPathName::AsOldStyleFullPath((TPathName *)v11, &v10, &v13);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);

    std::deque<TString>::~deque[abi:ne180100](v11);
  }
  fstd::optional_err<TString,int>::optional_err(a3, (TString **)&v13, &FullPOSIXPathDetails);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
}

void sub_1CBC814D0(_Unwind_Exception *a1, void *a2, ...)
{
  uint64_t v2;
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v2 - 40));
  _Unwind_Resume(a1);
}

void TNode::CFURL(TNode *this@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  const void *v9;
  unint64_t *v10;
  unint64_t v11;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  v9 = *(const void **)(v6 + 16);
  *a2 = v9;
  if (v9)
    CFRetain(v9);
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 100));
  if (v5)
  {
    v10 = (unint64_t *)&v5->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBC815E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  os_unfair_lock_s *v9;

  os_unfair_lock_unlock(v9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t TNode::IsInitialPopulationDeferred(TNode *this)
{
  char v1;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  os_unfair_lock_s *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v1 = atomic_load((unsigned __int16 *)this + 40);
  if ((v1 & 0x20) == 0)
    return 0;
  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v9 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  v10 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
  os_unfair_lock_unlock(v9);
  if (v5)
  {
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return (v10 >> 5) & 1;
}

uint64_t TNode::GetFullPOSIXPathDetails(uint64_t a1, TString *a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  os_unfair_lock_s *v9;
  void *v10;
  id v11;
  TString *v12;
  CFIndex Length;
  unint64_t *v14;
  unint64_t v15;
  const void *v17[3];

  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  v17[1] = (const void *)v6;
  v17[2] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v9 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  v10 = *(void **)(v6 + 16);
  v17[0] = v10;
  if (v10)
    CFRetain(v10);
  os_unfair_lock_unlock(v9);
  v11 = v10;
  objc_msgSend(v11, "path");
  v12 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  if ((TString *)a2->fString.fRef != v12)
    TString::SetStringRefAsImmutable(a2, v12);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v17);
  Length = CFStringGetLength(a2->fString.fRef);
  if (v5)
  {
    v14 = (unint64_t *)&v5->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (Length)
    return 0;
  else
    return 4294967253;
}

void sub_1CBC817DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  const void *v5;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, const void *);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

unint64_t TNode::UserCanWriteDataFork(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v3)
  {
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return (v8 >> 13) & 1;
}

void TNode::RequestInternalTask(const TNode *a1, int a2, TPropertyValue *a3, int a4)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  TNodePtr v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v12.fFINode = 0;
  std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,decltype(nullptr),void>(&v13);
  v8 = v13;
  TNodePtr::TNodePtr(&v12, a1);
  TNodeTask::SetRequest(v8, (id *)&v12.fFINode, a2, 0, a3, a4);

  TNode::PostNodeTaskRequest(a1, &v13);
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_1CBC8199C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL TNode::NeedsChildReconcile(TNode *this)
{
  uint64_t v2;
  int v3;
  unsigned int v5;
  int v6;

  v6 = 2048;
  TNode::GetPermissions((uint64_t)this, &v6);
  if (!v6)
    return 0;
  v2 = *((_QWORD *)this + 7);
  v3 = atomic_load((unsigned int *)TNode::GetNotifierList(this));
  if (v3 > 0)
    return 1;
  if (!v2)
    return 0;
  v5 = atomic_load((unsigned int *)(v2 + 192));
  return v5 != 0;
}

BOOL TNode::LowLevelIsLockFile(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TNode *v6;
  unint64_t v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  TNode *v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  TFSInfo *v16;
  unint64_t *v17;
  unint64_t v18;
  _BOOL8 IsLockFile;
  BOOL v20;
  unint64_t *v21;
  unint64_t v22;
  _BOOL8 v23;
  os_unfair_lock_s *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  os_unfair_lock_s *v29;
  int v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  TFSInfo *v37;
  std::__shared_weak_count *v38;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  v8 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    os_unfair_lock_unlock(v8);
    do
      v13 = __ldaxr(v10);
    while (__stlxr(v13 - 1, v10));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  else
  {
    os_unfair_lock_unlock(v8);
  }
  v14 = (os_unfair_lock_s *)TNode::InfoLock(v12);
  os_unfair_lock_lock(v14);
  v16 = (TFSInfo *)*((_QWORD *)this + 2);
  v15 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v37 = v16;
  v38 = v15;
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v14);
  IsLockFile = TFSInfo::LowLevelIsLockFile(v16);
  v20 = IsLockFile;
  if (!v15)
    goto LABEL_24;
  v21 = (unint64_t *)&v15->__shared_owners_;
  do
    v22 = __ldaxr(v21);
  while (__stlxr(v22 - 1, v21));
  if (!v22)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    if (v20)
      return 1;
  }
  else
  {
LABEL_24:
    if (IsLockFile)
      return 1;
  }
  v24 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLockFile);
  os_unfair_lock_lock(v24);
  v26 = *((_QWORD *)this + 2);
  v25 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v25)
  {
    v27 = (unint64_t *)&v25->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  os_unfair_lock_unlock(v24);
  v29 = (os_unfair_lock_s *)(v26 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v26 + 100));
  v30 = *(_DWORD *)(v26 + 115);
  os_unfair_lock_unlock(v29);
  if (!v25)
    goto LABEL_34;
  v31 = (unint64_t *)&v25->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    if ((v30 & 0x100) == 0)
      return 0;
  }
  else
  {
LABEL_34:
    if ((v30 & 0x100) == 0)
      return 0;
  }
  TNode::GetVolumeInfo(this, &v37);
  if (*((_BYTE *)v37 + 123))
    v23 = 1;
  else
    v23 = *((unsigned __int8 *)v37 + 128) != 0;
  v33 = v38;
  if (v38)
  {
    v34 = (unint64_t *)&v38->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  return v23;
}

void sub_1CBC81CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id TNode::FPItemsCollection(TNode *this, FPItem *a2)
{
  FPItem *v3;
  int v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  char v10;
  TNode *v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  TFSInfo *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  os_unfair_lock_s *v20;
  const void **v21;
  os_unfair_lock_s *v22;
  uint64_t v23;
  os_unfair_lock_s *v24;
  std::__shared_weak_count *v25;
  TFSInfo *v26;
  unint64_t *v27;
  unint64_t v28;
  void *v29;
  unint64_t *v30;
  unint64_t v31;
  void *v32;
  void *v33;
  int v34;
  const __CFURL *v35;
  void *v36;
  void *v37;
  void *v38;
  NSObject *v39;
  NSURL *v40;
  void *v41;
  void *v42;
  NSObject *v43;
  TNodePtr v45;
  _BYTE buf[18];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = TNode::VirtualType(this);
  if (v4 == 27)
  {
    TNode::GetFIProvider(this);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "domain");
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      FPItemManagerInstance();
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "rootCollectionForProviderDomain:", v6);
      v8 = (void *)objc_claimAutoreleasedReturnValue();

    }
    else
    {
      v8 = 0;
    }

    goto LABEL_35;
  }
  FPItemManagerInstance();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = objc_opt_respondsToSelector();

  if ((v10 & 1) == 0)
    goto LABEL_34;
  v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
  os_unfair_lock_lock(v12);
  v14 = (TFSInfo *)*((_QWORD *)this + 2);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  *(_QWORD *)buf = v14;
  *(_QWORD *)&buf[8] = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v12);
  TFSInfo::Name(v14, (TString *)&v45);
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v19 = operator==((void **)&v45.fFINode, CFSTR(".Trash"));
  if ((v19 & 1) == 0)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v45.fFINode);
    goto LABEL_34;
  }
  v20 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v19);
  os_unfair_lock_lock(v20);
  TNodePtr::TNodePtr((TNodePtr *)buf, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v20);
  LOBYTE(v20) = TNodeFromFINode(*(FINode **)buf) == 0;

  v21 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v45.fFINode);
  if ((v20 & 1) != 0)
  {
LABEL_34:
    v8 = 0;
    goto LABEL_35;
  }
  v22 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v21);
  os_unfair_lock_lock(v22);
  TNodePtr::TNodePtr(&v45, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v22);
  v23 = TNodeFromFINode(v45.fFINode);
  v24 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v23);
  os_unfair_lock_lock(v24);
  v26 = *(TFSInfo **)(v23 + 16);
  v25 = *(std::__shared_weak_count **)(v23 + 24);
  *(_QWORD *)buf = v26;
  *(_QWORD *)&buf[8] = v25;
  if (v25)
  {
    v27 = (unint64_t *)&v25->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  os_unfair_lock_unlock(v24);
  TFSInfo::GetFPItem(v26);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (v25)
  {
    v30 = (unint64_t *)&v25->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  if (v29
    && (objc_msgSend(v29, "itemIdentifier"),
        v32 = (void *)objc_claimAutoreleasedReturnValue(),
        NS_FileProviderRootContainerItemIdentifier(),
        v33 = (void *)objc_claimAutoreleasedReturnValue(),
        v34 = objc_msgSend(v32, "isEqualToString:", v33),
        v33,
        v32,
        v34))
  {
    objc_msgSend(v29, "fileURL");
    v35 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
    FIProviderDomainForURL(v35);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v36, "domain");
    v37 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v37
      || (FPItemManagerInstance(),
          v38 = (void *)objc_claimAutoreleasedReturnValue(),
          objc_msgSend(v38, "trashCollectionForProviderDomain:", v37),
          v8 = (void *)objc_claimAutoreleasedReturnValue(),
          v38,
          !v8))
    {
      LogObj(4);
      v39 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        objc_msgSend(v29, "fileURL");
        v40 = (NSURL *)objc_claimAutoreleasedReturnValue();
        SanitizedURL(v40);
        v41 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v41;
        _os_log_impl(&dword_1CBC4A000, v39, OS_LOG_TYPE_DEFAULT, "Could not create trash collection for %{public}@", buf, 0xCu);

      }
      v8 = 0;
    }

  }
  else
  {
    v8 = 0;
  }

LABEL_35:
  if (v3 && !v8)
  {
    FPItemManagerInstance();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v42, "collectionForFolderItem:", v3);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

  }
  objc_msgSend(v8, "setShowHiddenFiles:", 1);
  if (!v8)
  {
    LogObj(4);
    v43 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      *(_WORD *)&buf[8] = 2114;
      *(_QWORD *)&buf[10] = v3;
      _os_log_impl(&dword_1CBC4A000, v43, OS_LOG_TYPE_DEFAULT, "Could not create collection for %d (%{public}@)", buf, 0x12u);
    }

  }
  return v8;
}

void sub_1CBC82114(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

unint64_t TNode::AliasIsContainer(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  TNode *v9;
  unint64_t *v10;
  unint64_t v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  os_unfair_lock_s *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  void *v21;
  NSObject *v22;
  id v23;
  os_unfair_lock_s *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  os_unfair_lock_s *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  _QWORD block[4];
  id v35;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_8;
  v10 = (unint64_t *)&v3->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v8 & 0x40) == 0)
      goto LABEL_20;
  }
  else
  {
LABEL_8:
    if ((v8 & 0x40) == 0)
      goto LABEL_20;
  }
  v12 = (os_unfair_lock_s *)TNode::InfoLock(v9);
  os_unfair_lock_lock(v12);
  v14 = *((_QWORD *)this + 2);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v12);
  v17 = (os_unfair_lock_s *)(v14 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
  v18 = *(unsigned int *)(v14 + 115) | ((unint64_t)*(unsigned __int16 *)(v14 + 119) << 32);
  os_unfair_lock_unlock(v17);
  if (!v13)
    goto LABEL_18;
  v19 = (unint64_t *)&v13->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (v20)
  {
LABEL_18:
    if ((v18 & 0x200000000) == 0)
      goto LABEL_20;
    goto LABEL_19;
  }
  ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
  std::__shared_weak_count::__release_weak(v13);
  if ((v18 & 0x200000000) != 0)
  {
LABEL_19:
    FINodeFromTNode(this);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    dispatch_get_global_queue(0, 0);
    v22 = objc_claimAutoreleasedReturnValue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZNK5TNode16AliasIsContainerEv_block_invoke;
    block[3] = &unk_1E8751520;
    v35 = v21;
    v23 = v21;
    dispatch_async(v22, block);

  }
LABEL_20:
  v24 = (os_unfair_lock_s *)TNode::InfoLock(v9);
  os_unfair_lock_lock(v24);
  v26 = *((_QWORD *)this + 2);
  v25 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v25)
  {
    v27 = (unint64_t *)&v25->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  os_unfair_lock_unlock(v24);
  v29 = (os_unfair_lock_s *)(v26 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v26 + 100));
  v30 = *(unsigned int *)(v26 + 115) | ((unint64_t)*(unsigned __int16 *)(v26 + 119) << 32);
  os_unfair_lock_unlock(v29);
  if (v25)
  {
    v31 = (unint64_t *)&v25->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  return (v30 >> 17) & 1;
}

uint64_t TNode::NewNodeIterator(uint64_t a1, TNodeIterator **a2, _QWORD *a3, unsigned int a4)
{
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  os_unfair_lock_s *v13;
  int v14;
  const TNode *v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  NSURL *v19;
  void *v20;
  TNode *v22;
  TNode *v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  uint64_t v32;
  os_unfair_lock_s *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  int v38;
  unint64_t v39;
  TGlobalNodes *v40;
  TNodePtr v41;
  TNode *v42;
  TNode *v43;
  TNodeIterator *v44;
  id v45;
  void *v46;
  _BYTE buf[24];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v8);
  v10 = *(_QWORD *)(a1 + 16);
  v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v8);
  v13 = (os_unfair_lock_s *)(v10 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
  v14 = *(_DWORD *)(v10 + 115);
  os_unfair_lock_unlock(v13);
  if (!v9)
    goto LABEL_8;
  v16 = (unint64_t *)&v9->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((v14 & 0x20) == 0)
      goto LABEL_9;
  }
  else
  {
LABEL_8:
    if ((v14 & 0x20) == 0)
    {
LABEL_9:
      if (!TNode::Validate((TNode *)a1, v15))
      {
        LogObj(5);
        v18 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          TNode::CFURL((TNode *)a1, &v46);
          v19 = v46;
          SanitizedURL(v19);
          v20 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v20;
          _os_log_impl(&dword_1CBC4A000, v18, OS_LOG_TYPE_ERROR, "Failed to get node iterator for node that doesn't support container %@", buf, 0xCu);

          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v46);
        }

      }
      return 4294959224;
    }
  }
  TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)a1);
  v22 = (TNode *)TNodeFromFINode(*(FINode **)buf);
  if (!TNode::LowLevelIsLockFile(v22))
  {
    v23 = (TNode *)TNodeFromFINode(*(FINode **)buf);
    if ((TNode::IsPopulated(v23) & 1) == 0)
    {
      v24 = TNodeFromFINode(*(FINode **)buf);
      v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
      os_unfair_lock_lock(v25);
      v27 = *(_QWORD *)(v24 + 16);
      v26 = *(std::__shared_weak_count **)(v24 + 24);
      if (v26)
      {
        v28 = (unint64_t *)&v26->__shared_owners_;
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
        os_unfair_lock_unlock(v25);
        v30 = *(unsigned __int8 *)(v27 + 112);
        do
          v31 = __ldaxr(v28);
        while (__stlxr(v31 - 1, v28));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      else
      {
        os_unfair_lock_unlock(v25);
        v30 = *(unsigned __int8 *)(v27 + 112);
      }
      if (v30 != 5)
      {
        v32 = TNodeFromFINode(*(FINode **)buf);
        v33 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v32);
        os_unfair_lock_lock(v33);
        v35 = *(_QWORD *)(v32 + 16);
        v34 = *(std::__shared_weak_count **)(v32 + 24);
        if (v34)
        {
          v36 = (unint64_t *)&v34->__shared_owners_;
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
          os_unfair_lock_unlock(v33);
          v38 = *(unsigned __int8 *)(v35 + 112);
          do
            v39 = __ldaxr(v36);
          while (__stlxr(v39 - 1, v36));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
        else
        {
          os_unfair_lock_unlock(v33);
          v38 = *(unsigned __int8 *)(v35 + 112);
        }
        if (v38 != 6)
        {
          if (*a3)
          {
            v40 = (TGlobalNodes *)TNodeFromFINode(*(FINode **)buf);
            TNode::RequestSynchronize(v40, a4 | 0x1000000);
          }
          else
          {
            v45 = *(id *)buf;
            v41.fFINode = (FINode *)&v45;
            StFirstPopulationLock::StFirstPopulationLock((StFirstPopulationLock *)&v46, v41);

            v42 = (TNode *)TNodeFromFINode(*(FINode **)buf);
            if ((TNode::IsPopulated(v42) & 1) == 0)
            {
              v43 = (TNode *)TNodeFromFINode(*(FINode **)buf);
              TNode::HandlePopulate(v43, 0, HIBYTE(a4) & 1);
            }
            StFirstPopulationLock::~StFirstPopulationLock((StFirstPopulationLock *)&v46);
          }
        }
      }
    }
  }
  TNode::VirtualType((TNode *)a1);
  v44 = (TNodeIterator *)operator new();
  TNodeIterator::TNodeIterator(v44, (const TNodePtr *)buf, (a4 >> 2) & 1);
  *a2 = v44;

  return 0;
}

void sub_1CBC82848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11)
{

  _Unwind_Resume(a1);
}

TNode *TNode::UnmarkChildren(TNode *this)
{
  uint64_t v1;
  FINode **v2;
  FINode **v3;
  unsigned __int16 *v4;
  unsigned __int16 v5;

  v1 = *((_QWORD *)this + 7);
  if (v1)
  {
    v2 = *(FINode ***)(v1 + 64);
    v3 = *(FINode ***)(v1 + 72);
    while (v2 != v3)
    {
      this = (TNode *)TNodeFromFINode(*v2);
      v4 = (unsigned __int16 *)((char *)this + 80);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 & 0xFEFF, v4));
      ++v2;
    }
  }
  return this;
}

void TNode::HandlePopulate(TNode *this, int a2, int a3)
{
  unint64_t IsInitialPopulationDeferred;
  TNode *v7;
  int v8;
  unsigned int v9;
  FINode *v10;

  IsInitialPopulationDeferred = TNode::IsInitialPopulationDeferred(this);
  if ((IsInitialPopulationDeferred & 1) == 0)
  {
    TGlobalNodes::RootNode((uint64_t *)&v10, (TGlobalNodes *)IsInitialPopulationDeferred);
    v7 = (TNode *)TNodeFromFINode(v10);

    if (v7 != this)
    {
      if (a2)
        v8 = 83886080;
      else
        v8 = 0x1000000;
      if (a3)
        v9 = v8 | 0x40000000;
      else
        v9 = v8;
      TNode::HandleSync((uint64_t)this, v9);
    }
  }
}

void sub_1CBC8299C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t TNode::UserCanBrowse(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  TNode *v7;
  int v8;
  unint64_t v9;
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  os_unfair_lock_s *v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v20;
  unint64_t v21;
  os_unfair_lock_s *v22;
  int v23;
  TNode *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  os_unfair_lock_s *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  os_unfair_lock_s *v33;
  int v34;
  TNode *v35;
  os_unfair_lock_s *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    v8 = *(unsigned __int8 *)(v4 + 112);
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
    v8 = *(unsigned __int8 *)(v4 + 112);
  }
  v10 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v10);
  v12 = *((_QWORD *)this + 2);
  v11 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (!v8)
  {
    if (v11)
    {
      v20 = (unint64_t *)&v11->__shared_owners_;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    os_unfair_lock_unlock(v10);
    v22 = (os_unfair_lock_s *)(v12 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
    v23 = *(_DWORD *)(v12 + 115);
    os_unfair_lock_unlock(v22);
    if (!v11)
      goto LABEL_26;
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if ((v23 & 0x20) == 0)
        return 0;
    }
    else
    {
LABEL_26:
      if ((v23 & 0x20) == 0)
        return 0;
    }
    v28 = (os_unfair_lock_s *)TNode::InfoLock(v24);
    os_unfair_lock_lock(v28);
    v30 = *((_QWORD *)this + 2);
    v29 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v45 = v29;
    if (v29)
    {
      v31 = (unint64_t *)&v29->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    os_unfair_lock_unlock(v28);
    v33 = (os_unfair_lock_s *)(v30 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v30 + 100));
    v34 = *(_DWORD *)(v30 + 115);
    os_unfair_lock_unlock(v33);
    if ((v34 & 0x1000) != 0)
    {
      v36 = (os_unfair_lock_s *)TNode::InfoLock(v35);
      os_unfair_lock_lock(v36);
      v38 = *((_QWORD *)this + 2);
      v37 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
      if (v37)
      {
        v39 = (unint64_t *)&v37->__shared_owners_;
        do
          v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
      }
      os_unfair_lock_unlock(v36);
      os_unfair_lock_lock((os_unfair_lock_t)(v38 + 100));
      v27 = ((unint64_t)*(unsigned int *)(v38 + 115) >> 14) & 1;
      os_unfair_lock_unlock((os_unfair_lock_t)(v38 + 100));
      if (v37)
      {
        v41 = (unint64_t *)&v37->__shared_owners_;
        do
          v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      v29 = v45;
      if (!v45)
        return v27;
    }
    else
    {
      v27 = 0;
      if (!v29)
        return v27;
    }
    v43 = (unint64_t *)&v29->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    return v27;
  }
  if (v11)
  {
    v13 = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  os_unfair_lock_unlock(v10);
  v15 = (os_unfair_lock_s *)(v12 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
  v16 = *(_DWORD *)(v12 + 115);
  os_unfair_lock_unlock(v15);
  if (!v11)
    goto LABEL_17;
  v17 = (unint64_t *)&v11->__shared_owners_;
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if ((v16 & 0x20) == 0)
      return TNode::AliasIsContainer(this);
  }
  else
  {
LABEL_17:
    if ((v16 & 0x20) == 0)
      return TNode::AliasIsContainer(this);
  }
  return 1;
}

void sub_1CBC82CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TNode::CopyChildren(TNode *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  void ***v5;
  TNodePtr v6;
  FINode *v7[3];

  TNodePtr::TNodePtr(&v6, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v7, &v6, 0);

  v4 = *((_QWORD *)this + 7);
  if (v4)
    v5 = (void ***)(v4 + 64);
  else
    v5 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)a2, *v5, v5[1], v5[1] - *v5);
  TNode::StPopulating::~StPopulating(v7);
}

void sub_1CBC82D48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::DataType(TPropertyValue *this)
{
  unsigned int v1;

  v1 = LOBYTE(this->fData.__impl_.__index) - 1;
  if (v1 > 0x16)
    return 1853189228;
  else
    return *(unsigned int *)&aLoobynitrohsgn[4 * (char)v1];
}

TDSNotifier **TPropertyValue::As<TDSNotifier *>@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  TDSNotifier *v5;

  if (a1 && a1[4] == 19)
  {
    v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
    if (v3)
      TDSNotifier::AddPtrReference(*(TDSNotifier **)(*(_QWORD *)a1 + 8));
    *(_QWORD *)a2 = v3;
    v5 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    v5 = 0;
    *(_DWORD *)(a2 + 8) = -8050;
  }
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v5);
}

TPropertyValue *TPropertyValue::ReferenceCountedType(TPropertyValue *this)
{
  if (this)
  {
    if (this->fData.__impl_.__index == 19)
      return (TPropertyValue *)*(unsigned int *)this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
    else
      return 0;
  }
  return this;
}

id TFSVolumeInfo::GetSynchingGCDQueue(TFSVolumeInfo *this)
{
  return NodeEventRefFromNodeEvent(*((id **)this + 40));
}

BOOL TFSVolumeInfo::ShouldUseReadDir(TFSVolumeInfo *this)
{
  uint64_t v2;
  _BOOL8 result;
  int v4;

  if (TFSVolumeInfo::LoadPrefs(void)::once != -1)
    dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_15);
  if (!TFSVolumeInfo::gCanUseReadDir)
    return 0;
  v2 = *((_QWORD *)this + 7);
  if (!v2 || *(_BYTE *)(v2 + 112))
    return 0;
  result = 0;
  v4 = *((_DWORD *)this + 18);
  if (v4 && v4 != 5)
  {
    if (!*((_BYTE *)this + 127))
    {
      if (!*((_BYTE *)this + 107))
      {
        if (TFSVolumeInfo::gNoNetworkPropertyStores)
          return 1;
        v4 = *((_DWORD *)this + 18);
      }
      return (v4 - 1) < 3;
    }
    return 0;
  }
  return result;
}

id TChildrenList::GetCollectionStatusObserver(TChildrenList *this)
{
  os_unfair_lock_s *v2;
  id v3;

  v2 = (os_unfair_lock_s *)TChildrenList::InternalLock(this);
  os_unfair_lock_lock(v2);
  v3 = *((id *)this + 13);
  os_unfair_lock_unlock(v2);
  return v3;
}

const void **TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TFSInfo::IterationInfoPropertyKeys(TFSInfo *this)
{
  if (TFSInfo::IterationInfoPropertyKeys(void)::once != -1)
    dispatch_once(&TFSInfo::IterationInfoPropertyKeys(void)::once, &__block_literal_global_23);
  return TFSInfo::IterationInfoPropertyKeys(void)::basicKeys;
}

void TFSInfo::CopyFPItemIfNeeded(uint64_t a1, TFSInfo **a2)
{
  void *v4;
  uint64_t Inode;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  TString *v9;
  _BOOL4 v10;
  TString *v11;
  BOOL v12;
  NSObject *v13;
  uint64_t v14;
  _BYTE v15[12];
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (UseFileProviderFramework())
  {
    TFSInfo::GetFPItem(*a2);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v4)
    {
LABEL_5:

      return;
    }
    Inode = TFSInfo::GetInode((TFSInfo *)a1);
    if (*(_BYTE *)(a1 + 112))
    {
LABEL_4:
      TFSInfo::SetFPItem((TFSInfo *)a1, (FPItem *)v4);
      goto LABEL_5;
    }
    v6 = Inode;
    TFSInfo::GetFPItem(*a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = objc_msgSend(v7, "fileID");
    if (v8)
    {

      if (v8 == v6)
        goto LABEL_4;
    }
    else
    {
      objc_msgSend(v7, "providerDomainID");
      v9 = (TString *)(id)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)v15 = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)v15, v9);

      v10 = IsLocalStorageDomainID((const TString *)v15);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v15);
      if (v10)
      {

        goto LABEL_4;
      }
      v11 = v9;
      *(_QWORD *)v15 = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)v15, v11);

      v12 = IsExternalDeviceDomainID((const TString *)v15);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v15);

      if (v12)
        goto LABEL_4;
    }
    LogObj(4);
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = objc_msgSend(v4, "fileID");
      *(_DWORD *)v15 = 134218240;
      *(_QWORD *)&v15[4] = v14;
      v16 = 2048;
      v17 = v6;
      _os_log_impl(&dword_1CBC4A000, v13, OS_LOG_TYPE_INFO, "FPItem fileID (%llu) and current inode(%llu) differ, will refetch item.", v15, 0x16u);
    }

    goto LABEL_5;
  }
}

void sub_1CBC831F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TNode::SetShouldSyncUbiquityAttributes(TNode *this, int a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int8 v15;
  NSObject *v16;
  FINode *v17;
  _QWORD block[4];
  FINode *v19;
  char v20;
  TNodePtr v21;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = *((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    os_unfair_lock_unlock(v4);
    v9 = *(unsigned __int8 *)(v6 + 112);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (v10)
    {
      if (v9)
        return;
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if (v9)
        return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    if (*(_BYTE *)(v6 + 112))
      return;
  }
  v11 = (unsigned __int16 *)((char *)this + 80);
  v12 = atomic_load((unsigned __int16 *)this + 40);
  if (a2 != (unsigned __int16)(v12 & 0x400) >> 10)
  {
    if ((a2 & 1) != 0)
    {
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 | 0x400, v11));
    }
    else
    {
      do
        v14 = __ldaxr(v11);
      while (__stlxr(v14 & 0xFBFF, v11));
    }
    if ((v15 & 1) == 0)
    {
      {
        TNode::SetShouldSyncUbiquityAttributes(BOOL)::sBladeRunnerRegistration = (uint64_t)dispatch_queue_create("iCloudRegistration", 0);
      }
    }
    TNodePtr::TNodePtr(&v21, this);
    v16 = TNode::SetShouldSyncUbiquityAttributes(BOOL)::sBladeRunnerRegistration;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN5TNode31SetShouldSyncUbiquityAttributesEb_block_invoke;
    block[3] = &__block_descriptor_48_ea8_32c53_ZTSKZN5TNode31SetShouldSyncUbiquityAttributesEbE3__0_e5_v8__0l;
    v19 = v21.fFINode;
    v20 = a2;
    v17 = v19;
    dispatch_async(v16, block);

  }
}

void TNode::RegisterForUbiquityAttributes(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  unint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_info;
  unint64_t v17;
  NSObject *v18;
  void *v19;
  NSObject *v20;
  void *v21;
  TString v22;
  __CFString *fRef;
  char **p_data;
  TNodePtr v25;
  id v26;
  _BYTE buf[24];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    v7 = *(unsigned __int8 *)(v4 + 112);
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    if (v7)
      return;
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*(_BYTE *)(v4 + 112))
      return;
  }
  if (*((_QWORD *)this + 7) && UseFileProviderFramework())
  {
    TNode::GetFPItem(this);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (v9)
    {
      TNodePtr::TNodePtr(&v25, this);
      v10 = v9;
      fRef = 0;
      p_data = 0;
      v22.fString.fRef = 0;
      v26 = v10;
      *(_QWORD *)buf = &v22;
      buf[8] = 0;
      v22.fString.fRef = (__CFString *)operator new(0x10uLL);
      fRef = v22.fString.fRef;
      p_data = &v22.fString.fRef->data;
      fRef = (__CFString *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&p_data, (id *)&v25.fFINode, (id *)buf, v22.fString.fRef);
      TNode::AttachFPItemsMetadata(&v22, 1, 1);
      *(_QWORD *)buf = &v22;
      std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);

      TNode::FPItemsCollection(this, (FPItem *)v10);
      v11 = objc_claimAutoreleasedReturnValue();

      v12 = (void *)v11;
      if (v11)
      {
LABEL_15:
        v13 = *((_QWORD *)this + 7);
        TNodePtr::TNodePtr((TNodePtr *)buf, this);
        TNode::GetVolumeInfo(this, &v22);
        TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)v22.fString.fRef);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        TChildrenList::StartCollectionStatusObserver(v13, v12, (uint64_t)buf, v14, 0);

        v15 = (std::__shared_weak_count *)fRef;
        if (fRef)
        {
          p_info = (unint64_t *)&fRef->info;
          do
            v17 = __ldaxr(p_info);
          while (__stlxr(v17 - 1, p_info));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
        }

LABEL_27:
        return;
      }
    }
    else
    {
      LogObj(4);
      v18 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        TNode::GetPath((uint64_t)this, 1, (uint64_t)&v22);
        SanitizedPath(&v22);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v19;
        _os_log_impl(&dword_1CBC4A000, v18, OS_LOG_TYPE_INFO, "Attempting to observe fpitem collection via URL %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);

      }
      TNode::FPItemsCollectionFromURL(this);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (v12)
        goto LABEL_15;
    }
    LogObj(4);
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)&v22);
      SanitizedPath(&v22);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v21;
      _os_log_impl(&dword_1CBC4A000, v20, OS_LOG_TYPE_ERROR, "No collection found for node %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);

    }
    goto LABEL_27;
  }
}

void sub_1CBC837C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void TNode::HandleRegisterForNotification(TNodeTask **a1, FINode **a2)
{
  int v4;
  TNode *v5;
  TNode *v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  uint64_t v9;
  TNode *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  TDSNotifier *v14;
  char v15;
  TDSNotifier *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  TNodeTask::GetClientChangeNotifier(*a1, &v17);
  if ((TNodeTask::GetNotificationOptions(*a1) & 2) != 0)
  {
    v4 = *((_DWORD *)*a1 + 12);
    v16 = 0;
    StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v15);
    v5 = (TNode *)TNodeFromFINode(*a2);
    TNode::FindRegistration(v5, (uint64_t)&v17, a2, &v14);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(&v16, &v14);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v14);
    StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v15);
    if (v16)
    {
      v6 = (TNode *)TNodeFromFINode(*a2);
      v7 = (unsigned __int8 *)(TNode::GetNotifierList(v6) + 20);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(0, v7));
      v9 = TNodeFromFINode(*a2);
      TNode::DoExternalRegistration(v9, &v16, v8 & 1);
      if (v4 & 0x40000 | v8 & 1)
      {
        v10 = (TNode *)TNodeFromFINode(*a2);
        TNode::HandlePopulate(v10, 0, 0);
      }
    }
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v16);
  }
  v11 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1CBC839A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  TDSNotifier *v5;
  va_list va;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, TDSNotifier *);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

BOOL TNode::FSNotificationsSupported(TNode *this)
{
  _BOOL4 v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  _BYTE *v6;
  std::__shared_weak_count *v7;

  TNode::GetVolumeInfo(this, &v6);
  v1 = !v6[107] && v6[126] || v6[129] != 0;
  v2 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return TNode::gKQueueRegistrationCount < 128 && v1;
}

uint64_t TNode::RemoveUnmarkedChildren(TNode *this, TNodeEventPtrs *a2)
{
  uint64_t v4;
  FINode **v5;
  FINode **v6;
  char v7;
  FINode *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t v15;
  unsigned __int16 v16;
  FINode *fFINode;
  os_unfair_lock_s *v18;
  Class isa;
  int v20;
  id v21;
  FINode *v22;
  FINode *v23;
  TNode *v24;
  uint64_t v25;
  TNode *v26;
  void *v27;
  uint64_t v28;
  os_unfair_lock_s *v29;
  std::__shared_weak_count *v30;
  FINode *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  TNode *v36;
  unsigned __int16 *v37;
  unsigned __int16 v38;
  unsigned __int16 *v39;
  unsigned __int16 v40;
  TNode *v41;
  TNode *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  FINode *v48;
  std::__shared_weak_count *v49;
  FINode *v50;
  TNodePtr v51;
  std::__shared_weak_count *v52;
  FINode *v53[3];

  TNodePtr::TNodePtr(&v51, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v53, &v51, 0);

  v4 = *((_QWORD *)this + 7);
  if (v4)
  {
    v6 = *(FINode ***)(v4 + 64);
    v5 = *(FINode ***)(v4 + 72);
    if (v5 == v6)
    {
      v7 = 0;
    }
    else
    {
      v7 = 0;
      do
      {
        v8 = *--v5;
        v9 = TNodeFromFINode(v8);
        v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
        os_unfair_lock_lock(v10);
        v12 = *(_QWORD *)(v9 + 16);
        v11 = *(std::__shared_weak_count **)(v9 + 24);
        v51.fFINode = (FINode *)v12;
        v52 = v11;
        if (v11)
        {
          p_shared_owners = (unint64_t *)&v11->__shared_owners_;
          do
            v14 = __ldxr(p_shared_owners);
          while (__stxr(v14 + 1, p_shared_owners));
        }
        os_unfair_lock_unlock(v10);
        os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
        v15 = *(unsigned int *)(v12 + 115) | ((unint64_t)*(unsigned __int16 *)(v12 + 119) << 32);
        os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
        if ((v15 & 0x100000000) == 0)
        {
          v16 = atomic_load((unsigned __int16 *)(TNodeFromFINode(*v5) + 80));
          if ((v16 & 0x100) == 0)
          {
            fFINode = v51.fFINode;
            if (LOBYTE(v51.fFINode[14].super.isa) == 27)
            {
              v18 = (os_unfair_lock_s *)&v51.fFINode[12];
              os_unfair_lock_lock((os_unfair_lock_t)&v51.fFINode[12]);
              isa = fFINode[10].super.isa;
              if (isa
                && (os_unfair_lock_lock((os_unfair_lock_t)isa + 18),
                    v20 = *((unsigned __int8 *)isa + 76),
                    os_unfair_lock_unlock((os_unfair_lock_t)isa + 18),
                    v20 == 1))
              {
                v21 = *((id *)isa + 3);
              }
              else
              {
                v21 = 0;
              }
              os_unfair_lock_unlock(v18);
              v50 = 0;
              objc_msgSend(v21, "rootURL");
              v22 = (FINode *)objc_claimAutoreleasedReturnValue();
              v23 = v22;
              if (v22)
              {
                v48 = v22;
                TNode::GetNodeFromURL((CFURLRef *)&v48, (TNodePtr *)&v50, 0x80u);
              }

              if (TNodeFromFINode(v50))
              {
                v24 = (TNode *)TNodeFromFINode(v50);
                TNode::DetachFPItemsMetadata(v24);
                v25 = TNodeFromFINode(v50);
                TNode::HandleSync(v25, 0x1040000u);
                v26 = (TNode *)TNodeFromFINode(v50);
                TNode::GetFPItem(v26);
                v27 = (void *)objc_claimAutoreleasedReturnValue();

                if (v27)
                {
                  v28 = TNodeFromFINode(v50);
                  v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
                  os_unfair_lock_lock(v29);
                  v31 = *(FINode **)(v28 + 16);
                  v30 = *(std::__shared_weak_count **)(v28 + 24);
                  v48 = v31;
                  v49 = v30;
                  if (v30)
                  {
                    v32 = (unint64_t *)&v30->__shared_owners_;
                    do
                      v33 = __ldxr(v32);
                    while (__stxr(v33 + 1, v32));
                  }
                  os_unfair_lock_unlock(v29);
                  TFSInfo::SetFPItem((TFSInfo *)v31, 0);
                  if (v30)
                  {
                    v34 = (unint64_t *)&v30->__shared_owners_;
                    do
                      v35 = __ldaxr(v34);
                    while (__stlxr(v35 - 1, v34));
                    if (!v35)
                    {
                      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                      std::__shared_weak_count::__release_weak(v30);
                    }
                  }
                }
              }
              if (objc_msgSend(v21, "isiCloudDriveProvider", v48, v49))
              {
                if (objc_msgSend(v21, "isDataSeparatedDomain"))
                  TGlobalNodes::DataSeparatedICloudLibrariesContainerNode(&v48);
                else
                  TGlobalNodes::iCloudLibrariesContainerNode(&v48);
                if (TNodeFromFINode(v48))
                {
                  v36 = (TNode *)TNodeFromFINode(v48);
                  TNode::RemoveAllChildren(v36, 0, 0);
                  v37 = (unsigned __int16 *)(TNodeFromFINode(v48) + 80);
                  do
                    v38 = __ldaxr(v37);
                  while (__stlxr(v38 & 0xFFF7, v37));
                  v39 = (unsigned __int16 *)(TNodeFromFINode(v48) + 80);
                  do
                    v40 = __ldaxr(v39);
                  while (__stlxr(v40 & 0xFFEF, v39));
                }

              }
            }
            v41 = (TNode *)TNodeFromFINode(*v5);
            TNode::CloseNodeBrowserIfNecessary(v41, 0);
            v42 = (TNode *)TNodeFromFINode(*v5);
            TNode::Remove(v42, 0, a2);
            v7 = 1;
          }
        }
        v43 = v52;
        if (v52)
        {
          v44 = (unint64_t *)&v52->__shared_owners_;
          do
            v45 = __ldaxr(v44);
          while (__stlxr(v45 - 1, v44));
          if (!v45)
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
        }
      }
      while (v5 != v6);
    }
    v46 = v7 & 1;
  }
  else
  {
    v46 = 0;
  }
  TNode::StPopulating::~StPopulating(v53);
  return v46;
}

void sub_1CBC83DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, id a11, uint64_t a12, uint64_t a13, FINode *a14)
{
  void *v14;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  TNode::StPopulating::~StPopulating(&a14);
  _Unwind_Resume(a1);
}

uint64_t TNode::DoExternalRegistration(uint64_t a1, TDSNotifier **a2, int a3)
{
  TDSNotifier *v4;
  uint64_t NotifierList;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  TNode *v10;
  int v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  TNode *v17;
  int v18;
  unint64_t v19;
  void **v20;
  os_unfair_lock_s *v21;
  void **v22;
  void *v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  int os_unfair_lock_opaque_low;
  const TNodePtr *v27;
  os_unfair_lock_s *v28;
  std::__shared_weak_count *v29;
  TFSInfo *v30;
  unint64_t *v31;
  unint64_t v32;
  _BOOL4 IsFPv2;
  _BOOL4 v34;
  unint64_t *v35;
  unint64_t v36;
  FPItem *v37;
  void *v38;
  uint64_t v39;
  void *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  TCachedAppLibraryCollections *v44;
  NSString *v45;
  TCachedAppLibraryCollections *v46;
  NSObject *v47;
  uint64_t v48;
  void *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t IsNetworkNode;
  os_unfair_lock_s *v55;
  std::__shared_weak_count *v56;
  TFSInfo *v57;
  unint64_t *v58;
  unint64_t v59;
  TFSInfo *v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t RootNode;
  unsigned __int16 *v64;
  unsigned __int16 v65;
  unsigned __int16 v66;
  int v67;
  unsigned __int16 v68;
  dispatch_time_t v69;
  NSObject *v70;
  unsigned __int16 v71;
  const char *v72;
  NSObject *v73;
  os_unfair_lock_t v74;
  _QWORD v75[4];
  id v76;
  BOOL v77;
  TNodePtr v78;
  TFSInfo *v79;
  os_unfair_lock_t lock;
  std::__shared_weak_count *v81;
  id *v82;
  __int128 buf;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v82 = (id *)v4;
  if (!v4)
  {
    v24 = 0;
    goto LABEL_50;
  }
  TDSNotifier::AddPtrReference(v4);
  NotifierList = TNode::GetNotifierList((TNode *)a1);
  v7 = *(std::__shared_weak_count **)(NotifierList + 32);
  lock = *(os_unfair_lock_t *)(NotifierList + 24);
  v81 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = (TNode *)TNode::VirtualType((TNode *)a1);
  v11 = (int)v10;
  v12 = (os_unfair_lock_s *)TNode::InfoLock(v10);
  os_unfair_lock_lock(v12);
  v14 = *(_QWORD *)(a1 + 16);
  v13 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v13)
  {
    os_unfair_lock_unlock(v12);
    if (*(_BYTE *)(v14 + 112))
      goto LABEL_13;
LABEL_18:
    v25 = lock;
    os_unfair_lock_lock(lock);
    os_unfair_lock_opaque_low = LOBYTE(lock[1]._os_unfair_lock_opaque);
    os_unfair_lock_unlock(lock);
    if (!os_unfair_lock_opaque_low && TNode::FSNotificationsSupported((TNode *)a1))
    {
      TNode::SubscribeForFSNotification((TNode *)a1);
      os_unfair_lock_lock(lock);
      LOBYTE(lock[1]._os_unfair_lock_opaque) = 1;
      os_unfair_lock_unlock(v25);
    }
    if (a3)
    {
      *(_QWORD *)&buf = v82[3];
      TProgressMap::AddSubscriberForExternalProgress((const TNodePtr *)&buf, v27);

    }
    goto LABEL_44;
  }
  v15 = (unint64_t *)&v13->__shared_owners_;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  os_unfair_lock_unlock(v12);
  v18 = *(unsigned __int8 *)(v14 + 112);
  do
    v19 = __ldaxr(v15);
  while (__stlxr(v19 - 1, v15));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (!v18)
    goto LABEL_18;
LABEL_13:
  if (v11 == 26)
  {
    if (a3)
    {
      v20 = (void **)objc_opt_new();
      TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
      TNodePtr::operator=(v20 + 1, (void **)&buf);

      v21 = lock;
      v22 = v20;
      os_unfair_lock_lock(lock);
      v23 = *(void **)&lock[2]._os_unfair_lock_opaque;
      *(_QWORD *)&lock[2]._os_unfair_lock_opaque = v22;

      os_unfair_lock_unlock(v21);
      objc_msgSend(v22, "startObserving");

    }
    goto LABEL_44;
  }
  v28 = (os_unfair_lock_s *)TNode::InfoLock(v17);
  os_unfair_lock_lock(v28);
  v30 = *(TFSInfo **)(a1 + 16);
  v29 = *(std::__shared_weak_count **)(a1 + 24);
  *(_QWORD *)&buf = v30;
  *((_QWORD *)&buf + 1) = v29;
  if (v29)
  {
    v31 = (unint64_t *)&v29->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  os_unfair_lock_unlock(v28);
  IsFPv2 = TFSInfo::IsFPv2(v30, 1);
  v34 = IsFPv2;
  if (!v29)
    goto LABEL_30;
  v35 = (unint64_t *)&v29->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
    if (v34)
    {
LABEL_31:
      if (a3)
      {
        TNode::GetFPItem((TNode *)a1);
        v37 = (FPItem *)objc_claimAutoreleasedReturnValue();
        TNode::FPItemsCollection((TNode *)a1, v37);
        v38 = (void *)objc_claimAutoreleasedReturnValue();

        v39 = *(_QWORD *)(a1 + 56);
        TNodePtr::TNodePtr(&v78, (const TNode *)a1);
        TNode::GetVolumeInfo((TNode *)a1, &buf);
        TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)buf);
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        TChildrenList::StartCollectionStatusObserver(v39, v38, (uint64_t)&v78, v40, 0);

        v41 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
        if (*((_QWORD *)&buf + 1))
        {
          v42 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
          do
            v43 = __ldaxr(v42);
          while (__stlxr(v43 - 1, v42));
          if (!v43)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }

      }
      goto LABEL_44;
    }
  }
  else
  {
LABEL_30:
    if (IsFPv2)
      goto LABEL_31;
  }
  if ((v11 - 23) > 1u)
  {
    v79 = 0;
    IsNetworkNode = TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E74776B);
    if ((IsNetworkNode & 1) != 0
      || (IsNetworkNode = TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E747362), (IsNetworkNode & 1) != 0)
      || (IsNetworkNode = TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6D74726D), (_DWORD)IsNetworkNode))
    {
      v55 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsNetworkNode);
      os_unfair_lock_lock(v55);
      v57 = *(TFSInfo **)(a1 + 16);
      v56 = *(std::__shared_weak_count **)(a1 + 24);
      *(_QWORD *)&buf = v57;
      *((_QWORD *)&buf + 1) = v56;
      if (v56)
      {
        v58 = (unint64_t *)&v56->__shared_owners_;
        do
          v59 = __ldxr(v58);
        while (__stxr(v59 + 1, v58));
      }
      os_unfair_lock_unlock(v55);
      v60 = (TFSInfo *)TFSInfo::CopySFBrowserRef(v57);
      v79 = v60;
      if (v56)
      {
        v61 = (unint64_t *)&v56->__shared_owners_;
        do
          v62 = __ldaxr(v61);
        while (__stlxr(v62 - 1, v61));
        if (!v62)
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
        v60 = v79;
      }
      if (v60)
      {
        RootNode = SFBrowserGetRootNode();
        if ((ExternalRegistration::IsNetworkOpened(lock) & 1) == 0)
        {
          LOBYTE(v78.fFINode) = 0;
          v64 = (unsigned __int16 *)(a1 + 80);
          do
            v65 = __ldaxr(v64);
          while (__stlxr(v65 & 0xFFF7, v64));
          do
            v66 = __ldaxr(v64);
          while (__stlxr(v66 & 0xFFEF, v64));
          TNode::HandleSyncStarted(a1, 276824064, (BOOL *)&v78);
          v77 = 0;
          v67 = TFSInfo::BrowserOpenNode(v79, RootNode, 0, 0, &v77);
          if (LOBYTE(v78.fFINode))
          {
            do
              v68 = __ldaxr(v64);
            while (__stlxr(v68 | 0x20, v64));
            if (v77)
            {
              v69 = dispatch_time(0, 3000000000);
              dispatch_get_global_queue(0, 0);
              v70 = objc_claimAutoreleasedReturnValue();
              v75[0] = MEMORY[0x1E0C809B0];
              v75[1] = 3321888768;
              v75[2] = ___ZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEb_block_invoke;
              v75[3] = &__block_descriptor_40_ea8_32c94_ZTSKZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEbE3__0_e5_v8__0l;
              TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
              v76 = (id)buf;
              dispatch_after(v69, v70, v75);

            }
            else
            {
              do
                v71 = __ldaxr(v64);
              while (__stlxr(v71 & 0xFFDF, v64));
              if ((v71 & 0x20) != 0)
                TNode::HandleSync(a1, 0x1400000u);
            }
          }
          if (v67)
          {
            v24 = 4294959241;
LABEL_87:
            TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)&v79);
            goto LABEL_45;
          }
          v74 = lock;
          os_unfair_lock_lock(lock);
          BYTE1(v74[1]._os_unfair_lock_opaque) = 1;
          os_unfair_lock_unlock(v74);
          LODWORD(v74) = TNode::VirtualType((TNode *)a1);
          TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
          TNode::AddNWNode((int)v74, RootNode, (FINode **)&buf);

        }
      }
    }
    else
    {
      TNode::GetFSInfo((TNode *)a1, &buf);
      TNode::GetFSInfo((TNode *)a1, &v78);
      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v78);
      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
    }
    v24 = 0;
    goto LABEL_87;
  }
  if (ICloudDriveFPFSEnabled())
  {
    iCloudDriveDomainIDForDataSeparated(v11 == 24);
    v44 = (TCachedAppLibraryCollections *)objc_claimAutoreleasedReturnValue();
    v45 = (NSString *)v44;
    if (v44)
    {
      v46 = (TCachedAppLibraryCollections *)TCachedAppLibraryCollections::Singleton(v44);
      TString::TString((TString *)&buf, v45);
      TCachedAppLibraryCollections::CachedCollection(v46, (const TString *)&buf, 1);
      v47 = objc_claimAutoreleasedReturnValue();
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&buf);
      if (v47)
      {
        v48 = *(_QWORD *)(a1 + 56);
        TNodePtr::TNodePtr(&v78, (const TNode *)a1);
        TNode::GetVolumeInfo((TNode *)a1, &buf);
        TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)buf);
        v49 = (void *)objc_claimAutoreleasedReturnValue();
        TChildrenList::StartCollectionStatusObserver(v48, v47, (uint64_t)&v78, v49, 0);

        std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
        v24 = 0;
LABEL_95:

        goto LABEL_45;
      }
      if (v11 == 24)
      {
        LogObj(3);
        v73 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v45;
          _os_log_impl(&dword_1CBC4A000, v73, OS_LOG_TYPE_ERROR, "No app libraries collection found skipping start observing accountID='%@'", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        LogObj(4);
        v73 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v45;
          _os_log_impl(&dword_1CBC4A000, v73, OS_LOG_TYPE_ERROR, "No app libraries collection found skipping start observing accountID='%@'", (uint8_t *)&buf, 0xCu);
        }
      }

LABEL_94:
      v24 = 4294959240;
      goto LABEL_95;
    }
    if (v11 == 24)
    {
      LogObj(3);
      v47 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        goto LABEL_94;
      LOWORD(buf) = 0;
      v72 = "No domain id found for enterprise iCloud libraries collection";
    }
    else
    {
      LogObj(4);
      v47 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        goto LABEL_94;
      LOWORD(buf) = 0;
      v72 = "No domain id found for iCloud libraries collection";
    }
    _os_log_impl(&dword_1CBC4A000, v47, OS_LOG_TYPE_ERROR, v72, (uint8_t *)&buf, 2u);
    goto LABEL_94;
  }
LABEL_44:
  v24 = 0;
LABEL_45:
  v50 = v81;
  if (v81)
  {
    v51 = (unint64_t *)&v81->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
LABEL_50:
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v82);
  return v24;
}

void sub_1CBC846B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va1);
  _Unwind_Resume(a1);
}

void TNode::UpdateFPItemsMetadata(uint64_t a1, void ***a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  unint64_t v10;
  void *v11;
  void *v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  void **v17;
  void **v18;
  void **v19;
  uint64_t v20;
  _QWORD block[4];
  void **v22;
  _QWORD v23[3];
  TFSVolumeInfo *v24;
  std::__shared_weak_count *v25;
  void ***v26;

  if (*a2 == a2[1])
    return;
  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v5)
  {
    os_unfair_lock_unlock(v4);
    if (*(_BYTE *)(v6 + 112))
      return;
    goto LABEL_12;
  }
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  os_unfair_lock_unlock(v4);
  v9 = *(unsigned __int8 *)(v6 + 112);
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (!v9)
  {
LABEL_12:
    if (FPProviderDomainClass() && UseFileProviderFramework())
    {
      TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(a1 + 56));
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      if (v11
        || (TNode::GetFIProvider((TNode *)a1), v12 = (void *)objc_claimAutoreleasedReturnValue(), v12, v12))
      {
        TNode::GetVolumeInfo((TNode *)a1, &v24);
        TFSVolumeInfo::GetSynchingGCDQueue(v24);
        v13 = objc_claimAutoreleasedReturnValue();
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3321888768;
        block[2] = ___ZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEE_block_invoke;
        block[3] = &__block_descriptor_64_ea8_32c90_ZTSKZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEEE3__0_e5_v8__0l;
        v17 = v11;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)&v18, *a2, a2[1], a2[1] - *a2);
        v22 = v17;
        memset(v23, 0, sizeof(v23));
        std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)v23, v18, v19, v19 - v18);
        dispatch_async(v13, block);
        v26 = &v18;
        std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v26);

        v14 = v25;
        if (v25)
        {
          v15 = (unint64_t *)&v25->__shared_owners_;
          do
            v16 = __ldaxr(v15);
          while (__stlxr(v16 - 1, v15));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        v17 = (void **)v23;
        std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v17);

      }
    }
  }
}

void sub_1CBC84A2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TNode::ReplaceChildrenWith(uint64_t a1, void ***a2, int a3)
{
  uint64_t v4;
  FINode **v5;
  FINode **v6;
  uint64_t v7;
  TNode *v8;
  os_unfair_lock_s *v9;
  TNodePtr v10;

  v4 = *(_QWORD *)(a1 + 56);
  TChildrenList::ReplaceChildrenWith(v4, a2, a3);
  v5 = *(FINode ***)(v4 + 64);
  v6 = *(FINode ***)(v4 + 72);
  while (v5 != v6)
  {
    v7 = TNodeFromFINode(*v5);
    TNodePtr::TNodePtr(&v10, (const TNode *)a1);
    v9 = (os_unfair_lock_s *)TNode::ParentLock(v8);
    os_unfair_lock_lock(v9);
    *(_QWORD *)(v7 + 48) = TNodeFromFINode(v10.fFINode);
    os_unfair_lock_unlock(v9);

    ++v5;
  }
}

void sub_1CBC84B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

TNode *TNode::ClearSyncRequested(TNode *this)
{
  unsigned __int16 *v1;
  unsigned __int16 v2;

  v1 = (unsigned __int16 *)((char *)this + 80);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 & 0xFFFB, v1));
  return this;
}

uint64_t TNode::AddNewChildren(uint64_t a1, TNodePtr **a2, int a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  FINode **v6;
  FINode **v7;
  TNode *v8;
  FINode **v10;
  FINode **v11;
  uint64_t v12;
  FINode ***v13;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v5 = TChildrenList::AddNewChildren(*(_QWORD *)(a1 + 56), a2, a3, a4, (uint64_t *)&v10, a5);
  v6 = v10;
  v7 = v11;
  while (v6 != v7)
  {
    v8 = (TNode *)TNodeFromFINode(*v6);
    TNode::RemoveSelf(v8, 0);
    ++v6;
  }
  v13 = &v10;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v13);
  return v5;
}

void sub_1CBC84BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t TNode::RedundantSync(uint64_t a1, int a2)
{
  unsigned __int16 *v2;
  unsigned int v3;

  if ((a2 & 0x400000) != 0)
    return 0;
  v2 = (unsigned __int16 *)(a1 + 80);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 | 4, v2));
  return (v3 >> 2) & 1;
}

uint64_t TNode::HandleSync(_QWORD *a1, FINode **a2)
{
  unsigned int *v4;
  unsigned int v5;
  TNode *v6;
  int v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  os_unfair_lock_s *v14;
  int v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  os_unfair_lock_s *v21;
  std::__shared_weak_count *v22;
  TFSInfo *v23;
  unint64_t *v24;
  unint64_t v25;
  _BOOL8 IsAlias;
  _BOOL4 v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t SyncStartTime;
  TNode *v33;
  unint64_t v34;
  uint64_t v35;
  os_unfair_lock_s *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  TNode *v43;
  unint64_t v44;
  TNode *v45;
  _QWORD v46[2];

  if (TNodeFromFINode(*a2))
  {
    v4 = (unsigned int *)(*a1 + 24);
    LODWORD(v46[0]) = 0;
    v5 = TPropertyValue::As<NodeRequestOptions>(v4, (unsigned int *)v46);
    v6 = (TNode *)TNodeFromFINode(*a2);
    v7 = TNode::VirtualType(v6);
    v8 = TNodeFromFINode(*a2);
    v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    v11 = *(_QWORD *)(v8 + 16);
    v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v9);
    v14 = (os_unfair_lock_s *)(v11 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
    v15 = *(_DWORD *)(v11 + 115);
    os_unfair_lock_unlock(v14);
    if (!v10)
      goto LABEL_9;
    v16 = (unint64_t *)&v10->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if ((v15 & 0x20) == 0)
        goto LABEL_10;
    }
    else
    {
LABEL_9:
      if ((v15 & 0x20) == 0)
      {
LABEL_10:
        v18 = TNodeFromFINode(*a2);
        TNode::HandleSync(v18, v5);
        return 0;
      }
    }
    v20 = TNodeFromFINode(*a2);
    v21 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v20);
    os_unfair_lock_lock(v21);
    v23 = *(TFSInfo **)(v20 + 16);
    v22 = *(std::__shared_weak_count **)(v20 + 24);
    v46[0] = v23;
    v46[1] = v22;
    if (v22)
    {
      v24 = (unint64_t *)&v22->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }
    os_unfair_lock_unlock(v21);
    IsAlias = TFSInfo::IsAlias(v23);
    v27 = IsAlias;
    if (v22)
    {
      v28 = (unint64_t *)&v22->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    if (((v27 | ((v5 & 0x80000) >> 19)) & 1) != 0 || (v7 - 23) < 2)
      goto LABEL_10;
    v30 = TTime::MicrosecondsSinceStartup((TTime *)IsAlias);
    v31 = TNodeFromFINode(*a2);
    SyncStartTime = TChildrenList::LastSyncStartTime(*(TChildrenList **)(v31 + 56));
    v33 = (TNode *)TNodeFromFINode(*a2);
    v34 = TNode::AdjustedSyncQuanta(v33);
    v35 = TNodeFromFINode(*a2);
    v36 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v35);
    os_unfair_lock_lock(v36);
    v38 = *(_QWORD *)(v35 + 16);
    v37 = *(std::__shared_weak_count **)(v35 + 24);
    if (v37)
    {
      v39 = (unint64_t *)&v37->__shared_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
      os_unfair_lock_unlock(v36);
      v41 = *(unsigned __int8 *)(v38 + 112);
      do
        v42 = __ldaxr(v39);
      while (__stlxr(v42 - 1, v39));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
      if (v41)
        goto LABEL_34;
    }
    else
    {
      os_unfair_lock_unlock(v36);
      if (*(_BYTE *)(v38 + 112))
        goto LABEL_34;
    }
    v43 = (TNode *)TNodeFromFINode(*a2);
    if (!TNode::IsSynchingAppropriate(v43))
    {
      if (v30 > SyncStartTime + 20000000)
        goto LABEL_10;
      v44 = v30 + 1000000;
      goto LABEL_35;
    }
LABEL_34:
    v44 = v34 + SyncStartTime;
    if (v44 <= v30)
      goto LABEL_10;
LABEL_35:
    v45 = (TNode *)TNodeFromFINode(*a2);
    TNode::SetTimerToDispatchSyncRequest(v45, v44, v5);
  }
  return 0;
}

void sub_1CBC84ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CFIndex TNode::HandleSync(uint64_t a1, unsigned int a2, id **a3)
{
  TNode *IsFPv2;
  int v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  id *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  int IsDataless;
  unint64_t *v16;
  unint64_t v17;
  TNode *v18;
  TNode *v19;
  int v20;
  os_unfair_lock_s *v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  int v24;
  id **v25;
  unint64_t *v26;
  unint64_t v27;
  TNode *v28;
  int v29;
  unint64_t v30;
  os_unfair_lock_s *v31;
  std::__shared_weak_count *v32;
  int v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  CFIndex AdditionalPropertiesForSync;
  os_unfair_lock_s *v38;
  int v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  int v44;
  unint64_t *v45;
  unint64_t v46;
  os_unfair_lock_s *v47;
  TNode *v48;
  os_unfair_lock_s *v49;
  std::__shared_weak_count *v50;
  TFSInfo *v51;
  unint64_t *v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  TNode *v56;
  TFSInfo *v57;
  uint64_t v58;
  os_unfair_lock_s *v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  os_unfair_lock_s *v66;
  std::__shared_weak_count *v67;
  uint64_t v68;
  char v69;
  unint64_t *v70;
  unint64_t v71;
  TNode *v72;
  int v73;
  unint64_t v74;
  int v75;
  os_unfair_lock_s *v76;
  std::__shared_weak_count *v77;
  os_unfair_lock_s *v78;
  unint64_t *v79;
  unint64_t v80;
  CFURLRef CFURLRef;
  unint64_t *v82;
  unint64_t v83;
  TFSInfo *EnumeratorProperties;
  os_unfair_lock_s *v85;
  std::__shared_weak_count *v86;
  uint64_t v87;
  unint64_t *v88;
  unint64_t v89;
  int v90;
  os_unfair_lock_s *v91;
  uint64_t v92;
  int v93;
  id v94;
  unint64_t *v95;
  unint64_t v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  os_unfair_lock_s *v100;
  std::__shared_weak_count *v101;
  uint64_t v102;
  unint64_t *v103;
  unint64_t v104;
  os_unfair_lock_s *v105;
  int v106;
  TNode *v107;
  unint64_t *v108;
  unint64_t v109;
  char v110;
  void *v111;
  os_unfair_lock_s *v112;
  std::__shared_weak_count *v113;
  TFSInfo *v114;
  unint64_t *v115;
  unint64_t v116;
  int IsDatalessNow;
  unint64_t *v118;
  unint64_t v119;
  int v120;
  int v121;
  int v122;
  id **v124;
  const __CFURL *v125;
  os_unfair_lock_s *v126;
  std::__shared_weak_count *v127;
  TString v128;
  TNodePtr v129;
  id *v130;
  std::__shared_weak_count *v131;
  uint64_t v132;
  BOOL v133;
  TFSInfo *v134;
  std::__shared_weak_count *v135;

  v133 = 0;
  IsFPv2 = (TNode *)TNode::VirtualType((TNode *)a1);
  if ((_DWORD)IsFPv2 == 26 || (IsFPv2 = (TNode *)TNode::IsFPv2((TNode *)a1, 1), v7 = a2, (_DWORD)IsFPv2))
    v7 = a2 | 0x800000;
  v8 = (os_unfair_lock_s *)TNode::InfoLock(IsFPv2);
  os_unfair_lock_lock(v8);
  v10 = *(id **)(a1 + 16);
  v9 = *(std::__shared_weak_count **)(a1 + 24);
  v130 = v10;
  v131 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v8);
  IsDataless = TFSInfo::IsDataless((TFSInfo *)v10, v13, v14);
  if (v9)
  {
    v16 = (unint64_t *)&v9->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v18 = (TNode *)TNode::HandleSyncStarted(a1, v7, &v133);
  v19 = v18;
  v20 = !v133 & (a2 >> 19);
  v130 = 0;
  v131 = 0;
  v132 = 0;
  if ((a2 & 0x100) != 0)
    goto LABEL_61;
  v21 = (os_unfair_lock_s *)TNode::InfoLock(v18);
  os_unfair_lock_lock(v21);
  v23 = *(_QWORD *)(a1 + 16);
  v22 = *(std::__shared_weak_count **)(a1 + 24);
  if (v22)
  {
    v24 = IsDataless;
    v25 = a3;
    v26 = (unint64_t *)&v22->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    os_unfair_lock_unlock(v21);
    v29 = *(unsigned __int8 *)(v23 + 112);
    do
      v30 = __ldaxr(v26);
    while (__stlxr(v30 - 1, v26));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    a3 = v25;
    IsDataless = v24;
    if (v29)
      goto LABEL_21;
  }
  else
  {
    os_unfair_lock_unlock(v21);
    if (*(_BYTE *)(v23 + 112))
    {
LABEL_21:
      v31 = (os_unfair_lock_s *)TNode::InfoLock(v28);
      os_unfair_lock_lock(v31);
      v32 = *(std::__shared_weak_count **)(a1 + 24);
      if (v32)
      {
        v33 = IsDataless;
        v34 = (unint64_t *)&v32->__shared_owners_;
        do
          v35 = __ldxr(v34);
        while (__stxr(v35 + 1, v34));
        os_unfair_lock_unlock(v31);
        do
          v36 = __ldaxr(v34);
        while (__stlxr(v36 - 1, v34));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
        AdditionalPropertiesForSync = 0;
        IsDataless = v33;
        goto LABEL_113;
      }
      os_unfair_lock_unlock(v31);
LABEL_61:
      AdditionalPropertiesForSync = 0;
      goto LABEL_113;
    }
  }
  if ((v20 & 1) == 0)
  {
    v38 = (os_unfair_lock_s *)TNode::InfoLock(v28);
    v39 = IsDataless;
    os_unfair_lock_lock(v38);
    v41 = *(_QWORD *)(a1 + 16);
    v40 = *(std::__shared_weak_count **)(a1 + 24);
    v134 = (TFSInfo *)v41;
    v135 = v40;
    if (v40)
    {
      v42 = (unint64_t *)&v40->__shared_owners_;
      do
        v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
    }
    os_unfair_lock_unlock(v38);
    os_unfair_lock_lock((os_unfair_lock_t)(v41 + 100));
    v44 = *(_DWORD *)(v41 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(v41 + 100));
    if ((v44 & 0x8000) != 0)
      v28 = (TNode *)TFSInfo::TriggerMount((TFSInfo *)v41);
    IsDataless = v39;
    if (v40)
    {
      v45 = (unint64_t *)&v40->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
  }
  v47 = (os_unfair_lock_s *)TNode::ParentLock(v28);
  os_unfair_lock_lock(v47);
  TNodePtr::TNodePtr(&v129, *(const TNode **)(a1 + 48));
  os_unfair_lock_unlock(v47);
  v49 = (os_unfair_lock_s *)TNode::InfoLock(v48);
  os_unfair_lock_lock(v49);
  v51 = *(TFSInfo **)(a1 + 16);
  v50 = *(std::__shared_weak_count **)(a1 + 24);
  v134 = v51;
  v135 = v50;
  if (v50)
  {
    v52 = (unint64_t *)&v50->__shared_owners_;
    do
      v53 = __ldxr(v52);
    while (__stxr(v53 + 1, v52));
  }
  os_unfair_lock_unlock(v49);
  TFSInfo::Name(v51, &v128);
  if (v50)
  {
    v54 = (unint64_t *)&v50->__shared_owners_;
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v134);
  v56 = (TNode *)TNodeFromFINode(v129.fFINode);
  if (v56)
  {
    v57 = v134;
    v58 = TNodeFromFINode(v129.fFINode);
    v59 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v58);
    os_unfair_lock_lock(v59);
    v60 = *(std::__shared_weak_count **)(v58 + 24);
    v126 = *(os_unfair_lock_s **)(v58 + 16);
    v127 = v60;
    if (v60)
    {
      v61 = (unint64_t *)&v60->__shared_owners_;
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }
    os_unfair_lock_unlock(v59);
    v56 = (TNode *)TFSInfo::Initialize(v57, &v126, &v128);
    AdditionalPropertiesForSync = (CFIndex)v56;
    v63 = v127;
    if (v127)
    {
      v64 = (unint64_t *)&v127->__shared_owners_;
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    if (!(_DWORD)AdditionalPropertiesForSync)
      goto LABEL_85;
  }
  else
  {
    AdditionalPropertiesForSync = 4294959236;
  }
  v66 = (os_unfair_lock_s *)TNode::InfoLock(v56);
  v124 = a3;
  os_unfair_lock_lock(v66);
  v68 = *(_QWORD *)(a1 + 16);
  v67 = *(std::__shared_weak_count **)(a1 + 24);
  if (v67)
  {
    v69 = v20;
    v20 = IsDataless;
    v70 = (unint64_t *)&v67->__shared_owners_;
    do
      v71 = __ldxr(v70);
    while (__stxr(v71 + 1, v70));
    os_unfair_lock_unlock(v66);
    v73 = *(unsigned __int8 *)(v68 + 112);
    do
      v74 = __ldaxr(v70);
    while (__stlxr(v74 - 1, v70));
    a3 = v124;
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
      std::__shared_weak_count::__release_weak(v67);
    }
    IsDataless = v20;
    LOBYTE(v20) = v69;
    if (!v73)
    {
LABEL_73:
      v72 = (TNode *)TNodeFromFINode(v129.fFINode);
      if (v72)
        goto LABEL_107;
    }
  }
  else
  {
    os_unfair_lock_unlock(v66);
    v75 = *(unsigned __int8 *)(v68 + 112);
    a3 = v124;
    if (!v75)
      goto LABEL_73;
  }
  v76 = (os_unfair_lock_s *)TNode::InfoLock(v72);
  os_unfair_lock_lock(v76);
  v78 = *(os_unfair_lock_s **)(a1 + 16);
  v77 = *(std::__shared_weak_count **)(a1 + 24);
  v126 = v78;
  v127 = v77;
  if (v77)
  {
    v79 = (unint64_t *)&v77->__shared_owners_;
    do
      v80 = __ldxr(v79);
    while (__stxr(v80 + 1, v79));
  }
  os_unfair_lock_unlock(v76);
  CFURLRef = TFSInfo::CreateCFURLRef((TFSInfo *)v78);
  v125 = CFURLRef;
  a3 = v124;
  if (v77)
  {
    v82 = (unint64_t *)&v77->__shared_owners_;
    do
      v83 = __ldaxr(v82);
    while (__stlxr(v83 - 1, v82));
    if (!v83)
    {
      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
      std::__shared_weak_count::__release_weak(v77);
    }
    CFURLRef = v125;
  }
  if (CFURLRef)
  {
    AdditionalPropertiesForSync = TFSInfo::initialize((uint64_t)v134, CFURLRef, 0, 1, 1, 1, 0);
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v125);
    if (!(_DWORD)AdditionalPropertiesForSync)
    {
LABEL_85:
      EnumeratorProperties = TFSInfo::FetchEnumeratorProperties(v134);
      v85 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)EnumeratorProperties);
      os_unfair_lock_lock(v85);
      v87 = *(_QWORD *)(a1 + 16);
      v86 = *(std::__shared_weak_count **)(a1 + 24);
      v126 = (os_unfair_lock_s *)v87;
      v127 = v86;
      if (v86)
      {
        v88 = (unint64_t *)&v86->__shared_owners_;
        do
          v89 = __ldxr(v88);
        while (__stxr(v89 + 1, v88));
      }
      os_unfair_lock_unlock(v85);
      if ((a2 & 0x8000) != 0)
      {
        v90 = IsDataless;
        v91 = (os_unfair_lock_s *)(v87 + 96);
        os_unfair_lock_lock((os_unfair_lock_t)(v87 + 96));
        v92 = *(_QWORD *)(v87 + 80);
        if (v92
          && (os_unfair_lock_lock((os_unfair_lock_t)(v92 + 72)),
              v93 = *(unsigned __int8 *)(v92 + 76),
              os_unfair_lock_unlock((os_unfair_lock_t)(v92 + 72)),
              v93 == 1))
        {
          v94 = *(id *)(v92 + 24);
        }
        else
        {
          v94 = 0;
        }
        IsDataless = v90;
        os_unfair_lock_unlock(v91);
        if (v94)
          TFSInfo::UpdateFileProvider(v134, 0);

      }
      AdditionalPropertiesForSync = TNode::FetchAdditionalPropertiesForSync((TNode *)a1, &v134, 1);
      if (v86)
      {
        v95 = (unint64_t *)&v86->__shared_owners_;
        do
          v96 = __ldaxr(v95);
        while (__stlxr(v96 - 1, v95));
        if (!v96)
        {
          ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
          std::__shared_weak_count::__release_weak(v86);
        }
      }
      if (!(_DWORD)AdditionalPropertiesForSync)
      {
        if (TNode::ReconcileInternalProperties(a1, &v134, &v130, 1) && TNodeFromFINode(v129.fFINode))
        {
          TNodeFromFINode(v129.fFINode);
          TNode::AttachCreateFPItemIfNeeded((TNode *)a1, 1);
        }
        AdditionalPropertiesForSync = 0;
      }
    }
  }
  else
  {
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v125);
  }
LABEL_107:
  v97 = v135;
  if (v135)
  {
    v98 = (unint64_t *)&v135->__shared_owners_;
    do
      v99 = __ldaxr(v98);
    while (__stlxr(v99 - 1, v98));
    if (!v99)
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v128.fString.fRef);

LABEL_113:
  v100 = (os_unfair_lock_s *)TNode::InfoLock(v18);
  os_unfair_lock_lock(v100);
  v102 = *(_QWORD *)(a1 + 16);
  v101 = *(std::__shared_weak_count **)(a1 + 24);
  if (v101)
  {
    v103 = (unint64_t *)&v101->__shared_owners_;
    do
      v104 = __ldxr(v103);
    while (__stxr(v104 + 1, v103));
  }
  os_unfair_lock_unlock(v100);
  v105 = (os_unfair_lock_s *)(v102 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v102 + 100));
  v106 = *(_DWORD *)(v102 + 115);
  os_unfair_lock_unlock(v105);
  if (v101)
  {
    v108 = (unint64_t *)&v101->__shared_owners_;
    do
      v109 = __ldaxr(v108);
    while (__stlxr(v109 - 1, v108));
    if (!v109)
    {
      ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
      std::__shared_weak_count::__release_weak(v101);
    }
  }
  if ((v106 & 0x20) != 0)
    v110 = v20;
  else
    v110 = 1;
  if ((v110 & 1) == 0)
  {
    FIDSNodeFromTNode((TNode *)a1);
    v111 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v111, "synchronizeChildren:events:", v19, &v130);

  }
  if (IsDataless)
  {
    v112 = (os_unfair_lock_s *)TNode::InfoLock(v107);
    os_unfair_lock_lock(v112);
    v114 = *(TFSInfo **)(a1 + 16);
    v113 = *(std::__shared_weak_count **)(a1 + 24);
    v134 = v114;
    v135 = v113;
    if (v113)
    {
      v115 = (unint64_t *)&v113->__shared_owners_;
      do
        v116 = __ldxr(v115);
      while (__stxr(v116 + 1, v115));
    }
    os_unfair_lock_unlock(v112);
    IsDatalessNow = TFSInfo::IsDatalessNow(v114);
    if (v113)
    {
      v118 = (unint64_t *)&v113->__shared_owners_;
      do
        v119 = __ldaxr(v118);
      while (__stlxr(v119 - 1, v118));
      if (!v119)
      {
        ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
        std::__shared_weak_count::__release_weak(v113);
      }
    }
    if (!IsDatalessNow)
      LODWORD(v19) = v19 | 0x800000;
  }
  v120 = TNode::VirtualType((TNode *)a1);
  v121 = ICloudDriveFPFSEnabled();
  if ((v120 - 23) < 2)
    v122 = v121;
  else
    v122 = 0;
  if (v122 == 1 && !TNode::IsPopulated((TNode *)a1))
    LODWORD(v19) = v19 | 0x800000;
  TNode::HandleSyncCompleted(a1, (int)v19);
  TNodeEventPtrs::AddEvents(a3, &v130);
  v134 = (TFSInfo *)&v130;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v134);
  return AdditionalPropertiesForSync;
}

void sub_1CBC85758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void **v5;
  va_list va;
  uint64_t v7;
  const void *v8;
  va_list va1;
  id v10;
  uint64_t v11;
  va_list va2;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va3;

  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, void **);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, const void *);
  v10 = va_arg(va2, id);
  va_copy(va3, va2);
  v11 = va_arg(va3, _QWORD);
  v13 = va_arg(va3, _QWORD);
  v14 = va_arg(va3, _QWORD);
  v15 = va_arg(va3, _QWORD);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);

  va_copy((va_list)v5, va2);
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

CFIndex TNode::HandleSync(uint64_t a1, unsigned int a2)
{
  CFIndex v2;
  id *v4[3];
  id **v5;

  memset(v4, 0, sizeof(v4));
  v2 = TNode::HandleSync(a1, a2, v4);
  TNodeEventPtrs::SendNotifications(v4);
  v5 = v4;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v5);
  return v2;
}

void sub_1CBC858A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t fstd::optional_err<TString,int>::optional_err(uint64_t a1, TString **a2, _DWORD *a3)
{
  *(_QWORD *)a1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_DWORD *)(a1 + 8) = *a3;
  return a1;
}

void sub_1CBC85910(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef(TReferenceCounted **a1)
{
  TReferenceCounted *v2;

  v2 = *a1;
  if (v2)
    TReferenceCounted::RemovePtrReference(v2);
  return a1;
}

const void **TSystemNotificationTask::StartObservingDirectory(TString **this, const TString *a2)
{
  char v2;
  TString *v4;
  CFMutableStringRef MutableCopy;
  TString v7;
  CFTypeRef cf;

  v2 = (char)a2;
  TString::TString(&v7, "/");
  if (TString::EndsWith((TString *)this, &v7))
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, *this);
  }
  else
  {
    v4 = *this;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFStringRef)v4);
    if (cf)
      CFRelease(cf);
    cf = MutableCopy;
    TString::Append((TString *)&cf, (const __CFString *)"/");
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  std::mutex::lock(&gBusyFoldersLock);
  TBusyFolders::StartObservingDirectory((TBusyFolders *)TSystemNotificationTask::gBusyFolders, (const TString *)&cf, v2);
  std::mutex::unlock(&gBusyFoldersLock);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1CBC85A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void TClientChangeNotifier::SetTimerToHandleTickle(TClientChangeNotifier *this, TDSNotifier *a2, uint64_t a3)
{
  NSObject *v5;
  dispatch_source_t v6;
  uint64_t v7;
  NSObject *v8;
  TTime *v9;
  uint64_t v10;
  dispatch_time_t v11;
  const __CFAllocator *v12;
  double Current;
  TTime *v14;
  uint64_t v15;
  __CFRunLoop *Main;
  _QWORD v17[5];
  _QWORD handler[4];
  NSObject *v19;
  TDSNotifier *v20;
  CFRunLoopTimerRef timer;
  CFRunLoopTimerContext context;

  v5 = *((_QWORD *)this + 6);
  if (v5)
  {
    v6 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 1uLL, v5);
    RetainNotifier((unsigned int *)a2);
    v7 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke;
    handler[3] = &unk_1E8752AD8;
    v20 = a2;
    v8 = v6;
    v19 = v8;
    dispatch_source_set_event_handler(v8, handler);
    v17[0] = v7;
    v17[1] = 3221225472;
    v17[2] = ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_3;
    v17[3] = &__block_descriptor_40_e5_v8__0l;
    v17[4] = a2;
    dispatch_source_set_cancel_handler(v8, v17);
    v10 = TTime::MicrosecondsSinceStartup(v9);
    v11 = dispatch_time(0, 1000 * (a3 - v10));
    dispatch_source_set_timer(v8, v11, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(v8);

  }
  else
  {
    context.version = 0;
    context.info = a2;
    context.retain = (const void *(__cdecl *)(const void *))RetainNotifier;
    context.release = (void (__cdecl *)(const void *))ReleaseNotifier;
    context.copyDescription = 0;
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Current = CFAbsoluteTimeGetCurrent();
    v15 = TTime::MicrosecondsSinceStartup(v14);
    timer = CFRunLoopTimerCreate(v12, Current + (double)(a3 - v15) / 1000000.0, 0.0, 0, 0, (CFRunLoopTimerCallBack)TDSNotifier::HandleDeferredTickleOnMainRunLoop, &context);
    Main = CFRunLoopGetMain();
    CFRunLoopAddTimer(Main, timer, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
    TAutoRef<__CFRunLoopTimer *,CFRetainReleasePolicy>::~TAutoRef((const void **)&timer);
  }
}

void sub_1CBC85C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  void *v19;

  _Unwind_Resume(a1);
}

void StFirstPopulationLock::~StFirstPopulationLock(StFirstPopulationLock *this)
{
  os_unfair_lock_s *v2;
  std::mutex *v3;
  StFirstPopulationLock *v4;
  os_unfair_lock_s *v5;
  char *v6;
  int v7;
  id *v8;

  v2 = (os_unfair_lock_s *)StFirstPopulationLock::MapLock(this);
  os_unfair_lock_lock(v2);
  v8 = (id *)this;
  v3 = (std::mutex *)(std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(StFirstPopulationLock::sMutexes, (FINode **)this, (uint64_t)&std::piecewise_construct, &v8)+ 32);
  os_unfair_lock_unlock(v2);
  std::mutex::unlock(v3);
  v5 = (os_unfair_lock_s *)StFirstPopulationLock::MapLock(v4);
  os_unfair_lock_lock(v5);
  v8 = (id *)this;
  v6 = std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(StFirstPopulationLock::sMutexes, (FINode **)this, (uint64_t)&std::piecewise_construct, &v8);
  v7 = *((_DWORD *)v6 + 6) - 1;
  *((_DWORD *)v6 + 6) = v7;
  if (!v7)
    std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__erase_unique<TNodePtr>((_QWORD *)StFirstPopulationLock::sMutexes, (FINode **)this);
  os_unfair_lock_unlock(v5);

}

void StFirstPopulationLock::StFirstPopulationLock(StFirstPopulationLock *this, TNodePtr a2)
{
  objc_class *v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  char *v7;
  std::mutex *v8;
  FINode *fFINode;

  v4 = a2.fFINode->super.isa;
  *(_QWORD *)this = v4;
  v5 = (os_unfair_lock_s *)StFirstPopulationLock::MapLock(v4);
  os_unfair_lock_lock(v5);
  v6 = StFirstPopulationLock::sMutexes;
  if (!StFirstPopulationLock::sMutexes)
  {
    v6 = operator new();
    *(_OWORD *)v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_DWORD *)(v6 + 32) = 1065353216;
    StFirstPopulationLock::sMutexes = v6;
  }
  fFINode = a2.fFINode;
  v7 = std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(v6, (FINode **)a2.fFINode, (uint64_t)&std::piecewise_construct, (id **)&fFINode);
  ++*((_DWORD *)v7 + 6);
  v8 = (std::mutex *)(v7 + 32);
  os_unfair_lock_unlock(v5);
  std::mutex::lock(v8);
}

void sub_1CBC85E30(_Unwind_Exception *a1)
{
  id *v1;
  os_unfair_lock_s *v2;

  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

int *StFirstPopulationLock::MapLock(StFirstPopulationLock *this)
{
  unsigned __int8 v1;

  {
    StFirstPopulationLock::MapLock(void)::sMapLock = 0;
  }
  return &StFirstPopulationLock::MapLock(void)::sMapLock;
}

void TFSInfoSynchronizer::~TFSInfoSynchronizer(id *this)
{
  void **v2;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(this + 4));

  v2 = this;
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void TFSInfoSynchronizer::TFSInfoSynchronizer(TFSInfoSynchronizer *this, const TNodePtr *a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;

  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  objc_storeStrong((id *)this + 3, a2->fFINode);
  v4 = TNodeFromFINode(a2->fFINode);
  v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  v6 = *(_QWORD *)(v4 + 24);
  *(_QWORD *)&v12 = *(_QWORD *)(v4 + 16);
  *((_QWORD *)&v12 + 1) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  os_unfair_lock_unlock(v5);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 32, &v12);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_1CBC85FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  void **v9;
  uint64_t v10;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v10);

  a9 = v9;
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t TBlockingEventQueue::Tickle(TBlockingEventQueue *this)
{
  uint64_t v1;
  char *v2;
  uint64_t v4;

  v2 = (char *)this + 208;
  v1 = *((_QWORD *)this + 26);
  v4 = *((_QWORD *)v2 + 1);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v1 + 48))(v1, &v4);
}

uint64_t TPropertyReference::SetAs<long long>(uint64_t a1, _QWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_48;
      goto LABEL_45;
    case 2:
      if (v2 != 2)
        goto LABEL_48;
      goto LABEL_45;
    case 3:
      if (v2 != 3)
        goto LABEL_48;
      goto LABEL_45;
    case 4:
      if (v2 != 4)
        goto LABEL_48;
      goto LABEL_45;
    case 5:
      if (v2 != 5)
        goto LABEL_48;
      result = 0;
      **(_QWORD **)a1 = *a2;
      break;
    case 6:
      if (v2 != 6)
        goto LABEL_48;
      goto LABEL_45;
    case 7:
      if (v2 != 7)
        goto LABEL_48;
      goto LABEL_45;
    case 8:
      if (v2 != 8)
        goto LABEL_48;
      goto LABEL_45;
    case 9:
      if (v2 != 9)
        goto LABEL_48;
      goto LABEL_45;
    case 10:
      if (v2 != 10)
        goto LABEL_48;
      goto LABEL_45;
    case 11:
      if (v2 != 11)
        goto LABEL_48;
      goto LABEL_45;
    case 12:
      if (v2 != 12)
        goto LABEL_48;
      goto LABEL_45;
    case 13:
      if (v2 != 13)
        goto LABEL_48;
      goto LABEL_45;
    case 14:
      if (v2 != 14)
        goto LABEL_48;
      goto LABEL_45;
    case 15:
      if (v2 != 15)
        goto LABEL_48;
      goto LABEL_45;
    case 16:
      if (v2 != 16)
        goto LABEL_48;
      goto LABEL_45;
    case 17:
      if (v2 != 17)
        goto LABEL_48;
      goto LABEL_45;
    case 18:
      if (v2 != 18)
        goto LABEL_48;
      goto LABEL_45;
    case 19:
      if (v2 != 19)
        goto LABEL_48;
      result = TPropertyValue::SetAs<long long>(*(_QWORD *)a1, a2);
      break;
    case 20:
      if (v2 != 20)
        goto LABEL_48;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_48;
      goto LABEL_47;
    case 22:
      if (v2 == 22)
        goto LABEL_45;
      goto LABEL_48;
    case 23:
      if (v2 != 23)
LABEL_48:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_45:
      result = 4294959246;
      break;
  }
  return result;
}

void TConditionVariable::Signal(TConditionVariable *this)
{
  std::mutex *v2;

  *((_DWORD *)this + 16) = 0;
  v2 = (std::mutex *)*((_QWORD *)this + 6);
  std::mutex::lock(v2);
  std::mutex::unlock(v2);
  std::condition_variable::notify_all((std::condition_variable *)this);
}

void TReferenceCounted::~TReferenceCounted(TReferenceCounted *this)
{
  uint64_t v2;
  TReferenceCounted *v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 6);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 48))(v2, &v5);
  v3 = (TReferenceCounted *)*((_QWORD *)this + 6);
  if (v3 == (TReferenceCounted *)((char *)this + 24))
  {
    v4 = 4;
    v3 = (TReferenceCounted *)((char *)this + 24);
  }
  else
  {
    if (!v3)
      return;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
}

uint64_t TReferenceCounted::TReferenceCounted<TDSNotifier *>(uint64_t a1, int a2, uint64_t a3)
{
  *(_DWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 24) = &off_1E8750028;
  *(_QWORD *)(a1 + 48) = a1 + 24;
  if (a3)
    TRefCount::Retain<int>((unsigned int *)(a3 + 36));
  return a1;
}

void sub_1CBC862BC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;

  v3 = v2;
  v5 = *(_QWORD **)(v3 + 48);
  if (v5 == v1)
  {
    v6 = 4;
  }
  else
  {
    if (!v5)
      goto LABEL_6;
    v6 = 5;
    v1 = v5;
  }
  (*(void (**)(_QWORD *))(*v1 + 8 * v6))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t TReferenceCounted::Make<TDSNotifier *>@<X0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;

  v6 = operator new();
  result = TReferenceCounted::TReferenceCounted<TDSNotifier *>(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1CBC86354(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x10A0C40554B57A3);
  _Unwind_Resume(a1);
}

BOOL TReferenceCounted::RemovePtrReference(TReferenceCounted *this)
{
  _BOOL8 result;

  result = TRefCount::Release<int>((unsigned int *)this + 4);
  if (this && result)
  {
    TReferenceCounted::~TReferenceCounted(this);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

void TFSInfoOverflow::TakeFolderSizeRecord(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  v6 = *a2;
  *a2 = v5;
  if (v6)
    MEMORY[0x1D17A53D0](v6, 0x1000C40E0EAB150);
  os_unfair_lock_unlock(v4);
}

uint64_t TPropertyValue::TPropertyValue<TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(a1, (TReferenceCounted **)a1, a2);
  return a1;
}

void sub_1CBC86458(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::SetAs<SYDocumentAttributes * {__strong}>(id *location, id *a2)
{
  int v2;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},SYDocumentAttributes * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

id *TNodeEventPtrs::AddEvents(id **this, id **a2)
{
  return std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>,std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>((uint64_t)this, this[1], *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 4);
}

void TNodeIterator::TNodeIterator(TNodeIterator *this, const TNodePtr *a2, int a3)
{
  void ***v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  void **v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  int IsIndexSorted;
  unint64_t *v13;
  unint64_t v14;
  int *begin;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v20;
  unint64_t v21;
  unsigned int v22;
  TNode *v23;
  std::vector<int> v24;
  void **v25;
  void **v26;
  _BYTE v27[24];
  void *__p[3];
  _QWORD *v29[3];

  *((_OWORD *)this + 1) = 0u;
  v5 = (void ***)((char *)this + 16);
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  objc_storeStrong((id *)this, a2->fFINode);
  *((_DWORD *)this + 11) = 0;
  *((_BYTE *)this + 40) = 0;
  if (TNodeFromFINode(*(FINode **)this))
  {
    v6 = TNodeFromFINode(*(FINode **)this);
    v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v6);
    os_unfair_lock_lock(v7);
    v9 = *(void ***)(v6 + 16);
    v8 = *(std::__shared_weak_count **)(v6 + 24);
    v25 = v9;
    v26 = (void **)&v8->__vftable;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v7);
    IsIndexSorted = TFSInfo::IsIndexSorted((TFSInfo *)v9);
    if (v8)
    {
      v13 = (unint64_t *)&v8->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    TNodeIterator::GetVisibleChildrenAndSortProperties((const TNodePtr *)this, IsIndexSorted, a3, (uint64_t)&v25);
    if (IsIndexSorted)
    {
      memset(&v24, 0, sizeof(v24));
      std::vector<int>::resize(&v24, v26 - v25);
      begin = v24.__begin_;
      if (v26 != v25)
      {
        v16 = 0;
        v17 = v26 - v25;
        do
        {
          begin[v16] = v16;
          ++v16;
        }
        while (v17 > v16);
      }
      v18 = 126 - 2 * __clz(v24.__end_ - begin);
      v29[0] = &v25;
      v29[1] = __p;
      v29[2] = v27;
      if (v24.__end_ == begin)
        v19 = 0;
      else
        v19 = v18;
      std::__introsort<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,false>((unint64_t)begin, v24.__end_, v29, v19, 1);
      std::vector<TNodePtr>::resize(v5, v26 - v25);
      v20 = v25;
      if (v26 != v25)
      {
        v21 = 0;
        v22 = 1;
        do
        {
          objc_storeStrong(&(*v5)[v21], v20[v24.__begin_[v21]]);
          v21 = v22;
          v20 = v25;
          ++v22;
        }
        while (v21 < v26 - v25);
      }
      if (v24.__begin_)
      {
        v24.__end_ = v24.__begin_;
        operator delete(v24.__begin_);
      }
    }
    else if (v5 != &v25)
    {
      std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((uint64_t)v5, v25, v26, v26 - v25);
    }
    v23 = (TNode *)TNodeFromFINode(*(FINode **)this);
    *((_BYTE *)this + 40) = TNode::IsPopulated(v23);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v29[0] = v27;
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)v29);
    v29[0] = &v25;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)v29);
  }
  *((_QWORD *)this + 1) = *((_QWORD *)this + 2);
}

{
  TNodeIterator::TNodeIterator(this, a2, a3);
}

void sub_1CBC86848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  id *v13;

  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);

  _Unwind_Resume(a1);
}

void TNodeIterator::First(TNodeIterator *this@<X0>, TNodePtr *a2@<X8>)
{
  *((_QWORD *)this + 1) = *((_QWORD *)this + 2);
  TNodeIterator::Next(this, a2);
}

void TFSVolumeInfo::~TFSVolumeInfo(TFSVolumeInfo *this)
{
  _QWORD v2[5];
  void **v3;

  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3321888768;
  v2[2] = ___ZN13TFSVolumeInfoD2Ev_block_invoke;
  v2[3] = &__block_descriptor_33_ea8_32c31_ZTSKZN13TFSVolumeInfoD1EvE3__0_e5_v8__0l;
  dispatch_async(MEMORY[0x1E0C80D38], v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 52);
  if (*((_BYTE *)this + 408))
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 50);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 49);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 352);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 336);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 320);
  if (*((_BYTE *)this + 304))
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 37);
  TDSMutex::~TDSMutex((TDSMutex *)((char *)this + 224));
  if (*((_BYTE *)this + 216))
  {
    v3 = (void **)((char *)this + 192);
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 10);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)this + 5);
  if (*((_BYTE *)this + 32))
  {
    if (*((char *)this + 23) < 0)
      operator delete(*(void **)this);
  }
}

uint64_t TFSVolumeInfo::ShouldRecordIterationTimes(TFSVolumeInfo *this)
{
  if (TFSVolumeInfo::LoadPrefs(void)::once != -1)
    dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_15);
  return TFSVolumeInfo::gTimeIterations;
}

uint64_t TFSVolumeInfo::ShouldSkipLSProperties(TFSVolumeInfo *this)
{
  if (TFSVolumeInfo::LoadPrefs(void)::once != -1)
    dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_15);
  return TFSVolumeInfo::gSkipLSProperties;
}

uint64_t TFSVolumeInfo::ReadHiddenListFile(TFSVolumeInfo *this)
{
  uint64_t result;
  TFSInfo *v3;
  char __dst[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = TFSVolumeInfo::MayHaveHiddenList(this);
  if ((_DWORD)result)
  {
    TDSMutex::lock((TDSMutex *)((char *)this + 224));
    if (!*((_BYTE *)this + 288))
    {
      v3 = (TFSInfo *)*((_QWORD *)this + 7);
      if (v3)
      {
        if (!TFSInfo::CopyPathToCBuffer(v3, __dst, 1024)
          && strlcat(__dst, "/.hidden", 0x400uLL) <= 0x3FF)
        {
          ReadHiddenList((uint64_t)this + 192, __dst);
        }
        *((_BYTE *)this + 288) = 1;
      }
    }
    return TDSMutex::unlock((TDSMutex *)((char *)this + 224));
  }
  return result;
}

void sub_1CBC86B0C(_Unwind_Exception *a1)
{
  TDSMutex *v1;

  TDSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GarbageCollect(TFSVolumeInfo *this)
{
  _QWORD *VolumeMap;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  _BYTE v5[24];

  VolumeMap = (_QWORD *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  v2 = (_QWORD *)VolumeMap[2];
  if (v2)
  {
    do
    {
      while (1)
      {
        v3 = v2[5];
        if (!v3 || *(_QWORD *)(v3 + 8) == -1)
          break;
        v2 = (_QWORD *)*v2;
        if (!v2)
          goto LABEL_7;
      }
      v4 = (_QWORD *)*v2;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(VolumeMap, v2, (uint64_t)v5);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)v5, 0);
      v2 = v4;
    }
    while (v4);
  }
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
}

void TChildrenList::StartCollectionStatusObserver(uint64_t a1, void *a2, uint64_t a3, void *a4, int a5)
{
  TChildrenList *v9;
  os_unfair_lock_s *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  id v14;

  v14 = a2;
  v9 = a4;
  v10 = (os_unfair_lock_s *)TChildrenList::InternalLock(v9);
  os_unfair_lock_lock(v10);
  v11 = *(void **)(a1 + 104);
  if (a5)
  {
    if (!v11)
      goto LABEL_9;
    goto LABEL_5;
  }
  if (v11)
  {
LABEL_5:
    objc_msgSend(v11, "stopObserving");
    if (a5)
      objc_msgSend(*(id *)(a1 + 104), "resetError");
    goto LABEL_8;
  }
  v12 = objc_opt_new();
  v13 = *(void **)(a1 + 104);
  *(_QWORD *)(a1 + 104) = v12;

LABEL_8:
  objc_msgSend(*(id *)(a1 + 104), "startObserving:forParent:withQueue:", v14, a3, v9);
LABEL_9:
  os_unfair_lock_unlock(v10);

}

void sub_1CBC86C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void TChildrenList::SetNSProgressSubscriber(TChildrenList *this, objc_object *a2)
{
  objc_object *v4;

  v4 = a2;
  TDSMutex::lock((TDSMutex *)this);
  objc_storeStrong((id *)this + 21, a2);
  TDSMutex::unlock((TDSMutex *)this);

}

void sub_1CBC86D04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

TChildrenList *TChildrenList::SetLastSyncDuration(TChildrenList *this, uint64_t a2)
{
  *((_QWORD *)this + 14) = a2;
  return this;
}

void TChildrenList::ReplaceChildrenWith(uint64_t a1, void ***a2, int a3)
{
  uint64_t v6;
  FINode **v7;
  FINode **v8;
  uint64_t v9;
  TNode *v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  TNodePtr v16;

  v7 = *(FINode ***)(a1 + 64);
  v8 = *(FINode ***)(a1 + 72);
  v6 = a1 + 64;
  if (v7 == v8)
  {
    v12 = *(_QWORD *)(a1 + 64);
  }
  else
  {
    do
    {
      v9 = TNodeFromFINode(*v7);
      TNodePtr::TNodePtr(&v16, 0);
      v11 = (os_unfair_lock_s *)TNode::ParentLock(v10);
      os_unfair_lock_lock(v11);
      *(_QWORD *)(v9 + 48) = TNodeFromFINode(v16.fFINode);
      os_unfair_lock_unlock(v11);

      ++v7;
    }
    while (v7 != v8);
    v7 = *(FINode ***)(a1 + 64);
    v12 = *(_QWORD *)(a1 + 72);
  }
  v13 = v12 - (_QWORD)v7;
  std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>(v6, *a2, a2[1], a2[1] - *a2);
  v14 = *(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64);
  if (a3)
    v15 = v14 >> 3;
  else
    v15 = 0;
  *(_QWORD *)(a1 + 152) = v15;
  if (v13 != v14)
  {
    atomic_store(v14 >> 3, (unint64_t *)(a1 + 160));
    ++*(_DWORD *)(a1 + 184);
  }
}

void sub_1CBC86E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

TChildrenList *TChildrenList::SetLastSyncTime(TChildrenList *this, uint64_t a2)
{
  *((_QWORD *)this + 15) = a2;
  return this;
}

int *TChildrenList::InternalLock(TChildrenList *this)
{
  unsigned __int8 v1;

  {
    TChildrenList::InternalLock(void)::sChildrenListsLock = 0;
  }
  return &TChildrenList::InternalLock(void)::sChildrenListsLock;
}

const void **TBusyFolders::StartObservingDirectory(TBusyFolders *this, const TString *a2, char a3)
{
  NSObject *v6;
  __CFString *v8;
  char v9;
  _QWORD block[5];
  TString v11;
  char v12;

  v6 = (id)gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders23StartObservingDirectoryERK7TStringb_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c63_ZTSKZN12TBusyFolders23StartObservingDirectoryERK7TStringbE3__0_e5_v8__0l;
  v8 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&v8, (TString *)a2->fString.fRef);
  v9 = a3;
  block[4] = this;
  v11.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v11, (TString *)v8);
  v12 = v9;
  dispatch_async(v6, block);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
}

void sub_1CBC86F84(_Unwind_Exception *a1)
{
  void *v1;
  const void **v2;
  const void **v3;
  const void **v4;

  v4 = v3;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

uint64_t TFSIterator::TFSIterator(uint64_t a1, CFTypeRef cf, CFTypeRef a3, int a4, char a5)
{
  TString *v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  BOOL v12;
  CFTypeRef cf1;

  *(_QWORD *)a1 = cf;
  if (cf)
    CFRetain(cf);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 16) = 0;
  if (a3)
    CFRetain(a3);
  *(_DWORD *)(a1 + 32) = a4;
  *(_BYTE *)(a1 + 36) = a5;
  *(_BYTE *)(a1 + 37) = 1;
  objc_msgSend(*(id *)a1, "path");
  v9 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  cf1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&cf1, v9);

  if ((v10 & 1) == 0
  {
    TString::TString((TString *)&TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternal, "/private/var/mobile/Library/LiveFiles", 0x25uLL);
  }
  if ((v11 & 1) == 0
  {
    TString::operator+((const __CFString **)&TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternal, (const __CFString *)"/", &TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternalPrefix);
  }
  if (CFEqual(cf1, (CFTypeRef)TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternal))
    v12 = 0;
  else
    v12 = !TString::BeginsWith((TString *)&cf1, &TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternalPrefix);
  *(_BYTE *)(a1 + 37) = v12;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return a1;
}

void sub_1CBC87150(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void **v2;
  const void **v3;
  const void **v4;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v4);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(v3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v2);
  _Unwind_Resume(a1);
}

const void **TFSIterator::Reset(const void **this)
{
  const void **v1;
  const void *v2;

  if (*this)
  {
    v1 = this;
    v2 = (const void *)MEMORY[0x1D17A4DF4](0, *this, this[2], this[3]);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v1 + 1, v2);
    return TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(&v2);
  }
  return this;
}

void sub_1CBC87228(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSIterator::First(uint64_t a1, uint64_t a2)
{
  TFSIterator::Reset((const void **)a1);
  if (*(_QWORD *)(a1 + 8))
    return TFSIterator::Next(a1, a2);
  else
    return 4294965879;
}

void TDSNotifier::HandleDeferredTickle(TDSNotifier *this)
{
  unint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(*(_QWORD *)this + 40);
  TBlockingEventQueue::EventQueueFromID(v2, &v9);
  v4 = v9;
  v3 = v10;
  if (!v10)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if (!v4)
      return;
  }
  else
  {
LABEL_5:
    if (!v4)
      return;
  }
  TickleLock();
  os_unfair_lock_lock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
  *((_BYTE *)this + 60) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
  v7 = *(_QWORD *)this;
  v9 = v2;
  v8 = *(_QWORD *)(v7 + 80);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)v8 + 48))(v8, &v9);
}

void TNodeEvent::CreatePropertyChangedNodeEvent(id *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  TNodeEvent::CreateNodeEvent(2, a1, a2, a3);
}

Class initSYDocumentAttributes(void)
{
  Class Class;

  if (SynapseLibrary(void)::frameworkLibrary
    || (SynapseLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/Synapse.framework/Synapse", 2)) != 0)
  {
    Class = objc_getClass("SYDocumentAttributes");
    classSYDocumentAttributes = (uint64_t)Class;
    getSYDocumentAttributesClass = (uint64_t (*)(void))SYDocumentAttributesFunction;
  }
  else
  {
    Class = (Class)classSYDocumentAttributes;
  }
  return Class;
}

Class initSYDocumentWorkflows(void)
{
  Class Class;

  if (SynapseLibrary(void)::frameworkLibrary
    || (SynapseLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/Synapse.framework/Synapse", 2)) != 0)
  {
    Class = objc_getClass("SYDocumentWorkflows");
    classSYDocumentWorkflows = (uint64_t)Class;
    getSYDocumentWorkflowsClass = (uint64_t (*)(void))SYDocumentWorkflowsFunction;
  }
  else
  {
    Class = (Class)classSYDocumentWorkflows;
  }
  return Class;
}

{
  Class Class;

  if (SynapseLibrary(void)::frameworkLibrary
    || (SynapseLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/Synapse.framework/Synapse", 2)) != 0)
  {
    Class = objc_getClass("SYDocumentWorkflows");
    classSYDocumentWorkflows = (uint64_t)Class;
    getSYDocumentWorkflowsClass = (uint64_t (*)(void))SYDocumentWorkflowsFunction;
  }
  else
  {
    Class = (Class)classSYDocumentWorkflows;
  }
  return Class;
}

unsigned int *RetainNotifier(unsigned int *a1)
{
  TDSNotifier *v3;

  if (a1)
    TRefCount::Retain<int>(a1 + 9);
  v3 = 0;
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v3);
  return a1;
}

id objc_cast<FPExtensionCollection,FPItemCollection * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

const void *cf_cast<__CFDictionary const*,void const*>(const void *result)
{
  const void *v1;
  CFTypeID v2;
  CFTypeID v3;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFDictionaryGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

id DSFileServiceXPCInterface(void)
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", &unk_1EF9C0B10);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = (void *)MEMORY[0x1E0C99E60];
  v5[0] = objc_opt_class();
  v5[1] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v5, 2);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setWithArray:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v3, sel_inProgressOperationsWithReply_, 0, 1);

  return v0;
}

void sub_1CBC87660(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t URLMightBeInFileProvider(uint64_t result)
{
  if (result)
  {
    result = UseFileProviderFramework();
    if ((_DWORD)result)
      return FPURLMightBeInFileProvider() != 0;
  }
  return result;
}

uint64_t NodeNewSortedIterator(TNode *a1, OpaqueNodeRef *a2, uint64_t a3, unsigned int a4)
{
  TNode *v6;
  const TNode *v7;
  uint64_t result;
  TNodeIterator *v9;
  uint64_t v10;

  v10 = a3;
  if (!a2)
    return 4294959224;
  *(_QWORD *)a2 = 0;
  v6 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  if (TNode::WeakValidate(v6, v7))
    return 4294959224;
  v9 = 0;
  result = TNode::NewNodeIterator((uint64_t)v6, &v9, &v10, a4);
  if (!(_DWORD)result)
    *(_QWORD *)a2 = v9;
  return result;
}

uint64_t IsEnhancedAPFSEnabled(void)
{
  return 1;
}

const void *CopyURLForFPItem(FPItem *a1, int a2)
{
  FPItem *v3;
  void *v4;
  void *v5;
  const void *v6;
  const void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  dispatch_semaphore_t v10;
  void *v11;
  unint64_t v12;
  NSObject *v13;
  FPItem *v14;
  unint64_t v15;
  NSObject *v16;
  FPItem *v17;
  unint64_t v18;
  dispatch_time_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  NSObject *v27;
  FPItem *v28;
  uint64_t v29;
  _QWORD v30[5];
  std::__shared_weak_count *v31;
  NSObject *v32;
  FPItem *v33;
  char v34;
  id *v35;
  std::__shared_weak_count *v36;

  v3 = a1;
  if (!v3)
    goto LABEL_26;
  FPItemManagerInstance();
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v4)
    goto LABEL_26;
  -[FPItem fileURL](v3, "fileURL");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    -[FPItem fileURL](v3, "fileURL");
    v6 = (const void *)objc_claimAutoreleasedReturnValue();
    v7 = static_cf_cast<__CFString const*,void const*>(v6);
    goto LABEL_27;
  }
  if (!a2)
  {
LABEL_26:
    v7 = 0;
    goto LABEL_27;
  }
  v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750928;
  v8[1].__vftable = 0;
  v35 = (id *)&v8[1].__vftable;
  v36 = v8;
  v10 = dispatch_semaphore_create(0);
  FPItemManagerInstance();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v30[0] = MEMORY[0x1E0C809B0];
  v30[1] = 3321888768;
  v30[2] = ___Z16CopyURLForFPItemP6FPItemb_block_invoke;
  v30[3] = &__block_descriptor_72_ea8_32c38_ZTSKZ16CopyURLForFPItemP6FPItembE3__0_e27_v24__0__NSURL_8__NSError_16l;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  v13 = v10;
  v27 = v13;
  v14 = v3;
  v28 = v14;
  LOBYTE(v29) = a2;
  v30[4] = v8 + 1;
  v31 = v8;
  do
    v15 = __ldxr(p_shared_owners);
  while (__stxr(v15 + 1, p_shared_owners));
  v16 = v13;
  v32 = v16;
  v17 = v14;
  v33 = v17;
  v34 = a2;
  objc_msgSend(v11, "fetchURLForItem:creatingPlaceholderIfMissing:completionHandler:", v17, 1, v30, &v8[1], v8, v27, v28, v29);

  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }

  v19 = dispatch_time(0, 1000000000);
  v7 = 0;
  if (!dispatch_semaphore_wait(v16, v19))
    v7 = static_cf_cast<__CFString const*,void const*>(*v35);

  v20 = v31;
  if (v31)
  {
    v21 = (unint64_t *)&v31->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  v23 = v36;
  if (v36)
  {
    v24 = (unint64_t *)&v36->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
LABEL_27:

  return v7;
}

void sub_1CBC879DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;

  CopyURLForFPItem(FPItem *,BOOL)::$_0::~$_0(v3);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v4 - 96);
  _Unwind_Resume(a1);
}

__CFString *SanitizedStr(TString *a1)
{
  id v3;
  id v4;

  if (!IsRedactionEnabled())
    return objc_retainAutorelease(a1->fString.fRef);
  AcceptableNames();
  if (std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(AcceptableNames(void)::sNames, a1))
  {
    return objc_retainAutorelease(a1->fString.fRef);
  }
  RedactedStr(a1, (TString *)&v4);
  v3 = objc_retainAutorelease(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4);
  return (__CFString *)v3;
}

TString *Description@<X0>(int a1@<W0>, TString *a2@<X8>)
{
  return ((TString *(*)(TString *))((char *)sub_1CBC87AE0 + 4 * byte_1CBD12F13[a1]))(a2);
}

TString *sub_1CBC87AE0(TString *a1)
{
  return TString::TString(a1, "non virtual", 0xBuLL);
}

TString *sub_1CBC87C80(TString *a1)
{
  return TString::TString(a1, "Network sidebar", 0xFuLL);
}

uint64_t NodeRegisterChangeNotification(TNode *a1, OpaqueNodeRef *a2, uint64_t a3)
{
  uint64_t v3;
  TNode *v7;
  const TNode *v8;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v3 = 4294959224;
  if (a1)
  {
    if (a2)
    {
      v7 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
      v3 = TNode::WeakValidate(v7, v8);
      if (!(_DWORD)v3)
      {
        -[TNode registeringChangeNotification:](a1, "registeringChangeNotification:", a3);
        ClientNotifierFromNodeNotifier((OpaqueEventNotifier *)a2, &v13);
        if (v13)
          v3 = TNode::RegisterChangeNotification(v7, (TDSNotifier *)&v13, a3);
        else
          v3 = 4294959224;
        v10 = v14;
        if (v14)
        {
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            v12 = __ldaxr(p_shared_owners);
          while (__stlxr(v12 - 1, p_shared_owners));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
    }
  }
  return v3;
}

void sub_1CBC87D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t NodeNewChangeHandlerOnQueue(uint64_t a1, void *a2, void *a3)
{
  unint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD v8[3];
  unint64_t v9;
  std::__shared_weak_count *v10;

  memset(v8, 0, sizeof(v8));
  TClientChangeNotifier::Make(v8, a1, 0, a3, a2, (uint64_t)&v9);
  v3 = v9;
  AddToNodeChangeNotifierRegistry(v9, (uint64_t *)&v9);
  v4 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

void sub_1CBC87E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL NodeIteratorFullyPopulated(uint64_t a1)
{
  return !a1 || *(_BYTE *)(a1 + 40) != 0;
}

TNodeIterator *NodeIteratorFirst(TNodeIterator *this)
{
  TNodeIterator *v1;
  uint64_t v2;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  TNodePtr v14;
  TNodePtr v15;

  v1 = this;
  if (this)
  {
    TNodeIterator::First(this, &v15);
    while (TNodeFromFINode(v15.fFINode))
    {
      v2 = TNodeFromFINode(v15.fFINode);
      v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
      os_unfair_lock_lock(v3);
      v5 = *(_QWORD *)(v2 + 16);
      v4 = *(std::__shared_weak_count **)(v2 + 24);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v3);
      v8 = (os_unfair_lock_s *)(v5 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
      v9 = *(unsigned __int16 *)(v5 + 119);
      v10 = *(unsigned int *)(v5 + 115);
      os_unfair_lock_unlock(v8);
      if (v4)
      {
        v11 = (unint64_t *)&v4->__shared_owners_;
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      if (((v10 | (v9 << 32)) & 0x100000000) == 0)
        break;
      TNodeIterator::Next(v1, &v14);
      TNodePtr::operator=((void **)&v15.fFINode, (void **)&v14.fFINode);

    }
    v1 = (TNodeIterator *)TNodePtr::CopyAsNodeRef(&v15);

  }
  return v1;
}

void sub_1CBC87F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t NodeDisposeIterator(uint64_t result)
{
  id *v1;
  void **v2;

  if (result)
  {
    v1 = (id *)result;
    v2 = (void **)(result + 16);
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v2);

    return MEMORY[0x1D17A53D0](v1, 0x10E0C40DDD8502FLL);
  }
  return result;
}

void sub_1CBC88054(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC8822C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  objc_sync_exit(v3);
  _Unwind_Resume(a1);
}

void sub_1CBC88344(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<OpaqueNodeRef *,TRetainReleasePolicy<OpaqueNodeRef *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBC883A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FINodeIterator;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1CBC884F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC885CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC8863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC887DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  void *v14;
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1CBC88960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1CBC88A40(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a10);
  _Unwind_Resume(a1);
}

void sub_1CBC88FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;
  std::mutex *v30;

  std::mutex::unlock(v30);

  _Unwind_Resume(a1);
}

void sub_1CBC8934C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  void *v30;
  void *v31;
  void *v32;

  TNode::StPopulating::~StPopulating((TNode::StPopulating *)&a10);
  _Unwind_Resume(a1);
}

void sub_1CBC895E0(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  void *v13;

  TPropertyValue::~TPropertyValue((TPropertyValue *)&a13);

  _Unwind_Resume(a1);
}

void sub_1CBC898B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC89B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18, id a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1CBC89E60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  objc_sync_exit(v3);
  _Unwind_Resume(a1);
}

void sub_1CBC8A020(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1CBC8A12C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1CBC8A210(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC8A2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1CBC8A3FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c54_ZTSKZ41__FILocalStorageNode_fetchFPItemIfNeeded_E3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c54_ZTSKZ41__FILocalStorageNode_fetchFPItemIfNeeded_E3__0(uint64_t a1)
{

}

void sub_1CBC8A62C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FILocalAppContainerCollection;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void sub_1CBC8A744(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC8A7F8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1CBC8A8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1CBC8A958(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC8A9D8(_Unwind_Exception *a1)
{
  void *v1;
  std::mutex *v2;

  std::mutex::unlock(v2);

  _Unwind_Resume(a1);
}

void sub_1CBC8AC84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC8B4AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::mutex *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  void *v43;
  uint64_t v44;

  TNodeEventPtr::~TNodeEventPtr((id *)(v44 - 240));

  std::mutex::unlock(a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&STACK[0x238]);

  STACK[0x238] = (unint64_t)&a26;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x238]);

  TNode::StPopulating::~StPopulating((TNode::StPopulating *)&a31);
  StDefer<-[FILocalAppContainerCollection populate]::$_1,(void *)0>::~StDefer((id *)&a38);

  a38 = (uint64_t)&a43;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a38);
  _Unwind_Resume(a1);
}

void sub_1CBC8B89C(_Unwind_Exception *a1)
{
  void *v1;
  std::mutex *v2;

  std::mutex::unlock(v2);

  _Unwind_Resume(a1);
}

void sub_1CBC8B918(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1CBC8BB50(_Unwind_Exception *a1)
{
  std::mutex *v1;
  void *v2;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c75_ZTSKZ62__FILocalAppContainerCollection_synchronizeWithOptions_async__E3__4(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c75_ZTSKZ62__FILocalAppContainerCollection_synchronizeWithOptions_async__E3__4(uint64_t a1)
{

}

void sub_1CBC8BE10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1CBC8BEB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)FILocalAppContainerNode;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1CBC8BFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBC8C294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  id *v4;
  id v6;
  va_list va;
  id v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, id);
  v8 = va_arg(va1, id);
  v9 = va_arg(va1, _QWORD);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  TNodeEventPtr::~TNodeEventPtr(v4);

  TNodeEventPtr::~TNodeEventPtr((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1CBC8C3D4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1CBC8C494(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBC8C780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

id objc_cast<FILocalAppContainerNode,FIDSNode * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

id objc_cast<FINode_ICloudAppLibrary,FIDSNode * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

void sub_1CBC8C9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  objc_sync_exit(v10);

  _Unwind_Resume(a1);
}

void sub_1CBC8CA40(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1CBC8CB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBC8CD30(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBC8CDF0(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableSet<FILocalAppContainerNode *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBC8CE6C(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(uint64_t a1)
{

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));

}

void std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (id *)*v2);
    operator delete(**a1);
  }
}

void std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, id *a2)
{
  id *v4;
  id *v5;
  id *v6;
  void *v7;
  BOOL v8;

  v4 = *(id **)(a1 + 8);
  if (v4 != a2)
  {
    v5 = v4 - 1;
    do
    {
      TNodeEventPtr::~TNodeEventPtr(v5);
      v7 = *(v5 - 1);
      v6 = v5 - 1;

      v8 = v6 == a2;
      v5 = v6 - 1;
    }
    while (!v8);
  }
  *(_QWORD *)(a1 + 8) = a2;
}

uint64_t TDSNotifier::Make@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t result;

  v8 = operator new();
  result = TDSNotifier::TDSNotifier(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1CBC8D038(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x10A0C40FAC576B1);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

uint64_t std::unique_lock<TDSMutex>::~unique_lock[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    TDSMutex::unlock(*(TDSMutex **)a1);
  return a1;
}

void sub_1CBC8D1F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC8D274(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC8D3C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBC8D660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

id archiveServiceConnection(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = a1;
  v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3B38]), "initWithServiceName:", CFSTR("com.apple.desktopservices.ArchiveService"));
  DSArchiveServiceXPCInterface();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setRemoteObjectInterface:", v3);

  DSArchiveServiceStreamingXPCInterface();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setExportedInterface:", v4);

  objc_msgSend(v2, "setExportedObject:", v1);
  objc_msgSend(v2, "setInterruptionHandler:", &__block_literal_global_112);

  return v2;
}

void sub_1CBC8D79C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1CBC8D818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC8DF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1CBC8E0F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC8E1B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC8E230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC8E90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1CBC8EAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC8EBA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC8ED20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBC8F204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,void *a38)
{
  void *v38;

  _Unwind_Resume(a1);
}

void sub_1CBC8F344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC8F3F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1CBC8F514(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1CBC8FA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  void *v30;
  void *v31;

  _Unwind_Resume(a1);
}

void sub_1CBC8FBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC8FD50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBC8FE0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZL24archiveServiceConnectionPU44objcproto33DSArchiveServiceStreamingInternal11objc_object_block_invoke()
{
  NSObject *v0;
  uint8_t v1[16];

  LogObj(0);
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v1 = 0;
    _os_log_impl(&dword_1CBC4A000, v0, OS_LOG_TYPE_INFO, "Archive Service connection interrupted", v1, 2u);
  }

}

BOOL IsDebugLogCategoryEnabled(int a1)
{
  NSObject *v1;
  _BOOL8 v2;

  LogObj(a1);
  v1 = objc_claimAutoreleasedReturnValue();
  v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG);

  return v2;
}

id DSArchiveServiceXPCInterface()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v11[2];
  _QWORD v12[2];
  _QWORD v13[3];

  v13[2] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", &unk_1EF9C0AB0);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = (void *)MEMORY[0x1E0C99E60];
  v13[0] = objc_opt_class();
  v13[1] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v13, 2);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setWithArray:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v3, sel_archiveItemsWithURLWrappers_toURLWrapper_options_compressionFormat_passphrase_completionHandler_, 0, 0);

  v4 = (void *)MEMORY[0x1E0C99E60];
  v12[0] = objc_opt_class();
  v12[1] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v12, 2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "setWithArray:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v6, sel_archiveItemsWithURLWrappers_passphrase_addToKeychain_compressionFormat_destinationFolderURLWrapper_usePlaceholder_completionHandler_, 0, 0);

  v7 = (void *)MEMORY[0x1E0C99E60];
  v11[0] = objc_opt_class();
  v11[1] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v11, 2);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "setWithArray:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v9, sel_itemDescriptorsForItemWithURLWrapper_passphrases_completionHandler_, 0, 1);

  return v0;
}

void sub_1CBC900C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v2;

  _Unwind_Resume(a1);
}

id DSArchiveServiceStreamingXPCInterface()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", &unk_1EF9BBF68);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = (void *)MEMORY[0x1E0C99E60];
  v5[0] = objc_opt_class();
  v5[1] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v5, 2);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setWithArray:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v3, sel_receiveArchivedItemsDescriptors_, 0, 0);

  return v0;
}

void sub_1CBC90220(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void OperationsUpdatedHandler(__CFNotificationCenter *a1, void *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  id v5;

  static_objc_cast<DSFileServiceConnection,void *>(a2);
  v5 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "_triggerReloadCurrentOperations");

}

void sub_1CBC9028C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC90300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)DSFileServiceConnection;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1CBC904C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1CBC905E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC907E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, id location)
{
  void *v15;
  id *v16;
  void *v17;
  void *v18;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1CBC909F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC90A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC90B74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC90BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC90C94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC90E3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL23dsFileServiceConnectionv_block_invoke()
{
  NSLog(CFSTR("DSFileService connection interrupted"));
}

void sub_1CBC90F40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC90FCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC91040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC9111C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBC911AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9123C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC91310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC91494(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1CBC91530(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D17A53D0);
}

void sub_1CBC916C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC91788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC918D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void TOperationSizer::TOperationSizer(TOperationSizer *this, const TOperationSizer::TOperationSizerParams *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  TCloneCache *v15;
  uint64_t *v16;
  uint64_t v17;
  __int128 v18;
  CFTypeRef cf;

  *(_QWORD *)this = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  *((_QWORD *)this + 1) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  v7 = *((_QWORD *)a2 + 3);
  *((_QWORD *)this + 3) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = MEMORY[0x1D17A5A30](*((_QWORD *)a2 + 6));
  v10 = MEMORY[0x1D17A5A30](*((_QWORD *)a2 + 7));
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 7) = v10;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = *((_QWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 88) = *((_OWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 104) = *((_OWORD *)a2 + 5);
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = *((_QWORD *)a2 + 12);
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_BYTE *)this + 168) = *((_BYTE *)a2 + 121);
  *((_BYTE *)this + 169) = 0;
  *((_BYTE *)this + 170) = *((_BYTE *)a2 + 152);
  *((_BYTE *)this + 171) = *((_BYTE *)a2 + 42);
  *((_BYTE *)this + 172) = *((_BYTE *)a2 + 104);
  v11 = *((_BYTE *)a2 + 105);
  if (v11)
  {
    v12 = *(_QWORD *)a2;
    TCFURLInfo::CheckPrefetchState(*(_QWORD *)a2, 1);
    if ((*(_WORD *)(v12 + 76) & 1) != 0)
    {
      v13 = *(_QWORD *)a2;
      TCFURLInfo::CheckPrefetchState(*(_QWORD *)a2, 1);
      v11 = (*(_WORD *)(v13 + 76) & 4) == 0;
    }
    else
    {
      v11 = 0;
    }
  }
  *((_QWORD *)this + 25) = &stru_1E8752DF8;
  *((_BYTE *)this + 173) = v11;
  *((_BYTE *)this + 174) = *((_BYTE *)a2 + 106);
  *(_WORD *)((char *)this + 175) = *(_WORD *)((char *)a2 + 155);
  *((_QWORD *)this + 23) = 0;
  *((_BYTE *)this + 192) = *((_BYTE *)a2 + 120);
  *((_BYTE *)this + 193) = *((_BYTE *)a2 + 154);
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 26) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_BYTE *)this + 260) = *((_BYTE *)this + 173);
  *((_BYTE *)this + 261) = *((_BYTE *)a2 + 153);
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_QWORD *)this + 37) = 0;
  if (*((_BYTE *)a2 + 40))
  {
    v14 = operator new();
    *(_OWORD *)v14 = 0u;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_DWORD *)(v14 + 32) = 1065353216;
  }
  else
  {
    v14 = 0;
  }
  *((_QWORD *)this + 38) = v14;
  if (*((_BYTE *)a2 + 41))
  {
    v15 = (TCloneCache *)operator new();
    TCloneCache::TCloneCache(v15, 0);
  }
  else
  {
    v15 = 0;
  }
  *((_QWORD *)this + 39) = v15;
  *((_OWORD *)this + 20) = *((_OWORD *)a2 + 8);
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_QWORD *)this + 46) = 0;
  v16 = (uint64_t *)*((_QWORD *)a2 + 18);
  if (v16)
  {
    v17 = *v16;
    *((_QWORD *)this + 42) = *v16;
    v18 = *(_OWORD *)(v16 + 1);
    *(_OWORD *)((char *)this + 344) = v18;
    if (v17 && (_QWORD)v18)
      ((void (*)(void))v18)();
  }
  else
  {
    *((_QWORD *)this + 42) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 44) = 0;
  }
  if (*((_BYTE *)this + 173))
  {
    TCFURLInfo::FileSystemRepresentation(**(TCFURLInfo ***)this, (const __CFURL *)1, (TString *)&cf);
    if ((CFTypeRef *)((char *)this + 200) != &cf)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)this + 25, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  TCFURLInfo::Name(*(TCFURLInfo **)this, (TString *)&cf);
  if ((CFTypeRef *)((char *)this + 208) != &cf)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)this + 26, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1CBC91C6C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  TDeepCFURLIterator **v3;
  uint64_t v4;
  const void **v5;
  const void **v6;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1 + 360);
  std::unique_ptr<TCloneCache>::reset[abi:ne180100]((uint64_t *)(v1 + 312), 0);
  std::unique_ptr<std::unordered_set<unsigned long long>>::reset[abi:ne180100]((uint64_t *)(v1 + 304), 0);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1 + 288);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1 + 272);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v4);

  std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100](v3, 0);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void TOperationSizer::~TOperationSizer(TOperationSizer *this)
{
  void (*v2)(void);

  if (*((_QWORD *)this + 42))
  {
    v2 = (void (*)(void))*((_QWORD *)this + 44);
    if (v2)
      v2();
  }
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 360);
  std::unique_ptr<TCloneCache>::reset[abi:ne180100]((uint64_t *)this + 39, 0);
  std::unique_ptr<std::unordered_set<unsigned long long>>::reset[abi:ne180100]((uint64_t *)this + 38, 0);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 288);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 272);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 26);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 25);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);

  std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100]((TDeepCFURLIterator **)this + 4, 0);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

uint64_t TOperationSizer::ComputeSize(TOperationSizer *this)
{
  int v2;

  TOperationSizer::ComputeSizeWithTimeout(this, 0);
  v2 = *(unsigned __int8 *)(*((_QWORD *)this + 4) + 56);
  *((_BYTE *)this + 169) = v2;
  if (v2)
    *((_DWORD *)this + 40) |= 0x400u;
  return *((unsigned int *)this + 10);
}

uint64_t TOperationSizer::ComputeSizeWithTimeout(TOperationSizer *this, uint64_t a2)
{
  TCFURLInfo *v4;
  uint64_t BasicInfoPropertyKeys;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  TDeepCFURLIterator *v10;
  int v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  uint64_t v23;
  std::__shared_weak_count *v24;

  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)this + 8, (uint64_t *)this);
  TOperationSizer::UpdateSizingStats(this, 0);
  v4 = (TCFURLInfo *)IsRunningInFinder();
  if ((_DWORD)v4)
    *((_BYTE *)this + 166) = 1;
  else
    *((_BYTE *)this + 165) = 1;
  if (*((_BYTE *)this + 170))
    BasicInfoPropertyKeys = TCFURLInfo::GetBasicInfoPropertyKeys(v4);
  else
    BasicInfoPropertyKeys = TCFURLInfo::GetSizerPropertyKeys(v4);
  v6 = (const void *)BasicInfoPropertyKeys;
  v7 = *((_QWORD *)this + 38);
  v8 = *((_QWORD *)this + 39);
  v9 = operator new();
  v10 = (TDeepCFURLIterator *)v9;
  v11 = *((unsigned __int8 *)this + 170);
  v12 = *((unsigned __int8 *)this + 173);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v23 = *((_QWORD *)this + 2);
  v24 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  TDeepCFURLIterator::TDeepCFURLIterator(v9, (uint64_t)this, v11 != 0, v12 != 0, v6, 0, v7, v8, 0, 1, v11 != 0, 0, 0, &v23, 6);
  v16 = v24;
  if (v24)
  {
    v17 = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100]((TDeepCFURLIterator **)this + 4, v10);
  TOperationSizer::StartSizing(this);
  v19 = *(_QWORD *)this;
  TCFURLInfo::CheckPrefetchState(*(_QWORD *)this, 1);
  if ((*(_WORD *)(v19 + 76) & 1) != 0)
  {
    if ((TOperationSizer::ResumeSizing(this, a2) & 1) != 0)
      return 1;
  }
  else
  {
    TOperationSizer::CheckMaxFileSize((unint64_t)this, v20, v21);
    TOperationSizer::UpdateSizingStats(this, 1);
  }
  return 0;
}

void sub_1CBC91FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  uint64_t v14;

  if (a14)
    TOperationSizer::ComputeSizeWithTimeout(a14);
  MEMORY[0x1D17A53D0](v14, 0x10E0C408176880BLL);
  _Unwind_Resume(a1);
}

uint64_t TOperationSizer::UpdateSizingStats(TOperationSizer *this, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = *((_QWORD *)this + 6);
  if (result)
  {
    v4 = *((_QWORD *)this + 13);
    if (*((_BYTE *)this + 174))
    {
      v4 -= *((_QWORD *)this + 28) + *((_QWORD *)this + 31);
      v5 = *((_QWORD *)this + 12);
      v6 = *((_QWORD *)this + 11) - (*((int *)this + 55) + (uint64_t)*((int *)this + 60));
    }
    else
    {
      v6 = *((_QWORD *)this + 11);
      v5 = *((_QWORD *)this + 12);
    }
    return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(result + 16))(result, (char *)this + 64, v4, v6, v5, a2);
  }
  return result;
}

_QWORD *std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void TOperationSizer::StartSizing(TOperationSizer *this)
{
  __int128 v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  BOOL IsSuspendedCopyOfSource;
  TCFURLInfo **v10;
  void (***v11)(_QWORD, TOperationSizer *);
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;

  v16 = 0uLL;
  if (*((_BYTE *)this + 173))
  {
    TOperationSizer::MapSourceToDestination((uint64_t)this, (TCFURLInfo ***)this, (uint64_t)&v15);
    v2 = v15;
    v15 = 0uLL;
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
    v16 = v2;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
    if (*((_QWORD *)&v15 + 1))
    {
      v7 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    IsSuspendedCopyOfSource = v16;
    if ((_QWORD)v16)
      IsSuspendedCopyOfSource = TCFURLInfo::IsSuspendedCopyOfSource((TCFURLInfo **)v16, (const __CFURL ***)this, (double *)this + 23);
    *((_BYTE *)this + 174) = IsSuspendedCopyOfSource;
  }
  v10 = *(TCFURLInfo ***)this;
  TCFURLInfo::CheckPrefetchState(*(_QWORD *)this, 1);
  if ((*((_WORD *)v10 + 38) & 1) != 0)
  {
    v11 = (void (***)(_QWORD, TOperationSizer *))*((_QWORD *)this + 45);
    if (v11)
      (**v11)(v11, this);
  }
  TOperationSizer::AccumulateSize((uint64_t)this, (CFIndex *)this, 0, 0, (CFIndex *)&v16);
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
  if (*((_QWORD *)&v16 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_1CBC9224C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TOperationSizer::ResumeSizing(TOperationSizer *this, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  char v12;
  TCFURLInfo *v13;
  uint64_t v14;
  const __CFString *v15;
  TCFURLInfo *v16;
  uint64_t v17;
  uint64_t v18;
  int v21;
  uint64_t v22;
  unsigned int (*v23)(_QWORD);
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  TTime *v33;
  uint64_t v34;
  const __CFString *v35;
  _BOOL4 v36;
  int v37;
  int v38;
  uint64_t v39;
  TCFURLInfo *v41;
  std::__shared_weak_count *v42;
  CFIndex v43;
  std::__shared_weak_count *v44;
  const TCFURLInfo *v45;
  std::__shared_weak_count *v46;
  char v47;
  __int16 v48;
  int v49;
  int v50;

  v4 = TTime::MicrosecondsSinceStartup(this);
  do
  {
    v5 = (void *)MEMORY[0x1D17A5880]();
    v49 = 0;
    v50 = 0;
    v48 = 0;
    v47 = 0;
    v45 = 0;
    v46 = 0;
    v43 = 0;
    v44 = 0;
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v41);
    v6 = TDeepCFURLIterator::Next(*((_QWORD *)this + 4), &v41, &v50, &v49, (BOOL *)&v48 + 1, &v48, (uint64_t)&v43, &v47, &v45);
    v7 = v6;
    if (v6 == -8013)
    {
      v9 = *((_QWORD *)this + 45);
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    }
    else if (!v6)
    {
      if ((TOperationSizer::ShouldSkip((uint64_t *)this, &v41) & 1) != 0)
      {
        v8 = 0;
        goto LABEL_39;
      }
      if (!*((_QWORD *)this + 45))
        goto LABEL_21;
      if (v49 >= 1)
      {
        v11 = v49 + 1;
        while (--v11 >= 1)
          (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 45) + 8))(*((_QWORD *)this + 45), *(unsigned __int8 *)(*((_QWORD *)this + 4) + 112));
      }
      if (v50 >= 1
        && ((***((uint64_t (****)(_QWORD, TCFURLInfo **))this + 45))(*((_QWORD *)this + 45), &v41) & 1) != 0)
      {
        v12 = 1;
      }
      else
      {
LABEL_21:
        TOperationSizer::AccumulateSize((uint64_t)this, (CFIndex *)&v41, SHIBYTE(v48), v48, &v43);
        v12 = 0;
      }
      v13 = v41;
      TCFURLInfo::CheckPrefetchState((CFIndex)v41, 1);
      if ((*((_WORD *)v13 + 38) & 1) != 0)
      {
        v16 = v41;
        TCFURLInfo::CheckPrefetchState((CFIndex)v41, 1);
        if ((*((_WORD *)v16 + 38) & 4) == 0)
        {
          if (TCFURLInfo::IsDataless((const __CFURL **)v41, v14, v15))
          {
            v17 = *((_QWORD *)this + 45);
            if (v17)
              (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
            *((_BYTE *)this + 167) = 1;
          }
        }
      }
      if (!*((_BYTE *)this + 166)
        && TCFURLInfo::IsRootItem((TCFURLInfo **)v41, v14, v15)
        && IsRunningInFinder())
      {
        *((_BYTE *)this + 166) = 1;
        if (*((_BYTE *)this + 261))
          v7 = -8097;
        else
          v7 = 0;
        v8 = v7;
        if ((v12 & 1) == 0)
        {
LABEL_35:
          if (!HIBYTE(v48) || v50 <= 0)
            goto LABEL_42;
LABEL_40:
          TDeepCFURLIterator::PopIterator(*((_QWORD *)this + 4));
          v18 = *((_QWORD *)this + 45);
          if (v18)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 8))(v18, *(unsigned __int8 *)(*((_QWORD *)this + 4) + 112));
          goto LABEL_42;
        }
      }
      else
      {
        v7 = 0;
        v8 = 0;
        if ((v12 & 1) == 0)
          goto LABEL_35;
      }
LABEL_39:
      v7 = v8;
      if (v50 < 1)
        goto LABEL_42;
      goto LABEL_40;
    }
    if (v49 >= 1 && *((_QWORD *)this + 45))
    {
      v10 = v49 + 1;
      while (--v10 >= 1)
        (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 45) + 8))(*((_QWORD *)this + 45), *(unsigned __int8 *)(*((_QWORD *)this + 4) + 112));
    }
LABEL_42:
    if (v7 == -1417 || v7 == 0 || *((_BYTE *)this + 193) == 0)
      v21 = v7;
    else
      v21 = 0;
    if (*((_BYTE *)this + 173) && (!v21 || v21 == -1417) && v47 && v45)
    {
      ++*((_DWORD *)this + 59);
      TOperationSizer::SetFirstMergeDestinationConflict((uint64_t)this, &v45);
    }
    v22 = *((_QWORD *)this + 7);
    if (v22 && ((*(uint64_t (**)(void))(v22 + 16))() & 1) != 0
      || (v23 = (unsigned int (*)(_QWORD))*((_QWORD *)this + 41)) != 0 && v23(*((_QWORD *)this + 42)))
    {
      TDeepCFURLIterator::Cancel(*((_QWORD *)this + 4));
      v21 = -128;
    }
    v24 = v42;
    if (v42)
    {
      p_shared_owners = (unint64_t *)&v42->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = v44;
    if (v44)
    {
      v28 = (unint64_t *)&v44->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v30 = v46;
    if (v46)
    {
      v31 = (unint64_t *)&v46->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    objc_autoreleasePoolPop(v5);
    v36 = 0;
    if (a2 && !*((_BYTE *)this + 170))
      v36 = TTime::MicrosecondsSinceStartup(v33) - v4 > a2;
  }
  while (!v21 && !v36);
  TOperationSizer::CheckMaxFileSize((unint64_t)this, v34, v35);
  TOperationSizer::UpdateSizingStats(this, 1);
  if (v21)
    v37 = 1;
  else
    v37 = !v36;
  if (v37 == 1)
  {
    if (v21 == -1417)
      v38 = 0;
    else
      v38 = v21;
    *((_DWORD *)this + 10) = v38;
    if (!v38)
    {
      v39 = *((_QWORD *)this + 45);
      if (v39)
        (*(void (**)(uint64_t))(*(_QWORD *)v39 + 16))(v39);
    }
  }
  return v37 ^ 1u;
}

void sub_1CBC926B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

unint64_t TOperationSizer::CheckMaxFileSize(unint64_t this, uint64_t a2, const __CFString *a3)
{
  unint64_t v3;

  if (*(_BYTE *)(this + 170))
  {
    v3 = this;
    this = (unint64_t)TCFURLInfo::GetNumericalProperty(*(const __CFURL ***)(this + 16), (const __CFString *)*MEMORY[0x1E0C9B708], a3);
    if ((uint64_t)this >= 1 && *(_QWORD *)(v3 + 136) > this)
      *(_DWORD *)(v3 + 160) |= 0x100000u;
  }
  return this;
}

const void **TOperationSizer::MapSourceToDestination@<X0>(uint64_t a1@<X0>, TCFURLInfo ***a2@<X1>, uint64_t a3@<X8>)
{
  TString v7;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v7.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  if (TCFURLInfo::FileSystemRepresentationRelativeToSource(*a2, (const TString *)(a1 + 200), &v7))
    TCFURLInfo::CreateCFURLInfoWithFileSystemRepresentationRelativeToBase(*(TCFURLInfo **)(a1 + 16), &v7, (const __CFString **)(a1 + 208), (TString **)a3);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
}

void sub_1CBC927C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

uint64_t TOperationSizer::AccumulateSize(uint64_t a1, CFIndex *a2, char a3, char a4, CFIndex *a5)
{
  uint64_t v10;
  CFIndex v11;
  CFIndex v12;
  const __CFString *v13;
  int64_t NumericalProperty;
  const __CFString *v15;
  int64_t v16;
  CFIndex v17;
  const __CFString *v18;
  double v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  const __CFURL *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  CFIndex v29;
  uint64_t v30;
  const __CFString *v31;
  uint64_t v32;
  const __CFString *v33;
  CFIndex v34;
  CFIndex v35;
  TString *v36;
  std::__shared_weak_count *v37;
  unint64_t *p_shared_owners;
  unint64_t v39;
  CFIndex v40;
  CFIndex v41;
  TCFURLInfo *v42;
  CFIndex v43;
  int v44;
  CFIndex v45;
  CFIndex v46;
  const __CFURL *v47;
  CFIndex v48;
  int v49;
  CFIndex v50;
  uint64_t v51;
  const __CFString *v52;
  uint64_t v53;
  const __CFString *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  CFIndex v58;
  CFIndex v59;
  const __CFString *v60;
  CFIndex v61;
  unint64_t v62;
  CFIndex v63;
  unint64_t v64;
  CFIndex v65;
  CFIndex v66;
  const __CFString *v68;
  uint64_t v69;
  const __CFString *v70;
  const __CFString *v71;
  uint64_t v72;
  const __CFString *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  const __CFURL *v77;
  const __CFString *v78;
  char *v79;
  _BOOL8 v80;
  char v81;
  _BOOL4 v82;
  const __CFString *v83;
  _BOOL4 v84;
  const __CFURL *v85;
  const __CFString *v86;
  const __CFURL *v88;
  const __CFString *v89;
  const __CFURL *v90;
  BOOL v91;
  TString *v92;
  std::__shared_weak_count *v93;
  BOOL v94;

  v10 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v10 + 50) && !*(_BYTE *)(v10 + 51))
  {
    v11 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    if ((*(_WORD *)(v11 + 76) & 0x20) != 0)
      ++*(_QWORD *)(a1 + 88);
  }
  ++*(_QWORD *)(a1 + 96);
  if (!TCFURLInfo::IsTrash((TCFURLInfo *)*a2))
  {
    v12 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    if ((*(_WORD *)(v12 + 76) & 1) != 0
      || (a3 & 1) != 0
      || *(_BYTE *)(a1 + 170) && !*(_BYTE *)(a1 + 171) && (a4 & 1) != 0)
    {
      goto LABEL_33;
    }
    NumericalProperty = (int64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9B4A8], v13);
    v16 = (int64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9AC58], v15);
    *(_QWORD *)(a1 + 104) += v16 + NumericalProperty;
    v17 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    v19 = (double)NumericalProperty;
    if ((*(_WORD *)(v17 + 76) & 0x8000) != 0)
      v19 = (double)NumericalProperty * 0.48;
    v20 = (char *)(*(_QWORD *)(a1 + 120) + v16 + NumericalProperty);
    *(_QWORD *)(a1 + 112) = (uint64_t)(v19 + (double)v16 + (double)*(uint64_t *)(a1 + 112));
    *(_QWORD *)(a1 + 120) = v20;
    if (NumericalProperty < 1)
    {
LABEL_26:
      if (v16 < 1)
        goto LABEL_33;
      v26 = *(_QWORD *)(a1 + 80);
      v27 = v16;
      if (!__CFADD__(v16, v26))
      {
        if (!v26)
          goto LABEL_31;
        v27 = v16 + v26 - 1;
      }
      v26 *= v27 / v26;
LABEL_31:
      v28 = *(_QWORD *)(a1 + 136);
      *(_QWORD *)(a1 + 128) += v26;
      if (v16 > v28)
        *(_QWORD *)(a1 + 136) = v16;
LABEL_33:
      v29 = *a2;
      TCFURLInfo::CheckPrefetchState(*a2, 1);
      if ((*(_WORD *)(v29 + 76) & 1) != 0 && (a3 & 1) == 0)
        ++*(_QWORD *)(a1 + 152);
      if (TCFURLInfo::GetType((CFURLRef *)*a2) == 1651666795
        && !*(_BYTE *)(*(_QWORD *)(a1 + 32) + 50)
        && !*(_BYTE *)(a1 + 172))
      {
        *(_DWORD *)(a1 + 160) |= 0x1000u;
      }
      if (!*(_BYTE *)(a1 + 170))
        goto LABEL_104;
      v94 = 1;
      if ((TCFURLInfo::EffectiveUserCanRead((const void **)*a2, &v94) & 1) == 0)
        *(_DWORD *)(a1 + 160) |= 0x400u;
      if (TCFURLInfo::IsDataless((const __CFURL **)*a2, v30, v31) && *(_BYTE *)(a1 + 175))
        *(_DWORD *)(a1 + 160) |= 0x40000000u;
      if (*(_BYTE *)(a1 + 192) && TCFURLInfo::IsLocalVolume(*(TCFURLInfo ***)a1, v32, v33))
      {
        v92 = 0;
        v93 = 0;
        v34 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 2);
        if ((*(_WORD *)(v34 + 76) & 0x2000) != 0 && IsEqual(*(const void **)*a2, **(const void ***)a1))
          TCFURLInfo::GetParent((const void **)*a2, &v92);
        v35 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 2);
        if ((*(_WORD *)(v35 + 76) & 0x2000) == 0
          || (v36 = v92) != 0
          && (TCFURLInfo::CheckPrefetchState((CFIndex)v92, 2), (WORD2(v36[9].fString.fRef) & 0x2000) == 0))
        {
          *(_DWORD *)(a1 + 160) |= 0x400u;
        }
        v37 = v93;
        if (v93)
        {
          p_shared_owners = (unint64_t *)&v93->__shared_owners_;
          do
            v39 = __ldaxr(p_shared_owners);
          while (__stlxr(v39 - 1, p_shared_owners));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }
      }
      if (!v94
        || (v40 = *a2, TCFURLInfo::CheckPrefetchState(*a2, 2), (*(_WORD *)(v40 + 76) & 0x1000) == 0)
        || (v41 = *a2, v42 = (TCFURLInfo *)TCFURLInfo::CheckPrefetchState(*a2, 1), (*(_WORD *)(v41 + 76) & 1) != 0)
        && (v43 = *a2, v42 = (TCFURLInfo *)TCFURLInfo::CheckPrefetchState(*a2, 2), (*(_WORD *)(v43 + 76) & 0x4000) == 0)
        || (v44 = TCFURLInfo::GetgidToUse(v42), v44 != TCFURLInfo::GetUserGroups((CFURLRef *)*a2)))
      {
        *(_DWORD *)(a1 + 160) |= 0x80000000;
      }
      if (*(_BYTE *)(a1 + 168))
      {
        v45 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 1);
        if ((*(_WORD *)(v45 + 76) & 0x10) != 0)
          *(_DWORD *)(a1 + 160) |= 0x200u;
        if (*(_BYTE *)(a1 + 168))
        {
          v46 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if (((*(unsigned __int16 *)(v46 + 76) | (*(unsigned __int8 *)(v46 + 78) << 16)) & 0x20000) != 0)
            *(_DWORD *)(a1 + 160) |= 0x400u;
          if (*(_BYTE *)(a1 + 168) && TCFURLInfo::IsSystemRestrictionEffective((TCFURLInfo **)*a2, v47, v33))
            *(_DWORD *)(a1 + 160) |= 0x200u;
        }
      }
      if (!*(_BYTE *)(a1 + 173) || !*(_BYTE *)(a1 + 260))
        goto LABEL_104;
      v48 = *a2;
      if (*a5)
      {
        TCFURLInfo::CheckPrefetchState(*a2, 1);
        v49 = *(_WORD *)(v48 + 76) & 1;
        v50 = *a5;
        TCFURLInfo::CheckPrefetchState(*a5, 1);
        if (v49 != (*(_WORD *)(v50 + 76) & 1))
          *(_BYTE *)(a1 + 260) = 0;
        if (TCFURLInfo::IsDataless((const __CFURL **)*a5, v51, v52))
        {
          *(_BYTE *)(a1 + 260) = 0;
          goto LABEL_104;
        }
        if (!*(_BYTE *)(a1 + 260)
          || (v58 = *a2, TCFURLInfo::CheckPrefetchState(*a2, 1), (*(_WORD *)(v58 + 76) & 0x20) == 0))
        {
LABEL_104:
          v65 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if ((*(_WORD *)(v65 + 76) & 2) != 0)
            *(_DWORD *)(a1 + 160) |= 0x4000u;
          goto LABEL_106;
        }
        v59 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 1);
        if ((*(_WORD *)(v59 + 76) & 1) != 0)
        {
          v61 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if ((*(_WORD *)(v61 + 76) & 4) == 0)
          {
            ++*(_DWORD *)(a1 + 240);
            goto LABEL_104;
          }
        }
        v68 = (const __CFString *)*MEMORY[0x1E0C9B4A8];
        v69 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9B4A8], v60);
        v70 = (const __CFString *)*MEMORY[0x1E0C9AC58];
        v72 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9AC58], v71);
        if (v69 >= 1)
        {
          v74 = *(_QWORD *)(a1 + 80);
          if (__CFADD__(v69, v74))
          {
LABEL_114:
            v75 = v69 / v74 * v74;
            goto LABEL_116;
          }
          if (v74)
          {
            v69 = v69 + v74 - 1;
            goto LABEL_114;
          }
        }
        v75 = 0;
LABEL_116:
        if (v72 < 1)
          goto LABEL_122;
        v76 = *(_QWORD *)(a1 + 80);
        if (!__CFADD__(v72, v76))
        {
          if (!v76)
          {
LABEL_121:
            v75 += v76;
LABEL_122:
            if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 50))
            {
              v77 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v68, v73);
              v79 = (char *)v77 + (_QWORD)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v70, v78);
            }
            else
            {
              v92 = 0;
              if (IsRunningInFinder())
                v80 = *(_BYTE *)(a1 + 172) == 0;
              else
                v80 = 0;
              v81 = TCFURLInfo::CompareForMerge(*a2, (CFURLRef **)a5, (CFComparisonResult *)&v92, v80, *(_BYTE *)(a1 + 176));
              v91 = 0;
              v82 = TCFURLInfo::ModifiedAfterCheckPoint((CFURLRef *)*a5, *(double *)(a1 + 184), &v91);
              v84 = v82;
              if ((v81 & 1) != 0)
              {
                if (*(_BYTE *)(a1 + 174))
                {
                  if (v82)
                  {
                    v79 = 0;
                  }
                  else
                  {
                    ++*(_DWORD *)(a1 + 240);
                    v88 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v68, v83);
                    v90 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v70, v89);
                    v79 = 0;
                    *(_QWORD *)(a1 + 248) += (char *)v88 + (_QWORD)v90;
                  }
                }
                else
                {
                  v79 = 0;
                  ++*(_DWORD *)(a1 + 240);
                }
                goto LABEL_124;
              }
              v85 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v68, v83);
              v79 = (char *)v85 + (_QWORD)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v70, v86);
              if (v92 != (TString *)1)
              {
                if (v92 != (TString *)-1)
                {
                  TOperationSizer::SetFirstMergeSourceConflict(a1, (const TCFURLInfo **)a2);
                  ++*(_DWORD *)(a1 + 256);
                  goto LABEL_124;
                }
                if (!*(_BYTE *)(a1 + 174))
                {
                  TOperationSizer::SetFirstMergeDestinationConflict(a1, (const TCFURLInfo **)a5);
                  ++*(_DWORD *)(a1 + 220);
                  goto LABEL_124;
                }
                if (!v91 || !v84)
                {
                  TOperationSizer::SetFirstMergeDestinationConflict(a1, (const TCFURLInfo **)a5);
                  ++*(_DWORD *)(a1 + 220);
                  *(_QWORD *)(a1 + 224) += v79;
                  goto LABEL_124;
                }
              }
              TOperationSizer::SetFirstMergeSourceConflict(a1, (const TCFURLInfo **)a2);
              ++*(_DWORD *)(a1 + 216);
            }
LABEL_124:
            v64 = v75 - (_QWORD)v79 + *(_QWORD *)(a1 + 264);
LABEL_103:
            *(_QWORD *)(a1 + 264) = v64;
            goto LABEL_104;
          }
          v72 = v72 + v76 - 1;
        }
        v76 *= v72 / v76;
        goto LABEL_121;
      }
      v53 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9B4A8], v33);
      v55 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9AC58], v54);
      if (v53 >= 1)
      {
        v56 = *(_QWORD *)(a1 + 80);
        if (__CFADD__(v53, v56))
        {
LABEL_86:
          v57 = v53 / v56 * v56;
          goto LABEL_93;
        }
        if (v56)
        {
          v53 = v53 + v56 - 1;
          goto LABEL_86;
        }
      }
      v57 = 0;
LABEL_93:
      if (v55 < 1)
        goto LABEL_99;
      v62 = *(_QWORD *)(a1 + 80);
      if (!__CFADD__(v55, v62))
      {
        if (!v62)
        {
LABEL_98:
          v57 += v62;
LABEL_99:
          v63 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if ((*(_WORD *)(v63 + 76) & 0x20) != 0 && !*(_BYTE *)(*(_QWORD *)(a1 + 32) + 50))
          {
            TOperationSizer::SetFirstMergeSourceConflict(a1, (const TCFURLInfo **)a2);
            ++*(_DWORD *)(a1 + 232);
          }
          v64 = *(_QWORD *)(a1 + 264) + v57;
          goto LABEL_103;
        }
        v55 = v55 + v62 - 1;
      }
      v62 *= v55 / v62;
      goto LABEL_98;
    }
    if (*(_BYTE *)(a1 + 170))
    {
      v21 = *(_QWORD *)(a1 + 80);
      v22 = NumericalProperty;
      if (!__CFADD__(NumericalProperty, v21))
      {
        if (!v21)
          goto LABEL_24;
        v22 = NumericalProperty + v21 - 1;
      }
      v23 = v22 / v21;
    }
    else
    {
      v24 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9B5D0], v18);
      v21 = *(_QWORD *)(a1 + 80);
      if (!__CFADD__(v24, v21))
      {
        if (!v21)
          goto LABEL_24;
        v24 = (const __CFURL *)((char *)v24 + v21 - 1);
      }
      v23 = (unint64_t)v24 / v21;
    }
    v21 *= v23;
LABEL_24:
    v25 = *(_QWORD *)(a1 + 136);
    *(_QWORD *)(a1 + 128) += v21;
    if (NumericalProperty > v25)
      *(_QWORD *)(a1 + 136) = NumericalProperty;
    goto LABEL_26;
  }
LABEL_106:
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 50))
  {
    v66 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    if ((*(_WORD *)(v66 + 76) & 0x20) != 0)
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 64), a2);
  }
  return TOperationSizer::UpdateSizingStats((TOperationSizer *)a1, 0);
}

void sub_1CBC931B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TOperationSizer::ShouldSkip(uint64_t *a1, TCFURLInfo **a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _QWORD *v9;
  std::__shared_weak_count *v10;

  if (!a1[40])
    return 0;
  TDeepCFURLIterator::CurrentContainerInfo(a1[4], &v9);
  if (!v9
    || (((uint64_t (*)(_QWORD, _QWORD, uint64_t))a1[40])(*(_QWORD *)*a2, *v9, a1[42]) & 1) != 0
    || TCFURLInfo::IsTrash(*a2))
  {
    ++a1[18];
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  v5 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v4;
}

void sub_1CBC9328C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TOperationSizer::SetFirstMergeDestinationConflict(uint64_t a1, const TCFURLInfo **a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  __int128 v6;

  if (!*(_QWORD *)(a1 + 288))
  {
    v2 = a1 + 288;
    std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo&,void>(*a2, &v6);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v2, &v6);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v6 + 1);
    if (*((_QWORD *)&v6 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

void TOperationSizer::SetFirstMergeSourceConflict(uint64_t a1, const TCFURLInfo **a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  __int128 v6;

  if (!*(_QWORD *)(a1 + 272))
  {
    v2 = a1 + 272;
    std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo&,void>(*a2, &v6);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v2, &v6);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v6 + 1);
    if (*((_QWORD *)&v6 + 1))
    {
      v4 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

uint64_t std::unique_ptr<std::unordered_set<unsigned long long>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(result);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t *std::unique_ptr<TCloneCache>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v2 + 48);
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::~__hash_table(v2 + 8);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

TDeepCFURLIterator *std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100](TDeepCFURLIterator **a1, TDeepCFURLIterator *a2)
{
  TDeepCFURLIterator *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    TDeepCFURLIterator::~TDeepCFURLIterator(result);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x68uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI10TCFURLInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1CBC93564(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI10TCFURLInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_1E8750538;
  a1[1] = 0;
  TCFURLInfo::TCFURLInfo((TCFURLInfo *)(a1 + 3));
  return a1;
}

void sub_1CBC935B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TCFURLInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750538;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCFURLInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750538;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

const void **std::__shared_ptr_emplace<TCFURLInfo>::__on_zero_shared(uint64_t a1)
{
  return std::__destroy_at[abi:ne180100]<TCFURLInfo,0>(a1 + 24);
}

const void **std::__destroy_at[abi:ne180100]<TCFURLInfo,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  TFileDescriptor::~TFileDescriptor((TFileDescriptor *)(a1 + 32));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 8));
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo&,void>@<X0>(const TCFURLInfo *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x68uLL);
  result = std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo&,std::allocator<TCFURLInfo>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBC936AC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo&,std::allocator<TCFURLInfo>,0>(_QWORD *a1, const TCFURLInfo *a2)
{
  a1[2] = 0;
  *a1 = &unk_1E8750538;
  a1[1] = 0;
  TCFURLInfo::TCFURLInfo((TCFURLInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1CBC936F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1CBC93804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC93878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBC93AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

id CopyDeepHelper(NSObject *a1, int a2)
{
  NSObject *v3;
  NSArray *v4;
  void *v5;
  NSDictionary *v6;
  NSSet *v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;

  v3 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    static_objc_cast<NSString,objc_object * {__strong}>(v3);
    v4 = (NSArray *)objc_claimAutoreleasedReturnValue();
    v5 = v4;
    if (a2)
      MutableCopyDeep(v4);
    else
      CopyDeep(v4);
LABEL_11:
    v8 = objc_claimAutoreleasedReturnValue();
    v10 = (void *)v8;

    goto LABEL_19;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    static_objc_cast<NSString,objc_object * {__strong}>(v3);
    v6 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
    v5 = v6;
    if (a2)
      MutableCopyDeep(v6);
    else
      CopyDeep(v6);
    goto LABEL_11;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    static_objc_cast<NSString,objc_object * {__strong}>(v3);
    v7 = (NSSet *)objc_claimAutoreleasedReturnValue();
    v5 = v7;
    if (a2)
      MutableCopyDeep(v7);
    else
      CopyDeep(v7);
    goto LABEL_11;
  }
  if (a2 && -[NSObject conformsToProtocol:](v3, "conformsToProtocol:", &unk_1EF9BEAF8))
  {
    v9 = -[NSObject mutableCopy](v3, "mutableCopy");
  }
  else if (-[NSObject conformsToProtocol:](v3, "conformsToProtocol:", &unk_1EF9BAA10))
  {
    v9 = -[NSObject copy](v3, "copy");
  }
  else
  {
    v9 = v3;
  }
  v10 = v9;
LABEL_19:

  return v10;
}

void sub_1CBC93C48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id TNodeEvent::Clone@<X0>(TNodeEvent *this@<X0>, _QWORD *a2@<X8>)
{
  id result;

  result = -[FINodeEvent init:]([FINodeEvent alloc], "init:", this);
  *a2 = result;
  return result;
}

id std::vector<TNodeEventPtr>::push_back[abi:ne180100](uint64_t *a1, id *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  id result;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  _QWORD v16[5];

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v10 = ((uint64_t)v7 - *a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v16[4] = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    else
      v14 = 0;
    v15 = &v14[8 * v10];
    v16[0] = v14;
    v16[1] = v15;
    v16[3] = &v14[8 * v13];
    *(_QWORD *)v15 = *a2;
    v16[2] = v15 + 8;
    std::vector<TNodeEventPtr>::__swap_out_circular_buffer(a1, v16);
    v9 = (_QWORD *)a1[1];
    result = (id)std::__split_buffer<TNodeEventPtr>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    result = *a2;
    *v7 = result;
    v9 = v7 + 1;
    a1[1] = (uint64_t)v9;
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1CBC93DA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TNodeEventPtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNodeEvent::Notify(TNodeEvent *a1, TDSNotifier **a2, int a3)
{
  if (TNode::IsContextOpen((TNode *)a1))
  {
    TNodeEvent::NotifyCommon(&a1->fEventKind, a2, a3);
    TNodeEvent::ForwardEventToParent(a1);
  }
  return 0;
}

id *std::pair<TNodePtr,TNodeEventPtr>::~pair(id *a1)
{
  id v2;

  v2 = a1[1];
  a1[1] = 0;

  return a1;
}

void TBlockingEventQueue::~TBlockingEventQueue(TBlockingEventQueue *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = (char *)this + 184;
  v3 = (char *)*((_QWORD *)this + 26);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 160);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::mutex::~mutex((std::mutex *)((char *)this + 48));
  std::deque<TNodeEventPtr>::~deque[abi:ne180100](this);
}

void std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  TDSNotifier **v2;
  TDSNotifier **v4;
  void *v5;

  v1 = *a1;
  v2 = (TDSNotifier **)**a1;
  if (v2)
  {
    v4 = (TDSNotifier **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<TNodeEventPtr>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E874DB58, MEMORY[0x1E0DE42D0]);
}

void sub_1CBC93FE4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  __int128 v17;
  __int128 v18;

  *(_QWORD *)&v18 = a6;
  *((_QWORD *)&v18 + 1) = a7;
  v17 = v18;
  v15[0] = a1;
  v15[1] = &v17;
  v15[2] = &v18;
  if (a3 == a5)
  {
    v13 = a6;
  }
  else
  {
    v8 = a3;
    v9 = a7;
    v10 = *((_QWORD *)&v18 + 1);
    v11 = *((_QWORD *)&v18 + 1);
    do
    {
      v12 = *(void **)(v8 - 8);
      v8 -= 8;
      *(_QWORD *)(v9 - 8) = v12;
      v11 -= 8;
      v10 -= 8;
      v9 = v11;
    }
    while (v8 != a5);
    *((_QWORD *)&v18 + 1) = v11;
    v13 = v18;
  }
  v16 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v15);
  return v13;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id *i;
  id v6;

  for (i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {
    v6 = *i;
    *i = 0;

    i = (id *)(*(_QWORD *)(a2 + 32) + 8);
  }
}

uint64_t std::__split_buffer<TNodeEventPtr>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<TNodeEventPtr>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<TNodeEventPtr>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;
  id *v5;
  void *v6;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    v6 = *(void **)(i - 8);
    v5 = (id *)(i - 8);
    *(_QWORD *)(a1 + 16) = v5;
    *v5 = 0;

  }
}

void std::vector<TNodeEventPtr>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TNodeEventPtr>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (id *)*v2);
    operator delete(**a1);
  }
}

void std::vector<TNodeEventPtr>::__base_destruct_at_end[abi:ne180100](uint64_t a1, id *a2)
{
  id *i;
  void *v5;

  for (i = *(id **)(a1 + 8); i != a2; *i)
  {
    v5 = *--i;
    *i = 0;

  }
  *(_QWORD *)(a1 + 8) = a2;
}

uint64_t std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__push_back_slow_path<std::pair<TNodePtr,TNodeEventPtr>>(uint64_t *a1, id *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[5];

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 4;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 3 > v5)
    v5 = v8 >> 3;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
    v9 = 0xFFFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v14[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[16 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[16 * v9];
  TNodePtr::TNodePtr(v11, a2);
  *((_QWORD *)v11 + 1) = a2[1];
  v14[2] = v11 + 16;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1CBC94430(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v10;
  _QWORD *v11;

  v7 = a7;
  if (a3 != a5)
  {
    v10 = a3;
    v11 = (_QWORD *)(a7 - 16);
    do
    {
      TNodePtr::TNodePtr(v11, (id *)(v10 - 16));
      v11[1] = *(id *)(v10 - 8);
      v7 -= 16;
      v11 -= 2;
      v10 -= 16;
    }
    while (v10 != a5);
  }
  return a6;
}

void std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,TNodeEventPtr>,0>(id *a1)
{
  id v2;

  v2 = a1[1];
  a1[1] = 0;

}

id *std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>,std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(uint64_t a1, id *a2, id *a3, id *a4, uint64_t a5)
{
  id *v5;
  id *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  id *v21;
  id *v22;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;

  v5 = a2;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = *(_QWORD *)(a1 + 16);
    v9 = a1 + 16;
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 4)
    {
      v19 = v12 - (_QWORD)a2;
      v20 = (uint64_t)(v12 - (_QWORD)a2) >> 4;
      if (v20 >= a5)
      {
        v21 = &a3[2 * a5];
      }
      else
      {
        v21 = &a3[2 * v20];
        *(_QWORD *)(a1 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr>*>(v9, v21, a4, *(_QWORD **)(v9 - 8));
        if (v19 < 1)
          return v5;
      }
      std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__move_range((void **)a1, (uint64_t)v5, v12, &v5[2 * a5]);
      if (v21 != v7)
      {
        v22 = v5;
        do
        {
          std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](v22, v7);
          v7 += 2;
          v22 += 2;
        }
        while (v7 != v21);
      }
    }
    else
    {
      v13 = *(_BYTE **)a1;
      v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
      if (v14 >> 60)
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      v15 = ((char *)a2 - v13) >> 4;
      v16 = v10 - (_QWORD)v13;
      if (v16 >> 3 > v14)
        v14 = v16 >> 3;
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
        v17 = 0xFFFFFFFFFFFFFFFLL;
      else
        v17 = v14;
      v28 = v9;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(v9, v17);
      else
        v18 = 0;
      v24 = v18;
      v25 = &v18[16 * v15];
      v26 = v25;
      v27 = &v18[16 * v17];
      std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::__construct_at_end_with_size<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(&v24, v7, a5);
      v5 = (id *)std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(a1, &v24, v5);
      std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer((uint64_t)&v24);
    }
  }
  return v5;
}

void sub_1CBC9469C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void **std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__move_range(void **result, uint64_t a2, unint64_t a3, _BYTE *a4)
{
  void **v6;
  char *v7;
  uint64_t v8;
  id *v9;
  _QWORD *v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;

  v6 = result;
  v7 = (char *)result[1];
  v8 = v7 - a4;
  v9 = (id *)(a2 + v7 - a4);
  if ((unint64_t)v9 >= a3)
  {
    v11 = result[1];
  }
  else
  {
    v11 = result[1];
    do
    {
      TNodePtr::TNodePtr(v11, v9);
      result = (void **)v9[1];
      v11[1] = result;
      v9 += 2;
      v11 += 2;
    }
    while ((unint64_t)v9 < a3);
  }
  v6[1] = v11;
  if (v7 != a4)
  {
    v12 = (void **)(v7 - 16);
    v13 = 16 * (v8 >> 4);
    v14 = a2 - 16;
    do
    {
      result = std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](v12, (void **)(v14 + v13));
      v12 -= 2;
      v13 -= 16;
    }
    while (v13);
  }
  return result;
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr>*>(uint64_t a1, id *a2, id *a3, _QWORD *a4)
{
  id *v6;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *a4 = *v6;
      a4[1] = v6[1];
      a4 += 2;
      v6 += 2;
    }
    while (v6 != a3);
  }
  return a4;
}

void **std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](void **a1, void **a2)
{
  TNodePtr::operator=(a1, a2);
  objc_storeStrong(a1 + 1, a2[1]);
  return a1;
}

id *std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](id *a1, id *a2)
{
  objc_storeStrong(a1, *a2);
  objc_storeStrong(a1 + 1, a2[1]);
  return a1;
}

_QWORD *std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*>(uint64_t a1, id *a2, id *a3, _QWORD *a4)
{
  id *v6;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      TNodePtr::TNodePtr(a4, v6);
      a4[1] = v6[1];
      v6 += 2;
      a4 += 2;
    }
    while (v6 != a3);
  }
  return a4;
}

void std::__shared_ptr_emplace<std::mutex>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::mutex>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750880;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<std::mutex>::__on_zero_shared(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 24));
}

uint64_t std::deque<TNodeEventPtr>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  void **v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void **v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void *v15;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    v5 = a1[4];
    v6 = &v2[v5 >> 9];
    v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (void **)v8)
    {
      do
      {
        v9 = *v7;
        *v7 = 0;

        v10 = *v7++;
        if ((char *)v7 - (_BYTE *)*v6 == 4096)
        {
          v11 = (void **)v6[1];
          ++v6;
          v7 = v11;
        }
      }
      while (v7 != (void **)v8);
      v2 = (void **)a1[1];
      v3 = (void **)a1[2];
    }
  }
  *v4 = 0;
  v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v13 = v12 >> 3;
  if (v13 == 1)
  {
    v14 = 256;
  }
  else
  {
    if (v13 != 2)
      goto LABEL_16;
    v14 = 512;
  }
  a1[4] = v14;
LABEL_16:
  while (v2 != v3)
  {
    v15 = *v2++;
    operator delete(v15);
  }
  return std::__split_buffer<TNodeEventPtr *>::~__split_buffer((uint64_t)a1);
}

uint64_t *TPropertyValue::As<__CFData const*>(uint64_t *result, uint64_t **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_31;
      result = *a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_31;
      goto LABEL_39;
    case 2:
      if (v2 != 2)
        goto LABEL_31;
      goto LABEL_39;
    case 3:
      if (v2 != 3)
        goto LABEL_31;
      goto LABEL_39;
    case 4:
      if (v2 != 4)
        goto LABEL_31;
      goto LABEL_39;
    case 5:
      if (v2 != 5)
        goto LABEL_31;
      goto LABEL_39;
    case 6:
      if (v2 != 6)
        goto LABEL_31;
      goto LABEL_39;
    case 7:
      if (v2 != 7)
        goto LABEL_31;
      goto LABEL_39;
    case 8:
      if (v2 != 8)
        goto LABEL_31;
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10)
        goto LABEL_31;
      goto LABEL_39;
    case 11:
      if (v2 != 11)
        goto LABEL_31;
      goto LABEL_39;
    case 12:
      if (v2 != 12)
        goto LABEL_31;
      goto LABEL_39;
    case 13:
      if (v2 != 13)
        goto LABEL_31;
      goto LABEL_39;
    case 14:
      if (v2 != 14)
        goto LABEL_31;
      result = (uint64_t *)*result;
      break;
    case 15:
      if (v2 != 15)
        goto LABEL_31;
      goto LABEL_39;
    case 16:
      if (v2 != 16)
        goto LABEL_31;
      goto LABEL_39;
    case 17:
      if (v2 != 17)
        goto LABEL_31;
      goto LABEL_39;
    case 18:
      if (v2 != 18)
        goto LABEL_31;
      goto LABEL_39;
    case 19:
      if (v2 == 19)
        goto LABEL_39;
      goto LABEL_31;
    case 20:
      if (v2 != 20)
        goto LABEL_31;
      goto LABEL_39;
    case 21:
      if (v2 != 21)
        goto LABEL_31;
      goto LABEL_39;
    case 22:
      if (v2 != 22)
        goto LABEL_31;
      goto LABEL_39;
    case 23:
      if (v2 != 23)
LABEL_31:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5040] + 16;
  __cxa_throw(exception, MEMORY[0x1E0DE4E88], (void (*)(void *))std::bad_variant_access::~bad_variant_access);
}

unint64_t TPropertyValue::As<int>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unint64_t v4;

  v2 = a1[4];
  v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_50;
      v3 = *a2;
      v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1)
        goto LABEL_50;
      goto LABEL_48;
    case 2:
      if (v2 != 2)
        goto LABEL_50;
      goto LABEL_48;
    case 3:
      if (v2 != 3)
        goto LABEL_50;
      goto LABEL_48;
    case 4:
      if (v2 != 4)
        goto LABEL_50;
      goto LABEL_46;
    case 5:
      if (v2 != 5)
        goto LABEL_50;
      goto LABEL_48;
    case 6:
      if (v2 != 6)
        goto LABEL_50;
      goto LABEL_48;
    case 7:
      if (v2 != 7)
        goto LABEL_50;
      goto LABEL_48;
    case 8:
      if (v2 != 8)
        goto LABEL_50;
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10)
        goto LABEL_50;
      goto LABEL_48;
    case 11:
      if (v2 != 11)
        goto LABEL_50;
      goto LABEL_48;
    case 12:
      if (v2 != 12)
        goto LABEL_50;
      goto LABEL_48;
    case 13:
      if (v2 != 13)
        goto LABEL_50;
      goto LABEL_48;
    case 14:
      if (v2 != 14)
        goto LABEL_50;
      goto LABEL_48;
    case 15:
      if (v2 != 15)
        goto LABEL_50;
      goto LABEL_48;
    case 16:
      if (v2 != 16)
        goto LABEL_50;
      goto LABEL_48;
    case 17:
      if (v2 != 17)
        goto LABEL_50;
      goto LABEL_48;
    case 18:
      if (v2 != 18)
        goto LABEL_50;
      goto LABEL_48;
    case 19:
      if (v2 != 19)
        goto LABEL_50;
      goto LABEL_48;
    case 20:
      if (v2 != 20)
        goto LABEL_50;
      goto LABEL_48;
    case 21:
      if (v2 != 21)
        goto LABEL_50;
      goto LABEL_48;
    case 22:
      if (v2 != 22)
        goto LABEL_50;
LABEL_46:
      v4 = 0;
      v3 = *a1;
      break;
    case 23:
      if (v2 != 23)
LABEL_50:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      v4 = 0xFFFFE08E00000000;
      v3 = *a2;
      break;
    default:
      v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v2 + 24);
    operator delete(v2);
  }
}

_QWORD *std::allocate_shared[abi:ne180100]<TBlockingEventQueue,std::allocator<TBlockingEventQueue>,void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,void>@<X0>(void **a1@<X1>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0xF8uLL);
  result = std::__shared_ptr_emplace<TBlockingEventQueue>::__shared_ptr_emplace[abi:ne180100]<void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,std::allocator<TBlockingEventQueue>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1CBC94DD8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TBlockingEventQueue>::__shared_ptr_emplace[abi:ne180100]<void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,std::allocator<TBlockingEventQueue>,0>(_QWORD *a1, void **a2, uint64_t *a3)
{
  a1[2] = 0;
  *a1 = &unk_1E8750688;
  a1[1] = 0;
  TBlockingEventQueue::TBlockingEventQueue((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1CBC94E2C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TBlockingEventQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750688;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TBlockingEventQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750688;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<TBlockingEventQueue>::__on_zero_shared(uint64_t a1)
{
  TBlockingEventQueue::~TBlockingEventQueue((TBlockingEventQueue *)(a1 + 24));
}

uint64_t std::deque<TNodeEventPtr>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x200)
    a2 = 1;
  if (v2 < 0x400)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

void std::__split_buffer<TNodeEventPtr *>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = a1 + 24;
    v7 = *(_BYTE **)(a1 + 24);
    v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4)
        v12 = 1;
      else
        v12 = (v7 - v4) >> 2;
      v13 = 2 * v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v6, v12);
      v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v16 = *(uint64_t **)(a1 + 8);
      v17 = v5;
      v18 = *(_QWORD *)(a1 + 16) - (_QWORD)v16;
      if (v18)
      {
        v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        v19 = 8 * (v18 >> 3);
        v20 = v5;
        do
        {
          v21 = *v16++;
          *(_QWORD *)v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      v22 = *(char **)a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v17;
      *(_QWORD *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v9 = (v7 - v8) >> 3;
      if (v9 >= -1)
        v10 = v9 + 1;
      else
        v10 = v9 + 2;
      v11 = v10 >> 1;
      v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(*(_QWORD *)(a1 + 32), v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Property const&,0,Property,20ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 20)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property const&>(a1, a2);
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E8751628[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 20;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, id *a2)
{

}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm14EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm15EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm16EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm17EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm18EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(a2);
}

TReferenceCounted **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm19EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, TReferenceCounted **a2)
{
  return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef(a2);
}

const void **TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  TDSNotifier **v2;

  v2 = *(TDSNotifier ***)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v2 + 2);
    operator delete(v2);
  }
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::~__func(uint64_t a1)
{

  return a1;
}

void std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::~__func(uint64_t a1)
{

  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::__clone()
{
  return 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::target_type()
{
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E874DB60, MEMORY[0x1E0DE42E0]);
}

void sub_1CBC95548(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x1E0DE4FD0];
  v3 = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1CBC95698(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x1D17A5364](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x1E0DE4F50];
  v3 = *MEMORY[0x1E0DE4F50];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F50];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D17A5364](a1 + 128);
  return a1;
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x1D17A5208](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x1D17A5214](v13);
  return a1;
}

void sub_1CBC95850(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x1D17A5214](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1CBC95830);
}

void sub_1CBC95898(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1CBC959CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:ne180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  unint64_t v4;
  const void *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  result = std::stringbuf::view[abi:ne180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = (const void *)result;
  v6 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v4;
    if (!v4)
      goto LABEL_9;
  }
  result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:ne180100](uint64_t a1)
{
  int v1;
  unint64_t v3;

  v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    v3 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(a1 + 88) < v3)
      *(_QWORD *)(a1 + 88) = v3;
    return *(_QWORD *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(_QWORD *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

void std::vector<TNodePtr>::resize(_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 3;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 8 * a2;
      while (v3 != v5)
      {
        v6 = *(void **)(v3 - 8);
        v3 -= 8;

      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<TNodePtr>::__append((uint64_t)a1, a2 - v4);
  }
}

uint64_t std::tuple<std::vector<TNodePtr>,std::vector<TString>,std::vector<int>>::~tuple(uint64_t a1)
{
  void *v2;
  void **v4;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  v4 = (void **)(a1 + 24);
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = (void **)a1;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v4);
  return a1;
}

uint64_t std::vector<TString>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = *(_QWORD *)(a1 + 16);
  result = a1 + 16;
  if (a2 > (v4 - *(_QWORD *)a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 8 * v6;
    std::vector<TString>::__swap_out_circular_buffer((CFTypeRef *)a1, v7);
    return std::__split_buffer<TString>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1CBC95E28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *value;
  int64_t v5;
  char *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  std::vector<int>::pointer begin;
  int *end;
  int *v12;
  int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)p_end_cap, __n);
    v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

id std::vector<TNodePtr>::push_back[abi:ne180100](uint64_t a1, id *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  id result;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  _QWORD v16[5];

  v6 = *(_QWORD *)(a1 + 16);
  v4 = a1 + 16;
  v5 = v6;
  v7 = *(_QWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v10 = ((uint64_t)v7 - *(_QWORD *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *(_QWORD *)a1;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v16[4] = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    else
      v14 = 0;
    v15 = &v14[8 * v10];
    v16[0] = v14;
    v16[1] = v15;
    v16[3] = &v14[8 * v13];
    *(_QWORD *)v15 = *a2;
    v16[2] = v15 + 8;
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, v16);
    v9 = *(_QWORD **)(a1 + 8);
    result = (id)std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    result = *a2;
    *v7 = result;
    v9 = v7 + 1;
    *(_QWORD *)(a1 + 8) = v9;
  }
  *(_QWORD *)(a1 + 8) = v9;
  return result;
}

void sub_1CBC95FB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TString>::push_back[abi:ne180100](uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  CFTypeRef *v16;
  CFTypeRef *v17;
  char *v18;
  uint64_t v19;

  v6 = *(_QWORD *)(a1 + 16);
  v4 = a1 + 16;
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *(_QWORD *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *(_QWORD *)a1;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = (CFTypeRef *)&v14[8 * v10];
    v18 = &v14[8 * v13];
    std::construct_at[abi:ne180100]<TString,TString,TString*>(v16, a2);
    v17 = v16 + 1;
    std::vector<TString>::__swap_out_circular_buffer((CFTypeRef *)a1, &v15);
    v9 = *(_QWORD *)(a1 + 8);
    result = std::__split_buffer<TString>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = (uint64_t)std::construct_at[abi:ne180100]<TString,TString,TString*>(*(CFTypeRef **)(v4 - 8), a2);
    v9 = v7 + 8;
    *(_QWORD *)(a1 + 8) = v7 + 8;
  }
  *(_QWORD *)(a1 + 8) = v9;
  return result;
}

void sub_1CBC960B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *v5;
  int *value;
  int *end;
  std::vector<int>::pointer begin;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  int *v16;
  int *v17;
  int v18;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v9 = (char *)end - (char *)this->__begin_;
    v10 = __n + (v9 >> 2);
    if (v10 >> 62)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)p_end_cap, v13);
      begin = this->__begin_;
      end = this->__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = (int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    v17 = (int *)&v15[4 * __n];
    while (end != begin)
    {
      v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
      operator delete(begin);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

void std::vector<TNodePtr>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = *(_QWORD *)(a1 + 16);
  v4 = a1 + 16;
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    *(_QWORD *)(a1 + 8) = v7;
  }
  else
  {
    v8 = v7 - *(_QWORD *)a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - *(_QWORD *)a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[8 * v10];
    v17 = &v13[8 * v12];
    bzero(v15, 8 * a2);
    v16 = &v15[8 * a2];
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, &v14);
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_1CBC962F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>(uint64_t a1, void **a2, void **a3, unint64_t a4)
{
  void **v6;
  id *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  void *v13;
  unint64_t v14;
  void **v15;
  uint64_t v16;
  _QWORD *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  char v23;
  char v24;

  v6 = a2;
  v8 = *(id **)a1;
  if (a4 <= (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3)
  {
    v14 = (uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v8) >> 3;
    if (v14 >= a4)
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>((int)&v24, a2, a3, v8);
      v20 = v19;
      v21 = *(_QWORD *)(a1 + 8);
      if (v21 != v19)
      {
        do
        {
          v22 = *(void **)(v21 - 8);
          v21 -= 8;

        }
        while (v21 != v20);
      }
      *(_QWORD *)(a1 + 8) = v20;
    }
    else
    {
      v15 = &a2[v14];
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>((int)&v23, a2, v15, v8);
      v16 = *(_QWORD *)(a1 + 8);
      if (v15 != a3)
      {
        v17 = *(_QWORD **)(a1 + 8);
        do
        {
          v18 = *v15++;
          *v17++ = v18;
          v16 += 8;
        }
        while (v15 != a3);
      }
      *(_QWORD *)(a1 + 8) = v16;
    }
  }
  else
  {
    std::vector<TNodePtr>::__vdeallocate((void **)a1);
    if (a4 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v9 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
    v10 = v9 >> 2;
    if (v9 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<TNodePtr>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = *(_QWORD **)(a1 + 8);
    while (v6 != a3)
    {
      v13 = *v6++;
      *v12++ = v13;
    }
    *(_QWORD *)(a1 + 8) = v12;
  }
}

char *std::vector<TNodePtr>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void **std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>(int a1, void **a2, void **a3, id *location)
{
  void **v5;
  void *v7;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      v7 = *v5++;
      objc_storeStrong(location++, v7);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 1);
        v4 -= 8;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CFTypeRef *std::construct_at[abi:ne180100]<TString,TString,TString*>(CFTypeRef *a1, CFTypeRef *a2)
{
  *a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  return a1;
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorI8TNodePtrNS_9allocatorIS4_EEEENS3_I7TStringNS5_IS8_EEEENS3_IiNS5_IiEEEEEEC2B8ne180100IJLm0ELm1ELm2EEJS7_SA_SC_EJEJEJRS7_RSA_RSC_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSJ_IJDpT2_EEEDpOT3_(uint64_t a1, void ***a2, uint64_t *a3, uint64_t a4)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)a1, *a2, a2[1], a2[1] - *a2);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  std::vector<TString>::__init_with_size[abi:ne180100]<TString*,TString*>((_QWORD *)(a1 + 24), *a3, a3[1], (a3[1] - *a3) >> 3);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)(a1 + 48), *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2);
  return a1;
}

void sub_1CBC96628(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>(char *result, void **a2, void **a3, unint64_t a4)
{
  char *v6;
  char **v7;
  void *v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<TNodePtr>::__vallocate[abi:ne180100](result, a4);
    v7 = (char **)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      result = v8;
      *v7++ = result;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1CBC966BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<TString>::__init_with_size[abi:ne180100]<TString*,TString*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<TNodePtr>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString*,TString*,TString*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1CBC96734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString*,TString*,TString*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      std::construct_at[abi:ne180100]<TString,TString&,TString*>((TString *)(a4 + v7), (TString **)(a2 + v7));
      v7 += 8;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1CBC967B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 8;
    do
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v4 + v2));
      v2 -= 8;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

TString *std::construct_at[abi:ne180100]<TString,TString&,TString*>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  return a1;
}

void sub_1CBC96814(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::vector<TString>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<int>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1CBC968F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,false>(unint64_t result, int *a2, _QWORD **a3, uint64_t a4, char a5)
{
  int *i;
  int *v8;
  int *v9;
  int *v10;
  uint64_t v11;
  unint64_t v12;
  int *v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  CFComparisonResult v28;
  unint64_t v29;
  int *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int *v36;
  CFComparisonResult v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  CFComparisonResult v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int *v50;
  int *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  CFComparisonResult v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  CFComparisonResult v64;
  unint64_t v65;
  BOOL v66;
  BOOL v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int *j;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  int *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  int *v111;
  BOOL v112;
  char v113;
  uint64_t v114;
  int *v115;
  int *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  int *v123;
  uint64_t v124;
  _DWORD *v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  uint64_t v135;
  int *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  int v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  int v149;
  uint64_t v150;
  int *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  int v162;
  int v163;
  int *v164;
  uint64_t v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  int *v169;
  int *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  int v177;
  unint64_t v178;
  int *v179;
  uint64_t v180;
  unint64_t v181;
  unint64_t v182;
  int *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  int v188;
  int v189;
  int *v190;
  unint64_t v191;
  unint64_t v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  int v196;
  unint64_t v197;
  unint64_t v199;
  int *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int v204;
  int v205;
  int v206;
  int *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  int v212;
  unint64_t v213;
  unint64_t v214;
  uint64_t v215;
  int *v216;
  int v218;
  uint64_t v219;
  int v220;
  int *v222;

  i = (int *)result;
LABEL_2:
  v8 = a2;
  v9 = a2 - 1;
  while (2)
  {
    v10 = i;
    v11 = (char *)v8 - (char *)i;
    v12 = v8 - i;
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v105 = *(a2 - 1);
        v106 = *i;
        v107 = *a3[1];
        v108 = *(_DWORD *)(v107 + 4 * v105);
        v109 = *(_DWORD *)(v107 + 4 * v106);
        if (v108 < v109
          || v108 <= v109
          && ((result = TString::StringCompare((TString *)(*a3[2] + 8 * v105), (const TString *)(*a3[2] + 8 * v106)),
               result == -1)
           || !result
           && (v199 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v105)),
               result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v106)),
               v199 < result)))
        {
          v110 = *i;
          *i = *(a2 - 1);
          *(a2 - 1) = v110;
        }
        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(i, i + 1, v9, a3);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(i, i + 1, i + 2, v9, a3);
      case 5uLL:
        return std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,0>(i, i + 1, i + 2, i + 3, v9, a3);
      default:
        v222 = i;
        if (v11 > 95)
        {
          if (!a4)
          {
            if (i == v8)
              return result;
            v132 = (v12 - 2) >> 1;
            v133 = v132;
            do
            {
              v134 = v133;
              if (v132 < v133)
                goto LABEL_186;
              v135 = (2 * v133) | 1;
              v136 = &v10[v135];
              if (2 * v133 + 2 < (uint64_t)v12)
              {
                v137 = *v136;
                v138 = v136[1];
                v139 = *a3[1];
                v140 = *(_DWORD *)(v139 + 4 * v137);
                v141 = *(_DWORD *)(v139 + 4 * v138);
                if (v140 < v141
                  || v140 <= v141
                  && ((result = TString::StringCompare((TString *)(*a3[2] + 8 * v137), (const TString *)(*a3[2] + 8 * v138)), v132 = (v12 - 2) >> 1, result == -1)|| !result&& (v142 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v137)), result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v138)), v132 = (v12 - 2) >> 1, v142 < result)))
                {
                  ++v136;
                  v135 = 2 * v134 + 2;
                }
              }
              v143 = *v136;
              v10 = v222;
              v144 = v222[v134];
              v145 = *a3[1];
              v146 = *(_DWORD *)(v145 + 4 * v143);
              v147 = *(_DWORD *)(v145 + 4 * v144);
              if (v146 < v147)
                goto LABEL_186;
              if (v146 <= v147)
              {
                result = TString::StringCompare((TString *)(*a3[2] + 8 * v143), (const TString *)(*a3[2] + 8 * v144));
                v132 = (v12 - 2) >> 1;
                if (result == -1)
                  goto LABEL_186;
                if (!result)
                {
                  v148 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v143));
                  result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v144));
                  v132 = (v12 - 2) >> 1;
                  if (v148 < result)
                    goto LABEL_186;
                }
              }
              v149 = v222[v134];
              v222[v134] = *v136;
              v218 = v149;
              if (v132 < v135)
                goto LABEL_185;
              v150 = v149;
              v215 = v149;
              while (1)
              {
                v151 = v136;
                v152 = 2 * v135;
                v135 = (2 * v135) | 1;
                v136 = &v10[v135];
                v153 = v152 + 2;
                if (v152 + 2 < (uint64_t)v12)
                {
                  v154 = *v136;
                  v155 = v136[1];
                  v156 = *a3[1];
                  v157 = *(_DWORD *)(v156 + 4 * v154);
                  v158 = *(_DWORD *)(v156 + 4 * v155);
                  if (v157 < v158)
                    goto LABEL_170;
                  if (v157 <= v158)
                  {
                    v216 = v151;
                    result = TString::StringCompare((TString *)(*a3[2] + 8 * v154), (const TString *)(*a3[2] + 8 * v155));
                    v150 = v215;
                    v151 = v216;
                    v132 = (v12 - 2) >> 1;
                    if (result == -1
                      || !result
                      && (v159 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v154)),
                          result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v155)),
                          v150 = v215,
                          v151 = v216,
                          v132 = (v12 - 2) >> 1,
                          v159 < result))
                    {
LABEL_170:
                      ++v136;
                      v135 = v153;
                    }
                  }
                }
                v160 = *v136;
                v161 = *a3[1];
                v162 = *(_DWORD *)(v161 + 4 * v160);
                v163 = *(_DWORD *)(v161 + 4 * v150);
                if (v162 < v163)
                {
                  v136 = v151;
                  v10 = v222;
                  goto LABEL_185;
                }
                v10 = v222;
                if (v162 <= v163)
                {
                  v164 = v151;
                  v165 = v150;
                  result = TString::StringCompare((TString *)(*a3[2] + 8 * v160), (const TString *)(*a3[2] + 8 * v150));
                  if (result)
                  {
                    v132 = (v12 - 2) >> 1;
                    v150 = v165;
                    v151 = v164;
                    if (result == -1)
                      break;
                    goto LABEL_181;
                  }
                  v166 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v160));
                  result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v165));
                  v132 = (v12 - 2) >> 1;
                  v150 = v165;
                  v151 = v164;
                  if (v166 < result)
                    break;
                }
LABEL_181:
                *v151 = *v136;
                if (v132 < v135)
                  goto LABEL_185;
              }
              v136 = v151;
LABEL_185:
              *v136 = v218;
LABEL_186:
              v133 = v134 - 1;
            }
            while (v134);
            v167 = (unint64_t)v11 >> 2;
            while (1)
            {
              v168 = 0;
              v220 = *v10;
              v169 = v10;
              do
              {
                v170 = v169;
                v169 += v168 + 1;
                v171 = 2 * v168;
                v168 = (2 * v168) | 1;
                v172 = v171 + 2;
                if (v171 + 2 < v167)
                {
                  v173 = *v169;
                  v174 = v169[1];
                  v175 = *a3[1];
                  v176 = *(_DWORD *)(v175 + 4 * v173);
                  v177 = *(_DWORD *)(v175 + 4 * v174);
                  if (v176 < v177
                    || v176 <= v177
                    && ((result = TString::StringCompare((TString *)(*a3[2] + 8 * v173), (const TString *)(*a3[2] + 8 * v174)), result == -1)|| !result&& (v178 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v173)), result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v174)), v178 < result)))
                  {
                    ++v169;
                    v168 = v172;
                  }
                }
                *v170 = *v169;
              }
              while (v168 <= (uint64_t)((unint64_t)(v167 - 2) >> 1));
              v179 = a2 - 1;
              v112 = v169 == --a2;
              if (v112)
              {
                *v169 = v220;
              }
              else
              {
                *v169 = *v179;
                *v179 = v220;
                v10 = v222;
                v180 = (char *)v169 - (char *)v222 + 4;
                if (v180 < 5)
                  goto LABEL_216;
                v181 = ((unint64_t)v180 >> 2) - 2;
                v182 = v181 >> 1;
                v183 = &v222[v181 >> 1];
                v184 = *v183;
                v185 = *v169;
                v186 = *a3[1];
                v187 = *(_DWORD *)(v186 + 4 * v184);
                v188 = *(_DWORD *)(v186 + 4 * v185);
                if (v187 >= v188)
                {
                  if (v187 > v188)
                    goto LABEL_216;
                  result = TString::StringCompare((TString *)(*a3[2] + 8 * v184), (const TString *)(*a3[2] + 8 * v185));
                  if (result != -1)
                  {
                    if (result)
                      goto LABEL_216;
                    v191 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v184));
                    result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v185));
                    if (v191 >= result)
                      goto LABEL_216;
                  }
                }
                v189 = *v169;
                *v169 = *v183;
                if (v181 >= 2)
                {
                  while (1)
                  {
                    v192 = v182 - 1;
                    v182 = (v182 - 1) >> 1;
                    v190 = &v222[v182];
                    v193 = *v190;
                    v194 = *a3[1];
                    v195 = *(_DWORD *)(v194 + 4 * v193);
                    v196 = *(_DWORD *)(v194 + 4 * v189);
                    if (v195 >= v196)
                    {
                      if (v195 > v196)
                        break;
                      result = TString::StringCompare((TString *)(*a3[2] + 8 * v193), (const TString *)(*a3[2] + 8 * v189));
                      if (result != -1)
                      {
                        if (result)
                          break;
                        v197 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v193));
                        result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v189));
                        if (v197 >= result)
                          break;
                      }
                    }
                    *v183 = *v190;
                    v183 = &v222[v182];
                    if (v192 <= 1)
                      goto LABEL_214;
                  }
                }
                v190 = v183;
LABEL_214:
                *v190 = v189;
              }
              v10 = v222;
LABEL_216:
              if (v167-- <= 2)
                return result;
            }
          }
          v13 = &i[v12 >> 1];
          if ((unint64_t)v11 < 0x201)
          {
            result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(&v10[v12 >> 1], v10, v9, a3);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v10, &v10[v12 >> 1], v9, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v10 + 1, v13 - 1, a2 - 2, a3);
            v14 = &v10[(v12 >> 1) + 1];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v222 + 2, v14, a2 - 3, a3);
            v10 = v222;
            result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v13 - 1, v13, v14, a3);
            v15 = *v222;
            *v222 = *v13;
            *v13 = v15;
          }
          --a4;
          if ((a5 & 1) == 0)
          {
            v17 = *(v10 - 1);
            v16 = *v10;
            v18 = *a3[1];
            v19 = *(_DWORD *)(v18 + 4 * v17);
            v20 = *(_DWORD *)(v18 + 4 * v16);
            if (v19 >= v20)
            {
              if (v19 > v20
                || (result = TString::StringCompare((TString *)(*a3[2] + 8 * v17), (const TString *)(*a3[2] + 8 * v16)),
                    result != -1)
                && (result
                 || (v21 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v17)),
                     result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v16)),
                     v21 >= result)))
              {
                v68 = *v10;
                v69 = *v9;
                v70 = *a3[1];
                v71 = *(_DWORD *)(v70 + 4 * v68);
                v72 = *(_DWORD *)(v70 + 4 * v69);
                if (v71 < v72
                  || v71 <= v72
                  && ((result = TString::StringCompare((TString *)(*a3[2] + 8 * v68), (const TString *)(*a3[2] + 8 * v69)), result == -1)|| !result&& (v77 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v68)), result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69)), v77 < result)))
                {
                  i = v222 + 1;
                  v73 = v222[1];
                  v74 = *a3[1];
                  v75 = *(_DWORD *)(v74 + 4 * v68);
                  v76 = *(_DWORD *)(v74 + 4 * v73);
                  if (v75 >= v76)
                  {
                    v8 = a2;
                    do
                    {
                      if (v75 <= v76)
                      {
                        result = TString::StringCompare((TString *)(*a3[2] + 8 * v68), (const TString *)(*a3[2] + 8 * v73));
                        if (result)
                        {
                          if (result == -1)
                            break;
                        }
                        else
                        {
                          v83 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v68));
                          result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v73));
                          if (v83 < result)
                            break;
                        }
                      }
                      v84 = i[1];
                      ++i;
                      v73 = v84;
                      v85 = *a3[1];
                      v75 = *(_DWORD *)(v85 + 4 * v68);
                      v76 = *(_DWORD *)(v85 + 4 * v84);
                    }
                    while (v75 >= v76);
                  }
                  else
                  {
                    v8 = a2;
                  }
                }
                else
                {
                  v8 = a2;
                  for (i = v222 + 1; i < a2; ++i)
                  {
                    v78 = *i;
                    v79 = *a3[1];
                    v80 = *(_DWORD *)(v79 + 4 * v68);
                    v81 = *(_DWORD *)(v79 + 4 * v78);
                    if (v80 < v81)
                      break;
                    if (v80 <= v81)
                    {
                      result = TString::StringCompare((TString *)(*a3[2] + 8 * v68), (const TString *)(*a3[2] + 8 * v78));
                      if (result)
                      {
                        if (result == -1)
                          break;
                      }
                      else
                      {
                        v82 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v68));
                        result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v78));
                        if (v82 < result)
                          break;
                      }
                    }
                  }
                }
                j = v8;
                if (i < v8)
                {
                  for (j = a2 - 1; ; --j)
                  {
                    v87 = *j;
                    v88 = *a3[1];
                    v89 = *(_DWORD *)(v88 + 4 * v68);
                    v90 = *(_DWORD *)(v88 + 4 * v87);
                    if (v89 >= v90)
                    {
                      if (v89 > v90)
                        break;
                      result = TString::StringCompare((TString *)(*a3[2] + 8 * v68), (const TString *)(*a3[2] + 8 * v87));
                      if (result != -1)
                      {
                        if (result)
                          break;
                        v91 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v68));
                        result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v87));
                        if (v91 >= result)
                          break;
                      }
                    }
                  }
                }
                while (i < j)
                {
                  v92 = *i;
                  *i = *j;
                  *j = v92;
                  while (1)
                  {
                    v94 = i[1];
                    ++i;
                    v93 = v94;
                    v95 = *a3[1];
                    v96 = *(_DWORD *)(v95 + 4 * v68);
                    v97 = *(_DWORD *)(v95 + 4 * v94);
                    if (v96 < v97)
                      break;
                    if (v96 <= v97)
                    {
                      result = TString::StringCompare((TString *)(*a3[2] + 8 * v68), (const TString *)(*a3[2] + 8 * v93));
                      if (result)
                      {
                        if (result == -1)
                          goto LABEL_105;
                      }
                      else
                      {
                        v98 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v68));
                        result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v93));
                        if (v98 < result)
                          goto LABEL_105;
                      }
                    }
                  }
                  while (1)
                  {
                    do
                    {
LABEL_105:
                      v99 = *--j;
                      v100 = *a3[1];
                      v101 = *(_DWORD *)(v100 + 4 * v68);
                      v102 = *(_DWORD *)(v100 + 4 * v99);
                    }
                    while (v101 < v102);
                    if (v101 > v102)
                      break;
                    result = TString::StringCompare((TString *)(*a3[2] + 8 * v68), (const TString *)(*a3[2] + 8 * v99));
                    if (result != -1)
                    {
                      if (result)
                        break;
                      v103 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v68));
                      result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v99));
                      if (v103 >= result)
                        break;
                    }
                  }
                }
                v104 = i - 1;
                if (i - 1 != v222)
                  *v222 = *v104;
                a5 = 0;
                *v104 = v68;
                v9 = a2 - 1;
                continue;
              }
            }
          }
          v22 = 0;
          v23 = *v10;
          while (1)
          {
            v24 = v10[v22 + 1];
            v25 = *a3[1];
            v26 = *(_DWORD *)(v25 + 4 * v24);
            v27 = *(_DWORD *)(v25 + 4 * v23);
            if (v26 >= v27)
            {
              if (v26 > v27)
                break;
              v28 = TString::StringCompare((TString *)(*a3[2] + 8 * v24), (const TString *)(*a3[2] + 8 * v23));
              if (v28 != kCFCompareLessThan)
              {
                if (v28)
                  break;
                v29 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v24));
                if (v29 >= TNodeFromFINode(*(FINode **)(**a3 + 8 * v23)))
                  break;
              }
            }
            ++v22;
          }
          v30 = &v10[v22];
          v31 = v30 + 1;
          v219 = a4;
          if (!(v22 * 4))
          {
            v8 = a2;
            v36 = a2;
            if (v31 >= a2)
              goto LABEL_43;
            v41 = *v9;
            v42 = *a3[1];
            v43 = *(_DWORD *)(v42 + 4 * v41);
            v44 = *(_DWORD *)(v42 + 4 * v23);
            v36 = v9;
            if (v43 < v44)
              goto LABEL_43;
            v36 = v9;
            while (2)
            {
              if (v43 > v44)
              {
LABEL_38:
                if (v31 >= v36)
                  goto LABEL_43;
              }
              else
              {
                v45 = TString::StringCompare((TString *)(*a3[2] + 8 * v41), (const TString *)(*a3[2] + 8 * v23));
                if (v45)
                {
                  if (v45 == kCFCompareLessThan)
                    goto LABEL_43;
                  goto LABEL_38;
                }
                v46 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v41));
                v47 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v23));
                if (v31 >= v36 || v46 < v47)
                  goto LABEL_43;
              }
              v48 = *--v36;
              v41 = v48;
              v49 = *a3[1];
              v43 = *(_DWORD *)(v49 + 4 * v48);
              v44 = *(_DWORD *)(v49 + 4 * v23);
              if (v43 < v44)
                goto LABEL_43;
              continue;
            }
          }
          v32 = *v9;
          v33 = *a3[1];
          v34 = *(_DWORD *)(v33 + 4 * v32);
          v35 = *(_DWORD *)(v33 + 4 * v23);
          v36 = v9;
          v8 = a2;
          if (v34 >= v35)
          {
            v36 = v9;
            do
            {
              if (v34 <= v35)
              {
                v37 = TString::StringCompare((TString *)(*a3[2] + 8 * v32), (const TString *)(*a3[2] + 8 * v23));
                if (v37)
                {
                  if (v37 == kCFCompareLessThan)
                    break;
                }
                else
                {
                  v38 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v32));
                  if (v38 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v23)))
                    break;
                }
              }
              v39 = *--v36;
              v32 = v39;
              v40 = *a3[1];
              v34 = *(_DWORD *)(v40 + 4 * v39);
              v35 = *(_DWORD *)(v40 + 4 * v23);
            }
            while (v34 >= v35);
          }
LABEL_43:
          if (v31 < v36)
          {
            v50 = v30 + 1;
            v51 = v36;
            do
            {
              v52 = *v50;
              *v50++ = *v51;
              *v51 = v52;
              while (1)
              {
                v53 = *v50;
                v54 = *a3[1];
                v55 = *(_DWORD *)(v54 + 4 * v53);
                v56 = *(_DWORD *)(v54 + 4 * v23);
                if (v55 >= v56)
                {
                  if (v55 > v56)
                    break;
                  v57 = TString::StringCompare((TString *)(*a3[2] + 8 * v53), (const TString *)(*a3[2] + 8 * v23));
                  if (v57 != kCFCompareLessThan)
                  {
                    if (v57)
                      break;
                    v58 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v53));
                    if (v58 >= TNodeFromFINode(*(FINode **)(**a3 + 8 * v23)))
                      break;
                  }
                }
                ++v50;
              }
              while (1)
              {
                v60 = *--v51;
                v59 = v60;
                v61 = *a3[1];
                v62 = *(_DWORD *)(v61 + 4 * v60);
                v63 = *(_DWORD *)(v61 + 4 * v23);
                if (v62 < v63)
                  break;
                if (v62 <= v63)
                {
                  v64 = TString::StringCompare((TString *)(*a3[2] + 8 * v59), (const TString *)(*a3[2] + 8 * v23));
                  if (v64)
                  {
                    if (v64 == kCFCompareLessThan)
                      break;
                  }
                  else
                  {
                    v65 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v59));
                    if (v65 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v23)))
                      break;
                  }
                }
              }
            }
            while (v50 < v51);
            v30 = v50 - 1;
            v9 = a2 - 1;
          }
          if (v30 != v222)
            *v222 = *v30;
          *v30 = v23;
          v66 = v31 >= v36;
          a4 = v219;
          if (!v66)
          {
LABEL_66:
            result = std::__introsort<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,false>(v222, v30, a3, v219, a5 & 1);
            a5 = 0;
            i = v30 + 1;
            continue;
          }
          v67 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v222, v30, a3);
          i = v30 + 1;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v30 + 1, v8, a3);
          if (!(_DWORD)result)
          {
            if (v67)
              continue;
            goto LABEL_66;
          }
          a2 = v30;
          i = v222;
          if (v67)
            return result;
          goto LABEL_2;
        }
        v111 = i + 1;
        v112 = i == v8 || v111 == v8;
        v113 = v112;
        if ((a5 & 1) == 0)
        {
          if ((v113 & 1) == 0)
          {
            do
            {
              v200 = v10;
              v10 = v111;
              v202 = *v200;
              v201 = v200[1];
              v203 = *a3[1];
              v204 = *(_DWORD *)(v203 + 4 * v201);
              v205 = *(_DWORD *)(v203 + 4 * v202);
              if (v204 < v205
                || v204 <= v205
                && ((result = TString::StringCompare((TString *)(*a3[2] + 8 * v201), (const TString *)(*a3[2] + 8 * v202)), result == -1)|| !result&& (v214 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v201)), result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v202)), v214 < result)))
              {
                v206 = *v10;
                while (1)
                {
                  do
                  {
                    v207 = v200;
                    v200[1] = *v200;
                    v209 = *--v200;
                    v208 = v209;
                    v210 = *a3[1];
                    v211 = *(_DWORD *)(v210 + 4 * v206);
                    v212 = *(_DWORD *)(v210 + 4 * v209);
                  }
                  while (v211 < v212);
                  if (v211 > v212)
                    break;
                  result = TString::StringCompare((TString *)(*a3[2] + 8 * v206), (const TString *)(*a3[2] + 8 * v208));
                  if (result != -1)
                  {
                    if (result)
                      break;
                    v213 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v206));
                    result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v208));
                    if (v213 >= result)
                      break;
                  }
                }
                *v207 = v206;
              }
              v111 = v10 + 1;
            }
            while (v10 + 1 != a2);
          }
          return result;
        }
        if ((v113 & 1) != 0)
          return result;
        v114 = 0;
        v115 = i;
        do
        {
          v116 = v115;
          v115 = v111;
          v118 = *v116;
          v117 = v116[1];
          v119 = *a3[1];
          v120 = *(_DWORD *)(v119 + 4 * v117);
          v121 = *(_DWORD *)(v119 + 4 * v118);
          if (v120 >= v121)
          {
            if (v120 > v121)
              goto LABEL_149;
            result = TString::StringCompare((TString *)(*a3[2] + 8 * v117), (const TString *)(*a3[2] + 8 * v118));
            if (result != -1)
            {
              if (result)
                goto LABEL_149;
              v131 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v117));
              result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v118));
              if (v131 >= result)
                goto LABEL_149;
            }
          }
          v122 = v116[1];
          v116[1] = *v116;
          v123 = v10;
          if (v116 == v10)
            goto LABEL_148;
          v124 = v114;
          while (1)
          {
            v125 = (int *)((char *)v10 + v124);
            v126 = (int)*(v125 - 1);
            v127 = *a3[1];
            v128 = *(_DWORD *)(v127 + 4 * v122);
            v129 = *(_DWORD *)(v127 + 4 * v126);
            if (v128 >= v129)
            {
              if (v128 > v129)
                goto LABEL_146;
              result = TString::StringCompare((TString *)(*a3[2] + 8 * v122), (const TString *)(*a3[2] + 8 * v126));
              if (result != -1)
                break;
            }
LABEL_139:
            --v116;
            *v125 = *(v125 - 1);
            v124 -= 4;
            v10 = v222;
            if (!v124)
            {
              v123 = v222;
              goto LABEL_148;
            }
          }
          if (!result)
          {
            v130 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v122));
            result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v126));
            if (v130 >= result)
            {
LABEL_146:
              v123 = v116;
              v10 = v222;
              goto LABEL_148;
            }
            goto LABEL_139;
          }
          v10 = v222;
          v123 = (int *)((char *)v222 + v124);
LABEL_148:
          *v123 = v122;
LABEL_149:
          v111 = v115 + 1;
          v114 += 4;
        }
        while (v115 + 1 != a2);
        return result;
    }
  }
}

unint64_t std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,0>(int *a1, int *a2, int *a3, int *a4, int *a5, _QWORD **a6)
{
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a2, a3, a4, a6);
  v13 = *a5;
  v14 = *a4;
  v15 = *a6[1];
  v16 = *(_DWORD *)(v15 + 4 * v13);
  v17 = *(_DWORD *)(v15 + 4 * v14);
  if (v16 < v17
    || v16 <= v17
    && ((result = TString::StringCompare((TString *)(*a6[2] + 8 * v13), (const TString *)(*a6[2] + 8 * v14)),
         result == -1)
     || !result
     && (v37 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v13)),
         result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v14)),
         v37 < result)))
  {
    v18 = *a4;
    *a4 = *a5;
    *a5 = v18;
    v19 = *a4;
    v20 = *a3;
    v21 = *a6[1];
    v22 = *(_DWORD *)(v21 + 4 * v19);
    v23 = *(_DWORD *)(v21 + 4 * v20);
    if (v22 < v23
      || v22 <= v23
      && ((result = TString::StringCompare((TString *)(*a6[2] + 8 * v19), (const TString *)(*a6[2] + 8 * v20)),
           result == -1)
       || !result
       && (v38 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v19)),
           result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v20)),
           v38 < result)))
    {
      v24 = *a3;
      *a3 = *a4;
      *a4 = v24;
      v25 = *a3;
      v26 = *a2;
      v27 = *a6[1];
      v28 = *(_DWORD *)(v27 + 4 * v25);
      v29 = *(_DWORD *)(v27 + 4 * v26);
      if (v28 < v29
        || v28 <= v29
        && ((result = TString::StringCompare((TString *)(*a6[2] + 8 * v25), (const TString *)(*a6[2] + 8 * v26)),
             result == -1)
         || !result
         && (v39 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v25)),
             result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v26)),
             v39 < result)))
      {
        v30 = *a2;
        *a2 = *a3;
        *a3 = v30;
        v31 = *a2;
        v32 = *a1;
        v33 = *a6[1];
        v34 = *(_DWORD *)(v33 + 4 * v31);
        v35 = *(_DWORD *)(v33 + 4 * v32);
        if (v34 < v35
          || v34 <= v35
          && ((result = TString::StringCompare((TString *)(*a6[2] + 8 * v31), (const TString *)(*a6[2] + 8 * v32)),
               result == -1)
           || !result
           && (v40 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v31)),
               result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v32)),
               v40 < result)))
        {
          v36 = *a1;
          *a1 = *a2;
          *a2 = v36;
        }
      }
    }
  }
  return result;
}

int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(int *result, int *a2, int *a3, _QWORD **a4)
{
  int *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;

  v6 = a2;
  v7 = result;
  v8 = *a2;
  v9 = *result;
  v10 = *a4[1];
  v11 = *(_DWORD *)(v10 + 4 * v8);
  v12 = *(_DWORD *)(v10 + 4 * v9);
  if (v11 < v12
    || v11 <= v12
    && ((result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v8), (const TString *)(*a4[2] + 8 * v9)),
         result == (int *)-1)
     || !result
     && (v25 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v8)),
         result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v9)),
         v25 < (unint64_t)result)))
  {
    v13 = *a3;
    v14 = *v6;
    v15 = *a4[1];
    v16 = *(_DWORD *)(v15 + 4 * v13);
    v17 = *(_DWORD *)(v15 + 4 * v14);
    if (v16 >= v17)
    {
      if (v16 > v17
        || (result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v13), (const TString *)(*a4[2] + 8 * v14)),
            result != (int *)-1)
        && (result
         || (v18 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v13)),
             result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v14)),
             v18 >= (unint64_t)result)))
      {
        v19 = *v7;
        *v7 = *v6;
        *v6 = v19;
        v20 = *a3;
        v21 = *a4[1];
        v22 = *(_DWORD *)(v21 + 4 * v20);
        v23 = *(_DWORD *)(v21 + 4 * v19);
        if (v22 >= v23)
        {
          if (v22 > v23)
            return result;
          result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v20), (const TString *)(*a4[2] + 8 * v19));
          if (result != (int *)-1)
          {
            if (result)
              return result;
            v39 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v20));
            result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v19));
            v7 = v6;
            v6 = a3;
            if (v39 >= (unint64_t)result)
              return result;
LABEL_10:
            v24 = *v7;
            *v7 = *v6;
            *v6 = v24;
            return result;
          }
        }
        v7 = v6;
      }
    }
    v6 = a3;
    goto LABEL_10;
  }
  v26 = *a3;
  v27 = *v6;
  v28 = *a4[1];
  v29 = *(_DWORD *)(v28 + 4 * v26);
  v30 = *(_DWORD *)(v28 + 4 * v27);
  if (v29 < v30
    || v29 <= v30
    && ((result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v26), (const TString *)(*a4[2] + 8 * v27)),
         result == (int *)-1)
     || !result
     && (v38 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v26)),
         result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v27)),
         v38 < (unint64_t)result)))
  {
    v31 = *v6;
    *v6 = *a3;
    *a3 = v31;
    v32 = *v6;
    v33 = *v7;
    v34 = *a4[1];
    v35 = *(_DWORD *)(v34 + 4 * v32);
    v36 = *(_DWORD *)(v34 + 4 * v33);
    if (v35 < v36)
      goto LABEL_10;
    if (v35 <= v36)
    {
      result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v32), (const TString *)(*a4[2] + 8 * v33));
      if (result == (int *)-1)
        goto LABEL_10;
      if (!result)
      {
        v37 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v32));
        result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v33));
        if (v37 < (unint64_t)result)
          goto LABEL_10;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(int *a1, int *a2, _QWORD **a3)
{
  int *v4;
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int *v14;
  int *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  CFComparisonResult v31;
  unint64_t v32;
  CFComparisonResult v33;
  unint64_t v34;
  CFComparisonResult v35;
  unint64_t v36;
  int *v37;
  int v38;

  v4 = a2;
  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = *(a2 - 1);
      v9 = *a1;
      v10 = *a3[1];
      v11 = *(_DWORD *)(v10 + 4 * v8);
      v12 = *(_DWORD *)(v10 + 4 * v9);
      if (v11 < v12)
        goto LABEL_3;
      if (v11 > v12)
        return result;
      v35 = TString::StringCompare((TString *)(*a3[2] + 8 * v8), (const TString *)(*a3[2] + 8 * v9));
      if (v35 == kCFCompareLessThan
        || v35 == kCFCompareEqualTo
        && (v36 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v8)), v36 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v9))))
      {
LABEL_3:
        v13 = *a1;
        *a1 = *(v4 - 1);
        *(v4 - 1) = v13;
        return 1;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v14 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a1 + 1, a1 + 2, a3);
      v15 = a1 + 3;
      if (a1 + 3 == v4)
        return 1;
      v16 = 0;
      v17 = 0;
      v37 = v4;
      break;
  }
  while (1)
  {
    v18 = *v15;
    v19 = *v14;
    v20 = *a3[1];
    v21 = *(_DWORD *)(v20 + 4 * v18);
    v22 = *(_DWORD *)(v20 + 4 * v19);
    if (v21 < v22
      || v21 <= v22
      && ((v33 = TString::StringCompare((TString *)(*a3[2] + 8 * v18), (const TString *)(*a3[2] + 8 * v19)),
           v33 == kCFCompareLessThan)
       || v33 == kCFCompareEqualTo
       && (v34 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v18)), v34 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v19)))))
    {
      v23 = *v15;
      *v15 = *v14;
      v24 = a1;
      if (v14 != a1)
      {
        v38 = v23;
        v25 = v23;
        v26 = v16;
        while (1)
        {
          v27 = *(int *)((char *)a1 + v26 + 4);
          v28 = *a3[1];
          v29 = *(_DWORD *)(v28 + 4 * v25);
          v30 = *(_DWORD *)(v28 + 4 * v27);
          if (v29 >= v30)
          {
            if (v29 > v30)
              goto LABEL_22;
            v31 = TString::StringCompare((TString *)(*a3[2] + 8 * v25), (const TString *)(*a3[2] + 8 * v27));
            if (v31 != kCFCompareLessThan)
            {
              if (v31)
              {
LABEL_22:
                v24 = v14;
                goto LABEL_24;
              }
              v32 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v25));
              if (v32 >= TNodeFromFINode(*(FINode **)(**a3 + 8 * v27)))
                break;
            }
          }
          --v14;
          *(int *)((char *)a1 + v26 + 8) = *(int *)((char *)a1 + v26 + 4);
          v26 -= 4;
          if (v26 == -8)
          {
            v24 = a1;
            goto LABEL_24;
          }
        }
        v24 = (int *)((char *)a1 + v26 + 8);
LABEL_24:
        v4 = v37;
        v23 = v38;
      }
      *v24 = v23;
      if (++v17 == 8)
        return v15 + 1 == v4;
    }
    v14 = v15;
    v16 += 4;
    if (++v15 == v4)
      return 1;
  }
}

unint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(int *a1, int *a2, int *a3, int *a4, _QWORD **a5)
{
  unint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;

  result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a2, a3, a5);
  v11 = *a4;
  v12 = *a3;
  v13 = *a5[1];
  v14 = *(_DWORD *)(v13 + 4 * v11);
  v15 = *(_DWORD *)(v13 + 4 * v12);
  if (v14 < v15
    || v14 <= v15
    && ((result = TString::StringCompare((TString *)(*a5[2] + 8 * v11), (const TString *)(*a5[2] + 8 * v12)),
         result == -1)
     || !result
     && (v29 = TNodeFromFINode(*(FINode **)(**a5 + 8 * v11)),
         result = TNodeFromFINode(*(FINode **)(**a5 + 8 * v12)),
         v29 < result)))
  {
    v16 = *a3;
    *a3 = *a4;
    *a4 = v16;
    v17 = *a3;
    v18 = *a2;
    v19 = *a5[1];
    v20 = *(_DWORD *)(v19 + 4 * v17);
    v21 = *(_DWORD *)(v19 + 4 * v18);
    if (v20 < v21
      || v20 <= v21
      && ((result = TString::StringCompare((TString *)(*a5[2] + 8 * v17), (const TString *)(*a5[2] + 8 * v18)),
           result == -1)
       || !result
       && (v30 = TNodeFromFINode(*(FINode **)(**a5 + 8 * v17)),
           result = TNodeFromFINode(*(FINode **)(**a5 + 8 * v18)),
           v30 < result)))
    {
      v22 = *a2;
      *a2 = *a3;
      *a3 = v22;
      v23 = *a2;
      v24 = *a1;
      v25 = *a5[1];
      v26 = *(_DWORD *)(v25 + 4 * v23);
      v27 = *(_DWORD *)(v25 + 4 * v24);
      if (v26 < v27
        || v26 <= v27
        && ((result = TString::StringCompare((TString *)(*a5[2] + 8 * v23), (const TString *)(*a5[2] + 8 * v24)),
             result == -1)
         || !result
         && (v31 = TNodeFromFINode(*(FINode **)(**a5 + 8 * v23)),
             result = TNodeFromFINode(*(FINode **)(**a5 + 8 * v24)),
             v31 < result)))
      {
        v28 = *a1;
        *a1 = *a2;
        *a2 = v28;
      }
    }
  }
  return result;
}

uint64_t CopyBlob(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  const void *v10;
  void *v11;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;

  if ((int *)a1 == a2)
    return 0;
  v14 = v3;
  v15 = v4;
  if (!*(_QWORD *)(a1 + 8))
    return 4294959224;
  v7 = *(_DWORD *)(a1 + 4);
  a2[1] = v7;
  if (!v7)
    return 0;
  v8 = *a2;
  if (*a2 < v7)
  {
    v9 = *(_QWORD *)(a3 + 24);
    if (v9)
    {
      v13 = v7;
      (*(void (**)(uint64_t, int *, unsigned int *))(*(_QWORD *)v9 + 48))(v9, a2, &v13);
      v8 = *a2;
      v7 = a2[1];
    }
  }
  if (v7 <= v8)
  {
    v10 = *(const void **)(a1 + 8);
    if (v10)
    {
      v11 = (void *)*((_QWORD *)a2 + 1);
      if (v11)
      {
        memcpy(v11, v10, v7);
        return 0;
      }
    }
  }
  return 4294959233;
}

BOOL TPropertyReference::IsValid(TPropertyReference *this)
{
  return !this || *((_DWORD *)this + 2) != 0;
}

void TPropertyReference::Clear(void ***this)
{
  int v1;
  void **v2;
  void *v3;
  void **v4;
  void *v5;

  v1 = *((_DWORD *)this + 2);
  switch((char)v1)
  {
    case 10:
      if (v1 != 10)
        goto LABEL_9;
      v2 = *this;
      v3 = **this;
      *v2 = 0;

      break;
    case 12:
      if (v1 == 12)
        goto LABEL_5;
      goto LABEL_9;
    case 13:
      if (v1 != 13)
        goto LABEL_9;
      goto LABEL_5;
    case 14:
      if (v1 != 14)
        goto LABEL_9;
      goto LABEL_5;
    case 15:
      if (v1 != 15)
        goto LABEL_9;
      goto LABEL_5;
    case 16:
      if (v1 != 16)
        goto LABEL_9;
      goto LABEL_5;
    case 17:
      if (v1 != 17)
        goto LABEL_9;
      goto LABEL_5;
    case 18:
      if (v1 != 18)
LABEL_9:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_5:
      v4 = *this;
      v5 = **this;
      if (v5)
        CFRelease(v5);
      *v4 = 0;
      break;
    default:
      return;
  }
}

void TPropertyValue::TPropertyValue(TPropertyValue *this, const TPropertyReference *a2)
{
  int v2;
  TPropertyValue *v3;

  this->fData.__impl_.__index = 0;
  v2 = *((_DWORD *)a2 + 2);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_50;
      TPropertyValue::SetAs<BOOL>((uint64_t)this, *(_BYTE **)a2);
      break;
    case 2:
      if (v2 != 2)
        goto LABEL_50;
      TPropertyValue::SetAs<unsigned char>((uint64_t)this, *(_BYTE **)a2);
      break;
    case 3:
      if (v2 != 3)
        goto LABEL_50;
      TPropertyValue::SetAs<short>((uint64_t)this, *(_WORD **)a2);
      break;
    case 4:
      if (v2 != 4)
        goto LABEL_50;
      TPropertyValue::SetAs<int>(this, *(_DWORD **)a2);
      break;
    case 5:
      if (v2 != 5)
        goto LABEL_50;
      TPropertyValue::SetAs<long long>((uint64_t)this, *(_QWORD **)a2);
      break;
    case 6:
      if (v2 != 6)
        goto LABEL_50;
      TPropertyValue::SetAs<unsigned int>(this, *(_DWORD **)a2);
      break;
    case 7:
      if (v2 != 7)
        goto LABEL_50;
      TPropertyValue::SetAs<double>((uint64_t)this, *(_QWORD **)a2);
      break;
    case 8:
      if (v2 != 8)
        goto LABEL_50;
      TPropertyValue::SetAs<Point>(this, *(_DWORD **)a2);
      break;
    case 9:
      if (v2 != 9)
        goto LABEL_50;
      TPropertyValue::SetAs<Blob>(this, *(Blob **)a2);
      break;
    case 10:
      if (v2 != 10)
        goto LABEL_50;
      TPropertyValue::SetAs<NSObject * {__strong}>((id *)this, *(id **)a2);
      break;
    case 11:
      if (v2 != 11)
        goto LABEL_50;
      TPropertyValue::SetAs<TString>((uint64_t)this, *(TString ***)a2);
      break;
    case 12:
      if (v2 != 12)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 13:
      if (v2 != 13)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 14:
      if (v2 != 14)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 15:
      if (v2 != 15)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 16:
      if (v2 != 16)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 17:
      if (v2 != 17)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 18:
      if (v2 != 18)
        goto LABEL_50;
      TPropertyValue::SetAs<TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>((uint64_t)this, *(CFTypeRef **)a2);
      break;
    case 19:
      if (v2 != 19)
        goto LABEL_50;
      v3 = *(TPropertyValue **)a2;
      if (v3 != this)
        TPropertyValue::CopyFrom(this, v3);
      break;
    case 20:
      if (v2 != 20)
        goto LABEL_50;
      TPropertyValue::SetAs<Property>(this, *(_DWORD **)a2);
      break;
    case 21:
      if (v2 != 21)
        goto LABEL_50;
      TPropertyValue::SetAs<NodeRequestOptions>(this, *(_DWORD **)a2);
      break;
    case 22:
      if (v2 != 22)
        goto LABEL_50;
      TPropertyValue::SetAs<NodeDSStoreStatus>(this, *(_DWORD **)a2);
      break;
    case 23:
      if (v2 != 23)
LABEL_50:
        std::__throw_bad_variant_access[abi:ne180100]();
      TPropertyValue::SetAs<DSBladeRunnerFlags>(this, *(_DWORD **)a2);
      break;
    default:
      return;
  }
}

void sub_1CBC988E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::SetAs<BOOL>(uint64_t a1, _BYTE *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<BOOL const&,0,BOOL,1ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_9;
      result = 0;
      *(_BYTE *)a1 = *a2;
      break;
    case 2:
      if (v2 == 2)
        goto LABEL_7;
      goto LABEL_9;
    case 3:
      if (v2 != 3)
        goto LABEL_9;
      goto LABEL_7;
    case 4:
      if (v2 != 4)
        goto LABEL_9;
      goto LABEL_7;
    case 5:
      if (v2 != 5)
        goto LABEL_9;
      goto LABEL_7;
    case 6:
      if (v2 != 6)
        goto LABEL_9;
      goto LABEL_7;
    case 7:
      if (v2 != 7)
        goto LABEL_9;
      goto LABEL_7;
    case 8:
      if (v2 != 8)
        goto LABEL_9;
      goto LABEL_7;
    case 9:
      goto LABEL_7;
    case 10:
      if (v2 != 10)
        goto LABEL_9;
      goto LABEL_7;
    case 11:
      if (v2 != 11)
        goto LABEL_9;
      goto LABEL_7;
    case 12:
      if (v2 != 12)
        goto LABEL_9;
      goto LABEL_7;
    case 13:
      if (v2 != 13)
        goto LABEL_9;
      goto LABEL_7;
    case 14:
      if (v2 != 14)
        goto LABEL_9;
      goto LABEL_7;
    case 15:
      if (v2 != 15)
        goto LABEL_9;
      goto LABEL_7;
    case 16:
      if (v2 != 16)
        goto LABEL_9;
      goto LABEL_7;
    case 17:
      if (v2 != 17)
        goto LABEL_9;
      goto LABEL_7;
    case 18:
      if (v2 != 18)
        goto LABEL_9;
      goto LABEL_7;
    case 19:
      if (v2 != 19)
        goto LABEL_9;
      goto LABEL_7;
    case 20:
      if (v2 != 20)
        goto LABEL_9;
      goto LABEL_7;
    case 21:
      if (v2 != 21)
        goto LABEL_9;
      goto LABEL_7;
    case 22:
      if (v2 != 22)
        goto LABEL_9;
      goto LABEL_7;
    case 23:
      if (v2 != 23)
LABEL_9:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_7:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<unsigned char>(uint64_t a1, _BYTE *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned char const&,0,unsigned char,2ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_11;
      goto LABEL_9;
    case 2:
      if (v2 != 2)
        goto LABEL_11;
      result = 0;
      *(_BYTE *)a1 = *a2;
      break;
    case 3:
      if (v2 == 3)
        goto LABEL_9;
      goto LABEL_11;
    case 4:
      if (v2 != 4)
        goto LABEL_11;
      goto LABEL_9;
    case 5:
      if (v2 != 5)
        goto LABEL_11;
      goto LABEL_9;
    case 6:
      if (v2 != 6)
        goto LABEL_11;
      goto LABEL_9;
    case 7:
      if (v2 != 7)
        goto LABEL_11;
      goto LABEL_9;
    case 8:
      if (v2 != 8)
        goto LABEL_11;
      goto LABEL_9;
    case 9:
      goto LABEL_9;
    case 10:
      if (v2 != 10)
        goto LABEL_11;
      goto LABEL_9;
    case 11:
      if (v2 != 11)
        goto LABEL_11;
      goto LABEL_9;
    case 12:
      if (v2 != 12)
        goto LABEL_11;
      goto LABEL_9;
    case 13:
      if (v2 != 13)
        goto LABEL_11;
      goto LABEL_9;
    case 14:
      if (v2 != 14)
        goto LABEL_11;
      goto LABEL_9;
    case 15:
      if (v2 != 15)
        goto LABEL_11;
      goto LABEL_9;
    case 16:
      if (v2 != 16)
        goto LABEL_11;
      goto LABEL_9;
    case 17:
      if (v2 != 17)
        goto LABEL_11;
      goto LABEL_9;
    case 18:
      if (v2 != 18)
        goto LABEL_11;
      goto LABEL_9;
    case 19:
      if (v2 != 19)
        goto LABEL_11;
      goto LABEL_9;
    case 20:
      if (v2 != 20)
        goto LABEL_11;
      goto LABEL_9;
    case 21:
      if (v2 != 21)
        goto LABEL_11;
      goto LABEL_9;
    case 22:
      if (v2 != 22)
        goto LABEL_11;
      goto LABEL_9;
    case 23:
      if (v2 != 23)
LABEL_11:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_9:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<short>(uint64_t a1, _WORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<short const&,0,short,3ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      result = 0;
      *(_WORD *)a1 = *a2;
      return result;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_47;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      result = 0;
      *(_QWORD *)a1 = (__int16)*a2;
      return result;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      goto LABEL_41;
    case 20:
      if (v2 != 20)
        goto LABEL_43;
LABEL_41:
      result = 4294959246;
      break;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_47;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      *(_DWORD *)a1 = (__int16)*a2;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<int>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<int const&,0,int,4ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      goto LABEL_41;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_47;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      result = 0;
      *(_QWORD *)a1 = (int)*a2;
      return result;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      goto LABEL_41;
    case 20:
      if (v2 != 20)
        goto LABEL_43;
LABEL_41:
      result = 4294959246;
      break;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_47;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<long long>(uint64_t a1, _QWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<long long const&,0,long long,5ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_48;
      goto LABEL_45;
    case 2:
      if (v2 != 2)
        goto LABEL_48;
      goto LABEL_45;
    case 3:
      if (v2 != 3)
        goto LABEL_48;
      goto LABEL_45;
    case 4:
      if (v2 != 4)
        goto LABEL_48;
      goto LABEL_45;
    case 5:
      if (v2 != 5)
        goto LABEL_48;
      result = 0;
      *(_QWORD *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6)
        goto LABEL_48;
      goto LABEL_45;
    case 7:
      if (v2 != 7)
        goto LABEL_48;
      goto LABEL_45;
    case 8:
      if (v2 != 8)
        goto LABEL_48;
      goto LABEL_45;
    case 9:
      goto LABEL_45;
    case 10:
      if (v2 != 10)
        goto LABEL_48;
      goto LABEL_45;
    case 11:
      if (v2 != 11)
        goto LABEL_48;
      goto LABEL_45;
    case 12:
      if (v2 != 12)
        goto LABEL_48;
      goto LABEL_45;
    case 13:
      if (v2 != 13)
        goto LABEL_48;
      goto LABEL_45;
    case 14:
      if (v2 != 14)
        goto LABEL_48;
      goto LABEL_45;
    case 15:
      if (v2 != 15)
        goto LABEL_48;
      goto LABEL_45;
    case 16:
      if (v2 != 16)
        goto LABEL_48;
      goto LABEL_45;
    case 17:
      if (v2 != 17)
        goto LABEL_48;
      goto LABEL_45;
    case 18:
      if (v2 != 18)
        goto LABEL_48;
      goto LABEL_45;
    case 19:
      if (v2 != 19)
        goto LABEL_48;
      goto LABEL_45;
    case 20:
      if (v2 != 20)
        goto LABEL_48;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_48;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_48;
LABEL_45:
      result = 4294959246;
      break;
    case 23:
      if (v2 != 23)
LABEL_48:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      *(_DWORD *)a1 = *a2;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<unsigned int>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned int const&,0,unsigned int,6ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_45;
      goto LABEL_43;
    case 2:
      if (v2 != 2)
        goto LABEL_45;
      goto LABEL_43;
    case 3:
      if (v2 != 3)
        goto LABEL_45;
      goto LABEL_43;
    case 4:
      if (v2 != 4)
        goto LABEL_45;
      goto LABEL_43;
    case 5:
      if (v2 != 5)
        goto LABEL_45;
      goto LABEL_43;
    case 6:
      if (v2 != 6)
        goto LABEL_45;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_45;
      goto LABEL_43;
    case 8:
      if (v2 != 8)
        goto LABEL_45;
      goto LABEL_43;
    case 9:
      goto LABEL_43;
    case 10:
      if (v2 != 10)
        goto LABEL_45;
      goto LABEL_43;
    case 11:
      if (v2 != 11)
        goto LABEL_45;
      goto LABEL_43;
    case 12:
      if (v2 != 12)
        goto LABEL_45;
      goto LABEL_43;
    case 13:
      if (v2 != 13)
        goto LABEL_45;
      goto LABEL_43;
    case 14:
      if (v2 != 14)
        goto LABEL_45;
      goto LABEL_43;
    case 15:
      if (v2 != 15)
        goto LABEL_45;
      goto LABEL_43;
    case 16:
      if (v2 != 16)
        goto LABEL_45;
      goto LABEL_43;
    case 17:
      if (v2 != 17)
        goto LABEL_45;
      goto LABEL_43;
    case 18:
      if (v2 != 18)
        goto LABEL_45;
      goto LABEL_43;
    case 19:
      if (v2 != 19)
        goto LABEL_45;
      goto LABEL_43;
    case 20:
      if (v2 != 20)
        goto LABEL_45;
LABEL_41:
      result = 0;
      *a1 = *a2;
      break;
    case 21:
      if (v2 == 21)
        goto LABEL_43;
      goto LABEL_45;
    case 22:
      if (v2 != 22)
        goto LABEL_45;
      goto LABEL_43;
    case 23:
      if (v2 != 23)
LABEL_45:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_43:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<Point>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Point const&,0,Point,8ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_39;
      goto LABEL_23;
    case 2:
      if (v2 != 2)
        goto LABEL_39;
      goto LABEL_23;
    case 3:
      if (v2 != 3)
        goto LABEL_39;
      goto LABEL_23;
    case 4:
      if (v2 != 4)
        goto LABEL_39;
      goto LABEL_23;
    case 5:
      if (v2 != 5)
        goto LABEL_39;
      goto LABEL_23;
    case 6:
      if (v2 != 6)
        goto LABEL_39;
      goto LABEL_23;
    case 7:
      if (v2 != 7)
        goto LABEL_39;
      goto LABEL_23;
    case 8:
      if (v2 != 8)
        goto LABEL_39;
      result = 0;
      *a1 = *a2;
      break;
    case 9:
      goto LABEL_23;
    case 10:
      if (v2 != 10)
        goto LABEL_39;
      goto LABEL_23;
    case 11:
      if (v2 == 11)
        goto LABEL_23;
      goto LABEL_39;
    case 12:
      if (v2 != 12)
        goto LABEL_39;
      goto LABEL_23;
    case 13:
      if (v2 != 13)
        goto LABEL_39;
      goto LABEL_23;
    case 14:
      if (v2 != 14)
        goto LABEL_39;
      goto LABEL_23;
    case 15:
      if (v2 != 15)
        goto LABEL_39;
      goto LABEL_23;
    case 16:
      if (v2 != 16)
        goto LABEL_39;
      goto LABEL_23;
    case 17:
      if (v2 != 17)
        goto LABEL_39;
      goto LABEL_23;
    case 18:
      if (v2 != 18)
        goto LABEL_39;
      goto LABEL_23;
    case 19:
      if (v2 != 19)
        goto LABEL_39;
      goto LABEL_23;
    case 20:
      if (v2 != 20)
        goto LABEL_39;
      goto LABEL_23;
    case 21:
      if (v2 != 21)
        goto LABEL_39;
      goto LABEL_23;
    case 22:
      if (v2 != 22)
        goto LABEL_39;
      goto LABEL_23;
    case 23:
      if (v2 != 23)
LABEL_39:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_23:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<TString>(uint64_t a1, TString **a2)
{
  int v2;
  const void *v4;
  CFTypeRef v5;
  const void *v6;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(a1, (TString **)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_28;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_28;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_28;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_28;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_28;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_28;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_28;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_28;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_28;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_28;
      if ((TString **)a1 != a2)
        TString::SetStringRefAsImmutable((TString *)a1, *a2);
      return 0;
    case 12:
      if (v2 != 12)
        goto LABEL_28;
      v4 = RetainCF<__CFString const*>((const void **)a2);
      if (v4)
      {
        v5 = CFAutorelease(v4);
        v6 = static_cf_cast<__CFString const*,void const*>(v5);
      }
      else
      {
        v6 = 0;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, v6);
      return 0;
    case 13:
      if (v2 != 13)
        goto LABEL_28;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_28;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_28;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_28;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_28;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_28;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_28;
    case 20:
      if (v2 != 20)
        goto LABEL_28;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_28;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_28;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_28:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<Blob>(TPropertyValue *this, Blob *a2)
{
  unsigned int index;
  uint64_t result;

  index = this->fData.__impl_.__index;
  switch((char)index)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>((uint64_t)this, &kEmptyBlob);
      TPropertyValue::CopyBlob(this, a2);
      goto LABEL_3;
    case 1:
      if (index == 1)
        goto LABEL_5;
      goto LABEL_7;
    case 2:
      if (index != 2)
        goto LABEL_7;
      goto LABEL_5;
    case 3:
      if (index != 3)
        goto LABEL_7;
      goto LABEL_5;
    case 4:
      if (index != 4)
        goto LABEL_7;
      goto LABEL_5;
    case 5:
      if (index != 5)
        goto LABEL_7;
      goto LABEL_5;
    case 6:
      if (index != 6)
        goto LABEL_7;
      goto LABEL_5;
    case 7:
      if (index != 7)
        goto LABEL_7;
      goto LABEL_5;
    case 8:
      if (index != 8)
        goto LABEL_7;
      goto LABEL_5;
    case 9:
      return TPropertyValue::CopyBlob(this, a2);
    case 10:
      if (index != 10)
        goto LABEL_7;
      goto LABEL_5;
    case 11:
      if (index != 11)
        goto LABEL_7;
      goto LABEL_5;
    case 12:
      if (index != 12)
        goto LABEL_7;
      goto LABEL_5;
    case 13:
      if (index != 13)
        goto LABEL_7;
      goto LABEL_5;
    case 14:
      if (index != 14)
        goto LABEL_7;
      goto LABEL_5;
    case 15:
      if (index != 15)
        goto LABEL_7;
      goto LABEL_5;
    case 16:
      if (index != 16)
        goto LABEL_7;
      goto LABEL_5;
    case 17:
      if (index != 17)
        goto LABEL_7;
      goto LABEL_5;
    case 18:
      if (index != 18)
        goto LABEL_7;
      goto LABEL_5;
    case 19:
      if (index != 19)
        goto LABEL_7;
      goto LABEL_5;
    case 20:
      if (index != 20)
        goto LABEL_7;
      goto LABEL_5;
    case 21:
      if (index != 21)
        goto LABEL_7;
      goto LABEL_5;
    case 22:
      if (index != 22)
        goto LABEL_7;
      goto LABEL_5;
    case 23:
      if (index != 23)
LABEL_7:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_5:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<double>(uint64_t a1, _QWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<double const&,0,double,7ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_23;
      goto LABEL_19;
    case 2:
      if (v2 != 2)
        goto LABEL_23;
      goto LABEL_19;
    case 3:
      if (v2 != 3)
        goto LABEL_23;
      goto LABEL_19;
    case 4:
      if (v2 != 4)
        goto LABEL_23;
      goto LABEL_19;
    case 5:
      if (v2 != 5)
        goto LABEL_23;
      goto LABEL_19;
    case 6:
      if (v2 != 6)
        goto LABEL_23;
      goto LABEL_19;
    case 7:
      if (v2 != 7)
        goto LABEL_23;
      result = 0;
      *(_QWORD *)a1 = *a2;
      break;
    case 8:
      if (v2 == 8)
        goto LABEL_19;
      goto LABEL_23;
    case 9:
      goto LABEL_19;
    case 10:
      if (v2 != 10)
        goto LABEL_23;
      goto LABEL_19;
    case 11:
      if (v2 != 11)
        goto LABEL_23;
      goto LABEL_19;
    case 12:
      if (v2 != 12)
        goto LABEL_23;
      goto LABEL_19;
    case 13:
      if (v2 != 13)
        goto LABEL_23;
      goto LABEL_19;
    case 14:
      if (v2 != 14)
        goto LABEL_23;
      goto LABEL_19;
    case 15:
      if (v2 != 15)
        goto LABEL_23;
      goto LABEL_19;
    case 16:
      if (v2 != 16)
        goto LABEL_23;
      goto LABEL_19;
    case 17:
      if (v2 != 17)
        goto LABEL_23;
      goto LABEL_19;
    case 18:
      if (v2 != 18)
        goto LABEL_23;
      goto LABEL_19;
    case 19:
      if (v2 != 19)
        goto LABEL_23;
      goto LABEL_19;
    case 20:
      if (v2 != 20)
        goto LABEL_23;
      goto LABEL_19;
    case 21:
      if (v2 != 21)
        goto LABEL_23;
      goto LABEL_19;
    case 22:
      if (v2 != 22)
        goto LABEL_23;
      goto LABEL_19;
    case 23:
      if (v2 != 23)
LABEL_23:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_19:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;
  TString *v4;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_28;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_28;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_28;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_28;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_28;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_28;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_28;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_28;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_28;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_28;
      v4 = (TString *)*a2;
      if (*(CFTypeRef *)a1 != *a2)
        TString::SetStringRefAsImmutable((TString *)a1, v4);
      return 0;
    case 12:
      if (v2 != 12)
        goto LABEL_28;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 13:
      if (v2 != 13)
        goto LABEL_28;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_28;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_28;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_28;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_28;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_28;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_28;
    case 20:
      if (v2 != 20)
        goto LABEL_28;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_28;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_28;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_28:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_29;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_29;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_29;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_29;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_29;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_29;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_29;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_29;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_29;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_29;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_29;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_29;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 14:
      if (v2 != 14)
        goto LABEL_29;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_29;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_29;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_29;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_29;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_29;
    case 20:
      if (v2 != 20)
        goto LABEL_29;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_29;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_29;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_29:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_31;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_31;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_31;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_31;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_31;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_31;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_31;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_31;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_31;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_31;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_31;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_31;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_31;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 15:
      if (v2 != 15)
        goto LABEL_31;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_31;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_31;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_31;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_31;
    case 20:
      if (v2 != 20)
        goto LABEL_31;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_31;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_31;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_31:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong((id *)a1, (id)*a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<NSObject * {__strong}>(id *location, id *a2)
{
  int v2;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_35;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_35;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_35;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_35;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_35;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_35;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_35;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_35;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_35;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_35;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_35;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_35;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_35;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_35;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_35;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 17:
      if (v2 != 17)
        goto LABEL_35;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_35;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_35;
    case 20:
      if (v2 != 20)
        goto LABEL_35;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_35;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_35;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_35:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_37;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_37;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_37;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_37;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_37;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_37;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_37;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_37;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_37;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_37;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_37;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_37;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_37;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_37;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_37;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_37;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 18:
      if (v2 != 18)
        goto LABEL_37;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_37;
    case 20:
      if (v2 != 20)
        goto LABEL_37;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_37;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_37;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_37:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, CFTypeRef *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_41;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_41;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_41;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_41;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_41;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_41;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_41;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_41;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_41;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_41;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_41;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_41;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_41;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_41;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_41;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_41;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_41;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_41;
    case 20:
      if (v2 != 20)
        goto LABEL_41;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_41;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_41;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_41:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<Property>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Property const&,0,Property,20ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_45;
      goto LABEL_43;
    case 2:
      if (v2 != 2)
        goto LABEL_45;
      goto LABEL_43;
    case 3:
      if (v2 != 3)
        goto LABEL_45;
      goto LABEL_43;
    case 4:
      if (v2 != 4)
        goto LABEL_45;
      goto LABEL_43;
    case 5:
      if (v2 != 5)
        goto LABEL_45;
      goto LABEL_43;
    case 6:
      if (v2 != 6)
        goto LABEL_45;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_45;
      goto LABEL_43;
    case 8:
      if (v2 != 8)
        goto LABEL_45;
      goto LABEL_43;
    case 9:
      goto LABEL_43;
    case 10:
      if (v2 != 10)
        goto LABEL_45;
      goto LABEL_43;
    case 11:
      if (v2 != 11)
        goto LABEL_45;
      goto LABEL_43;
    case 12:
      if (v2 != 12)
        goto LABEL_45;
      goto LABEL_43;
    case 13:
      if (v2 != 13)
        goto LABEL_45;
      goto LABEL_43;
    case 14:
      if (v2 != 14)
        goto LABEL_45;
      goto LABEL_43;
    case 15:
      if (v2 != 15)
        goto LABEL_45;
      goto LABEL_43;
    case 16:
      if (v2 != 16)
        goto LABEL_45;
      goto LABEL_43;
    case 17:
      if (v2 != 17)
        goto LABEL_45;
      goto LABEL_43;
    case 18:
      if (v2 != 18)
        goto LABEL_45;
      goto LABEL_43;
    case 19:
      if (v2 != 19)
        goto LABEL_45;
      goto LABEL_43;
    case 20:
      if (v2 != 20)
        goto LABEL_45;
LABEL_41:
      result = 0;
      *a1 = *a2;
      break;
    case 21:
      if (v2 == 21)
        goto LABEL_43;
      goto LABEL_45;
    case 22:
      if (v2 != 22)
        goto LABEL_45;
      goto LABEL_43;
    case 23:
      if (v2 != 23)
LABEL_45:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_43:
      result = 4294959246;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<NodeRequestOptions>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_48;
      goto LABEL_45;
    case 2:
      if (v2 != 2)
        goto LABEL_48;
      goto LABEL_45;
    case 3:
      if (v2 != 3)
        goto LABEL_48;
      goto LABEL_45;
    case 4:
      if (v2 != 4)
        goto LABEL_48;
      goto LABEL_45;
    case 5:
      if (v2 != 5)
        goto LABEL_48;
      result = 0;
      *(_QWORD *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6)
        goto LABEL_48;
      goto LABEL_45;
    case 7:
      if (v2 != 7)
        goto LABEL_48;
      goto LABEL_45;
    case 8:
      if (v2 != 8)
        goto LABEL_48;
      goto LABEL_45;
    case 9:
      goto LABEL_45;
    case 10:
      if (v2 != 10)
        goto LABEL_48;
      goto LABEL_45;
    case 11:
      if (v2 != 11)
        goto LABEL_48;
      goto LABEL_45;
    case 12:
      if (v2 != 12)
        goto LABEL_48;
      goto LABEL_45;
    case 13:
      if (v2 != 13)
        goto LABEL_48;
      goto LABEL_45;
    case 14:
      if (v2 != 14)
        goto LABEL_48;
      goto LABEL_45;
    case 15:
      if (v2 != 15)
        goto LABEL_48;
      goto LABEL_45;
    case 16:
      if (v2 != 16)
        goto LABEL_48;
      goto LABEL_45;
    case 17:
      if (v2 != 17)
        goto LABEL_48;
      goto LABEL_45;
    case 18:
      if (v2 != 18)
        goto LABEL_48;
      goto LABEL_45;
    case 19:
      if (v2 != 19)
        goto LABEL_48;
      goto LABEL_45;
    case 20:
      if (v2 != 20)
        goto LABEL_48;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_48;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_48;
LABEL_45:
      result = 4294959246;
      break;
    case 23:
      if (v2 != 23)
LABEL_48:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<NodeDSStoreStatus>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeDSStoreStatus const&,0,NodeDSStoreStatus,22ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      goto LABEL_41;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_47;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      result = 0;
      *(_QWORD *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      goto LABEL_41;
    case 20:
      if (v2 != 20)
        goto LABEL_43;
LABEL_41:
      result = 4294959246;
      break;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_47;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<DSBladeRunnerFlags>(_DWORD *a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<DSBladeRunnerFlags const&,0,DSBladeRunnerFlags,23ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1)
        goto LABEL_48;
      goto LABEL_45;
    case 2:
      if (v2 != 2)
        goto LABEL_48;
      goto LABEL_45;
    case 3:
      if (v2 != 3)
        goto LABEL_48;
      goto LABEL_45;
    case 4:
      if (v2 != 4)
        goto LABEL_48;
      goto LABEL_45;
    case 5:
      if (v2 != 5)
        goto LABEL_48;
      result = 0;
      *(_QWORD *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6)
        goto LABEL_48;
      goto LABEL_45;
    case 7:
      if (v2 != 7)
        goto LABEL_48;
      goto LABEL_45;
    case 8:
      if (v2 != 8)
        goto LABEL_48;
      goto LABEL_45;
    case 9:
      goto LABEL_45;
    case 10:
      if (v2 != 10)
        goto LABEL_48;
      goto LABEL_45;
    case 11:
      if (v2 != 11)
        goto LABEL_48;
      goto LABEL_45;
    case 12:
      if (v2 != 12)
        goto LABEL_48;
      goto LABEL_45;
    case 13:
      if (v2 != 13)
        goto LABEL_48;
      goto LABEL_45;
    case 14:
      if (v2 != 14)
        goto LABEL_48;
      goto LABEL_45;
    case 15:
      if (v2 != 15)
        goto LABEL_48;
      goto LABEL_45;
    case 16:
      if (v2 != 16)
        goto LABEL_48;
      goto LABEL_45;
    case 17:
      if (v2 != 17)
        goto LABEL_48;
      goto LABEL_45;
    case 18:
      if (v2 != 18)
        goto LABEL_48;
      goto LABEL_45;
    case 19:
      if (v2 != 19)
        goto LABEL_48;
      goto LABEL_45;
    case 20:
      if (v2 != 20)
        goto LABEL_48;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_48;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_48;
LABEL_45:
      result = 4294959246;
      break;
    case 23:
      if (v2 != 23)
LABEL_48:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      result = 0;
      break;
  }
  return result;
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=(TReferenceCounted **a1, uint64_t a2)
{
  if (a2)
    TRefCount::Retain<int>((unsigned int *)(a2 + 16));
  if (*a1)
    TReferenceCounted::RemovePtrReference(*a1);
  *a1 = (TReferenceCounted *)a2;
  return a1;
}

uint64_t *TString::KEmptyString(TString *this)
{
  unsigned __int8 v1;

  {
    TString::KEmptyString(void)::sEmptyString = (uint64_t)&stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
  }
  return &TString::KEmptyString(void)::sEmptyString;
}

void sub_1CBC9A900(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>(uint64_t a1, _OWORD *a2)
{
  if (*(_DWORD *)(a1 + 16) == 9)
    *(_OWORD *)a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob const&>(a1, a2);
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16))
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate>(a1);
  return a1;
}

uint64_t TPropertyValue::CopyBlob(TPropertyValue *this, const Blob *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (this->fData.__impl_.__index != 9)
    return 4294959224;
  if (this->fData.__impl_.__index != 9)
    std::__throw_bad_variant_access[abi:ne180100]();
  v6[0] = &off_1E874FFD0;
  v7 = v6;
  v2 = CopyBlob((uint64_t)a2, &this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value, (uint64_t)v6);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_8;
  }
  if (v7)
  {
    v4 = 5;
LABEL_8:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return v2;
}

void sub_1CBC9AA5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;

  v2 = result;
  v3 = *(unsigned int *)(result + 16);
  v4 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v3 == -1)
  {
    if ((_DWORD)v4 == -1)
      return result;
  }
  else if ((_DWORD)v4 == -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_1E87516E8[v3])(&v6, result, a2);
    *(_DWORD *)(v2 + 16) = -1;
    return result;
  }
  v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_1E87517A8[v4])(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16))
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate>(result);
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 1)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 2)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _WORD *a2, _WORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 3)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 4)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 5)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 6)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 7)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 8)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 9)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob>(result, a3);
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, void **a2, uint64_t *a3)
{
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * {__strong}>(*a1, a2, a3);
}

CFTypeRef *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(CFTypeRef **a1, const void **a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13ELm13EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm14ELm14EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm15ELm15EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm16ELm16EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm17ELm17EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm18ELm18EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(*a1, a2, a3);
}

TReferenceCounted **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm19ELm19EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, TReferenceCounted **a2, TReferenceCounted **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(*a1, a2, a3);
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm20ELm20EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 20)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm21ELm21EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 21)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm22ELm22EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 22)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm23ELm23EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 23)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate>(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v2])(&v4, a1);
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL>(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_BYTE *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 1;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char>(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_BYTE *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 2;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short>(uint64_t a1, _WORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_WORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 3;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 4;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 5;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 6;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 7;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 8;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob>(uint64_t a1, _OWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_OWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 9;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * {__strong}>(uint64_t a1, void **a2, uint64_t *a3)
{
  uint64_t v3;
  void *v4;

  if (*(_DWORD *)(a1 + 16) == 10)
  {
    v3 = *a3;
    *a3 = 0;
    v4 = *a2;
    *a2 = (void *)v3;

  }
  else
  {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * {__strong}>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * {__strong}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  char v7;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v7, a1);
  *(_DWORD *)(a1 + 16) = -1;
  v5 = *a2;
  *a2 = 0;
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

CFTypeRef *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString>(CFTypeRef *result, const void **a2, CFTypeRef *a3)
{
  if (*((_DWORD *)result + 4) != 11)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<11ul,TString>((uint64_t)result, a3);
  if (a2 != a3)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, a3);
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a3, &stru_1E8752DF8);
  }
  return result;
}

CFTypeRef *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<11ul,TString>(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  CFTypeRef *result;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  result = std::__variant_detail::__alt<11ul,TString>::__alt[abi:ne180100]<TString>((CFTypeRef *)a1, a2);
  *(_DWORD *)(a1 + 16) = 11;
  return result;
}

CFTypeRef *std::__variant_detail::__alt<11ul,TString>::__alt[abi:ne180100]<TString>(CFTypeRef *a1, CFTypeRef *a2)
{
  *a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 12)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 12;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 13)
    return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::operator=<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(a1, a3);
}

const void **TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::operator=<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 13;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 14)
    return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 14;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 15)
    return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::operator=<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(a1, a3);
}

const void **TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::operator=<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 15;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 16)
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 16;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 17)
    return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::operator=<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(a1, a3);
}

const void **TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::operator=<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 17;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 18)
    return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::operator=<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>(a2, a3);
  else
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(a1, a3);
}

const void **TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::operator=<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 18;
  return a1;
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, TReferenceCounted **a2, TReferenceCounted **a3)
{
  if (*(_DWORD *)(a1 + 16) == 19)
    return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>(a2, a3);
  else
    return (TReferenceCounted **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(a1, a3);
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>(TReferenceCounted **a1, TReferenceCounted **a2)
{
  TReferenceCounted *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      TReferenceCounted::RemovePtrReference(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 19;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 20;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 21;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 22;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 23;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;

  v2 = result;
  v3 = *(unsigned int *)(result + 16);
  v4 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v3 == -1)
  {
    if ((_DWORD)v4 == -1)
      return result;
  }
  else if ((_DWORD)v4 == -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_1E87516E8[v3])(&v6, result, a2);
    *(_DWORD *)(v2 + 16) = -1;
    return result;
  }
  v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_1E8751868[v4])(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16))
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate const&>(result);
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 1)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL const&>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 2)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char const&>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _WORD *a2, _WORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 3)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short const&>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 4)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int const&>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 5)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long const&>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 6)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int const&>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 7)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double const&>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 8)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point const&>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t result;

  result = *a1;
  if (*(_DWORD *)(result + 16) != 9)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob const&>(result, a3);
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, id *a2, id *a3)
{
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * const {__strong}&>(*a1, a2, a3);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, TString **a2, TString **a3)
{
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13ELm13EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm14ELm14EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm15ELm15EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm16ELm16EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm17ELm17EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm18ELm18EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(*a1, a2, a3);
}

TReferenceCounted **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm19ELm19EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, TReferenceCounted **a2, uint64_t *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(*a1, a2, a3);
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm20ELm20EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 20)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property const&>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm21ELm21EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 21)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions const&>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm22ELm22EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 22)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus const&>(result, a3);
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm23ELm23EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result;

  result = *a1;
  if (result[4] != 23)
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags const&>(result, a3);
  *a2 = *a3;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate const&>(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v2])(&v4, a1);
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL const&>(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_BYTE *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 1;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char const&>(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_BYTE *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 2;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short const&>(uint64_t a1, _WORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_WORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 3;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 4;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long const&>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 5;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 6;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double const&>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 7;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 8;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob const&>(uint64_t a1, _OWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_OWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 9;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
    objc_storeStrong(location, *a3);
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * const {__strong}&>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(uint64_t a1, TString **this, TString **a3)
{
  uint64_t v3[2];

  if (*(_DWORD *)(a1 + 16) == 11)
  {
    if (this != a3)
      TString::SetStringRefAsImmutable((TString *)this, *a3);
  }
  else
  {
    v3[0] = a1;
    v3[1] = (uint64_t)a3;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(std::__variant_detail::__alt<11ul,TString> &,TString const&)::{unnamed type#1}::operator()[abi:ne180100](v3);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(std::__variant_detail::__alt<11ul,TString> &,TString const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  TString **v2;
  TString v4;

  v1 = *a1;
  v2 = (TString **)a1[1];
  v4.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v4, *v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<11ul,TString>(v1, (CFTypeRef *)&v4.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
}

void sub_1CBC9C23C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 12)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(std::__variant_detail::__alt<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>> &,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(std::__variant_detail::__alt<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>> &,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(v1, &v4);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v4);
}

void sub_1CBC9C2E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 13)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(std::__variant_detail::__alt<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>> &,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(std::__variant_detail::__alt<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>> &,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(v1, &v4);
  return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(&v4);
}

void sub_1CBC9C388(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 14)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(std::__variant_detail::__alt<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>> &,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(std::__variant_detail::__alt<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>> &,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(v1, &v4);
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v4);
}

void sub_1CBC9C42C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 15)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(std::__variant_detail::__alt<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>> &,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(std::__variant_detail::__alt<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>> &,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(v1, &v4);
  return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v4);
}

void sub_1CBC9C4D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 16)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(std::__variant_detail::__alt<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>> &,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(std::__variant_detail::__alt<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>> &,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(v1, &v4);
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v4);
}

void sub_1CBC9C574(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 17)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(std::__variant_detail::__alt<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>> &,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(std::__variant_detail::__alt<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>> &,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(v1, &v4);
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v4);
}

void sub_1CBC9C618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 18)
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(std::__variant_detail::__alt<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>> &,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(std::__variant_detail::__alt<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>> &,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(const void ***)(a1 + 8);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(v1, &v4);
  return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(&v4);
}

void sub_1CBC9C6BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(uint64_t a1, TReferenceCounted **a2, uint64_t *a3)
{
  _QWORD v4[2];

  if (*(_DWORD *)(a1 + 16) == 19)
    return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=(a2, *a3);
  v4[0] = a1;
  v4[1] = a3;
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(std::__variant_detail::__alt<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>> &,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v4);
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(std::__variant_detail::__alt<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>> &,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  TReferenceCounted *v4;

  v1 = *(_QWORD *)a1;
  v2 = **(_QWORD **)(a1 + 8);
  v4 = (TReferenceCounted *)v2;
  if (v2)
    TRefCount::Retain<int>((unsigned int *)(v2 + 16));
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(v1, &v4);
  return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef(&v4);
}

void sub_1CBC9C764(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef((TReferenceCounted **)va);
  _Unwind_Resume(a1);
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 21;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 22;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  char v6;

  v4 = a1[4];
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, _DWORD *))off_1E87516E8[v4])(&v6, a1);
  *a1 = *a2;
  a1[4] = 23;
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<BOOL const&,0,BOOL,1ul,0>(uint64_t a1, _BYTE *a2)
{
  if (*(_DWORD *)(a1 + 16) == 1)
    *(_BYTE *)a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL const&>(a1, a2);
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned char const&,0,unsigned char,2ul,0>(uint64_t a1, _BYTE *a2)
{
  if (*(_DWORD *)(a1 + 16) == 2)
    *(_BYTE *)a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char const&>(a1, a2);
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<short const&,0,short,3ul,0>(uint64_t a1, _WORD *a2)
{
  if (*(_DWORD *)(a1 + 16) == 3)
    *(_WORD *)a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short const&>(a1, a2);
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<int const&,0,int,4ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 4)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int const&>(a1, a2);
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<long long const&,0,long long,5ul,0>(uint64_t a1, _QWORD *a2)
{
  if (*(_DWORD *)(a1 + 16) == 5)
    *(_QWORD *)a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long const&>(a1, a2);
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned int const&,0,unsigned int,6ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 6)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int const&>(a1, a2);
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Point const&,0,Point,8ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 8)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point const&>(a1, a2);
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<double const&,0,double,7ul,0>(uint64_t a1, _QWORD *a2)
{
  if (*(_DWORD *)(a1 + 16) == 7)
    *(_QWORD *)a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double const&>(a1, a2);
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 21)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions const&>(a1, a2);
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeDSStoreStatus const&,0,NodeDSStoreStatus,22ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 22)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus const&>(a1, a2);
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<DSBladeRunnerFlags const&,0,DSBladeRunnerFlags,23ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 23)
    *a1 = *a2;
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags const&>(a1, a2);
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},decltype(nullptr)>(uint64_t a1, void **a2)
{
  void *v2;

  if (*(_DWORD *)(a1 + 16) == 10)
  {
    v2 = *a2;
    *a2 = 0;

  }
  else
  {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,decltype(nullptr)>(a1);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,decltype(nullptr)>(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1E87516E8[v2])(&v4, a1);
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E874FFD0;
  return result;
}

void std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E874FFD0;
}

uint64_t std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;
  uint64_t result;

  *(_DWORD *)a2 = *a3;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
    MEMORY[0x1D17A53B8](v4, 0x1000C8077774924);
  result = operator new[]();
  *(_QWORD *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::target_type()
{
}

void sub_1CBC9CE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;

  v15 = v14;

  _Unwind_Resume(a1);
}

void sub_1CBC9CEA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9CEF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9CFE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D0D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D1FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D26C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)FINode_ICloudAppLibrary;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1CBC9D33C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBC9D3F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC9D458(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D4FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D55C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBC9D5B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D648(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9D848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  id *v4;
  id v6;
  va_list va;
  id v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, id);
  v8 = va_arg(va1, id);
  v9 = va_arg(va1, _QWORD);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  TNodeEventPtr::~TNodeEventPtr(v4);

  TNodeEventPtr::~TNodeEventPtr((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1CBC9D9D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9DAB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9DB70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9DF00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, const void *a11, void *a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, id a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  void *v31;
  id *v32;
  id *v33;
  void *v34;

  TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)&a20);
  objc_destroyWeak(v33);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  objc_destroyWeak(v32);

  objc_destroyWeak(&location);
  objc_destroyWeak(&a17);

  _Unwind_Resume(a1);
}

void AddProgressObserver(void *a1, uint64_t *a2, uint64_t a3)
{
  id v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  TString *v11;
  _QWORD *v12;
  uint64_t v13;
  TString v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v7 = *a2;
  for (i = a2[1]; i != v7; TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)(i - 40)))
    ;
  a2[1] = v7;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v8 = objc_msgSend(&unk_1E875AD40, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
  if (v8)
  {
    v9 = *(_QWORD *)v16;
    do
    {
      v10 = 0;
      do
      {
        if (*(_QWORD *)v16 != v9)
          objc_enumerationMutation(&unk_1E875AD40);
        v11 = (TString *)*(id *)(*((_QWORD *)&v15 + 1) + 8 * v10);
        v14.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v14, v11);

        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v19, a3);
        TKeyValueObserver::StartObserving<std::function<void ()(void)>>(a2, v5, &v14, (uint64_t)v19, 0);
        v12 = v20;
        if (v20 == v19)
        {
          v12 = v19;
          v13 = 4;
        }
        else
        {
          if (!v20)
            goto LABEL_14;
          v13 = 5;
        }
        (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_14:
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);
        ++v10;
      }
      while (v8 != v10);
      v8 = objc_msgSend(&unk_1E875AD40, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
    }
    while (v8);
  }

}

void sub_1CBC9E1C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBC9E5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;
  void *v25;
  void *v26;
  id *v27;
  const void **v28;
  uint64_t v29;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v28);
  objc_destroyWeak(v27);
  -[DSFileProgress progressChanged:]::$_3::~$_3((uint64_t)&location);

  -[DSFileProgress progressChanged:]::$_3::~$_3((uint64_t)&a24);
  objc_destroyWeak((id *)(v29 - 112));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v29 - 104));

  _Unwind_Resume(a1);
}

void sub_1CBC9E698()
{
  void *v0;

  JUMPOUT(0x1CBC9E688);
}

void sub_1CBC9E6A4()
{
  JUMPOUT(0x1CBC9E688);
}

void sub_1CBC9E6AC()
{
  JUMPOUT(0x1CBC9E68CLL);
}

void OperationTypeFromProgress(NSDictionary *a1@<X0>, TString *a2@<X8>)
{
  void *v3;
  TString *v4;
  CFStringRef theString;

  -[NSDictionary objectForKeyedSubscript:](a1, "objectForKeyedSubscript:", *MEMORY[0x1E0CB30C8]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<NSString,objc_object * {__strong}>(v3);
  v4 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&theString, v4);

  if (CFStringGetLength(theString))
  {
    if (operator==((void **)&theString, (void *)*MEMORY[0x1E0CB30B0]))
    {
      a2->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a2, (TString *)CFSTR("CopyOperationType"));
LABEL_6:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      return;
    }
    if (operator==((void **)&theString, (void *)*MEMORY[0x1E0CB30A0]))
    {
      a2->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a2, (TString *)CFSTR("AirdropOperationType"));
      goto LABEL_6;
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, (TString *)CFSTR("CopyOperationType"));
}

void sub_1CBC9E804(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void **v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

id TProgressMap::GetProgressDispatchQueue(TProgressMap *this)
{
  if (TProgressMap::GetProgressDispatchQueue(void)::once != -1)
    dispatch_once(&TProgressMap::GetProgressDispatchQueue(void)::once, &__block_literal_global_1);
  return (id)TProgressMap::GetProgressDispatchQueue(void)::progressQueue;
}

void sub_1CBC9E988(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__3(uint64_t a1, uint64_t a2)
{
  __n128 result;

  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  *(_QWORD *)(a1 + 40) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(_QWORD *)(a1 + 48) = *(id *)(a2 + 48);
  result = *(__n128 *)(a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

void sub_1CBC9EA24(_Unwind_Exception *a1)
{
  id *v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__3(uint64_t a1)
{
  id *v2;

  v2 = (id *)(a1 + 32);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
  objc_destroyWeak(v2);
}

id TProgressInfo::CreateProgressDictionary(TProgressInfo *this)
{
  double v2;
  double v3;
  void *v4;
  double v5;
  void *v6;
  void *v7;
  void *v8;
  double v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  _QWORD v28[15];
  void *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  id v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v28[0] = CFSTR("InlineState");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *((unsigned int *)this + 17));
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = v27;
  v28[1] = CFSTR("InlinePercentageDone");
  LODWORD(v2) = *((_DWORD *)this + 4);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2);
  v30 = objc_claimAutoreleasedReturnValue();
  v28[2] = CFSTR("InlineTimeEstimate");
  LODWORD(v3) = *((_DWORD *)this + 18);
  v26 = (void *)v30;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v3);
  v31 = objc_claimAutoreleasedReturnValue();
  v28[3] = CFSTR("TotalSize");
  v25 = (void *)v31;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *(_QWORD *)this);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = v24;
  v28[4] = CFSTR("CompletedSize");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *((_QWORD *)this + 1));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = v4;
  v28[5] = CFSTR("DownloadPercentageDone");
  LODWORD(v5) = *((_DWORD *)this + 10);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = v6;
  v28[6] = CFSTR("DownloadTotalSize");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *((_QWORD *)this + 3));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = v7;
  v28[7] = CFSTR("DownloadCompletedSize");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *((_QWORD *)this + 4));
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = v8;
  v28[8] = CFSTR("UploadPercentageDone");
  LODWORD(v9) = *((_DWORD *)this + 16);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = v10;
  v28[9] = CFSTR("UploadTotalSize");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *((_QWORD *)this + 6));
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = v11;
  v28[10] = CFSTR("UploadCompletedSize");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *((_QWORD *)this + 7));
  v12 = objc_claimAutoreleasedReturnValue();
  v13 = (void *)v12;
  if (*((_BYTE *)this + 76))
    v14 = MEMORY[0x1E0C9AAB0];
  else
    v14 = MEMORY[0x1E0C9AAA0];
  v39 = v12;
  v40 = v14;
  v28[11] = CFSTR("InlineCanCancel");
  v28[12] = CFSTR("InlineCanPause");
  if (*((_BYTE *)this + 77))
    v15 = MEMORY[0x1E0C9AAB0];
  else
    v15 = MEMORY[0x1E0C9AAA0];
  if (*((_BYTE *)this + 78))
    v16 = MEMORY[0x1E0C9AAB0];
  else
    v16 = MEMORY[0x1E0C9AAA0];
  v41 = v15;
  v42 = v16;
  v28[13] = CFSTR("UserDownload");
  v28[14] = CFSTR("InlineOperationType");
  v17 = objc_retainAutorelease(*((id *)this + 10));
  v43 = v17;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v29, v28, 15);
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  v19 = *((id *)this + 14);
  if (v19
    && (v20 = v19,
        v21 = (void *)objc_msgSend(v18, "mutableCopy"),
        objc_msgSend(v21, "setObject:forKeyedSubscript:", v20, CFSTR("InlineImage")),
        v20,
        v21))
  {
    v22 = (id)objc_msgSend(v21, "copy");
  }
  else
  {
    v22 = v18;
    v21 = 0;
  }

  return v22;
}

void sub_1CBC9EEA8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TProgressMap::NormalizedPathForPath(TString **this@<X0>, TString *a2@<X8>)
{
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *this);
}

void sub_1CBC9EFA4(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

BOOL TProgressMap::HasProgress(TProgressMap *this, const __CFURL *a2)
{
  const void **v2;
  os_unfair_lock_s *v3;
  _BOOL8 v4;
  CFTypeRef cf;
  TString v7;

  TCFURLInfo::FileSystemRepresentation(this, (const __CFURL *)1, &v7);
  TProgressMap::NormalizedPathForPath((TString **)&v7, (TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v7.fString.fRef, &cf);
  CFRetain(&stru_1E8752DF8);
  if (cf)
    CFRelease(cf);
  cf = &stru_1E8752DF8;
  v2 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  v3 = (os_unfair_lock_s *)TProgressMap::ProgressLock((TProgressMap *)v2);
  os_unfair_lock_lock(v3);
  v4 = TProgressMap::gProgressMap
    && *(_QWORD *)(TProgressMap::gProgressMap + 16)
    && TProgressMap::gProgressMap + 8 != std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, (CFStringRef *)&v7.fString.fRef);
  os_unfair_lock_unlock(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  return v4;
}

void sub_1CBC9F078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

int *TProgressMap::ProgressLock(TProgressMap *this)
{
  unsigned __int8 v1;

  {
    TProgressMap::ProgressLock(void)::gProgressLock = 0;
  }
  return &TProgressMap::ProgressLock(void)::gProgressLock;
}

uint64_t TProgressMap::GetProgress(TProgressMap *this, const TNodePtr *a2, TProgressInfo *a3)
{
  os_unfair_lock_s *v5;
  CFIndex Length;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  os_unfair_lock_s *v21;
  uint64_t v22;
  double v23;
  float v24;
  int v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  TString *v29;
  __CFString *fFINode;
  unint64_t *v31;
  unint64_t v32;
  __int128 cf;
  CFStringRef theString;
  std::__shared_weak_count *v36;

  v5 = (os_unfair_lock_s *)TProgressMap::ProgressLock(this);
  os_unfair_lock_lock(v5);
  if (TProgressMap::gProgressMap && *(_QWORD *)(TProgressMap::gProgressMap + 16))
  {
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    ProgressPathForNode((const TNodePtr *)this, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&theString, (const void **)&cf);
    CFRetain(&stru_1E8752DF8);
    if ((_QWORD)cf)
      CFRelease((CFTypeRef)cf);
    *(_QWORD *)&cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&cf);
    Length = CFStringGetLength(theString);
    v7 = Length != 0;
    if (!Length)
      goto LABEL_10;
    v8 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
    v9 = v8;
    if (TProgressMap::gProgressMap + 8 != v8)
    {
      *(_OWORD *)&a2->fFINode = *(_OWORD *)(v8 + 40);
      v10 = *(_OWORD *)(v8 + 56);
      v11 = *(_OWORD *)(v8 + 72);
      v12 = *(_OWORD *)(v8 + 88);
      *(_OWORD *)((char *)&a2[7].fFINode + 7) = *(_OWORD *)(v8 + 103);
      *(_OWORD *)&a2[4].fFINode = v11;
      *(_OWORD *)&a2[6].fFINode = v12;
      *(_OWORD *)&a2[2].fFINode = v10;
      if ((const TNodePtr *)(v8 + 40) != a2)
        TString::SetStringRefAsImmutable((TString *)&a2[10], *(TString **)(v8 + 120));
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](&a2[11].fFINode, (uint64_t *)(v9 + 128));
      objc_storeStrong((id *)&a2[13].fFINode, *(id *)(v9 + 144));
      objc_storeStrong((id *)&a2[14].fFINode, *(id *)(v9 + 152));
LABEL_10:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      os_unfair_lock_unlock(v5);
      return v7;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  os_unfair_lock_unlock(v5);
  v13 = TNodeFromFINode(*(FINode **)this);
  v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
  os_unfair_lock_lock(v14);
  v16 = *(_QWORD *)(v13 + 16);
  v15 = *(std::__shared_weak_count **)(v13 + 24);
  theString = (CFStringRef)v16;
  v36 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v14);
  os_unfair_lock_lock((os_unfair_lock_t)(v16 + 100));
  v19 = *(unsigned __int16 *)(v16 + 119);
  v20 = *(unsigned int *)(v16 + 115) | (unint64_t)(v19 << 32);
  os_unfair_lock_unlock((os_unfair_lock_t)(v16 + 100));
  if ((v20 & 0x20000000000) != 0)
  {
    v21 = (os_unfair_lock_s *)(v16 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(v16 + 96));
    v22 = *(_QWORD *)(v16 + 80);
    if (v22)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v22 + 72));
      v23 = *(double *)(v22 + 48);
      os_unfair_lock_unlock((os_unfair_lock_t)(v22 + 72));
      v24 = v23;
    }
    else
    {
      v24 = 0.0;
    }
    os_unfair_lock_unlock(v21);
    if (v24 >= 100.0)
      v25 = 0;
    else
      v25 = 3;
    *(float *)&a2[2].fFINode = v24;
    if (v24 <= 0.0)
      v25 = 2;
    HIDWORD(a2[8].fFINode) = v25;
    LODWORD(a2[9].fFINode) = 0;
    cf = 0uLL;
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)&a2[11], &cf);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&cf + 1);
    if (*((_QWORD *)&cf + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&cf + 1) + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    a2->fFINode = 0;
    a2[1].fFINode = 0;
    WORD2(a2[9].fFINode) = 0;
    fFINode = (__CFString *)a2[10].fFINode;
    v29 = (TString *)&a2[10];
    if (fFINode != CFSTR("CopyOperationType"))
      TString::SetStringRefAsImmutable(v29, (TString *)CFSTR("CopyOperationType"));
    v15 = v36;
  }
  v7 = (v19 >> 9) & 1;
  if (v15)
  {
    v31 = (unint64_t *)&v15->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return v7;
}

void sub_1CBC9F3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProgressPathForNode(const TNodePtr *a1@<X0>, TString *a2@<X8>)
{
  uint64_t v4;
  uint64_t *v5;
  TString v6;
  const void *v7[2];

  if (TNodeFromFINode(a1->fFINode))
  {
    v4 = TNodeFromFINode(a1->fFINode);
    TNode::GetPath(v4, 1, (uint64_t)v7);
    TString::TString(&v6, "", 0);
    fstd::optional_err<TString,int>::value_or<TString>((uint64_t)v7, (CFTypeRef *)&v6.fString.fRef, (CFTypeRef *)&a2->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v7);
  }
  else
  {
    v5 = TString::KEmptyString(0);
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)*v5);
  }
}

void sub_1CBC9F4C0(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TProgressMap::KeyForMatchingProgressObject(TProgressMap *this@<X0>, TString *a2@<X8>)
{
  TProgressMap *v4;
  TProgressMap *v5;
  uint64_t v6;
  TString *v7;
  __CFString *fRef;
  __CFString *v9;
  BOOL v10;
  NSObject *v11;
  void *v12;
  int v13;
  void *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = this;
  v5 = v4;
  if (!v4 || !TProgressMap::gProgressMap)
    goto LABEL_16;
  v6 = TProgressMap::gProgressMap + 8;
  v7 = *(TString **)TProgressMap::gProgressMap;
  if (*(_QWORD *)TProgressMap::gProgressMap != TProgressMap::gProgressMap + 8)
  {
    while ((TProgressMap *)v7[18].fString.fRef != v4)
    {
      fRef = v7[1].fString.fRef;
      if (fRef)
      {
        do
        {
          v9 = fRef;
          fRef = (__CFString *)fRef->isa;
        }
        while (fRef);
      }
      else
      {
        do
        {
          v9 = v7[2].fString.fRef;
          v10 = v9->isa == v7;
          v7 = (TString *)v9;
        }
        while (!v10);
      }
      v7 = (TString *)v9;
      if (v9 == (__CFString *)v6)
        goto LABEL_16;
    }
  }
  if (v7 != (TString *)v6)
  {
    LogObj(5);
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      SanitizedPath(v7 + 4);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v13 = 138543362;
      v14 = v12;
      _os_log_impl(&dword_1CBC4A000, v11, OS_LOG_TYPE_INFO, "Found path matching progress object %{public}@", (uint8_t *)&v13, 0xCu);

    }
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)v7[4].fString.fRef);
  }
  else
  {
LABEL_16:
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
  }

}

void sub_1CBC9F660(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

const void **TProgressMap::UpdateExternalProgress(TNodePtr *this, const TNodePtr *a2, const TProgressInfo *a3)
{
  _BOOL4 v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  __CFString *v10;
  __CFString *v11;
  unint64_t *p_info;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  __CFString *v16;
  TNode *v17;
  const TNode *v18;
  int v19;
  TProgressMap *v20;
  os_unfair_lock_s *v21;
  TProgressMap *Length;
  os_unfair_lock_s *v23;
  uint64_t v24;
  uint64_t **v25;
  _BOOL4 v26;
  int fFINode_high;
  int v28;
  _BOOL4 v29;
  float v30;
  float v31;
  int v32;
  int v33;
  FINode *fFINode;
  FINode *v35;
  FINode *v36;
  float v37;
  FINode *v38;
  FINode *v39;
  float v40;
  TString *v41;
  const void *v42;
  TString **v43;
  int v44;
  const TNodePtr *v45;
  _BOOL4 v46;
  uint64_t v47;
  TString v49;
  CFStringRef theString[3];
  _BYTE buf[12];
  __int16 v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v5 = HIDWORD(a2[8].fFINode) == 0;
  ProgressPathForNode(this, (TString *)buf);
  TProgressMap::NormalizedPathForPath((TString **)buf, (TString *)theString);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if (!CFStringGetLength(theString[0]))
  {
    LogObj(5);
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = TNodeFromFINode(this->fFINode);
      if (v7)
      {
        v8 = TNodeFromFINode(this->fFINode);
        v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
        os_unfair_lock_lock(v9);
        v11 = *(__CFString **)(v8 + 16);
        v10 = *(__CFString **)(v8 + 24);
        theString[1] = v11;
        theString[2] = v10;
        if (v10)
        {
          p_info = (unint64_t *)&v10->info;
          do
            v13 = __ldxr(p_info);
          while (__stxr(v13 + 1, p_info));
        }
        os_unfair_lock_unlock(v9);
        TFSInfo::Name((TFSInfo *)v11, &v49);
        if (v10)
        {
          v14 = (unint64_t *)&v10->info;
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            (*((void (**)(__CFString *))v10->isa + 2))(v10);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v10);
          }
        }
        SanitizedStr(&v49);
        v16 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v16 = CFSTR("nil node");
      }
      v17 = (TNode *)TNodeFromFINode(this->fFINode);
      v19 = TNode::Validate(v17, v18);
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)&buf[4] = v16;
      v52 = 1024;
      v53 = v19;
      _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_INFO, "No path found for progress %{public}@ valid=%d", buf, 0x12u);
      if (v7)
      {

        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v49.fString.fRef);
      }
    }

    v21 = (os_unfair_lock_s *)TProgressMap::ProgressLock(v20);
    os_unfair_lock_lock(v21);
    TProgressMap::KeyForMatchingProgressObject((TProgressMap *)a2[13].fFINode, (TString *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)theString, (const void **)buf);
    CFRetain(&stru_1E8752DF8);
    if (*(_QWORD *)buf)
      CFRelease(*(CFTypeRef *)buf);
    *(_QWORD *)buf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    os_unfair_lock_unlock(v21);
    v5 = 0;
  }
  Length = (TProgressMap *)CFStringGetLength(theString[0]);
  if (Length)
  {
    v23 = (os_unfair_lock_s *)TProgressMap::ProgressLock(Length);
    os_unfair_lock_lock(v23);
    if (!TProgressMap::gProgressMap)
    {
      os_unfair_lock_unlock(v23);
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    }
    v24 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, theString);
    v25 = (uint64_t **)TProgressMap::gProgressMap;
    v26 = TProgressMap::gProgressMap + 8 == v24 && v5;
    if (v26 && a2[13].fFINode)
    {
      TProgressMap::KeyForMatchingProgressObject((TProgressMap *)a2[13].fFINode, (TString *)buf);
      if (CFStringGetLength(*(CFStringRef *)buf))
      {
        TString::SetStringRefAsImmutable((TString *)theString, *(TString **)buf);
        v24 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, theString);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
      v25 = (uint64_t **)TProgressMap::gProgressMap;
    }
    if ((uint64_t **)v24 == v25 + 1)
    {
      v29 = 0;
    }
    else
    {
      fFINode_high = HIDWORD(a2[8].fFINode);
      if (fFINode_high)
      {
        v28 = *(_DWORD *)(v24 + 108);
        v29 = v28 != fFINode_high;
        if (v28 != fFINode_high)
          *(_DWORD *)(v24 + 108) = fFINode_high;
        v30 = *(float *)&a2[2].fFINode;
        if (*(float *)(v24 + 56) != v30)
        {
          *(float *)(v24 + 56) = v30;
          v29 = 1;
        }
        v31 = *(float *)&a2[9].fFINode;
        if (*(float *)(v24 + 112) != v31)
        {
          *(float *)(v24 + 112) = v31;
          v29 = 1;
        }
        v32 = BYTE5(a2[9].fFINode);
        if (*(unsigned __int8 *)(v24 + 117) != v32)
        {
          *(_BYTE *)(v24 + 117) = v32;
          v29 = 1;
        }
        v33 = BYTE4(a2[9].fFINode);
        if (*(unsigned __int8 *)(v24 + 116) != v33)
        {
          *(_BYTE *)(v24 + 116) = v33;
          v29 = 1;
        }
        if (*(FINode **)(v24 + 40) != a2->fFINode)
        {
          *(TNodePtr *)(v24 + 40) = (TNodePtr)a2->fFINode;
          v29 = 1;
        }
        fFINode = a2[1].fFINode;
        if (*(FINode **)(v24 + 48) != fFINode)
        {
          *(_QWORD *)(v24 + 48) = fFINode;
          v29 = 1;
        }
        v35 = a2[3].fFINode;
        if (*(FINode **)(v24 + 64) != v35)
        {
          *(_QWORD *)(v24 + 64) = v35;
          v29 = 1;
        }
        v36 = a2[4].fFINode;
        if (*(FINode **)(v24 + 72) != v36)
        {
          *(_QWORD *)(v24 + 72) = v36;
          v29 = 1;
        }
        v37 = *(float *)&a2[5].fFINode;
        if (*(float *)(v24 + 80) != v37)
        {
          *(float *)(v24 + 80) = v37;
          v29 = 1;
        }
        v38 = a2[6].fFINode;
        if (*(FINode **)(v24 + 88) != v38)
        {
          *(_QWORD *)(v24 + 88) = v38;
          v29 = 1;
        }
        v39 = a2[7].fFINode;
        if (*(FINode **)(v24 + 96) != v39)
        {
          *(_QWORD *)(v24 + 96) = v39;
          v29 = 1;
        }
        v40 = *(float *)&a2[8].fFINode;
        if (*(float *)(v24 + 104) != v40)
        {
          *(float *)(v24 + 104) = v40;
          v29 = 1;
        }
        v42 = *(const void **)(v24 + 120);
        v41 = (TString *)(v24 + 120);
        v43 = (TString **)&a2[10];
        v44 = v29;
        if (CFEqual(v42, a2[10].fFINode))
          goto LABEL_65;
        if (v41 != (TString *)v43)
          TString::SetStringRefAsImmutable(v41, *v43);
      }
      else
      {
        std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(v25, (uint64_t *)v24);
        std::pair<TString,TProgressInfo>::~pair(v24 + 32);
        operator delete((void *)v24);
      }
      v29 = 1;
    }
    v44 = 1;
LABEL_65:
    os_unfair_lock_unlock(v23);
    if (TNodeFromFINode(this->fFINode))
    {
      if (v44)
        TProgressMap::PostProgressChange(&this->fFINode, v45);
      if (HIDWORD(a2[8].fFINode))
        v46 = 0;
      else
        v46 = v29;
      if (v46)
      {
        v47 = TNodeFromFINode(this->fFINode);
        TNode::HandleSync(v47, 0x10080000u);
      }
    }
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
}

void sub_1CBC9FB44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  os_unfair_lock_s *v2;
  const void *v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  os_unfair_lock_unlock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TProgressMap::PostProgressChange(FINode **this, const TNodePtr *a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  os_unfair_lock_s *v9;
  int v10;
  unint64_t *v11;
  unint64_t v12;
  TNode *v13;
  const TNode *v14;

  if (TNodeFromFINode(*this))
  {
    v3 = TNodeFromFINode(*this);
    v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
    os_unfair_lock_lock(v4);
    v6 = *(_QWORD *)(v3 + 16);
    v5 = *(std::__shared_weak_count **)(v3 + 24);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v4);
    v9 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    v10 = *(_DWORD *)(v6 + 115);
    os_unfair_lock_unlock(v9);
    if (!v5)
      goto LABEL_9;
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if ((v10 & 0x20) != 0)
        goto LABEL_11;
    }
    else
    {
LABEL_9:
      if ((v10 & 0x20) != 0)
      {
LABEL_11:
        v14 = (const TNode *)TNodeFromFINode(*this);
        TNode::SendNotification(v14, 2, (id *)this, 1768845426, 0);
        return;
      }
    }
    v13 = (TNode *)TNodeFromFINode(*this);
    TNode::UpdatePropertySynchronous(v13, 1819240307, 0, 0);
    goto LABEL_11;
  }
}

void TProgressMap::AddExternalProgress(TProgressMap *this, TNodePtr *a2, TNodePtr *a3, NSDictionary *a4)
{
  TProgressMap *v7;
  TNodePtr *v8;
  void *v9;
  const __CFNumber *v10;
  void *v11;
  NSProgress *v12;
  double v13;
  float v14;
  _QWORD *v15;
  TProgressMap *v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  const TString *v20;
  const TNodePtr *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  CFTypeRef cf;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  _BYTE v36[7];
  const __CFString *v37;
  __int128 v38;
  __int128 v39;
  double valuePtr;
  TString v41;

  v7 = this;
  v8 = a3;
  if (TNodeFromFINode(a2->fFINode))
  {
    ProgressPathForNode(a2, &v41);
    if (CFStringGetLength(v41.fString.fRef))
    {
      -[TNodePtr objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", *MEMORY[0x1E0CB3070]);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = (const __CFNumber *)static_cf_cast<__CFString const*,void const*>(v9);

      valuePtr = 0.0;
      if (v10)
        CFNumberGetValue(v10, kCFNumberDoubleType, &valuePtr);
      -[TNodePtr objectForKey:](v8, "objectForKey:", *MEMORY[0x1E0CB3098]);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v26 = 0;
      v27 = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v32 = 0;
      v33 = 0;
      v34 = 0;
      *(_DWORD *)&v36[3] = 0;
      v37 = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      v38 = 0u;
      v39 = 0u;
      v35 = TProgressInfo::ProgressStateFromProgress(v7, v12);
      -[TProgressMap fractionCompleted](v7, "fractionCompleted");
      *(float *)&v13 = v13 * 100.0;
      v14 = valuePtr;
      v28 = LODWORD(v13);
      *(float *)v36 = v14;
      OperationTypeFromProgress((NSDictionary *)v8, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v37, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      v26 = -[TProgressMap totalUnitCount](v7, "totalUnitCount");
      v27 = -[TProgressMap completedUnitCount](v7, "completedUnitCount");
      v36[5] = -[TProgressMap isPausable](v7, "isPausable");
      v36[4] = -[TProgressMap isCancellable](v7, "isCancellable");
      v15 = operator new(0x28uLL);
      v15[2] = 0;
      *v15 = &unk_1E8750768;
      v15[1] = 0;
      v16 = v7;
      v15[3] = &unk_1E874FE60;
      v15[4] = v16;
      v17 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      *(_QWORD *)&v38 = v15 + 3;
      *((_QWORD *)&v38 + 1) = v15;
      if (v17)
      {
        p_shared_owners = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldaxr(p_shared_owners);
        while (__stlxr(v19 - 1, p_shared_owners));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      if (v11)
        objc_storeStrong((id *)&v39 + 1, v11);
      objc_storeStrong((id *)&v39, this);
      TProgressMap::AddProgressForPath((TProgressMap *)&v26, (TString **)&v41, v20);
      if (TNodeFromFINode(a2->fFINode))
        TProgressMap::PostProgressChange(&a2->fFINode, v21);

      v22 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      if (*((_QWORD *)&v38 + 1))
      {
        v23 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v37);

    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v41.fString.fRef);
  }

}

void sub_1CBC9FFE4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v3 - 72));

  _Unwind_Resume(a1);
}

uint64_t TProgressInfo::ProgressStateFromProgress(TProgressInfo *this, NSProgress *a2)
{
  TProgressInfo *v2;
  uint64_t v3;

  v2 = this;
  if ((-[TProgressInfo isFinished](v2, "isFinished") & 1) != 0
    || (-[TProgressInfo isCancelled](v2, "isCancelled") & 1) != 0)
  {
    v3 = 0;
  }
  else if (-[TProgressInfo isIndeterminate](v2, "isIndeterminate"))
  {
    v3 = 2;
  }
  else
  {
    v3 = 3;
  }

  return v3;
}

void sub_1CBCA009C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

const void **TProgressMap::AddProgressForPath(TProgressMap *this, TString **a2, const TString *a3)
{
  TProgressMap *v4;
  os_unfair_lock_s *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t **v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  CFStringRef v13[11];
  const void *v14;
  std::__shared_weak_count *v15;
  id v16;
  id v17;
  TString v18;

  TProgressMap::NormalizedPathForPath(a2, &v18);
  v5 = (os_unfair_lock_s *)TProgressMap::ProgressLock(v4);
  os_unfair_lock_lock(v5);
  v6 = (_QWORD *)TProgressMap::gProgressMap;
  if (!TProgressMap::gProgressMap)
  {
    v6 = (_QWORD *)operator new();
    v6[2] = 0;
    v6[1] = 0;
    *v6 = v6 + 1;
    TProgressMap::gProgressMap = (uint64_t)v6;
  }
  v7 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>((uint64_t)v6, (CFStringRef *)&v18.fString.fRef);
  v8 = (uint64_t **)TProgressMap::gProgressMap;
  if (TProgressMap::gProgressMap + 8 == v7)
  {
    std::pair<TString,TProgressInfo>::pair[abi:ne180100]<true,0>((uint64_t)v13, (TString **)&v18, (__int128 *)this);
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__emplace_unique_key_args<TString,std::pair<TString,TProgressInfo>>(v8, v13, (uint64_t)v13);

    v9 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v14);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v13);
  }
  os_unfair_lock_unlock(v5);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
}

void sub_1CBCA01CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::pair<TString,TProgressInfo>::~pair((uint64_t)va);
  os_unfair_lock_unlock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v3 - 40));
  _Unwind_Resume(a1);
}

void TProgressInfo::~TProgressInfo(TProgressInfo *this)
{

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 88);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 10);
}

const void **std::pair<TString,TProgressInfo>::~pair(uint64_t a1)
{

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 96);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 88));
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)a1);
}

void ___ZN12TProgressMap24GetProgressDispatchQueueEv_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;

  v0 = dispatch_queue_create("TProgressMap", 0);
  v1 = (void *)TProgressMap::GetProgressDispatchQueue(void)::progressQueue;
  TProgressMap::GetProgressDispatchQueue(void)::progressQueue = (uint64_t)v0;

}

void TProgressMap::CancelProgress(TProgressMap *this, const TNodePtr *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  TString v9;
  void (***v10)(_QWORD, const TNodePtr *);
  std::__shared_weak_count *v11;

  v10 = 0;
  v11 = 0;
  v4 = (os_unfair_lock_s *)TProgressMap::ProgressLock(this);
  os_unfair_lock_lock(v4);
  if (!TProgressMap::gProgressMap)
    goto LABEL_6;
  ProgressPathForNode((const TNodePtr *)this, &v9);
  v5 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, (CFStringRef *)&v9.fString.fRef);
  if (TProgressMap::gProgressMap + 8 == v5)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
LABEL_6:
    os_unfair_lock_unlock(v4);
    goto LABEL_7;
  }
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](&v10, (uint64_t *)(v5 + 128));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  os_unfair_lock_unlock(v4);
  if (v10)
    (**v10)(v10, a2);
LABEL_7:
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1CBCA03A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void TKeyValueObserver::StartObserving<std::function<void ()(void)>>(uint64_t *a1, void *a2, const TString *a3, uint64_t a4, uint64_t a5)
{
  id v9;
  _QWORD *v10;
  uint64_t v11;
  _BYTE v12[40];
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  TKeyValueObserver::TKeyValueObserver((TKeyValueObserver *)v12);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v13, a4);
  TKeyValueObserver::StartObserving<std::function<void ()(void)>>((TKeyValueObserver *)v12, v9, a3, (uint64_t)v13, a5);
  v10 = v14;
  if (v14 == v13)
  {
    v11 = 4;
    v10 = v13;
    goto LABEL_5;
  }
  if (v14)
  {
    v11 = 5;
LABEL_5:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }
  std::vector<TKeyValueObserver>::push_back[abi:ne180100](a1, (uint64_t)v12);
  TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)v12);

}

void sub_1CBCA04C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  void *v17;
  char *v18;
  char *v20;
  uint64_t v21;

  v20 = a17;
  if (a17 == v18)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)&a9);

  _Unwind_Resume(a1);
}

const void **TProgressMap::AddSubscriberForExternalProgress(const TNodePtr *this, const TNodePtr *a2)
{
  const void **result;
  TNode *v4;
  const void **started;
  void *v6;
  void *v7;
  TNode *v8;
  __CFURL *v9;
  objc_object *v10;
  uint64_t v11;
  _QWORD v12[5];
  CFStringRef theString;

  result = (const void **)TNodeFromFINode(this->fFINode);
  if (result)
  {
    ProgressPathForNode(this, (TString *)&theString);
    if (CFStringGetLength(theString))
    {
      v4 = (TNode *)TNodeFromFINode(this->fFINode);
      TNode::TestAndSetRegisteredForExternalProgress(v4, 1);
      started = TSystemNotificationTask::StartObservingDirectory((TString **)&theString, 0);
      v6 = (void *)MEMORY[0x1D17A5880](started);
      v7 = (void *)MEMORY[0x1E0CB38A8];
      v8 = (TNode *)TNodeFromFINode(this->fFINode);
      v9 = TNode::CopyURL(v8);
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3321888768;
      v12[2] = ___ZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtr_block_invoke;
      v12[3] = &__block_descriptor_33_ea8_32c72_ZTSKZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtrE3__0_e26____v___16__0__NSProgress_8l;
      objc_msgSend(v7, "addSubscriberForFileURL:withPublishingHandler:", v9, v12);
      v10 = (objc_object *)objc_claimAutoreleasedReturnValue();

      if (v10)
      {
        v11 = TNodeFromFINode(this->fFINode);
        TChildrenList::SetNSProgressSubscriber(*(TChildrenList **)(v11 + 56), v10);
      }

      objc_autoreleasePoolPop(v6);
    }
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  return result;
}

void sub_1CBCA0624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  va_list va;

  va_start(va, a6);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

id ___ZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtr_block_invoke(uint64_t a1, void *a2)
{
  id v2;
  void *v3;
  char v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  const __CFURL *v9;
  _BOOL4 HasProgress;
  void *v11;
  NSDictionary *v12;
  NSObject *v13;
  void *v14;
  void *v15;
  NSURL *v16;
  void *v17;
  void *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  DSFileProgress *v21;
  NSObject *v22;
  uint64_t v23;
  id v24;
  DSFileProgress *v25;
  id v26;
  void *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  id v31;
  DSFileProgress *v32;
  unint64_t *v33;
  unint64_t v34;
  DSFileProgress *v35;
  unint64_t *v36;
  unint64_t v37;
  void *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  void *v50;
  void *v51;
  DSFileProgress *v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count *v54;
  _QWORD v55[4];
  id v56;
  DSFileProgress *v57;
  std::__shared_weak_count *v58;
  std::__shared_weak_count *v59;
  _BYTE buf[24];
  void *v61;
  id v62;
  DSFileProgress *v63;
  id v64;
  std::__shared_weak_count *v65;
  std::__shared_weak_count *v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  objc_msgSend(v2, "kind");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "isEqualToString:", *MEMORY[0x1E0CB30F8]);

  if ((v4 & 1) == 0)
  {

    goto LABEL_6;
  }
  objc_msgSend(v2, "userInfo");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = *MEMORY[0x1E0CB30F0];
  objc_msgSend(v5, "objectForKeyedSubscript:", *MEMORY[0x1E0CB30F0]);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  static_objc_cast<NSString,objc_object * {__strong}>(v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (v8)
  {
    HasProgress = TProgressMap::HasProgress((TProgressMap *)v8, v9);

    if (!HasProgress)
      goto LABEL_8;
LABEL_6:
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3321888768;
    *(_QWORD *)&buf[16] = ___ZL21StartExternalProgressP10NSProgress_block_invoke;
    v61 = &__block_descriptor_33_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__0_e5_v8__0l;
    v11 = (void *)objc_msgSend(buf, "copy");
    goto LABEL_45;
  }

LABEL_8:
  objc_msgSend(v2, "userInfo");
  v12 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
  MutableCopyDeep(v12);
  v50 = (void *)objc_claimAutoreleasedReturnValue();

  LogObj(5);
  v13 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(v2, "userInfo");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "objectForKeyedSubscript:", v6);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    static_objc_cast<NSString,objc_object * {__strong}>(v15);
    v16 = (NSURL *)objc_claimAutoreleasedReturnValue();
    SanitizedURL(v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "userInfo");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138543874;
    *(_QWORD *)&buf[4] = v17;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v2;
    *(_WORD *)&buf[22] = 2112;
    v61 = v18;
    _os_log_impl(&dword_1CBC4A000, v13, OS_LOG_TYPE_INFO, "StartExternalProgress for url %{public}@ %@ %@", buf, 0x20u);

  }
  v19 = (std::__shared_weak_count *)operator new(0x20uLL);
  v19->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v19->__shared_owners_;
  v19->__shared_weak_owners_ = 0;
  v19->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874F000;
  LOBYTE(v19[1].__vftable) = 1;
  v53 = v19 + 1;
  v54 = v19;
  v21 = objc_alloc_init(DSFileProgress);
  TProgressMap::GetProgressDispatchQueue((TProgressMap *)v21);
  v22 = objc_claimAutoreleasedReturnValue();
  v23 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3321888768;
  *(_QWORD *)&buf[16] = ___ZL21StartExternalProgressP10NSProgress_block_invoke_37;
  v61 = &__block_descriptor_72_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1_e5_v8__0l;
  v24 = v2;
  v25 = v21;
  v26 = v50;
  v27 = v26;
  do
    v28 = __ldxr(p_shared_owners);
  while (__stxr(v28 + 1, p_shared_owners));
  v62 = v24;
  v63 = v25;
  v64 = v26;
  v65 = v19 + 1;
  v66 = v19;
  do
    v29 = __ldxr(p_shared_owners);
  while (__stxr(v29 + 1, p_shared_owners));
  dispatch_async(v22, buf);
  do
    v30 = __ldaxr(p_shared_owners);
  while (__stlxr(v30 - 1, p_shared_owners));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }

  v31 = v24;
  v51 = v31;
  v32 = v25;
  v52 = v32;
  if (v54)
  {
    v33 = (unint64_t *)&v54->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  v55[0] = v23;
  v55[1] = 3321888768;
  v55[2] = ___ZZL21StartExternalProgressP10NSProgressENK3__2cvU13block_pointerFvvEEv_block_invoke;
  v55[3] = &__block_descriptor_64_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2_e5_v8__0l;
  v56 = v31;
  v35 = v32;
  v57 = v35;
  v58 = v53;
  v59 = v54;
  if (v54)
  {
    v36 = (unint64_t *)&v54->__shared_owners_;
    do
      v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }
  v38 = (void *)MEMORY[0x1D17A5A30](v55);
  v39 = v59;
  if (v59)
  {
    v40 = (unint64_t *)&v59->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }

  v11 = (void *)objc_msgSend(v38, "copy");
  if (v54)
  {
    v42 = (unint64_t *)&v54->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }

  v44 = v66;
  if (v66)
  {
    v45 = (unint64_t *)&v66->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }

  if (v54)
  {
    v47 = (unint64_t *)&v54->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }

LABEL_45:
  return v11;
}

void sub_1CBCA0B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  v16 = v11;

  _Unwind_Resume(a1);
}

const void **TProgressMap::RemoveSubscriberForExternalProgress(const TNodePtr *this, const TNodePtr *a2)
{
  TNode *v3;
  const void **result;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  CFStringRef theString;

  v3 = (TNode *)TNodeFromFINode(this->fFINode);
  result = (const void **)TNode::TestAndSetRegisteredForExternalProgress(v3, 0);
  if ((_DWORD)result)
  {
    ProgressPathForNode(this, (TString *)&theString);
    if (CFStringGetLength(theString))
      TSystemNotificationTask::StopObservingDirectory((TString **)&theString, 0);
    v5 = TNodeFromFINode(this->fFINode);
    TChildrenList::NSProgressSubscriber(*(TChildrenList **)(v5 + 56));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      objc_msgSend(MEMORY[0x1E0CB38A8], "removeSubscriber:", v6);
      v7 = TNodeFromFINode(this->fFINode);
      TChildrenList::SetNSProgressSubscriber(*(TChildrenList **)(v7 + 56), 0);
    }

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  return result;
}

void sub_1CBCA0CF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TKeyValueObserver::~TKeyValueObserver(TKeyValueObserver *this)
{
  TKeyValueObserver::StopObserving(this);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4);

}

void sub_1CBCA0F2C(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  const void **v3;
  void *v4;
  va_list va;

  va_start(va, a3);

  ___ZZ34__DSFileProgress_progressChanged__ENK3__2cvU13block_pointerFvvEEv_block_invoke_cold_1((uint64_t)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__2(uint64_t a1, uint64_t a2)
{
  __n128 result;

  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  *(_QWORD *)(a1 + 40) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(_QWORD *)(a1 + 48) = *(id *)(a2 + 48);
  result = *(__n128 *)(a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

void sub_1CBCA0FD0(_Unwind_Exception *a1)
{
  id *v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__2(uint64_t a1)
{
  id *v2;

  v2 = (id *)(a1 + 32);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
  objc_destroyWeak(v2);
}

void std::vector<TKeyValueObserver>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)(v4 - 40));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::pair<TString,TProgressInfo>::pair[abi:ne180100]<true,0>(uint64_t a1, TString **a2, __int128 *a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  *(_QWORD *)a1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  v6 = a3[2];
  v7 = a3[3];
  v8 = *(__int128 *)((char *)a3 + 63);
  v10 = *a3;
  v9 = a3[1];
  *(_QWORD *)(a1 + 88) = &stru_1E8752DF8;
  *(_OWORD *)(a1 + 71) = v8;
  *(_OWORD *)(a1 + 40) = v6;
  *(_OWORD *)(a1 + 56) = v7;
  *(_OWORD *)(a1 + 8) = v10;
  *(_OWORD *)(a1 + 24) = v9;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 88), *((TString **)a3 + 10));
  v11 = *((_QWORD *)a3 + 12);
  *(_QWORD *)(a1 + 96) = *((_QWORD *)a3 + 11);
  *(_QWORD *)(a1 + 104) = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  *(_QWORD *)(a1 + 112) = *((id *)a3 + 13);
  *(_QWORD *)(a1 + 120) = *((id *)a3 + 14);
  return a1;
}

void sub_1CBCA1154(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void ___ZL21StartExternalProgressP10NSProgress_block_invoke_37(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  const TNode *v5;
  void *v6;
  int v7;
  _BYTE *v8;
  void *v9;
  void *v10;
  TString *v11;
  void *v12;
  void *v13;
  TNode *v14;
  _BOOL4 IsLockFile;
  __CFRunLoop *Main;
  const void *v17;
  id v18;
  id v19;
  id v20;
  id v21;
  NSDictionary *v22;
  TString block[4];
  id v24;
  id v25;
  NSProgress v26;

  objc_msgSend(*(id *)(a1 + 32), "userInfo");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKeyedSubscript:", *MEMORY[0x1E0CB30F0]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  static_objc_cast<NSString,objc_object * {__strong}>(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  NodeForURL((const __CFURL *)v4, (TNodePtr *)&v26);
  v5 = (const TNode *)TNodeFromFINode((FINode *)v26.super.isa);
  FINodeFromTNode(v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*(id *)(a1 + 40), "setProgressNode:", v6);

  **(_BYTE **)(a1 + 56) = TNodeFromFINode((FINode *)v26.super.isa) != 0;
  v7 = UseFileProviderFramework();
  v8 = *(_BYTE **)(a1 + 56);
  if (v7)
  {
    if (!*v8)
      goto LABEL_12;
    objc_msgSend(*(id *)(a1 + 32), "userInfo");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "objectForKeyedSubscript:", *MEMORY[0x1E0CB30C8]);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_cast<NSString,objc_object * {__strong}>(v10);
    v11 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    block[0].fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(block, v11);

    if ((operator==((void **)&block[0].fString.fRef, (void *)*MEMORY[0x1E0CB30E0]) & 1) != 0
      || operator==((void **)&block[0].fString.fRef, (void *)*MEMORY[0x1E0CB30B8]))
    {
      objc_msgSend(*(id *)(a1 + 32), "userInfo");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "objectForKeyedSubscript:", *MEMORY[0x1E0CB3090]);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      if (v13)
      {

      }
      else
      {
        v14 = (TNode *)TNodeFromFINode((FINode *)v26.super.isa);
        IsLockFile = TNode::LowLevelIsLockFile(v14);

        if (IsLockFile)
          **(_BYTE **)(a1 + 56) = 0;
      }
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&block[0].fString.fRef);
    v8 = *(_BYTE **)(a1 + 56);
  }
  if (*v8)
  {
    Main = CFRunLoopGetMain();
    v17 = (const void *)*MEMORY[0x1E0C9B270];
    block[0].fString.fRef = (__CFString *)MEMORY[0x1E0C809B0];
    block[1].fString.fRef = (__CFString *)3321888768;
    block[2].fString.fRef = (__CFString *)___ZZL21StartExternalProgressP10NSProgressENK3__1clEv_block_invoke;
    block[3].fString.fRef = (__CFString *)&__block_descriptor_48_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE__e5_v8__0l;
    v18 = *(id *)(a1 + 32);
    v19 = *(id *)(a1 + 40);
    v24 = v18;
    v20 = v19;
    v25 = v20;
    v21 = v18;
    CFRunLoopPerformBlock(Main, v17, block);

    TProgressMap::AddExternalProgress(*(TProgressMap **)(a1 + 32), (TNodePtr *)&v26, *(TNodePtr **)(a1 + 48), v22);
  }
LABEL_12:

}

void sub_1CBCA1404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  void *v16;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1(_QWORD *a1, uint64_t a2)
{
  id result;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  a1[4] = *(id *)(a2 + 32);
  a1[5] = *(id *)(a2 + 40);
  result = *(id *)(a2 + 48);
  v6 = *(_QWORD *)(a2 + 56);
  v5 = *(_QWORD *)(a2 + 64);
  a1[6] = result;
  a1[7] = v6;
  a1[8] = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1(id *a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 7));

}

id *StartExternalProgress(NSProgress *)::$_1::~$_1(id *a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));

  return a1;
}

id *StartExternalProgress(NSProgress *)::$_2::~$_2(id *a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 2));

  return a1;
}

void std::__shared_ptr_emplace<BOOL>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874F000;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BOOL>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874F000;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void NodeForURL(const __CFURL *a1@<X0>, TNodePtr *a2@<X8>)
{
  id v3;
  const __CFURL *v4;

  v3 = 0;
  v4 = a1;
  if (TNode::GetNodeFromURL(&v4, &v3, 0))
    TNodePtr::TNodePtr(a2, 0);
  else
    a2->fFINode = (FINode *)v3;

}

void sub_1CBCA1690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

uint64_t ___ZZL21StartExternalProgressP10NSProgressENK3__1clEv_block_invoke(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 40), "startObserving:", *(_QWORD *)(a1 + 32));
  return objc_msgSend(*(id *)(a1 + 32), "acknowledgeWithSuccess:", 1);
}

id __copy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE_(uint64_t a1, uint64_t a2)
{
  id result;

  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  result = *(id *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE_(uint64_t a1)
{

}

void ___ZZL21StartExternalProgressP10NSProgressENK3__2cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  NSObject *v2;
  id v3;
  id v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  id v9;
  id v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[4];
  id v18;
  id v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  TProgressMap::GetProgressDispatchQueue((TProgressMap *)a1);
  v2 = objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = ___ZZL21StartExternalProgressP10NSProgressENK3__2clEv_block_invoke;
  v17[3] = &__block_descriptor_64_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE__e5_v8__0l;
  v3 = *(id *)(a1 + 32);
  v4 = *(id *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 48);
  v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = v3;
  v18 = v9;
  v10 = v4;
  v19 = v10;
  v20 = v6;
  v21 = v5;
  if (v5)
  {
    v11 = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    dispatch_async(v2, v17);
    do
      v13 = __ldaxr(v11);
    while (__stlxr(v13 - 1, v11));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    dispatch_async(v2, v17);
  }

  v14 = v21;
  if (v21)
  {
    v15 = (unint64_t *)&v21->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

}

id __copy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2(_QWORD *a1, uint64_t a2)
{
  id result;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  a1[4] = *(id *)(a2 + 32);
  result = *(id *)(a2 + 40);
  v6 = *(_QWORD *)(a2 + 48);
  v5 = *(_QWORD *)(a2 + 56);
  a1[5] = result;
  a1[6] = v6;
  a1[7] = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2(uint64_t a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 48);

}

void ___ZZL21StartExternalProgressP10NSProgressENK3__2clEv_block_invoke(uint64_t a1)
{
  void *v1;
  void *v2;
  id v3;
  id v4;
  NSObject *v5;
  void *v6;
  void *v7;
  NSURL *v8;
  void *v9;
  void *v10;
  NSObject *v11;
  int v12;
  void *v13;
  BOOL v14;
  FINode *v15;
  const TNode *v16;
  const TProgressInfo *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  __CFRunLoop *Main;
  const void *v22;
  id v23;
  TNodePtr v24;
  _BYTE buf[24];
  void *v26;
  id v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD v31[2];
  const __CFString *v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (**(_BYTE **)(a1 + 48))
  {
    v2 = *(void **)(a1 + 32);
    v1 = *(void **)(a1 + 40);
    v3 = v2;
    v4 = v1;
    LogObj(5);
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      objc_msgSend(v3, "userInfo");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKeyedSubscript:", *MEMORY[0x1E0CB30F0]);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      static_objc_cast<NSString,objc_object * {__strong}>(v7);
      v8 = (NSURL *)objc_claimAutoreleasedReturnValue();
      SanitizedURL(v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v3, "userInfo");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543874;
      *(_QWORD *)&buf[4] = v9;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v3;
      *(_WORD *)&buf[22] = 2112;
      v26 = v10;
      _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_INFO, "EndExternalProgress for url %{public}@ %@ %@", buf, 0x20u);

    }
    objc_msgSend(v3, "kind");
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = IsEqual(v11, *MEMORY[0x1E0CB30F8]);

    if (v12)
    {
      objc_msgSend(v3, "userInfo");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = v13 == 0;

      if (!v14)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        memset(v31, 0, 15);
        v32 = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        v34 = 0u;
        v33 = 0u;
        *(_DWORD *)&buf[16] = 1120403456;
        *(_QWORD *)((char *)v31 + 4) = 0;
        BYTE5(v31[1]) = objc_msgSend(v3, "isPausable");
        BYTE4(v31[1]) = objc_msgSend(v3, "isCancellable");
        objc_storeStrong((id *)&v34, v2);
        objc_msgSend(v4, "progressNode");
        v15 = (FINode *)objc_claimAutoreleasedReturnValue();
        v16 = (const TNode *)TNodeFromFINode(v15);
        TNodePtr::TNodePtr(&v24, v16);
        TProgressMap::UpdateExternalProgress(&v24, (const TNodePtr *)buf, v17);

        v18 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
        if (*((_QWORD *)&v33 + 1))
        {
          v19 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v32);
      }
    }
    Main = CFRunLoopGetMain();
    v22 = (const void *)*MEMORY[0x1E0C9B270];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3321888768;
    *(_QWORD *)&buf[16] = ___ZL19EndExternalProgressP10NSProgressP14DSFileProgress_block_invoke;
    v26 = &__block_descriptor_40_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0_e5_v8__0l;
    v23 = v4;
    v27 = v23;
    CFRunLoopPerformBlock(Main, v22, buf);

  }
}

void sub_1CBCA1C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24,void *a25)
{
  void *v25;
  void *v26;
  const void **v27;
  void *v28;
  unint64_t *p_shared_owners;
  unint64_t v31;

  if (a23)
  {
    p_shared_owners = (unint64_t *)&a23->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))a23->__on_zero_shared)(a23);
      std::__shared_weak_count::__release_weak(a23);
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v27);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE_(_QWORD *a1, uint64_t a2)
{
  id result;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  a1[4] = *(id *)(a2 + 32);
  result = *(id *)(a2 + 40);
  v6 = *(_QWORD *)(a2 + 48);
  v5 = *(_QWORD *)(a2 + 56);
  a1[5] = result;
  a1[6] = v6;
  a1[7] = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE_(uint64_t a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 48);

}

uint64_t ___ZL19EndExternalProgressP10NSProgressP14DSFileProgress_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "stopObserving");
}

id __copy_helper_block_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0(uint64_t a1)
{

}

void sub_1CBCA1F98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::vector<TKeyValueObserver>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v10 + 1 > 0x666666666666666)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    v12 = 2 * v11;
    if (2 * v11 <= v10 + 1)
      v12 = v10 + 1;
    if (v11 >= 0x333333333333333)
      v13 = 0x666666666666666;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TKeyValueObserver>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[40 * v10];
    v18 = &v14[40 * v13];
    TKeyValueObserver::TKeyValueObserver(v16, a2);
    v17 = v16 + 40;
    std::vector<TKeyValueObserver>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<TKeyValueObserver>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = TKeyValueObserver::TKeyValueObserver(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 40;
    a1[1] = v7 + 40;
  }
  a1[1] = v9;
  return result;
}

void sub_1CBCA2100(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TKeyValueObserver>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TKeyValueObserver::TKeyValueObserver(TKeyValueObserver *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
}

void sub_1CBCA214C(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA24A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id objc_cast<NSURL,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

uint64_t std::unordered_set<NSObject *>::unordered_set(uint64_t a1, id *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  if (a3)
  {
    v5 = 8 * a3;
    do
    {
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_unique_key_args<std::hash,NSObject * const&>(a1, a2, a2);
      ++a2;
      v5 -= 8;
    }
    while (v5);
  }
  return a1;
}

void sub_1CBCA261C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_unique_key_args<std::hash,NSObject * const&>(uint64_t a1, id *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v7 = objc_msgSend(*a2, "hash");
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v8)
        {
          if ((std::equal_to<NSObject * {__strong}>::operator()(a1 + 44, *((void **)i + 2), *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v8;
  *((_QWORD *)i + 2) = *a3;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 40);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)i = *v22;
LABEL_38:
    *v22 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*(_QWORD *)i)
  {
    v23 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCA285C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::equal_to<NSObject * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;

  v4 = a2;
  v5 = a3;
  if (v4 == v5)
    v6 = 1;
  else
    v6 = objc_msgSend(v4, "isEqual:", v5);

  return v6;
}

void sub_1CBCA28D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::vector<TKeyValueObserver>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 40;
    result = TKeyValueObserver::TKeyValueObserver(result - 40, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TKeyValueObserver>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a2);
}

uint64_t std::__split_buffer<TKeyValueObserver>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)(i - 40));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(uint64_t a1, CFStringRef *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _BOOL4 v6;
  uint64_t *v7;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 8;
  do
  {
    v6 = TString::operator<((CFStringRef *)(v3 + 32), a2);
    v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      v7 = (uint64_t *)v3;
      v5 = v3;
    }
    v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || TString::operator<(a2, (CFStringRef *)(v5 + 32)))
    return v2;
  return v5;
}

uint64_t *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void std::__shared_ptr_emplace<TExternalOperationCanceller>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TExternalOperationCanceller>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750768;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__shared_ptr_emplace<TExternalOperationCanceller>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 24))(a1 + 24);
}

uint64_t TExternalOperationCanceller::CancelTaskForProgress(id *this)
{
  if (objc_msgSend(this[1], "isCancellable"))
    objc_msgSend(this[1], "cancel");
  return 1;
}

void *TExternalOperationCanceller::TaskIsPausable(TExternalOperationCanceller *this)
{
  void *result;

  result = (void *)*((_QWORD *)this + 1);
  if (result)
    return (void *)objc_msgSend(result, "isPausable");
  return result;
}

uint64_t TExternalOperationCanceller::PauseTaskForProgress(id *this)
{
  objc_msgSend(this[1], "pause");
  return 1;
}

void TExternalOperationCanceller::~TExternalOperationCanceller(id *this)
{

}

{

  JUMPOUT(0x1D17A53D0);
}

uint64_t *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__emplace_unique_key_args<TString,std::pair<TString,TProgressInfo>>(uint64_t **a1, CFStringRef *a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  _QWORD v9[2];
  char v10;
  uint64_t v11;

  v5 = (uint64_t **)std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__find_equal<TString>((uint64_t)a1, &v11, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    v6 = (uint64_t *)operator new(0xA0uLL);
    v9[1] = a1 + 1;
    std::pair<TString const,TProgressInfo>::pair[abi:ne180100]<TString,TProgressInfo,0>((uint64_t)(v6 + 4), a3);
    v10 = 1;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v11, v7, v6);
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

_QWORD *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__find_equal<TString>(uint64_t a1, _QWORD *a2, CFStringRef *a3)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v7;
  CFStringRef *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = (_QWORD *)v4;
        v8 = (CFStringRef *)(v4 + 32);
        if (!TString::operator<(a3, (CFStringRef *)(v4 + 32)))
          break;
        v4 = *v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (!TString::operator<(v8, a3))
        break;
      v5 = v7 + 1;
      v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::pair<TString const,TProgressInfo>::pair[abi:ne180100]<TString,TProgressInfo,0>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a2, &stru_1E8752DF8);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  v4 = *(_OWORD *)(a2 + 24);
  v5 = *(_OWORD *)(a2 + 40);
  v6 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 71) = *(_OWORD *)(a2 + 71);
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 88), &stru_1E8752DF8);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  v7 = *(_OWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_OWORD *)(a1 + 112) = v7;
  return a1;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::pair<TString,TProgressInfo>::~pair((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void TKeyValueObserver::StartObserving<std::function<void ()(void)>>(TKeyValueObserver *a1, void *a2, const TString *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v9;
  DS_TKeyValueObserverGlue *v10;
  _BYTE v11[48];
  id v12[2];

  v12[1] = *(id *)MEMORY[0x1E0C80C00];
  v9 = a2;
  v12[0] = v9;
  std::unordered_set<NSObject *>::unordered_set((uint64_t)v11, v12, 1);
  TKeyValueObserver::CreateObserver((uint64_t)a1, a4, (uint64_t)v11, (uint64_t)a3);
  v10 = (DS_TKeyValueObserverGlue *)objc_claimAutoreleasedReturnValue();
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v11);
  TKeyValueObserver::StartObservingPriv(a1, v10, v9, a3, a5);

}

void sub_1CBCA3404(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

void TBusyFolders::StopObserving(TBusyFolders *this)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders13StopObservingEv_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c43_ZTSKZN12TBusyFolders13StopObservingEvE3__0_e5_v8__0l;
  block[4] = this;
  dispatch_async((dispatch_queue_t)gSystemNotificationStreamGCDQueue, block);
}

void TSystemNotificationTask::FinalizeSystemNotificationTask(TSystemNotificationTask *this)
{
  uint64_t v1;

  std::mutex::lock(&gBusyFoldersLock);
  v1 = TSystemNotificationTask::gSystemNotificationTask;
  if (TSystemNotificationTask::gSystemNotificationTask)
  {
    TBusyFolders::StopObserving((TBusyFolders *)TSystemNotificationTask::gBusyFolders);
    MEMORY[0x1D17A53D0](v1, 0xC400A2AC0F1);
  }
  TSystemNotificationTask::gSystemNotificationTask = 0;
  std::mutex::unlock(&gBusyFoldersLock);
}

const void **TSystemNotificationTask::HandleBusyFoldersChanges(TSystemNotificationTask *this, const __FSEventStream *a2, const void **a3, const char **a4, int *a5, const unsigned int *a6, const unint64_t *a7)
{
  return TSystemNotificationTask::HandleFSEvent(a3, a4, a5, 0);
}

const void **TSystemNotificationTask::StopObservingDirectory(TString **this, const TString *a2)
{
  char v2;
  TString *v4;
  CFMutableStringRef MutableCopy;
  TString v7;
  CFTypeRef cf;

  v2 = (char)a2;
  TString::TString(&v7, "/");
  if (TString::EndsWith((TString *)this, &v7))
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, *this);
  }
  else
  {
    v4 = *this;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFStringRef)v4);
    if (cf)
      CFRelease(cf);
    cf = MutableCopy;
    TString::Append((TString *)&cf, (const __CFString *)"/");
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  std::mutex::lock(&gBusyFoldersLock);
  TBusyFolders::StopObservingDirectory((TBusyFolders *)TSystemNotificationTask::gBusyFolders, (const TString *)&cf, v2);
  std::mutex::unlock(&gBusyFoldersLock);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1CBCA365C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void **TBusyFolders::StopObservingDirectory(TBusyFolders *this, const TString *a2, char a3)
{
  NSObject *v6;
  __CFString *v8;
  char v9;
  _QWORD block[5];
  TString v11;
  char v12;

  v6 = (id)gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders22StopObservingDirectoryERK7TStringb_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0_e5_v8__0l;
  v8 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&v8, (TString *)a2->fString.fRef);
  v9 = a3;
  block[4] = this;
  v11.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v11, (TString *)v8);
  v12 = v9;
  dispatch_async(v6, block);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
}

void sub_1CBCA3798(_Unwind_Exception *a1)
{
  void *v1;
  const void **v2;
  const void **v3;
  const void **v4;

  v4 = v3;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

void CloseFSEventStream(__FSEventStream *a1)
{
  NSObject *v2;
  int v3;
  __FSEventStream *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    LogObj(5);
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = 134217984;
      v4 = a1;
      _os_log_impl(&dword_1CBC4A000, v2, OS_LOG_TYPE_DEFAULT, "Closing FSEvent Stream %p", (uint8_t *)&v3, 0xCu);
    }

    FSEventStreamStop(a1);
    FSEventStreamInvalidate(a1);
    FSEventStreamRelease(a1);
  }
}

void ___ZN12TBusyFolders14StartObservingEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  __FSEventStream *FSEventStreamForPath;

  v2 = *(_QWORD *)(a1 + 32);
  notify_register_dispatch("CACHE_DELETE_PURGEABLE_UPDATED", (int *)(v2 + 48), (dispatch_queue_t)gSystemNotificationGCDQueue, &__block_literal_global_2);
  FSEventStreamForPath = CreateFSEventStreamForPath((TString *)CFSTR("/"), (void (__cdecl *)(ConstFSEventStreamRef, void *, size_t, void *, const FSEventStreamEventFlags *, const FSEventStreamEventId *))TSystemNotificationTask::HandleAllFileChanges, *(const __CFArray **)(a1 + 40));
  dispatch_assert_queue_V2((dispatch_queue_t)gSystemNotificationStreamGCDQueue);
  *(_QWORD *)(v2 + 40) = FSEventStreamForPath;
}

__CFArray *TBusyFolders::CopyBusyFolders(TBusyFolders *this)
{
  __CFArray *Mutable;
  const void **i;
  const void *v4;
  CFTypeRef v5;
  const void *v6;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  for (i = (const void **)*((_QWORD *)this + 2); i; i = (const void **)*i)
  {
    v4 = RetainCF<__CFString const*>(i + 2);
    if (v4)
    {
      v5 = CFAutorelease(v4);
      v6 = static_cf_cast<__CFString const*,void const*>(v5);
    }
    else
    {
      v6 = 0;
    }
    CFArrayAppendValue(Mutable, v6);
  }
  return Mutable;
}

void ___ZN12TBusyFolders23StartObservingDirectoryERK7TStringb_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _BOOL4 v4;
  int v5;
  TString *v6;
  CFTypeRef v7;
  CFTypeRef v8;
  __FSEventStream *FSEventStreamForPath;
  uint64_t **v10;
  CFTypeRef cf;

  v2 = *(_QWORD **)(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  v3 = v2 + 2;
  while (1)
  {
    v3 = (_QWORD *)*v3;
    if (!v3)
      break;
    if (*((_BYTE *)v3 + 36))
      v4 = *(_BYTE *)(a1 + 48) != 0;
    else
      v4 = 0;
    if (CheckInterestedInPath((TString *)(a1 + 40), (TString *)v3 + 2, v4))
    {
      v5 = *((_DWORD *)v3 + 8);
      *((_DWORD *)v3 + 8) = v5 + 1;
      if (!v5)
      {
        cf = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v3[2]);
        v6 = (TString *)cf;
        if (cf)
        {
          v7 = CFRetain(cf);
          v6 = (TString *)static_cf_cast<__CFString const*,void const*>(v7);
          if (v6)
          {
            v8 = CFAutorelease(v6);
            v6 = (TString *)static_cf_cast<__CFString const*,void const*>(v8);
          }
        }
        FSEventStreamForPath = CreateFSEventStreamForPath(v6, (void (__cdecl *)(ConstFSEventStreamRef, void *, size_t, void *, const FSEventStreamEventFlags *, const FSEventStreamEventId *))TSystemNotificationTask::HandleBusyFoldersChanges, 0);
        v10 = std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(v2, (TString *)&cf);
        if (v10 && *((int *)v10 + 8) >= 1 && !v10[3])
          v10[3] = (uint64_t *)FSEventStreamForPath;
        else
          CloseFSEventStream(FSEventStreamForPath);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      break;
    }
  }
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1CBCA3A94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::mutex::unlock(&gBusyFoldersLock);
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c63_ZTSKZN12TBusyFolders23StartObservingDirectoryERK7TStringbE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = &stru_1E8752DF8;
  *(_QWORD *)(a1 + 32) = v4;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
}

void sub_1CBCA3B24(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **__destroy_helper_block_ea8_32c63_ZTSKZN12TBusyFolders23StartObservingDirectoryERK7TStringbE3__0(uint64_t a1)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
}

void ___ZN12TBusyFolders13StopObservingEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  v2 = *(_DWORD *)(v1 + 48);
  if (v2)
    notify_cancel(v2);
  *(_DWORD *)(v1 + 48) = 0;
  dispatch_assert_queue_V2((dispatch_queue_t)gSystemNotificationStreamGCDQueue);
  CloseFSEventStream(*(__FSEventStream **)(v1 + 40));
  dispatch_assert_queue_V2((dispatch_queue_t)gSystemNotificationStreamGCDQueue);
  *(_QWORD *)(v1 + 40) = 0;
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1CBCA3BA0(_Unwind_Exception *a1)
{
  std::mutex::unlock(&gBusyFoldersLock);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c43_ZTSKZN12TBusyFolders13StopObservingEvE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZN12TBusyFolders22StopObservingDirectoryERK7TStringb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  _BOOL4 v4;
  int v5;
  BOOL v6;
  int v7;
  __FSEventStream *v8;

  v2 = *(_QWORD *)(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  v3 = (uint64_t *)(v2 + 16);
  while (1)
  {
    v3 = (uint64_t *)*v3;
    if (!v3)
      break;
    if (*((_BYTE *)v3 + 36))
      v4 = *(_BYTE *)(a1 + 48) != 0;
    else
      v4 = 0;
    if (CheckInterestedInPath((TString *)(a1 + 40), (TString *)v3 + 2, v4))
    {
      v5 = *((_DWORD *)v3 + 8);
      v6 = __OFSUB__(v5, 1);
      v7 = v5 - 1;
      if (v7 < 0 == v6)
      {
        *((_DWORD *)v3 + 8) = v7;
        if (!v7)
        {
          v8 = (__FSEventStream *)v3[3];
          v3[3] = 0;
          CloseFSEventStream(v8);
        }
      }
      break;
    }
  }
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1CBCA3C5C(_Unwind_Exception *a1)
{
  std::mutex::unlock(&gBusyFoldersLock);
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = &stru_1E8752DF8;
  *(_QWORD *)(a1 + 32) = v4;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
}

void sub_1CBCA3CD0(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **__destroy_helper_block_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0(uint64_t a1)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
}

BOOL CheckInterestedInPath(TString *a1, TString *a2, int a3)
{
  _BOOL8 result;

  result = TString::BeginsWith(a1, a2);
  if ((result & 1) == 0)
  {
    if (a3)
      return TString::BeginsWith(a2, a1);
  }
  return result;
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(_QWORD *a1, TString *this)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **i;
  unint64_t v12;

  v4 = FowlerNollVoHash::hash(this, this);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  for (i = *v10; i; i = (uint64_t **)*i)
  {
    v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if (CFEqual(i[2], this->fString.fRef))
        return i;
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(_QWORD *)&v5)
          v12 %= *(_QWORD *)&v5;
      }
      else
      {
        v12 &= *(_QWORD *)&v5 - 1;
      }
      if (v12 != v9)
        return 0;
    }
  }
  return i;
}

uint64_t std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__deallocate_node(a1, *(const void ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__deallocate_node(uint64_t a1, const void **a2)
{
  const void **v2;
  const void **v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (const void **)*v2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

TString *std::pair<TString const,TBusyFolders::TSpecialFolderStream>::pair[abi:ne180100]<TString const&>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = 0;
  a1[2].fString.fRef = 0;
  return a1;
}

void sub_1CBCA3EF0(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  const void **v2;

  v2 = *(const void ***)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2 + 2);
    operator delete(v2);
  }
}

uint64_t IsEqual(const void *a1, const void *a2)
{
  uint64_t v4;
  const __CFURL *v5;
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFString *v8;
  CFTypeRef cf2;
  CFTypeRef cf1;

  if (a1 == a2 || a1 && a2 && CFEqual(a1, a2))
    return 1;
  v5 = (const __CFURL *)cf_cast<__CFURL const*,void const*>(a1);
  v6 = (const __CFURL *)cf_cast<__CFURL const*,void const*>(a2);
  v4 = 0;
  if (v5)
  {
    v7 = v6;
    if (v6)
    {
      cf2 = 0;
      cf1 = 0;
      v8 = (const __CFString *)*MEMORY[0x1E0C9B470];
      if (CFURLCopyResourcePropertyForKey(v5, (CFStringRef)*MEMORY[0x1E0C9B470], &cf1, 0)
        && CFURLCopyResourcePropertyForKey(v7, v8, &cf2, 0)
        && cf1)
      {
        v4 = IsEqual(cf1, cf2);
      }
      else
      {
        v4 = 0;
      }
      TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&cf2);
      TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&cf1);
    }
  }
  return v4;
}

void sub_1CBCA4034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&a9);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&a10);
  _Unwind_Resume(a1);
}

void sub_1CBCA40CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TDSMutex *v10;

  TDSMutex::unlock(v10);

  _Unwind_Resume(a1);
}

void TDSHelperContext::HandleHelperEvent(_QWORD *a1, void *a2)
{
  void *v3;
  void *v4;
  xpc_object_t xdict;

  xdict = a2;
  if (MEMORY[0x1D17A5E44]() == MEMORY[0x1E0C81310])
  {
    v3 = xdict;
    if (xdict == (xpc_object_t)MEMORY[0x1E0C81260])
    {
      v4 = (void *)a1[19];
      a1[19] = 0;

      v3 = xdict;
    }
    TDSHelperContext::ReplyReceived((uint64_t)a1, v3);
  }
  else if (xpc_dictionary_get_string(xdict, "request") && a1[19])
  {
    (*(void (**)(_QWORD *))(*a1 + 16))(a1);
  }

}

void sub_1CBCA41A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t TDSHelperContext::TDSHelperContext(uint64_t a1, int a2, TString *a3)
{
  _QWORD *v6;

  *(_QWORD *)a1 = &off_1E874FDF8;
  *(_QWORD *)(a1 + 8) = 850045863;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 1018212795;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  v6 = operator new(0x58uLL);
  v6[3] = 850045863;
  *(_QWORD *)(a1 + 120) = v6 + 3;
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &unk_1E8750880;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  v6[10] = 0;
  *(_QWORD *)(a1 + 128) = v6;
  *(_DWORD *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 148) = a2;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 160), a3);
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  return a1;
}

void sub_1CBCA4318(_Unwind_Exception *a1)
{
  std::mutex *v1;
  std::condition_variable *v2;
  uint64_t v3;
  uint64_t v4;
  const void **v5;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v4);
  std::condition_variable::~condition_variable(v2);
  std::mutex::~mutex(v1);
  _Unwind_Resume(a1);
}

void TDSHelperContext::~TDSHelperContext(TDSHelperContext *this)
{
  *(_QWORD *)this = &off_1E874FDF8;
  TDSHelperContext::Disconnect(this);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 20);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 120);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

{
  TDSHelperContext::~TDSHelperContext(this);
  JUMPOUT(0x1D17A53D0);
}

void TDSHelperContext::Disconnect(TDSHelperContext *this)
{
  void *v1;
  void *v3;

  v1 = (void *)*((_QWORD *)this + 19);
  if (v1)
  {
    *((_QWORD *)this + 19) = 0;

    objc_msgSend(*((id *)this + 25), "clearHelper");
    v3 = (void *)*((_QWORD *)this + 25);
    *((_QWORD *)this + 25) = 0;

  }
}

int64_t TDSHelperContext::LaunchDesktopServicesHelper(TDSHelperContext *this, BOOL a2, BOOL a3)
{
  int64_t int64;
  const char *v7;
  NSObject *v8;
  xpc_connection_t mach_service;
  void *v10;
  DS_TDSHelperConnectionHandler *v11;
  void *v12;
  id v13;
  _xpc_connection_s *v14;
  id v15;
  TDSHelperContext *v16;
  void *v17;
  char v18;
  const char *v19;
  xpc_object_t v20;
  _QWORD handler[4];
  id v23;

  if (*((_QWORD *)this + 19))
    return 0;
  v7 = DesktopServicesHelperServiceName();
  dispatch_get_global_queue(0, 0);
  v8 = objc_claimAutoreleasedReturnValue();
  mach_service = xpc_connection_create_mach_service(v7, v8, 2uLL);
  v10 = (void *)*((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = mach_service;

  if (!*((_QWORD *)this + 19))
    return 4294959234;
  v11 = -[DS_TDSHelperConnectionHandler initWithHelper:]([DS_TDSHelperConnectionHandler alloc], "initWithHelper:", this);
  v12 = (void *)*((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = v11;

  v13 = *((id *)this + 25);
  v14 = (_xpc_connection_s *)*((_QWORD *)this + 19);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3221225472;
  handler[2] = ___ZN16TDSHelperContext27LaunchDesktopServicesHelperEbb_block_invoke;
  handler[3] = &unk_1E8751950;
  v15 = v13;
  v23 = v15;
  xpc_connection_set_event_handler(v14, handler);
  xpc_connection_resume(*((xpc_connection_t *)this + 19));
  TDSHelperContext::CreateMessageForHelper(v16, "Handshake");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_set_BOOL(v17, "authorizeImmediately", a2);
  v18 = UseFileProviderFramework();
  xpc_dictionary_set_BOOL(v17, "ENABLE_FILE_PROVIDER", v18);
  xpc_dictionary_set_BOOL(v17, "FXEnableResumableCopies", a3);
  xpc_dictionary_set_uint64(v17, "processOptions", *((unsigned int *)this + 37));
  if (CFStringGetLength(*((CFStringRef *)this + 20)))
  {
    v19 = (const char *)TString::c_str((TString *)this + 20);
    xpc_dictionary_set_string(v17, "AuthMessage", v19);
  }
  v20 = xpc_connection_send_message_with_reply_sync(*((xpc_connection_t *)this + 19), v17);
  if (MEMORY[0x1D17A5E44]() == MEMORY[0x1E0C812F8])
    int64 = xpc_dictionary_get_int64(v20, "errorStatus");
  else
    int64 = 4294959234;

  return int64;
}

void sub_1CBCA4638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t ___ZN16TDSHelperContext27LaunchDesktopServicesHelperEbb_block_invoke(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "handleHelperEvent:", a2);
}

id TDSHelperContext::CreateMessageForHelper(TDSHelperContext *this, const char *a2)
{
  xpc_object_t v3;
  char v4;

  v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "request", a2);
  v4 = UseFileProviderFramework();
  xpc_dictionary_set_BOOL(v3, "UseFileProviderFramework", v4);
  return v3;
}

void sub_1CBCA46E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TDSHelperContext::ReplyReceived(uint64_t a1, void *a2)
{
  id v4;

  v4 = a2;
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (*(_BYTE *)(a1 + 144))
  {
    *(_BYTE *)(a1 + 144) = 0;
    objc_storeStrong((id *)(a1 + 192), a2);
    TConditionVariable::Signal((TConditionVariable *)(a1 + 72));
  }
  std::mutex::unlock((std::mutex *)(a1 + 8));

}

void sub_1CBCA4764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex *v10;

  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

void TDSHelperContext::UpdateDestinationSpaceNeeds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const char *a16, const char *a17, uint64_t a18, unint64_t a19, int a20,char a21,char a22,int a23)
{
  char *v24;
  const char *v25;
  const char *v26;

  *(_QWORD *)a2 = a3;
  *(_QWORD *)(a2 + 8) = a4;
  *(_QWORD *)(a2 + 16) = a5;
  *(_QWORD *)(a2 + 24) = a6;
  *(_BYTE *)(a2 + 2168) = a22;
  if (a21)
  {
    *(_QWORD *)(a2 + 48) = a8;
    *(_QWORD *)(a2 + 56) = a9;
    *(_QWORD *)(a2 + 32) = a7;
    *(_QWORD *)(a2 + 40) = a10;
    *(_QWORD *)(a2 + 64) = a11;
    *(_QWORD *)(a2 + 72) = a12;
    v24 = (char *)(a2 + 104);
    *(_QWORD *)(a2 + 80) = a13;
    *(_QWORD *)(a2 + 88) = a14;
    if (a16)
      v25 = a16;
    else
      v25 = "";
    *(_QWORD *)(a2 + 96) = a15;
    strlcpy(v24, v25, 0x400uLL);
    if (a17)
      v26 = a17;
    else
      v26 = "";
    strlcpy((char *)(a2 + 1128), v26, 0x400uLL);
  }
  else
  {
    *(_BYTE *)(a2 + 1128) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 89) = 0u;
  }
  *(_QWORD *)(a2 + 2152) = a18;
  if (*(_QWORD *)(a2 + 2160) < a19)
    *(_QWORD *)(a2 + 2160) = a19;
  *(_DWORD *)(a2 + 2172) |= a20;
  if (*(_DWORD *)(a2 + 2176))
    *(_DWORD *)(a2 + 2176) = a23;
}

id TDSHelperContext::SendMessageAndWait(uint64_t a1, void *a2)
{
  id v3;
  std::mutex *v4;
  void *v5;
  id v6;
  id v7;

  v3 = a2;
  if (*(_QWORD *)(a1 + 152))
  {
    v4 = (std::mutex *)(a1 + 8);
    std::mutex::lock((std::mutex *)(a1 + 8));
    *(_BYTE *)(a1 + 144) = 1;
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 152), v3);
    TConditionVariable::Wait((TConditionVariable *)(a1 + 72), (std::mutex *)(a1 + 8));
    if (!*(_QWORD *)(a1 + 152))
    {
      objc_msgSend(*(id *)(a1 + 200), "clearHelper");
      v5 = *(void **)(a1 + 200);
      *(_QWORD *)(a1 + 200) = 0;

    }
    v6 = *(id *)(a1 + 192);
    std::mutex::unlock(v4);
  }
  else
  {
    v6 = (id)MEMORY[0x1E0C81260];
    v7 = MEMORY[0x1E0C81260];
  }

  return v6;
}

void sub_1CBCA4920(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopyChildCreateLock(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int64_t a6, int a7, unsigned int a8, BOOL value, const void **a10, BOOL *a11)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  int64_t int64;
  const char *string;
  id v29;
  id v30;
  TDSHelperContext *v31;
  id v32;
  id v33;
  CFTypeRef cf;
  unsigned __int8 uuid[8];
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v33 = a2;
  v32 = a3;
  v29 = a4;
  v31 = a5;
  *a11 = 0;
  TDSHelperContext::CreateMessageForHelper(v31, "FilesCopyChildCreateLock");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v33, 0, 0);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v32, 1, 0);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v18, 1, 0);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v19, 1, 0, v20);
  v30 = (id)objc_claimAutoreleasedReturnValue();
  v21 = objc_retainAutorelease(v20);
  xpc_dictionary_set_data(v17, "parentURLWrapper", (const void *)objc_msgSend(v21, "bytes"), objc_msgSend(v21, "length"));
  v22 = objc_retainAutorelease(v30);
  xpc_dictionary_set_data(v17, "sourceURLWrapper", (const void *)objc_msgSend(v22, "bytes"), objc_msgSend(v22, "length"));
  v23 = objc_retainAutorelease(v29);
  xpc_dictionary_set_string(v17, "newName", (const char *)objc_msgSend(v23, "UTF8String"));
  xpc_dictionary_set_uint64(v17, "processOptions", a8);
  xpc_dictionary_set_BOOL(v17, "copyIsDuplication", value);
  *(_QWORD *)uuid = 0;
  v36 = 0;
  -[TDSHelperContext getUUIDBytes:](v31, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v17, "GroupUUID", uuid);
  xpc_dictionary_set_int64(v17, "GroupCount", a6);
  xpc_dictionary_set_BOOL(v17, "UseFileProviderFramework", 0);
  TDSHelperContext::SendMessageAndWait(a1, v17);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = v24;
  int64 = 4294959293;
  if (v24 != (void *)MEMORY[0x1E0C81260])
  {
    if (v24)
    {
      if (v24 != (void *)MEMORY[0x1E0C81258])
      {
        int64 = xpc_dictionary_get_int64(v24, "errorStatus");
        if (!(_DWORD)int64)
        {
          *a11 = xpc_dictionary_get_BOOL(v25, "resultIsClone");
          string = xpc_dictionary_get_string(v25, "resultPath");
          TString::TString((TString *)&cf, string);
          if (&cf != a10)
          {
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a10, &cf);
            CFRetain(&stru_1E8752DF8);
            if (cf)
              CFRelease(cf);
            cf = &stru_1E8752DF8;
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (CFStringGetLength((CFStringRef)*a10))
            int64 = 0;
          else
            int64 = 4294959236;
        }
      }
    }
  }

  return int64;
}

void sub_1CBCA4C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

int64_t TDSHelperContext::FilesCopyDeleteLock(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  TDSHelperContext *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  void *v16;
  int64_t int64;
  unsigned __int8 uuid[8];
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  TDSHelperContext::CreateMessageForHelper(v9, "FilesCopyDeleteLock");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v7, 1, 0);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v8, 1, 0);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = objc_retainAutorelease(v11);
  xpc_dictionary_set_data(v10, "lockURLWrapper", (const void *)objc_msgSend(v13, "bytes"), objc_msgSend(v13, "length"));
  v14 = objc_retainAutorelease(v12);
  xpc_dictionary_set_data(v10, "sourceURLWrapper", (const void *)objc_msgSend(v14, "bytes"), objc_msgSend(v14, "length"));
  *(_QWORD *)uuid = 0;
  v20 = 0;
  -[TDSHelperContext getUUIDBytes:](v9, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v10, "GroupUUID", uuid);
  TDSHelperContext::SendMessageAndWait(a1, v10);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = v15;
  int64 = 4294959293;
  if (v15 != (void *)MEMORY[0x1E0C81260] && v15 && v15 != (void *)MEMORY[0x1E0C81258])
    int64 = xpc_dictionary_get_int64(v15, "errorStatus");

  return int64;
}

void sub_1CBCA4F14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopyDeleteItem(uint64_t a1, void *a2, unsigned int a3, BOOL a4, BOOL a5)
{
  TDSHelperContext *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  int64_t int64;

  v9 = a2;
  TDSHelperContext::CreateMessageForHelper(v9, "DeleteItem");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v9, 1, 0);
  v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  xpc_dictionary_set_data(v10, "sourceURLWrapper", (const void *)objc_msgSend(v11, "bytes"), objc_msgSend(v11, "length"));
  xpc_dictionary_set_uint64(v10, "mergeResolution", a3);
  xpc_dictionary_set_BOOL(v10, "deleteLocked", a4);
  xpc_dictionary_set_BOOL(v10, "deleteBusy", a5);
  xpc_dictionary_set_BOOL(v10, "reportProgress", 0);
  TDSHelperContext::SendMessageAndWait(a1, v10);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = v12;
  int64 = 4294959293;
  if (v12 != (void *)MEMORY[0x1E0C81260] && v12 && v12 != (void *)MEMORY[0x1E0C81258])
    int64 = xpc_dictionary_get_int64(v12, "errorStatus");

  return int64;
}

void sub_1CBCA50C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopySetRootMetadata(uint64_t a1, void *a2, void *a3, void *a4, unsigned int a5, _DWORD *a6)
{
  id v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  TDSHelperContext *v19;
  void *v20;
  void *v21;
  int64_t int64;
  _DWORD *v24;
  void *v25;
  TDSHelperContext *v26;
  id v27;

  v11 = a2;
  v27 = a3;
  v25 = v11;
  v26 = a4;
  TDSHelperContext::CreateMessageForHelper(v26, "RunFilesCopyRunSetRootMetadata");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v11, 1, 0);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v27, 0, 0);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = a6;
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v13, 1, 0);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v14, 1, 0);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = objc_retainAutorelease(v15);
  xpc_dictionary_set_data(v12, "sourceURLWrapper", (const void *)objc_msgSend(v17, "bytes"), objc_msgSend(v17, "length"));
  v18 = objc_retainAutorelease(v16);
  xpc_dictionary_set_data(v12, "destinationURLWrapper", (const void *)objc_msgSend(v18, "bytes"), objc_msgSend(v18, "length"));
  v19 = objc_retainAutorelease(v26);
  xpc_dictionary_set_string(v12, "targetName", (const char *)-[TDSHelperContext UTF8String](v19, "UTF8String"));
  xpc_dictionary_set_int64(v12, "requestedOperation", a5);
  TDSHelperContext::SendMessageAndWait(a1, v12);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v21 = v20;
  int64 = 4294959293;
  if (v20 != (void *)MEMORY[0x1E0C81260] && v20 && v20 != (void *)MEMORY[0x1E0C81258])
  {
    *v24 = xpc_dictionary_get_int64(v20, "completedOperation");
    int64 = xpc_dictionary_get_int64(v21, "errorStatus");
  }

  return int64;
}

void sub_1CBCA533C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopyOperationSize(uint64_t a1, void *a2, void *a3, void *a4, unsigned int a5, __int16 a6, int64_t *a7, unsigned int a8, void *a9, int64_t *a10)
{
  int64_t v16;
  int64_t v17;
  int64_t v18;
  int64_t v19;
  void *v20;
  void *v21;
  void *v22;
  int64_t v23;
  const char *string;
  const char *v25;
  int64_t v26;
  uint64_t uint64;
  int v28;
  char v29;
  char v30;
  int64_t v31;
  int64_t v33;
  int64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  int64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  int64_t v43;
  id v44;
  int64_t v46;
  int64_t v47;
  int64_t int64;
  id v49;
  void *v50;
  void *v51;
  TDSHelperContext *v52;
  id v53;
  id v54;
  id v55;
  id v56;
  void *v57;
  void *v58;
  unsigned __int8 uuid[8];
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v56 = a2;
  v55 = a3;
  v49 = a4;
  v52 = a9;
  v16 = *a7;
  v17 = a7[1];
  v19 = a7[2];
  v18 = a7[3];
  v47 = a7[269];
  TDSHelperContext::CreateMessageForHelper(v52, "FilesCopyOperationSizing");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v56, 1, 0);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v55, 0, 0);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v58, 1, 0);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v57, 1, 0);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = objc_retainAutorelease(v50);
  xpc_dictionary_set_data(v20, "sourceURLWrapper", (const void *)objc_msgSend(v54, "bytes"), objc_msgSend(v54, "length"));
  v53 = objc_retainAutorelease(v51);
  xpc_dictionary_set_data(v20, "destinationURLWrapper", (const void *)objc_msgSend(v53, "bytes"), objc_msgSend(v53, "length"));
  v44 = objc_retainAutorelease(v49);
  xpc_dictionary_set_string(v20, "targetName", (const char *)objc_msgSend(v44, "UTF8String"));
  xpc_dictionary_set_BOOL(v20, "Coordinate", (a6 & 0x2000) != 0);
  xpc_dictionary_set_int64(v20, "requestedOperation", a5);
  xpc_dictionary_set_int64(v20, "conflicts", a8);
  xpc_dictionary_set_int64(v20, "userVisibleItemsTotal", v16);
  xpc_dictionary_set_int64(v20, "FSItemsTotal", v17);
  xpc_dictionary_set_int64(v20, "logicalBytesTotal", v19);
  xpc_dictionary_set_int64(v20, "physicalBytesTotal", v18);
  xpc_dictionary_set_int64(v20, "conflictPhysicalDelta", v47);
  xpc_dictionary_set_BOOL(v20, "canMerge", (a6 & 0x40) == 0);
  *(_QWORD *)uuid = 0;
  v60 = 0;
  -[TDSHelperContext getUUIDBytes:](v52, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v20, "GroupUUID", uuid);
  TDSHelperContext::SendMessageAndWait(a1, v20);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = v21;
  v23 = 4294959293;
  if (v21 != (void *)MEMORY[0x1E0C81260] && v21 && v21 != (void *)MEMORY[0x1E0C81258])
  {
    *a10 = xpc_dictionary_get_int64(v21, "oprecordBytesCompleted");
    int64 = xpc_dictionary_get_int64(v22, "userVisibleItemsCompleted");
    v46 = xpc_dictionary_get_int64(v22, "itemsCompleted");
    v43 = xpc_dictionary_get_int64(v22, "logicalBytesTotal");
    v42 = xpc_dictionary_get_int64(v22, "physicalBytesTotal");
    v41 = xpc_dictionary_get_int64(v22, "mergeSourceNewerConflictsCount");
    v40 = xpc_dictionary_get_int64(v22, "mergeDestinationNewerConflictsCount");
    v39 = xpc_dictionary_get_int64(v22, "mergeDestinationNewerConflictsBytes");
    v38 = xpc_dictionary_get_int64(v22, "mergeSourceItemsNotInDestinationCount");
    v37 = xpc_dictionary_get_int64(v22, "mergeDestinationItemsNotInSourceCount");
    v36 = xpc_dictionary_get_int64(v22, "mergeMatchedFilesCount");
    v35 = xpc_dictionary_get_int64(v22, "mergeMatchedFilesBytes");
    v34 = xpc_dictionary_get_int64(v22, "mergeDiffMetaDataFilesCount");
    v33 = xpc_dictionary_get_int64(v22, "mergePhysicalDelta");
    string = xpc_dictionary_get_string(v22, "mergeFirstSourceConflictPath");
    v25 = xpc_dictionary_get_string(v22, "mergeFirstDestinationConflictPath");
    v26 = xpc_dictionary_get_int64(v22, "conflictPhysicalDelta");
    uint64 = xpc_dictionary_get_uint64(v22, "maxFileSize");
    v28 = xpc_dictionary_get_int64(v22, "conflicts");
    v29 = xpc_dictionary_get_BOOL(v22, "mergeAllowed");
    v30 = xpc_dictionary_get_BOOL(v22, "CopyWillClone");
    v31 = xpc_dictionary_get_int64(v22, "errorStatus");
    TDSHelperContext::UpdateDestinationSpaceNeeds(v31, (uint64_t)a7, int64, v46, v43, v42, v41, v40, v39, v38, v37, v36, v35, v34, v33, string, v25, v26, uint64,
      v28,
      v29,
      v30,
      v31);
    v23 = xpc_dictionary_get_int64(v22, "errorStatus");
  }

  return v23;
}

void sub_1CBCA5914(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::PerformFilesCopy(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, BOOL a7, BOOL a8, _DWORD *a9)
{
  id v15;
  void *v16;
  void *v17;
  unint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  id v28;
  void *v29;
  void *v30;
  int64_t int64;
  id v33;
  id v34;
  id v35;
  uint64_t v36;
  BOOL v37;
  BOOL v38;
  TDSHelperContext *v40;
  id v41;
  xpc_object_t xdict;
  id v43;
  id v44;
  unsigned __int8 uuid[8];
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v15 = a2;
  v41 = a3;
  v43 = a4;
  v40 = a5;
  TDSHelperContext::CreateMessageForHelper(v40, "RunFilesCopyOperation");
  xdict = (xpc_object_t)objc_claimAutoreleasedReturnValue();
  v37 = a8;
  v38 = a7;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = a1;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = 0;
  v19 = 0;
  while (v18 < objc_msgSend(v15, "count"))
  {
    objc_msgSend(v15, "objectAtIndexedSubscript:", v18);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = (void *)objc_opt_class();
    v44 = v19;
    objc_msgSend(v21, "wrapperWithURL:readonly:error:", v20, 1, &v44);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = v44;

    if (v22)
    {
      objc_msgSend(v16, "addObject:", v22);
      objc_msgSend(v43, "objectAtIndexedSubscript:", v18);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v17, "addObject:", v24);

    }
    ++v18;
    v19 = v23;
  }
  objc_msgSend((id)objc_opt_class(), "wrapperWithURL:readonly:error:", v41, 0, 0);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v16, 1, 0);
  v34 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v25, 1, 0);
  v33 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v43, 1, 0);
  v35 = (id)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_set_int64(xdict, "requestedOperation", 2);
  v26 = objc_retainAutorelease(v34);
  xpc_dictionary_set_data(xdict, "sourceURLWrappers", (const void *)objc_msgSend(v26, "bytes"), objc_msgSend(v26, "length"));
  v27 = objc_retainAutorelease(v33);
  xpc_dictionary_set_data(xdict, "destinationURLWrapper", (const void *)objc_msgSend(v27, "bytes"), objc_msgSend(v27, "length"));
  v28 = objc_retainAutorelease(v35);
  xpc_dictionary_set_data(xdict, "targetNames", (const void *)objc_msgSend(v28, "bytes"), objc_msgSend(v28, "length"));
  xpc_dictionary_set_uint64(xdict, "maxFileSize", a6);
  xpc_dictionary_set_BOOL(xdict, "copySync", v38);
  xpc_dictionary_set_BOOL(xdict, "copyIsDuplication", v37);
  *(_QWORD *)uuid = 0;
  v46 = 0;
  -[TDSHelperContext getUUIDBytes:](v40, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(xdict, "GroupUUID", uuid);
  TDSHelperContext::SendMessageAndWait(v36, xdict);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = v29;
  int64 = 4294959293;
  if (v29 != (void *)MEMORY[0x1E0C81260] && v29 && v29 != (void *)MEMORY[0x1E0C81258])
  {
    *a9 = xpc_dictionary_get_int64(v29, "completedOperation");
    int64 = xpc_dictionary_get_int64(v30, "errorStatus");
  }

  return int64;
}

void sub_1CBCA5D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

void TDSHelperContext::HandleMsgFromHelper(uint64_t a1, const char *a2, void *a3)
{
  id v5;

  v5 = a3;
  if (!strcmp(a2, "DeleteItem_Reply")
    || !strcmp(a2, "ChildCreateLock_Reply")
    || !strcmp(a2, "RunCopyMoveOperation_Reply")
    || !strcmp(a2, "OperationSizing_Reply")
    || !strcmp(a2, "FilesCopyDeleteLock_Reply")
    || !strcmp(a2, "RunFilesCopyOperation"))
  {
    TDSHelperContext::ReplyReceived(a1, v5);
  }

}

void sub_1CBCA5F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void TCloneCache::TCloneCache(TCloneCache *this, char a2)
{
  *(_BYTE *)this = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
}

_QWORD *TCloneCache::RecordClone(TCloneCache *a1, unint64_t *a2, uint64_t *a3)
{
  _QWORD *result;
  _QWORD *v7;
  unint64_t *v8;

  result = (_QWORD *)TCloneCache::HasCloneID(a1, a2);
  if ((result & 1) == 0)
  {
    if (*(_BYTE *)a1)
    {
      v8 = a2;
      v7 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)a1 + 8, a2, (uint64_t)&std::piecewise_construct, &v8);
      return std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v7 + 3, a3);
    }
    else
    {
      return std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)a1 + 48, a2, a2);
    }
  }
  return result;
}

BOOL TCloneCache::HasCloneID(TCloneCache *this, unint64_t *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  if (*(_BYTE *)this)
  {
    v2 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>((_QWORD *)this + 1, a2);
    if (v2)
    {
      v3 = (_QWORD *)v2[3];
      v4 = (std::__shared_weak_count *)v2[4];
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    v3 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>((_QWORD *)this + 6, a2);
  }
  return v3 != 0;
}

void TCloneCache::RemoveAll(TCloneCache *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear((_QWORD *)this + 6);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::clear((uint64_t)this + 8);
}

void std::vector<TString>::__vdeallocate(void **a1)
{
  const void **v1;
  const void **v3;
  void *v4;

  v1 = (const void **)*a1;
  if (*a1)
  {
    v3 = (const void **)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        v3 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3 - 1);
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString const*,TString const*,TString*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      std::construct_at[abi:ne180100]<TString,TString const&,TString*>((TString *)(a4 + v7), (TString **)(a2 + v7));
      v7 += 8;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1CBCA6150(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 8;
    do
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v4 + v2));
      v2 -= 8;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

TString *std::construct_at[abi:ne180100]<TString,TString const&,TString*>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  return a1;
}

void sub_1CBCA61B4(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v6;
  i[2] = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCA63CC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  uint64_t *result;

  result = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a1, a2);
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    operator delete(v3);
  return v2;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;

  if (result[3])
  {
    v1 = result;
    result = (_QWORD *)result[2];
    if (result)
    {
      do
      {
        v2 = (_QWORD *)*result;
        operator delete(result);
        result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    v3 = v1[1];
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        *(_QWORD *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void TString::TString(TString *this, const TString *a2)
{
  this->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(this, (TString *)a2->fString.fRef);
}

void sub_1CBCA6600(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

CFComparisonResult SpotlightStringCompare(const __CFString *a1, const __CFString *a2)
{
  if (a1)
  {
    if (a2)
      return CFStringCompare(a1, a2, 0x260uLL);
    else
      return 1;
  }
  else if (a2)
  {
    return -1;
  }
  else
  {
    return 0;
  }
}

const void **FileSuffixChain@<X0>(TString a1@<0:X0>, TString *a2@<X8>)
{
  uint64_t v4;
  const __CFAllocator *v5;
  _BOOL4 v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  CFIndex Length;
  CFIndex v15;
  const __CFString *v16;
  const __CFString *MutableCopy;
  CFStringRef v19;
  CFTypeRef cf;
  CFStringRef theString;

  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  FileSuffix((const TString *)a1.fString.fRef, (TString *)&v19);
  v4 = *MEMORY[0x1E0CEC528];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&theString, (TString *)v19);
    TString::TString((TString *)&cf, ".");
    v6 = TString::BeginsWith((TString *)&theString, (const TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v6)
    {
      TString::SubStringFrom((TString *)&v19, 1, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&theString, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    if (!CFStringGetLength(theString))
      break;
    objc_msgSend(MEMORY[0x1E0CEC3F8], "typeWithFilenameExtension:conformingToType:", theString, v4);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    if (!v7)
      break;
    if (objc_msgSend(v7, "isDeclared"))
    {

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    }
    else
    {
      v9 = objc_alloc(MEMORY[0x1E0CA58A8]);
      objc_msgSend(v8, "identifier");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = (void *)objc_msgSend(v9, "initWithTypeIdentifier:error:", v10, 0);

      objc_msgSend(v11, "bundleRecord");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "executableURL");
      v13 = (void *)objc_claimAutoreleasedReturnValue();

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (!v13)
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
    }
    Length = CFStringGetLength((CFStringRef)a1.fString.fRef->isa);
    v15 = CFStringGetLength(v19);
    TString::SetLength((TString *)a1.fString.fRef, Length - v15);
    v16 = v19;
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    MutableCopy = CFStringCreateMutableCopy(v5, 0, v16);
    if (theString)
      CFRelease(theString);
    theString = MutableCopy;
    TString::Append((TString *)&theString, a2);
    if (&theString != (CFStringRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, (const void **)&theString);
      CFRetain(&stru_1E8752DF8);
      if (theString)
        CFRelease(theString);
      theString = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    FileSuffix((const TString *)a1.fString.fRef, (TString *)&theString);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v19, (const void **)&theString);
    CFRetain(&stru_1E8752DF8);
    if (theString)
      CFRelease(theString);
    theString = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
}

void sub_1CBCA68D8(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

TString *RedactedStr@<X0>(TString *a1@<X0>, TString *a2@<X8>)
{
  CFIndex Length;
  TString v5;
  uint64_t v6;
  CFIndex v7;
  int v8;
  uint64_t v9;
  __CFString *fRef;
  __CFString *v12;
  uint64_t data_low;
  NSUInteger v14;
  NSUInteger v15;
  __CFString *v16;
  int data;
  __CFString *v18;
  CFIndex v19;
  __CFString *v20;
  const __CFAllocator *v21;
  CFMutableStringRef MutableCopy;
  std::string *v23;
  CFIndex size;
  const __CFString *v25;
  CFMutableStringRef v26;
  const __CFString *v27;
  CFMutableStringRef v28;
  const __CFString *v29;
  CFMutableStringRef v30;
  const __CFString *v31;
  CFMutableStringRef v32;
  void *__p;
  char v35;
  TString v36;
  std::string v37;
  TString v38;
  TString v39;
  CFTypeRef cf;
  CFTypeRef v41;
  CFTypeRef v42;
  CFTypeRef v43;
  TString v44;
  TString v45;
  _NSRange v46;
  _NSRange v47;
  TString v48;
  TString v49;
  TString v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t);
  void *v53;
  std::string *v54;

  if (!CFStringGetLength(a1->fString.fRef))
    return TString::TString(a2, "<empty>", 7uLL);
  Length = CFStringGetLength(a1->fString.fRef);
  v48.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v48, (TString *)a1->fString.fRef);
  v5.fString.fRef = (__CFString *)&v48;
  FileSuffixChain(v5, &v49);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v48.fString.fRef);
  v6 = Length - CFStringGetLength(v49.fString.fRef);
  if (v6 <= 2 && CFStringGetLength(v49.fString.fRef))
  {
    while (1)
    {
      v7 = v6 + 1;
      if (v6 + 1 >= Length)
        break;
      v8 = v6 < -1 || CFStringGetLength(a1->fString.fRef) <= v7
         ? 0
         : CFStringGetCharacterAtIndex(a1->fString.fRef, v6 + 1);
      v9 = v6 + 1;
      if (v6++ >= 2)
      {
        v6 = v9;
        if (v8 == 46)
          break;
      }
    }
    TString::SubStringFrom(a1, v7, &v50);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v49.fString.fRef, (const void **)&v50.fString.fRef);
    CFRetain(&stru_1E8752DF8);
    if (v50.fString.fRef)
      CFRelease(v50.fString.fRef);
    v50.fString.fRef = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v50.fString.fRef);
    v6 = v7;
  }
  LODWORD(v37.__r_.__value_.__l.__data_) = 0;
  fRef = a1->fString.fRef;
  v12 = (__CFString *)MEMORY[0x1E0C809B0];
  v50.fString.fRef = (__CFString *)MEMORY[0x1E0C809B0];
  v51 = 3321888768;
  v52 = ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke;
  v53 = &__block_descriptor_40_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE__e52_v56__0__NSString_8__NSRange_QQ_16__NSRange_QQ_32_B48l;
  v54 = &v37;
  -[__CFString enumerateSubstringsInRange:options:usingBlock:](fRef, "enumerateSubstringsInRange:options:usingBlock:", 0, Length, 2, &v50);
  data_low = SLODWORD(v37.__r_.__value_.__l.__data_);
  if (data_low - CFStringGetLength(v49.fString.fRef) < 3)
  {
    TString::TString(a2, "<private>", 9uLL);
  }
  else
  {
    v47.location = 0;
    v47.length = 0;
    v47.location = -[__CFString rangeOfComposedCharacterSequenceAtIndex:](a1->fString.fRef, "rangeOfComposedCharacterSequenceAtIndex:", 0);
    v47.length = v14;
    v46.location = 0;
    v46.length = 0;
    v46.location = -[__CFString rangeOfComposedCharacterSequenceAtIndex:](a1->fString.fRef, "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
    v46.length = v15;
    TString::SubString(a1, &v47, &v45);
    TString::SubString(a1, &v46, &v44);
    LODWORD(v37.__r_.__value_.__l.__data_) = 0;
    v16 = a1->fString.fRef;
    v50.fString.fRef = v12;
    v51 = 3321888768;
    v52 = ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke;
    v53 = &__block_descriptor_40_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE__e52_v56__0__NSString_8__NSRange_QQ_16__NSRange_QQ_32_B48l;
    v54 = &v37;
    -[__CFString enumerateSubstringsInRange:options:usingBlock:](v16, "enumerateSubstringsInRange:options:usingBlock:", v47.length + v47.location, v46.location - (v47.length + v47.location), 2, &v50);
    data = (int)v37.__r_.__value_.__l.__data_;
    HIBYTE(v52) = 1;
    LOWORD(v50.fString.fRef) = 123;
    v39.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    if (SHIBYTE(v52) >= 0)
      v18 = (__CFString *)&v50;
    else
      v18 = v50.fString.fRef;
    if (SHIBYTE(v52) >= 0)
      v19 = HIBYTE(v52);
    else
      v19 = v51;
    TString::SetFromUTF8(&v39, (const UInt8 *)v18, v19);
    v20 = v45.fString.fRef;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v20);
    if (cf)
      CFRelease(cf);
    cf = MutableCopy;
    TString::Append((TString *)&cf, &v39);
    std::to_string(&v37, data);
    v38.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v23 = &v37;
    else
      v23 = (std::string *)v37.__r_.__value_.__r.__words[0];
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
    else
      size = v37.__r_.__value_.__l.__size_;
    TString::SetFromUTF8(&v38, (const UInt8 *)v23, size);
    v25 = (const __CFString *)cf;
    v41 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v26 = CFStringCreateMutableCopy(v21, 0, v25);
    if (v41)
      CFRelease(v41);
    v41 = v26;
    TString::Append((TString *)&v41, &v38);
    v35 = 1;
    LOWORD(__p) = 125;
    v36.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetFromUTF8(&v36, (const UInt8 *)&__p, 1);
    v27 = (const __CFString *)v41;
    v42 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v28 = CFStringCreateMutableCopy(v21, 0, v27);
    if (v42)
      CFRelease(v42);
    v42 = v28;
    TString::Append((TString *)&v42, &v36);
    v29 = (const __CFString *)v42;
    v43 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v30 = CFStringCreateMutableCopy(v21, 0, v29);
    if (v43)
      CFRelease(v43);
    v43 = v30;
    TString::Append((TString *)&v43, &v44);
    v31 = (const __CFString *)v43;
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v32 = CFStringCreateMutableCopy(v21, 0, v31);
    if (a2->fString.fRef)
      CFRelease(a2->fString.fRef);
    a2->fString.fRef = v32;
    TString::Append(a2, &v49);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v43);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v42);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v36.fString.fRef);
    if (v35 < 0)
      operator delete(__p);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v41);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v37.__r_.__value_.__l.__data_);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
    if (SHIBYTE(v52) < 0)
      operator delete(v50.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v45.fString.fRef);
  }
  return (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v49.fString.fRef);
}

void sub_1CBCA6E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,int a43,__int16 a44,char a45,char a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  uint64_t v55;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v55 - 144));
  _Unwind_Resume(a1);
}

void AcceptableNames(void)
{
  unsigned __int8 v0;
  TCFURLInfo *v1;
  uint64_t *PropertyStoreName;
  uint64_t i;
  TString v4;
  TString v5;
  TString v6;
  TString v7;
  TString v8;
  TString v9;
  TString v10;
  TString v11;
  TString v12;
  TString v13;
  TString v14;
  TString v15;
  TString v16;
  TString v17;
  TString v18;
  TString v19;
  TString v20;
  TString v21;
  TString v22[2];

  v22[1] = *(TString *)MEMORY[0x1E0C80C00];
  {
    TString::TString(&v4, "/", 1uLL);
    TString::TString(&v5, "Volumes", 7uLL);
    TString::TString(&v6, "Users", 5uLL);
    TString::TString(&v7, "Applications", 0xCuLL);
    TString::TString(&v8, "Utilities", 9uLL);
    TString::TString(&v9, "System", 6uLL);
    TString::TString(&v10, "Desktop", 7uLL);
    TString::TString(&v11, "Documents", 9uLL);
    TString::TString(&v12, "Downloads", 9uLL);
    TString::TString(&v13, "Library", 7uLL);
    TString::TString(&v14, "Movies", 6uLL);
    TString::TString(&v15, "Music", 5uLL);
    TString::TString(&v16, "Pictures", 8uLL);
    TString::TString(&v17, "Public", 6uLL);
    v1 = (TCFURLInfo *)TString::TString(&v18, "Drop Box", 8uLL);
    PropertyStoreName = TCFURLInfo::GetPropertyStoreName(v1);
    TString::TString(&v19, (const TString *)PropertyStoreName);
    TString::TString(&v20, ".localized", 0xAuLL);
    TString::TString(&v21, ".Trash", 6uLL);
    TString::TString(v22, ".Trashes", 8uLL);
    std::unordered_set<TString>::unordered_set((uint64_t)&AcceptableNames(void)::sNames, &v4, 19);
    for (i = 144; i != -8; i -= 8)
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)((char *)&v4.fString.fRef + i));
  }
}

void sub_1CBCA7288(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t i;

  for (i = 144; i != -8; i -= 8)
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v1 + i));
  _Unwind_Resume(a1);
}

id SanitizedURL(NSURL *a1)
{
  NSURL *v1;
  TString *v2;
  void *v3;
  void *v4;
  void *v6;
  void *v7;
  TString v8;

  v1 = a1;
  -[NSURL path](v1, "path");
  v2 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  v8.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v8, v2);

  SanitizedPath(&v8);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);

  if (IsRedactionEnabled()
    && -[NSURL isFileURL](v1, "isFileURL")
    && !-[NSURL isFileReferenceURL](v1, "isFileReferenceURL"))
  {
    v6 = (void *)MEMORY[0x1E0CB3940];
    -[NSURL scheme](v1, "scheme");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "stringWithFormat:", CFSTR("%@://<private> (%@)"), v7, v3);
    v4 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ (%@)"), v1, v3);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v4;
}

void sub_1CBCA73EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke(uint64_t result)
{
  ++**(_DWORD **)(result + 32);
  return result;
}

uint64_t __copy_helper_block_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t std::unordered_set<TString>::unordered_set(uint64_t a1, TString *this, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 8 * a3;
    do
    {
      std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__emplace_unique_key_args<TString,TString const&>(a1, this, (TString **)this);
      ++this;
      v5 -= 8;
    }
    while (v5);
  }
  return a1;
}

void sub_1CBCA74C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__emplace_unique_key_args<TString,TString const&>(uint64_t a1, TString *this, TString **a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint64_t ***v12;
  uint64_t **i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[3];

  v7 = FowlerNollVoHash::hash(this, this);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = (uint64_t **)*i)
      {
        v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if (CFEqual(i[2], this->fString.fRef))
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__construct_node_hash<TString const&>(a1, (__CFString *)v8, a3, (uint64_t)v24);
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9)
          v22 %= v9;
      }
      else
      {
        v22 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  i = (uint64_t **)v24[0];
  v24[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return i;
}

void sub_1CBCA7730(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

TString *std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__construct_node_hash<TString const&>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  TString *v8;
  TString *result;

  v7 = a1 + 16;
  v8 = (TString *)operator new(0x18uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  v8->fString.fRef = 0;
  v8[1].fString.fRef = a2;
  result = std::construct_at[abi:ne180100]<TString,TString const&,TString*>(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCA77A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(_QWORD *a1, TString *this)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **i;
  unint64_t v12;

  v4 = FowlerNollVoHash::hash(this, this);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  for (i = *v10; i; i = (uint64_t **)*i)
  {
    v12 = (unint64_t)i[1];
    if (v6 == v12)
    {
      if (CFEqual(i[2], this->fString.fRef))
        return i;
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(_QWORD *)&v5)
          v12 %= *(_QWORD *)&v5;
      }
      else
      {
        v12 &= *(_QWORD *)&v5 - 1;
      }
      if (v12 != v9)
        return 0;
    }
  }
  return i;
}

_QWORD *TReservationRecord::TReservationRecord(_QWORD *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[2] = 0;
  a1[1] = 0;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 1, a2);
  return a1;
}

void TReservationRecord::~TReservationRecord(TFileCoordinationRecord **this)
{
  TFileCoordinationRecord *v2;

  v2 = *this;
  if (v2)
  {
    TFileCoordinationRecord::~TFileCoordinationRecord(v2);
    MEMORY[0x1D17A53D0]();
  }
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(this + 1));
}

uint64_t TReservationRecord::CreateAndAcquireFileCoordinator(TReservationRecord *this, NSFileCoordinator *a2)
{
  NSFileCoordinator *v3;
  uint64_t v4;
  TFileCoordinationRecord *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v3 = a2;
  if (*(_QWORD *)this
    || (v5 = (TFileCoordinationRecord *)operator new(),
        TFileCoordinationRecord::TFileCoordinationRecord(v5, v3),
        *(_QWORD *)this = v5,
        v7 = *((_QWORD *)this + 1),
        v6 = (uint64_t *)((char *)this + 8),
        !v7))
  {
    v4 = 4294959201;
  }
  else
  {
    TFileCoordinationRecord::CoordinateReading((uint64_t)v5, v6, 0, &v13);
    v8 = v13;
    if (v13 != *v6)
    {
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v6, &v13);
      v8 = *v6;
    }
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if (v8)
      v4 = 0;
    else
      v4 = 4294959201;
  }

  return v4;
}

void sub_1CBCA7A24(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA7B08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCA7EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1CBCA8724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c62_ZTSKZ49__FINode_fiNodeFromItem_inFPv2Domain_completion__E3__0(_QWORD *a1, uint64_t a2)
{
  uint64_t result;

  a1[4] = *(id *)(a2 + 32);
  a1[5] = *(id *)(a2 + 40);
  result = MEMORY[0x1D17A5A30](*(_QWORD *)(a2 + 48));
  a1[6] = result;
  return result;
}

void __destroy_helper_block_ea8_32c62_ZTSKZ49__FINode_fiNodeFromItem_inFPv2Domain_completion__E3__0(id *a1)
{

}

void sub_1CBCA8A60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBCA8B04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBCA8BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBCA8C6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA8E98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA8EE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA8F50(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA92F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9364(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9410(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA94BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9568(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9614(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9700(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9770(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA98DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t FINodeSizingSkipProc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t v6;

  v5 = a3;
  if ((objc_opt_respondsToSelector() & 1) != 0)
    v6 = objc_msgSend(v5, "FINodeSizingSkip:forParent:", a1, a2);
  else
    v6 = 0;

  return v6;
}

void sub_1CBCA9968(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t FINodeSizingCancelProc(void *a1)
{
  id v1;
  uint64_t v2;

  v1 = a1;
  if ((objc_opt_respondsToSelector() & 1) != 0)
    v2 = objc_msgSend(v1, "FINodeSizingCancel");
  else
    v2 = 0;

  return v2;
}

void sub_1CBCA99C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCA9E80(_Unwind_Exception *a1, void *a2, void *a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, FPItem **a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  char *v8;
  uint64_t result;

  v8 = (char *)operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1CBCAA01C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, *a3, *a4);
  return a1;
}

void sub_1CBCAA074(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFSInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87507A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87507A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

TFSInfoOverflow *std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100](TFSInfoOverflow **a1, TFSInfoOverflow *a2)
{
  TFSInfoOverflow *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    TFSInfoOverflow::~TFSInfoOverflow(result);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

void std::default_delete<TVersionData>::operator()[abi:ne180100](uint64_t a1, const void **a2)
{
  if (a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2 + 3);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2 + 2);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2 + 1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2);
    JUMPOUT(0x1D17A53D0);
  }
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCAA208(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(a1, a2);
  if (a3 >= 1)
  {
    v5 = *(_QWORD *)(a1 + 120);
    do
    {
      if (v5 >= *(_QWORD *)(a1 + 112) - 1)
      {
        v6 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
        v5 = -1;
        *(_QWORD *)(a1 + 112) = v6;
        *(_QWORD *)(a1 + 120) = -1;
      }
      if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
      {
        objc_enumerationMutation(*(id *)a1);
        v5 = *(_QWORD *)(a1 + 120);
      }
      v7 = *(_QWORD *)(a1 + 128) + 1;
      *(_QWORD *)(a1 + 120) = ++v5;
      *(_QWORD *)(a1 + 128) = v7;
      --a3;
    }
    while (a3);
  }
  return a1;
}

void sub_1CBCAA2C8(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCAA448(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCAA4C4(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItem *>>::NSForwardIterator<NSArray<FPItem *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCAA584(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItem *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCAA600(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ___ZL30DefaultContainerOfDomainWithIDRK7TString_block_invoke(uint64_t a1)
{
  return IsDatalessDomain(*(NSURL **)(a1 + 32), 1);
}

id __copy_helper_block_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0(uint64_t a1)
{

}

id DSLocalizationBundle(void)
{
  if (DSLocalizationBundle(void)::onceToken != -1)
    dispatch_once(&DSLocalizationBundle(void)::onceToken, &__block_literal_global_3);
  return (id)DSLocalizationBundle(void)::bundle;
}

void ___Z20DSLocalizationBundlev_block_invoke()
{
  uint64_t v0;
  void *v1;

  objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", objc_opt_class());
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = (void *)DSLocalizationBundle(void)::bundle;
  DSLocalizationBundle(void)::bundle = v0;

}

id DSLocalizedErrorStringForKey(NSString *a1)
{
  NSString *v1;
  void *v2;
  void *v3;
  NSObject *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  uint8_t buf[4];
  NSString *v11;
  __int16 v12;
  void *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  DSLocalizationBundle();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "localizedStringForKey:value:table:", v1, CFSTR("X"), 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  if (objc_msgSend(v3, "isEqualToString:", CFSTR("X")))
  {
    LogObj(2);
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      DSLocalizationBundle();
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "bundlePath");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543618;
      v11 = v1;
      v12 = 2114;
      v13 = v6;
      _os_log_impl(&dword_1CBC4A000, v4, OS_LOG_TYPE_ERROR, "Localized key '%{public}@' missing from DesktopServices (bundlePath:%{public}@)", buf, 0x16u);

    }
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("KEY_MISSING(%@)"), v1);
    v7 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v7 = v3;
  }
  v8 = v7;

  return v8;
}

void sub_1CBCAA834(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1CBCAAA70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCAAC44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCAACB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBCAAD24(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCAADC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBCAAF64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCAB0C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCAB1B8(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x1D17A53D0](v2, 0x10E1C4078A9A281);

  _Unwind_Resume(a1);
}

void sub_1CBCAB344(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCAB540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  const void *v12;
  va_list va;
  uint64_t v14;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v12 = va_arg(va1, const void *);
  v14 = va_arg(va1, _QWORD);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);

  _Unwind_Resume(a1);
}

void sub_1CBCAB974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  va_list va;

  va_start(va, a11);
  TRef<__CFUserNotification *,TRetainReleasePolicy<__CFUserNotification *>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBCABAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1CBCABF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25)
{
  void *v25;
  uint64_t v26;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v26 - 104));

  _Unwind_Resume(a1);
}

void sub_1CBCAC184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  va_list va;

  va_start(va, a2);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCAC404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a4);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCAC834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1CBCACB0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1CBCAD44C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,void *a24,uint64_t a25,void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,void *a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,id a49,uint64_t a50,char a51,uint64_t a52,id a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  void *v63;
  void *v64;
  void *v65;
  void *v66;

  StScopedResourceAccess::~StScopedResourceAccess(&a49);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a51);
  StScopedResourceAccess::~StScopedResourceAccess(&a53);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a63);
  _Unwind_Resume(a1);
}

void sub_1CBCAD718(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCADEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,id a53,uint64_t a54,id a55)
{
  void *v55;
  void *v56;

  StScopedResourceAccess::~StScopedResourceAccess(&a53);
  _Unwind_Resume(a1);
}

void sub_1CBCAE174(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c102_ZTSKZ89__DSNSHelperContext_copyItemsAtURLs_toURL_options_conflictStrategy_receiveTargets_error__E3__1(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

void sub_1CBCAE244(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void StScopedResourceAccess::StScopedResourceAccess(StScopedResourceAccess *this, NSURL *a2)
{
  NSURL *v3;
  char v4;
  char v5;
  NSObject *v6;
  uint8_t v7[16];

  v3 = a2;
  *(_QWORD *)this = v3;
  v4 = -[NSURL startAccessingSecurityScopedResource](v3, "startAccessingSecurityScopedResource");
  *((_BYTE *)this + 8) = v4;
  if (*(_QWORD *)this)
    v5 = v4;
  else
    v5 = 1;
  if ((v5 & 1) == 0)
  {
    LogObj(2);
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_ERROR, "Failed to access security-scoped resource.", v7, 2u);
    }

  }
}

void sub_1CBCAE334(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void StScopedResourceAccess::~StScopedResourceAccess(id *this)
{
  if (*((_BYTE *)this + 8))
    objc_msgSend(*this, "stopAccessingSecurityScopedResource");

}

const void **TRef<__CFUserNotification *,TRetainReleasePolicy<__CFUserNotification *>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t BRContainerClass(void)
{
  return objc_opt_class();
}

uint64_t CheckPointXattrName(void)
{
  unsigned __int8 v0;

  {
    CheckPointXattrName(void)::sCheckpointXattrNameLegacy = (uint64_t)xattr_name_with_flags("com.apple.finder.copy.checkpoint", 4uLL);
  }
  return CheckPointXattrName(void)::sCheckpointXattrNameLegacy;
}

void sub_1CBCAE42C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t SourceInodeXattrName(char a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  unsigned __int8 v3;
  __guard *v5;

  if ((a1 & 1) == 0)
  {
    if ((v3 & 1) != 0)
    {
      v2 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrName;
      return *v2;
    }
    v2 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrName;
      return *v2;
    SourceInodeXattrName(BOOL)::sSourceInodeXattrName = (uint64_t)xattr_name_without_flags("com.apple.finder.copy.source.inode");
LABEL_11:
    __cxa_guard_release(v5);
    return *v2;
  }
  if ((v1 & 1) == 0)
  {
    v2 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrNameLegacy;
      return *v2;
    SourceInodeXattrName(BOOL)::sSourceInodeXattrNameLegacy = (uint64_t)xattr_name_with_flags("com.apple.finder.copy.source.inode", 4uLL);
    goto LABEL_11;
  }
  v2 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrNameLegacy;
  return *v2;
}

void sub_1CBCAE508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t SourceVolumeUUIDXattrName(char a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  unsigned __int8 v3;
  __guard *v5;

  if ((a1 & 1) == 0)
  {
    if ((v3 & 1) != 0)
    {
      v2 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrName;
      return *v2;
    }
    v2 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrName;
      return *v2;
    SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrName = (uint64_t)xattr_name_without_flags("com.apple.finder.copy.source.volumeuuid");
LABEL_11:
    __cxa_guard_release(v5);
    return *v2;
  }
  if ((v1 & 1) == 0)
  {
    v2 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrNameLegacy;
      return *v2;
    SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrNameLegacy = (uint64_t)xattr_name_with_flags("com.apple.finder.copy.source.volumeuuid", 4uLL);
    goto LABEL_11;
  }
  v2 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrNameLegacy;
  return *v2;
}

void sub_1CBCAE5F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *DesktopServicesHelperServiceName(void)
{
  return "com.apple.DesktopServicesHelper";
}

const void **TCFURLInfo::BootURL(void)::$_0::operator()()
{
  const __CFAllocator *v0;
  CFURLRef v1;
  NSObject *v2;
  __CFError *v3;
  CFErrorRef error;
  uint8_t buf[4];
  __CFError *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  error = 0;
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  TCFURLInfo::BootURL(void)::rootURL = (uint64_t)CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("/"), kCFURLPOSIXPathStyle, 1u);
  v1 = CFURLCreateFileReferenceURL(v0, (CFURLRef)TCFURLInfo::BootURL(void)::rootURL, &error);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&TCFURLInfo::BootURL(void)::rootURL, v1);
  if (error)
  {
    LogObj(5);
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = error;
      *(_DWORD *)buf = 138543362;
      v7 = v3;
      _os_log_impl(&dword_1CBC4A000, v2, OS_LOG_TYPE_ERROR, "Failed to get root URL. %{public}@", buf, 0xCu);

    }
  }
  return TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
}

void sub_1CBCAE738(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&TCFURLInfo::BootURL(void)::rootURL);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **ROSPVolumeID::BootVolumeID(void)::$_0::operator()()
{
  const __CFURL *v0;
  CFTypeRef VolumeIdentifier;
  const void **result;
  TCFURLInfo *v3;

  TCFURLInfo::BootURL(&v3);
  VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier(v3, v0);
  result = TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v3);
  ROSPVolumeID::BootVolumeID(void)::sBootDeviceID = (uint64_t)VolumeIdentifier;
  if (VolumeIdentifier)
    return (const void **)CFRetain(VolumeIdentifier);
  return result;
}

void sub_1CBCAE7BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::AreOnSameVolume(TCFURLInfo ***a1, const __CFURL *a2)
{
  CFTypeRef VolumeIdentifier;
  const __CFURL *v4;
  CFTypeRef v5;
  const void *v6;
  _BOOL8 v7;
  const void *v9;
  CFTypeRef cf1;

  VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier(**a1, a2);
  cf1 = VolumeIdentifier;
  if (VolumeIdentifier)
    CFRetain(VolumeIdentifier);
  v5 = TCFURLInfo::GetVolumeIdentifier(**(TCFURLInfo ***)a2, v4);
  v6 = v5;
  v9 = v5;
  if (v5)
  {
    CFRetain(v5);
    if (cf1)
      v7 = CFEqual(cf1, v6) != 0;
    else
      v7 = 0;
  }
  else
  {
    v7 = cf1 == 0;
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v9);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf1);
  return v7;
}

void sub_1CBCAE870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a9);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::IsOnSystemVolume(TCFURLInfo **this, const __CFURL *a2)
{
  CFTypeRef VolumeIdentifier;
  _BOOL8 v3;
  __int128 v5;

  VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier(*this, a2);
  *((_QWORD *)&v5 + 1) = VolumeIdentifier;
  if (VolumeIdentifier)
    CFRetain(VolumeIdentifier);
  ROSPVolumeID::BootVolumeID(&v5);
  v3 = v5 == 0;
  if (*((_QWORD *)&v5 + 1) && (_QWORD)v5)
    v3 = CFEqual(*((CFTypeRef *)&v5 + 1), (CFTypeRef)v5) != 0;
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v5);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v5 + 1);
  return v3;
}

void sub_1CBCAE908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a9);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::ShowAllExtensions(TCFURLInfo *this)
{
  return TCFURLInfo::gShowAllExtensions;
}

uint64_t TCFURLInfo::GetgidToUse(TCFURLInfo *this)
{
  if (TCFURLInfo::gDSHelperRunning)
    return TCFURLInfo::ggidToUse;
  else
    return getgid();
}

void TCFURLInfo::TCFURLInfo(TCFURLInfo *this)
{
  int v2;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 2) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 3) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_BYTE *)this + 44) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 18) = 0;
  v2 = (*((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16)) & 0xE00100;
  *((_WORD *)this + 38) &= 0x100u;
  *((_BYTE *)this + 78) = BYTE2(v2);
}

void sub_1CBCAE9F0(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;
  const void **v3;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TCFURLInfo::TCFURLInfo(TCFURLInfo *this, const TCFURLInfo *a2)
{
  TString *v4;
  unsigned __int16 *v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = &stru_1E8752DF8;
  v4 = (TString *)((char *)this + 8);
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 2) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 3) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_BYTE *)this + 44) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this, *(CFTypeRef *)a2);
  if (this != a2)
  {
    TString::SetStringRefAsImmutable(v4, *((TString **)a2 + 1));
    TString::SetStringRefAsImmutable((TString *)this + 2, *((TString **)a2 + 2));
    TString::SetStringRefAsImmutable((TString *)this + 3, *((TString **)a2 + 3));
  }
  v6 = *((unsigned __int16 *)a2 + 38);
  v5 = (unsigned __int16 *)((char *)a2 + 76);
  v7 = *((_WORD *)this + 38) & 0xFEFF | (*((unsigned __int8 *)this + 78) << 16) | (((v6 >> 8) & 1) << 8);
  *((_WORD *)this + 38) = *((_WORD *)this + 38) & 0xFEFF | (((v6 >> 8) & 1) << 8);
  v8 = v7 & 0xFFFFFFFE | *v5 & 1;
  *((_WORD *)this + 38) = v8;
  v9 = v8 & 0xFFFFFFFD | (2 * ((*v5 >> 1) & 1));
  *((_WORD *)this + 38) = v9;
  v10 = v9 & 0xFFFFFFFB | (4 * ((*v5 >> 2) & 1));
  *((_WORD *)this + 38) = v10;
  v11 = v10 & 0xFFFFFFF7 | (8 * ((*v5 >> 3) & 1));
  *((_WORD *)this + 38) = v11;
  v12 = v11 & 0xFFFFFFEF | (16 * ((*v5 >> 4) & 1));
  *((_WORD *)this + 38) = v12;
  v13 = v12 & 0xFFFFFFDF | (32 * ((*v5 >> 5) & 1));
  *((_WORD *)this + 38) = v13;
  v14 = v13 & 0xFFFFFFBF | (((*v5 >> 6) & 1) << 6);
  *((_WORD *)this + 38) = v14;
  v15 = v14 & 0xFFFFFF7F | (((*v5 >> 7) & 1) << 7);
  *((_WORD *)this + 38) = v15;
  v16 = v15 & 0xFFFFFDFF | (((*v5 >> 9) & 1) << 9);
  *((_WORD *)this + 38) = v16;
  v17 = *((unsigned __int8 *)v5 + 2) >> 4;
  *((_WORD *)this + 38) = v16;
  v18 = v16 & 0xFFEFFFFF | ((v17 & 1) << 20);
  v19 = HIWORD(v18);
  *((_BYTE *)this + 78) = BYTE2(v18);
  v20 = v18 & 0xFFFFFBFF | (((*v5 >> 10) & 1) << 10);
  *((_BYTE *)this + 78) = v19;
  *((_WORD *)this + 38) = v20;
  v21 = v20 & 0xFFFFF7FF | (((*v5 >> 11) & 1) << 11);
  *((_BYTE *)this + 78) = v19;
  *((_WORD *)this + 38) = v21;
  v22 = v21 & 0xFFFF7FFF | (((*v5 >> 15) & 1) << 15);
  *((_BYTE *)this + 78) = v19;
  *((_WORD *)this + 38) = v22;
  v23 = v22 & 0xFFFFEFFF | (((*v5 >> 12) & 1) << 12);
  *((_BYTE *)this + 78) = v19;
  *((_WORD *)this + 38) = v23;
  v24 = v23 & 0xFFFFDFFF | (((*v5 >> 13) & 1) << 13);
  *((_BYTE *)this + 78) = v19;
  *((_WORD *)this + 38) = v24;
  v25 = v24 & 0xFFFFBFFF | (((*v5 >> 14) & 1) << 14);
  *((_BYTE *)this + 78) = v19;
  *((_WORD *)this + 38) = v25;
  v26 = v25 & 0xFFFEFFFF | ((v5[1] & 1) << 16);
  *((_WORD *)this + 38) = v25;
  *((_BYTE *)this + 78) = BYTE2(v26);
  v27 = v26 & 0xFFFDFFFF | (((*((unsigned __int8 *)v5 + 2) >> 1) & 1) << 17);
  *((_WORD *)this + 38) = v25;
  *((_BYTE *)this + 78) = BYTE2(v27);
  v28 = v27 & 0xFFFBFFFF | (((*((unsigned __int8 *)v5 + 2) >> 2) & 1) << 18);
  *((_WORD *)this + 38) = v25;
  *((_BYTE *)this + 78) = BYTE2(v28);
  v29 = v28 & 0xFFF7FFFF | (((*((unsigned __int8 *)v5 + 2) >> 3) & 1) << 19);
  *((_WORD *)this + 38) = v25;
  *((_BYTE *)this + 78) = BYTE2(v29);
  *((_DWORD *)this + 18) = *((_DWORD *)v5 - 1);
}

void sub_1CBCAEC9C(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;
  const void **v3;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetObjectIdentifier(TCFURLInfo *this)
{
  TCFURLInfo::CopyPropertyValues(*(_QWORD *)this);
  return 0;
}

uint64_t TCFURLInfo::PathAsCStr(TCFURLInfo *this)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  int FileSystemRepresentation;
  char *begin;
  size_t v7;
  std::vector<char>::pointer end;
  char *v9;
  char *v10;
  uint64_t v11;
  std::vector<char> v13;

  {
    TCFURLInfo::PathAsCStr(void)const::localLock = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&TCFURLInfo::PathAsCStr(void)const::localLock);
  v3 = *((_QWORD *)this + 6);
  v4 = *((_QWORD *)this + 7);
  if (v3 == v4)
  {
    v4 = *((_QWORD *)this + 6);
    if (*(_QWORD *)this)
    {
      std::vector<char>::vector(&v13, 0x400uLL);
      FileSystemRepresentation = TCFURLInfo::GetFileSystemRepresentation(*(TCFURLInfo **)this, (const __CFURL *)1, (UInt8 *)v13.__begin_, (unsigned __int8 *)(v13.__end_ - v13.__begin_));
      begin = v13.__begin_;
      if (FileSystemRepresentation)
      {
        v7 = strlen(v13.__begin_);
        if (v7 + 1 <= v13.__end_ - v13.__begin_)
        {
          end = &v13.__begin_[v7 + 1];
          if (v7 + 1 >= v13.__end_ - v13.__begin_)
            end = v13.__end_;
        }
        else
        {
          std::vector<char>::__append(&v13, v7 + 1 - (v13.__end_ - v13.__begin_));
          begin = v13.__begin_;
          end = v13.__end_;
        }
        v9 = (char *)*((_QWORD *)this + 6);
        *((_QWORD *)this + 6) = begin;
        *((_QWORD *)this + 7) = end;
        v10 = (char *)*((_QWORD *)this + 8);
        *((_QWORD *)this + 8) = v13.__end_cap_.__value_;
        v13.__begin_ = v9;
        v13.__end_cap_.__value_ = v10;
        begin = v9;
      }
      if (begin)
      {
        v13.__end_ = begin;
        operator delete(begin);
      }
      v3 = *((_QWORD *)this + 6);
      v4 = *((_QWORD *)this + 7);
    }
  }
  if (v3 == v4)
    v11 = 0;
  else
    v11 = v3;
  os_unfair_lock_unlock((os_unfair_lock_t)&TCFURLInfo::PathAsCStr(void)const::localLock);
  return v11;
}

void sub_1CBCAEEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&TCFURLInfo::PathAsCStr(void)const::localLock);
  _Unwind_Resume(a1);
}

TString *TCFURLInfo::Path@<X0>(TCFURLInfo *this@<X0>, TString *a2@<X8>)
{
  const char *v3;

  v3 = (const char *)TCFURLInfo::PathAsCStr(this);
  if (v3)
    return TString::TString(a2, v3);
  else
    return TString::TString(a2, "", 0);
}

uint64_t TCFURLInfo::CopyExtendedAttribute(TCFURLInfo *this, CFStringRef theString, const __CFString *a3, CFDataRef *a4, const __CFData **a5)
{
  uint64_t v5;
  int v8;
  const char *CStringPtr;
  ssize_t v11;
  unint64_t v12;
  std::vector<char>::pointer begin;
  std::vector<char>::pointer end;
  int *v16;
  const char *v17;
  std::vector<char> bytes;
  char buffer[127];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  v5 = 4294959224;
  if (!this || !theString)
    return v5;
  v8 = (int)a3;
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(theString, buffer, 127, 0x8000100u))
      CStringPtr = 0;
  }
  std::vector<char>::vector(&bytes, 0x1000uLL);
  if (!strcmp("com.apple.ResourceFork", CStringPtr))
  {
LABEL_9:
    v12 = getxattr((const char *)this, CStringPtr, 0, 0, 0, v8);
    if ((v12 & 0x8000000000000000) == 0)
    {
      begin = bytes.__begin_;
      end = bytes.__end_;
      if (v12 <= bytes.__end_ - bytes.__begin_)
      {
        if (v12 < bytes.__end_ - bytes.__begin_)
        {
          end = &bytes.__begin_[v12];
          bytes.__end_ = &bytes.__begin_[v12];
        }
      }
      else
      {
        std::vector<char>::__append(&bytes, v12 - (bytes.__end_ - bytes.__begin_));
        begin = bytes.__begin_;
        end = bytes.__end_;
      }
      v11 = getxattr((const char *)this, CStringPtr, begin, end - begin, 0, v8);
      if ((v11 & 0x8000000000000000) == 0)
        goto LABEL_15;
    }
LABEL_19:
    v16 = __error();
    v5 = *v16;
    if ((_DWORD)v5)
    {
      if ((_DWORD)v5 == 93)
      {
        v5 = 4294965869;
      }
      else if ((_DWORD)v5 == 45)
      {
        v5 = 4294965870;
      }
      else
      {
        v5 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v16, 0, v17);
      }
    }
    goto LABEL_16;
  }
  v11 = getxattr((const char *)this, CStringPtr, bytes.__begin_, bytes.__end_ - bytes.__begin_, 0, v8);
  if (v11 < 0)
  {
    if (*__error() != 34)
      goto LABEL_19;
    goto LABEL_9;
  }
LABEL_15:
  v5 = 0;
  *a4 = CFDataCreate(0, (const UInt8 *)bytes.__begin_, v11);
LABEL_16:
  if (bytes.__begin_)
  {
    bytes.__end_ = bytes.__begin_;
    operator delete(bytes.__begin_);
  }
  return v5;
}

void sub_1CBCAF100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFIndex TCFURLInfo::CheckPrefetchState(CFIndex result, int a2)
{
  int v2;

  v2 = *(_DWORD *)(result + 72);
  if (v2 < a2 || v2 == 0)
    return TCFURLInfo::FetchProperties((const void **)result, 1);
  return result;
}

CFIndex TCFURLInfo::FetchProperties(const void **this, int a2)
{
  const __CFURL *v2;
  const __CFArray *CopyItemRequestedPropertyKeys;
  TCFURLInfo *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  const __CFString *v11;
  CFIndex v12;
  __CFError *v13;
  const __CFString *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  TString *v22;
  unsigned __int8 v23;
  unsigned int NumericalProperty;
  char *v25;
  int v26;
  unsigned int v27;
  CFTypeRef cf;
  CFErrorRef v30;
  const void *propertyValueTypeRefPtr;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  CFDictionaryRef v36;
  CFErrorRef error;
  _BYTE v38[128];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFURL *)*this;
  if (!*this)
    return 4294959236;
  error = 0;
  if ((a2 & 1) != 0)
  {
    CopyItemRequestedPropertyKeys = (const __CFArray *)TCFURLInfo::GetCopyItemRequestedPropertyKeys((TCFURLInfo *)this);
    v36 = CFURLCopyResourcePropertiesForKeys(v2, CopyItemRequestedPropertyKeys, &error);
    if (error)
    {
      CFRelease(error);
      error = 0;
      v32 = 0u;
      v33 = 0u;
      v34 = 0u;
      v35 = 0u;
      v7 = (id)TCFURLInfo::GetCopyItemRequestedPropertyKeys(v6);
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v32, v38, 16);
      if (v8)
      {
        v9 = *(_QWORD *)v33;
        do
        {
          for (i = 0; i != v8; ++i)
          {
            if (*(_QWORD *)v33 != v9)
              objc_enumerationMutation(v7);
            v11 = *(const __CFString **)(*((_QWORD *)&v32 + 1) + 8 * i);
            v30 = 0;
            propertyValueTypeRefPtr = 0;
            CFURLCopyResourcePropertyForKey((CFURLRef)*this, v11, &propertyValueTypeRefPtr, &v30);
            TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v30);
            TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&propertyValueTypeRefPtr);
          }
          v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v32, v38, 16);
        }
        while (v8);
      }

    }
  }
  else
  {
    v36 = 0;
  }
  propertyValueTypeRefPtr = 0;
  if (_CFURLGetResourcePropertyFlags())
  {
    v15 = propertyValueTypeRefPtr;
    v16 = (propertyValueTypeRefPtr >> 1) & 0x7FFFFF;
    v17 = *((_WORD *)this + 38) & 0xFFFC | (*((unsigned __int8 *)this + 78) << 16) & 0xFFFEFFFC | ((propertyValueTypeRefPtr & 1) << 16) | ((propertyValueTypeRefPtr & 0xFFFFFE) >> 1) & 2 | ((propertyValueTypeRefPtr & 0xFFFFFE) >> 1) & 1;
    *((_BYTE *)this + 78) = (*((_WORD *)this + 38) & 0xFFFC | (*((unsigned __int8 *)this + 78) << 16) & 0xFFFEFFFF | ((propertyValueTypeRefPtr & 1) << 16)) >> 16;
    *((_WORD *)this + 38) = v17;
    if ((v16 & 1) != 0)
    {
      if (TCFURLInfo::GetBooleanProperty((TCFURLInfo *)*this, (const __CFString *)*MEMORY[0x1E0C9B508], v14))v18 = 4;
      else
        v18 = 0;
      v17 = *((_WORD *)this + 38) & 0xFFFB | (*((unsigned __int8 *)this + 78) << 16) | v18;
      *((_WORD *)this + 38) = *((_WORD *)this + 38) & 0xFFFB | v18;
      v15 = propertyValueTypeRefPtr;
    }
    v19 = (v15 >> 2) & 0x10 | v17 & 0xFFFD7F4F | (((v15 >> 5) & 1) << 17);
    v20 = HIWORD(v19);
    v21 = (v19 & 0xFFFF7F7F | (((v15 >> 3) & 1) << 7) & 0xFFFF7FFF | (v15 >> 2) & 0x20 | (((v15 >> 10) & 1) << 15)) ^ 0x20;
    *((_BYTE *)this + 78) = v20;
    *((_WORD *)this + 38) = v21;
    *((_DWORD *)this + 18) = 1;
    if (a2)
    {
      *((_BYTE *)this + 78) = BYTE2(v21);
      *((_WORD *)this + 38) = (v15 >> 2) & 0x40 | v15 & 0x7000 | (v15 >> 6) & 8 | v21 & 0x8FB7;
      *((_DWORD *)this + 18) = 2;
    }
    v30 = 0;
    if (CFURLCopyResourcePropertyForKey((CFURLRef)*this, (CFStringRef)*MEMORY[0x1E0C9B5A0], &v30, &error))
    {
      v22 = (TString *)v30;
      cf = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)&cf, v22);
      if (this + 1 != &cf)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(this + 1, &cf);
        CFRetain(&stru_1E8752DF8);
        if (cf)
          CFRelease(cf);
        cf = &stru_1E8752DF8;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v30);
  }
  v23 = atomic_load(sUseFileProviderFramework);
  if ((v23 & 1) != 0)
  {
    NumericalProperty = TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, (const __CFString *)*MEMORY[0x1E0C9AC48], v14);
    v26 = *((unsigned __int16 *)this + 38);
    v25 = (char *)this + 76;
    v27 = (v26 | (v25[2] << 16)) & 0xFFFBFFFF | (NumericalProperty >> 12) & 0x40000;
    *(_WORD *)v25 = v26;
    v25[2] = BYTE2(v27);
  }
  v12 = TCFURLInfo::TranslateCFError(error, v13);
  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&v36);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
  return v12;
}

void sub_1CBCAF4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  void *v14;
  const void *v16;
  va_list va;
  va_list va1;

  va_start(va1, a14);
  va_start(va, a14);
  v16 = va_arg(va1, const void *);

  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetCopyItemRequestedPropertyKeys(TCFURLInfo *this)
{
  unsigned __int8 v1;
  TCFURLInfo *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::copyKeys = (uint64_t)TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::$_0::operator()(v3);
    }
  }
  return TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::copyKeys;
}

void sub_1CBCAF5C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t TCFURLInfo::IsDataless(const __CFURL **this, uint64_t a2, const __CFString *a3)
{
  return ((unint64_t)TCFURLInfo::GetNumericalProperty(*this, (const __CFString *)*MEMORY[0x1E0C9AC48], a3) >> 30) & 1;
}

CFIndex TCFURLInfo::TranslateCFError(TCFURLInfo *this, __CFError *a2)
{
  TCFURLInfo *v2;
  TString *Domain;
  __CFError *v4;
  CFIndex v5;
  CFIndex v6;
  const __CFDictionary *v7;
  const void *Value;
  TCFURLInfo *v9;
  __CFError *v10;
  __CFError *v11;
  void *v12;
  NSObject *v13;
  TCFURLInfo *v14;
  char v15;
  unsigned __int8 v16;
  NSObject *v17;
  NSObject *v18;
  NSObject **v19;
  NSObject **v20;
  void *v21;
  TString v23;
  _BYTE buf[12];
  __int16 v25;
  TCFURLInfo *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    v2 = this;
    Domain = (TString *)CFErrorGetDomain(v2);
    v23.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v23, Domain);
    FileProviderErrorDomain((TString *)buf);
    LODWORD(Domain) = CFEqual(v23.fString.fRef, *(CFTypeRef *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    if ((_DWORD)Domain)
    {
      v5 = TCFURLInfo::TranslateFileProviderError(v2, v4);
    }
    else
    {
      v7 = CFErrorCopyUserInfo(v2);
      *(_QWORD *)buf = v7;
      if (v7)
      {
        Value = CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E0C9B000]);
        v9 = (TCFURLInfo *)static_cf_cast<__CFString const*,void const*>(Value);
        if (v9)
        {
          v6 = TCFURLInfo::OSStatusFromCFErrorShallow(v9, v10);
          TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)buf);
LABEL_10:
          if (operator==((void **)&v23.fString.fRef, (void *)*MEMORY[0x1E0CB28A8])
            && -[TCFURLInfo code](v2, "code") == 260)
          {
            -[TCFURLInfo userInfo](v2, "userInfo");
            v12 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v12, "objectForKeyedSubscript:", *MEMORY[0x1E0CB3308]);
            v13 = objc_claimAutoreleasedReturnValue();

            if (v13)
            {
              -[NSObject lastPathComponent](v13, "lastPathComponent");
              v14 = (TCFURLInfo *)objc_claimAutoreleasedReturnValue();
              TCFURLInfo::GetPropertyStoreName(v14);
              v15 = operator==((void **)&TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName, v14);

            }
            else
            {
              v15 = 1;
            }
            if ((v16 & 1) == 0
            {
              TCFURLInfo::TranslateCFError(__CFError *)::$_0::operator()();
            }
            if ((v15 & 1) != 0)
            {
              v17 = v13;
LABEL_26:

              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
              return v6;
            }
            v18 = v13;
            v19 = (NSObject **)TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories;
            v20 = *(NSObject ***)algn_1EF9B97D8;
            v17 = v18;
            while (1)
            {
              if (v19 == v20)
              {

                goto LABEL_26;
              }
              if ((IsEqual(v17, *v19) & 1) != 0)
                break;
              ++v19;
            }

          }
          LogObj(2);
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v6);
            v21 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v21;
            v25 = 2112;
            v26 = v2;
            _os_log_impl(&dword_1CBC4A000, v17, OS_LOG_TYPE_ERROR, "TCFURLInfo::TranslateCFError -- status: %{public}@, CFError = %@", buf, 0x16u);

          }
          goto LABEL_26;
        }
      }
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)buf);
      v5 = TCFURLInfo::OSStatusFromCFErrorShallow(v2, v11);
    }
    v6 = v5;
    goto LABEL_10;
  }
  return 0;
}

void sub_1CBCAF8B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::ForceNameFetch(const void **this)
{
  const __CFURL *v2;
  CFStringRef PathComponent;
  TString *v4;
  CFTypeRef cf;
  CFStringRef v7;

  v2 = (const __CFURL *)*this;
  if (v2)
  {
    PathComponent = CFURLCopyLastPathComponent(v2);
    v7 = PathComponent;
    if (PathComponent)
    {
      v4 = (TString *)PathComponent;
      cf = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)&cf, v4);
      if (this + 1 != &cf)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(this + 1, &cf);
        CFRetain(&stru_1E8752DF8);
        if (cf)
          CFRelease(cf);
        cf = &stru_1E8752DF8;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
  }
  else
  {
    v7 = 0;
  }
  return TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v7);
}

void sub_1CBCAFA28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&a10);
  _Unwind_Resume(a1);
}

CFIndex TCFURLInfo::Initialize(TString *this, const __CFURL *a2, int a3, int a4)
{
  TString *v8;
  int v9;

  v8 = this + 1;
  TString::SetStringRefAsImmutable(this + 1, 0);
  TString::SetFromUTF8(v8, (const UInt8 *)"", 0);
  TString::SetStringRefAsImmutable(this + 2, 0);
  TString::SetFromUTF8(this + 2, (const UInt8 *)"", 0);
  TString::SetStringRefAsImmutable(this + 3, 0);
  TString::SetFromUTF8(this + 3, (const UInt8 *)"", 0);
  v9 = WORD2(this[9].fString.fRef) & 0xFEFF | (BYTE6(this[9].fString.fRef) << 16);
  WORD2(this[9].fString.fRef) &= ~0x100u;
  BYTE6(this[9].fString.fRef) = BYTE2(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, a2);
  if (this->fString.fRef && a3)
    return TCFURLInfo::FetchProperties((const void **)&this->fString.fRef, a4);
  else
    return 0;
}

CFIndex TCFURLInfo::Initialize(TString *this, const char *__s)
{
  CFIndex v4;
  CFURLRef v5;
  CFIndex v6;
  CFURLRef v8;

  if (!__s)
    return 4294959224;
  v4 = strlen(__s);
  v5 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__s, v4, 0);
  v8 = v5;
  if (v5)
    v6 = TCFURLInfo::Initialize(this, v5, 1, 1);
  else
    v6 = 4294959238;
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v8);
  return v6;
}

void sub_1CBCAFBC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetSizerPropertyKeys(TCFURLInfo *this)
{
  unsigned __int8 v1;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  _QWORD v24[23];

  v24[21] = *MEMORY[0x1E0C80C00];
  {
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B5A0]);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24[0] = v23;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC58]);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v24[1] = v22;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC40]);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v24[2] = v21;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC60]);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v24[3] = v20;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC88]);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v24[4] = v19;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4A8]);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v24[5] = v18;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B420]);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v24[6] = v17;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B570]);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v24[7] = v16;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4F8]);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v24[8] = v15;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B548]);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v24[9] = v14;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B538]);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v24[10] = v13;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACD8]);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v24[11] = v12;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACB0]);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v24[12] = v3;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACA8]);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v24[13] = v4;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACD0]);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v24[14] = v5;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B550]);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v24[15] = v6;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B530]);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v24[16] = v7;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4E0]);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v24[17] = v8;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B520]);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v24[18] = v9;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4D0]);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v24[19] = v10;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AD38]);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v24[20] = v11;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v24, 21);
    TCFURLInfo::GetSizerPropertyKeys(void)::sizerKeys = objc_claimAutoreleasedReturnValue();

  }
  return TCFURLInfo::GetSizerPropertyKeys(void)::sizerKeys;
}

void sub_1CBCAFF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

__CFArray *TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::$_0::operator()(TCFURLInfo *a1)
{
  const __CFAllocator *v1;
  const __CFArray *BasicInfoPropertyKeys;
  __CFArray *MutableCopy;

  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  BasicInfoPropertyKeys = (const __CFArray *)TCFURLInfo::GetBasicInfoPropertyKeys(a1);
  MutableCopy = CFArrayCreateMutableCopy(v1, 0, BasicInfoPropertyKeys);
  CFArrayAppendValue(MutableCopy, (const void *)*MEMORY[0x1E0C9B4A0]);
  return MutableCopy;
}

uint64_t TCFURLInfo::GetBasicInfoPropertyKeys(TCFURLInfo *this)
{
  unsigned __int8 v1;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  _QWORD v40[41];

  v40[39] = *MEMORY[0x1E0C80C00];
  {
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B5A0]);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    v40[0] = v39;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ADD0]);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    v40[1] = v38;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC50]);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    v40[2] = v37;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC58]);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    v40[3] = v36;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC40]);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    v40[4] = v35;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC60]);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    v40[5] = v34;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC88]);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    v40[6] = v33;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4A8]);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v40[7] = v32;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B420]);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    v40[8] = v31;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B408]);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v40[9] = v30;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B400]);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v40[10] = v29;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B3B8]);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v40[11] = v28;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B3C0]);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v40[12] = v27;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B568]);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    v40[13] = v26;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B570]);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v40[14] = v25;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4C8]);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    v40[15] = v24;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B550]);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v40[16] = v23;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4F8]);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v40[17] = v22;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B548]);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v40[18] = v21;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B538]);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v40[19] = v20;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACD8]);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v40[20] = v19;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACB0]);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v40[21] = v18;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACA8]);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v40[22] = v17;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ACD0]);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v40[23] = v16;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B530]);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v40[24] = v15;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4E0]);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v40[25] = v3;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B520]);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v40[26] = v4;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4D0]);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v40[27] = v5;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4D8]);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v40[28] = v6;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B518]);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v40[29] = v7;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B558]);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v40[30] = v8;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9B4F0]);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v40[31] = v9;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9AC48]);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v40[32] = v10;
    NodeEventRefFromNodeEvent(MEMORY[0x1E0C9ADB8]);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = *MEMORY[0x1E0C99938];
    v40[33] = v11;
    v40[34] = v12;
    v13 = *MEMORY[0x1E0C99908];
    v40[35] = *MEMORY[0x1E0C99A88];
    v40[36] = v13;
    v14 = *MEMORY[0x1E0C99A80];
    v40[37] = *MEMORY[0x1E0C99A20];
    v40[38] = v14;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v40, 39);
    TCFURLInfo::GetBasicInfoPropertyKeys(void)::basicKeys = objc_claimAutoreleasedReturnValue();

  }
  return TCFURLInfo::GetBasicInfoPropertyKeys(void)::basicKeys;
}

void sub_1CBCB0668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33)
{
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;

  _Unwind_Resume(a1);
}

void TCFURLInfo::Name(TCFURLInfo *this@<X0>, TString *a2@<X8>)
{
  if (!CFStringGetLength(*((CFStringRef *)this + 1)) && !*((_DWORD *)this + 18))
    TCFURLInfo::ForceNameFetch((const void **)this);
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 1));
}

void sub_1CBCB08DC(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TCFURLInfo::DisplayName(TString **this@<X0>, TString *a2@<X8>)
{
  int v4;
  __int16 v5;
  TString *v6;
  CFStringRef *v7;
  CFIndex Length;
  CFIndex v9;
  const void **v10;
  CFTypeRef cf;
  CFTypeRef cf1;

  v4 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
  if ((*((_WORD *)this + 38) & 0x100) != 0)
  {
    if (CFStringGetLength((CFStringRef)this[2]))
    {
      a2->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a2, this[2]);
      return;
    }
    v4 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
  }
  if ((v4 & 0x100) != 0)
    goto LABEL_14;
  LOBYTE(v5) = v4;
  *((_BYTE *)this + 78) = BYTE2(v4);
  *((_WORD *)this + 38) = v4 | 0x100;
  if (!*this)
    goto LABEL_14;
  if ((v4 & 0x40001) != 0)
  {
    TCFURLInfo::StringProperty((TCFURLInfo *)*this, (const __CFString *)*MEMORY[0x1E0C9B580], (TString *)&cf1);
    if (CFEqual(cf1, this[1]))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
LABEL_14:
      a2->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a2, this[1]);
      return;
    }
    v6 = (TString *)(this + 2);
    if (v6 != (TString *)&cf1)
      TString::SetStringRefAsImmutable(v6, (TString *)cf1);
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)v6->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  }
  else
  {
    if (TCFURLInfo::gShowAllExtensions)
      goto LABEL_14;
    if (*((int *)this + 18) <= 1)
    {
      TCFURLInfo::FetchProperties((const void **)this, 1);
      v5 = *((_WORD *)this + 38);
    }
    if ((v5 & 0x40) == 0)
      goto LABEL_14;
    v7 = (CFStringRef *)(this + 1);
    FileSuffix((const TString *)this + 1, (TString *)&cf1);
    if (CFStringGetLength((CFStringRef)cf1))
    {
      Length = CFStringGetLength(*v7);
      v9 = CFStringGetLength((CFStringRef)cf1);
      TString::SubString((TString *)this + 1, 0, Length - v9, (TString *)&cf);
    }
    else
    {
      cf = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)&cf, (TString *)*v7);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    v10 = (const void **)(this + 2);
    if (v10 != &cf)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(v10, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)*v10);
  }
}

void sub_1CBCB0B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetType(CFURLRef *this)
{
  uint64_t v1;
  const __CFData *propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  if (CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E0C9AC60], &propertyValueTypeRefPtr, 0)
    && propertyValueTypeRefPtr
    && CFDataGetLength(propertyValueTypeRefPtr) == 32)
  {
    v1 = *(unsigned int *)CFDataGetBytePtr(propertyValueTypeRefPtr);
  }
  else
  {
    v1 = 0;
  }
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  return v1;
}

void sub_1CBCB0BEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetInode(const __CFURL **this)
{
  const __CFURL *v1;
  uint64_t v2;
  CFNumberRef number;
  uint64_t valuePtr;

  number = 0;
  valuePtr = 0;
  v1 = *this;
  if (v1 && CFURLCopyResourcePropertyForKey(v1, (CFStringRef)*MEMORY[0x1E0C9B440], &number, 0) && number)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
    v2 = valuePtr;
  }
  else
  {
    v2 = 0;
  }
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&number);
  return v2;
}

void sub_1CBCB0C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

void TCFURLInfo::VolumeUUID(const __CFURL **this@<X0>, TString *a2@<X8>)
{
  const __CFURL *v3;
  TString *v4;
  TString *propertyValueTypeRefPtr;

  v3 = *this;
  propertyValueTypeRefPtr = 0;
  if (v3)
  {
    CFURLCopyResourcePropertyForKey(v3, (CFStringRef)*MEMORY[0x1E0C9B7F0], &propertyValueTypeRefPtr, 0);
    v4 = propertyValueTypeRefPtr;
  }
  else
  {
    v4 = 0;
  }
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, v4);
}

void sub_1CBCB0D00(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

double TCFURLInfo::GetCreationDate(CFURLRef *this)
{
  double v1;
  const void *v3;
  const void *propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E0C9B408], &propertyValueTypeRefPtr, 0);
  v3 = propertyValueTypeRefPtr;
  if (propertyValueTypeRefPtr)
    v1 = MEMORY[0x1D17A4A1C](propertyValueTypeRefPtr);
  else
    v1 = 0.0;
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&v3);
  return v1;
}

void sub_1CBCB0D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetOwner(CFURLRef *this)
{
  uint64_t v1;
  CFFileSecurityRef fileSec;
  uid_t owner;

  owner = 0;
  fileSec = 0;
  if (CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E0C9B4A0], &fileSec, 0) && fileSec)
  {
    CFFileSecurityGetOwner(fileSec, &owner);
    v1 = owner;
  }
  else
  {
    v1 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
  return v1;
}

void sub_1CBCB0E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetUserGroups(CFURLRef *this)
{
  uint64_t v1;
  CFFileSecurityRef fileSec;
  gid_t group;

  group = 0;
  fileSec = 0;
  if (CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E0C9B4A0], &fileSec, 0) && fileSec)
  {
    CFFileSecurityGetGroup(fileSec, &group);
    v1 = group;
  }
  else
  {
    v1 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
  return v1;
}

void sub_1CBCB0E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

TCFURLInfo *TCFURLInfo::TranslatePOSIXError(TCFURLInfo *this, const char *a2, const char *a3)
{
  TCFURLInfo *v4;
  NSObject *v5;
  void *v6;
  TString v8;
  uint8_t buf[4];
  int v10;
  __int16 v11;
  void *v12;
  uint64_t v13;

  v4 = this;
  v13 = *MEMORY[0x1E0C80C00];
  if ((int)this > -2)
  {
    if ((_DWORD)this == -1)
      this = (TCFURLInfo *)*__error();
    return TCFURLInfo::TranslateRawPOSIXError(this, a2, a3);
  }
  else
  {
    if (a2)
    {
      LogObj(5);
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        TString::TString(&v8, a2);
        SanitizedPath(&v8);
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 67109378;
        v10 = (int)v4;
        v11 = 2114;
        v12 = v6;
        _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_ERROR, "MacOS error %d for %{public}@", buf, 0x12u);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);

      }
    }
    return v4;
  }
}

void sub_1CBCB0FF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

id TCFURLInfo::GetNumberProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  void *v3;
  void *propertyValueTypeRefPtr;

  if (!this)
    goto LABEL_6;
  propertyValueTypeRefPtr = 0;
  if (!CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0)
    || (v3 = propertyValueTypeRefPtr) == 0)
  {
    TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
LABEL_6:
    v3 = 0;
    return v3;
  }
  propertyValueTypeRefPtr = 0;
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  return v3;
}

void sub_1CBCB107C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFURL *TCFURLInfo::GetNumericalProperty(const __CFURL **this, const __CFString *a2, const __CFString *a3)
{
  return TCFURLInfo::GetNumericalProperty(*this, a2, a3);
}

uint64_t TCFURLInfo::IsClone(const void **this, unint64_t *a2, BOOL *a3)
{
  uint64_t v6;
  const char *v7;
  int v8;
  char v9;
  BOOL v10;
  uint64_t v12;
  unint64_t v13;
  CFNumberRef number;
  void *propertyValueTypeRefPtr;

  if (a3)
    *a3 = 0;
  if (a2)
    *a2 = 0;
  if (*((int *)this + 18) <= 0)
    TCFURLInfo::FetchProperties(this, 1);
  if (((*((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16)) & 0x10000) == 0)
    return 0;
  propertyValueTypeRefPtr = 0;
  if (CFURLCopyResourcePropertyForKey((CFURLRef)*this, (CFStringRef)*MEMORY[0x1E0C9B598], &propertyValueTypeRefPtr, 0)&& (objc_msgSend(propertyValueTypeRefPtr, "BOOLValue") & 1) != 0)
  {
    number = 0;
    if (a3 || !CFURLCopyResourcePropertyForKey((CFURLRef)*this, (CFStringRef)*MEMORY[0x1E0C9B428], &number, 0))
    {
      v7 = (const char *)TCFURLInfo::PathAsCStr((TCFURLInfo *)this);
      if (v7)
      {
        v12 = 0;
        v13 = 0;
        v8 = fsctl(v7, 0x40104A0EuLL, &v12, 0);
        v9 = v12;
        v10 = v8 < 0 || v12 == 0;
        v6 = !v10;
        if (!v10)
        {
          if (a2)
            *a2 = v13;
          if (a3 && (v9 & 2) != 0)
            *a3 = 1;
        }
      }
      else
      {
        v6 = 0;
      }
    }
    else
    {
      if (a2)
        CFNumberGetValue(number, kCFNumberLongLongType, a2);
      v6 = 1;
    }
    TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&number);
  }
  else
  {
    v6 = 0;
  }
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  return v6;
}

void sub_1CBCB11F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::FileSystemRepresentationRelativeToSource(TCFURLInfo **this, const TString *a2, TString *a3)
{
  _BOOL8 v6;
  CFIndex Length;
  CFTypeRef cf;
  __CFString *v10;
  TString v11;
  CFStringRef theString;

  TString::SetStringRefAsImmutable(a3, 0);
  TCFURLInfo::FileSystemRepresentation(*this, (const __CFURL *)1, (TString *)&theString);
  if (CFStringGetLength(theString))
  {
    cf = a2;
    v10 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&v10, (TString *)theString);
    v11.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v11, (TString *)v10);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10);
    v6 = TString::BeginsWith(&v11, a2);
    if (v6)
    {
      Length = CFStringGetLength(a2->fString.fRef);
      TString::SubStringFrom(&v11, Length, (TString *)&cf);
      if (&cf != (CFTypeRef *)a3)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a3->fString.fRef, &cf);
        CFRetain(&stru_1E8752DF8);
        if (cf)
          CFRelease(cf);
        cf = &stru_1E8752DF8;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
  }
  else
  {
    v6 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v6;
}

void sub_1CBCB1358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::CreateCFURLInfoWithFileSystemRepresentationRelativeToBase(TCFURLInfo *a1, const TString *a2, const __CFString **a3, TString **a4)
{
  const __CFString *v7;
  __CFString *MutableCopy;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  CFTypeRef v12;
  const void *v13;
  CFTypeRef v14;
  const __CFString *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  __int128 v24;
  TString v25;
  CFTypeRef cf;

  TCFURLInfo::Path(a1, (TString *)&v24);
  v7 = *a3;
  v25.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v7);
  CFRelease(&stru_1E8752DF8);
  v25.fString.fRef = MutableCopy;
  TString::Append(&v25, a2);
  AppendPath((const TString *)&v24, &v25, (TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v25.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v24);
  v24 = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a4, &v24);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
  if (*((_QWORD *)&v24 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (cf && (v12 = CFRetain(cf), (v13 = static_cf_cast<__CFString const*,void const*>(v12)) != 0))
  {
    v14 = CFAutorelease(v13);
    v15 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v14);
  }
  else
  {
    v15 = 0;
  }
  v25.fString.fRef = (__CFString *)CFURLCreateWithFileSystemPath(0, v15, kCFURLPOSIXPathStyle, 1u);
  if (v25.fString.fRef)
  {
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v24);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a4, &v24);
    v16 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
    if (*((_QWORD *)&v24 + 1))
    {
      v17 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    if (!TCFURLInfo::Initialize(*a4, (const __CFURL *)v25.fString.fRef, 1, 1))
    {
      v22 = 0;
      goto LABEL_24;
    }
    v24 = 0uLL;
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a4, &v24);
    v19 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
    if (*((_QWORD *)&v24 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  v22 = 4294959236;
LABEL_24:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v25.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  return v22;
}

void sub_1CBCB15A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  const void *v5;
  va_list va;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, const void *);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetVolumeInfoRecord(CFURLRef *a1, _QWORD *a2)
{
  CFURLRef v3;
  uint64_t VolumeInfoRecord;
  CFURLRef v6;

  if (*a1)
    v3 = CFURLCreateFilePathURL(0, *a1, 0);
  else
    v3 = 0;
  v6 = v3;
  VolumeInfoRecord = TCFURLInfo::GetVolumeInfoRecord(v3, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v6);
  return VolumeInfoRecord;
}

void sub_1CBCB164C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

CFComparisonResult TCFURLInfo::CheckDestinationModificationDates(CFURLRef *a1, CFURLRef **a2, char a3)
{
  const __CFString *v5;
  const __CFDate *v6;
  CFURLRef *v7;
  const __CFDate *v8;
  int v9;
  CFComparisonResult v10;
  double v11;
  const __CFDate *v13;
  const __CFDate *v14;
  const __CFDate *propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  v5 = (const __CFString *)*MEMORY[0x1E0C9B400];
  CFURLCopyResourcePropertyForKey(*a1, (CFStringRef)*MEMORY[0x1E0C9B400], &propertyValueTypeRefPtr, 0);
  v6 = propertyValueTypeRefPtr;
  v14 = propertyValueTypeRefPtr;
  v7 = *a2;
  if (*a2)
  {
    propertyValueTypeRefPtr = 0;
    CFURLCopyResourcePropertyForKey(*v7, v5, &propertyValueTypeRefPtr, 0);
    v6 = v14;
    v8 = propertyValueTypeRefPtr;
  }
  else
  {
    v8 = 0;
  }
  v13 = v8;
  v9 = v8 != 0;
  if (v6)
    ++v9;
  if (!v9)
    goto LABEL_17;
  if (v9 != 1)
  {
    v10 = CFDateCompare(v6, v8, 0);
    if ((a3 & 1) != 0)
      goto LABEL_18;
    goto LABEL_14;
  }
  if (v6)
    v10 = kCFCompareGreaterThan;
  else
    v10 = kCFCompareLessThan;
  if ((a3 & 1) == 0)
  {
LABEL_14:
    if (v10 != kCFCompareGreaterThan)
      goto LABEL_18;
    v11 = MEMORY[0x1D17A4A1C](v14);
    if (floor(v11) != MEMORY[0x1D17A4A1C](v13))
    {
      v10 = kCFCompareGreaterThan;
      goto LABEL_18;
    }
LABEL_17:
    v10 = kCFCompareEqualTo;
  }
LABEL_18:
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)&v13);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)&v14);
  return v10;
}

void sub_1CBCB177C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::XattrValuesEqual(TCFURLInfo *this, TCFURLInfo *a2, TCFURLInfo *a3, CFStringRef theString, __CFString *a5)
{
  int v8;
  const __CFData **v9;
  int v10;
  _BOOL8 v11;
  const void *v13;
  const void *v14;

  v13 = 0;
  v14 = 0;
  v8 = TCFURLInfo::CopyExtendedAttribute(a2, theString, a5, (CFDataRef *)&v14, (const __CFData **)a5);
  v10 = TCFURLInfo::CopyExtendedAttribute(a3, theString, a5, (CFDataRef *)&v13, v9);
  if (v8 == -1427 && v10 == -1427)
  {
    v11 = 1;
  }
  else if (v8 | v10)
  {
    v11 = 0;
  }
  else
  {
    v11 = CFEqual(v14, v13) != 0;
  }
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v13);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v14);
  return v11;
}

void sub_1CBCB1858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&a9);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&a10);
  _Unwind_Resume(a1);
}

void ListXattrs(const char *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  ssize_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  std::string *v15;
  std::string *v16;
  __int128 v17;
  uint64_t v18;
  int v19;
  char *v20;
  ssize_t v21;
  size_t v22;
  char *begin;
  void *__p[2];
  std::string::size_type v25;
  std::vector<char> v26;
  std::__split_buffer<std::string> __v;

  std::vector<char>::vector(&v26, 0x400uLL);
  v6 = listxattr(a1, v26.__begin_, 0x400uLL, a2);
  if (v6 == -1)
  {
    if (*__error() != 34 || (v21 = listxattr(a1, 0, 0, a2), v22 = v21, v21 < 1))
    {
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      goto LABEL_26;
    }
    begin = v26.__begin_;
    if ((std::vector<char>::pointer)v21 <= (std::vector<char>::pointer)(v26.__end_ - v26.__begin_))
    {
      if ((std::vector<char>::pointer)v21 < (std::vector<char>::pointer)(v26.__end_ - v26.__begin_))
        v26.__end_ = &v26.__begin_[v21];
    }
    else
    {
      std::vector<char>::__append(&v26, v21 - (v26.__end_ - v26.__begin_));
      begin = v26.__begin_;
    }
    v6 = listxattr(a1, begin, v22, a2);
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  if (v6 >= 1)
  {
    v7 = v26.__begin_;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, v7);
      v9 = *(_QWORD *)(a3 + 8);
      v8 = *(_QWORD *)(a3 + 16);
      if (v9 >= v8)
      {
        v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *(_QWORD *)a3) >> 3);
        v12 = v11 + 1;
        if (v11 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *(_QWORD *)a3) >> 3);
        if (2 * v13 > v12)
          v12 = 2 * v13;
        if (v13 >= 0x555555555555555)
          v14 = 0xAAAAAAAAAAAAAAALL;
        else
          v14 = v12;
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a3 + 16);
        if (v14)
          v15 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(a3 + 16, v14);
        else
          v15 = 0;
        v16 = v15 + v11;
        __v.__first_ = v15;
        __v.__begin_ = v16;
        __v.__end_cap_.__value_ = &v15[v14];
        v17 = *(_OWORD *)__p;
        v16->__r_.__value_.__r.__words[2] = v25;
        *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
        __p[1] = 0;
        v25 = 0;
        __p[0] = 0;
        __v.__end_ = v16 + 1;
        std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a3, &__v);
        v18 = *(_QWORD *)(a3 + 8);
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        v19 = SHIBYTE(v25);
        *(_QWORD *)(a3 + 8) = v18;
        if (v19 < 0)
          operator delete(__p[0]);
      }
      else
      {
        v10 = *(_OWORD *)__p;
        *(_QWORD *)(v9 + 16) = v25;
        *(_OWORD *)v9 = v10;
        *(_QWORD *)(a3 + 8) = v9 + 24;
      }
      v7 += strlen(v7) + 1;
      v20 = v26.__begin_;
    }
    while (v7 < &v26.__begin_[v6]);
    if (v26.__begin_)
      goto LABEL_19;
    return;
  }
LABEL_26:
  v20 = v26.__begin_;
  if (v26.__begin_)
  {
LABEL_19:
    v26.__end_ = v20;
    operator delete(v20);
  }
}

void sub_1CBCB1AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, uint64_t a18, std::__split_buffer<std::string> *a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t xattr_intent(const char *a1, xattr_operation_intent_t a2)
{
  unsigned __int8 v4;
  CFTypeRef *v5;
  uint64_t v6;
  uint64_t v7;
  TString v9[2];

  v9[1] = *(TString *)MEMORY[0x1E0C80C00];
  if ((v4 & 1) == 0)
  {
    {
      TString::TString(v9, "com.apple.favorite-rank.number#PS");
      std::vector<TString>::vector[abi:ne180100](&xattr_intent(char const*,unsigned int)::sharedXATTRs, (uint64_t)v9, 1uLL);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9[0].fString.fRef);
    }
  }
  if ((a2 & 0xFFFFFFFD) != 1)
    return xattr_preserve_for_intent(a1, a2);
  v5 = (CFTypeRef *)xattr_intent(char const*,unsigned int)::sharedXATTRs;
  v6 = qword_1EF9B9798;
  if (xattr_intent(char const*,unsigned int)::sharedXATTRs == qword_1EF9B9798)
  {
    v7 = xattr_intent(char const*,unsigned int)::sharedXATTRs;
  }
  else
  {
    while (!operator==(v5, a1))
    {
      if (++v5 == (CFTypeRef *)v6)
      {
        v5 = (CFTypeRef *)v6;
        break;
      }
    }
    v7 = (uint64_t)v5;
    v5 = (CFTypeRef *)qword_1EF9B9798;
  }
  if (v5 == (CFTypeRef *)v7)
    return xattr_preserve_for_intent(a1, a2);
  else
    return 0;
}

void sub_1CBCB1C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<TString>::vector[abi:ne180100](_QWORD *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4;

  a1[2] = 0;
  v4 = (uint64_t)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  if (a3)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a3);
    a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString const*,TString const*,TString*>(v4, a2, a2 + 8 * a3, a1[1]);
  }
  return a1;
}

void sub_1CBCB1CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

__CFSet *TCFURLInfo::CopyXattrNamesForCompare(TCFURLInfo *this, const char *a2)
{
  __int128 *v2;
  __int128 *v3;
  __CFSet *Mutable;
  const __CFAllocator *v5;
  __int128 v6;
  std::string *v7;
  std::string::size_type size;
  std::string *v9;
  std::string::size_type v10;
  std::string::size_type v11;
  int v12;
  BOOL v13;
  BOOL v14;
  std::string::size_type v15;
  std::string *v16;
  int v17;
  CFStringRef v18;
  _BOOL4 v19;
  void *v21[2];
  char v22;
  void *__p[2];
  char v24;
  void *v25[2];
  char v26;
  void *v27[2];
  char v28;
  std::string v29;
  __int128 *v30;
  __int128 *v31;

  ListXattrs(a2, 1, (uint64_t)&v30);
  v3 = v30;
  v2 = v31;
  if (v30 != v31)
  {
    Mutable = 0;
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    while (1)
    {
      if (*((char *)v3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)v3, *((_QWORD *)v3 + 1));
      }
      else
      {
        v6 = *v3;
        v29.__r_.__value_.__r.__words[2] = *((_QWORD *)v3 + 2);
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v6;
      }
      v7 = (v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &v29
         : (std::string *)v29.__r_.__value_.__r.__words[0];
      if (xattr_intent((const char *)v7, 1u) == 1)
        break;
LABEL_45:
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v29.__r_.__value_.__l.__data_);
      v3 = (__int128 *)((char *)v3 + 24);
      if (v3 == v2)
        goto LABEL_53;
    }
    std::string::basic_string[abi:ne180100]<0>(v27, "com.apple.mtm.");
    std::string::basic_string[abi:ne180100]<0>(v25, "com.apple.acl.text.");
    size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v29.__r_.__value_.__l.__size_;
    if (size != 20
      || ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (v9 = &v29)
        : (v9 = (std::string *)v29.__r_.__value_.__r.__words[0]),
          (v10 = v9->__r_.__value_.__r.__words[0],
           v11 = v9->__r_.__value_.__l.__size_,
           v12 = v9->__r_.__value_.__r.__words[2],
           v10 == 0x6C7070612E6D6F63)
        ? (v13 = v11 == 0x6E61726175712E65)
        : (v13 = 0),
          v13 ? (v14 = v12 == 1701734772) : (v14 = 0),
          !v14))
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.metadata:_kTimeMachine");
      if (BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, __p))
        goto LABEL_33;
      v15 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v15 = v29.__r_.__value_.__l.__size_;
      if (v15 == 42
        && ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (v16 = &v29)
          : (v16 = (std::string *)v29.__r_.__value_.__r.__words[0]),
            !memcmp(v16, "com.apple.metadata:_kMDItemTimeMachinePath", 0x2AuLL))
        || BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, v27)
        || BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, v25))
      {
LABEL_33:
        v17 = 0;
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(v21, "com.apple.timemachine.private.");
        v19 = BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, v21);
        if (v22 < 0)
          operator delete(v21[0]);
        v17 = !v19;
      }
      if ((v24 & 0x80000000) == 0)
      {
        if (!v17)
          goto LABEL_41;
LABEL_38:
        v18 = CFStringCreateWithCString(v5, (const char *)v7, 0x8000100u);
        __p[0] = (void *)v18;
        if (!Mutable)
        {
          Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E0C9B3B0]);
          v18 = (CFStringRef)__p[0];
        }
        CFSetAddValue(Mutable, v18);
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)__p);
        goto LABEL_41;
      }
      operator delete(__p[0]);
      if (v17)
        goto LABEL_38;
    }
LABEL_41:
    if (v26 < 0)
      operator delete(v25[0]);
    if (v28 < 0)
      operator delete(v27[0]);
    goto LABEL_45;
  }
  Mutable = 0;
LABEL_53:
  v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v29);
  return Mutable;
}

void sub_1CBCB1FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v38;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  if (a38 < 0)
    operator delete(a33);
  a33 = (void *)(v38 - 104);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);
  _Unwind_Resume(a1);
}

BOOL BeginsWith(const void **a1, _QWORD *a2)
{
  int v2;
  size_t v3;
  size_t v4;
  const void **v5;
  size_t v6;

  v2 = *((char *)a2 + 23);
  if (v2 >= 0)
    v3 = *((unsigned __int8 *)a2 + 23);
  else
    v3 = a2[1];
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (v3 != -1)
    {
      v4 = *((unsigned __int8 *)a1 + 23);
      goto LABEL_9;
    }
LABEL_20:
    std::string::__throw_out_of_range[abi:ne180100]();
  }
  if (v3 == -1)
    goto LABEL_20;
  v5 = a1;
  a1 = (const void **)*a1;
  v4 = (size_t)v5[1];
LABEL_9:
  if (v4 >= v3)
    v6 = v3;
  else
    v6 = v4;
  if (v2 < 0)
    a2 = (_QWORD *)*a2;
  return !memcmp(a1, a2, v6) && v6 == v3;
}

uint64_t TCFURLInfo::XattrsEqual(TCFURLInfo **a1, TCFURLInfo ***a2)
{
  TCFURLInfo *v3;
  TCFURLInfo *v4;
  const __CFSet *v5;
  CFIndex Count;
  const __CFSet *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  __CFString *v11;
  TCFURLInfo *v12;
  TCFURLInfo *v13;
  uint64_t v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  CFSetRef v20;
  CFSetRef theSet;
  TString v22;
  TString v23;
  _BYTE v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  TCFURLInfo::FileSystemRepresentation(*a1, (const __CFURL *)1, &v23);
  TCFURLInfo::FileSystemRepresentation(**a2, (const __CFURL *)1, &v22);
  v3 = (TCFURLInfo *)TString::c_str(&v23);
  theSet = TCFURLInfo::CopyXattrNamesForCompare(v3, (const char *)v3);
  v4 = (TCFURLInfo *)TString::c_str(&v22);
  v5 = TCFURLInfo::CopyXattrNamesForCompare(v4, (const char *)v4);
  v20 = v5;
  if (!theSet)
  {
    Count = 0;
    if (!v5)
      goto LABEL_6;
    goto LABEL_5;
  }
  Count = CFSetGetCount(theSet);
  v5 = v20;
  if (v20)
LABEL_5:
    v5 = (const __CFSet *)CFSetGetCount(v5);
LABEL_6:
  if ((const __CFSet *)Count == v5)
  {
    if (Count < 1)
    {
      v14 = 1;
    }
    else
    {
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v7 = theSet;
      v8 = -[__CFSet countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v16, v24, 16);
      if (v8)
      {
        v9 = *(_QWORD *)v17;
        while (2)
        {
          for (i = 0; i != v8; ++i)
          {
            if (*(_QWORD *)v17 != v9)
              objc_enumerationMutation(v7);
            v11 = (__CFString *)*(id *)(*((_QWORD *)&v16 + 1) + 8 * i);
            if (!CFSetContainsValue(v20, v11))
            {

LABEL_22:
              v14 = 0;
              goto LABEL_23;
            }
            v12 = (TCFURLInfo *)TString::c_str(&v23);
            v13 = (TCFURLInfo *)TString::c_str(&v22);
            LODWORD(v12) = TCFURLInfo::XattrValuesEqual(v13, v12, v13, v11, (__CFString *)1);

            if (!(_DWORD)v12)
              goto LABEL_22;
          }
          v8 = -[__CFSet countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v16, v24, 16);
          v14 = 1;
          if (v8)
            continue;
          break;
        }
      }
      else
      {
        v14 = 1;
      }
LABEL_23:

    }
  }
  else
  {
    v14 = 0;
  }
  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)&v20);
  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)&theSet);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
  return v14;
}

void sub_1CBCB2314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  const void *v12;
  va_list va;
  const void *v14;
  va_list va1;
  const void *v16;
  va_list va2;
  va_list va3;

  va_start(va3, a10);
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  v12 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v14 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v16 = va_arg(va3, const void *);

  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)va);
  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::LessThan(TCFURLInfo *a1, TCFURLInfo **a2)
{
  _BOOL8 v3;
  TString v5;
  TString v6;

  TCFURLInfo::Name(a1, &v6);
  TCFURLInfo::Name(*a2, &v5);
  v3 = TString::StringCompare(&v6, &v5) == kCFCompareLessThan;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return v3;
}

void sub_1CBCB23E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::ShouldSkip(const void **this, uint64_t a2, int a3)
{
  __int16 v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFURL *NumericalProperty;
  const __CFString *v10;
  const __CFString *v11;

  if (*((int *)this + 18) <= 0)
    TCFURLInfo::FetchProperties(this, 1);
  v6 = *((_WORD *)this + 38);
  if ((v6 & 1) != 0)
    return 0;
  if (a3)
  {
    if (*((int *)this + 18) <= 1)
    {
      TCFURLInfo::FetchProperties(this, 1);
      v6 = *((_WORD *)this + 38);
    }
    if ((v6 & 0x1000) == 0)
      return 1;
  }
  if (TCFURLInfo::GetType((CFURLRef *)this) == 1651666795 && (*((_WORD *)this + 38) & 0x400) == 0)
    return 1;
  if (a2 < 1)
    return 0;
  v8 = (const __CFString *)*MEMORY[0x1E0C9AC58];
  NumericalProperty = TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, (const __CFString *)*MEMORY[0x1E0C9AC58], v7);
  if ((uint64_t)NumericalProperty
     + (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, (const __CFString *)*MEMORY[0x1E0C9B4A8], v10) > a2)
    return 1;
  return (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, v8, v11) > a2;
}

uint64_t TCFURLInfo::EffectiveUserCanRead(const void **this, BOOL *a2)
{
  uid_t v4;
  uint64_t v5;

  if (!a2)
    return 0;
  *a2 = 1;
  if (TCFURLInfo::gDSHelperRunning)
    v4 = TCFURLInfo::guidToUse;
  else
    v4 = getuid();
  if (*((int *)this + 18) <= 1)
    TCFURLInfo::FetchProperties(this, 1);
  v5 = (*((unsigned __int16 *)this + 38) >> 12) & 1;
  *a2 = TCFURLInfo::GetOwner((CFURLRef *)this) == v4;
  return v5;
}

CFIndex TCFURLInfo::GetParent(const void **this, TString **a2)
{
  const __CFURL *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  CFIndex v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v16;
  const __CFURL *propertyValueTypeRefPtr;

  if (*((int *)this + 18) <= 0)
    TCFURLInfo::FetchProperties(this, 1);
  if ((*((_WORD *)this + 38) & 0x80) != 0 || (v4 = (const __CFURL *)*this) == 0)
  {
    v16 = 0uLL;
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v16);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    return 0;
  }
  else
  {
    propertyValueTypeRefPtr = 0;
    CFURLCopyResourcePropertyForKey(v4, (CFStringRef)*MEMORY[0x1E0C9B5A8], &propertyValueTypeRefPtr, 0);
    if (propertyValueTypeRefPtr)
    {
      _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v16);
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v16);
      v5 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
      if (*((_QWORD *)&v16 + 1))
      {
        v6 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
        do
          v7 = __ldaxr(v6);
        while (__stlxr(v7 - 1, v6));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
      v8 = TCFURLInfo::Initialize(*a2, propertyValueTypeRefPtr, 1, 1);
    }
    else
    {
      v16 = 0uLL;
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a2, &v16);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
      if (*((_QWORD *)&v16 + 1))
      {
        v13 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v8 = 4294959236;
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  }
  return v8;
}

void sub_1CBCB273C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::SetImmutableAndAppendFlags(id *a1, int a2)
{
  __CFDictionary *Mutable;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  uint64_t v11;
  CFMutableDictionaryRef theDict;

  if (!*a1)
    return 4294959238;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  theDict = Mutable;
  v5 = (const void *)*MEMORY[0x1E0C9AE50];
  v6 = (const void *)*MEMORY[0x1E0C9AE40];
  if ((a2 & 1) != 0)
    v7 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v7 = (const void *)*MEMORY[0x1E0C9AE40];
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9B548], v7);
  if ((a2 & 0x100) != 0)
    v8 = v5;
  else
    v8 = v6;
  CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0C9B538], v8);
  if ((*(_QWORD *)&a2 & 0x10000) != 0)
    v9 = v5;
  else
    v9 = v6;
  CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0C9ACD8], v9);
  if ((a2 & 0x1000000) != 0)
    v10 = v5;
  else
    v10 = v6;
  CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0C9ACB0], v10);
  if (TCFURLInfo::SetResourceProperties(a1, theDict))
    v11 = 4294967260;
  else
    v11 = 0;
  TAutoRef<__CFDictionary *,TRetainReleasePolicy<__CFDictionary *>>::~TAutoRef((const void **)&theDict);
  return v11;
}

void sub_1CBCB285C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFDictionary *,TRetainReleasePolicy<__CFDictionary *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::SetResourceProperties(id *this, const __CFDictionary *a2)
{
  const __CFURL *v3;
  uint64_t v5;
  NSObject *v6;
  NSURL *v7;
  void *v8;
  __CFError *v9;
  unsigned int v10;
  CFErrorRef error;
  uint8_t buf[4];
  void *v14;
  __int16 v15;
  const __CFDictionary *v16;
  __int16 v17;
  CFErrorRef v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = (const __CFURL *)*this;
  if (!v3)
    return 4294959238;
  error = 0;
  if (CFURLSetResourcePropertiesForKeys(v3, a2, &error))
  {
    v5 = 0;
  }
  else
  {
    LogObj(2);
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = (NSURL *)*this;
      SanitizedURL(v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543874;
      v14 = v8;
      v15 = 2114;
      v16 = a2;
      v17 = 2114;
      v18 = error;
      _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_ERROR, "CFURLSetResourcePropertiesForKeys failed %{public}@, %{public}@, error: %{public}@", buf, 0x20u);

    }
    v10 = TCFURLInfo::TranslateCFError(error, v9);
    if (v10 == -5000)
      v5 = 0;
    else
      v5 = v10;
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
  return v5;
}

void sub_1CBCB29A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);

  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::IsTrash(TCFURLInfo *this)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  _BOOL8 v4;
  TString *v6;
  TString *v7;
  CFTypeRef v8;
  CFTypeRef cf1;

  {
    v6 = (TString *)operator new();
    TString::TString(v6, ".Trash");
    TCFURLInfo::IsTrash(void)const::trashName = (uint64_t)v6;
  }
  {
    v7 = (TString *)operator new();
    TString::TString(v7, ".Trashes");
    TCFURLInfo::IsTrash(void)const::trashesName = (uint64_t)v7;
  }
  TCFURLInfo::Name(this, (TString *)&cf1);
  if (CFEqual(cf1, *(CFTypeRef *)TCFURLInfo::IsTrash(void)const::trashName))
  {
    v4 = 1;
  }
  else
  {
    TCFURLInfo::Name(this, (TString *)&v8);
    v4 = CFEqual(v8, *(CFTypeRef *)TCFURLInfo::IsTrash(void)const::trashesName) != 0;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v8);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v4;
}

void sub_1CBCB2B20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::TranslateFileProviderError(TCFURLInfo *this, __CFError *a2)
{
  CFIndex Code;

  Code = CFErrorGetCode(this);
  if ((unint64_t)(Code + 1004) > 4)
    return 4294959279;
  else
    return *((unsigned int *)&unk_1CBD12D84 + Code + 1004);
}

CFIndex TCFURLInfo::OSStatusFromCFErrorShallow(TCFURLInfo *this, __CFError *a2)
{
  TString *Domain;
  TCFURLInfo *Code;
  const char *v5;
  TCFURLInfo *v6;
  CFIndex v7;
  int v8;
  __CFError *v10;
  int v11;
  int v12;
  int v13;
  CFTypeRef cf2;
  TString v15;
  CFTypeRef cf1;

  Domain = (TString *)CFErrorGetDomain(this);
  cf1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&cf1, Domain);
  v15.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v15, (TString *)*MEMORY[0x1E0C9AFD0]);
  LODWORD(Domain) = CFEqual(cf1, v15.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
  if ((_DWORD)Domain)
  {
    Code = (TCFURLInfo *)CFErrorGetCode(this);
    v6 = TCFURLInfo::TranslatePOSIXError(Code, 0, v5);
  }
  else
  {
    v15.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v15, (TString *)*MEMORY[0x1E0C9AFC8]);
    v8 = CFEqual(cf1, v15.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    if (v8)
    {
      v7 = CFErrorGetCode(this);
      goto LABEL_6;
    }
    FileProviderErrorDomain(&v15);
    if (CFEqual(cf1, v15.fString.fRef))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    }
    else
    {
      cf2 = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)&cf2, (TString *)*MEMORY[0x1E0CB32E8]);
      v11 = CFEqual(cf1, cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
      if (!v11)
      {
        v15.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v15, (TString *)*MEMORY[0x1E0C9AFB8]);
        v12 = CFEqual(cf1, v15.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        if (v12)
        {
          v13 = CFErrorGetCode(this);
          if (v13 > 639)
          {
            if (v13 > 4352)
            {
              if (v13 == 4353 || v13 == 4355)
              {
                v7 = 4294959289;
                goto LABEL_6;
              }
            }
            else
            {
              if (v13 == 640)
              {
                v7 = 4294967262;
                goto LABEL_6;
              }
              if (v13 == 3072)
              {
                v7 = 4294967168;
                goto LABEL_6;
              }
            }
          }
          else
          {
            v7 = 4294967253;
            if (v13 > 259)
            {
              if (v13 == 260)
                goto LABEL_6;
              if (v13 == 516)
              {
                v7 = 4294967248;
                goto LABEL_6;
              }
            }
            else
            {
              if (v13 == 4)
                goto LABEL_6;
              if (v13 == 257)
              {
                v7 = 4294967242;
                goto LABEL_6;
              }
            }
          }
        }
        v7 = 4294967260;
        goto LABEL_6;
      }
    }
    v6 = (TCFURLInfo *)TCFURLInfo::TranslateFileProviderError(this, v10);
  }
  v7 = (CFIndex)v6;
LABEL_6:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v7;
}

void sub_1CBCB2E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t *TCFURLInfo::GetPropertyStoreName(TCFURLInfo *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    TString::TString((TString *)&TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName, ".DS_Store", 9uLL);
  }
  return &TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName;
}

void sub_1CBCB2EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TCFURLInfo::TranslateCFError(__CFError *)::$_0::operator()()
{
  void *v0;
  void *v1;
  void *v2;
  id v3;
  id v4;
  id v5;

  TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories = 0;
  *(_QWORD *)algn_1EF9B97D8 = 0;
  qword_1EF9B97E0 = 0;
  v0 = (void *)MEMORY[0x1E0C99E98];
  NSHomeDirectory();
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "stringByAppendingPathComponent:", CFSTR("Applications"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "fileURLWithPath:isDirectory:", v2, 1);
  v5 = (id)objc_claimAutoreleasedReturnValue();

  std::vector<NSURL * {__strong}>::push_back[abi:ne180100]((char **)&TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories, &v5);
  objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", CFSTR("/Developer"), 1);
  v4 = (id)objc_claimAutoreleasedReturnValue();
  std::vector<NSURL * {__strong}>::push_back[abi:ne180100]((char **)&TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories, &v4);
  objc_msgSend(v4, "URLByAppendingPathComponent:", CFSTR("Applications"));
  v3 = (id)objc_claimAutoreleasedReturnValue();
  std::vector<NSURL * {__strong}>::push_back[abi:ne180100]((char **)&TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories, &v3);

}

void sub_1CBCB300C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void **a12)
{

  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

TCFURLInfo *TCFURLInfo::TranslateRawPOSIXError(TCFURLInfo *this, const char *a2, const char *a3)
{
  TCFURLInfo *v3;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  _DWORD v9[2];
  __int16 v10;
  int v11;
  __int16 v12;
  const char *v13;
  uint64_t v14;

  v3 = this;
  v14 = *MEMORY[0x1E0C80C00];
  if ((int)this < -1)
    return v3;
  if ((int)this > 62)
  {
    if ((int)this <= 68)
    {
      if ((_DWORD)this == 63)
      {
        v5 = 4294965886;
        goto LABEL_30;
      }
      if ((_DWORD)this == 66)
      {
LABEL_12:
        v5 = 4294967249;
        goto LABEL_30;
      }
    }
    else
    {
      switch((_DWORD)this)
      {
        case 'E':
          v5 = 4294965871;
          goto LABEL_30;
        case 'P':
          v5 = 4294962273;
          goto LABEL_30;
        case 'Y':
          v5 = 4294967168;
LABEL_30:
          LogObj(2);
          v6 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            v7 = "'null'";
            v9[0] = 67109634;
            if (a2)
              v7 = a2;
            v9[1] = (_DWORD)v3;
            v10 = 1024;
            v11 = v5;
            v12 = 2080;
            v13 = v7;
            _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_DEBUG, "TCFURLInfo::TranslateRawPOSIXError %d -> %d, path: %s", (uint8_t *)v9, 0x18u);
          }

          return (TCFURLInfo *)v5;
      }
    }
LABEL_29:
    v5 = ((_DWORD)this + 100000);
    goto LABEL_30;
  }
  v5 = 4294967260;
  switch((int)this)
  {
    case -1:
    case 5:
      goto LABEL_30;
    case 0:
      return v3;
    case 1:
    case 13:
      v5 = 4294962296;
      goto LABEL_30;
    case 2:
      v5 = 4294967253;
      goto LABEL_30;
    case 9:
      v5 = 4294967245;
      goto LABEL_30;
    case 11:
      v5 = 4294959283;
      goto LABEL_30;
    case 12:
    case 23:
      v5 = 4294967255;
      goto LABEL_30;
    case 16:
      goto LABEL_12;
    case 17:
      v5 = 4294967248;
      goto LABEL_30;
    case 18:
      v5 = 100018;
      goto LABEL_30;
    case 20:
    case 21:
      v5 = 4294965889;
      goto LABEL_30;
    case 22:
      v5 = 4294967246;
      goto LABEL_30;
    case 24:
      v5 = 4294967254;
      goto LABEL_30;
    case 27:
      v5 = 4294965987;
      goto LABEL_30;
    case 28:
      v5 = 4294967262;
      goto LABEL_30;
    case 30:
      v5 = 4294967235;
      goto LABEL_30;
    case 45:
      v5 = 4294965870;
      goto LABEL_30;
    default:
      goto LABEL_29;
  }
  return v3;
}

uint64_t TCFURLInfo::TranslateXAttrError(uint64_t this, int a2, const char *a3)
{
  if ((_DWORD)this)
  {
    if ((_DWORD)this == 93)
    {
      return 4294965869;
    }
    else if ((_DWORD)this == 45)
    {
      return 4294965870;
    }
    else
    {
      return (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)this, 0, a3);
    }
  }
  return this;
}

uint64_t TCFURLInfo::DesktopServicesBundle(TCFURLInfo *this)
{
  unsigned __int8 v1;

  {
    TCFURLInfo::DesktopServicesBundle(void)::dsBundle = (uint64_t)TCFURLInfo::DesktopServicesBundle(void)::$_0::operator()();
  }
  return TCFURLInfo::DesktopServicesBundle(void)::dsBundle;
}

void sub_1CBCB32EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFBundleRef TCFURLInfo::DesktopServicesBundle(void)::$_0::operator()()
{
  CFBundleRef BundleWithIdentifier;
  CFBundleRef v1;
  const __CFURL *v2;
  CFBundleRef v4;
  CFBundleRef v5;

  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.desktopservices"));
  v5 = BundleWithIdentifier;
  if (BundleWithIdentifier)
  {
    v1 = BundleWithIdentifier;
    CFRetain(BundleWithIdentifier);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", CFSTR("/System/Library/PrivateFrameworks/DesktopServicesPriv.framework"), 1);
    v2 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
    v4 = CFBundleCreate(0, v2);
    TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::operator=<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>((const void **)&v5, (const void **)&v4);
    TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef((const void **)&v4);

    v1 = v5;
  }
  v5 = 0;
  TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef((const void **)&v5);
  return v1;
}

void sub_1CBCB33A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);

  TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::LocalizedCopyErrorMessage@<X0>(TCFURLInfo *this@<X0>, const void **a2@<X1>, TString *a3@<X8>)
{
  int v7;
  int v8;
  const __CFString *v9;
  __CFBundle *v10;
  CFStringRef v11;
  const void *v12;
  CFTypeRef v13;
  CFStringRef v14;
  TString *v15;
  CFStringRef v17;
  TString *v18;

  if ((int)this <= -1310)
  {
    if ((int)this <= -5009)
    {
      if ((int)this <= -8088)
      {
        if ((_DWORD)this == -8095)
        {
          v8 = 0;
          v7 = 0;
          v9 = CFSTR("ReservationError");
          goto LABEL_35;
        }
        if ((_DWORD)this == -8089)
        {
          v7 = 0;
          v8 = 1;
          v9 = CFSTR("CaseSensitivity");
          goto LABEL_35;
        }
      }
      else
      {
        switch((_DWORD)this)
        {
          case 0xFFFFE069:
            goto LABEL_10;
          case 0xFFFFEC66:
            goto LABEL_20;
          case 0xFFFFEC6E:
LABEL_10:
            v8 = 0;
            v7 = 0;
            v9 = CFSTR("FileBusy");
            goto LABEL_35;
        }
      }
LABEL_31:
      v8 = 0;
      v7 = 1;
      v9 = CFSTR("UnknownError");
      goto LABEL_35;
    }
    if ((int)this <= -1430)
    {
      if ((_DWORD)this != -5008)
      {
        if ((_DWORD)this == -5000)
        {
          v8 = 0;
          v7 = 0;
          v9 = CFSTR("AccessDenied");
          goto LABEL_35;
        }
        goto LABEL_31;
      }
    }
    else if ((_DWORD)this != -1429)
    {
      if ((_DWORD)this == -1410)
      {
LABEL_28:
        v7 = 0;
        v8 = 1;
        v9 = CFSTR("BadName");
        goto LABEL_35;
      }
      if ((_DWORD)this != -1401)
        goto LABEL_31;
      goto LABEL_20;
    }
LABEL_27:
    v8 = 0;
    v7 = 0;
    v9 = CFSTR("DiskFull");
    goto LABEL_35;
  }
  if ((int)this <= -49)
  {
    if ((_DWORD)this == -1309)
    {
      v8 = 0;
      v7 = 0;
      v9 = CFSTR("FileTooBig");
      goto LABEL_35;
    }
    if ((_DWORD)this != -120)
    {
      if ((_DWORD)this == -61)
      {
        v8 = 0;
        v7 = 0;
        v9 = CFSTR("WritePermission");
        goto LABEL_35;
      }
      goto LABEL_31;
    }
LABEL_20:
    v8 = 0;
    v7 = 1;
    v9 = CFSTR("FileNotFound");
    goto LABEL_35;
  }
  switch((int)this)
  {
    case -48:
      v7 = 0;
      v8 = 1;
      v9 = CFSTR("DuplicateFileName");
      break;
    case -47:
      goto LABEL_10;
    case -46:
    case -45:
    case -44:
    case -42:
    case -41:
    case -40:
    case -39:
    case -38:
      goto LABEL_31;
    case -43:
    case -35:
      goto LABEL_20;
    case -37:
      goto LABEL_28;
    case -36:
      v7 = 0;
      v8 = 1;
      v9 = CFSTR("IOError");
      break;
    case -34:
      goto LABEL_27;
    default:
      if ((_DWORD)this != 100006)
        goto LABEL_31;
      v8 = 0;
      v7 = 0;
      v9 = CFSTR("DeviceDisappeared");
      break;
  }
LABEL_35:
  v10 = (__CFBundle *)TCFURLInfo::DesktopServicesBundle(this);
  v11 = CFBundleCopyLocalizedString(v10, v9, v9, 0);
  v18 = (TString *)v11;
  if (v8)
  {
    v12 = RetainCF<__CFString const*>(a2);
    if (v12)
    {
      v13 = CFAutorelease(v12);
      v12 = static_cf_cast<__CFString const*,void const*>(v13);
    }
    v14 = CFStringCreateWithFormat(0, 0, v11, v12);
    goto LABEL_41;
  }
  if (v7)
  {
    v14 = CFStringCreateWithFormat(0, 0, v11, this);
LABEL_41:
    v17 = v14;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v18, (const void **)&v17);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
  }
  v15 = v18;
  a3->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a3, v15);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18);
}

void sub_1CBCB368C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TCFURLInfo::LocalizedCopyErrorMessage(TCFURLInfo *this@<X0>, const __CFURL *a2@<X1>, TString *a3@<X8>)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  TCFURLInfo *v10;
  std::__shared_weak_count *v11;

  _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v10);
  TCFURLInfo::Initialize((TString *)v10, a2, 1, 0);
  TCFURLInfo::LocalizedCopyErrorMessage((TString **)v10, this, a3);
  v7 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1CBCB3754(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::LocalizedCopyErrorMessage@<X0>(TString **this@<X0>, TCFURLInfo *a2@<X1>, TString *a3@<X8>)
{
  TString v7;
  CFStringRef theString;

  TCFURLInfo::DisplayName(this, (TString *)&theString);
  if (CFStringGetLength(theString))
  {
    v7.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v7, (TString *)theString);
  }
  else
  {
    TCFURLInfo::Name((TCFURLInfo *)this, &v7);
  }
  TCFURLInfo::LocalizedCopyErrorMessage(a2, (const void **)&v7.fString.fRef, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1CBCB37FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::LocalizedStringWithFileName@<X0>(const __CFString *this@<X0>, __CFString *a2@<X1>, TString *a3@<X8>)
{
  const void **v6;
  __CFBundle *v7;
  CFStringRef v8;
  CFTypeRef v9;
  CFTypeRef v10;
  CFTypeRef v11;
  TString *v12;
  TString *v14;
  CFStringRef v15;
  CFTypeRef cf;

  v6 = TCFURLInfo::StringProperty((TCFURLInfo *)a2, (const __CFString *)*MEMORY[0x1E0C9B580], (TString *)&cf);
  v7 = (__CFBundle *)TCFURLInfo::DesktopServicesBundle((TCFURLInfo *)v6);
  v8 = CFBundleCopyLocalizedString(v7, this, this, 0);
  v15 = v8;
  v9 = cf;
  if (cf)
  {
    v10 = CFRetain(cf);
    v9 = static_cf_cast<__CFString const*,void const*>(v10);
    if (v9)
    {
      v11 = CFAutorelease(v9);
      v9 = static_cf_cast<__CFString const*,void const*>(v11);
    }
  }
  v12 = (TString *)CFStringCreateWithFormat(0, 0, v8, v9);
  v14 = v12;
  a3->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a3, v12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1CBCB38F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void **v2;
  const void *v4;
  va_list va;
  const void *v6;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v6 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::DeleteDeep(const void **this, int a2, int a3)
{
  const void **v5;
  __int16 v6;
  __int16 v7;
  const __CFArray *BasicInfoPropertyKeys;
  TCFURLIterator *v9;
  char v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  TCFURLInfo *v17;
  std::__shared_weak_count *v18;
  TCFURLIterator *v19;

  v5 = this;
  if (*((int *)this + 18) <= 0)
    this = (const void **)TCFURLInfo::FetchProperties(this, 1);
  LOBYTE(v6) = *((_WORD *)v5 + 38);
  if ((*((_WORD *)v5 + 38) & 1) == 0)
    return TCFURLInfo::Delete((TCFURLInfo *)v5, a2, a3);
  LOBYTE(v7) = *((_WORD *)v5 + 38);
  if (*((int *)v5 + 18) <= 0)
  {
    this = (const void **)TCFURLInfo::FetchProperties(v5, 1);
    v7 = *((_WORD *)v5 + 38);
    if (*((int *)v5 + 18) <= 0)
      this = (const void **)TCFURLInfo::FetchProperties(v5, 1);
    v6 = *((_WORD *)v5 + 38);
  }
  BasicInfoPropertyKeys = (const __CFArray *)TCFURLInfo::GetBasicInfoPropertyKeys((TCFURLInfo *)this);
  v9 = (TCFURLIterator *)operator new();
  TCFURLIterator::TCFURLIterator(v9, (const TCFURLInfo *)v5, BasicInfoPropertyKeys, 0);
  v10 = 0;
  a2 |= (v7 & 4) >> 2;
  a3 |= (v6 & 4) >> 2;
  v19 = v9;
  do
  {
    while (1)
    {
      _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v17);
      v11 = TCFURLIterator::Next((uint64_t)v19, (TString **)&v17);
      if (!v11)
      {
        TCFURLInfo::FetchProperties((const void **)v17, 1);
        v10 = v10 & 1 | (TCFURLInfo::DeleteDeep(v17, a2, a3) != 0);
      }
      v12 = v18;
      if (v18)
      {
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        do
          v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
          break;
      }
      if (v11)
        goto LABEL_18;
    }
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  while (!v11);
LABEL_18:
  v15 = (uint64_t)v19;
  v19 = 0;
  if (v15)
    std::default_delete<TCFURLIterator>::operator()[abi:ne180100]((uint64_t)&v19, v15);
  result = 4294959215;
  if (v11 != -8095 && (v10 & 1) == 0)
    return TCFURLInfo::Delete((TCFURLInfo *)v5, a2, a3);
  return result;
}

void sub_1CBCB3B08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1060C40FBA2130BLL);
  _Unwind_Resume(a1);
}

uint64_t TCFURLIterator::Next(uint64_t a1, TString **a2)
{
  CFIndex v4;
  const __CFString *v5;
  CFIndex Raw;
  const __CFURL *v7;
  int v8;
  uint64_t v9;
  BOOL v10;
  const __CFString *v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const __CFString *v18;
  const __CFURL *v19;
  TString *v20;
  BOOL v21;
  const __CFString *v22;
  __int128 v24;
  const void *v25;

  v4 = a1 + 16;
  if (!*(_QWORD *)(a1 + 16))
  {
    v25 = (const void *)MEMORY[0x1D17A4DF4](0, **(_QWORD **)a1, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)v4, v25);
    if (*(_BYTE *)(a1 + 74))
    {
      v5 = (const __CFString *)*MEMORY[0x1E0C9AC48];
      do
      {
        _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v24);
        Raw = TCFURLIterator::NextRaw(a1, (TString **)&v24);
        v8 = Raw;
        if ((_DWORD)Raw != -1417)
        {
          if ((_DWORD)Raw)
          {
            v12 = 0;
            v4 = Raw;
            goto LABEL_19;
          }
          v9 = v24;
          if (*(int *)(v24 + 72) <= 0)
            TCFURLInfo::FetchProperties((const void **)v24, 1);
          if (*(_QWORD *)v9)
            v10 = TCFURLInfo::gRootlessEnabled == 0;
          else
            v10 = 1;
          if (!v10
            && TCFURLInfo::IsOnSystemVolume((TCFURLInfo **)v9, v7)
            && (TCFURLInfo::GetNumericalProperty(*(const __CFURL **)v9, v5, v11) & 0x80) != 0
            || ((*(unsigned __int16 *)(v9 + 76) | (*(unsigned __int8 *)(v9 + 78) << 16)) & 0x10003) == 0)
          {
            v4 = 0;
            v12 = 0;
            goto LABEL_19;
          }
          std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)(a1 + 40), &v24);
        }
        v12 = 1;
LABEL_19:
        v13 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
        if (*((_QWORD *)&v24 + 1))
        {
          v14 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        if (!v12)
        {
          TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(&v25);
          return v4;
        }
      }
      while (v8 != -1417);
    }
    TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(&v25);
  }
  if (!*(_BYTE *)(a1 + 74))
  {
    v18 = (const __CFString *)*MEMORY[0x1E0C9AC48];
    while (1)
    {
      v4 = TCFURLIterator::NextRaw(a1, a2);
      if (!(_DWORD)v4)
      {
        v20 = *a2;
        if (SLODWORD((*a2)[9].fString.fRef) <= 0)
          TCFURLInfo::FetchProperties((const void **)&(*a2)->fString.fRef, 1);
        if (v20->fString.fRef)
          v21 = TCFURLInfo::gRootlessEnabled == 0;
        else
          v21 = 1;
        if ((v21
           || !TCFURLInfo::IsOnSystemVolume((TCFURLInfo **)v20, v19)
           || (TCFURLInfo::GetNumericalProperty((const __CFURL *)v20->fString.fRef, v18, v22) & 0x80) == 0)
          && ((WORD2(v20[9].fString.fRef) | (BYTE6(v20[9].fString.fRef) << 16)) & 0x10003) != 0)
        {
          return 0;
        }
        v4 = 4294959234;
      }
      if ((_DWORD)v4 != -8062)
        return v4;
    }
  }
  v16 = *(_QWORD *)(a1 + 64);
  v17 = *(_QWORD *)(a1 + 40);
  if (v16 >= (*(_QWORD *)(a1 + 48) - v17) >> 4)
    return 4294965879;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a2, (uint64_t *)(v17 + 16 * v16));
  v4 = 0;
  ++*(_QWORD *)(a1 + 64);
  return v4;
}

void sub_1CBCB3DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::Delete(TCFURLInfo *this, int a2, char a3)
{
  uint64_t v6;
  const __CFString *v7;
  const char *v8;
  _WORD *v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int BooleanProperty;
  const __CFString *v16;
  TCFURLInfo *Properties;
  int v18;
  int v19;
  TCFURLInfo *v20;
  int v21;
  int *v22;
  const char *v23;
  const __CFURL *v24;
  const __CFString *v25;
  const __CFString *v26;
  int v27;
  int v28;
  int v29;
  CFTypeRef cf1;

  if (!*(_QWORD *)this)
    return 4294959238;
  v6 = TCFURLInfo::PathAsCStr(this);
  if (!v6)
    return 0;
  v8 = (const char *)v6;
  if (*((int *)this + 18) < 1)
  {
    TCFURLInfo::FetchProperties((const void **)this, 1);
    v9 = (_WORD *)((char *)this + 76);
    LOBYTE(v11) = *((_WORD *)this + 38);
    if (*((int *)this + 18) <= 0)
      TCFURLInfo::FetchProperties((const void **)this, 1);
    v10 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
  }
  else
  {
    v9 = (_WORD *)((char *)this + 76);
    v10 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
    v11 = *((_WORD *)this + 38);
  }
  v13 = v11 & 0x10;
  v14 = v10 & 0x20000;
  BooleanProperty = TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)this, (const __CFString *)*MEMORY[0x1E0C9ACD8], v7);
  Properties = (TCFURLInfo *)TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)this, (const __CFString *)*MEMORY[0x1E0C9ACB0], v16);
  v18 = (int)Properties;
  if (!a2
    || (v13 | v14 ? (v19 = 1) : (v19 = BooleanProperty),
        (v19 | Properties) != 1
     || (Properties = (TCFURLInfo *)TCFURLInfo::SetImmutableAndAppendFlags((id *)this, 0),
         v12 = (uint64_t)Properties,
         !(_DWORD)Properties)))
  {
    if (*((int *)this + 18) <= 0)
      Properties = (TCFURLInfo *)TCFURLInfo::FetchProperties((const void **)this, 1);
    if ((*v9 & 1) != 0)
    {
      v12 = TCFURLInfo::RmDir(Properties, v8);
LABEL_26:
      if ((_DWORD)v12 && a2)
      {
        v27 = v13 | v14 ? 1 : BooleanProperty;
        if ((v27 | v18) == 1)
        {
          v28 = 0x1000000;
          if (!v18)
            v28 = 0;
          v29 = 0x10000;
          if (!BooleanProperty)
            v29 = 0;
          TCFURLInfo::SetImmutableAndAppendFlags((id *)this, v29 | v28 | (v14 >> 9) | (v13 >> 4));
        }
      }
      return v12;
    }
    if ((a3 & 1) != 0
      || (TCFURLInfo::Name(this, (TString *)&cf1),
          TCFURLInfo::GetPropertyStoreName(v20),
          v21 = CFEqual(cf1, (CFTypeRef)TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName),
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1),
          v21))
    {
      if (unlink(v8))
      {
LABEL_21:
        v22 = __error();
        v12 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v22, 0, v23);
        if (TCFURLInfo::IsSystemRestrictionEffective((TCFURLInfo **)this, v24, v25)
          || TCFURLInfo::gRootlessEnabled
          && TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)this, (const __CFString *)*MEMORY[0x1E0C9ACD0], v26))
        {
          v12 = 4294959217;
        }
        goto LABEL_26;
      }
    }
    else if (__carbon_delete())
    {
      goto LABEL_21;
    }
    return 0;
  }
  return v12;
}

void sub_1CBCB4074(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::RmDir(TCFURLInfo *this, const char *a2)
{
  uint64_t result;
  int *v4;
  const char *v5;
  unsigned int v6;

  result = rmdir(a2);
  if ((_DWORD)result)
  {
    v4 = __error();
    v6 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v4, 0, v5);
    if (unlinkat(-2, a2, 256))
      return v6;
    else
      return 0;
  }
  return result;
}

BOOL TCFURLInfo::IsSystemRestrictionEffective(TCFURLInfo **this, const __CFURL *a2, const __CFString *a3)
{
  _BOOL8 result;

  if (TCFURLInfo::gRootlessEnabled
    && (TCFURLInfo::GetBooleanProperty(*this, (const __CFString *)*MEMORY[0x1E0C9ACA8], a3) & 1) != 0)
  {
    return 1;
  }
  result = TCFURLInfo::IsOnSystemVolume(this, a2);
  if ((_DWORD)result)
    return TCFURLInfo::gROSPState != 3;
  return result;
}

uint64_t TCFURLInfo::IsRootItem(TCFURLInfo **this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*this, (const __CFString *)*MEMORY[0x1E0C9AD38], a3);
}

uint64_t TCFURLInfo::IsLocalVolume(TCFURLInfo **this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*this, (const __CFString *)*MEMORY[0x1E0C9B6D8], a3);
}

uint64_t TCFURLInfo::RenameWithoutReplacing(const std::__fs::filesystem::path *this, const std::__fs::filesystem::path *a2, const char *a3)
{
  unsigned __int8 v5;
  TDSMutex *v6;
  std::error_code *v7;
  CFIndex v8;
  CFIndex v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFURL *NumericalProperty;
  const __CFString *v13;
  const __CFURL *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFURL *v17;
  const __CFString *v18;
  const __CFURL *v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  TDSMutex *v26;
  TCFURLInfo *v27;
  std::__shared_weak_count *v28;
  TCFURLInfo *v29;
  stat v30;

  if (strcmp((const char *)this, (const char *)a2))
  {
    if ((v5 & 1) == 0
    {
      v26 = (TDSMutex *)operator new();
      TDSMutex::TDSMutex(v26, 0);
      TCFURLInfo::RenameWithoutReplacing(char const*,char const*)::sLocalMutex = (uint64_t)v26;
    }
    v6 = (TDSMutex *)TCFURLInfo::RenameWithoutReplacing(char const*,char const*)::sLocalMutex;
    TDSMutex::lock((TDSMutex *)TCFURLInfo::RenameWithoutReplacing(char const*,char const*)::sLocalMutex);
    if (!lstat((const char *)a2, &v30))
    {
      v8 = strlen((const char *)this);
      v27 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)this, v8, 0);
      v9 = strlen((const char *)a2);
      v29 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)a2, v9, 0);
      v10 = (const __CFString *)*MEMORY[0x1E0C9AC50];
      NumericalProperty = TCFURLInfo::GetNumericalProperty(v27, (const __CFString *)*MEMORY[0x1E0C9AC50], v11);
      v14 = TCFURLInfo::GetNumericalProperty(v29, v10, v13);
      v15 = (const __CFString *)*MEMORY[0x1E0C9ADD0];
      v17 = TCFURLInfo::GetNumericalProperty(v27, (const __CFString *)*MEMORY[0x1E0C9ADD0], v16);
      v19 = TCFURLInfo::GetNumericalProperty(v29, v15, v18);
      if (NumericalProperty != v14 || v17 != v19)
      {
        *__error() = 17;
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v29);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v27);
        goto LABEL_19;
      }
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v29);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v27);
    }
    rename(this, a2, v7);
    v21 = v20;
    if ((v20 & 0x80000000) == 0 || *__error() != 18)
      goto LABEL_20;
    if ((copyfile((const char *)this, (const char *)a2, 0, 0x6800Fu) & 0x80000000) == 0)
    {
      _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v27);
      if (!TCFURLInfo::Initialize((TString *)v27, (const char *)this))
        TCFURLInfo::DeleteDeep((const void **)v27, 1, 1);
      v22 = v28;
      if (v28)
      {
        p_shared_owners = (unint64_t *)&v28->__shared_owners_;
        do
          v24 = __ldaxr(p_shared_owners);
        while (__stlxr(v24 - 1, p_shared_owners));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      goto LABEL_20;
    }
LABEL_19:
    v21 = 0xFFFFFFFFLL;
LABEL_20:
    TDSMutex::unlock(v6);
    return v21;
  }
  return 0;
}

void sub_1CBCB43B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1000C40FA0F61DDLL);
  _Unwind_Resume(a1);
}

TString *TCFURLInfo::SourcePathForResumableCopy@<X0>(TString *a1@<X8>)
{
  return TString::TString(a1, "");
}

BOOL TCFURLInfo::IsSuspendedCopyOfSource(TString *a1, const __CFURL ***a2, double *a3)
{
  const char *v6;
  const char *v7;
  ssize_t v8;
  const char *v9;
  const char *v10;
  uint64_t Inode;
  const char *v12;
  const char *v13;
  double v14;
  const char *v15;
  const char *v16;
  ssize_t v17;
  CFIndex v18;
  _BOOL8 v19;
  TString v21;
  CFStringRef theString;
  double v23;
  uint64_t value;
  UInt8 __s[256];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  *a3 = 0.0;
  value = 0;
  v6 = (const char *)TString::c_str(a1);
  v7 = (const char *)SourceInodeXattrName(0);
  v8 = getxattr(v6, v7, &value, 8uLL, 0, 1);
  if (v8 == -1)
  {
    v9 = (const char *)TString::c_str(a1);
    v10 = (const char *)SourceInodeXattrName(1);
    if (getxattr(v9, v10, &value, 8uLL, 0, 1) == -1)
      return 0;
  }
  Inode = TCFURLInfo::GetInode(*a2);
  if (Inode != value)
    return 0;
  v23 = 0.0;
  v12 = (const char *)TString::c_str(a1);
  v13 = (const char *)CheckPointXattrName();
  if (getxattr(v12, v13, &v23, 8uLL, 0, 1) != -1)
  {
    v14 = v23;
    if (v14 < CFAbsoluteTimeGetCurrent())
    {
      *a3 = v23;
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v15 = (const char *)TString::c_str(a1);
  v16 = (const char *)SourceVolumeUUIDXattrName(v8 == -1);
  v17 = getxattr(v15, v16, __s, 0x100uLL, 0, 1);
  if (v17 != -1)
  {
    __s[v17] = 0;
    TString::SetStringRefAsImmutable((TString *)&theString, 0);
    v18 = strlen((const char *)__s);
    TString::SetFromUTF8((TString *)&theString, __s, v18);
  }
  TCFURLInfo::VolumeUUID(*a2, &v21);
  if (CFStringGetLength(theString))
    v19 = CFEqual(v21.fString.fRef, theString) != 0;
  else
    v19 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v19;
}

void sub_1CBCB4674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::IsSuspendedCopyOfSource(TCFURLInfo **a1, const __CFURL ***a2, double *a3)
{
  _BOOL8 IsSuspendedCopyOfSource;
  CFStringRef theString;

  TCFURLInfo::FileSystemRepresentation(*a1, (const __CFURL *)1, (TString *)&theString);
  if (CFStringGetLength(theString))
    IsSuspendedCopyOfSource = TCFURLInfo::IsSuspendedCopyOfSource((TString *)&theString, a2, a3);
  else
    IsSuspendedCopyOfSource = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return IsSuspendedCopyOfSource;
}

void sub_1CBCB4710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::ModifiedAfterCheckPoint(CFURLRef *this, double a2, BOOL *a3)
{
  double v5;
  _BOOL8 v6;
  const void *v8;
  const void *propertyValueTypeRefPtr;

  *a3 = 0;
  propertyValueTypeRefPtr = 0;
  CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E0C9B3C0], &propertyValueTypeRefPtr, 0);
  v8 = propertyValueTypeRefPtr;
  v5 = MEMORY[0x1D17A4A1C](propertyValueTypeRefPtr);
  if (v5 < a2 + 120.0)
    *a3 = 1;
  v6 = v5 > a2;
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&v8);
  return v6;
}

void sub_1CBCB47B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TFileDescriptor::Close(TFileDescriptor *this)
{
  int v2;
  uint64_t result;
  const char *v4;
  int v5;

  v2 = *((_DWORD *)this + 2);
  if (v2 < 1)
    return 4294967242;
  result = close(v2);
  if ((_DWORD)result)
    result = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)result, 0, v4);
  if ((_DWORD)result)
    v5 = -1;
  else
    v5 = 0;
  *((_DWORD *)this + 2) = v5;
  return result;
}

uint64_t TCFURLInfo::CompareForMerge(uint64_t a1, CFURLRef **a2, CFComparisonResult *a3, uint64_t a4, char a5)
{
  CFComparisonResult v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFURL *NumericalProperty;
  const __CFString *v12;
  const __CFString *v13;
  const __CFURL *v14;
  const __CFURL **v15;
  const __CFString *v16;
  const __CFURL *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFURL *v20;
  const __CFString *v21;
  const __CFString *v22;
  int v23;
  CFURLRef *v24;
  const __CFString *v26;
  const __CFString *v27;

  v8 = TCFURLInfo::CheckDestinationModificationDates((CFURLRef *)a1, a2, a5);
  *a3 = v8;
  if (v8)
    return 0;
  v10 = (const __CFString *)*MEMORY[0x1E0C9AC58];
  NumericalProperty = TCFURLInfo::GetNumericalProperty(*(const __CFURL **)a1, (const __CFString *)*MEMORY[0x1E0C9AC58], v9);
  v12 = (const __CFString *)*MEMORY[0x1E0C9B4A8];
  v14 = (const __CFURL *)((char *)NumericalProperty
                        + (_QWORD)TCFURLInfo::GetNumericalProperty(*(const __CFURL **)a1, (const __CFString *)*MEMORY[0x1E0C9B4A8], v13));
  v15 = *a2;
  v17 = TCFURLInfo::GetNumericalProperty(**a2, v10, v16);
  if (v14 != (const __CFURL *)((char *)v17 + (_QWORD)TCFURLInfo::GetNumericalProperty(*v15, v12, v18)))
    return 0;
  v20 = TCFURLInfo::GetNumericalProperty(*(const __CFURL **)a1, v10, v19);
  if (v20 != TCFURLInfo::GetNumericalProperty(**a2, v10, v21))
    return 0;
  if (*(int *)(a1 + 72) <= 0)
    TCFURLInfo::FetchProperties((const void **)a1, 1);
  v23 = *(unsigned __int16 *)(a1 + 76) | (*(unsigned __int8 *)(a1 + 78) << 16);
  v24 = *a2;
  if (*((int *)*a2 + 18) <= 0)
    TCFURLInfo::FetchProperties((const void **)*a2, 1);
  if (((v23 ^ (*((unsigned __int16 *)v24 + 38) | (*((unsigned __int8 *)v24 + 78) << 16))) & 1) != 0)
    return 0;
  v26 = (const __CFString *)*MEMORY[0x1E0C9B6D8];
  if (TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)a1, (const __CFString *)*MEMORY[0x1E0C9B6D8], v22)
    && TCFURLInfo::GetBooleanProperty(**a2, v26, v27))
  {
    return TCFURLInfo::XattrsEqual((TCFURLInfo **)a1, a2);
  }
  else
  {
    return 1;
  }
}

uint64_t TCFURLInfo::GetMagicBusyCreationDate(TCFURLInfo *this)
{
  if (TCFURLInfo::GetMagicBusyCreationDate(void)::once != -1)
    dispatch_once(&TCFURLInfo::GetMagicBusyCreationDate(void)::once, &__block_literal_global_77);
  return TCFURLInfo::GetMagicBusyCreationDate(void)::magicBusyCreationDate;
}

CFDateRef ___ZN10TCFURLInfo24GetMagicBusyCreationDateEv_block_invoke()
{
  CFDateRef result;

  result = CFDateCreate(0, -534528000.0);
  TCFURLInfo::GetMagicBusyCreationDate(void)::magicBusyCreationDate = (uint64_t)result;
  return result;
}

uint64_t TCFURLInfo::CopyVolumeURL(CFURLRef *this)
{
  uint64_t propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E0C9B7E8], &propertyValueTypeRefPtr, 0);
  return propertyValueTypeRefPtr;
}

void Format<unsigned int,std::string>(const char *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  __int128 v7;

  *(_QWORD *)&v7 = a1;
  *((_QWORD *)&v7 + 1) = strlen(a1);
  FormatDetails<unsigned int,std::string>(&v7, a2, a3, a4);
}

BOOL TCFURLInfo::IsLockFile(CFURLRef *this)
{
  if (TCFURLInfo::GetCreationDate(this) == -534528000.0)
    return 1;
  if (*((int *)this + 18) <= 0)
    TCFURLInfo::FetchProperties((const void **)this, 1);
  return (*((_WORD *)this + 38) & 1) == 0 && TCFURLInfo::GetType(this) == 1651666795;
}

void TCFURLIterator::TCFURLIterator(TCFURLIterator *this, const TCFURLInfo *a2, const __CFArray *a3, char a4)
{
  std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo const&,void>(a2, this);
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = a3;
  if (a3)
    CFRetain(a3);
  *((_BYTE *)this + 72) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_BYTE *)this + 73) = a4;
  *((_BYTE *)this + 74) = 0;
}

void sub_1CBCB4B88(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void **v2;

  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(v2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

CFIndex TCFURLIterator::NextRaw(uint64_t a1, TString **a2)
{
  uint64_t v4;
  __CFError *v5;
  unsigned int v6;
  CFIndex v7;
  __CFURL *v9;
  TCFURLInfo *v10;

  v9 = 0;
  v10 = 0;
  v4 = MEMORY[0x1D17A4E00](*(_QWORD *)(a1 + 16), &v9, &v10);
  if (v4 == 1)
  {
    v7 = TCFURLInfo::Initialize(*a2, v9, 1, *(unsigned __int8 *)(a1 + 73));
  }
  else if (v4 == 3)
  {
    v6 = TCFURLInfo::TranslateCFError(v10, v5);
    if (v6 == -43)
      v7 = 4294959234;
    else
      v7 = v6;
  }
  else
  {
    v7 = 4294965879;
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v10);
  return v7;
}

void sub_1CBCB4C34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

uint64_t TDeepCFURLIterator::TDeepCFURLIterator(uint64_t a1, uint64_t a2, char a3, char a4, const void *a5, char a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char a11, char a12, char a13, uint64_t *a14, int a15)
{
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  const __CFURL ***v23;
  __int128 *v24;
  const __CFString *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  CFTypeRef *v30;
  __int128 cf;

  *(_QWORD *)(a1 + 8) = *(_QWORD *)a2;
  v20 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v20;
  if (v20)
  {
    v21 = (unint64_t *)(v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v30 = (CFTypeRef *)(a1 + 40);
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 48) = a6;
  *(_BYTE *)(a1 + 55) = a10;
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(_QWORD *)(a1 + 120) = a7;
  *(_QWORD *)(a1 + 128) = a8;
  *(_QWORD *)(a1 + 144) = 0;
  v23 = (const __CFURL ***)(a1 + 144);
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = &stru_1E8752DF8;
  v24 = (__int128 *)(a1 + 160);
  CFRetain(&stru_1E8752DF8);
  *(_QWORD *)(a1 + 168) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *(_OWORD *)(a1 + 176) = 0u;
  *(_QWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_QWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 232) = a15;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v30, a5);
  *(_BYTE *)(a1 + 216) = a11;
  *(_QWORD *)(a1 + 136) = a9;
  *(_BYTE *)(a1 + 217) = a3;
  *(_BYTE *)(a1 + 218) = a4;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 144), a14);
  if (*(_BYTE *)(a1 + 217) && *v23)
  {
    TCFURLInfo::FileSystemRepresentation(**(TCFURLInfo ***)a2, (const __CFURL *)1, (TString *)&cf);
    if (v24 != &cf)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 160), (const void **)&cf);
      CFRetain(&stru_1E8752DF8);
      if ((_QWORD)cf)
        CFRelease((CFTypeRef)cf);
      *(_QWORD *)&cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&cf);
    if (*v23)
      *(_QWORD *)(a1 + 224) = TCFURLInfo::GetNumericalProperty(**v23, (const __CFString *)*MEMORY[0x1E0C9B708], v25);
  }
  TCFURLInfo::Name(*(TCFURLInfo **)a2, (TString *)&cf);
  if ((__int128 *)(a1 + 168) != &cf)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 168), (const void **)&cf);
    CFRetain(&stru_1E8752DF8);
    if ((_QWORD)cf)
      CFRelease((CFTypeRef)cf);
    *(_QWORD *)&cf = &stru_1E8752DF8;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&cf);
  cf = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 200, &cf);
  v26 = (std::__shared_weak_count *)*((_QWORD *)&cf + 1);
  if (*((_QWORD *)&cf + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&cf + 1) + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 219) = a12;
  *(_BYTE *)(a1 + 220) = a13;
  TDeepCFURLIterator::Reset((TDeepCFURLIterator *)a1);
  return a1;
}

{
  return TDeepCFURLIterator::TDeepCFURLIterator(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_1CBCB5014(_Unwind_Exception *a1, void **a2, uint64_t a3, uint64_t a4, const void **a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void **v8;
  const void **v9;
  void *v11;
  va_list va;

  va_start(va, a5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a4);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v8);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v7);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v6 + 72);
  v11 = *a2;
  if (*a2)
  {
    *(_QWORD *)(v5 + 80) = v11;
    operator delete(v11);
  }
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(a5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v6);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a3);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::Reset(TDeepCFURLIterator *this)
{
  uint64_t v2;
  uint64_t v3;
  const void ***v4;
  uint64_t v5;
  TCFURLIterator *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  const void **v10;
  __int16 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  TCloneCache *v16;
  uint64_t result;
  const void **v18;
  const void **v19;
  __int128 v20;

  v2 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    *(_QWORD *)&v20 = v2 + 40;
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v2 + 16));
    v3 = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
    MEMORY[0x1D17A53D0](v3, 0x1060C40FBA2130BLL);
  }
  v4 = (const void ***)((char *)this + 8);
  v5 = *((_QWORD *)this + 1);
  if (*(int *)(v5 + 72) <= 0)
    TCFURLInfo::FetchProperties(*((const void ***)this + 1), 1);
  if ((*(_WORD *)(v5 + 76) & 1) != 0)
  {
    v6 = (TCFURLIterator *)operator new();
    TCFURLIterator::TCFURLIterator(v6, *((const TCFURLInfo **)this + 1), *((const __CFArray **)this + 5), *((_BYTE *)this + 216));
  }
  else
  {
    v6 = 0;
  }
  *(_QWORD *)this = v6;
  if (*((_BYTE *)this + 218))
  {
    if (*((_QWORD *)this + 18))
    {
      TDeepCFURLIterator::CreateDestinationListForSource((uint64_t)this, (TCFURLInfo ***)this + 1, (uint64_t **)&v20);
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 200, &v20);
      v7 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
      if (*((_QWORD *)&v20 + 1))
      {
        v8 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
  v10 = *v4;
  if (*((int *)*v4 + 18) <= 0)
    TCFURLInfo::FetchProperties(*v4, 1);
  v11 = *((_WORD *)v10 + 38);
  *((_BYTE *)this + 49) = (v11 & 4) != 0;
  *((_BYTE *)this + 52) = 0;
  *((_BYTE *)this + 54) = 0;
  if ((v11 & 4) != 0)
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)this + 12, (uint64_t *)this + 1);
  v20 = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)this + 24, &v20);
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  *((_WORD *)this + 29) = *((unsigned __int8 *)this + 49);
  *((_WORD *)this + 30) = *((unsigned __int8 *)this + 52);
  *((_WORD *)this + 31) = *((unsigned __int8 *)this + 54);
  *((_WORD *)this + 32) = 1;
  *((_WORD *)this + 25) = 0;
  *((_BYTE *)this + 53) = 0;
  v15 = (_QWORD *)*((_QWORD *)this + 15);
  if (v15)
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(v15);
  v16 = (TCloneCache *)*((_QWORD *)this + 16);
  if (v16)
    TCloneCache::RemoveAll(v16);
  result = (uint64_t)TDeepCFURLIterator::ResetReservationStack(this);
  if (*((_BYTE *)this + 217))
  {
    if (*((_QWORD *)this + 18))
    {
      LOBYTE(v20) = 1;
      if (*((_BYTE *)this + 55))
      {
        if (!*((_BYTE *)this + 56))
        {
          v18 = *v4;
          if (*((int *)*v4 + 18) <= 0)
            result = TCFURLInfo::FetchProperties(*v4, 1);
          if ((*((_WORD *)v18 + 38) & 1) != 0)
          {
            result = TCFURLInfo::EffectiveUserCanRead(*v4, (BOOL *)&v20);
            if (!(_DWORD)result)
              goto LABEL_39;
            v19 = *v4;
            if (*((int *)v19 + 18) <= 1)
              result = TCFURLInfo::FetchProperties(v19, 1);
            if ((*((_WORD *)v19 + 38) & 0x4000) == 0)
LABEL_39:
              *((_BYTE *)this + 56) = 1;
          }
        }
      }
    }
  }
  return result;
}

void sub_1CBCB5350(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1060C40FBA2130BLL);
  _Unwind_Resume(a1);
}

void TDeepCFURLIterator::~TDeepCFURLIterator(TDeepCFURLIterator *this)
{
  void *v2;
  void **v3;

  TDeepCFURLIterator::DestroyIterators((uint64_t *)this);
  TDeepCFURLIterator::ResetReservationStack(this);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 200);
  v3 = (void **)((char *)this + 176);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 21);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 20);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 144);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)this + 5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t *TDeepCFURLIterator::DestroyIterators(uint64_t *this)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;

  v1 = this;
  v2 = *this;
  if (*this)
  {
    v9 = (void **)(v2 + 40);
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v9);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v2 + 16));
    v3 = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
    this = (uint64_t *)MEMORY[0x1D17A53D0](v3, 0x1060C40FBA2130BLL);
  }
  *v1 = 0;
  v5 = v1[9];
  v4 = v1[10];
  if (v4 != v5)
  {
    do
    {
      v7 = *(_QWORD *)(v4 - 8);
      v4 -= 8;
      v6 = v7;
      if (v7)
      {
        v9 = (void **)(v6 + 40);
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v9);
        TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v6 + 32));
        TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v6 + 16));
        v8 = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v6);
        this = (uint64_t *)MEMORY[0x1D17A53D0](v8, 0x1060C40FBA2130BLL);
      }
    }
    while (v4 != v5);
    v4 = v1[9];
  }
  v1[10] = v4;
  return this;
}

_QWORD *TDeepCFURLIterator::ResetReservationStack(TDeepCFURLIterator *this)
{
  _QWORD *result;
  uint64_t v3;
  TReservationRecord *v4;

  result = (_QWORD *)*((_QWORD *)this + 17);
  if (result)
  {
    while (1)
    {
      v3 = result[5];
      if (!v3)
        break;
      v4 = *(TReservationRecord **)(*(_QWORD *)(result[1]
                                              + (((unint64_t)(v3 + result[4] - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                                  + 8 * ((v3 + result[4] - 1) & 0x1FF));
      if (!v4)
        break;
      result[5] = v3 - 1;
      std::deque<TReservationRecord *>::__maybe_remove_back_spare[abi:ne180100](result, 1);
      TReservationRecord::~TReservationRecord(v4);
      MEMORY[0x1D17A53D0]();
      result = (_QWORD *)*((_QWORD *)this + 17);
    }
  }
  return result;
}

void TCFURLIterator::~TCFURLIterator(const void **this)
{
  void **v2;

  v2 = (void **)(this + 5);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v2);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(this + 4);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(this + 2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void TDeepCFURLIterator::CreateDestinationListForSource(uint64_t a1@<X0>, TCFURLInfo ***a2@<X1>, uint64_t **a3@<X8>)
{
  uint64_t *v6;
  const void **v7;
  int v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  __int128 v23;
  _BYTE v24[8];
  std::__shared_weak_count *v25;
  const void *v26;
  const void *v27;
  uint64_t v28;
  const void **v29;
  std::__shared_weak_count *v30;

  v6 = (uint64_t *)operator new(0x30uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = (uint64_t)&unk_1E87505E0;
  v6[4] = 0;
  v6[5] = 0;
  a3[1] = v6;
  v6[3] = 0;
  *a3 = v6 + 3;
  if (CFStringGetLength(*(CFStringRef *)(a1 + 160)))
  {
    TDeepCFURLIterator::MapSourceToDestination(a1, a2, (uint64_t)&v29);
    v7 = v29;
    if (v29)
    {
      if (*((int *)v29 + 18) <= 0)
        TCFURLInfo::FetchProperties(v29, 1);
      if ((*((_WORD *)v7 + 38) & 1) != 0)
      {
        TCFURLIterator::TCFURLIterator((TCFURLIterator *)v24, (const TCFURLInfo *)v29, *(const __CFArray **)(a1 + 40), 1);
        do
        {
          while (1)
          {
            _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v23);
            v8 = TCFURLIterator::Next((uint64_t)v24, (TString **)&v23);
            if (!v8)
            {
              v9 = v23;
              if (*(int *)(v23 + 72) <= 0)
                TCFURLInfo::FetchProperties((const void **)v23, 1);
              if ((*(_WORD *)(v9 + 76) & 0x20) != 0)
                std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)*a3, &v23);
            }
            v10 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
            if (*((_QWORD *)&v23 + 1))
            {
              v11 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
              do
                v12 = __ldaxr(v11);
              while (__stlxr(v12 - 1, v11));
              if (!v12)
                break;
            }
            if (v8)
              goto LABEL_19;
          }
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        while (!v8);
LABEL_19:
        v13 = **a3;
        v14 = (*a3)[1];
        v15 = 126 - 2 * __clz((uint64_t)(v14 - v13) >> 4);
        if (v14 == v13)
          v16 = 0;
        else
          v16 = v15;
        std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>(v13, v14, v16, 1);
        *(_QWORD *)&v23 = &v28;
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v23);
        TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v27);
        TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(&v26);
        v17 = v25;
        if (v25)
        {
          p_shared_owners = (unint64_t *)&v25->__shared_owners_;
          do
            v19 = __ldaxr(p_shared_owners);
          while (__stlxr(v19 - 1, p_shared_owners));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
    }
    v20 = v30;
    if (v30)
    {
      v21 = (unint64_t *)&v30->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
  }
}

void sub_1CBCB5810(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2 - 56);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::CurrentContainerInfo@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 32);
  *a2 = *(_QWORD *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t TDeepCFURLIterator::Cancel(uint64_t this)
{
  uint64_t *v1;
  uint64_t *i;
  uint64_t v3;

  *(_BYTE *)(this + 112) = 1;
  if (*(_QWORD *)this)
    *(_BYTE *)(*(_QWORD *)this + 72) = 1;
  v1 = *(uint64_t **)(this + 72);
  for (i = *(uint64_t **)(this + 80); v1 != i; *(_BYTE *)(v3 + 72) = 1)
    v3 = *v1++;
  return this;
}

uint64_t TDeepCFURLIterator::PushIterator(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  TCFURLInfo *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  __int16 v8;
  TReservationRecord *v9;
  const __CFString *v10;
  unint64_t v11;
  TReservationRecord *v12;
  uint64_t v13;
  __int16 v14;
  BOOL IsTrash;
  __int16 v16;
  TCFURLInfo *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  TCFURLInfo *v32;
  TCFURLIterator *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  TReservationRecord *v41[2];
  BOOL v42;
  TCFURLInfo *v43;
  std::__shared_weak_count *v44;

  v5 = *(TCFURLInfo **)a2;
  v4 = *(std::__shared_weak_count **)(a2 + 8);
  v43 = *(TCFURLInfo **)a2;
  v44 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = *(_WORD *)(a1 + 58);
  if (!v8)
  {
    if (*((int *)v5 + 18) <= 0)
      TCFURLInfo::FetchProperties((const void **)v5, 1);
    if ((*((_WORD *)v5 + 38) & 4) != 0)
      goto LABEL_10;
    v8 = *(_WORD *)(a1 + 58);
  }
  if (v8 < 1)
  {
LABEL_29:
    v14 = *(_WORD *)(a1 + 60);
    if (!v14 && (IsTrash = TCFURLInfo::IsTrash(v43), v14 = *(_WORD *)(a1 + 60), IsTrash) || v14 >= 1)
      *(_WORD *)(a1 + 60) = v14 + 1;
    v16 = *(_WORD *)(a1 + 62);
    if (!v16
      && ((v17 = v43, *((int *)v43 + 18) <= 0)
        ? (TCFURLInfo::FetchProperties((const void **)v43, 1), v16 = *(_WORD *)(a1 + 62))
        : (v16 = 0),
          (*((_WORD *)v17 + 38) & 0x20) == 0)
      || v16 >= 1)
    {
      *(_WORD *)(a1 + 62) = v16 + 1;
    }
    v18 = *(_QWORD *)(a1 + 88);
    ++*(_WORD *)(a1 + 64);
    v19 = *(_QWORD **)(a1 + 80);
    if ((unint64_t)v19 >= v18)
    {
      v21 = *(_QWORD *)(a1 + 72);
      v22 = ((uint64_t)v19 - v21) >> 3;
      if ((unint64_t)(v22 + 1) >> 61)
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      v23 = v18 - v21;
      v24 = v23 >> 2;
      if (v23 >> 2 <= (unint64_t)(v22 + 1))
        v24 = v22 + 1;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v25 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v25 = v24;
      if (v25)
        v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(a1 + 88, v25);
      else
        v26 = 0;
      v27 = &v26[8 * v22];
      v28 = &v26[8 * v25];
      *(_QWORD *)v27 = *(_QWORD *)a1;
      v20 = v27 + 8;
      v30 = *(char **)(a1 + 72);
      v29 = *(char **)(a1 + 80);
      if (v29 != v30)
      {
        do
        {
          v31 = *((_QWORD *)v29 - 1);
          v29 -= 8;
          *((_QWORD *)v27 - 1) = v31;
          v27 -= 8;
        }
        while (v29 != v30);
        v29 = *(char **)(a1 + 72);
      }
      *(_QWORD *)(a1 + 72) = v27;
      *(_QWORD *)(a1 + 80) = v20;
      *(_QWORD *)(a1 + 88) = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *v19 = *(_QWORD *)a1;
      v20 = v19 + 1;
    }
    *(_QWORD *)(a1 + 80) = v20;
    v42 = 1;
    if (*(_BYTE *)(a1 + 217) && *(_QWORD *)(a1 + 144) && *(_BYTE *)(a1 + 55) && !*(_BYTE *)(a1 + 56))
    {
      if (!TCFURLInfo::EffectiveUserCanRead((const void **)v43, &v42))
        goto LABEL_83;
      v32 = v43;
      if (*((int *)v43 + 18) <= 1)
        TCFURLInfo::FetchProperties((const void **)v43, 1);
      if ((*((_WORD *)v32 + 38) & 0x4000) == 0)
      {
LABEL_83:
        if (!*(_WORD *)(a1 + 60))
          *(_BYTE *)(a1 + 56) = 1;
      }
    }
    v33 = (TCFURLIterator *)operator new();
    TCFURLIterator::TCFURLIterator(v33, v43, *(const __CFArray **)(a1 + 40), *(_BYTE *)(a1 + 216));
    *(_QWORD *)a1 = v33;
    if (*(_BYTE *)(a1 + 218))
    {
      if (*(_QWORD *)(a1 + 144))
      {
        std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((char **)(a1 + 176), (__int128 *)(a1 + 200));
        TDeepCFURLIterator::CreateDestinationListForSource(a1, (TCFURLInfo ***)a2, (uint64_t **)v41);
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 200, (__int128 *)v41);
        v34 = (std::__shared_weak_count *)v41[1];
        if (v41[1])
        {
          v35 = (unint64_t *)((char *)v41[1] + 8);
          do
            v36 = __ldaxr(v35);
          while (__stlxr(v36 - 1, v35));
          if (!v36)
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
      }
    }
    v13 = 0;
    goto LABEL_74;
  }
LABEL_10:
  if (!*(_QWORD *)(a1 + 136))
  {
LABEL_25:
    v13 = 0;
    goto LABEL_26;
  }
  v9 = (TReservationRecord *)operator new();
  TReservationRecord::TReservationRecord(v9, (uint64_t *)a2);
  v41[0] = v9;
  if (!*(_BYTE *)(a1 + 220))
    goto LABEL_16;
  if (*((int *)v43 + 18) <= 0)
    TCFURLInfo::FetchProperties((const void **)v43, 1);
  if (((*((unsigned __int16 *)v43 + 38) | (*((unsigned __int8 *)v43 + 78) << 16)) & 0x40000) != 0)
LABEL_16:
    LOBYTE(v11) = 1;
  else
    v11 = ((unint64_t)TCFURLInfo::GetNumericalProperty(*(const __CFURL **)v43, (const __CFString *)*MEMORY[0x1E0C9AC48], v10) >> 30) & 1;
  if (!*(_BYTE *)(a1 + 219) || (v11 & 1) == 0)
  {
    v12 = v41[0];
LABEL_24:
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](&v43, (uint64_t *)v12 + 1);
    std::deque<TReservationRecord *>::push_back(*(_QWORD **)(a1 + 136), v41);
    goto LABEL_25;
  }
  v12 = v41[0];
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 136) + 48))
    goto LABEL_24;
  v13 = TReservationRecord::CreateAndAcquireFileCoordinator(v41[0], *(NSFileCoordinator **)(*(_QWORD *)(a1 + 136) + 48));
  v12 = v41[0];
  if (!(_DWORD)v13)
    goto LABEL_24;
  if (v41[0])
  {
    TReservationRecord::~TReservationRecord(v41[0]);
    MEMORY[0x1D17A53D0]();
  }
LABEL_26:
  if (!*(_QWORD *)(a1 + 96))
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 96), (uint64_t *)&v43);
  ++*(_WORD *)(a1 + 58);
  if (!(_DWORD)v13)
    goto LABEL_29;
LABEL_74:
  v37 = v44;
  if (v44)
  {
    v38 = (unint64_t *)&v44->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  return v13;
}

void sub_1CBCB5D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::Next(uint64_t a1, TCFURLInfo **a2, _DWORD *a3, _DWORD *a4, BOOL *a5, _BYTE *a6, uint64_t a7, _BYTE *a8, _QWORD *a9)
{
  uint64_t result;
  BOOL v18;
  BOOL v19;
  TString v20;
  TString v21;
  TString v22;
  TString v23;

  result = TDeepCFURLIterator::NextInternal(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
  if (*(_BYTE *)(a1 + 48))
    v18 = (_DWORD)result == 0;
  else
    v18 = 0;
  if (v18)
  {
    while (TCFURLInfo::IsTrash(*a2) || *(_BYTE *)(a1 + 53))
    {
      result = TDeepCFURLIterator::NextInternal(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
      if ((_DWORD)result)
        return result;
    }
    while (*(_DWORD *)(a1 + 232) == 3)
    {
      TCFURLInfo::Name(*a2, &v23);
      TString::TString(&v22, ".com.apple.backupd.mvlist.plist", 0x1FuLL);
      if (CFEqual(v23.fString.fRef, v22.fString.fRef))
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
      }
      else
      {
        TCFURLInfo::Name(*a2, &v21);
        TString::TString(&v20, ".com.apple.backupd.mdmv", 0x17uLL);
        v19 = TString::BeginsWith(&v21, &v20);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
        if (!v19)
          return 0;
      }
      result = TDeepCFURLIterator::NextInternal(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
      if ((_DWORD)result)
        return result;
    }
    return 0;
  }
  return result;
}

void sub_1CBCB5F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  const void *v6;
  va_list va1;
  const void *v8;
  va_list va2;
  va_list va3;

  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v8 = va_arg(va3, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::NextInternal(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, BOOL *a5, _BYTE *a6, uint64_t a7, _BYTE *a8, _QWORD *a9)
{
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  const void **v25;
  int v26;
  TString *v27;
  const __CFString *v28;
  TString *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  int v39;
  TString *v40;
  __int16 v41;
  _DWORD *v42;
  BOOL *v43;
  _BYTE *v44;
  int IsClone;
  TString *v46;
  TString *v47;
  std::__shared_weak_count *v48;
  unint64_t *p_shared_owners;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  _QWORD *v58;
  uint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  uint64_t v68;
  BOOL *v69;
  _DWORD *v70;
  TString *v71;
  std::__shared_weak_count *v72;
  BOOL v73;
  unint64_t v74;
  __int128 v75;

  v75 = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a7, &v75);
  v17 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v75 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  *a8 = 0;
  v75 = 0uLL;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a9, &v75);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v75 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = *(uint64_t **)a1;
  if (!*(_QWORD *)a1)
    goto LABEL_77;
  v68 = a7;
  v69 = a5;
  v70 = a3;
  while (1)
  {
    *(_BYTE *)(a1 + 50) = *(__int16 *)(a1 + 58) > 0;
    *(_BYTE *)(a1 + 53) = *(__int16 *)(a1 + 60) > 0;
    *(_BYTE *)(a1 + 51) = *(__int16 *)(a1 + 62) > 0;
    v24 = TCFURLIterator::Next((uint64_t)v23, (TString **)a2);
    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 24), *(uint64_t **)a1);
    if ((_DWORD)v24)
    {
      if (!*a9 && !*(_BYTE *)(a1 + 50))
      {
        v30 = *(_QWORD *)(a1 + 200);
        if (!v30 || (v31 = *(uint64_t **)v30, *(_QWORD *)v30 == *(_QWORD *)(v30 + 8)))
        {
          v75 = 0uLL;
        }
        else
        {
          v33 = *v31;
          v32 = v31[1];
          *(_QWORD *)&v75 = v33;
          *((_QWORD *)&v75 + 1) = v32;
          if (v32)
          {
            v34 = (unint64_t *)(v32 + 8);
            do
              v35 = __ldxr(v34);
            while (__stxr(v35 + 1, v34));
          }
        }
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a9, &v75);
        v36 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
        if (*((_QWORD *)&v75 + 1))
        {
          v37 = (unint64_t *)(*((_QWORD *)&v75 + 1) + 8);
          do
            v38 = __ldaxr(v37);
          while (__stlxr(v38 - 1, v37));
          if (!v38)
          {
            ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
            std::__shared_weak_count::__release_weak(v36);
          }
        }
      }
      TDeepCFURLIterator::PopIterator(a1);
      ++*a4;
      *a8 = 1;
      goto LABEL_27;
    }
    TDeepCFURLIterator::RecordHardlink(*(_QWORD *)(a1 + 120), (const void ***)a2, (const __CFString *)*(unsigned int *)(a1 + 232));
    v25 = *(const void ***)(a1 + 128);
    v26 = *(_DWORD *)(a1 + 232);
    v27 = *(TString **)a2;
    if (*(int *)(*(_QWORD *)a2 + 72) <= 0)
      TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
    TDeepCFURLIterator::RecordClone(v25, (uint64_t *)a2, v26 == 1, WORD2(v27[9].fString.fRef) >> 15);
    v29 = *(TString **)a2;
    if (*(int *)(*(_QWORD *)a2 + 72) <= 0)
      TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
    if ((WORD2(v29[9].fString.fRef) & 1) == 0
      || !TCFURLInfo::ShouldSkip(*(const void ***)a2, *(_QWORD *)(a1 + 224), 0)
      && (!*(_BYTE *)(a1 + 48) || !TCFURLInfo::IsTrash(*(TCFURLInfo **)a2) && !*(_BYTE *)(a1 + 53)))
    {
      break;
    }
    v24 = 4294965879;
LABEL_27:
    v23 = *(uint64_t **)a1;
    if (!*(_QWORD *)a1 || (_DWORD)v24 != -1417)
      goto LABEL_76;
  }
  if ((uint64_t)TCFURLInfo::GetNumericalProperty(**(const __CFURL ***)a2, (const __CFString *)*MEMORY[0x1E0C9B570], v28) < 2)
  {
    v43 = v69;
    v42 = v70;
    *v69 = 0;
    v74 = 0;
    v73 = 0;
    v40 = *(TString **)a2;
    v44 = a6;
    goto LABEL_46;
  }
  LOBYTE(v39) = 0;
  v40 = *(TString **)a2;
  v41 = *(_WORD *)(*(_QWORD *)a2 + 76);
  v43 = v69;
  v42 = v70;
  *v69 = (v41 & 0x200) != 0;
  v74 = 0;
  v73 = 0;
  v44 = a6;
  if ((v41 & 0x200) == 0)
  {
LABEL_46:
    if (SLODWORD(v40[9].fString.fRef) <= 0)
      TCFURLInfo::FetchProperties((const void **)&v40->fString.fRef, 1);
    if ((WORD2(v40[9].fString.fRef) & 1) != 0)
    {
      LOBYTE(v39) = 0;
    }
    else
    {
      IsClone = TCFURLInfo::IsClone(*(const void ***)a2, &v74, &v73);
      LOBYTE(v39) = 0;
      if (IsClone && v73)
        v39 = (*(unsigned __int8 *)(*(_QWORD *)a2 + 78) >> 4) & 1;
    }
  }
  *v44 = v39;
  if (*(_BYTE *)(a1 + 218))
  {
    if (*(_QWORD *)(a1 + 144))
    {
      if (!*(_BYTE *)(a1 + 50))
      {
        TCFURLInfoList::FindAndRemove(*(_QWORD *)(a1 + 200), (TCFURLInfo **)a2, &v75);
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v68, &v75);
        v62 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
        if (*((_QWORD *)&v75 + 1))
        {
          v63 = (unint64_t *)(*((_QWORD *)&v75 + 1) + 8);
          do
            v64 = __ldaxr(v63);
          while (__stlxr(v64 - 1, v63));
          if (!v64)
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
        }
      }
    }
  }
  v46 = *(TString **)a2;
  if (*(int *)(*(_QWORD *)a2 + 72) <= 0)
    TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
  v24 = 0;
  if ((WORD2(v46[9].fString.fRef) & 1) != 0 && !*v43)
  {
    v47 = *(TString **)a2;
    if (*(int *)(*(_QWORD *)a2 + 72) <= 0)
      TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
    if ((WORD2(v47[9].fString.fRef) & 0x80) != 0 || !*(_QWORD *)a1)
    {
      v24 = 0;
    }
    else
    {
      v48 = *(std::__shared_weak_count **)(a2 + 8);
      v71 = *(TString **)a2;
      v72 = v48;
      if (v48)
      {
        p_shared_owners = (unint64_t *)&v48->__shared_owners_;
        do
          v50 = __ldxr(p_shared_owners);
        while (__stxr(v50 + 1, p_shared_owners));
      }
      v24 = TDeepCFURLIterator::PushIterator(a1, (uint64_t)&v71);
      v51 = v72;
      if (v72)
      {
        v52 = (unint64_t *)&v72->__shared_owners_;
        do
          v53 = __ldaxr(v52);
        while (__stlxr(v53 - 1, v52));
        if (!v53)
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
        }
      }
      if (!(_DWORD)v24)
        ++*v42;
    }
  }
  v54 = *(_QWORD *)a2 + 76;
  v55 = *(_WORD *)v54 & 0xFBFF | (*(unsigned __int8 *)(*(_QWORD *)a2 + 78) << 16) | (*(unsigned __int8 *)(a1 + 50) << 10);
  *(_WORD *)v54 = *(_WORD *)v54 & 0xFBFF | (*(unsigned __int8 *)(a1 + 50) << 10);
  *(_BYTE *)(v54 + 2) = BYTE2(v55);
LABEL_76:
  if ((_DWORD)v24 == -1417)
  {
LABEL_77:
    v56 = *(_QWORD *)(a1 + 200);
    if (v56)
    {
      *a8 = 1;
      if (!*a9 && !*(_BYTE *)(a1 + 50))
      {
        v58 = *(_QWORD **)v56;
        if (*(_QWORD *)v56 == *(_QWORD *)(v56 + 8))
        {
          v75 = 0uLL;
        }
        else
        {
          v59 = v58[1];
          *(_QWORD *)&v75 = *v58;
          *((_QWORD *)&v75 + 1) = v59;
          if (v59)
          {
            v60 = (unint64_t *)(v59 + 8);
            do
              v61 = __ldxr(v60);
            while (__stxr(v61 + 1, v60));
          }
        }
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)a9, &v75);
        v65 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
        if (*((_QWORD *)&v75 + 1))
        {
          v66 = (unint64_t *)(*((_QWORD *)&v75 + 1) + 8);
          do
            v67 = __ldaxr(v66);
          while (__stlxr(v67 - 1, v66));
          if (!v67)
          {
            ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }
        }
      }
    }
    return 4294965879;
  }
  return v24;
}

void sub_1CBCB651C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::PopIterator(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;
  int v9;
  const void ***v10;
  uint64_t v11;
  const void **v12;
  TCFURLInfo *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  TReservationRecord *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  __int128 v22;

  v1 = this;
  v2 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    *(_QWORD *)&v22 = v2 + 40;
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v22);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v2 + 16));
    v3 = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
    this = MEMORY[0x1D17A53D0](v3, 0x1060C40FBA2130BLL);
  }
  v4 = *(_QWORD *)(v1 + 80);
  if (*(_QWORD *)(v1 + 72) == v4)
  {
    *(_QWORD *)v1 = 0;
  }
  else
  {
    v5 = *(__int16 *)(v1 + 60);
    v6 = __OFSUB__(v5, 1);
    v7 = v5 - 1;
    if (v7 < 0 == v6)
      *(_WORD *)(v1 + 60) = v7;
    v8 = *(__int16 *)(v1 + 62);
    v6 = __OFSUB__(v8, 1);
    v9 = v8 - 1;
    if (v9 < 0 == v6)
      *(_WORD *)(v1 + 62) = v9;
    v10 = *(const void ****)(v4 - 8);
    *(_QWORD *)v1 = v10;
    *(_QWORD *)(v1 + 80) = v4 - 8;
    v11 = *(_QWORD *)(v1 + 184);
    if (*(_QWORD *)(v1 + 176) != v11)
    {
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(v1 + 200), (uint64_t *)(v11 - 16));
      this = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](*(_QWORD *)(v1 + 184) - 16);
      *(_QWORD *)(v1 + 184) = this;
      v10 = *(const void ****)v1;
    }
    if (v10)
    {
      v12 = *v10;
      v13 = (TCFURLInfo *)*v10;
      if (*((int *)*v10 + 18) <= 0)
      {
        TCFURLInfo::FetchProperties(*v10, 1);
        v13 = **(TCFURLInfo ***)v1;
      }
      *(_BYTE *)(v1 + 49) = (*((_BYTE *)v12 + 76) & 4) != 0;
      this = TCFURLInfo::IsTrash(v13);
      *(_BYTE *)(v1 + 52) = this;
      --*(_WORD *)(v1 + 64);
    }
    else
    {
      *(_BYTE *)(v1 + 49) = 0;
      *(_BYTE *)(v1 + 52) = 0;
    }
    v14 = *(__int16 *)(v1 + 58);
    v6 = __OFSUB__(v14, 1);
    v15 = v14 - 1;
    if (v15 < 0 == v6)
    {
      *(_WORD *)(v1 + 58) = v15;
      if (!(_WORD)v15)
      {
        v22 = 0uLL;
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v1 + 96, &v22);
        v19 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
        if (*((_QWORD *)&v22 + 1))
        {
          v20 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
      }
      this = *(_QWORD *)(v1 + 136);
      if (this)
      {
        v16 = *(_QWORD *)(this + 40);
        if (v16)
        {
          v17 = v16 - 1;
          v18 = *(TReservationRecord **)(*(_QWORD *)(*(_QWORD *)(this + 8)
                                                   + (((unint64_t)(*(_QWORD *)(this + 32) + v17) >> 6) & 0x3FFFFFFFFFFFFF8))
                                       + 8 * ((*(_QWORD *)(this + 32) + v17) & 0x1FF));
          *(_QWORD *)(this + 40) = v17;
          this = std::deque<TReservationRecord *>::__maybe_remove_back_spare[abi:ne180100]((_QWORD *)this, 1);
          if (v18)
          {
            TReservationRecord::~TReservationRecord(v18);
            return MEMORY[0x1D17A53D0]();
          }
        }
      }
    }
  }
  return this;
}

uint64_t TDeepCFURLIterator::RecordHardlink(uint64_t result, const void ***a2, const __CFString *a3)
{
  const void **v4;
  uint64_t v5;
  unsigned int v6;
  const __CFString *v7;
  const void **v8;
  char v9;
  char v10;
  const __CFString *v11;
  char *v12;
  int v13;
  unsigned int v14;
  uint64_t ObjectIdentifier;

  if (result)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = result;
      v6 = a3 & 0xFFFFFFFB;
      if (*((int *)v4 + 18) <= 0)
        result = TCFURLInfo::FetchProperties(*a2, 1);
      if (v6 == 2 || (*((_WORD *)v4 + 38) & 1) == 0)
      {
        v7 = (const __CFString *)*MEMORY[0x1E0C9B570];
        result = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)**a2, (const __CFString *)*MEMORY[0x1E0C9B570], a3);
        if (result >= 2)
        {
          ObjectIdentifier = TCFURLInfo::GetObjectIdentifier((TCFURLInfo *)*a2);
          v8 = *a2;
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(v5, (unint64_t *)&ObjectIdentifier, &ObjectIdentifier);
          v10 = v9;
          result = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)*v8, v7, v11);
          if (result >= 2)
          {
            v13 = *((unsigned __int16 *)v8 + 38);
            v12 = (char *)v8 + 76;
            v14 = v13 & 0xFFFFFDFF | (v12[2] << 16);
            v12[2] = BYTE2(v14);
            *(_WORD *)v12 = (v14 | ((v10 & 1) << 9)) ^ 0x200;
          }
        }
      }
    }
  }
  return result;
}

const void **TDeepCFURLIterator::RecordClone(const void **result, uint64_t *a2, int a3, char a4)
{
  TCloneCache *v5;
  const __CFString *v8;
  _BOOL4 HasCloneID;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unint64_t v16;

  if (result)
  {
    v5 = (TCloneCache *)result;
    result = (const void **)*a2;
    if (*a2)
    {
      v16 = 0;
      result = (const void **)TCFURLInfo::IsClone(result, &v16, 0);
      if ((_DWORD)result)
      {
        if ((!a3
           || (result = (const void **)TCFURLInfo::GetNumericalProperty(*(const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E0C9B4A8], v8)) != 0)&& (a4 & 1) == 0)
        {
          HasCloneID = TCloneCache::HasCloneID(v5, &v16);
          if (!HasCloneID)
            TCloneCache::RecordClone(v5, &v16, a2);
          v10 = *a2;
          result = (const void **)TCFURLInfo::IsClone((const void **)v10, 0, 0);
          if ((_DWORD)result)
          {
            v12 = *(unsigned __int16 *)(v10 + 76);
            v11 = v10 + 76;
            v13 = v12 | (*(unsigned __int8 *)(v11 + 2) << 16);
            if (HasCloneID)
              v14 = 0x100000;
            else
              v14 = 0;
            v15 = v13 & 0xFFEFFFFF;
            *(_WORD *)v11 = v15;
            *(_BYTE *)(v11 + 2) = (v15 | v14) >> 16;
          }
        }
      }
    }
  }
  return result;
}

uint64_t TCFURLInfoList::FindAndRemove@<X0>(uint64_t result@<X0>, TCFURLInfo **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  TCFURLInfo **v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  TString v15;
  TString v16;

  v4 = result;
  *a3 = 0;
  a3[1] = 0;
  v7 = *(_QWORD *)result;
  v6 = *(_QWORD *)(result + 8);
  v8 = v6 - *(_QWORD *)result;
  if (v8 >= 1)
  {
    v9 = (unint64_t)v8 >> 4;
    do
    {
      v10 = (TCFURLInfo **)(v7 + 16 * (v9 >> 1));
      result = TCFURLInfo::LessThan(*v10, a2);
      if ((_DWORD)result)
      {
        v7 = (uint64_t)(v10 + 2);
        v9 += ~(v9 >> 1);
      }
      else
      {
        v9 >>= 1;
      }
    }
    while ((uint64_t)v9 > 0);
    v6 = *(_QWORD *)(v4 + 8);
  }
  if (v7 != v6)
  {
    TCFURLInfo::Name(*(TCFURLInfo **)v7, &v16);
    TCFURLInfo::Name(*a2, &v15);
    v11 = CFEqual(v16.fString.fRef, v15.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    result = (uint64_t)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
    if (v11)
    {
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a3, (uint64_t *)v7);
      result = v7 + 16;
      v12 = *(_QWORD *)(v4 + 8);
      if (v7 + 16 != v12)
      {
        do
        {
          v13 = v7 + 16;
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v7, (__int128 *)(v7 + 16));
          v14 = v7 + 32;
          v7 += 16;
        }
        while (v14 != v12);
        result = *(_QWORD *)(v4 + 8);
        v7 = v13;
      }
      while (result != v7)
        result = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](result - 16);
      *(_QWORD *)(v4 + 8) = v7;
    }
  }
  return result;
}

void sub_1CBCB6A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  uint64_t v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v10);
  _Unwind_Resume(a1);
}

const void **TDeepCFURLIterator::MapSourceToDestination@<X0>(uint64_t a1@<X0>, TCFURLInfo ***a2@<X1>, uint64_t a3@<X8>)
{
  TString v7;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v7.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  if (TCFURLInfo::FileSystemRepresentationRelativeToSource(*a2, (const TString *)(a1 + 160), &v7))
    TCFURLInfo::CreateCFURLInfoWithFileSystemRepresentationRelativeToBase(*(TCFURLInfo **)(a1 + 144), &v7, (const __CFString **)(a1 + 168), (TString **)a3);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
}

void sub_1CBCB6AD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void TFileDescriptor::~TFileDescriptor(TFileDescriptor *this)
{
  if (*((int *)this + 2) >= 1)
    TFileDescriptor::Close(this);
}

void ___ZZ16CloudDocsRootURLvENK3__0cvU13block_pointerFvP5NSURLP7NSErrorEEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v6;
  id v7;
  id v8;
  id v9;
  NSObject *v10;
  int v11;
  id v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  v7 = a3;
  v8 = v6;
  v9 = v7;
  if (v8)
  {
    objc_storeStrong(*(id **)(a1 + 32), a2);
  }
  else
  {
    LogObj(5);
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = 138412290;
      v12 = v9;
      _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_ERROR, "BRGetCloudDocsRootURL failed: %@", (uint8_t *)&v11, 0xCu);
    }

  }
}

void sub_1CBCB6C2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c30_ZTSKZ16CloudDocsRootURLvE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  std::vector<char>::pointer end;
  char *v5;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<char>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    v5 = &end[__n];
    bzero(end, __n);
    this->__end_ = v5;
  }
  return this;
}

void sub_1CBCB6CA8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<char>::__vallocate[abi:ne180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n)
{
  char *value;
  char *end;
  std::vector<char>::pointer begin;
  int64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  end = this->__end_;
  value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      bzero(this->__end_, __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v7 = end - this->__begin_;
    v8 = v7 + __n;
    if ((uint64_t)(v7 + __n) < 0)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v9 = value - begin;
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (char *)operator new(v10);
    else
      v11 = 0;
    v12 = &v11[v7];
    v13 = &v11[v10];
    bzero(v12, __n);
    if (end == begin)
    {
      v11 = v12;
    }
    else
    {
      v14 = &end[~(unint64_t)begin];
      do
      {
        v15 = *--end;
        (v14--)[(_QWORD)v11] = v15;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v11;
    this->__end_ = &v12[__n];
    this->__end_cap_.__value_ = v13;
    if (end)
      operator delete(end);
  }
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

id std::vector<NSURL * {__strong}>::push_back[abi:ne180100](char **a1, id *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  id result;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;

  v6 = (unint64_t)a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v10 = (v7 - *a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)*a1;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v25 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    else
      v14 = 0;
    v15 = &v14[8 * v10];
    v16 = &v14[8 * v13];
    v24 = v16;
    *(_QWORD *)v15 = *a2;
    v9 = v15 + 8;
    v23.i64[1] = (uint64_t)(v15 + 8);
    v18 = *a1;
    v17 = a1[1];
    if (v17 == *a1)
    {
      v20 = vdupq_n_s64((unint64_t)v17);
    }
    else
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *(_QWORD *)v17 = 0;
        *((_QWORD *)v15 - 1) = v19;
        v15 -= 8;
      }
      while (v17 != v18);
      v20 = *(int64x2_t *)a1;
      v9 = (char *)v23.i64[1];
      v16 = v24;
    }
    *a1 = v15;
    a1[1] = v9;
    v23 = v20;
    v21 = a1[2];
    a1[2] = v16;
    v24 = v21;
    v22 = v20.i64[0];
    result = (id)std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    result = *a2;
    *(_QWORD *)v7 = result;
    v9 = v7 + 8;
  }
  a1[1] = v9;
  return result;
}

const void **TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::operator=<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

const void **TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t std::string_view::compare[abi:ne180100](_QWORD *a1, unint64_t a2, size_t a3, void *__s2, size_t a5)
{
  unint64_t v5;
  BOOL v6;
  size_t v7;
  const void *v9;
  size_t v10;
  size_t v11;
  uint64_t result;
  unsigned int v13;

  v5 = a1[1];
  v6 = v5 >= a2;
  v7 = v5 - a2;
  if (!v6)
    std::__throw_out_of_range[abi:ne180100]("string_view::substr");
  v9 = (const void *)(*a1 + a2);
  if (v7 >= a3)
    v10 = a3;
  else
    v10 = v7;
  if (a5 >= v10)
    v11 = v10;
  else
    v11 = a5;
  LODWORD(result) = memcmp(v9, __s2, v11);
  if (v10 < a5)
    v13 = -1;
  else
    v13 = 1;
  if (v10 == a5)
    v13 = 0;
  if ((_DWORD)result)
    return result;
  else
    return v13;
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::__split_buffer<std::string>::pointer end;
  __int128 v12;
  uint64_t v13;
  std::__split_buffer<std::string> __v;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9)
    v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    end = __v.__end_;
  }
  else
  {
    v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_1CBCB7430(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

void std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

const void **TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TAutoRef<__CFDictionary *,TRetainReleasePolicy<__CFDictionary *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::default_delete<TCFURLIterator>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void **v4;

  if (a2)
  {
    v4 = (void **)(a2 + 40);
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v4);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(a2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(a2 + 16));
    v3 = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a2);
    MEMORY[0x1D17A53D0](v3, 0x1060C40FBA2130BLL);
  }
}

void FormatDetails<unsigned int,std::string>(__int128 *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  unint64_t v7;
  std::string *p_p;
  std::string::size_type size;
  std::string *v10;
  std::string v11;
  __int128 v12;
  std::string __p;

  memset(&__p, 0, sizeof(__p));
  v12 = *a1;
  do
  {
    v7 = FormatOneDetails<unsigned int>((const std::string::value_type **)&v12, &__p, a2);
    if ((_DWORD)v7)
    {
      *((_BYTE *)&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v7) == 7);
  FormatDetails<std::string>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v10 = std::string::insert(&v11, 0, (const std::string::value_type *)p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1CBCB7688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a15 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<unsigned int>(const std::string::value_type **a1, std::string *this, unsigned int *a3)
{
  const std::string::value_type *v3;
  const std::string::value_type *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t i;
  uint64_t v12;
  unint64_t v13;
  const std::string::value_type *v14;
  BOOL v15;
  const std::string::value_type *v16;
  size_t v17;
  void *v18;
  std::string *p_dst;
  std::string *v20;
  std::string::size_type v21;
  void *v22;
  std::string *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  std::string *v30;
  std::string::size_type v31;
  size_t v32;
  size_t v33;
  uint64_t v34;
  int v35;
  std::string::size_type v36;
  std::string *v37;
  std::string::size_type size;
  size_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  std::string::size_type v43;
  std::string *v44;
  void *v45;
  void *v46;
  void *v47;
  size_t v48;
  size_t v49;
  unint64_t v50;
  void *v51;
  size_t v52;
  size_t v53;
  size_t v54;
  size_t v55;
  std::string *v56;
  std::string::size_type v57;
  const std::string::value_type *v58;
  const std::string::value_type *v59;
  void *__p[2];
  unint64_t v62;
  std::string __dst;
  std::string v64;
  void *__src;
  size_t __len;
  unsigned int v67;
  std::string __str[4];
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v3 = a1[1];
  if (v3)
  {
    v7 = *a1;
    v8 = (unsigned __int8 *)&v3[(_QWORD)*a1];
    v9 = 1;
    v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1CBD2B109[i])
        {
          v12 = 0;
          v9 = 1;
          if (v10 != v8)
          {
            v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              v14 = a1[1];
              v15 = (unint64_t)v14 >= v13;
              v16 = &v14[-v13];
              if (!v15)
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&__src);
              v17 = __len;
              if (__len)
              {
                switch(v67)
                {
                  case 1u:
                    if (__len > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v18 = __src;
                    if (__len >= 0x17)
                    {
                      v48 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17)
                        v48 = __len | 7;
                      v49 = v48 + 1;
                      p_dst = (std::string *)operator new(v48 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v49 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = __len;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    p_dst->__r_.__value_.__s.__data_[v17] = 0;
                    LODWORD(v50) = *a3;
                    v35 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    v36 = __dst.__r_.__value_.__r.__words[0];
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      snprintf((char *)__str, 0x64uLL, (const char *)&__dst, (double)v50);
                    else
                      snprintf((char *)__str, 0x64uLL, __dst.__r_.__value_.__l.__data_, (double)v50);
                    std::string::basic_string[abi:ne180100]<0>(&v64, (char *)__str);
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v37 = &v64;
                    else
                      v37 = (std::string *)v64.__r_.__value_.__r.__words[0];
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                    else
                      size = v64.__r_.__value_.__l.__size_;
                    goto LABEL_100;
                  case 2u:
                    if (__len > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v28 = __src;
                    if (__len >= 0x17)
                    {
                      v52 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17)
                        v52 = __len | 7;
                      v53 = v52 + 1;
                      v29 = operator new(v52 + 1);
                      v64.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
                      v64.__r_.__value_.__r.__words[2] = v53 | 0x8000000000000000;
                    }
                    else
                    {
                      *((_BYTE *)&v64.__r_.__value_.__s + 23) = __len;
                      v29 = &v64;
                    }
                    memmove(v29, v28, v17);
                    *((_BYTE *)v29 + v17) = 0;
                    std::to_string(__str, *a3);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v20 = __str;
                    else
                      v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    else
                      v21 = __str[0].__r_.__value_.__l.__size_;
                    goto LABEL_113;
                  case 3u:
                    if (__len > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v22 = __src;
                    if (__len >= 0x17)
                    {
                      v32 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17)
                        v32 = __len | 7;
                      v33 = v32 + 1;
                      v23 = (std::string *)operator new(v32 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = __len;
                      v23 = &__dst;
                    }
                    memmove(v23, v22, v17);
                    v23->__r_.__value_.__s.__data_[v17] = 0;
                    v34 = *a3;
                    v35 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    v36 = __dst.__r_.__value_.__r.__words[0];
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      snprintf((char *)__str, 0x64uLL, (const char *)&__dst, v34);
                    else
                      snprintf((char *)__str, 0x64uLL, __dst.__r_.__value_.__l.__data_, v34);
                    std::string::basic_string[abi:ne180100]<0>(&v64, (char *)__str);
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v37 = &v64;
                    else
                      v37 = (std::string *)v64.__r_.__value_.__r.__words[0];
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                    else
                      size = v64.__r_.__value_.__l.__size_;
LABEL_100:
                    std::string::append(this, (const std::string::value_type *)v37, size);
                    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v64.__r_.__value_.__l.__data_);
                    if ((v35 & 0x80000000) == 0)
                      goto LABEL_136;
                    v51 = (void *)v36;
                    goto LABEL_135;
                  case 4u:
                    if (__len > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v24 = __src;
                    if (__len >= 0x17)
                    {
                      v39 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17)
                        v39 = __len | 7;
                      v40 = v39 + 1;
                      v25 = operator new(v39 + 1);
                      v64.__r_.__value_.__l.__size_ = v17;
                      v64.__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
                      v64.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
                    }
                    else
                    {
                      *((_BYTE *)&v64.__r_.__value_.__s + 23) = __len;
                      v25 = &v64;
                    }
                    memmove(v25, v24, v17);
                    *((_BYTE *)v25 + v17) = 0;
                    HexDescriptionPrinterGlue<unsigned int,void>::dump((uint64_t)&v64, a3, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v20 = __str;
                    else
                      v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    else
                      v21 = __str[0].__r_.__value_.__l.__size_;
                    goto LABEL_113;
                  case 5u:
                    std::to_string(&v64, *a3);
                    RedactForPrivacy((uint64_t *)&__src, (uint64_t)&v64, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v20 = __str;
                    else
                      v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    else
                      v21 = __str[0].__r_.__value_.__l.__size_;
                    goto LABEL_113;
                  case 6u:
                    std::to_string(&v64, *a3);
                    RedactForPrivacy((uint64_t *)&__src, (uint64_t)&v64, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v20 = __str;
                    else
                      v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    else
                      v21 = __str[0].__r_.__value_.__l.__size_;
                    goto LABEL_113;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&__src, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v30 = __str;
                    else
                      v30 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v31 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    else
                      v31 = __str[0].__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v30, v31);
                    goto LABEL_133;
                  case 8u:
                    if (__len > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v26 = __src;
                    if (__len >= 0x17)
                    {
                      v41 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17)
                        v41 = __len | 7;
                      v42 = v41 + 1;
                      v27 = operator new(v41 + 1);
                      v64.__r_.__value_.__l.__size_ = v17;
                      v64.__r_.__value_.__r.__words[2] = v42 | 0x8000000000000000;
                      v64.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
                    }
                    else
                    {
                      *((_BYTE *)&v64.__r_.__value_.__s + 23) = __len;
                      v27 = &v64;
                    }
                    memmove(v27, v26, v17);
                    *((_BYTE *)v27 + v17) = 0;
                    ExtractEmbeddedFormat(&v64, __str);
                    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v64.__r_.__value_.__l.__data_);
                    v43 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    v44 = __str;
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      v43 = __str[0].__r_.__value_.__l.__size_;
                      v44 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
                    __dst.__r_.__value_.__l.__size_ = v43;
                    FormatDetails<unsigned int>((__int128 *)&__dst, &v64);
                    v45 = (void *)__len;
                    if (__len > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v46 = __src;
                    if (__len >= 0x17)
                    {
                      v54 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17)
                        v54 = __len | 7;
                      v55 = v54 + 1;
                      v47 = operator new(v54 + 1);
                      __p[1] = v45;
                      v62 = v55 | 0x8000000000000000;
                      __p[0] = v47;
                    }
                    else
                    {
                      HIBYTE(v62) = __len;
                      v47 = __p;
                      if (!__len)
                        goto LABEL_121;
                    }
                    memmove(v47, v46, (size_t)v45);
LABEL_121:
                    *((_BYTE *)v45 + (_QWORD)v47) = 0;
                    ExtendedFormatAdaptor((char *)__p, (uint64_t)&v64, &__dst);
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v56 = &__dst;
                    else
                      v56 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v57 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    else
                      v57 = __dst.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v56, v57);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v62) < 0)
                      operator delete(__p[0]);
                    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v64.__r_.__value_.__l.__data_);
LABEL_133:
                    if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0)
                    {
                      v51 = (void *)__str[0].__r_.__value_.__r.__words[0];
LABEL_135:
                      operator delete(v51);
                    }
LABEL_136:
                    v58 = a1[1];
                    v59 = &v58[-__len];
                    if ((unint64_t)v58 < __len)
                      std::__throw_out_of_range[abi:ne180100]("string_view::substr");
                    v9 = 0;
                    *a1 += __len;
                    a1[1] = v59;
                    v12 = v67;
                    break;
                  default:
                    std::to_string(&v64, *a3);
                    RedactForPrivacy((uint64_t *)&__src, (uint64_t)&v64, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v20 = __str;
                    else
                      v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    else
                      v21 = __str[0].__r_.__value_.__l.__size_;
LABEL_113:
                    std::string::append(this, (const std::string::value_type *)v20, v21);
                    if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__str[0].__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_136;
                    v51 = (void *)v64.__r_.__value_.__r.__words[0];
                    goto LABEL_135;
                }
              }
              else
              {
                v12 = 0;
                v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8)
        continue;
      break;
    }
    v12 = 0;
  }
  else
  {
    v12 = 0;
    v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1CBCB7E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a22 < 0)
    operator delete(__p);
  if (a16 < 0)
    operator delete(a11);
  if (a28 < 0)
    operator delete(a23);
  if (a37 < 0)
    operator delete(a32);
  _Unwind_Resume(exception_object);
}

void FormatDetails<unsigned int>(__int128 *a1@<X0>, std::string *a2@<X8>)
{
  unint64_t v3;
  std::string *v4;
  std::string::size_type size;
  std::string *v6;
  std::string v7;
  __int128 v8;
  std::string v9;

  memset(&v9, 0, sizeof(v9));
  v8 = *a1;
  do
  {
    v3 = FormatOneDetails<unsigned int>((int)&v8, &v9);
    if ((_DWORD)v3)
    {
      *((_BYTE *)&a2->__r_.__value_.__s + 23) = 0;
      a2->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v3) == 7);
  FormatDetails(&v8, &v7);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v4 = &v9;
  else
    v4 = (std::string *)v9.__r_.__value_.__r.__words[0];
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  else
    size = v9.__r_.__value_.__l.__size_;
  v6 = std::string::insert(&v7, 0, (const std::string::value_type *)v4, size);
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
LABEL_13:
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
}

void sub_1CBCB8010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v15 - 17) < 0)
    operator delete(*(void **)(v15 - 40));
  _Unwind_Resume(exception_object);
}

_QWORD *HexDescriptionPrinterGlue<unsigned int,void>::dump@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t v7;
  void *__p[2];
  char v9;
  char __str[16];
  uint64_t v11;
  _QWORD v12[10];
  char v13;
  _QWORD v14[20];

  v14[19] = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a1 + 8);
  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong((char *)a1, (uint64_t)__p);
    if (v9 >= 0)
      snprintf(__str, 0x64uLL, (const char *)__p, *a2);
    else
      snprintf(__str, 0x64uLL, (const char *)__p[0], *a2);
    if (v9 < 0)
      operator delete(__p[0]);
    return std::string::basic_string[abi:ne180100]<0>(a3, __str);
  }
  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__str);
    *(_DWORD *)((char *)v12 + *(_QWORD *)(v11 - 24)) = *(_DWORD *)((_BYTE *)v12 + *(_QWORD *)(v11 - 24)) & 0xFFFFFFB5 | 8;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"0x", 2);
    std::ostream::operator<<();
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, a3);
    *(_QWORD *)__str = *MEMORY[0x1E0DE4F50];
    v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    *(_QWORD *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v11 = v7;
    v12[0] = MEMORY[0x1E0DE4FB8] + 16;
    if (v13 < 0)
      operator delete((void *)v12[8]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return (_QWORD *)MEMORY[0x1D17A5364](v14);
  }
}

void sub_1CBCB81C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo const&,void>@<X0>(const TCFURLInfo *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x68uLL);
  result = std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo const&,std::allocator<TCFURLInfo>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCB8228(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo const&,std::allocator<TCFURLInfo>,0>(_QWORD *a1, const TCFURLInfo *a2)
{
  a1[2] = 0;
  *a1 = &unk_1E8750538;
  a1[1] = 0;
  TCFURLInfo::TCFURLInfo((TCFURLInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1CBCB8274(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::deque<TReservationRecord *>::__maybe_remove_back_spare[abi:ne180100](_QWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v7;

  v3 = a1[1];
  v2 = a1[2];
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200)
    a2 = 1;
  if (v5 < 0x400)
    v7 = a2;
  else
    v7 = 0;
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void std::deque<TReservationRecord *>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v4 = a1[2];
  v5 = a1[1];
  if (v4 == v5)
    v6 = 0;
  else
    v6 = ((v4 - v5) << 6) - 1;
  v7 = a1[5];
  v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<TReservationRecord *>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5];
    v8 = a1[4] + v7;
  }
  *(_QWORD *)(*(_QWORD *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void std::deque<TReservationRecord *>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1CBCB8640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TCFURLInfoList>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87505E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCFURLInfoList>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87505E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<TCFURLInfoList>::__on_zero_shared(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  char *v7;
  TCFURLInfo **v8;
  __int128 *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _OWORD *v13;
  __int128 v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  TCFURLInfo *v18;
  TCFURLInfo *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  TCFURLInfo *v24;
  TCFURLInfo *v25;
  __int128 *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  BOOL v30;
  BOOL v31;
  TCFURLInfo *v32;
  TCFURLInfo **v33;
  _BOOL4 v34;
  unint64_t v35;
  TCFURLInfo *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  TCFURLInfo *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  TCFURLInfo **v46;
  uint64_t v47;
  BOOL v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  int64_t v53;
  int64_t v54;
  int64_t v55;
  uint64_t v56;
  TCFURLInfo **v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 *v70;
  BOOL v71;
  uint64_t v72;
  unint64_t v73;
  __int128 *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  __int128 v89;
  __int128 v90;

LABEL_1:
  v7 = (char *)a2;
  v8 = (TCFURLInfo **)(a2 - 16);
  v9 = (__int128 *)a1;
  while (2)
  {
    a1 = (uint64_t)v9;
    v10 = v7 - (char *)v9;
    v11 = (v7 - (char *)v9) >> 4;
    switch(v11)
    {
      case 0:
      case 1:
        return;
      case 2:
        if (TCFURLInfo::LessThan(*(TCFURLInfo **)(a2 - 16), (TCFURLInfo **)a1))
        {
          v41 = *(TCFURLInfo **)a1;
          *(_QWORD *)a1 = *(_QWORD *)(a2 - 16);
          *(_QWORD *)(a2 - 16) = v41;
          v42 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 - 8);
          *(_QWORD *)(a2 - 8) = v42;
        }
        return;
      case 3:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, (uint64_t)v8);
        return;
      case 4:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a1 + 32, (uint64_t)v8);
        return;
      case 5:
        std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,0>(a1, a1 + 16, a1 + 32, a1 + 48, (uint64_t)v8);
        return;
      default:
        if (v10 <= 383)
        {
          if ((a4 & 1) != 0)
          {
            if ((char *)a1 != v7)
            {
              v43 = a1 + 16;
              if (a1 + 16 != a2)
              {
                v44 = 0;
                v45 = a1;
                do
                {
                  v46 = (TCFURLInfo **)v45;
                  v45 = v43;
                  if (TCFURLInfo::LessThan(v46[2], v46))
                  {
                    v90 = *(_OWORD *)v45;
                    *(_QWORD *)v45 = 0;
                    *(_QWORD *)(v45 + 8) = 0;
                    v47 = v44;
                    while (1)
                    {
                      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + v47 + 16, (__int128 *)(a1 + v47));
                      if (!v47)
                        break;
                      v48 = TCFURLInfo::LessThan((TCFURLInfo *)v90, (TCFURLInfo **)(a1 + v47 - 16));
                      v47 -= 16;
                      if (!v48)
                      {
                        v49 = a1 + v47 + 16;
                        goto LABEL_79;
                      }
                    }
                    v49 = a1;
LABEL_79:
                    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v49, &v90);
                    v50 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
                    if (*((_QWORD *)&v90 + 1))
                    {
                      v51 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
                      do
                        v52 = __ldaxr(v51);
                      while (__stlxr(v52 - 1, v51));
                      if (!v52)
                      {
                        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
                        std::__shared_weak_count::__release_weak(v50);
                      }
                    }
                  }
                  v43 = v45 + 16;
                  v44 += 16;
                }
                while (v45 + 16 != a2);
              }
            }
          }
          else if ((char *)a1 != v7)
          {
            v83 = a1 + 16;
            while (v83 != a2)
            {
              v84 = v83;
              if (TCFURLInfo::LessThan(*(TCFURLInfo **)(a1 + 16), (TCFURLInfo **)a1))
              {
                v90 = *(_OWORD *)v84;
                *(_QWORD *)v84 = 0;
                *(_QWORD *)(v84 + 8) = 0;
                do
                {
                  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 16, (__int128 *)a1);
                  a1 -= 16;
                }
                while (TCFURLInfo::LessThan((TCFURLInfo *)v90, (TCFURLInfo **)a1));
                std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 16, &v90);
                v85 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
                if (*((_QWORD *)&v90 + 1))
                {
                  v86 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
                  do
                    v87 = __ldaxr(v86);
                  while (__stlxr(v87 - 1, v86));
                  if (!v87)
                  {
                    ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
                    std::__shared_weak_count::__release_weak(v85);
                  }
                }
              }
              v83 = v84 + 16;
              a1 = v84;
            }
          }
          return;
        }
        if (!a3)
        {
          if ((char *)a1 != v7)
          {
            v53 = (unint64_t)(v11 - 2) >> 1;
            v54 = v53;
            do
            {
              v55 = v54;
              if (v53 >= v54)
              {
                v56 = (2 * v54) | 1;
                v57 = (TCFURLInfo **)(a1 + 16 * v56);
                if (2 * v54 + 2 < v11 && TCFURLInfo::LessThan(*v57, v57 + 2))
                {
                  v57 += 2;
                  v56 = 2 * v55 + 2;
                }
                v58 = a1 + 16 * v55;
                if (!TCFURLInfo::LessThan(*v57, (TCFURLInfo **)v58))
                {
                  v90 = *(_OWORD *)v58;
                  *(_QWORD *)v58 = 0;
                  *(_QWORD *)(v58 + 8) = 0;
                  do
                  {
                    v59 = (uint64_t)v57;
                    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v58, (__int128 *)v57);
                    if (v53 < v56)
                      break;
                    v60 = (2 * v56) | 1;
                    v57 = (TCFURLInfo **)(a1 + 16 * v60);
                    v56 = 2 * v56 + 2;
                    if (v56 >= v11)
                    {
                      v56 = v60;
                    }
                    else if (TCFURLInfo::LessThan(*v57, v57 + 2))
                    {
                      v57 += 2;
                    }
                    else
                    {
                      v56 = v60;
                    }
                    v58 = v59;
                  }
                  while (!TCFURLInfo::LessThan(*v57, (TCFURLInfo **)&v90));
                  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v59, &v90);
                  v61 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
                  if (*((_QWORD *)&v90 + 1))
                  {
                    v62 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
                    do
                      v63 = __ldaxr(v62);
                    while (__stlxr(v63 - 1, v62));
                    if (!v63)
                    {
                      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                      std::__shared_weak_count::__release_weak(v61);
                    }
                  }
                }
              }
              v54 = v55 - 1;
            }
            while (v55);
            v64 = (unint64_t)v10 >> 4;
            do
            {
              v65 = 0;
              v89 = *(_OWORD *)a1;
              *(_QWORD *)a1 = 0;
              *(_QWORD *)(a1 + 8) = 0;
              v66 = a1;
              do
              {
                v67 = v66 + 16 * v65 + 16;
                v68 = (2 * v65) | 1;
                v69 = 2 * v65 + 2;
                if (v69 < v64 && TCFURLInfo::LessThan(*(TCFURLInfo **)v67, (TCFURLInfo **)(v66 + 16 * v65 + 32)))
                {
                  v67 += 16;
                  v68 = v69;
                }
                std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v66, (__int128 *)v67);
                v66 = v67;
                v65 = v68;
              }
              while (v68 <= (uint64_t)((unint64_t)(v64 - 2) >> 1));
              v70 = (__int128 *)(a2 - 16);
              v71 = v67 == a2 - 16;
              a2 -= 16;
              if (v71)
              {
                std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v67, &v89);
              }
              else
              {
                std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v67, v70);
                std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)v70, &v89);
                v72 = v67 - a1 + 16;
                if (v72 >= 17)
                {
                  v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                  v74 = (__int128 *)(a1 + 16 * v73);
                  if (TCFURLInfo::LessThan(*(TCFURLInfo **)v74, (TCFURLInfo **)v67))
                  {
                    v90 = *(_OWORD *)v67;
                    *(_QWORD *)v67 = 0;
                    *(_QWORD *)(v67 + 8) = 0;
                    do
                    {
                      v75 = (uint64_t)v74;
                      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v67, v74);
                      if (!v73)
                        break;
                      v73 = (v73 - 1) >> 1;
                      v74 = (__int128 *)(a1 + 16 * v73);
                      v67 = v75;
                    }
                    while (TCFURLInfo::LessThan(*(TCFURLInfo **)v74, (TCFURLInfo **)&v90));
                    std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v75, &v90);
                    v76 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
                    if (*((_QWORD *)&v90 + 1))
                    {
                      v77 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
                      do
                        v78 = __ldaxr(v77);
                      while (__stlxr(v78 - 1, v77));
                      if (!v78)
                      {
                        ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
                        std::__shared_weak_count::__release_weak(v76);
                      }
                    }
                  }
                }
              }
              v79 = (std::__shared_weak_count *)*((_QWORD *)&v89 + 1);
              if (*((_QWORD *)&v89 + 1))
              {
                v80 = (unint64_t *)(*((_QWORD *)&v89 + 1) + 8);
                do
                  v81 = __ldaxr(v80);
                while (__stlxr(v81 - 1, v80));
                if (!v81)
                {
                  ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
                  std::__shared_weak_count::__release_weak(v79);
                }
              }
            }
            while (v64-- > 2);
          }
          return;
        }
        v12 = (unint64_t)v11 >> 1;
        v13 = (_OWORD *)(a1 + 16 * ((unint64_t)v11 >> 1));
        if ((unint64_t)v10 < 0x801)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>((uint64_t)v13, a1, (uint64_t)v8);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, (uint64_t)v13, (uint64_t)v8);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1 + 16, (uint64_t)(v13 - 1), a2 - 32);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1 + 32, a1 + 16 + 16 * v12, a2 - 48);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>((uint64_t)(v13 - 1), (uint64_t)v13, a1 + 16 + 16 * v12);
          v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *v13;
          *v13 = v14;
        }
        --a3;
        v7 = (char *)a2;
        if ((a4 & 1) == 0 && !TCFURLInfo::LessThan(*(TCFURLInfo **)(a1 - 16), (TCFURLInfo **)a1))
        {
          v90 = *(_OWORD *)a1;
          v32 = (TCFURLInfo *)v90;
          *(_QWORD *)a1 = 0;
          *(_QWORD *)(a1 + 8) = 0;
          if (TCFURLInfo::LessThan(v32, v8))
          {
            v9 = (__int128 *)a1;
            do
              ++v9;
            while (!TCFURLInfo::LessThan((TCFURLInfo *)v90, (TCFURLInfo **)v9));
          }
          else
          {
            v33 = (TCFURLInfo **)(a1 + 16);
            do
            {
              v9 = (__int128 *)v33;
              if ((unint64_t)v33 >= a2)
                break;
              v34 = TCFURLInfo::LessThan((TCFURLInfo *)v90, v33);
              v33 = (TCFURLInfo **)(v9 + 1);
            }
            while (!v34);
          }
          v35 = a2;
          if ((unint64_t)v9 < a2)
          {
            v35 = a2;
            do
              v35 -= 16;
            while (TCFURLInfo::LessThan((TCFURLInfo *)v90, (TCFURLInfo **)v35));
          }
          while ((unint64_t)v9 < v35)
          {
            v36 = *(TCFURLInfo **)v9;
            *(_QWORD *)v9 = *(_QWORD *)v35;
            *(_QWORD *)v35 = v36;
            v37 = *((_QWORD *)v9 + 1);
            *((_QWORD *)v9 + 1) = *(_QWORD *)(v35 + 8);
            *(_QWORD *)(v35 + 8) = v37;
            do
              ++v9;
            while (!TCFURLInfo::LessThan((TCFURLInfo *)v90, (TCFURLInfo **)v9));
            do
              v35 -= 16;
            while (TCFURLInfo::LessThan((TCFURLInfo *)v90, (TCFURLInfo **)v35));
          }
          if (v9 - 1 != (__int128 *)a1)
            std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1, v9 - 1);
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)(v9 - 1), &v90);
          v38 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
          if (*((_QWORD *)&v90 + 1))
          {
            v39 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
            do
              v40 = __ldaxr(v39);
            while (__stlxr(v40 - 1, v39));
            if (!v40)
            {
              ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
              std::__shared_weak_count::__release_weak(v38);
            }
          }
          a4 = 0;
          continue;
        }
        v15 = 0;
        v90 = *(_OWORD *)a1;
        *(_QWORD *)a1 = 0;
        *(_QWORD *)(a1 + 8) = 0;
        do
        {
          v16 = TCFURLInfo::LessThan(*(TCFURLInfo **)(a1 + v15 + 16), (TCFURLInfo **)&v90);
          v15 += 16;
        }
        while (v16);
        v17 = a1 + v15;
        if (v15 == 16)
        {
          v7 = (char *)a2;
          do
          {
            if (v17 >= (unint64_t)v7)
              break;
            v19 = (TCFURLInfo *)*((_QWORD *)v7 - 2);
            v7 -= 16;
          }
          while (!TCFURLInfo::LessThan(v19, (TCFURLInfo **)&v90));
        }
        else
        {
          do
          {
            v18 = (TCFURLInfo *)*((_QWORD *)v7 - 2);
            v7 -= 16;
          }
          while (!TCFURLInfo::LessThan(v18, (TCFURLInfo **)&v90));
        }
        if (v17 >= (unint64_t)v7)
        {
          v26 = (__int128 *)(v17 - 16);
        }
        else
        {
          v20 = (char *)(a1 + v15);
          v21 = v7;
          do
          {
            v22 = *(_QWORD *)v20;
            *(_QWORD *)v20 = *(_QWORD *)v21;
            *(_QWORD *)v21 = v22;
            v23 = *((_QWORD *)v20 + 1);
            *((_QWORD *)v20 + 1) = *((_QWORD *)v21 + 1);
            *((_QWORD *)v21 + 1) = v23;
            do
            {
              v24 = (TCFURLInfo *)*((_QWORD *)v20 + 2);
              v20 += 16;
            }
            while (TCFURLInfo::LessThan(v24, (TCFURLInfo **)&v90));
            do
            {
              v25 = (TCFURLInfo *)*((_QWORD *)v21 - 2);
              v21 -= 16;
            }
            while (!TCFURLInfo::LessThan(v25, (TCFURLInfo **)&v90));
          }
          while (v20 < v21);
          v26 = (__int128 *)(v20 - 16);
        }
        if (v26 != (__int128 *)a1)
          std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1, v26);
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)v26, &v90);
        v27 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
        if (*((_QWORD *)&v90 + 1))
        {
          v28 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 - 1, v28));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
        }
        v30 = v17 >= (unint64_t)v7;
        v7 = (char *)a2;
        if (!v30)
        {
LABEL_37:
          std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>(a1, v26, a3, a4 & 1);
          a4 = 0;
          v9 = v26 + 1;
          continue;
        }
        v31 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, (uint64_t)v26);
        v9 = v26 + 1;
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>((uint64_t)(v26 + 1), a2))
        {
          if (v31)
            continue;
          goto LABEL_37;
        }
        a2 = (unint64_t)v26;
        if (!v31)
          goto LABEL_1;
        return;
    }
  }
}

void sub_1CBCB8FD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  unint64_t *p_shared_owners;
  unint64_t v16;

  if (a14)
  {
    p_shared_owners = (unint64_t *)&a14->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }
  _Unwind_Resume(exception_object);
}

BOOL std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 result;
  TCFURLInfo *v11;
  uint64_t v12;
  TCFURLInfo *v13;
  uint64_t v14;
  TCFURLInfo *v15;
  uint64_t v16;
  TCFURLInfo *v17;
  uint64_t v18;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a2, a3, a4);
  result = TCFURLInfo::LessThan(*(TCFURLInfo **)a5, (TCFURLInfo **)a4);
  if (result)
  {
    v11 = *(TCFURLInfo **)a4;
    *(_QWORD *)a4 = *(_QWORD *)a5;
    *(_QWORD *)a5 = v11;
    v12 = *(_QWORD *)(a4 + 8);
    *(_QWORD *)(a4 + 8) = *(_QWORD *)(a5 + 8);
    *(_QWORD *)(a5 + 8) = v12;
    result = TCFURLInfo::LessThan(*(TCFURLInfo **)a4, (TCFURLInfo **)a3);
    if (result)
    {
      v13 = *(TCFURLInfo **)a3;
      *(_QWORD *)a3 = *(_QWORD *)a4;
      *(_QWORD *)a4 = v13;
      v14 = *(_QWORD *)(a3 + 8);
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(a4 + 8);
      *(_QWORD *)(a4 + 8) = v14;
      result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
      if (result)
      {
        v15 = *(TCFURLInfo **)a2;
        *(_QWORD *)a2 = *(_QWORD *)a3;
        *(_QWORD *)a3 = v15;
        v16 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
        *(_QWORD *)(a3 + 8) = v16;
        result = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
        if (result)
        {
          v17 = *(TCFURLInfo **)a1;
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v17;
          v18 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
          *(_QWORD *)(a2 + 8) = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6;
  _BOOL8 result;
  TCFURLInfo *v8;
  uint64_t *v9;
  uint64_t *v10;
  TCFURLInfo *v11;
  uint64_t v12;
  uint64_t *v13;
  TCFURLInfo *v14;
  uint64_t v15;
  TCFURLInfo *v16;
  uint64_t v17;

  v6 = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
  result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
  if (v6)
  {
    v8 = *(TCFURLInfo **)a1;
    if (result)
    {
      *(_QWORD *)a1 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v8;
      v9 = (uint64_t *)(a3 + 8);
      v10 = (uint64_t *)(a1 + 8);
    }
    else
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v8;
      v15 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = v15;
      result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
      if (!result)
        return result;
      v16 = *(TCFURLInfo **)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v16;
      v9 = (uint64_t *)(a3 + 8);
      v10 = (uint64_t *)(a2 + 8);
    }
    v13 = v9;
    goto LABEL_10;
  }
  if (result)
  {
    v11 = *(TCFURLInfo **)a2;
    *(_QWORD *)a2 = *(_QWORD *)a3;
    *(_QWORD *)a3 = v11;
    v13 = (uint64_t *)(a2 + 8);
    v12 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 8) = v12;
    result = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
    if (result)
    {
      v14 = *(TCFURLInfo **)a1;
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v10 = (uint64_t *)(a1 + 8);
      *(_QWORD *)a2 = v14;
LABEL_10:
      v17 = *v10;
      *v10 = *v13;
      *v13 = v17;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  TCFURLInfo *v6;
  uint64_t v7;
  TCFURLInfo **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (TCFURLInfo::LessThan(*(TCFURLInfo **)(a2 - 16), (TCFURLInfo **)a1))
      {
        v6 = *(TCFURLInfo **)a1;
        *(_QWORD *)a1 = *(_QWORD *)(a2 - 16);
        *(_QWORD *)(a2 - 16) = v6;
        v7 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a2 - 8) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,0>(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16);
      return 1;
    default:
      v8 = (TCFURLInfo **)(a1 + 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a1 + 32);
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    if (TCFURLInfo::LessThan(*(TCFURLInfo **)v9, v8))
    {
      v18 = *(_OWORD *)v9;
      *(_QWORD *)v9 = 0;
      *(_QWORD *)(v9 + 8) = 0;
      v12 = v10;
      while (1)
      {
        std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + v12 + 48, (__int128 *)(a1 + v12 + 32));
        if (v12 == -32)
          break;
        v13 = TCFURLInfo::LessThan((TCFURLInfo *)v18, (TCFURLInfo **)(a1 + v12 + 16));
        v12 -= 16;
        if (!v13)
        {
          v14 = a1 + v12 + 48;
          goto LABEL_12;
        }
      }
      v14 = a1;
LABEL_12:
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v14, &v18);
      v15 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
      if (*((_QWORD *)&v18 + 1))
      {
        v16 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (TCFURLInfo **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void sub_1CBCB94CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 result;
  TCFURLInfo *v9;
  uint64_t v10;
  TCFURLInfo *v11;
  uint64_t v12;
  TCFURLInfo *v13;
  uint64_t v14;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a2, a3);
  result = TCFURLInfo::LessThan(*(TCFURLInfo **)a4, (TCFURLInfo **)a3);
  if (result)
  {
    v9 = *(TCFURLInfo **)a3;
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v9;
    v10 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 8) = *(_QWORD *)(a4 + 8);
    *(_QWORD *)(a4 + 8) = v10;
    result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
    if (result)
    {
      v11 = *(TCFURLInfo **)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v11;
      v12 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
      *(_QWORD *)(a3 + 8) = v12;
      result = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
      if (result)
      {
        v13 = *(TCFURLInfo **)a1;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v13;
        v14 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_0()
{
  uint64_t v0;

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
}

void OUTLINED_FUNCTION_1(unint64_t *a1@<X8>)
{
  unint64_t v1;

  v1 = __ldaxr(a1);
  __stlxr(v1 - 1, a1);
}

void OUTLINED_FUNCTION_3()
{
  std::__shared_weak_count *v0;

  std::__shared_weak_count::__release_weak(v0);
}

void sub_1CBCB9668(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::function<void ()(void)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(void)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1CBCB9798(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::function<void ()(NSDictionary<NSString *,NSObject *> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1CBCB996C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::function<void ()(NSDictionary<NSString *,NSObject *> *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3;
  id v4;

  v4 = a2;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *))(*(_QWORD *)v3 + 48))(v3, &v4);

}

void sub_1CBCB99D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t TKeyValueObserver::TKeyValueObserver(uint64_t a1, uint64_t *a2)
{
  CFTypeRef v3;
  _QWORD *v4;
  __int128 v5;

  v3 = (CFTypeRef)*a2;
  *a2 = 0;
  *(_QWORD *)a1 = v3;
  v4 = a2 + 1;
  *(_QWORD *)(a1 + 8) = a2[1];
  *(_QWORD *)(a1 + 16) = a2[2];
  v5 = *(_OWORD *)(a2 + 3);
  a2[3] = 0;
  *(_OWORD *)(a1 + 24) = v5;
  a2[4] = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a2 + 4, &stru_1E8752DF8);
  *v4 = 0;
  v4[1] = 0;
  return a1;
}

void TKeyValueObserver::StartObservingPriv(TKeyValueObserver *this, DS_TKeyValueObserverGlue *a2, NSObject *a3, const TString *a4, uint64_t a5)
{
  NSObject *v10;
  NSObject *v11;
  DS_TKeyValueObserverGlue *v12;

  v12 = a2;
  v10 = a3;
  objc_storeStrong((id *)this, a2);
  *((_QWORD *)this + 1) = v10;
  v11 = v10;
  if ((const TString *)((char *)this + 32) != a4)
  {
    TString::SetStringRefAsImmutable((TString *)this + 4, (TString *)a4->fString.fRef);
    v11 = *((_QWORD *)this + 1);
  }
  -[NSObject addObserver:forKeyPath:options:context:](v11, "addObserver:forKeyPath:options:context:", *(_QWORD *)this, *((_QWORD *)this + 4), a5, 0);

}

void sub_1CBCB9BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void TKeyValueObserver::StopObserving(TKeyValueObserver *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    objc_msgSend(v2, "removeObserver:forKeyPath:", *(_QWORD *)this, *((_QWORD *)this + 4));
    *((_QWORD *)this + 1) = 0;
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 2);
    if (v3)
    {
      objc_msgSend(v3, "removeObserver:fromObjectsAtIndexes:forKeyPath:", *(_QWORD *)this, *((_QWORD *)this + 3), *((_QWORD *)this + 4));
      v4 = (void *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 2) = 0;
      *((_QWORD *)this + 3) = 0;

    }
  }
  v5 = *(void **)this;
  *(_QWORD *)this = 0;

  TString::SetStringRefAsImmutable((TString *)this + 4, 0);
}

DS_TKeyValueObserverGlue *TKeyValueObserver::CreateObserver(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[DS_TKeyValueObserverGlue initWithFunctor:observedObjects:observedKeyPath:]([DS_TKeyValueObserverGlue alloc], "initWithFunctor:observedObjects:observedKeyPath:", a2, a3, a4);
}

_QWORD *std::__function::__value_func<void ()(void)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1CBCB9E10(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1CBCB9F84(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
    *(_BYTE *)(a1 + 44) = *(_BYTE *)(a2 + 44);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::hash,void *> *>>((_QWORD *)a1, *(void ***)(a2 + 16), 0);
  }
  return a1;
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::hash,void *> *>>(_QWORD *a1, void **a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t i;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;

  v6 = a1[1];
  if (!v6)
    goto LABEL_9;
  for (i = 0; i != v6; *(_QWORD *)(*a1 + 8 * i++) = 0)
    ;
  v8 = (_QWORD *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v8)
  {
    while (a2 != (void **)a3)
    {
      v8[2] = a2[2];
      v9 = (_QWORD *)*v8;
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi(a1, (uint64_t)v8);
      a2 = (void **)*a2;
      v8 = v9;
      if (!v9)
        goto LABEL_9;
    }
    do
    {
      v10 = (_QWORD *)*v8;
      operator delete(v8);
      v8 = v10;
    }
    while (v10);
  }
  else
  {
LABEL_9:
    while (a2 != (void **)a3)
    {
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_multi<NSObject * const&>(a1, a2 + 2);
      a2 = (void **)*a2;
    }
  }
}

void sub_1CBCBA0A0(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1CBCBA0C0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi(_QWORD *a1, uint64_t a2)
{
  void **v4;
  unint64_t v5;
  _QWORD *inserted;

  v4 = (void **)(a2 + 16);
  v5 = objc_msgSend(*(id *)(a2 + 16), "hash");
  *(_QWORD *)(a2 + 8) = v5;
  inserted = std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_prepare((uint64_t)a1, v5, v4);
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_perform(a1, (_QWORD *)a2, inserted);
  return a2;
}

_QWORD *std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, void **a3)
{
  unint64_t v6;
  float v7;
  float v8;
  _BOOL8 v9;
  unint64_t v10;
  unint64_t v11;
  size_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int v22;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v8 = *(float *)(a1 + 40);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    v9 = 1;
    if (v6 >= 3)
      v9 = (v6 & (v6 - 1)) != 0;
    v10 = v9 | (2 * v6);
    v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11)
      v12 = v11;
    else
      v12 = v10;
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<false>(a1, v12);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v13 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v13.i16[0] = vaddlv_u8(v13);
  v14 = v13.u32[0];
  if (v13.u32[0] > 1uLL)
  {
    v15 = a2;
    if (v6 <= a2)
      v15 = a2 % v6;
  }
  else
  {
    v15 = (v6 - 1) & a2;
  }
  v16 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
  if (v16)
  {
    v17 = (_QWORD *)*v16;
    if (*v16)
    {
      v18 = 0;
      v19 = a1 + 44;
      do
      {
        v20 = v17[1];
        if (v14 > 1)
        {
          v21 = v17[1];
          if (v20 >= v6)
            v21 = v20 % v6;
        }
        else
        {
          v21 = v20 & (v6 - 1);
        }
        if (v21 != v15)
          break;
        v22 = v20 == a2 ? std::equal_to<NSObject * {__strong}>::operator()(v19, (void *)v17[2], *a3) : 0;
        if ((v18 & (v22 ^ 1) & 1) != 0)
          break;
        v18 |= v22;
        v16 = (_QWORD *)*v16;
        v17 = (_QWORD *)*v16;
      }
      while (*v16);
    }
  }
  return v16;
}

_QWORD *std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_perform(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(_QWORD *)(*result + 8 * v4) = result + 2;
    if (!*a2)
      goto LABEL_19;
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
LABEL_18:
    *(_QWORD *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
    if (v6 != v4)
      goto LABEL_18;
  }
LABEL_19:
  ++result[3];
  return result;
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<false>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 40));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__do_rehash<false>(a1, prime);
  }
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  void *v11;
  uint64_t i;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  int v16;
  _QWORD *v17;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(uint64_t **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      v10 = v9.u32[0];
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      for (i = *v7; *v7; i = *v7)
      {
        v13 = *(_QWORD *)(i + 8);
        if (v10 > 1)
        {
          if (v13 >= a2)
            v13 %= a2;
        }
        else
        {
          v13 &= a2 - 1;
        }
        if (v13 == v8)
        {
          v7 = (uint64_t *)i;
        }
        else if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v13))
        {
          v14 = *(_QWORD **)i;
          v15 = (_QWORD *)i;
          if (*(_QWORD *)i)
          {
            while (1)
            {
              v16 = std::equal_to<NSObject * {__strong}>::operator()(a1 + 44, *(void **)(i + 16), (void *)v14[2]);
              v17 = (_QWORD *)*v15;
              if (!v16)
                break;
              v14 = (_QWORD *)*v17;
              v15 = (_QWORD *)*v15;
              if (!*v17)
                goto LABEL_30;
            }
            v14 = (_QWORD *)*v15;
            v17 = v15;
          }
          else
          {
            v17 = (_QWORD *)i;
          }
LABEL_30:
          *v7 = (uint64_t)v14;
          *v17 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v13);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v13) = i;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v13) = v7;
          v7 = (uint64_t *)i;
          v8 = v13;
        }
      }
    }
  }
  else
  {
    v11 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v11)
      operator delete(v11);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_multi<NSObject * const&>(_QWORD *a1, void **a2)
{
  uint64_t v4[3];

  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__construct_node<NSObject * const&>((uint64_t)a1, a2, (uint64_t)v4);
  return std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi(a1, v4[0]);
}

void sub_1CBCBA654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__construct_node<NSObject * const&>@<X0>(uint64_t a1@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  uint64_t result;

  v5 = a1 + 16;
  v6 = operator new(0x18uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *v6 = 0;
  v6[1] = 0;
  v7 = *a2;
  v6[2] = *a2;
  *(_BYTE *)(a3 + 16) = 1;
  result = objc_msgSend(v7, "hash");
  v6[1] = result;
  return result;
}

void sub_1CBCBA6C8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  *v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::find<std::hash>(_QWORD *a1, id *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **v11;
  uint64_t v12;
  unint64_t v13;

  v4 = objc_msgSend(*a2, "hash");
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)a1 + 44;
    do
    {
      v13 = (unint64_t)v11[1];
      if (v6 == v13)
      {
        if ((std::equal_to<NSObject * {__strong}>::operator()(v12, v11[2], *a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

void ___Z16IsDatalessDomainP5NSURLb_block_invoke(uint64_t a1, void *a2)
{
  objc_storeStrong(*(id **)(a1 + 32), a2);
}

uint64_t __copy_helper_block_ea8_32c37_ZTSKZ16IsDatalessDomainP5NSURLbE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

BOOL IsDataSeparatedDomainID(const TString *this)
{
  unsigned __int8 v2;

  if ((v2 & 1) == 0
  {
    TString::TString(&IsDataSeparatedDomainID(TString const&)::kDataSeparatedDomainIDPrefix, "com.apple.CloudDocs.iCloudDriveFileProviderManaged/", 0x33uLL);
  }
  return TString::BeginsWith((TString *)this, &IsDataSeparatedDomainID(TString const&)::kDataSeparatedDomainIDPrefix);
}

void sub_1CBCBA864(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL IsMainICloudDriveDomainID(const TString *this)
{
  unsigned __int8 v2;

  if ((v2 & 1) == 0
  {
    TString::TString(&IsMainICloudDriveDomainID(TString const&)::kMainICloudDriveProviderID, "com.apple.CloudDocs.iCloudDriveFileProvider/", 0x2CuLL);
  }
  return TString::BeginsWith((TString *)this, &IsMainICloudDriveDomainID(TString const&)::kMainICloudDriveProviderID);
}

void sub_1CBCBA8EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id FIProviderDomainForURL(const __CFURL *a1)
{
  void *v1;
  id v2;
  id v3;
  id v5;

  v5 = 0;
  +[FIProviderDomain providerDomainForURL:cachePolicy:error:](FIProviderDomain, "providerDomainForURL:cachePolicy:error:", a1, 1, &v5);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v5;
  if ((objc_msgSend(v1, "supportsEnumeration") & 1) != 0)
    v3 = v1;
  else
    v3 = 0;

  return v3;
}

void sub_1CBCBA984(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IsDefaultFPDomain(FPProviderDomain *a1)
{
  FPProviderDomain *v1;
  void *v2;
  void *v3;
  uint64_t v4;

  v1 = a1;
  -[FPProviderDomain identifier](v1, "identifier");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  -[FPProviderDomain providerID](v1, "providerID");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v2, "isEqualToString:", v3);

  return v4;
}

void sub_1CBCBA9FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

id FPSharedItemCreator(FPItem *a1)
{
  -[FPItem ownerNameComponents](a1, "ownerNameComponents");
  return (id)objc_claimAutoreleasedReturnValue();
}

void MyFPResolveSymlink(NSURL *a1@<X0>, uint64_t a2@<X8>)
{
  NSURL *v3;
  void *v4;
  void *v5;
  id v6;
  int v7;

  v3 = a1;
  FPResolveSymlink();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (v4)
  {
    v6 = v4;
    v7 = 0;
  }
  else
  {
    v6 = 0;
    v7 = -8064;
  }
  *(_QWORD *)a2 = v6;
  *(_DWORD *)(a2 + 8) = v7;

}

void sub_1CBCBAAD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void FileProviderErrorDomain(TString *a1@<X8>)
{
  TString *v2;

  v2 = (TString *)*MEMORY[0x1E0CAAB48];
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, v2);
}

void sub_1CBCBAB28(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void FileProviderInternalErrorDomain(TString *a1@<X8>)
{
  TString *v2;

  v2 = (TString *)*MEMORY[0x1E0CAAB88];
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, v2);
}

void sub_1CBCBAB80(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void FileProviderSharedItemPermissionsReadOnly(TString *a1@<X8>)
{
  TString *v2;

  v2 = (TString *)*MEMORY[0x1E0C99B80];
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, v2);
}

void sub_1CBCBABD8(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

id FP_ItemDecorationTypeSharing(void)
{
  return (id)*MEMORY[0x1E0CAA9F8];
}

BOOL IsDomainDisconnected(FPProviderDomain *a1)
{
  FPProviderDomain *v1;
  FPProviderDomain *v2;
  _BOOL8 v3;

  v1 = a1;
  v2 = v1;
  if (v1)
    v3 = -[FPProviderDomain disconnectionState](v1, "disconnectionState") != 1;
  else
    v3 = 0;

  return v3;
}

void sub_1CBCBAC40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL FileProviderDomainsHaveEquivalentProperties(FPProviderDomain *a1, FPProviderDomain *a2)
{
  FPProviderDomain *v3;
  FPProviderDomain *v4;
  FPProviderDomain *v5;
  int v6;
  int v7;
  int v8;
  _BOOL4 v9;
  int v10;
  void *v11;
  void *v12;
  int v13;
  int v14;
  void *v15;
  void *v16;
  char v17;
  _BOOL8 v18;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  id v24;
  void *v25;
  id v26;
  NSObject *v27;
  NSObject *v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  FPProviderDomain *v35;
  FPProviderDomain *v36;
  void *v37;
  FPProviderDomain *v38;
  id v39[17];
  id obj;
  _QWORD v41[8];
  _QWORD v42[5];
  uint64_t v43;
  uint64_t v44;
  char *v45;
  id v46[17];
  id v47;
  _QWORD v48[8];
  _QWORD v49[5];
  uint64_t v50;
  uint64_t v51;
  char *v52;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3 || !v4)
  {
    v18 = v3 == v4;
    goto LABEL_17;
  }
  if (!-[FPProviderDomain isEqual:](v3, "isEqual:", v4))
    goto LABEL_16;
  v6 = -[FPProviderDomain isEnabled](v3, "isEnabled");
  if (v6 != -[FPProviderDomain isEnabled](v5, "isEnabled"))
    goto LABEL_16;
  v7 = -[FPProviderDomain isHidden](v3, "isHidden");
  if (v7 != -[FPProviderDomain isHidden](v5, "isHidden"))
    goto LABEL_16;
  v8 = -[FPProviderDomain needsAuthentication](v3, "needsAuthentication");
  if (v8 != -[FPProviderDomain needsAuthentication](v5, "needsAuthentication"))
    goto LABEL_16;
  v9 = IsDomainDisconnected(v3);
  if (v9 != IsDomainDisconnected(v5))
    goto LABEL_16;
  v10 = -[FPProviderDomain storageURLsAreInTransientState](v3, "storageURLsAreInTransientState");
  if (v10 != -[FPProviderDomain storageURLsAreInTransientState](v5, "storageURLsAreInTransientState"))
    goto LABEL_16;
  -[FPProviderDomain domainFullDisplayName](v3, "domainFullDisplayName");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  -[FPProviderDomain domainFullDisplayName](v5, "domainFullDisplayName");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v11, "isEqual:", v12) & 1) == 0)
  {

    goto LABEL_16;
  }
  v13 = -[FPProviderDomain isUsingFPFS](v3, "isUsingFPFS");
  v14 = -[FPProviderDomain isUsingFPFS](v5, "isUsingFPFS");

  if (v13 != v14)
    goto LABEL_16;
  if (!-[FPProviderDomain isUsingFPFS](v3, "isUsingFPFS")
    || (-[FPProviderDomain storageURLs](v3, "storageURLs"),
        v15 = (void *)objc_claimAutoreleasedReturnValue(),
        -[FPProviderDomain storageURLs](v5, "storageURLs"),
        v16 = (void *)objc_claimAutoreleasedReturnValue(),
        v17 = objc_msgSend(v15, "isEqual:", v16),
        v16,
        v15,
        (v17 & 1) != 0))
  {
    v18 = 1;
    goto LABEL_17;
  }
  -[FPProviderDomain storageURLs](v3, "storageURLs");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v21 = objc_msgSend(v20, "count");
  -[FPProviderDomain storageURLs](v5, "storageURLs");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = objc_msgSend(v22, "count");

  if (v21 != v23)
  {
LABEL_16:
    v18 = 0;
    goto LABEL_17;
  }
  v36 = v5;
  -[FPProviderDomain storageURLs](v3, "storageURLs");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = v36;
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)&obj, v37);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v39, -1, v37);
  v38 = v35;
  while (obj != v39[0] || v45 != v39[16])
  {
    v24 = *(id *)(v41[1] + 8 * v44);
    -[FPProviderDomain storageURLs](v38, "storageURLs");
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = v24;
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)&v47, v25);
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v46, -1, v25);
    v27 = v26;
    while (v47 != v46[0] || v52 != v46[16])
    {
      v28 = *(id *)(v48[1] + 8 * v51);
      v29 = IsEqual(v27, v28);

      if ((v29 & 1) != 0)
      {
        v32 = 1;
        goto LABEL_33;
      }
      v30 = v51;
      if (v51 >= v50 - 1)
      {
        v31 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", v48, v49, 4);
        v30 = -1;
        v50 = v31;
        v51 = -1;
      }
      if (v49[4] != *(_QWORD *)v48[2])
      {
        objc_enumerationMutation(v47);
        v30 = v51;
      }
      v51 = v30 + 1;
      ++v52;
    }
    v32 = 0;
LABEL_33:

    if ((v32 & 1) == 0)
    {
      v18 = 0;
      goto LABEL_41;
    }
    v33 = v44;
    if (v44 >= v43 - 1)
    {
      v34 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v41, v42, 4);
      v33 = -1;
      v43 = v34;
      v44 = -1;
    }
    if (v42[4] != *(_QWORD *)v41[2])
    {
      objc_enumerationMutation(obj);
      v33 = v44;
    }
    v44 = v33 + 1;
    ++v45;
  }
  v18 = 1;
LABEL_41:

LABEL_17:
  return v18;
}

void sub_1CBCBB0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  void *v33;
  void *v34;

  _Unwind_Resume(a1);
}

id FileMetadataCopyLastUsedDateAtURL()
{
  FPFileMetadataCopyLastUsedDateAtURL();
  return (id)objc_claimAutoreleasedReturnValue();
}

uint64_t IsAppInbox(NSURL *a1)
{
  NSURL *v1;
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  TString *v7;
  id v8;
  char v9;
  void **v11[2];
  id v12;
  id v13;
  id v14[17];
  id v15;
  uint64_t v16;
  TString v17;
  id v18;
  id v19;
  uint64_t v20;
  id v21;
  id v22;
  TString v23;

  v1 = a1;
  if (UseFileProviderFramework())
  {
    -[NSURL lastPathComponent](v1, "lastPathComponent");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    TString::TString(&v17, "Inbox", 5uLL);
    v3 = operator==((void **)&v17.fString.fRef, v2);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);

    if ((_DWORD)v3)
    {
      -[NSURL path](v1, "path");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "stringByStandardizingPath");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "pathComponents");
      v13 = (id)objc_claimAutoreleasedReturnValue();

      v12 = &unk_1E875AD58;
      v6 = objc_msgSend(v13, "count");
      if (v6 == objc_msgSend(&unk_1E875AD58, "count"))
      {
        v11[0] = &v13;
        v11[1] = &v12;
        iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cbegin<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(v11, (uint64_t)&v17);
        iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cend<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(v11, (uint64_t)v14);
        while ((v17.fString.fRef != v14[0] || v18 != v14[16]) && (v19 != v15 || v20 != v16))
        {
          iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator*(&v17, &v21);
          v7 = (TString *)v21;
          v23.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v23, v7);

          v8 = v22;
          if (objc_msgSend(v8, "length"))
          {
            v9 = operator==((void **)&v23.fString.fRef, v8);

            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
            if ((v9 & 1) == 0)
            {
              v3 = 0;
              goto LABEL_17;
            }
          }
          else
          {

            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
          }
          iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator++((uint64_t)&v17);
        }
        v3 = 1;
LABEL_17:

      }
      else
      {
        v3 = 0;
      }

    }
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1CBCBB3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a65;
  void *v65;

  _Unwind_Resume(a1);
}

uint64_t TCachedAppLibraryCollections::Singleton(TCachedAppLibraryCollections *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)v3 = 0u;
    *(_QWORD *)(v3 + 48) = 850045863;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_QWORD *)(v3 + 104) = 0;
    TCachedAppLibraryCollections::Singleton(void)::sCollections = v3;
  }
  return TCachedAppLibraryCollections::Singleton(void)::sCollections;
}

void sub_1CBCBB554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__optional_destruct_base<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
  {

    *(_BYTE *)(a1 + 16) = 0;
  }
}

id TCachedAppLibraryCollections::CachedCollection(TCachedAppLibraryCollections *this, const TString *a2, int a3)
{
  std::mutex *v6;
  _BOOL4 v7;
  uint64_t v8;
  TCachedAppLibraryCollections *v9;
  void *v10;
  id v11;
  void *v12;
  __CFString *v13;
  void *v14;
  __CFString *v16;
  id v17;

  v6 = (std::mutex *)((char *)this + 48);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  if (!CFStringGetLength(a2->fString.fRef))
    goto LABEL_14;
  v7 = IsMainICloudDriveDomainID(a2);
  if (!v7 && !IsDataSeparatedDomainID(a2))
    goto LABEL_14;
  v8 = 24;
  if (v7)
  {
    v8 = 0;
    v9 = this;
  }
  else
  {
    v9 = (TCachedAppLibraryCollections *)((char *)this + 24);
  }
  if (!*((_BYTE *)v9 + 16)
    || !operator==((void **)&a2->fString.fRef, *(void **)((char *)this + v8))
    || (v10 = (void *)*((_QWORD *)v9 + 1)) == 0)
  {
    std::__optional_destruct_base<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,false>::reset[abi:ne180100]((uint64_t)v9);
    if (a3)
    {
      objc_msgSend((id)objc_opt_class(), "defaultManager");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v13 = a2->fString.fRef;
      objc_msgSend(v12, "appLibraryCollectionForProviderDomainID:", v13);
      v14 = (void *)objc_claimAutoreleasedReturnValue();

      if (v14)
      {
        v16 = objc_retainAutorelease(a2->fString.fRef);
        v11 = v14;
        v17 = v11;
        std::optional<std::pair<NSString * {__strong},FPItemCollection * {__strong}>>::operator=[abi:ne180100]<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,void>((uint64_t)v9, (uint64_t *)&v16);

        goto LABEL_15;
      }
    }
LABEL_14:
    v11 = 0;
    goto LABEL_15;
  }
  v11 = v10;
LABEL_15:
  std::mutex::unlock(v6);
  return v11;
}

void sub_1CBCBB6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  std::mutex *v10;
  void *v11;

  std::mutex::unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::pair<NSString * {__strong},FPItemCollection * {__strong}>>::operator=[abi:ne180100]<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,void>(uint64_t a1, uint64_t *a2)
{
  int v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  v4 = *(unsigned __int8 *)(a1 + 16);
  v5 = *a2;
  *a2 = 0;
  if (v4)
  {
    v6 = *(void **)a1;
    *(_QWORD *)a1 = v5;

    v7 = a2[1];
    a2[1] = 0;
    v8 = *(void **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v7;

  }
  else
  {
    v9 = a2[1];
    a2[1] = 0;
    *(_QWORD *)a1 = v5;
    *(_QWORD *)(a1 + 8) = v9;
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCBB850(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCBB8CC(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator*@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  id v4;
  id result;

  v4 = *(id *)(a1[2] + 8 * a1[15]);
  result = *(id *)(a1[19] + 8 * a1[32]);
  *a2 = v4;
  a2[1] = result;
  return result;
}

uint64_t iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator++(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 120);
  if (v2 >= *(_QWORD *)(a1 + 112) - 1)
  {
    v3 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    v2 = -1;
    *(_QWORD *)(a1 + 112) = v3;
    *(_QWORD *)(a1 + 120) = -1;
  }
  if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
  {
    objc_enumerationMutation(*(id *)a1);
    v2 = *(_QWORD *)(a1 + 120);
  }
  v4 = *(_QWORD *)(a1 + 128) + 1;
  *(_QWORD *)(a1 + 120) = v2 + 1;
  *(_QWORD *)(a1 + 128) = v4;
  v5 = *(_QWORD *)(a1 + 256);
  if (v5 >= *(_QWORD *)(a1 + 248) - 1)
  {
    v6 = objc_msgSend(*(id *)(a1 + 136), "countByEnumeratingWithState:objects:count:", a1 + 144, a1 + 208, 4);
    v5 = -1;
    *(_QWORD *)(a1 + 248) = v6;
    *(_QWORD *)(a1 + 256) = -1;
  }
  if (*(_QWORD *)(a1 + 240) != **(_QWORD **)(a1 + 160))
  {
    objc_enumerationMutation(*(id *)(a1 + 136));
    v5 = *(_QWORD *)(a1 + 256);
  }
  v7 = *(_QWORD *)(a1 + 264) + 1;
  *(_QWORD *)(a1 + 256) = v5 + 1;
  *(_QWORD *)(a1 + 264) = v7;
  return a1;
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cbegin<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(void ***a1@<X0>, uint64_t a2@<X8>)
{
  id v4[17];
  id v5[17];
  id v6[34];

  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)v5, **a1);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)v4, *a1[1]);
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1EEEEJ26IDContainerIteratorAdaptorI7NSArrayIP8NSStringEES8_EEC2B8ne180100IJLm0ELm1EEJS8_S8_EJEJEJS8_S8_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSC_IJDpT2_EEEDpOT3_((uint64_t)v6, (uint64_t)v5, (uint64_t)v4);
  std::__tuple_impl<std::__tuple_indices<0ul,1ul>,IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>::__tuple_impl(a2, (uint64_t)v6);

}

void sub_1CBCBBA9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCBBB68(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1EEEEJ26IDContainerIteratorAdaptorI7NSArrayIP8NSStringEES8_EEC2B8ne180100IJLm0ELm1EEJS8_S8_EJEJEJS8_S8_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSC_IJDpT2_EEEDpOT3_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(a1, a2);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(v5 + 136, a3);
  return a1;
}

void sub_1CBCBBBB4(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCBBD34(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul>,IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(a1, a2);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(v4 + 136, a2 + 136);
  return a1;
}

void sub_1CBCBBD80(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cend<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(void ***a1@<X0>, uint64_t a2@<X8>)
{
  id v4[17];
  id v5[17];
  id v6[34];

  IDContainerIteratorAdaptor<NSArray<NSString *>>::IDContainerIteratorAdaptor((uint64_t)v5, -1, **a1);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::IDContainerIteratorAdaptor((uint64_t)v4, -1, *a1[1]);
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1EEEEJ26IDContainerIteratorAdaptorI7NSArrayIP8NSStringEES8_EEC2B8ne180100IJLm0ELm1EEJS8_S8_EJEJEJS8_S8_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSC_IJDpT2_EEEDpOT3_((uint64_t)v6, (uint64_t)v5, (uint64_t)v4);
  std::__tuple_impl<std::__tuple_indices<0ul,1ul>,IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>::__tuple_impl(a2, (uint64_t)v6);

}

void sub_1CBCBBE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSString *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCBBEB4(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t *TypeForUTI(NSString *a1)
{
  NSString *v1;
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  void *v13;
  NSObject *v14;
  uint64_t v15;
  id *v16;
  uint64_t v18;
  _QWORD block[5];
  NSString *v20;
  uint8_t buf[8];

  v1 = a1;
  v20 = v1;
  if (-[NSString length](v1, "length"))
  {
    {
      v18 = operator new();
      *(_OWORD *)v18 = 0u;
      *(_OWORD *)(v18 + 16) = 0u;
      *(_DWORD *)(v18 + 32) = 1065353216;
      TypeForUTI(NSString *)::sKnownCache = v18;
    }
    {
      TypeForUTI(NSString *)::sCacheSpinLock = 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&TypeForUTI(NSString *)::sCacheSpinLock);
    v4 = std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>((_QWORD *)TypeForUTI(NSString *)::sKnownCache, (id *)&v20);
    if (v4)
      v5 = v4[3];
    else
      v5 = 0;
    v6 = v5;
    if (!v6 && TypeForUTI(NSString *)::sRecentDynamicCache)
    {
      v7 = std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>((_QWORD *)TypeForUTI(NSString *)::sRecentDynamicCache, (id *)&v20);
      if (v7)
        v8 = v7[3];
      else
        v8 = 0;
      v6 = v8;
    }
    if (!v6 && TypeForUTI(NSString *)::sOldDynamicCache)
    {
      v9 = std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>((_QWORD *)TypeForUTI(NSString *)::sOldDynamicCache, (id *)&v20);
      if (v9)
        v10 = v9[3];
      else
        v10 = 0;
      v6 = v10;
    }
    if (!v6)
    {
      objc_msgSend(MEMORY[0x1E0CEC3F8], "typeWithIdentifier:", v20);
      v11 = (uint64_t *)objc_claimAutoreleasedReturnValue();
      v6 = v11;
      if (v11)
      {
        if ((objc_msgSend(v11, "isDynamic") & 1) != 0)
        {
          v12 = TypeForUTI(NSString *)::sRecentDynamicCache;
          if (!TypeForUTI(NSString *)::sRecentDynamicCache)
          {
            v12 = operator new();
            *(_OWORD *)v12 = 0u;
            *(_OWORD *)(v12 + 16) = 0u;
            *(_DWORD *)(v12 + 32) = 1065353216;
            std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(v12, 0x9C4uLL);
            TypeForUTI(NSString *)::sRecentDynamicCache = v12;
          }
          if (*(_QWORD *)(v12 + 24) >= 0x3E8uLL)
          {
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3321888768;
            block[2] = ___Z10TypeForUTIP8NSString_block_invoke;
            block[3] = &__block_descriptor_33_ea8_32c33_ZTSKZ10TypeForUTIP8NSStringE3__0_e5_v8__0l;
            if (TypeForUTI(NSString *)::__once__ != -1)
              dispatch_once(&TypeForUTI(NSString *)::__once__, block);
            v12 = TypeForUTI(NSString *)::sRecentDynamicCache;
            if (*(_QWORD *)(TypeForUTI(NSString *)::sRecentDynamicCache + 24) >= 0x9C4uLL)
            {
              v13 = (void *)MEMORY[0x1D17A5880]();
              LogObj(5);
              v14 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_1CBC4A000, v14, OS_LOG_TYPE_ERROR, "Swapping Dynamic UTType caches.", buf, 2u);
              }

              v15 = TypeForUTI(NSString *)::sOldDynamicCache;
              if (!TypeForUTI(NSString *)::sOldDynamicCache)
              {
                v15 = operator new();
                std::unordered_map<NSString * {__strong},UTType * {__strong}>::unordered_map(v15, 0x9C4uLL);
                TypeForUTI(NSString *)::sOldDynamicCache = v15;
              }
              std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::clear(v15);
              std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::swap(TypeForUTI(NSString *)::sOldDynamicCache, TypeForUTI(NSString *)::sRecentDynamicCache);
              objc_autoreleasePoolPop(v13);
              v12 = TypeForUTI(NSString *)::sRecentDynamicCache;
            }
          }
          *(_QWORD *)buf = &v20;
          v16 = (id *)std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(v12, (id *)&v20, (uint64_t)&std::piecewise_construct, (id **)buf);
        }
        else
        {
          *(_QWORD *)buf = &v20;
          v16 = (id *)std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(TypeForUTI(NSString *)::sKnownCache, (id *)&v20, (uint64_t)&std::piecewise_construct, (id **)buf);
        }
        objc_storeStrong(v16 + 3, v6);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&TypeForUTI(NSString *)::sCacheSpinLock);
    v1 = v20;
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1CBCBC23C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{

  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<NSString * {__strong},UTType * {__strong}>::unordered_map(uint64_t a1, size_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, a2);
  return a1;
}

void sub_1CBCBC300(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void ___Z10TypeForUTIP8NSString_block_invoke()
{
  NSObject *v0;
  uint8_t v1[16];

  LogObj(5);
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v1 = 0;
    _os_log_impl(&dword_1CBC4A000, v0, OS_LOG_TYPE_ERROR, "Dynamic UTType cache is larger then expected.", v1, 2u);
  }

}

uint64_t TFSInfo::GetName(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3;
  TString v5;

  TFSInfo::Name(a1, &v5);
  v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1CBCBC3C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::ReadOnlyError()
{
  return 4294959235;
}

uint64_t TFSInfo::GetDisplayName(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3;
  TString v5;

  TFSInfo::DisplayName(a1, &v5);
  v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1CBCBC42C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetPath(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3;
  TString *v5;

  TFSInfo::Path(a1, (CFTypeRef *)&v5);
  v3 = TPropertyReference::SetAs<TString>(a2, &v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5);
  return v3;
}

void sub_1CBCBC488(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetType(uint64_t a1, uint64_t a2)
{
  int v2;
  int v4;

  if (*(_BYTE *)(a1 + 112) == 21)
    v2 = 0;
  else
    v2 = *(_DWORD *)(a1 + 104);
  v4 = v2;
  return TPropertyReference::SetAs<unsigned int>(a2, &v4);
}

CFIndex TFSInfo::SetType(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unsigned int v4;
  CFIndex result;
  unsigned int v6;

  v6 = 0;
  v3 = TPropertyReference::As<unsigned int>(a2, &v6);
  v4 = v3;
  result = HIDWORD(v3);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 112) || *(_DWORD *)(a1 + 104) == v4)
      return 0;
    else
      return TFSInfo::SetType((TFSInfo *)a1, v4);
  }
  return result;
}

uint64_t TFSInfo::GetCreator(uint64_t a1, uint64_t a2)
{
  int v2;
  int v4;

  if (*(_BYTE *)(a1 + 112) == 21)
    v2 = 0;
  else
    v2 = *(_DWORD *)(a1 + 108);
  v4 = v2;
  return TPropertyReference::SetAs<unsigned int>(a2, &v4);
}

CFIndex TFSInfo::SetCreator(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  CFIndex result;
  unsigned int v5;

  v5 = 0;
  v3 = TPropertyReference::As<unsigned int>(a2, &v5);
  result = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    if (*(_BYTE *)(a1 + 112) || *(_DWORD *)(a1 + 108) == (_DWORD)v3)
      return 0;
    else
      return TFSInfo::SetCreator((TFSInfo *)a1, v3);
  }
  return result;
}

uint64_t TFSInfo::GetCreationDate(TFSInfo *a1, uint64_t a2)
{
  double CreationDate;

  CreationDate = TFSInfo::GetCreationDate(a1);
  return TPropertyReference::SetAs<double>(a2, &CreationDate);
}

CFIndex TFSInfo::SetCreationDate(uint64_t a1, uint64_t *a2)
{
  double v4;
  uint64_t *v5;

  if (*(_BYTE *)(a1 + 112))
    return 4294959224;
  v5 = (uint64_t *)0xC1E6CEAF20000000;
  v4 = COERCE_DOUBLE(TPropertyReference::As<double>(a2, &v5));
  if (TFSInfo::GetCreationDate((TFSInfo *)a1) == v4)
    return 0;
  else
    return TFSInfo::SetTimeProperty((TFSInfo *)a1, (const __CFString *)*MEMORY[0x1E0C9B408], v4);
}

CFIndex TFSInfo::SetModificationDate(TFSInfo *a1, uint64_t *a2)
{
  double v3;
  CFIndex v4;
  CFIndex result;
  CFAbsoluteTime v6;
  uint64_t *v7;

  v7 = (uint64_t *)0xC1E6CEAF20000000;
  v3 = COERCE_DOUBLE(TPropertyReference::As<double>(a2, &v7));
  result = v4;
  if (!(_DWORD)v4)
  {
    v6 = v3;
    if (TFSInfo::GetModificationDate(a1) == v3)
      return 0;
    else
      return TFSInfo::SetTimeProperty(a1, (const __CFString *)*MEMORY[0x1E0C9B400], v6);
  }
  return result;
}

uint64_t TFSInfo::GetDateAdded(TFSInfo *a1, uint64_t a2)
{
  double DateAddedDate;

  DateAddedDate = TFSInfo::GetDateAddedDate(a1);
  return TPropertyReference::SetAs<double>(a2, &DateAddedDate);
}

uint64_t TFSInfo::IsLocked(TFSInfo *a1, uint64_t a2)
{
  char IsLocked;

  IsLocked = TFSInfo::IsLocked(a1);
  return TPropertyReference::SetAs<BOOL>(a2, &IsLocked);
}

CFIndex TFSInfo::SetIsLocked(TFSInfo *a1, unint64_t a2)
{
  unint64_t v3;
  unsigned __int8 v4;
  CFIndex result;
  const __CFString **v6;
  unsigned __int8 v7;

  v7 = 0;
  v3 = TPropertyReference::As<BOOL>(a2, &v7);
  v4 = v3;
  result = HIDWORD(v3);
  if (!(_DWORD)result)
  {
    if (TFSInfo::IsLocked(a1) == v4)
    {
      return 0;
    }
    else
    {
      v6 = (const __CFString **)MEMORY[0x1E0C9AE40];
      if (v4)
        v6 = (const __CFString **)MEMORY[0x1E0C9AE50];
      return TFSInfo::SetProperty(a1, (const __CFString *)*MEMORY[0x1E0C9B548], *v6);
    }
  }
  return result;
}

uint64_t TFSInfo::IsSystemRestrictionEffective(uint64_t a1, uint64_t a2)
{
  char v3;

  v3 = 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v3);
}

uint64_t TFSInfo::IsNoUnlinkEffective(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  char BooleanProperty;

  BooleanProperty = TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)(a1 + 8), (const __CFString *)*MEMORY[0x1E0C9ACD0], a3);
  return TPropertyReference::SetAs<BOOL>(a2, &BooleanProperty);
}

uint64_t TFSInfo::IsStationery(TFSInfo *a1, uint64_t a2)
{
  __int16 v3;
  BOOL v5;

  TFSInfo::GetFinderInfo(a1);
  v5 = (v3 & 0x800) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v5);
}

CFIndex TFSInfo::SetIsStationery(TFSInfo *a1, unint64_t a2)
{
  unint64_t v3;
  unsigned __int8 v4;
  CFIndex result;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[4];

  LOBYTE(v10[0]) = 0;
  v3 = TPropertyReference::As<BOOL>(a2, (unsigned __int8 *)v10);
  v4 = v3;
  result = HIDWORD(v3);
  if (!(_DWORD)result)
  {
    v6 = v4;
    TFSInfo::GetFinderInfo(a1);
    if (((v7 >> 11) & 1) == v6)
    {
      return 0;
    }
    else
    {
      v10[0] = TFSInfo::GetFinderInfo(a1);
      v10[1] = v8 & 0xFFFFFFFFFFFFF7FFLL | ((unint64_t)(v6 != 0) << 11);
      v10[2] = TFSInfo::GetExtendedFinderInfo(a1);
      v10[3] = v9;
      return TFSInfo::SetTotalFinderInfo(a1, (const UInt8 *)v10);
    }
  }
  return result;
}

uint64_t TFSInfo::IsVisible(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  char v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  v6 = v3 & 1;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

CFIndex TFSInfo::SetIsVisible(TFSInfo *a1, unint64_t a2)
{
  unint64_t v3;
  char v4;
  CFIndex result;
  unsigned __int8 v6;

  v6 = 0;
  v3 = TPropertyReference::As<BOOL>(a2, &v6);
  v4 = v3;
  result = HIDWORD(v3);
  if (!(_DWORD)result)
    return TFSInfo::SetIsInvisible(a1, v4 == 0);
  return result;
}

uint64_t TFSInfo::IsContainer(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  BOOL v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  v6 = (v3 & 0x20) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::IsAlias(TFSInfo *a1, uint64_t a2)
{
  BOOL IsAlias;

  IsAlias = TFSInfo::IsAlias(a1);
  return TPropertyReference::SetAs<BOOL>(a2, &IsAlias);
}

uint64_t TFSInfo::GetDataLogicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t DataLogicalSize;

  DataLogicalSize = TFSInfo::GetDataLogicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &DataLogicalSize);
}

uint64_t TFSInfo::GetResourceLogicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t ResourceLogicalSize;

  ResourceLogicalSize = TFSInfo::GetResourceLogicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &ResourceLogicalSize);
}

uint64_t TFSInfo::GetDataPhysicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t DataPhysicalSize;

  DataPhysicalSize = TFSInfo::GetDataPhysicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &DataPhysicalSize);
}

uint64_t TFSInfo::GetResourcePhysicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t ResourcePhysicalSize;

  ResourcePhysicalSize = TFSInfo::GetResourcePhysicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &ResourcePhysicalSize);
}

uint64_t TFSInfo::IsSystemCompressed(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  BOOL v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LODWORD(v3) = *(os_unfair_lock_s *)((char *)v3 + 115);
  os_unfair_lock_unlock(v4);
  v6 = ((unsigned __int16)v3 & 0x200) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::IsVolume(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  char v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = v3[29]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v4);
  v6 = v3 & 1;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::ObjectIdentifier(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3;
  TString v5;

  TFSInfo::ObjectIdentifier(a1, &v5);
  v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1CBCBCCA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOwner(TFSInfo *a1, uint64_t a2)
{
  int Owner;

  Owner = TFSInfo::GetOwner(a1);
  return TPropertyReference::SetAs<int>(a2, &Owner);
}

uint64_t TFSInfo::SetOwner(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uid_t v5;
  __CFFileSecurity *v6;
  uid_t owner;
  CFFileSecurityRef fileSec;

  LODWORD(fileSec) = 0;
  v3 = TPropertyReference::As<int>(a2, (unsigned int *)&fileSec);
  v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    if (*(_QWORD *)(a1 + 8))
    {
      v5 = v3;
      v6 = (__CFFileSecurity *)TFSInfo::CopyPermissions((TFSInfo *)a1);
      fileSec = v6;
      if (v6 && (owner = 0, CFFileSecurityGetOwner(v6, &owner), owner != v5) && CFFileSecuritySetOwner(fileSec, v5))
        v4 = TFSInfo::SetProperty((TFSInfo *)a1, (const __CFString *)*MEMORY[0x1E0C9B4A0], (const __CFString *)fileSec);
      else
        v4 = 0;
      TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
    }
    else
    {
      return 4294959238;
    }
  }
  return v4;
}

void sub_1CBCBCDB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUserGroups(TFSInfo *a1, uint64_t a2)
{
  int UserGroups;

  UserGroups = TFSInfo::GetUserGroups(a1);
  return TPropertyReference::SetAs<int>(a2, &UserGroups);
}

uint64_t TFSInfo::SetUserGroups(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  gid_t v5;
  __CFFileSecurity *v6;
  uid_t owner;
  CFFileSecurityRef fileSec;

  LODWORD(fileSec) = 0;
  v3 = TPropertyReference::As<int>(a2, (unsigned int *)&fileSec);
  v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    if (*(_QWORD *)(a1 + 8))
    {
      v5 = v3;
      v6 = (__CFFileSecurity *)TFSInfo::CopyPermissions((TFSInfo *)a1);
      fileSec = v6;
      if (v6 && (owner = 0, CFFileSecurityGetOwner(v6, &owner), owner != v5) && CFFileSecuritySetGroup(fileSec, v5))
        v4 = TFSInfo::SetProperty((TFSInfo *)a1, (const __CFString *)*MEMORY[0x1E0C9B4A0], (const __CFString *)fileSec);
      else
        v4 = 0;
      TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
    }
    else
    {
      return 4294959238;
    }
  }
  return v4;
}

void sub_1CBCBCEC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetMode(TFSInfo *a1, uint64_t a2)
{
  __int16 Mode;

  Mode = TFSInfo::GetMode(a1);
  return TPropertyReference::SetAs<short>(a2, &Mode);
}

CFIndex TFSInfo::SetMode(TFSInfo *a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unsigned __int16 v6;

  v6 = 0;
  v3 = TPropertyReference::As<short>(a2, &v6);
  v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
    return TFSInfo::SetModeDetails(a1, v3);
  return v4;
}

uint64_t TFSInfo::GetUserAccess(TFSInfo *a1, uint64_t a2)
{
  __int16 UserAccess;

  UserAccess = TFSInfo::GetUserAccess(a1);
  return TPropertyReference::SetAs<short>(a2, &UserAccess);
}

uint64_t TFSInfo::IsExtensionHidden(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  BOOL v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  v6 = (v3 & 8) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

unint64_t TFSInfo::SetIsExtensionHidden(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  unsigned int v6;
  unsigned __int8 v8;

  v8 = 0;
  v3 = TPropertyReference::As<BOOL>(a2, &v8);
  v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    v5 = v3;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    v6 = *(unsigned __int8 *)(a1 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    if (((v6 >> 3) & 1) != v5)
      TFSInfo::SetIsExtensionHidden((TFSInfo *)a1, v5 != 0);
  }
  return v4;
}

uint64_t TFSInfo::CanSetExtensionHidden(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  uint32_t v5;
  unint64_t v6;
  BOOL v8;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  v5 = *(uint32_t *)((char *)&v3[28]._os_unfair_lock_opaque + 3);
  v3 = (os_unfair_lock_s *)((char *)v3 + 115);
  v6 = v5 | ((unint64_t)LOWORD(v3[1]._os_unfair_lock_opaque) << 32) | 0x80000000000;
  v3->_os_unfair_lock_opaque = v5;
  LOWORD(v3[1]._os_unfair_lock_opaque) = WORD2(v6);
  os_unfair_lock_unlock(v4);
  os_unfair_lock_lock(v4);
  LOBYTE(v3) = v3->_os_unfair_lock_opaque;
  os_unfair_lock_unlock(v4);
  v8 = (v3 & 0x10) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v8);
}

uint64_t TFSInfo::IsPackage(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  BOOL v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  v6 = (v3 & 2) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::IsApplication(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  BOOL v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  v6 = (v3 & 4) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::GetApplicationDMFPolicy(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v6;
  __int16 v7;
  __int16 v8;

  if (!*(_BYTE *)(a1 + 112)
    && *(_QWORD *)(a1 + 8)
    && (os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100)),
        v6 = *(_DWORD *)(a1 + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100)),
        (v6 & 4) != 0))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (*(char *)(a1 + 113) == -1)
    {
      *(_BYTE *)(a1 + 113) = 0;
      v3 = 4294959210;
    }
    else
    {
      v8 = *(char *)(a1 + 113);
      v3 = TPropertyReference::SetAs<short>(a2, &v8);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
  else
  {
    v7 = 0;
    return TPropertyReference::SetAs<short>(a2, &v7);
  }
  return v3;
}

void sub_1CBCBD288(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetIFSymbol(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3;
  id v5;

  TFSInfo::FetchIFSymbol(a1);
  v5 = (id)objc_claimAutoreleasedReturnValue();
  v3 = TPropertyReference::SetAs<IFSymbol * {__strong}>(a2, &v5);

  return v3;
}

void sub_1CBCBD2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SupportsFileSharing()
{
  return 4294959245;
}

uint64_t TFSInfo::SupportsScreenSharing()
{
  return 4294959245;
}

uint64_t TFSInfo::IsMountedSharepoint()
{
  return 4294959245;
}

uint64_t TFSInfo::GetSortingGroup()
{
  return 4294959245;
}

uint64_t TFSInfo::GetNetworkConnectionState()
{
  return 4294959245;
}

uint64_t TFSInfo::GetServerUserName()
{
  return 4294959245;
}

uint64_t TFSInfo::GetNetworkComment()
{
  return 4294959245;
}

uint64_t TFSInfo::GetContact()
{
  return 4294959245;
}

uint64_t TFSInfo::GetCapacity(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  os_unfair_lock_s *v6;
  uint64_t result;
  uint64_t Capacity;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v6);
  if (!*a3)
    return 4294959245;
  Capacity = TFSVolumeInfo::GetCapacity(*a3);
  result = TPropertyReference::SetAs<long long>(a2, &Capacity);
  if (!(_DWORD)result)
  {
    if (TFSVolumeInfo::SpaceAndCapacityAreUpToDate(*a3, 0))
      return 0;
    else
      return 4294959210;
  }
  return result;
}

uint64_t TFSInfo::GetFreeSpace(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  os_unfair_lock_s *v6;
  uint64_t FreeSpace;
  uint64_t result;
  uint64_t v9;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v6);
  if (!*a3)
    return 4294959245;
  FreeSpace = TFSVolumeInfo::GetFreeSpace(*a3);
  v9 = FreeSpace + TFSVolumeInfo::GetReclaimableSpace(*a3);
  if (v9 < 0)
    v9 = TFSVolumeInfo::GetFreeSpace(*a3);
  result = TPropertyReference::SetAs<long long>(a2, &v9);
  if (!(_DWORD)result)
  {
    if (TFSVolumeInfo::SpaceAndCapacityAreUpToDate(*a3, 1))
      return 0;
    else
      return 4294959210;
  }
  return result;
}

uint64_t TFSInfo::GetReclaimableSpace(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  os_unfair_lock_s *v6;
  uint64_t result;
  uint64_t ReclaimableSpace;

  v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v6);
  if (!*a3)
    return 4294959245;
  ReclaimableSpace = TFSVolumeInfo::GetReclaimableSpace(*a3);
  result = TPropertyReference::SetAs<long long>(a2, &ReclaimableSpace);
  if (!(_DWORD)result)
  {
    if (TFSVolumeInfo::SpaceAndCapacityAreUpToDate(*a3, 1))
      return 0;
    else
      return 4294959210;
  }
  return result;
}

uint64_t TFSInfo::GetVolumeFormat(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  __int16 VolumeFormat;

  if (!*a3)
    return 4294959245;
  VolumeFormat = TFSVolumeInfo::GetVolumeFormat(*a3);
  return TPropertyReference::SetAs<short>(a2, &VolumeFormat);
}

uint64_t TFSInfo::GetVolumeFormatString(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  uint64_t v4;
  TString v6;

  if (!*a3)
    return 4294959245;
  TFSVolumeInfo::GetVolumeFormatString(*a3, &v6);
  v4 = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return v4;
}

void sub_1CBCBD5B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSystemBuildVersion(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  TString **v4;

  if (!*a3)
    return 4294959245;
  v4 = (TString **)TFSVolumeInfo::SystemBuildVersion(*a3);
  return TPropertyReference::SetAs<TString>(a2, v4);
}

uint64_t TFSInfo::GetAboutToUnmount(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  BOOL v4;
  BOOL v6;

  v3 = *a3;
  if (!*a3)
    return 4294959245;
  if (*(_BYTE *)(v3 + 123))
    v4 = 1;
  else
    v4 = *(_BYTE *)(v3 + 128) != 0;
  v6 = v4;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::GetVolUUID(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  uint64_t v4;
  TString v6;

  if (!*a3)
    return 4294959245;
  TFSVolumeInfo::GetUUID(*a3, &v6);
  v4 = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return v4;
}

void sub_1CBCBD6B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetShortVersion(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t ShortVersion;
  const __CFString *v9;

  v9 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  ShortVersion = TFSInfo::GetShortVersion(a1, (const void **)&v9, a4);
  if (!(_DWORD)ShortVersion)
    ShortVersion = TPropertyReference::SetAs<TString>(a2, (TString **)&v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9);
  return ShortVersion;
}

void sub_1CBCBD744(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLongVersion(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t LongVersion;
  TString v9;

  v9.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  LongVersion = TFSInfo::GetLongVersion(a1, &v9, a4);
  if (!(_DWORD)LongVersion)
    LongVersion = TPropertyReference::SetAs<TString>(a2, (TString **)&v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  return LongVersion;
}

void sub_1CBCBD7D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSystemVersion(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t SystemVersion;
  TString v9;

  v9.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  SystemVersion = TFSInfo::GetSystemVersion(a1, &v9, a4);
  if (!(_DWORD)SystemVersion)
    SystemVersion = TPropertyReference::SetAs<TString>(a2, (TString **)&v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  return SystemVersion;
}

void sub_1CBCBD864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetCopyrightString(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t CopyrightString;
  TString v9;

  v9.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  CopyrightString = TFSInfo::GetCopyrightString(a1, &v9, a4);
  if (!(_DWORD)CopyrightString)
    CopyrightString = TPropertyReference::SetAs<TString>(a2, (TString **)&v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  return CopyrightString;
}

void sub_1CBCBD8F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetKindWithoutPlatformString(TFSInfo *a1, uint64_t a2, uint64_t a3, char a4, _BYTE *a5)
{
  uint64_t KindWithoutPlatform;
  uint64_t v10;
  uint64_t v11;
  TString v13;

  v13.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  KindWithoutPlatform = TFSInfo::GetKindWithoutPlatform(a1, &v13, a4, a5);
  v10 = KindWithoutPlatform;
  if ((_DWORD)KindWithoutPlatform && (_DWORD)KindWithoutPlatform != -8086
    || (v11 = TPropertyReference::SetAs<TString>(a2, (TString **)&v13), !(_DWORD)v11))
  {
    v11 = v10;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  return v11;
}

void sub_1CBCBD9A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetTypeIdentifierString(TFSInfo *a1, uint64_t a2, uint64_t a3, char a4, _BYTE *a5)
{
  uint64_t UTType;
  uint64_t v7;
  void *v9;
  uint64_t v10;
  id v11;
  CFTypeRef v13;
  id location;

  location = 0;
  UTType = TFSInfo::GetUTType(a1, &location, a4, a5);
  v7 = UTType;
  if ((_DWORD)UTType != -8086 && (_DWORD)UTType != 0)
  {
    v11 = location;
LABEL_7:
    v10 = v7;
    goto LABEL_8;
  }
  v11 = location;
  objc_msgSend(location, "identifier");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = v9;
  v10 = TPropertyReference::SetAs<__CFString const*>(a2, &v13);

  if (!(_DWORD)v10)
    goto LABEL_7;
LABEL_8:

  return v10;
}

void sub_1CBCBDA50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetPhysicalSize(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t PhysicalSize;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v4);
  PhysicalSize = TFSInfo::GetPhysicalSize((TFSInfo *)a1);
  TPropertyReference::SetAs<long long>(a2, &PhysicalSize);
  os_unfair_lock_lock(v4);
  LODWORD(a2) = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((a2 & 0x2000000) == 0
    && ((os_unfair_lock_lock(v4), v5 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v4), (v5 & 0x10000000) != 0)
     || *(_BYTE *)(a1 + 112) == 7))
  {
    return 0;
  }
  else
  {
    return 4294959210;
  }
}

uint64_t TFSInfo::GetLogicalSize(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t LogicalSize;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v4);
  LogicalSize = TFSInfo::GetLogicalSize((TFSInfo *)a1);
  TPropertyReference::SetAs<long long>(a2, &LogicalSize);
  os_unfair_lock_lock(v4);
  LODWORD(a2) = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((a2 & 0x2000000) == 0
    && ((os_unfair_lock_lock(v4), v5 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v4), (v5 & 0x10000000) != 0)
     || *(_BYTE *)(a1 + 112) == 7))
  {
    return 0;
  }
  else
  {
    return 4294959210;
  }
}

uint64_t TFSInfo::GetDeepItemCount(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  int v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  _QWORD v10[4];
  char v11;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  v5 = *(uint32_t *)((char *)&v3[28]._os_unfair_lock_opaque + 3);
  v3 = (os_unfair_lock_s *)((char *)v3 + 115);
  v3->_os_unfair_lock_opaque = v5 | 0x8000000;
  os_unfair_lock_unlock(v4);
  v6 = (os_unfair_lock_s *)((char *)v3 - 19);
  os_unfair_lock_lock((os_unfair_lock_s *)((char *)v3 - 19));
  v7 = *(os_unfair_lock_s **)((char *)&v3[-9]._os_unfair_lock_opaque + 1);
  if (v7)
  {
    TFSInfoOverflow::FolderSizeRecord(v7, (uint64_t)v10);
    if (v11)
      v8 = v10[2];
    else
      v8 = -1;
  }
  else
  {
    v8 = -1;
  }
  os_unfair_lock_unlock(v6);
  v10[0] = v8;
  return TPropertyReference::SetAs<long long>(a2, v10);
}

void sub_1CBCBDC9C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetDeepVisibleItemCount(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  int v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  _QWORD v10[4];
  char v11;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  v5 = *(uint32_t *)((char *)&v3[28]._os_unfair_lock_opaque + 3);
  v3 = (os_unfair_lock_s *)((char *)v3 + 115);
  v3->_os_unfair_lock_opaque = v5 | 0x8000000;
  os_unfair_lock_unlock(v4);
  v6 = (os_unfair_lock_s *)((char *)v3 - 19);
  os_unfair_lock_lock((os_unfair_lock_s *)((char *)v3 - 19));
  v7 = *(os_unfair_lock_s **)((char *)&v3[-9]._os_unfair_lock_opaque + 1);
  if (v7)
  {
    TFSInfoOverflow::FolderSizeRecord(v7, (uint64_t)v10);
    if (v11)
      v8 = v10[3];
    else
      v8 = -1;
  }
  else
  {
    v8 = -1;
  }
  os_unfair_lock_unlock(v6);
  v10[0] = v8;
  return TPropertyReference::SetAs<long long>(a2, v10);
}

void sub_1CBCBDD4C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLastUsedDate(uint64_t a1, uint64_t a2, uint64_t a3, char a4, _BYTE *a5)
{
  id v9;
  void *v10;
  int v11;
  uint64_t v12;
  id v13;
  char v14;
  uint64_t v16;
  void *v17;
  double v18;

  v9 = *(id *)(a1 + 72);
  v10 = *(void **)(a1 + 72);
  if (v10)
    goto LABEL_2;
  if ((a4 & 0x82) != 0)
  {
    v12 = 4294959222;
  }
  else
  {
    TFSInfo::LastUsedDate((TFSInfo *)a1);
    v16 = objc_claimAutoreleasedReturnValue();
    v17 = *(void **)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v16;

    v10 = *(void **)(a1 + 72);
    if (v10)
    {
LABEL_2:
      v11 = 0;
      v12 = 0;
      goto LABEL_6;
    }
    v12 = 0;
  }
  objc_msgSend(MEMORY[0x1E0C99D68], "distantPast");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 1;
LABEL_6:
  v13 = v10;
  v18 = MEMORY[0x1D17A4A1C]();
  TPropertyReference::SetAs<double>(a2, &v18);

  if (v11)
  if (*(_QWORD *)(a1 + 72))
    v14 = objc_msgSend(v9, "isEqualToDate:") ^ 1;
  else
    v14 = 0;
  *a5 = v14;

  return v12;
}

void sub_1CBCBDE68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetTagsAndAttributes(TFSInfo *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;

  v6 = 0;
  TPropertyReference::As<__CFArray const*>(a2, &v6);
  v4 = v3;
  if (!(_DWORD)v3)
    TFSInfo::GetLabel(a1);
  return v4;
}

uint64_t TFSInfo::GetUbiquityStatus(TFSInfo *a1, uint64_t a2)
{
  int BladeRunnerFlags;
  uint64_t result;
  uint64_t v5;

  BladeRunnerFlags = TFSInfo::GetBladeRunnerFlags(a1);
  v5 = BladeRunnerFlags & 0x7FFFFFFF;
  LODWORD(result) = TPropertyReference::SetAs<long long>(a2, &v5);
  if ((_DWORD)result)
    return result;
  else
    return (BladeRunnerFlags >> 31) & 0xFFFFE06A;
}

uint64_t TFSInfo::GetUbiquityFault(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  unint64_t v5;
  const __CFString *v6;
  char v7;
  char v9;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v5 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x400000000) != 0
    || (TCFURLInfo::GetNumericalProperty(*(const __CFURL **)(a1 + 8), (const __CFString *)*MEMORY[0x1E0C9AC48], v6) & 0x40000000) != 0)
  {
    v7 = 1;
  }
  else
  {
    v7 = TFSInfo::GetBladeRunnerFlags((TFSInfo *)a1) & 1;
  }
  v9 = v7;
  return TPropertyReference::SetAs<BOOL>(a2, &v9);
}

uint64_t TFSInfo::GetICloudSharePerson(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3;
  id v5;

  TFSInfo::CopyICloudSharePerson(a1);
  v5 = (id)objc_claimAutoreleasedReturnValue();
  v3 = TPropertyReference::SetAs<NSPersonNameComponents * {__strong}>(a2, &v5);

  return v3;
}

void sub_1CBCBE008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetICloudSharePersonString(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  TString v5;

  UseFileProviderFramework();
  TString::TString(&v5, "", 0);
  v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1CBCBE074(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetICloudLastEditor(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  uint64_t v4;
  id v6;

  v3 = a1 + 24;
  os_unfair_lock_lock(a1 + 24);
  os_unfair_lock_unlock(v3);
  v6 = 0;
  v4 = TPropertyReference::SetAs<NSPersonNameComponents * {__strong}>(a2, &v6);

  return v4;
}

void sub_1CBCBE0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSLHighlight()
{
  return 4294967246;
}

uint64_t TFSInfo::GetSLHighlightID()
{
  return 4294967246;
}

uint64_t TFSInfo::GetIsTopLevelSharedItem(TFSInfo *a1, uint64_t a2)
{
  char IsTopLevelSharedItem;

  IsTopLevelSharedItem = TFSInfo::IsTopLevelSharedItem(a1);
  return TPropertyReference::SetAs<BOOL>(a2, &IsTopLevelSharedItem);
}

uint64_t TFSInfo::GetOldViewStyle(TFSInfo *a1, uint64_t a2)
{
  __int16 OldViewStyle;

  OldViewStyle = TFSInfo::GetOldViewStyle(a1);
  return TPropertyReference::SetAs<short>(a2, &OldViewStyle);
}

uint64_t TFSInfo::GetOldLocation(TFSInfo *a1, uint64_t a2)
{
  int OldLocation;

  OldLocation = TFSInfo::GetOldLocation(a1);
  return TPropertyReference::SetAs<Point>(a2, &OldLocation);
}

uint64_t TFSInfo::GetOldIconOrigin(TFSInfo *a1, uint64_t a2)
{
  int OldIconOrigin;

  OldIconOrigin = TFSInfo::GetOldIconOrigin(a1);
  return TPropertyReference::SetAs<Point>(a2, &OldIconOrigin);
}

uint64_t TFSInfo::GetResumableCopy(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  BOOL v6;

  v3 = a1;
  v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOWORD(v3) = *(_WORD *)((char *)&v3[29]._os_unfair_lock_opaque + 3);
  os_unfair_lock_unlock(v4);
  v6 = ((unsigned __int16)v3 & 0x1000) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::SetProperty(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t (*v9)(_QWORD *, uint64_t, uint64_t, uint64_t);
  _QWORD *v10;
  _BYTE v12[24];
  uint64_t (*v13)(_QWORD *, uint64_t, uint64_t, uint64_t);
  uint64_t v14;

  if (!GetPropertyRecord(a2, (uint64_t)v12))
    return 4294959245;
  v9 = v13;
  v10 = (_QWORD *)(a1 + (v14 >> 1));
  if ((v14 & 1) != 0)
    v9 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v10 + v13);
  return v9(v10, a3, a4, a5);
}

void TFSInfo::ObjectIdentifier(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  int v4;
  void *v5;
  void *v6;
  TString *v7;
  TString *v8;
  uint64_t ObjectIdentifier;
  uint64_t VolumeIdentifier;
  id v11;
  char __str[256];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = *((unsigned __int8 *)this + 112);
  if (v4 == 28)
  {
    TFSInfo::GetFPItem(this);
    v11 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "itemID");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "identifier");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3500], "URLHostAllowedCharacterSet");
    v7 = (TString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "stringByAddingPercentEncodingWithAllowedCharacters:", v7);
    v8 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, v8);

    goto LABEL_5;
  }
  if (v4 == 27)
  {
    TFSInfo::GetFPItem(this);
    v11 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "providerDomainID");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3500], "URLHostAllowedCharacterSet");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "stringByAddingPercentEncodingWithAllowedCharacters:", v6);
    v7 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, v7);

LABEL_5:
    return;
  }
  ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
  VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
  snprintf(__str, 0x100uLL, "%llu.%llu", VolumeIdentifier, ObjectIdentifier);
  TString::TString(a2, __str);
}

void sub_1CBCBE4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(exception_object);
}

unint64_t TFSInfo::IsSymlink(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 6) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

void TFSInfo::TFSInfo(TFSInfo *this, FIProviderDomain *a2, FPItem *a3, int a4)
{
  FIProviderDomain *v7;
  FPItem *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  FPProviderDomain *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t Overflow;
  os_unfair_lock_s *v19;
  int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  void *v26;
  BOOL v27;
  void *v28;
  TString *v29;
  uint64_t v30;
  uint64_t v31;
  CFURLRef v32;
  const void *v33;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  TFSInfoOverflow *v38;
  uint64_t v39;
  FPItem *v40;
  id v41;
  TString v42;
  TString *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  TFSInfo::TFSInfo(this);
  -[FIProviderDomain domain](v7, "domain");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v9)
  {
    -[FIProviderDomain asyncFetchedDomain](v7, "asyncFetchedDomain");
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v10)
      goto LABEL_5;
    -[FIProviderDomain asyncFetchedDomain](v7, "asyncFetchedDomain");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    +[FIProviderDomain providerDomainForDomain:](FIProviderDomain, "providerDomainForDomain:", v9);
    v11 = objc_claimAutoreleasedReturnValue();

    v7 = (FIProviderDomain *)v11;
  }

LABEL_5:
  -[FIProviderDomain domain](v7, "domain");
  v12 = objc_claimAutoreleasedReturnValue();

  if (v12)
  {
    -[FIProviderDomain domain](v7, "domain");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFE | objc_msgSend(v13, "isHidden") ^ 1;

    *((_BYTE *)this + 112) = 27;
    v14 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFE7FF8FFFFFCFLL | 0x80070000020;
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0x8FFFFFCF | 0x70000020;
    *(_WORD *)((char *)this + 119) = WORD2(v14);
    -[FIProviderDomain domain](v7, "domain");
    v15 = (FPProviderDomain *)objc_claimAutoreleasedReturnValue();
    ProviderDisplayName(v15, &v42);
  }
  else
  {
    v16 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
    *((_BYTE *)this + 112) = 27;
    v17 = v16 & 0xFFFFE7FF8FFFFFCELL | 0x80070000020;
    *(_DWORD *)((char *)this + 115) = v17 | 1;
    *(_WORD *)((char *)this + 119) = WORD2(v17);
    -[FIProviderDomain identifier](v7, "identifier");
    v15 = (FPProviderDomain *)(id)objc_claimAutoreleasedReturnValue();
    v42.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v42, (TString *)v15);

  }
  TFSInfo::SetItemName(this, &v42);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);

  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  Overflow = (uint64_t)TFSInfo::GetOrCreateOverflow(this);
  v19 = (os_unfair_lock_s *)(Overflow + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
  v20 = *(unsigned __int8 *)(Overflow + 76);
  if (v20 == 2)
  {
    TFSInfoOverflow::MigrateToType(Overflow, 1);
    LOBYTE(v20) = *(_BYTE *)(Overflow + 76);
  }
  else if (v20 == 3)
  {
    LOBYTE(v20) = 1;
    *(_BYTE *)(Overflow + 76) = 1;
    *(_QWORD *)(Overflow + 32) = 0;
    *(_OWORD *)Overflow = 0u;
    *(_OWORD *)(Overflow + 16) = 0u;
    *(_DWORD *)(Overflow + 32) = 0x80000000;
  }
  v21 = v20;
  v22 = Overflow & 0xFFFFFFFFFFFFFF00;
  v23 = Overflow & 0xF8;
  os_unfair_lock_unlock(v19);
  if (v21 == 1)
    v24 = v23;
  else
    v24 = 0;
  v25 = v24 | v22;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  objc_storeStrong((id *)(v25 + 24), v7);
  if (!v8 && a4)
  {
    if (-[FIProviderDomain expectFPItems](v7, "expectFPItems"))
    {
      FPItemManagerInstance();
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      v27 = v26 == 0;

      if (!v27)
      {
        -[FIProviderDomain domain](v7, "domain");
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        v39 = 0x4014000000000000;
        v43 = 0;
        TNode::RootFPItemForDomainWithTimeout(v28, (double *)&v39, (uint64_t)&v42, &v40);
        if (v41)
        {
          v8 = 0;
        }
        else
        {
          v8 = v40;
          v40 = 0;
        }

        v29 = v43;
        if (v43 == &v42)
        {
          v30 = 4;
          v29 = &v42;
        }
        else
        {
          if (!v43)
          {
LABEL_28:

            goto LABEL_29;
          }
          v30 = 5;
        }
        (*((void (**)(void))&v29->fString.fRef->isa + v30))();
        goto LABEL_28;
      }
    }
    v8 = 0;
  }
LABEL_29:
  if (v8 || !v12)
  {
    objc_storeStrong((id *)this + 8, v8);
    -[FPItem fileURL](v8, "fileURL");
    v31 = objc_claimAutoreleasedReturnValue();
    if (!(v31 | v12))
    {
      if (!-[FIProviderDomain isUsingFPFS](v7, "isUsingFPFS"))
      {
        v31 = 0;
LABEL_40:

        goto LABEL_41;
      }
      -[FIProviderDomain rootURL](v7, "rootURL");
      v31 = objc_claimAutoreleasedReturnValue();
    }
    if (v31 && -[FIProviderDomain isUsingFPFS](v7, "isUsingFPFS"))
    {
      v32 = CFURLCreateFileReferenceURL(0, (CFURLRef)v31, 0);
      v33 = (const void *)*((_QWORD *)this + 2);
      if (v33)
        CFRelease(v33);
      *((_QWORD *)this + 2) = v32;
    }
    goto LABEL_40;
  }
LABEL_41:
  TFSInfo::FetchISIcon(this);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v34, "symbol");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = v35;
  if (v35)
  {
    v37 = v35;
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v38 = TFSInfo::GetOrCreateOverflow(this);
    TFSInfoOverflow::SetIFSymbol((uint64_t)v38, v37);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);

  }
}

void sub_1CBCBEA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  void *v15;
  TFSInfo *v16;
  char *v17;
  void *v18;
  char *v20;
  uint64_t v21;

  v20 = a15;
  if (a15 == v17)
  {
    v21 = 4;
    v20 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:

  TFSInfo::~TFSInfo(v16);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::Initialize(TFSInfo *this, FPItem *a2, int a3)
{
  FPItem *v5;
  FPItem *v6;
  const void *v7;
  CFIndex v8;
  void *v9;
  unint64_t v10;
  TString *v11;
  unint64_t v12;
  TString v14;
  const void *v15;

  v5 = a2;
  v6 = v5;
  if (!a3)
  {
    *((_BYTE *)this + 112) = 28;
    v12 = *(_DWORD *)((char *)this + 115) & 0xF9FFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xF9FFFFFF | 0x4000000;
    *(_WORD *)((char *)this + 119) = WORD2(v12);
    TFSInfo::SetFPItem(this, v5);
    TFSInfo::FetchProperties(this, 0);
    v8 = 0;
    goto LABEL_8;
  }
  v7 = CopyURLForFPItem(v5, 0);
  v15 = v7;
  if (!v7)
  {
    v8 = 4294967253;
    goto LABEL_7;
  }
  v8 = TFSInfo::initialize((uint64_t)this, (const __CFURL *)v7, 0, 1, 1, 1, 0);
  if ((_DWORD)v8)
  {
LABEL_7:
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v15);
    goto LABEL_8;
  }
  *(_DWORD *)((char *)this + 115) |= 0x40003821u;
  -[FPItem documentSize](v6, "documentSize");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | ((v9 != 0) << 28);
  *(_WORD *)((char *)this + 119) = WORD2(v10);

  -[FPItem displayName](v6, "displayName");
  v11 = (TString *)objc_claimAutoreleasedReturnValue();
  v14.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v14, v11);
  TFSInfo::SetItemName(this, &v14);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);

  *((_BYTE *)this + 112) = 25;
  TFSInfo::SetFPItem(this, v6);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v15);
  v8 = 0;
LABEL_8:

  return v8;
}

void sub_1CBCBECF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  void *v10;
  void *v11;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::initialize(uint64_t a1, const __CFURL *a2, int a3, int a4, int a5, char a6, int a7)
{
  os_unfair_lock_s *v14;
  unint64_t v15;
  const void *v16;
  CFTypeRef *v17;
  const void *v18;
  CFTypeRef *v19;
  __CFString *v20;
  unint64_t v21;
  CFURLRef v22;
  void *v23;
  uint64_t v24;
  CFIndex Properties;
  int v26;
  int v27;
  int v28;
  uint64_t v29;

  v14 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v15 = *(_DWORD *)(a1 + 115) & 0xBFFFFFFF | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  *(_DWORD *)(a1 + 115) &= ~0x40000000u;
  *(_WORD *)(a1 + 119) = WORD2(v15);
  os_unfair_lock_unlock(v14);
  v17 = (CFTypeRef *)(a1 + 16);
  v16 = *(const void **)(a1 + 16);
  if (v16)
    CFRelease(v16);
  v19 = (CFTypeRef *)(a1 + 8);
  v18 = *(const void **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  if (v18)
    CFRelease(v18);
  v20 = *(__CFString **)(a1 + 24);
  *(_QWORD *)(a1 + 8) = 0;
  if (v20 != CFSTR("?"))
    TString::SetStringRefAsImmutable((TString *)(a1 + 24), (TString *)CFSTR("?"));
  TString::SetStringRefAsImmutable((TString *)(a1 + 32), 0);
  std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100]((TFSInfoOverflow **)(a1 + 80), 0);
  v21 = *(_DWORD *)(a1 + 115) & 0xF9FFFFFF | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  *(_DWORD *)(a1 + 115) = *(_DWORD *)(a1 + 115) & 0xF9FFFFFF | 0x4000000;
  *(_WORD *)(a1 + 119) = WORD2(v21);
  if (a7)
  {
    if (!a2)
      goto LABEL_20;
  }
  else
  {
    if (!a2)
      goto LABEL_20;
    _CFURLCacheSetAutoFlushingEnabled();
  }
  if (a5 && (!CFURLIsFileReferenceURL(a2) && (a6 & 1) != 0 || CFURLGetBaseURL(a2)))
  {
    CFURLClearResourcePropertyCache(a2);
    v22 = CFURLCreateFileReferenceURL(0, a2, 0);
    if (*v19)
      CFRelease(*v19);
    *v19 = v22;
    if (!v22)
    {
LABEL_24:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 8), a2);
      if (!a4)
        goto LABEL_32;
      goto LABEL_25;
    }
    _CFURLCacheSetAutoFlushingEnabled();
  }
LABEL_20:
  if (!*v19)
    goto LABEL_24;
  objc_msgSend((id)*v19, "path");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = objc_msgSend(v23, "length");

  if (!v24)
    goto LABEL_24;
  if (!a4)
    goto LABEL_32;
LABEL_25:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a1 + 8));
  Properties = TFSInfo::FetchProperties((TFSInfo *)a1, a3 == 0);
  if (!(_DWORD)Properties)
  {
    os_unfair_lock_lock(v14);
    v26 = *(_DWORD *)(a1 + 115);
    os_unfair_lock_unlock(v14);
    if ((v26 & 0x20) != 0
      || (os_unfair_lock_lock(v14), v27 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v14), (v27 & 0x400) != 0)
      || (os_unfair_lock_lock(v14), v28 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v14), (v28 & 0x40) != 0))
    {
LABEL_32:
      v29 = _CFURLCopyFileURL();
      if (*v17)
        CFRelease(*v17);
      Properties = 0;
      *v17 = (CFTypeRef)v29;
      if (!v29)
        goto LABEL_35;
      return Properties;
    }
    Properties = 4294967253;
  }
  if (!*v17)
LABEL_35:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v17, *v19);
  return Properties;
}

void sub_1CBCBEFCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TFSInfoOverflow::MigrateToType(uint64_t a1, int a2)
{
  id v3;
  void *v4;

  if (a2 == 1 && *(_BYTE *)(a1 + 76) == 2)
  {
    v3 = *(id *)a1;

    *(_BYTE *)(a1 + 76) = 1;
    *(_QWORD *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0x80000000;
    v4 = *(void **)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v3;

  }
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, os_unfair_lock_s **a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, char a9)
{
  int v14;
  int v15;
  unsigned int *v16;
  int v17;
  unsigned int v18;
  CFIndex v19;
  uint64_t v20;
  const void *v21;
  CFURLRef v23;
  CFStringRef theString;
  TString __dst[129];

  __dst[128] = *(TString *)MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)a1);
  TString::TString(__dst, a4);
  TFSInfo::SetItemName((TFSInfo *)a1, __dst);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__dst[0].fString.fRef);
  FileSuffix((const TString *)(a1 + 24), (TString *)&theString);
  if (a8)
  {
    if (CFStringGetLength(theString))
    {
      TString::TString(__dst, a4);
      TFSInfo::Initialize((TFSInfo *)a1, *a2, __dst);
LABEL_17:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__dst[0].fString.fRef);
      goto LABEL_18;
    }
    v14 = 32;
    v15 = 20480;
  }
  else
  {
    v14 = 0;
    v15 = 4096;
  }
  v16 = (unsigned int *)(a1 + 115);
  if (a9)
    v17 = 100664384;
  else
    v17 = 100664320;
  v18 = v17 | v14 | *(_DWORD *)(a1 + 115) & 0xF9FFFB9F;
  *v16 = v18;
  *v16 = v15 | (*a4 != 46) | v18 & 0xFFFF8FFE;
  strlcpy((char *)__dst, a3, 0x400uLL);
  strlcat((char *)__dst, a4, 0x400uLL);
  v19 = strlen((const char *)__dst);
  v23 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__dst, v19, a8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 8), v23);
  if (*(_QWORD *)(a1 + 8))
    _CFURLCacheSetAutoFlushingEnabled();
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v23);
  if (!*(_QWORD *)(a1 + 8))
  {
    TString::TString(__dst, a4);
    TFSInfo::Initialize((TFSInfo *)a1, *a2, __dst);
    goto LABEL_17;
  }
  v20 = _CFURLCopyFileURL();
  v21 = *(const void **)(a1 + 16);
  if (v21)
    CFRelease(v21);
  *(_QWORD *)(a1 + 16) = v20;
  if (strchr(a4, 58))
  {
    ColonsToSlashes((const TString *)(a1 + 24), __dst);
    TFSInfo::SetDisplayName((TFSInfo *)a1, __dst);
    goto LABEL_17;
  }
LABEL_18:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return a1;
}

void sub_1CBCBF298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  TFSInfo *v3;
  const void *v5;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TFSInfo::~TFSInfo(v3);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5;
  os_unfair_lock_s *Overflow;
  os_unfair_lock_s *v7;
  int os_unfair_lock_opaque_low;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  TString *v13;
  uint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  TString v20;
  TString *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;

  v24 = a3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)a1);
  *(_BYTE *)(v5 + 112) = a2;
  *(_DWORD *)(v5 + 115) |= 0x40000000u;
  std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,__SFNode *&,void>(&v24, &v22);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  Overflow = (os_unfair_lock_s *)TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
  v7 = Overflow + 18;
  os_unfair_lock_lock(Overflow + 18);
  os_unfair_lock_opaque_low = LOBYTE(Overflow[19]._os_unfair_lock_opaque);
  if (os_unfair_lock_opaque_low == 3)
  {
    os_unfair_lock_opaque_low = 0;
    LOBYTE(Overflow[19]._os_unfair_lock_opaque) = 0;
    *(_QWORD *)&Overflow->_os_unfair_lock_opaque = 0;
    *(_QWORD *)&Overflow[2]._os_unfair_lock_opaque = 0;
  }
  v9 = (unint64_t)Overflow & 0xFFFFFFFFFFFFFF00;
  v10 = Overflow & 0xF8;
  os_unfair_lock_unlock(v7);
  if (os_unfair_lock_opaque_low)
    v11 = 0;
  else
    v11 = v10;
  v12 = (_QWORD *)(v11 | v9);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v12, &v22);
  v13 = (TString *)SFNodeCopyDisplayName();
  v21 = v13;
  v14 = 32;
  if ((*(_WORD *)(*v12 + 57) & 0x80) == 0)
    v14 = 133120;
  v15 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32) | v14;
  *(_DWORD *)(a1 + 115) = v15;
  if ((*(_BYTE *)(*v12 + 57) & 8) != 0)
  {
    *(_WORD *)(a1 + 119) = WORD2(v15);
    *(_DWORD *)(a1 + 115) = v15 | 0x20;
  }
  v20.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(&v20, v13);
  TFSInfo::SetItemName((TFSInfo *)a1, &v20);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
  *(_DWORD *)(a1 + 115) |= 1u;
  TFSInfo::SetIfVirtualAlias((TFSInfo *)a1);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v21);
  v16 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return a1;
}

void sub_1CBCBF4D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  TFSInfo *v2;
  const void *v4;
  va_list va;
  const void *v6;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v6 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va1);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  TFSInfo::~TFSInfo(v2);
  _Unwind_Resume(a1);
}

void sub_1CBCBF52C()
{
  JUMPOUT(0x1CBCBF51CLL);
}

const void **TFSInfo::CopyFSInfo@<X0>(TFSInfo *this@<X0>, uint64_t *a2@<X8>)
{
  os_unfair_lock_s *v4;
  int v5;
  const __CFURL *v7;
  const __CFURL *v8;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x2000000) == 0)
    return (const void **)std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo const&,void>(this, a2);
  os_unfair_lock_lock(v4);
  v7 = (const __CFURL *)*((_QWORD *)this + 2);
  v8 = v7;
  if (v7)
    CFRetain(v7);
  os_unfair_lock_unlock(v4);
  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(a2);
  TFSInfo::initialize(*a2, v8, 1, 0, 1, 1, 0);
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v8);
}

void sub_1CBCBF5F0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IterationFullSetOfPropertyKeys(void)::$_0::operator()()
{
  void *v0;
  void *v1;
  void *v2;
  uint64_t v3;

  v0 = (void *)objc_opt_new();
  if (TFSInfo::IterationInfoPropertyKeys(void)::once != -1)
    dispatch_once(&TFSInfo::IterationInfoPropertyKeys(void)::once, &__block_literal_global_23);
  objc_msgSend(v0, "addObjectsFromArray:", TFSInfo::IterationInfoPropertyKeys(void)::basicKeys);
  if (TFSInfo::LSPropertyKeys(void)::once != -1)
    dispatch_once(&TFSInfo::LSPropertyKeys(void)::once, &__block_literal_global_24);
  objc_msgSend(v0, "addObjectsFromArray:", TFSInfo::LSPropertyKeys(void)::LSPropertyKeys);
  objc_msgSend(MEMORY[0x1E0D3A848], "sharedInstance");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "generalProperties");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v0, "addObjectsFromArray:", v2);
  objc_msgSend(v0, "allObjects");
  v3 = objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1CBCBF710(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

id TFSInfo::ISIconRefFromTypeInfo(TFSInfo *this)
{
  id v2;
  id v3;
  void *v4;
  void *v5;
  id v6;
  const void *v8;
  char v9;
  id location;

  location = 0;
  TFSInfo::GetUTType(this, &location, 128, &v9);
  v2 = location;
  if (location)
  {
    v3 = objc_alloc(MEMORY[0x1E0D3A820]);
    objc_msgSend(v2, "identifier");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = (void *)objc_msgSend(v3, "initWithType:", v4);

  }
  else
  {
    TFSInfo::ActualSuffix(this, (TString *)&v8);
    v6 = objc_alloc(MEMORY[0x1E0D3A820]);
    v5 = (void *)objc_msgSend(v6, "initWithFileExtension:", v8);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v8);
  }

  return v5;
}

void sub_1CBCBF7F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSInfo::SetISIcon(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v4 = *(void **)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v3;

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
}

void DecorationIdentifier(void *a1@<X0>, TString *a2@<X8>)
{
  TString *v3;
  id v4;

  v4 = a1;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_cast<NSString,objc_object * {__strong}>((void *)objc_msgSend(v4, "performSelector:", sel_identifier));
    v3 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, v3);

  }
  else
  {
    TString::TString(a2, "", 0);
  }

}

void sub_1CBCBF92C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  const void **v10;
  void *v11;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);

  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsFPv2(TFSInfo *this, int a2)
{
  int v2;
  os_unfair_lock_s *v4;
  uint64_t v5;
  int v6;
  id v7;
  uint64_t v8;

  v2 = *((unsigned __int8 *)this + 112);
  if (!a2 || v2 != 27)
    return v2 == 28;
  v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v5 = *((_QWORD *)this + 10);
  if (v5
    && (os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72)),
        v6 = *(unsigned __int8 *)(v5 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72)),
        v6 == 1))
  {
    v7 = *(id *)(v5 + 24);
  }
  else
  {
    v7 = 0;
  }
  os_unfair_lock_unlock(v4);
  v8 = objc_msgSend(v7, "isFPv2");

  return v8;
}

void sub_1CBCBFA08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id TFSInfo::FetchISIcon(void)const::$_0::operator()(TFSInfo **a1, void *a2)
{
  id v3;
  TFSInfo *v4;
  FPItem *v5;
  __int16 v6;
  void *v7;
  void *v8;
  id v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  id v20;
  id v22[17];
  id v23[17];
  id v24;
  _QWORD v25[8];
  _QWORD v26[5];
  uint64_t v27;
  uint64_t v28;
  char *v29;
  TString v30;

  v3 = a2;
  if (!v3)
    goto LABEL_17;
  TFSInfo::GetFPItem(*a1);
  v4 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  v6 = TFSInfo::FPItemPermissionRestrictions(v4, v5);

  if ((v6 & 0x800) == 0)
    goto LABEL_17;
  objc_msgSend(v3, "decorations");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator((uint64_t)&v24, v7);
  IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::IDContainerIteratorAdaptor((uint64_t)v23, -1, v7);
  v8 = (void *)*MEMORY[0x1E0D3A850];
  while (v24 != v23[0] || v29 != v23[16])
  {
    v9 = *(id *)(v25[1] + 8 * v28);
    DecorationIdentifier(v9, &v30);
    v10 = operator==((void **)&v30.fString.fRef, v8);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v30.fString.fRef);

    if ((v10 & 1) != 0)
      break;
    v11 = v28;
    if (v28 >= v27 - 1)
    {
      v12 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", v25, v26, 4);
      v11 = -1;
      v27 = v12;
      v28 = -1;
    }
    if (v26[4] != *(_QWORD *)v25[2])
    {
      objc_enumerationMutation(v24);
      v11 = v28;
    }
    v28 = v11 + 1;
    ++v29;
  }
  IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator((uint64_t)v22, (uint64_t)&v24);

  IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::IDContainerIteratorAdaptor((uint64_t)&v24, -1, v7);
  if (v22[0] != v24)
  {

LABEL_16:
    v19 = v22[0];
    v20 = *((id *)v22[2] + (uint64_t)v22[15]);

LABEL_17:
    v18 = v3;
    goto LABEL_18;
  }
  v13 = v22[16];
  v14 = v29;

  if (v13 != v14)
    goto LABEL_16;

  v15 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  objc_msgSend(v3, "decorations");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "addObjectsFromArray:", v16);

  v17 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D3A828]), "initWithType:", v8);
  objc_msgSend(v15, "addObject:", v17);
  objc_msgSend(v3, "iconWithDecorations:", v15);
  v18 = (id)objc_claimAutoreleasedReturnValue();

LABEL_18:
  return v18;
}

void sub_1CBCBFC8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FetchApplicationDMFPolicy(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v4;
  const __CFString *v5;
  signed __int8 NumericalProperty;
  os_unfair_lock_s *v7;
  const __CFURL *v9;

  if (!*((_QWORD *)this + 2))
    return 0;
  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 4) == 0)
    return 0;
  v9 = CFURLCreateFilePathURL(0, *((CFURLRef *)this + 2), 0);
  NumericalProperty = TCFURLInfo::GetNumericalProperty(v9, (const __CFString *)*MEMORY[0x1E0C9ABC0], v5);
  v7 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  *((_BYTE *)this + 113) = NumericalProperty;
  v4 = NumericalProperty;
  os_unfair_lock_unlock(v7);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v9);
  return v4;
}

void sub_1CBCBFDC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FetchFPItemProperties(TFSInfo *this)
{
  TFSInfo *v2;
  TFSInfo *v3;
  TString *v4;
  TString *v5;
  uint64_t v6;
  void *v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  int v21;
  FPItem *v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  const __CFString *v31;
  CFTypeRef cf;

  TFSInfo::GetFPItem(this);
  v2 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if (!v2)
  {
    v10 = 4294959224;
    goto LABEL_25;
  }
  -[TFSInfo filename](v2, "filename");
  v4 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  cf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&cf, v4);

  TFSInfo::SetItemName(this, (const TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);

  -[TFSInfo displayName](v3, "displayName");
  v5 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  cf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&cf, v5);

  TFSInfo::SetDisplayName(this, (const TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);

  -[TFSInfo contentType](v3, "contentType");
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = (void *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v6;

  KindWithoutPlatformFromUTType(*((UTType **)this + 5), (TString *)&cf);
  if ((CFTypeRef *)((char *)this + 48) != &cf)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)this + 6, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  v8 = -[TFSInfo fileSystemFlags](v3, "fileSystemFlags");
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFE | ((v8 & 8) == 0);
  if (-[TFSInfo isFolder](v3, "isFolder"))
  {
    v9 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  }
  else
  {
    v11 = -[TFSInfo isPackage](v3, "isPackage");
    v9 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
    if (!v11)
    {
      v12 = 0;
      goto LABEL_12;
    }
  }
  v12 = 32;
LABEL_12:
  *(_WORD *)((char *)this + 119) = WORD2(v9);
  *(_DWORD *)((char *)this + 115) = v9 & 0xFFFFFFDF | v12;
  v13 = -[TFSInfo isPackage](v3, "isPackage");
  v14 = 2;
  if (!v13)
    v14 = 0;
  v15 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | v14;
  *(_WORD *)((char *)this + 119) = WORD2(v15);
  v16 = objc_msgSend(*((id *)this + 5), "conformsToType:", *MEMORY[0x1E0CEC648]);
  v17 = 256;
  if (!v16)
    v17 = 0;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFF7AFF | v17 & 0xFFFFFBFF | (((*(_DWORD *)((char *)this + 115) >> 5) & 1) << 10);
  v18 = objc_msgSend(*((id *)this + 5), "conformsToType:", *MEMORY[0x1E0CEC5F8]);
  v19 = 64;
  if (!v18)
    v19 = 0;
  v20 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v20);
  v21 = objc_msgSend(*((id *)this + 5), "conformsToType:", *MEMORY[0x1E0CEC438]);
  v23 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  v24 = 4;
  if (!v21)
    v24 = 0;
  v25 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | v24;
  *(_DWORD *)((char *)this + 115) = v25;
  *(_WORD *)((char *)this + 119) = (v23 & 0xFFFFFFFFFFFFFFFBLL) >> 32;
  if ((v23 & 0x40) != 0
    || (v26 = objc_msgSend(*((id *)this + 5), "conformsToType:", *MEMORY[0x1E0CEC428]),
        v25 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32),
        v26))
  {
    v27 = 2048;
  }
  else
  {
    v27 = 0;
  }
  *(_WORD *)((char *)this + 119) = WORD2(v25);
  *(_DWORD *)((char *)this + 115) = v25 & 0xFFFFF7FF | v27;
  *((_QWORD *)this + 13) = 0;
  v28 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFE7 | (v8 >> 1) & 8 | ~(TFSInfo::FPItemPermissionRestrictions(v3, v22) >> 13) & 0x10;
  *(_WORD *)((char *)this + 119) = *(_WORD *)((char *)this + 119);
  *(_DWORD *)((char *)this + 115) = v28;
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_WORD *)((char *)this + 119) |= 0x800u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  v29 = *(_DWORD *)((char *)this + 115) & 0xFFFF8FFF | (v8 << 11) & 0x3000 | ((v8 & 1) << 14);
  *(_WORD *)((char *)this + 119) = *(_WORD *)((char *)this + 119);
  *(_DWORD *)((char *)this + 115) = v29;
  TFSInfo::FetchBladeRunnerProperties(this, v30, v31);
  v10 = 0;
LABEL_25:

  return v10;
}

void sub_1CBCC01A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void KindWithoutPlatformFromUTType(UTType *a1@<X0>, TString *a2@<X8>)
{
  void *v3;
  void *v4;
  TString *v5;
  UTType *v6;

  v6 = a1;
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  -[UTType _kindString](v6, "_kindString");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    if ((TString *)a2->fString.fRef != v5)
      TString::SetStringRefAsImmutable(a2, v5);
  }
  else
  {
    -[UTType localizedDescription](v6, "localizedDescription");
    v5 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    if ((TString *)a2->fString.fRef != v5)
      TString::SetStringRefAsImmutable(a2, v5);

  }
}

void sub_1CBCC02C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  const void **v10;
  void *v11;
  void *v12;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FPItemPermissionRestrictions(TFSInfo *this, FPItem *a2)
{
  TFSInfo *v2;
  void *v3;
  void *v4;
  void *v5;
  char v6;
  uint64_t v7;
  unsigned __int8 v8;
  uint64_t v9;
  _DWORD *v10;
  void *v11;
  int v12;
  char v13;
  void *v14;
  void *v15;
  int v16;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v2 = this;
  if (v2)
  {
    FPItemManagerInstance();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v18[0] = v2;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v18, 1);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "eligibleActionsForItems:", v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    if ((-[TFSInfo isFolder](v2, "isFolder") & 1) != 0)
      v6 = 1;
    else
      v6 = -[TFSInfo isPackage](v2, "isPackage");
    if ((v8 & 1) == 0
    {
      FP_ActionImportHere();
      _ZGRZN7TFSInfo28FPItemPermissionRestrictionsEP6FPItemE22sFPActionToPermissions_ = objc_claimAutoreleasedReturnValue();
      dword_1EF9B9948 = 20484;
      FP_ActionReparent();
      qword_1EF9B9950 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B9958 = 2;
      FP_ActionCopy();
      qword_1EF9B9960 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B9968 = 0x10000;
      FP_ActionRename();
      qword_1EF9B9970 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B9978 = 1;
      FP_ActionDelete();
      qword_1EF9B9980 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B9988 = 0x400000;
      FP_ActionTrash();
      qword_1EF9B9990 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B9998 = 0x200000;
      FP_ActionUntrash();
      qword_1EF9B99A0 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B99A8 = 0x800000;
      FP_ActionTag();
      qword_1EF9B99B0 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B99B8 = 0x100000;
      FP_ActionModifyFlags();
      qword_1EF9B99C0 = objc_claimAutoreleasedReturnValue();
      dword_1EF9B99C8 = 0x2000;
      TFSInfo::FPItemPermissionRestrictions(FPItem *)::sFPActionToPermissions = (uint64_t)&_ZGRZN7TFSInfo28FPItemPermissionRestrictionsEP6FPItemE22sFPActionToPermissions_;
      qword_1EF9B9930 = 9;
    }
    if (qword_1EF9B9930)
    {
      v7 = 0;
      v9 = 16 * qword_1EF9B9930;
      v10 = (_DWORD *)(TFSInfo::FPItemPermissionRestrictions(FPItem *)::sFPActionToPermissions + 8);
      do
      {
        if ((objc_msgSend(v5, "containsObject:", *((_QWORD *)v10 - 1)) & 1) == 0)
          v7 = *v10 | v7;
        v10 += 4;
        v9 -= 16;
      }
      while (v9);
      if ((v6 & 1) == 0)
      {
LABEL_18:
        v13 = -[TFSInfo capabilities](v2, "capabilities");
        if ((v13 & 1) != 0)
        {
          if ((v6 & 1) != 0)
          {
LABEL_28:

            goto LABEL_29;
          }
        }
        else
        {
          -[TFSInfo itemIdentifier](v2, "itemIdentifier");
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          NS_FileProviderRootContainerItemIdentifier();
          v15 = (void *)objc_claimAutoreleasedReturnValue();
          v16 = objc_msgSend(v14, "isEqualToString:", v15);

          if (v16)
            v7 = v7;
          else
            v7 = v7 | 0x80800;
          if ((v6 & 1) != 0)
            goto LABEL_28;
          LODWORD(v7) = v7 | 0x10000;
        }
        if ((v13 & 2) != 0)
          v7 = v7;
        else
          v7 = v7 | 0xD004;
        goto LABEL_28;
      }
    }
    else
    {
      v7 = 0;
      if ((v6 & 1) == 0)
        goto LABEL_18;
    }
    FP_ActionImportHere();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = objc_msgSend(v5, "containsObject:", v11);

    if (v12)
      v7 = v7;
    else
      v7 = v7 | 0x8000;
    goto LABEL_18;
  }
  v7 = 0;
LABEL_29:

  return v7;
}

void sub_1CBCC061C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t *v3;
  uint64_t *v5;
  void *v6;

  v5 = &qword_1EF9B99C0;
  do
  {
    v6 = (void *)*(v5 - 2);
    v5 -= 2;

  }
  while (v5 != v3);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetAliasInfoFrom(TFSInfo *this, BOOL *a2, BOOL *a3, TString *a4, TString *a5)
{
  int v10;
  const void *URL;
  const void *v12;
  unint64_t v13;
  const void *v14;
  __CFString *v15;
  CFTypeID v16;
  int v17;
  void *v18;
  CFTypeID v19;
  __CFString *v20;
  CFTypeID v21;
  CFTypeID TypeID;
  __CFString *v23;
  CFTypeID v24;
  CFTypeID v25;
  _BOOL4 v26;
  uint64_t v27;
  const char *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  const char *v33;
  __CFString *v35;
  __CFString *v36;
  void *v37;
  const void *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  TString v43;
  char v44[8];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (TFSInfo::IsAlias(this))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v10 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v10 & 0x40) == 0)
    {
      if (TFSInfo::GetAliasInfoFrom(BOOL &,BOOL &,TString *,TString *)const::once != -1)
        dispatch_once(&TFSInfo::GetAliasInfoFrom(BOOL &,BOOL &,TString *,TString *)const::once, &__block_literal_global_96);
      URL = TFSInfo::MakeURL(this);
      *(_QWORD *)v44 = URL;
      if (!URL)
        goto LABEL_26;
      v12 = URL;
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      v13 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      if ((v13 & 0x400000000) != 0)
      {
        v38 = 0;
      }
      else
      {
        v14 = (const void *)MEMORY[0x1D17A4D88](0, v12, 0);
        v38 = v14;
        if (v14)
        {
          v15 = (__CFString *)MEMORY[0x1D17A4DD0](0, *MEMORY[0x1E0C9B4E0], v14);
          v43.fString.fRef = v15;
          if (v15)
          {
            v16 = CFGetTypeID(v15);
            if (v16 == CFBooleanGetTypeID())
            {
              v17 = IsEqual(v43.fString.fRef, (const void *)*MEMORY[0x1E0C9AE50]);
              *a3 = v17;
              TFSInfo::SetAliasIsContainer(this, v17);
            }
          }
          v18 = (void *)MEMORY[0x1D17A4DD0](0, *MEMORY[0x1E0C9B550], v38);
          v37 = v18;
          if (v18)
          {
            v19 = CFGetTypeID(v18);
            if (v19 == CFBooleanGetTypeID())
              *a2 = IsEqual(v37, (const void *)*MEMORY[0x1E0C9AE50]);
          }
          v20 = (__CFString *)MEMORY[0x1D17A4DD0](0, *MEMORY[0x1E0C9B3D0], v38);
          v36 = v20;
          if (v20)
          {
            v21 = CFGetTypeID(v20);
            TypeID = CFStringGetTypeID();
            if (a4)
            {
              if (v21 == TypeID && a4->fString.fRef != v36)
                TString::SetStringRefAsImmutable(a4, (TString *)v36);
            }
          }
          v23 = (__CFString *)MEMORY[0x1D17A4DD0](0, *MEMORY[0x1E0C9B5A0], v38);
          v35 = v23;
          if (v23)
          {
            v24 = CFGetTypeID(v23);
            v25 = CFStringGetTypeID();
            if (a5)
            {
              if (v24 == v25)
              {
                if (a5->fString.fRef != v35)
                  TString::SetStringRefAsImmutable(a5, (TString *)v35);
                v26 = TString::EndsWith(a5, (const TString *)TFSInfo::GetAliasInfoFrom(BOOL &,BOOL &,TString *,TString *)const::burnFolderExtension);
                TFSInfo::SetAliasIsBurnFolder(this, v26);
              }
            }
          }
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v35);
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v36);
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v37);
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v43.fString.fRef);
          TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v38);
LABEL_26:
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)v44);
          return 0;
        }
      }
      TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v38);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)v44);
      return 4294959232;
    }
    TFSInfo::Path(this, (CFTypeRef *)&v43.fString.fRef);
    v28 = (const char *)TString::c_str(&v43);
    if (readlink(v28, v44, 0x400uLL) == -1)
    {
      v32 = __error();
      v27 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v32, 0, v33);
    }
    else
    {
      *a2 = 0;
      *a3 = 1;
      if (a4 && &v43 != a4)
        TString::SetStringRefAsImmutable(a4, (TString *)v43.fString.fRef);
      if (!a5)
        goto LABEL_40;
      TPathName::TPathName((TPathName *)&v38, &v43, TPathName::kPOSIXPathNameSeparator);
      if (v40 != v39)
      {
        v29 = (_QWORD *)(v39 + 8 * ((v41 + v42) >> 9));
        v30 = (v41 + v42) & 0x1FF;
        v31 = *v29 + 8 * v30;
        if (v31 != *(_QWORD *)(v39 + ((v41 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v41 & 0x1FF))
        {
          if (!v30)
            v31 = *(v29 - 1) + 4096;
          if ((TString *)(v31 - 8) != a5)
            TString::SetStringRefAsImmutable(a5, *(TString **)(v31 - 8));
          std::deque<TString>::~deque[abi:ne180100](&v38);
LABEL_40:
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
          return 0;
        }
      }
      std::deque<TString>::~deque[abi:ne180100](&v38);
      v27 = 4294959234;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
    return v27;
  }
  return 4294959226;
}

void sub_1CBCC0B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetIsResumableCopyTarget(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  __int16 v10;
  unint64_t v11;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v6 = *(_DWORD *)((char *)this + 115);
  v5 = (char *)this + 115;
  v7 = *((unsigned __int16 *)v5 + 2);
  v8 = v6 | (unint64_t)(v7 << 32);
  v9 = (v7 >> 12) & 1;
  v10 = 4096;
  if (!a2)
    v10 = 0;
  v11 = v8 & 0xFFFFEFFFFFFFFFFFLL;
  *(_DWORD *)v5 = v11;
  *((_WORD *)v5 + 2) = WORD2(v11) | v10;
  os_unfair_lock_unlock(v4);
  return v9;
}

uint64_t TFSInfo::SetSizesFetchedValid(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v6 = *(_DWORD *)((char *)this + 115);
  v5 = (char *)this + 115;
  v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  v8 = (v7 >> 28) & 1;
  v9 = 0x10000000;
  if (!a2)
    v9 = 0;
  v10 = v7 & 0xFFFFFFFFEFFFFFFFLL;
  *(_DWORD *)v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

void TFSInfo::SetOperationFractionCompleted(TFSInfo *this, double a2)
{
  os_unfair_lock_s *v4;
  unint64_t v5;
  os_unfair_lock_s *v6;
  TFSInfoOverflow *Overflow;
  TFSInfoOverflow *v8;
  double v10;
  os_unfair_lock_s *v11;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x20000000000) != 0)
  {
    v6 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    Overflow = TFSInfo::GetOrCreateOverflow(this);
    v8 = Overflow;
    if (a2 > 1.0 || a2 < 0.0)
      v10 = 0.0;
    else
      v10 = a2 * 100.0;
    v11 = (os_unfair_lock_s *)((char *)Overflow + 72);
    os_unfair_lock_lock((os_unfair_lock_t)Overflow + 18);
    *((double *)v8 + 6) = v10;
    os_unfair_lock_unlock(v11);
    os_unfair_lock_unlock(v6);
  }
}

void sub_1CBCC0D5C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetLocalizedTypeDescription(TFSInfo *this, const TString *a2, int a3)
{
  os_unfair_lock_s *v6;
  TString *v7;
  const void *v8;
  uint64_t v9;

  v6 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v8 = (const void *)*((_QWORD *)this + 6);
  v7 = (TString *)((char *)this + 48);
  if (CFEqual(v8, a2->fString.fRef) || a3 && CFStringGetLength(v7->fString.fRef))
  {
    v9 = 0;
  }
  else
  {
    if (v7 != a2)
      TString::SetStringRefAsImmutable(v7, (TString *)a2->fString.fRef);
    v9 = 1;
  }
  os_unfair_lock_unlock(v6);
  return v9;
}

void sub_1CBCC0DF4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

unint64_t TFSInfoOverflow::ICloud(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  int v8;

  v4 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  if (!a2)
  {
    v8 = *(unsigned __int8 *)(a1 + 76);
    if (v8 == 2)
    {
      TFSInfoOverflow::MigrateToType(a1, 1);
    }
    else if (v8 == 3)
    {
      *(_BYTE *)(a1 + 76) = 1;
      *(_QWORD *)(a1 + 32) = 0;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      *(_DWORD *)(a1 + 32) = 0x80000000;
    }
  }
  v5 = *(unsigned __int8 *)(a1 + 76);
  os_unfair_lock_unlock(v4);
  v6 = a1;
  if (v5 != 1)
    v6 = 0;
  return v6 | a1 & 0xFFFFFFFFFFFFFF00;
}

void ComputeBRFlagsFromFPItem(FPItem *a1@<X0>, uint64_t a2@<X8>)
{
  int v3;
  FPItem *v4;
  char v5;
  char v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  void *v12;
  void *v13;
  NSError *v14;
  void *v15;
  char v16;
  char v17;
  FPItem *v18;

  v18 = a1;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 7) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  v3 = UseFileProviderFramework() ^ 1;
  if (!v18)
    LOBYTE(v3) = 1;
  v4 = v18;
  if ((v3 & 1) == 0)
  {
    if (-[FPItem isCloudItem](v18, "isCloudItem"))
    {
      if ((-[FPItem isFolder](v18, "isFolder") & 1) != 0 || -[FPItem isPackage](v18, "isPackage"))
        v5 = -[FPItem isRecursivelyDownloaded](v18, "isRecursivelyDownloaded");
      else
        v5 = -[FPItem isDownloaded](v18, "isDownloaded");
      v6 = v5 ^ 1;
    }
    else
    {
      v6 = 0;
    }
    *(_BYTE *)a2 = v6;
    *(_BYTE *)(a2 + 1) = -[FPItem isUploaded](v18, "isUploaded");
    *(_BYTE *)(a2 + 2) = -[FPItem isUploading](v18, "isUploading");
    *(_BYTE *)(a2 + 3) = -[FPItem isDownloading](v18, "isDownloading");
    v7 = -[FPItem isMostRecentVersionDownloaded](v18, "isMostRecentVersionDownloaded");
    *(_BYTE *)(a2 + 4) = v7;
    v8 = -[FPItem isExcludedFromSync](v18, "isExcludedFromSync");
    *(_BYTE *)(a2 + 6) = v8;
    -[FPItem downloadingError](v18, "downloadingError");
    v9 = objc_claimAutoreleasedReturnValue();
    *(_QWORD *)(a2 + 16) = v9;
    -[FPItem uploadingError](v18, "uploadingError");
    v10 = objc_claimAutoreleasedReturnValue();
    *(_QWORD *)(a2 + 24) = v10;
    v11 = (v8 & 1) == 0 && (v10 | v9) != 0;
    *(_BYTE *)(a2 + 5) = v11;
    static_objc_cast<NSString,objc_object * {__strong}>(v18);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "isDownloadRequested");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_BYTE *)(a2 + 7) = objc_msgSend(v13, "BOOLValue") & (v7 ^ 1);

    -[FPItem uploadingError](v18, "uploadingError");
    v14 = (NSError *)objc_claimAutoreleasedReturnValue();
    *(_BYTE *)(a2 + 8) = BladeRunnerOutOfSpaceError(v14);

    if (-[FPItem isShared](v18, "isShared"))
    {
      FPSharedItemCreator(v18);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      *(_BYTE *)(a2 + 9) = v15 != 0;

    }
    else
    {
      *(_BYTE *)(a2 + 9) = 0;
    }
    v16 = -[FPItem isShared](v18, "isShared");
    if (*(_BYTE *)(a2 + 9))
      v17 = 0;
    else
      v17 = v16;
    *(_BYTE *)(a2 + 10) = v17;
    v4 = v18;
  }

}

void sub_1CBCC1078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id *v10;
  void *v11;

  BRFlagsRecord::~BRFlagsRecord(v10);
  _Unwind_Resume(a1);
}

void BRFlagsRecord::~BRFlagsRecord(id *this)
{

}

uint64_t BRFlagsFromState(unsigned __int8 *a1)
{
  int v1;
  uint64_t v2;

  v1 = *a1;
  LODWORD(v2) = v1 | 2;
  if (!a1[2])
    LODWORD(v2) = *a1;
  if (a1[3])
    LODWORD(v2) = v2 | 8;
  if (a1[5])
    LODWORD(v2) = v2 | 0x10;
  if (a1[6])
    LODWORD(v2) = v2 | 0x20;
  if (a1[9])
    LODWORD(v2) = v2 | 0x80;
  if (a1[10])
    LODWORD(v2) = v2 | 0x100;
  if (a1[8])
    v2 = v2 | 0x800;
  else
    v2 = v2;
  if (!a1[6])
  {
    if (a1[2] || !a1[4] || a1[1])
    {
      if (*a1 && !a1[3] && a1[7])
      {
        return v2 | 0x400;
      }
      else if (a1[2] | v1 | a1[3] | a1[4])
      {
        return v2;
      }
      else
      {
        return v2 | 0x2000;
      }
    }
    else
    {
      return v2 | 0x200;
    }
  }
  return v2;
}

id objc_cast<NSError,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

void TFSInfo::SetICloudSharePerson(TFSInfo *this, NSPersonNameComponents *a2)
{
  os_unfair_lock_s *v4;
  TFSInfoOverflow *Overflow;
  int v6;
  int v7;
  NSPersonNameComponents *v8;

  v8 = a2;
  v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  if (v8 || *((_QWORD *)this + 10))
  {
    Overflow = TFSInfo::GetOrCreateOverflow(this);
    os_unfair_lock_lock((os_unfair_lock_t)Overflow + 18);
    if (v8)
    {
      v6 = *((unsigned __int8 *)Overflow + 76);
      if (v6 == 2)
      {
        TFSInfoOverflow::MigrateToType((uint64_t)Overflow, 1);
      }
      else if (v6 == 3)
      {
        *((_BYTE *)Overflow + 76) = 1;
        *((_QWORD *)Overflow + 4) = 0;
        *(_OWORD *)Overflow = 0u;
        *((_OWORD *)Overflow + 1) = 0u;
        *((_DWORD *)Overflow + 8) = 0x80000000;
      }
    }
    v7 = *((unsigned __int8 *)Overflow + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)Overflow + 18);
    if (v7 == 1)
      objc_storeStrong((id *)Overflow, a2);
  }
  os_unfair_lock_unlock(v4);

}

void sub_1CBCC12D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetKindWithoutPlatform(TFSInfo *this, TString *a2, char a3, _BYTE *a4)
{
  CFTypeRef v6;
  uint64_t v7;
  void *v9;
  UTType *v10;
  void *v12;
  void *v13;
  void *v14;
  TString *v15;
  const void *v16;
  CFTypeRef cf;

  *a4 = 0;
  switch(*((_BYTE *)this + 112))
  {
    case 0:
      TFSInfo::LocalizedTypeDescription(this, (TString *)&cf);
      if (&cf != (CFTypeRef *)a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
        CFRetain(&stru_1E8752DF8);
        if (cf)
          CFRelease(cf);
        cf = &stru_1E8752DF8;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      if (CFStringGetLength(a2->fString.fRef))
        return 0;
      if (a3 < 0)
      {
        TFSInfo::ApproximateUTType(this);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v14 = v13;
        if (v13)
        {
          objc_msgSend(v13, "_kindString");
          v15 = (TString *)(id)objc_claimAutoreleasedReturnValue();
          if ((TString *)a2->fString.fRef != v15)
            TString::SetStringRefAsImmutable(a2, v15);

        }
        if (CFStringGetLength(a2->fString.fRef))
          v7 = 4294959210;
        else
          v7 = 4294959222;
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        v12 = (void *)*((_QWORD *)this + 2);
        v16 = v12;
        if (v12)
          CFRetain(v12);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        TCFURLInfo::StringProperty((TCFURLInfo *)v12, (const __CFString *)*MEMORY[0x1E0C9B588], (TString *)&cf);
        if (&cf != (CFTypeRef *)a2)
        {
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
          CFRetain(&stru_1E8752DF8);
          if (cf)
            CFRelease(cf);
          cf = &stru_1E8752DF8;
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v16);
        v7 = 0;
      }
      TFSInfo::SetLocalizedTypeDescription(this, a2, v7 != 0);
      return v7;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 0xB:
    case 0xC:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x22:
    case 0x23:
      cf = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      if (&cf == (CFTypeRef *)a2)
        goto LABEL_6;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      v6 = cf;
      if (!cf)
        goto LABEL_5;
      goto LABEL_4;
    case 0x1B:
    case 0x1C:
      TFSInfo::GetFPItem(this);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "contentType");
      v10 = (UTType *)objc_claimAutoreleasedReturnValue();

      KindWithoutPlatformFromUTType(v10, (TString *)&cf);
      if (&cf != (CFTypeRef *)a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
        CFRetain(&stru_1E8752DF8);
        if (cf)
          CFRelease(cf);
        cf = &stru_1E8752DF8;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);

      return 0;
    case 0x1F:
    case 0x20:
    case 0x21:
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
      return 0;
    default:
      TString::TString((TString *)&cf, "Unknown");
      if (&cf != (CFTypeRef *)a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
        CFRetain(&stru_1E8752DF8);
        v6 = cf;
        if (cf)
LABEL_4:
          CFRelease(v6);
LABEL_5:
        cf = &stru_1E8752DF8;
      }
LABEL_6:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      return 0;
  }
}

void sub_1CBCC15E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetShortVersion(uint64_t a1, const void **a2, int a3)
{
  uint64_t VersionMetaData;
  os_unfair_lock_s *v6;
  TString **v7;
  CFTypeRef cf;

  VersionMetaData = TFSInfo::FetchVersionMetaData(a1, a3);
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  cf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  if (&cf != a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  v7 = *(TString ***)a1;
  if (v7)
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, *v7);
    if (&cf != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v6);
  return VersionMetaData;
}

void sub_1CBCC175C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  os_unfair_lock_s *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLongVersion(uint64_t a1, TString *a2, int a3)
{
  uint64_t VersionMetaData;
  os_unfair_lock_s *v6;
  uint64_t v7;
  CFTypeRef cf;

  VersionMetaData = TFSInfo::FetchVersionMetaData(a1, a3);
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  TString::SetStringRefAsImmutable(a2, 0);
  v7 = *(_QWORD *)a1;
  if (v7)
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, *(TString **)(v7 + 8));
    if (&cf != (CFTypeRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v6);
  return VersionMetaData;
}

void sub_1CBCC1850(_Unwind_Exception *a1, uint64_t a2, ...)
{
  os_unfair_lock_s *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSystemVersion(uint64_t a1, TString *a2, int a3)
{
  uint64_t VersionMetaData;
  os_unfair_lock_s *v6;
  uint64_t v7;
  CFTypeRef cf;

  VersionMetaData = TFSInfo::FetchVersionMetaData(a1, a3);
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  TString::SetStringRefAsImmutable(a2, 0);
  v7 = *(_QWORD *)a1;
  if (v7)
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, *(TString **)(v7 + 16));
    if (&cf != (CFTypeRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v6);
  return VersionMetaData;
}

void sub_1CBCC1940(_Unwind_Exception *a1, uint64_t a2, ...)
{
  os_unfair_lock_s *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetCopyrightString(uint64_t a1, TString *a2, int a3)
{
  uint64_t VersionMetaData;
  os_unfair_lock_s *v6;
  uint64_t v7;
  CFTypeRef cf;

  VersionMetaData = TFSInfo::FetchVersionMetaData(a1, a3);
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  TString::SetStringRefAsImmutable(a2, 0);
  v7 = *(_QWORD *)a1;
  if (v7)
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, *(TString **)(v7 + 24));
    if (&cf != (CFTypeRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v6);
  return VersionMetaData;
}

void sub_1CBCC1A30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  os_unfair_lock_s *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetExtendedUserAccess(TFSInfo *this)
{
  void *v2;
  TFSInfo *v3;
  FPItem *v4;
  int v5;
  os_unfair_lock_s *v6;
  int v7;
  os_unfair_lock_s *v8;
  unsigned int *v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  int v19;
  unint64_t v20;
  char v21;
  int v22;
  unint64_t v23;

  TFSInfo::GetFPItem(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    TFSInfo::GetFPItem(this);
    v3 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
    v5 = TFSInfo::FPItemPermissionRestrictions(v3, v4);

    v6 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v7 = (~v5 & 0x1004) != 0;
    v8 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v10 = *(_DWORD *)((char *)this + 115);
    v9 = (unsigned int *)((char *)this + 115);
    os_unfair_lock_unlock(v8);
    v11 = v7 ^ (v10 >> 20) & 1;
    os_unfair_lock_lock(v8);
    v12 = *v9 & 0xFFEFFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *v9 = *v9 & 0xFFEFFFFF | (v7 << 20);
    *((_WORD *)v9 + 2) = WORD2(v12);
    os_unfair_lock_unlock(v8);
    v13 = (~v5 & 0x5000) != 0;
    os_unfair_lock_lock(v8);
    v14 = ((unint64_t)*v9 >> 21) & 1;
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    v15 = *v9 & 0xFFDFFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *v9 = *v9 & 0xFFDFFFFF | (v13 << 21);
    *((_WORD *)v9 + 2) = WORD2(v15);
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    v16 = ((unint64_t)*v9 >> 22) & 1;
    os_unfair_lock_unlock(v8);
    LOBYTE(v11) = v11 | v13 ^ v14 | ((v5 & 0x400000) == 0) ^ v16;
    os_unfair_lock_lock(v8);
    v17 = *v9 & 0xFFBFFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *v9 = *v9 & 0xFFBFFFFF | v5 & 0x400000 ^ 0x400000;
    *((_WORD *)v9 + 2) = WORD2(v17);
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    v18 = *v9;
    os_unfair_lock_unlock(v8);
    v19 = ((~v5 & 0x9000) != 0) & (v18 >> 5);
    os_unfair_lock_lock(v8);
    v20 = ((unint64_t)*v9 >> 23) & 1;
    os_unfair_lock_unlock(v8);
    v21 = v11 | v19 ^ v20;
    os_unfair_lock_lock(v8);
    v22 = 0x800000;
    if ((v19 & 1) == 0)
      v22 = 0;
    v23 = *v9 & 0xFF7FFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *v9 = *v9 & 0xFF7FFFFF | v22;
    *((_WORD *)v9 + 2) = WORD2(v23);
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    *v9 |= 0x80000000;
    os_unfair_lock_unlock(v8);
    os_unfair_lock_unlock(v6);
  }
  else
  {
    v21 = 0;
  }

  return v21 & 1;
}

void sub_1CBCC1C94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TFSInfo::UpdateFileProvider(TFSInfo *this, FIProviderDomain *a2)
{
  FIProviderDomain *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  id v7;
  NSObject *v8;
  os_unfair_lock_s *v9;
  int v10;
  FIProviderDomain *v11;
  id v12;
  uint64_t v13;
  id v14;
  NSObject *v15;
  NSURL *v16;
  void *v17;
  TFSInfoOverflow *Overflow;
  int v19;
  int v20;
  id v21;
  id v22;
  uint8_t buf[4];
  void *v24;
  __int16 v25;
  id v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  TFSInfo::GetFPItem(this);
  v4 = objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v5 = (void *)v4;
    v22 = 0;
    +[FIProviderDomain providerDomainForItem:cachePolicy:error:](FIProviderDomain, "providerDomainForItem:cachePolicy:error:", v4, 0, &v22);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v22;
    if (v7)
    {
      LogObj(4);
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543618;
        v24 = v5;
        v25 = 2114;
        v26 = v7;
        _os_log_impl(&dword_1CBC4A000, v8, OS_LOG_TYPE_ERROR, "Failed to get the domain from the FPItem. Falling back to URL: %{public}@, error: %{public}@", buf, 0x16u);
      }

    }
    if (v6)
    {
      v9 = (os_unfair_lock_s *)((char *)this + 96);
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      v10 = 1;
      goto LABEL_20;
    }
  }
  else
  {
    v7 = 0;
  }
  if (v3)
  {
    v11 = v3;
    if (!v7)
      goto LABEL_16;
  }
  else
  {
    v12 = *((id *)this + 2);
    v21 = v7;
    +[FIProviderDomain providerDomainForURL:cachePolicy:error:](FIProviderDomain, "providerDomainForURL:cachePolicy:error:", v12, 1, &v21);
    v13 = objc_claimAutoreleasedReturnValue();
    v14 = v21;

    v11 = (FIProviderDomain *)v13;
    v7 = v14;
    if (!v14)
      goto LABEL_16;
  }
  LogObj(4);
  v15 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    v16 = (NSURL *)*((id *)this + 2);
    SanitizedURL(v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138543618;
    v24 = v17;
    v25 = 2114;
    v26 = v7;
    _os_log_impl(&dword_1CBC4A000, v15, OS_LOG_TYPE_ERROR, "Failed to get the domain from the URL: %{public}@, error: %{public}@", buf, 0x16u);

  }
LABEL_16:
  v9 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  if (v11)
  {
    v10 = 1;
    v6 = v11;
  }
  else
  {
    v6 = 0;
    if (!*((_QWORD *)this + 10))
      goto LABEL_27;
    v10 = 0;
  }
LABEL_20:
  Overflow = TFSInfo::GetOrCreateOverflow(this);
  os_unfair_lock_lock((os_unfair_lock_t)Overflow + 18);
  if (v10)
  {
    v19 = *((unsigned __int8 *)Overflow + 76);
    if (v19 == 2)
    {
      TFSInfoOverflow::MigrateToType((uint64_t)Overflow, 1);
    }
    else if (v19 == 3)
    {
      *((_BYTE *)Overflow + 76) = 1;
      *((_QWORD *)Overflow + 4) = 0;
      *(_OWORD *)Overflow = 0u;
      *((_OWORD *)Overflow + 1) = 0u;
      *((_DWORD *)Overflow + 8) = 0x80000000;
    }
  }
  v20 = *((unsigned __int8 *)Overflow + 76);
  os_unfair_lock_unlock((os_unfair_lock_t)Overflow + 18);
  if (v20 == 1)
    objc_storeStrong((id *)Overflow + 3, v6);
LABEL_27:
  os_unfair_lock_unlock(v9);

}

void sub_1CBCC1F84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t *SFBrowsers(void)
{
  unsigned __int8 v0;

  {
    std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::vector(&SFBrowsers(void)::browsers, 2uLL);
  }
  return &SFBrowsers(void)::browsers;
}

void sub_1CBCC2044(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *SFBrowserLock(void)
{
  unsigned __int8 v0;

  {
    SFBrowserLock(void)::lock = 0;
  }
  return &SFBrowserLock(void)::lock;
}

const void **TFSInfo::Finalize(TFSInfo *this)
{
  os_unfair_lock_s *v1;
  const void *v2;
  const void *v3;
  TFSInfo *v4;
  uint64_t v5;
  int *v6;
  int *v7;
  int *v8;
  int *v9;
  BOOL v10;
  CFTypeRef *v11;
  CFTypeRef *v12;
  const void *v14;
  const void *v15;

  v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  v2 = (const void *)TFSInfo::gNetworkNearbyBrowserRef;
  TFSInfo::gNetworkNearbyBrowserRef = 0;
  v3 = (const void *)TFSInfo::gAirDropBrowserRef;
  TFSInfo::gAirDropBrowserRef = 0;
  v14 = v3;
  v15 = v2;
  v5 = TFSInfo::OpenBrowserMap(v4);
  v6 = (int *)(v5 + 8);
  v7 = *(int **)v5;
  if (*(_QWORD *)v5 != v5 + 8)
  {
    do
    {
      if (v7[12] >= 1)
        SFBrowserCloseNode();
      v8 = (int *)*((_QWORD *)v7 + 1);
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = *(int **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (int *)*((_QWORD *)v7 + 2);
          v10 = *(_QWORD *)v9 == (_QWORD)v7;
          v7 = v9;
        }
        while (!v10);
      }
      v7 = v9;
    }
    while (v9 != v6);
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(v5, *(_QWORD **)(v5 + 8));
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)v5 = v6;
  os_unfair_lock_unlock(v1);
  SFBrowserLock();
  os_unfair_lock_lock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  SFBrowsers();
  v11 = (CFTypeRef *)SFBrowsers(void)::browsers;
  v12 = *(CFTypeRef **)algn_1EF9B98B0;
  while (v11 != v12)
  {
    if (*v11)
      CFRelease(*v11);
    *v11++ = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  if (v15)
    SFBrowserInvalidate();
  if (v14)
    SFBrowserInvalidate();
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v14);
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v15);
}

void sub_1CBCC21F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&a9);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::OpenBrowserMap(TFSInfo *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  {
    v3 = (_QWORD *)operator new();
    v3[2] = 0;
    v3[1] = 0;
    *v3 = v3 + 1;
    TFSInfo::OpenBrowserMap(void)::sOpenNodeBrowsers = (uint64_t)v3;
  }
  return TFSInfo::OpenBrowserMap(void)::sOpenNodeBrowsers;
}

void sub_1CBCC22BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetResourcePropertyForKey(TFSInfo *this, const __CFString *a2, const __CFString *a3, const void *a4)
{
  __CFError *v4;
  CFIndex v5;
  CFErrorRef error;

  error = 0;
  if (CFURLSetResourcePropertyForKey((CFURLRef)this, a2, a3, &error))
    v5 = 0;
  else
    v5 = TCFURLInfo::TranslateCFError(error, v4);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
  return v5;
}

void sub_1CBCC2324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetProperty(TFSInfo *this, const __CFString *a2, const __CFString *a3)
{
  os_unfair_lock_s *v6;
  TFSInfo *v7;
  const void *v8;
  CFIndex v9;
  TFSInfo *v11;

  v6 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v7 = (TFSInfo *)*((_QWORD *)this + 2);
  v11 = v7;
  if (v7)
  {
    CFRetain(v7);
    os_unfair_lock_unlock(v6);
    if (a3)
      v9 = TFSInfo::SetResourcePropertyForKey(v7, a2, a3, v8);
    else
      v9 = 4294959224;
  }
  else
  {
    os_unfair_lock_unlock(v6);
    v9 = 4294959238;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v11);
  return v9;
}

void sub_1CBCC23D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetTimeProperty(TFSInfo *this, const __CFString *a2, CFAbsoluteTime a3)
{
  const __CFString *v5;
  CFIndex v6;
  const __CFString *v8;

  v5 = (const __CFString *)CFDateCreate(0, a3);
  v8 = v5;
  if (v5)
    v6 = TFSInfo::SetProperty(this, a2, v5);
  else
    v6 = 4294959224;
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)&v8);
  return v6;
}

void sub_1CBCC2458(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::UserIsOwner(TFSInfo *this)
{
  int UserID;

  UserID = TFSInfo::GetUserID(this);
  return UserID == TFSInfo::GetOwner(this);
}

uint64_t TFSInfo::GetUserID(TFSInfo *this)
{
  unsigned __int8 v1;

  {
    TFSInfo::GetUserID(void)::UID = geteuid();
  }
  return TFSInfo::GetUserID(void)::UID;
}

void sub_1CBCC24F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<TString,TString>>::vector[abi:ne180100](uint64_t a1, TString **a2, unint64_t a3)
{
  uint64_t v4;

  *(_QWORD *)(a1 + 16) = 0;
  v4 = a1 + 16;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  if (a3)
  {
    std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100]((_QWORD *)a1, a3);
    *(_QWORD *)(a1 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString> const*,std::pair<TString,TString> const*,std::pair<TString,TString>*>(v4, a2, &a2[2 * a3], *(TString **)(a1 + 8));
  }
  return a1;
}

void sub_1CBCC2588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::pair<TString,TString>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetInode(TFSInfo *this)
{
  const __CFURL *v1;
  uint64_t v2;
  CFNumberRef number;
  uint64_t valuePtr;

  number = 0;
  valuePtr = 0;
  v1 = (const __CFURL *)*((_QWORD *)this + 1);
  if (v1 && CFURLCopyResourcePropertyForKey(v1, (CFStringRef)*MEMORY[0x1E0C9B440], &number, 0) && number)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
    v2 = valuePtr;
  }
  else
  {
    v2 = 0;
  }
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&number);
  return v2;
}

void sub_1CBCC2620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

void ___Z16CopyURLForFPItemP6FPItemb_block_invoke(uint64_t a1, void *a2)
{
  id v4;

  objc_storeStrong(*(id **)(a1 + 32), a2);
  v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));

}

id __copy_helper_block_ea8_32c38_ZTSKZ16CopyURLForFPItemP6FPItembE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id result;

  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *(_QWORD *)(a1 + 48) = *(id *)(a2 + 48);
  result = *(id *)(a2 + 56);
  *(_QWORD *)(a1 + 56) = result;
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c38_ZTSKZ16CopyURLForFPItemP6FPItembE3__0(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

uint64_t CopyURLForFPItem(FPItem *,BOOL)::$_0::~$_0(uint64_t a1)
{

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1);
}

os_unfair_lock_s *TFSInfo::CopyParentPathURL(TFSInfo *this)
{
  os_unfair_lock_s *PathComponent;
  const void *v3;
  const void *v5;

  PathComponent = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = (const void *)*((_QWORD *)this + 2);
  v5 = v3;
  if (v3)
  {
    CFRetain(v3);
    os_unfair_lock_unlock(PathComponent);
    PathComponent = (os_unfair_lock_s *)CFURLCreateCopyDeletingLastPathComponent(0, (CFURLRef)v3);
  }
  else
  {
    os_unfair_lock_unlock(PathComponent);
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v5);
  if (v3)
    return PathComponent;
  else
    return 0;
}

void sub_1CBCC27B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TString::GetUniChar(TString *this, CFIndex a2)
{
  if (a2 < 0 || CFStringGetLength(this->fString.fRef) <= a2)
    return 0;
  else
    return CFStringGetCharacterAtIndex(this->fString.fRef, a2);
}

uint64_t TFSInfo::IsLocation(TFSInfo *this)
{
  TFSInfo *v1;
  const TString *v2;
  uint64_t IsLocation;
  TString v5;

  if (*((_BYTE *)this + 112) == 21)
    v1 = 0;
  else
    v1 = (TFSInfo *)*((unsigned int *)this + 26);
  TFSInfo::Name(this, &v5);
  IsLocation = TFSInfo::IsLocation(v1, (TFSInfo *)&v5, v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return IsLocation;
}

void sub_1CBCC2880(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsLocation(TFSInfo *this, TFSInfo *a2, const TString *a3)
{
  unsigned __int16 v3;

  if ((int)this <= 1768712036)
  {
    if ((int)this > 1768711784)
    {
      if ((_DWORD)this != 1768711785)
      {
        v3 = 26228;
        goto LABEL_13;
      }
    }
    else if ((_DWORD)this != 1768710502)
    {
      v3 = 24948;
      goto LABEL_13;
    }
    return 1;
  }
  if ((int)this <= 1768713568)
  {
    if ((_DWORD)this != 1768712037)
    {
      v3 = 26740;
      goto LABEL_13;
    }
    return 1;
  }
  if ((_DWORD)this == 1768713569 || (_DWORD)this == 1768713847)
    return 1;
  v3 = 30318;
LABEL_13:
  if ((_DWORD)this == (v3 | 0x696C0000))
    return 1;
  return TFSInfo::HasLocationExtension(a2, (const TString *)a2);
}

uint64_t TFSInfo::HasLocationExtension(TFSInfo *this, const TString *a2)
{
  unint64_t Length;
  CFIndex v4;
  unint64_t v5;
  CFIndex v6;
  int CharacterAtIndex;
  uint64_t result;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;

  Length = CFStringGetLength(*(CFStringRef *)this);
  v4 = Length - 5;
  if (Length < 5)
    return 0;
  v5 = Length;
  v6 = Length - 3;
  if ((uint64_t)(Length - 3) < 0)
    return 0;
  if ((CFStringGetLength(*(CFStringRef *)this) <= v6 || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v6) != 76)
    && (CFStringGetLength(*(CFStringRef *)this) <= v6 || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v6) != 108))
  {
    return 0;
  }
  if ((CFStringGetLength(*(CFStringRef *)this) <= (uint64_t)(v5 - 2)
     || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 2) != 79)
    && (CFStringGetLength(*(CFStringRef *)this) <= (uint64_t)(v5 - 2)
     || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 2) != 111))
  {
    return 0;
  }
  if (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 1)
    && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 1) == 67)
  {
    if (v5 < 7)
      return 0;
    goto LABEL_18;
  }
  if (CFStringGetLength(*(CFStringRef *)this) <= (uint64_t)(v5 - 1))
    return 0;
  CharacterAtIndex = CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 1);
  result = 0;
  if (v5 >= 7 && CharacterAtIndex == 99)
  {
LABEL_18:
    v9 = v5 - 6;
    if (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 6)
      && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 46
      && (CFStringGetLength(*(CFStringRef *)this) > v4 && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 65
       || CFStringGetLength(*(CFStringRef *)this) > v4 && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 97)
      && (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 4)
       && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 4) == 84
       || TString::GetUniChar((TString *)this, v5 - 4) == 116))
    {
      return 1;
    }
    if (v5 >= 8)
    {
      v10 = v5 - 7;
      if (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 7)
        && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 7) == 46
        && ((CFStringGetLength(*(CFStringRef *)this) > v9
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 87
          || CFStringGetLength(*(CFStringRef *)this) > v9
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 119)
         && (CFStringGetLength(*(CFStringRef *)this) > v4 && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 69
          || TString::GetUniChar((TString *)this, v4) == 101)
         && (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 4)
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 4) == 66
          || TString::GetUniChar((TString *)this, v5 - 4) == 98)
         || (CFStringGetLength(*(CFStringRef *)this) > v9
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 70
          || TString::GetUniChar((TString *)this, v5 - 6) == 102)
         && (TString::GetUniChar((TString *)this, v4) == 84
          || TString::GetUniChar((TString *)this, v4) == 116)
         && (TString::GetUniChar((TString *)this, v5 - 4) == 80
          || TString::GetUniChar((TString *)this, v5 - 4) == 112)
         || (TString::GetUniChar((TString *)this, v5 - 6) == 65
          || TString::GetUniChar((TString *)this, v5 - 6) == 97)
         && (TString::GetUniChar((TString *)this, v4) == 70
          || TString::GetUniChar((TString *)this, v4) == 102)
         && (TString::GetUniChar((TString *)this, v5 - 4) == 80
          || TString::GetUniChar((TString *)this, v5 - 4) == 112)))
      {
        return 1;
      }
      if (v5 >= 9
        && CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 8)
        && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 8) == 46)
      {
        if ((CFStringGetLength(*(CFStringRef *)this) > v10
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 7) == 70
           || TString::GetUniChar((TString *)this, v5 - 7) == 102)
          && (CFStringGetLength(*(CFStringRef *)this) > v9
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 73
           || TString::GetUniChar((TString *)this, v5 - 6) == 105)
          && (CFStringGetLength(*(CFStringRef *)this) > v4
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 76
           || TString::GetUniChar((TString *)this, v4) == 108)
          && (TString::GetUniChar((TString *)this, v5 - 4) == 69
           || TString::GetUniChar((TString *)this, v5 - 4) == 101))
        {
          return 1;
        }
        if ((CFStringGetLength(*(CFStringRef *)this) > v10
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 7) == 73
           || TString::GetUniChar((TString *)this, v5 - 7) == 105)
          && (TString::GetUniChar((TString *)this, v5 - 6) == 78
           || TString::GetUniChar((TString *)this, v5 - 6) == 110)
          && (TString::GetUniChar((TString *)this, v4) == 69
           || TString::GetUniChar((TString *)this, v4) == 101)
          && (TString::GetUniChar((TString *)this, v5 - 4) == 84
           || TString::GetUniChar((TString *)this, v5 - 4) == 116))
        {
          return 1;
        }
        if ((TString::GetUniChar((TString *)this, v5 - 7) == 77
           || TString::GetUniChar((TString *)this, v5 - 7) == 109)
          && (TString::GetUniChar((TString *)this, v5 - 6) == 65
           || TString::GetUniChar((TString *)this, v5 - 6) == 97)
          && (TString::GetUniChar((TString *)this, v4) == 73
           || TString::GetUniChar((TString *)this, v4) == 105)
          && (TString::GetUniChar((TString *)this, v5 - 4) == 76
           || TString::GetUniChar((TString *)this, v5 - 4) == 108))
        {
          return 1;
        }
        if ((TString::GetUniChar((TString *)this, v5 - 7) == 78
           || TString::GetUniChar((TString *)this, v5 - 7) == 110)
          && (TString::GetUniChar((TString *)this, v5 - 6) == 69
           || TString::GetUniChar((TString *)this, v5 - 6) == 101)
          && (TString::GetUniChar((TString *)this, v4) == 87
           || TString::GetUniChar((TString *)this, v4) == 119))
        {
          v11 = v5 - 4;
          if (TString::GetUniChar((TString *)this, v11) == 83
            || TString::GetUniChar((TString *)this, v11) == 115)
          {
            return 1;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

BOOL TFSInfo::UserCanChangeLock(TFSInfo *this)
{
  TFSInfo *UserID;
  os_unfair_lock_s *v3;
  _BOOL8 v4;
  int v5;
  int v6;
  int Owner;

  UserID = (TFSInfo *)TFSInfo::GetUserID(this);
  if (!*((_BYTE *)this + 112))
  {
    v5 = (int)UserID;
    v6 = TFSInfo::GetUserID(UserID);
    Owner = TFSInfo::GetOwner(this);
    if (v5)
    {
      if (v6 != Owner)
        return 0;
    }
  }
  v3 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v4 = (*(_DWORD *)((char *)this + 115) & 0x10000) == 0;
  os_unfair_lock_unlock(v3);
  return v4;
}

BOOL TFSInfo::UserIsRoot(TFSInfo *this)
{
  return TFSInfo::GetUserID(this) == 0;
}

unint64_t TFSInfo::InfoIs(TFSInfo *this, uint64_t a2)
{
  TFSInfo *v3;
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int UserID;
  unint64_t v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  void *v23;

  v3 = this;
  if ((a2 & 1) != 0)
  {
    v4 = *((_BYTE *)this + 112) != 0;
    if ((a2 & 2) == 0)
      goto LABEL_8;
  }
  else
  {
    v4 = 0;
    if ((a2 & 2) == 0)
      goto LABEL_8;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(_DWORD *)((char *)v3 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  if ((v5 & 0x20) != 0
    || (os_unfair_lock_lock((os_unfair_lock_t)v3 + 25),
        v6 = *(_DWORD *)((char *)v3 + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25),
        (v6 & 0x20000) != 0))
  {
    v4 |= 2uLL;
  }
LABEL_8:
  if ((a2 & 4) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    v7 = *(_DWORD *)((char *)v3 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    if ((v7 & 0x100) != 0 && *((unsigned __int8 *)v3 + 112) - 23 >= 2)
      v4 |= 4uLL;
  }
  if ((a2 & 8) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    v8 = *(_DWORD *)((char *)v3 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    v4 = v4 & 0xFFFFFFFFFFFFFFF7 | (8 * (v8 & 1));
    if ((a2 & 0x10) == 0)
    {
LABEL_14:
      if ((a2 & 0x20) == 0)
        goto LABEL_15;
      goto LABEL_26;
    }
  }
  else if ((a2 & 0x10) == 0)
  {
    goto LABEL_14;
  }
  this = (TFSInfo *)TFSInfo::IsAlias(v3);
  if ((_DWORD)this)
    v4 |= 0x10uLL;
  if ((a2 & 0x20) == 0)
  {
LABEL_15:
    if ((a2 & 0x40) == 0)
      goto LABEL_16;
    goto LABEL_27;
  }
LABEL_26:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  v9 = *(unsigned int *)((char *)v3 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  v4 |= (v9 >> 1) & 0x20;
  if ((a2 & 0x40) == 0)
  {
LABEL_16:
    if ((a2 & 0x80) == 0)
      goto LABEL_17;
    goto LABEL_28;
  }
LABEL_27:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  v10 = (unint64_t)*(unsigned int *)((char *)v3 + 115) >> 2;
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  v4 = v4 & 0xFFFFFFFFFFFFFFBFLL | ((v10 & 1) << 6);
  if ((a2 & 0x80) == 0)
  {
LABEL_17:
    if ((a2 & 0x200) == 0)
      goto LABEL_18;
    goto LABEL_29;
  }
LABEL_28:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  v11 = (unint64_t)*(unsigned int *)((char *)v3 + 115) >> 1;
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  v4 = v4 & 0xFFFFFFFFFFFFFF7FLL | ((v11 & 1) << 7);
  if ((a2 & 0x200) == 0)
  {
LABEL_18:
    if ((a2 & 0x400) == 0)
      goto LABEL_19;
    goto LABEL_32;
  }
LABEL_29:
  this = (TFSInfo *)TFSInfo::IsLocation(v3);
  if ((_DWORD)this)
    v4 |= 0x200uLL;
  if ((a2 & 0x400) == 0)
  {
LABEL_19:
    if ((a2 & 0x800) == 0)
      goto LABEL_20;
    goto LABEL_35;
  }
LABEL_32:
  this = (TFSInfo *)TFSInfo::HasCustomIcon(v3);
  if ((_DWORD)this)
    v4 |= 0x400uLL;
  if ((a2 & 0x800) == 0)
  {
LABEL_20:
    if ((a2 & 0x1000) == 0)
      goto LABEL_42;
    goto LABEL_38;
  }
LABEL_35:
  UserID = TFSInfo::GetUserID(this);
  if (UserID == TFSInfo::GetOwner(v3))
    v4 |= 0x800uLL;
  if ((a2 & 0x1000) != 0)
  {
LABEL_38:
    if (*((_BYTE *)v3 + 112) || *((_DWORD *)v3 + 26) != 1651666795 && TFSInfo::GetCreationDate(v3) != -534528000.0)
      v4 |= 0x1000uLL;
  }
LABEL_42:
  if ((a2 & 0x4000) != 0)
  {
    if (*((_BYTE *)v3 + 112) == 1)
      v4 |= 0x4000uLL;
    if ((a2 & 0x10000) == 0)
    {
LABEL_44:
      if ((a2 & 0x20000) == 0)
        goto LABEL_45;
      goto LABEL_55;
    }
  }
  else if ((a2 & 0x10000) == 0)
  {
    goto LABEL_44;
  }
  if (*((_BYTE *)v3 + 112) == 5)
    v4 |= 0x10000uLL;
  if ((a2 & 0x20000) == 0)
  {
LABEL_45:
    if ((a2 & 0x40000) == 0)
      goto LABEL_46;
    goto LABEL_56;
  }
LABEL_55:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  v13 = (unint64_t)*(unsigned __int16 *)((char *)v3 + 119) >> 6;
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  v4 = v4 & 0xFFFFFFFFFFFDFFFFLL | ((v13 & 1) << 17);
  if ((a2 & 0x40000) == 0)
  {
LABEL_46:
    if ((a2 & 0x80000) == 0)
      goto LABEL_47;
    goto LABEL_59;
  }
LABEL_56:
  if (*((_BYTE *)v3 + 112) == 7)
    v4 |= 0x40000uLL;
  if ((a2 & 0x80000) == 0)
  {
LABEL_47:
    if ((a2 & 0x200000) == 0)
      goto LABEL_67;
    goto LABEL_62;
  }
LABEL_59:
  if (*((_BYTE *)v3 + 112) == 6)
    v4 |= 0x80000uLL;
  if ((a2 & 0x200000) != 0)
  {
LABEL_62:
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    v14 = *(_DWORD *)((char *)v3 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    if ((v14 & 0x20) != 0
      || (os_unfair_lock_lock((os_unfair_lock_t)v3 + 25),
          v15 = *(_DWORD *)((char *)v3 + 115),
          os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25),
          (v15 & 0x20000) != 0))
    {
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
      v16 = *(_DWORD *)((char *)v3 + 115);
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
      if ((v16 & 2) == 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
        v17 = *(unsigned int *)((char *)v3 + 115) | ((unint64_t)*(unsigned __int16 *)((char *)v3 + 119) << 32);
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
        if ((v17 & 0x4000000000) == 0)
          v4 |= 0x200000uLL;
      }
    }
  }
LABEL_67:
  if ((a2 & 0x2000000) != 0)
  {
    if (*((_BYTE *)v3 + 112) == 20)
      v4 |= 0x2000000uLL;
    if ((a2 & 0x4000000000000) == 0)
    {
LABEL_69:
      if ((a2 & 0x40000000000) == 0)
        goto LABEL_70;
      goto LABEL_80;
    }
  }
  else if ((a2 & 0x4000000000000) == 0)
  {
    goto LABEL_69;
  }
  if (*((_BYTE *)v3 + 112) == 34)
    v4 |= 0x4000000000000uLL;
  if ((a2 & 0x40000000000) == 0)
  {
LABEL_70:
    if ((a2 & 0x8000000) == 0)
      goto LABEL_71;
    goto LABEL_83;
  }
LABEL_80:
  if (*((_BYTE *)v3 + 112) == 33)
    v4 |= 0x40000000000uLL;
  if ((a2 & 0x8000000) == 0)
  {
LABEL_71:
    if ((a2 & 0x100000000000) == 0)
      goto LABEL_72;
LABEL_86:
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    v18 = *(unsigned __int16 *)((char *)v3 + 119);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    v4 |= (v18 << 35) & 0x100000000000;
    if ((a2 & 0x20000000000000) == 0)
      goto LABEL_93;
    goto LABEL_87;
  }
LABEL_83:
  if (*((_BYTE *)v3 + 112) == 16)
    v4 |= 0x8000000uLL;
  if ((a2 & 0x100000000000) != 0)
    goto LABEL_86;
LABEL_72:
  if ((a2 & 0x20000000000000) == 0)
    goto LABEL_93;
LABEL_87:
  v19 = *((unsigned __int8 *)v3 + 112);
  if ((v19 - 26) < 3)
  {
    v4 |= 0x20000000000000uLL;
    if ((a2 & 0x40000000000000) == 0)
      goto LABEL_97;
    goto LABEL_94;
  }
  if (*((_BYTE *)v3 + 112))
  {
    if (v19 == 35)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
      v20 = (unint64_t)*(unsigned __int16 *)((char *)v3 + 119) >> 7;
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
      v4 = v4 & 0xFFDFFFFFFFFFFFFFLL | ((v20 & 1) << 53);
    }
LABEL_93:
    if ((a2 & 0x40000000000000) == 0)
      goto LABEL_97;
    goto LABEL_94;
  }
  TFSInfo::GetFPItem(v3);
  v23 = (void *)objc_claimAutoreleasedReturnValue();

  if (v23)
    v4 |= 0x20000000000000uLL;
  if ((a2 & 0x40000000000000) != 0)
  {
LABEL_94:
    if (*((unsigned __int8 *)v3 + 112) - 29 < 2
      || (os_unfair_lock_lock((os_unfair_lock_t)v3 + 25),
          v21 = *(unsigned int *)((char *)v3 + 115) | ((unint64_t)*(unsigned __int16 *)((char *)v3 + 119) << 32),
          os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25),
          (v21 & 0x10000000000) != 0))
    {
      v4 |= 0x40000000000000uLL;
    }
  }
LABEL_97:
  if ((a2 & 0x2000000000000) != 0 && *((unsigned __int8 *)v3 + 112) - 23 < 2)
    v4 |= 0x2000000000000uLL;
  if ((a2 & 0x1000000000000) != 0 && *((_BYTE *)v3 + 112) == 25)
    v4 |= 0x1000000000000uLL;
  return v4;
}

uint64_t TFSInfo::HasExtendedUserAccess(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  const void *v4;
  int v5;
  int v6;
  uint64_t v7;
  const void *v9;

  v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if (v3 < 0)
    goto LABEL_9;
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x100000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x200000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x400000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x800000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v4 = (const void *)*((_QWORD *)this + 2);
  v9 = v4;
  if (!v4)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    goto LABEL_7;
  }
  CFRetain(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
    goto LABEL_8;
  }
  v6 = *((unsigned __int8 *)this + 112);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
  if (v6)
  {
LABEL_8:
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    *(_DWORD *)((char *)this + 115) |= 0x80000000;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
LABEL_9:
    v7 = 1;
    goto LABEL_10;
  }
  v7 = 0;
LABEL_10:
  os_unfair_lock_unlock(v2);
  return v7;
}

void sub_1CBCC3700(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;

  os_unfair_lock_unlock(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::MoveAndRenameTo(uint64_t a1, TFSInfo **a2, TString **a3, TString *this)
{
  const __CFString *v8;
  uint64_t v9;
  const char *v10;
  const std::__fs::filesystem::path *v11;
  const std::__fs::filesystem::path *v12;
  const char *v13;
  int v14;
  int *v15;
  const char *v16;
  unsigned int v17;
  TString v19;
  TString v20;
  CFStringRef v21;
  CFStringRef v22;
  CFStringRef v23;
  CFStringRef theString;

  TString::SetStringRefAsImmutable(this, 0);
  if ((TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)(a1 + 8), (const __CFString *)*MEMORY[0x1E0C9ACD0], v8) & 1) == 0)
  {
    TFSInfo::Path((TFSInfo *)a1, (CFTypeRef *)&theString);
    if (!CFStringGetLength(theString))
    {
      v9 = 4294959238;
LABEL_27:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      return v9;
    }
    TFSInfo::Path(*a2, (CFTypeRef *)&v23);
    if (!CFStringGetLength(v23))
    {
      v9 = 4294959238;
LABEL_26:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23);
      goto LABEL_27;
    }
    TFSInfo::Name((TFSInfo *)a1, (TString *)&v22);
    if (!CFStringGetLength(v22))
    {
      v9 = 4294959238;
LABEL_25:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22);
      goto LABEL_26;
    }
    v21 = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    if (a3)
      TString::SetStringRefAsImmutable((TString *)&v21, *a3);
    else
      TString::SetStringRefAsImmutable((TString *)&v21, (TString *)v22);
    if (CFStringGetLength(v21))
    {
      SlashesToColons((const TString *)&v21, &v19);
      AppendPath((const TString *)&v23, &v19, &v20);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
      v10 = (const char *)TString::c_str(&v20);
      if (strlen(v10) < 0x400)
      {
        if (&v20 != this)
          TString::SetStringRefAsImmutable(this, (TString *)v20.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
        v11 = (const std::__fs::filesystem::path *)TString::c_str((TString *)&theString);
        v12 = (const std::__fs::filesystem::path *)TString::c_str(this);
        v14 = TCFURLInfo::RenameWithoutReplacing(v11, v12, v13);
        if (v14)
        {
          v15 = __error();
          v17 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v15, 0, v16);
        }
        else
        {
          v17 = -8069;
        }
        if (v14)
          v9 = v17;
        else
          v9 = 0;
        goto LABEL_24;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
    }
    v9 = 4294959227;
LABEL_24:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21);
    goto LABEL_25;
  }
  return 4294959217;
}

void sub_1CBCC3904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  const void *v6;
  va_list va1;
  const void *v8;
  va_list va2;
  va_list va3;

  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v8 = va_arg(va3, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsNoUnlinkEffective(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E0C9ACD0], a3);
}

uint64_t TFSInfo::FileScheme(TFSInfo *this)
{
  unsigned __int8 v1;
  TString *v3;

  {
    v3 = (TString *)operator new();
    TString::TString(v3, "file");
    TFSInfo::FileScheme(void)::fileScheme = (uint64_t)v3;
  }
  return TFSInfo::FileScheme(void)::fileScheme;
}

void sub_1CBCC3A10(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::TriggerMount(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v4;
  const char *v5;
  DIR *v6;
  int *v7;
  const char *v8;
  CFStringRef theString;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x8000) == 0)
    return 0;
  TFSInfo::Path(this, (CFTypeRef *)&theString);
  if (CFStringGetLength(theString))
  {
    v5 = (const char *)TString::c_str((TString *)&theString);
    v6 = opendir(v5);
    if (v6)
    {
      closedir(v6);
      v4 = 0;
    }
    else
    {
      v7 = __error();
      v4 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v7, 0, v8);
    }
  }
  else
  {
    v4 = 4294959238;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v4;
}

void sub_1CBCC3AFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

id objc_cast<NSArray,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

uint64_t TFSInfo::WriteTagsForPath(TFSInfo *this, const __CFArray *a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;
  void *v7;
  CFIndex Count;
  TString *v9;
  CFDataRef Data;
  const char *v11;
  const __CFData *v12;
  TString *v13;
  const char *v14;
  uint64_t v15;
  CFStringRef theString;
  void *v18;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = (void *)*((_QWORD *)this + 2);
  v18 = v5;
  if (v5)
  {
    CFRetain(v5);
    v6 = v18;
  }
  else
  {
    v6 = 0;
  }
  os_unfair_lock_unlock(v4);
  if ((objc_msgSend(v6, "isFileURL") & 1) == 0)
    goto LABEL_15;
  v7 = v18;
  if (!v18)
  {
LABEL_17:
    v15 = 4294959238;
    goto LABEL_18;
  }
  if (!a2 || (Count = CFArrayGetCount(a2), v7 = v18, !Count))
  {
    objc_msgSend(v7, "path");
    v13 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&theString, v13);

    if (CFStringGetLength(theString))
    {
      v14 = (const char *)TString::c_str((TString *)&theString);
      removexattr(v14, "com.apple.metadata:_kMDItemUserTags", 1);
    }
    goto LABEL_14;
  }
  objc_msgSend(v18, "path");
  v9 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&theString, v9);

  if (!CFStringGetLength(theString))
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_17;
  }
  Data = CFPropertyListCreateData(0, a2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    v11 = (const char *)TString::c_str((TString *)&theString);
    v12 = objc_retainAutorelease(Data);
    setxattr(v11, "com.apple.metadata:_kMDItemUserTags", (const void *)-[__CFData bytes](v12, "bytes"), -[__CFData length](v12, "length"), 0, 1);
  }

LABEL_14:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
LABEL_15:
  v15 = 0;
LABEL_18:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v18);
  return v15;
}

void sub_1CBCC3D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TFSInfo::Rename(TFSInfo *this@<X0>, TString *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  unsigned int v8;
  int v9;
  int v10;
  int Parent;
  int v12;
  const void *v13;
  CFTypeRef v14;
  const __CFString *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  CFTypeRef cf1;
  std::__shared_weak_count *v20;

  *(_QWORD *)a4 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *(_DWORD *)(a4 + 8) = 0;
  v8 = *((unsigned __int8 *)this + 112);
  if (v8 > 0x14)
  {
    if (v8 == 21 || v8 == 34)
      goto LABEL_8;
  }
  else if (*((_BYTE *)this + 112))
  {
    if (v8 == 1)
    {
      TFSInfo::Name(this, (TString *)&cf1);
      v9 = CFEqual(cf1, a2->fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (!v9)
LABEL_8:
        TFSInfo::SetItemName(this, a2);
    }
  }
  else
  {
    TFSInfo::Name(this, (TString *)&cf1);
    v10 = CFEqual(cf1, a2->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    if (v10)
    {
      if (a3)
        *(_DWORD *)(a4 + 8) = 0;
      else
        *(_DWORD *)(a4 + 8) = -8057;
    }
    else
    {
      _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&cf1);
      Parent = TFSInfo::GetParent((uint64_t)this, (uint64_t *)&cf1);
      *(_DWORD *)(a4 + 8) = Parent;
      if (!Parent)
      {
        if (cf1)
        {
          v12 = TFSInfo::MoveAndRenameTo((uint64_t)this, (TFSInfo **)&cf1, (TString **)a2, (TString *)a4);
        }
        else
        {
          v13 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
          if (v13)
          {
            v14 = CFAutorelease(v13);
            v15 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v14);
          }
          else
          {
            v15 = 0;
          }
          v12 = TFSInfo::SetProperty(this, (const __CFString *)*MEMORY[0x1E0C9B5A0], v15);
        }
        *(_DWORD *)(a4 + 8) = v12;
      }
      v16 = v20;
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
    }
  }
}

void sub_1CBCC3F50(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetType(TFSInfo *this, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  CFIndex result;
  _QWORD v7[4];

  TFSInfo::GetFinderInfo(this);
  v7[0] = a2 | ((unint64_t)*((unsigned int *)this + 27) << 32);
  v7[1] = v4;
  v7[2] = TFSInfo::GetExtendedFinderInfo(this);
  v7[3] = v5;
  result = TFSInfo::SetTotalFinderInfo(this, (const UInt8 *)v7);
  if (!(_DWORD)result)
    *((_DWORD *)this + 26) = a2;
  return result;
}

CFIndex TFSInfo::SetCreator(TFSInfo *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  CFIndex result;
  _QWORD v7[4];

  TFSInfo::GetFinderInfo(this);
  v7[0] = *((unsigned int *)this + 26) | (unint64_t)(a2 << 32);
  v7[1] = v4;
  v7[2] = TFSInfo::GetExtendedFinderInfo(this);
  v7[3] = v5;
  result = TFSInfo::SetTotalFinderInfo(this, (const UInt8 *)v7);
  if (!(_DWORD)result)
    *((_DWORD *)this + 27) = a2;
  return result;
}

uint64_t TFSInfo::GetFinderInfo(TFSInfo *this)
{
  if (*((_BYTE *)this + 112) != 28)
    TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  return 0;
}

CFIndex TFSInfo::SetIsExtensionHidden(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  const __CFString **v7;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x10) == 0)
    return 0;
  v7 = (const __CFString **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v7 = (const __CFString **)MEMORY[0x1E0C9AE40];
  return TFSInfo::SetProperty(this, (const __CFString *)*MEMORY[0x1E0C9B4C8], *v7);
}

id TFSInfo::LastUsedDate(TFSInfo *this)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  uint64_t v9;
  void *v10;
  const void *v12;

  v2 = (void *)*((_QWORD *)this + 9);
  if (!v2)
  {
    TFSInfo::GetFPItem(this);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = v3;
    if (v3)
    {
      objc_msgSend(v3, "lastUsedDate");
      v5 = objc_claimAutoreleasedReturnValue();
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      v7 = (void *)*((_QWORD *)this + 2);
      v12 = v7;
      if (v7)
        CFRetain(v7);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      v8 = v7;
      FileMetadataCopyLastUsedDateAtURL();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = (void *)*((_QWORD *)this + 9);
      *((_QWORD *)this + 9) = v9;

      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v12);
      if (*((_QWORD *)this + 9))
        goto LABEL_8;
      objc_msgSend(MEMORY[0x1E0C99D68], "distantPast");
      v5 = objc_claimAutoreleasedReturnValue();
    }
    v6 = (void *)*((_QWORD *)this + 9);
    *((_QWORD *)this + 9) = v5;

LABEL_8:
    v2 = (void *)*((_QWORD *)this + 9);
  }
  return v2;
}

void sub_1CBCC423C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  void *v10;
  os_unfair_lock_s *v11;

  os_unfair_lock_unlock(v11);

  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetIsInvisible(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  const __CFString **v7;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v4);
  if (((v5 ^ a2) & 1) != 0)
    return 0;
  v7 = (const __CFString **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v7 = (const __CFString **)MEMORY[0x1E0C9AE40];
  return TFSInfo::SetProperty(this, (const __CFString *)*MEMORY[0x1E0C9B4F8], *v7);
}

uint64_t TFSInfo::GetExtendedFinderInfo(TFSInfo *this)
{
  if (*((_BYTE *)this + 112) != 28)
    TCFURLInfo::CopyPropertyValues(*((_QWORD *)this + 1));
  return 0;
}

CFIndex TFSInfo::SetTotalFinderInfo(TFSInfo *a1, const UInt8 *a2)
{
  CFIndex v3;
  const __CFString *v5;

  v5 = (const __CFString *)CFDataCreate(0, a2, 32);
  v3 = TFSInfo::SetProperty(a1, (const __CFString *)*MEMORY[0x1E0C9AC60], v5);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&v5);
  return v3;
}

void sub_1CBCC43E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::HasBeenInited(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  unint64_t v4;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0)
    return 0;
  TFSInfo::GetFinderInfo(this);
  return (v4 >> 8) & 1;
}

uint64_t TFSInfo::GetPhysicalSize(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v5;
  int v6;
  const __CFString *v7;
  const __CFString *v8;
  void *v9;
  os_unfair_lock_s *v10;
  os_unfair_lock_s *v11;
  _BYTE v12[8];
  uint64_t v13;
  char v14;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0)
    return -1;
  if (*((unsigned __int8 *)this + 112) - 27 <= 1)
    return TFSInfo::GetDataLogicalSize(this);
  os_unfair_lock_lock(v2);
  v6 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v6 & 0x20) != 0)
  {
    if (UseFileProviderFramework())
    {
      if ((TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9AC48], v8) & 0x40000000) != 0)
      {
        TFSInfo::GetFPItem(this);
        v9 = (void *)objc_claimAutoreleasedReturnValue();

        if (v9)
          return 0;
      }
    }
    v10 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    v11 = (os_unfair_lock_s *)*((_QWORD *)this + 10);
    if (v11)
    {
      TFSInfoOverflow::FolderSizeRecord(v11, (uint64_t)v12);
      if (v14)
        v5 = v13;
      else
        v5 = -1;
    }
    else
    {
      v5 = -1;
    }
    os_unfair_lock_unlock(v10);
    return v5;
  }
  return (uint64_t)TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E0C9B5D0], v7);
}

void sub_1CBCC4594(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLabel(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  unsigned int v4;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0)
    return 0;
  TFSInfo::GetFinderInfo(this);
  return (v4 >> 1) & 7;
}

CFIndex TFSInfo::SetModeDetails(TFSInfo *this, mode_t a2)
{
  __CFFileSecurity *v4;
  CFIndex v5;
  mode_t mode;
  CFFileSecurityRef fileSec;

  if (!*((_QWORD *)this + 1))
    return 4294959238;
  v4 = (__CFFileSecurity *)TFSInfo::CopyPermissions(this);
  fileSec = v4;
  if (v4 && (mode = 0, CFFileSecurityGetMode(v4, &mode), mode != a2) && CFFileSecuritySetMode(fileSec, a2))
    v5 = TFSInfo::SetProperty(this, (const __CFString *)*MEMORY[0x1E0C9B4A0], (const __CFString *)fileSec);
  else
    v5 = 0;
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
  return v5;
}

void sub_1CBCC46A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<ISIcon * {__strong}>(uint64_t a1, id *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<ISIcon * {__strong}>(*(id **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

id TFSInfo::FetchIFSymbol(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  TFSInfoOverflow *v3;
  id v4;
  void *v5;
  TFSInfoOverflow *Overflow;
  uint64_t v7;

  v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  v3 = (TFSInfoOverflow *)*((_QWORD *)this + 10);
  if (v3)
  {
    TFSInfoOverflow::GetIFSymbol(v3);
    v4 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  if (!v4)
  {
    TFSInfo::FetchISIcon(this);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "symbol");
    v4 = (id)objc_claimAutoreleasedReturnValue();
    os_unfair_lock_lock(v2);
    if (v4)
    {
      Overflow = TFSInfo::GetOrCreateOverflow(this);
      TFSInfoOverflow::SetIFSymbol((uint64_t)Overflow, v4);
    }
    else
    {
      v7 = *((_QWORD *)this + 10);
      if (v7)
        TFSInfoOverflow::SetIFSymbol(v7, 0);
    }
    os_unfair_lock_unlock(v2);

  }
  return v4;
}

void sub_1CBCC48D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<IFSymbol * {__strong}>(uint64_t a1, id *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<IFSymbol * {__strong}>(*(id **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

BOOL TFSInfo::FetchFlatFileVersion(uint64_t a1, TString *a2)
{
  os_unfair_lock_s *v4;
  const __CFURL *v5;
  const __CFDictionary *v6;
  _BOOL8 v7;
  TString *Value;
  TString *v9;
  CFTypeID v10;
  TString *v11;
  TString *v12;
  CFTypeID v13;
  TString v15;
  CFDictionaryRef theDict;
  const __CFURL *v17;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v5 = *(const __CFURL **)(a1 + 16);
  v17 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    v6 = CFBundleCopyInfoDictionaryForURL(v17);
    theDict = v6;
    v7 = v6 != 0;
    if (v6)
    {
      Value = (TString *)CFDictionaryGetValue(v6, CFSTR("CFBundleShortVersionString"));
      v9 = Value;
      if (Value)
      {
        v10 = CFGetTypeID(Value);
        if (v10 == CFStringGetTypeID())
        {
          v15.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v15, v9);
          if (&v15 != a2)
            TString::SetStringRefAsImmutable(a2, (TString *)v15.fString.fRef);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        }
      }
      v11 = (TString *)CFDictionaryGetValue(theDict, CFSTR("CFBundleGetInfoString"));
      v12 = v11;
      if (v11)
      {
        v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          v15.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v15, v12);
          if (&a2[1] != &v15)
            TString::SetStringRefAsImmutable(a2 + 1, (TString *)v15.fString.fRef);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        }
      }
    }
    TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&theDict);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    v7 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v17);
  return v7;
}

void sub_1CBCC4BE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)va1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::FetchPlistVersion(uint64_t a1, TString *a2)
{
  os_unfair_lock_s *v4;
  const void *v5;
  __CFBundle *Unique;
  _BOOL8 v7;
  TString *ValueForInfoDictionaryKey;
  TString *v9;
  CFTypeID v10;
  TString *v11;
  TString *v12;
  CFTypeID v13;
  TString *v14;
  TString *v15;
  CFTypeID v16;
  TString v18;
  CFBundleRef bundle;
  const void *v20;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v5 = *(const void **)(a1 + 16);
  v20 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    Unique = (__CFBundle *)_CFBundleCreateUnique();
    bundle = Unique;
    v7 = Unique != 0;
    if (Unique)
    {
      ValueForInfoDictionaryKey = (TString *)CFBundleGetValueForInfoDictionaryKey(Unique, CFSTR("CFBundleShortVersionString"));
      v9 = ValueForInfoDictionaryKey;
      if (ValueForInfoDictionaryKey)
      {
        v10 = CFGetTypeID(ValueForInfoDictionaryKey);
        if (v10 == CFStringGetTypeID())
        {
          v18.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v18, v9);
          if (&v18 != a2)
            TString::SetStringRefAsImmutable(a2, (TString *)v18.fString.fRef);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
        }
      }
      v11 = (TString *)CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("CFBundleGetInfoString"));
      v12 = v11;
      if (v11)
      {
        v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          v18.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v18, v12);
          if (&a2[1] != &v18)
            TString::SetStringRefAsImmutable(a2 + 1, (TString *)v18.fString.fRef);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
        }
      }
      v14 = (TString *)CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("NSHumanReadableCopyright"));
      v15 = v14;
      if (v14)
      {
        v16 = CFGetTypeID(v14);
        if (v16 == CFStringGetTypeID())
        {
          v18.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable(&v18, v15);
          if (&a2[3] != &v18)
            TString::SetStringRefAsImmutable(a2 + 3, (TString *)v18.fString.fRef);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
        }
      }
    }
    TAutoRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TAutoRef((const void **)&bundle);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    v7 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v20);
  return v7;
}

void sub_1CBCC4E24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TAutoRef((const void **)va1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsFramework(TFSInfo *this)
{
  int v2;
  _BOOL8 v3;
  TString v5;

  if (TFSInfo::IsFramework(void)const::once != -1)
    dispatch_once(&TFSInfo::IsFramework(void)const::once, &__block_literal_global_86);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v2 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v2 & 0x20) == 0)
    return 0;
  TFSInfo::Name(this, &v5);
  v3 = TString::EndsWith(&v5, (const TString *)TFSInfo::IsFramework(void)const::kFrameworkExtension);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1CBCC4F34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCC4F90(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

const void *TFSInfo::SFNodeFromSFBrowser(TFSInfo *a1, uint64_t a2, int a3)
{
  const void *v5;
  const void *RootNode;
  unint64_t v7;
  int v8;
  const void *v9;
  unsigned int v10;
  NSObject *v12;
  dispatch_source_t v13;
  NSObject *v14;
  dispatch_time_t v15;
  CFTypeRef cf;
  CFTypeRef v18;
  NSObject *v19;
  _QWORD handler[4];
  CFTypeRef v21;
  CFTypeRef v22;
  NSObject *v23;
  const void *v24;
  BOOL v25;
  const void *v26;
  TFSInfo *v27;

  v27 = 0;
  if (((_DWORD)a1 - 31) < 2)
  {
    cf = TFSInfo::CopyNetworkNearbyBrowserRef(a1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&v27, cf);
LABEL_5:
    TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(&cf);
    goto LABEL_6;
  }
  if ((_DWORD)a1 == 33)
  {
    cf = TFSInfo::CopyAirDropBrowserRef(a1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&v27, cf);
    goto LABEL_5;
  }
LABEL_6:
  v5 = 0;
  if (a2 && v27)
  {
    RootNode = (const void *)SFBrowserGetRootNode();
    v26 = RootNode;
    if (RootNode)
    {
      CFRetain(RootNode);
      v7 = (unint64_t)v26;
    }
    else
    {
      v7 = 0;
    }
    v25 = 0;
    v8 = TFSInfo::BrowserOpenNode(v27, v7, 0, 0, &v25);
    v9 = (const void *)SFBrowserCopyNodeForURL();
    v5 = v9;
    v24 = v9;
    if (a3 && !v9)
    {
      v10 = 0;
      do
      {
        usleep(0x186A0u);
        v5 = (const void *)SFBrowserCopyNodeForURL();
        v24 = v5;
        if (v5)
          break;
      }
      while (v10++ < 0x31);
    }
    if (!v8)
    {
      dispatch_get_global_queue(0, 0);
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v12);

      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3321888768;
      handler[2] = ___ZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLb_block_invoke;
      handler[3] = &__block_descriptor_56_ea8_32c72_ZTSKZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLbE3__0_e5_v8__0l;
      cf = v27;
      if (v27)
        CFRetain(v27);
      v18 = v26;
      if (v26)
        CFRetain(v26);
      v14 = v13;
      v19 = v14;
      v21 = cf;
      if (cf)
        CFRetain(cf);
      v22 = v18;
      if (v18)
        CFRetain(v18);
      v23 = v19;
      dispatch_source_set_event_handler(v14, handler);

      TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(&v18);
      TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&cf);
      v15 = dispatch_time(0, 20000000000);
      dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
      dispatch_resume(v14);

      TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(&v22);
      TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v21);

      v5 = v24;
    }
    v24 = 0;
    TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef(&v24);
    TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(&v26);
  }
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)&v27);
  return v5;
}

void sub_1CBCC5234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;
  const void **v10;
  uint64_t v11;

  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v10);
  TFSInfo::SFNodeFromSFBrowser(FSInfoVirtualType,__CFURL const*,BOOL)::$_0::~$_0((uint64_t)&a9);

  TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef((const void **)(v11 - 64));
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)(v11 - 48));
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)(v11 - 40));
  _Unwind_Resume(a1);
}

const void *TFSInfo::CopyNetworkNearbyBrowserRef(TFSInfo *this)
{
  os_unfair_lock_s *v1;
  const void *v2;

  v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  v2 = RetainCF<__CFString const*>((const void **)&TFSInfo::gNetworkNearbyBrowserRef);
  os_unfair_lock_unlock(v1);
  return v2;
}

void sub_1CBCC5308(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void *TFSInfo::CopyAirDropBrowserRef(TFSInfo *this)
{
  os_unfair_lock_s *v1;
  const void *v2;

  v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  v2 = RetainCF<__CFString const*>((const void **)&TFSInfo::gAirDropBrowserRef);
  os_unfair_lock_unlock(v1);
  return v2;
}

void sub_1CBCC535C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::BrowserOpenNode(TFSInfo *a1, unint64_t a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  os_unfair_lock_s *v8;
  TFSInfo *v9;
  uint64_t **v10;
  _OWORD *v11;
  int v12;
  unint64_t v14[2];
  unint64_t *v15;

  *a5 = 0;
  v8 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v8);
  v10 = (uint64_t **)TFSInfo::OpenBrowserMap(v9);
  v14[0] = (unint64_t)a1;
  v14[1] = a2;
  v15 = v14;
  v11 = std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__emplace_unique_key_args<std::pair<__SFBrowser *,__SFNode *>,std::piecewise_construct_t const&,std::tuple<std::pair<__SFBrowser *,__SFNode *>&&>,std::tuple<>>(v10, v14, (uint64_t)&std::piecewise_construct, (_OWORD **)&v15);
  v12 = *((_DWORD *)v11 + 12);
  *((_DWORD *)v11 + 12) = v12 + 1;
  *a5 = v12 == 0;
  os_unfair_lock_unlock(v8);
  if (*a5)
    return SFBrowserOpenNode();
  else
    return 0;
}

void sub_1CBCC5430(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void ___ZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLb_block_invoke(uint64_t a1)
{
  BOOL v2;

  v2 = 0;
  TFSInfo::BrowserCloseNode(*(TFSInfo **)(a1 + 32), *(_QWORD *)(a1 + 40), &v2);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
}

id __copy_helper_block_ea8_32c72_ZTSKZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLbE3__0(_QWORD *a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  id result;

  v4 = *(const void **)(a2 + 32);
  a1[4] = v4;
  if (v4)
    CFRetain(v4);
  v5 = *(const void **)(a2 + 40);
  a1[5] = v5;
  if (v5)
    CFRetain(v5);
  result = *(id *)(a2 + 48);
  a1[6] = result;
  return result;
}

void sub_1CBCC54DC(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **__destroy_helper_block_ea8_32c72_ZTSKZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLbE3__0(uint64_t a1)
{
  const void **v2;

  v2 = (const void **)(a1 + 32);

  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)(a1 + 40));
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v2);
}

const void **TFSInfo::SFNodeFromSFBrowser(FSInfoVirtualType,__CFURL const*,BOOL)::$_0::~$_0(uint64_t a1)
{

  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)(a1 + 8));
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)a1);
}

uint64_t TFSInfo::BrowserCloseNode(TFSInfo *a1, unint64_t a2, BOOL *a3)
{
  os_unfair_lock_s *v6;
  TFSInfo *v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  unint64_t v12[2];

  *a3 = 0;
  v6 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v6);
  v8 = TFSInfo::OpenBrowserMap(v7);
  v12[0] = (unint64_t)a1;
  v12[1] = a2;
  v9 = std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::find<std::pair<__SFBrowser *,__SFNode *>>(v8, v12);
  if ((_QWORD *)(v8 + 8) != v9)
  {
    v10 = *((_DWORD *)v9 + 12) - 1;
    *((_DWORD *)v9 + 12) = v10;
    *a3 = v10 == 0;
  }
  os_unfair_lock_unlock(v6);
  if (*a3)
    return SFBrowserCloseNode();
  else
    return 0;
}

void sub_1CBCC55F8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsBrowserOpen(TFSInfo *a1)
{
  os_unfair_lock_s *v2;
  TFSInfo *v3;
  uint64_t v4;
  _BOOL8 v5;
  unint64_t v7[2];

  v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  v4 = TFSInfo::OpenBrowserMap(v3);
  v7[0] = (unint64_t)a1;
  v7[1] = SFBrowserGetRootNode();
  v5 = v4 + 8 != (_QWORD)std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::find<std::pair<__SFBrowser *,__SFNode *>>(v4, v7);
  os_unfair_lock_unlock(v2);
  return v5;
}

void sub_1CBCC5680(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void *TFSInfo::SFNodeFromURL(uint64_t a1, int a2, char *a3)
{
  char v6;
  const void *result;

  v6 = 31;
  result = TFSInfo::SFNodeFromSFBrowser((TFSInfo *)0x1F, a1, a2);
  if (result)
    goto LABEL_2;
  if ((IsRunningInFinder() & 1) != 0)
    return 0;
  v6 = 33;
  result = TFSInfo::SFNodeFromSFBrowser((TFSInfo *)0x21, a1, a2);
  if (result)
LABEL_2:
    *a3 = v6;
  return result;
}

uint64_t TFSInfo::SetAliasIsContainer(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v6 = *(_DWORD *)((char *)this + 115);
  v5 = (char *)this + 115;
  v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  v8 = (v7 >> 17) & 1;
  v9 = 0x20000;
  if (!a2)
    v9 = 0;
  v10 = v7 & 0xFFFFFFFFFFFDFFFFLL;
  *(_DWORD *)v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

const void **__Block_byref_object_dispose_(uint64_t a1)
{
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)(a1 + 48));
}

void ___ZNK7TFSInfo24FollowAliasOrSymlinkDeepE18NodeRequestOptionsRNSt3__110shared_ptrIS_EEi_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  const void *v5;

  v3 = a2;
  if (*(_BYTE *)(a1 + 40))
    v4 = (const void *)MEMORY[0x1D17A4D88](0, v3, 0);
  else
    v4 = 0;
  v5 = v4;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), v4);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v5);

}

void sub_1CBCC5808(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CFIndex TFSInfo::CopyBookmarkDataTo(TFSInfo *this, const __CFData **a2)
{
  os_unfair_lock_s *v4;
  const void *v5;
  __CFError *v6;
  CFIndex v7;
  TCFURLInfo *v9;
  const void *v10;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = (const void *)*((_QWORD *)this + 2);
  v10 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    v9 = 0;
    *a2 = (const __CFData *)MEMORY[0x1D17A4D7C](0, v5, 536871424, 0, v5, &v9);
    if (v9)
      v7 = TCFURLInfo::TranslateCFError(v9, v6);
    else
      v7 = 0;
    TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v9);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    v7 = 4294959238;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v10);
  return v7;
}

void sub_1CBCC58E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<short>(uint64_t a1, __int16 *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      result = 0;
      **(_WORD **)a1 = *a2;
      break;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_47;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      result = 0;
      **(_QWORD **)a1 = *a2;
      break;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      result = TPropertyValue::SetAs<short>(*(_QWORD *)a1, a2);
      break;
    case 20:
      if (v2 == 20)
        goto LABEL_41;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_47;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_41:
      result = 4294959246;
      break;
  }
  return result;
}

uint64_t TFSInfo::FetchVersionMetaData(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  _BOOL4 FlatFileVersion;
  _BOOL4 v10;
  os_unfair_lock_s *v11;
  TString *v12;
  const void **v13;
  TString *v14;
  TString *v16;

  v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v5 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x20000000) != 0)
    return 0;
  std::make_unique[abi:ne180100]<TVersionData>((uint64_t *)&v16);
  if ((a2 & 0x8000000) == 0)
  {
    v6 = 4294959222;
    goto LABEL_19;
  }
  os_unfair_lock_lock(v4);
  v7 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  os_unfair_lock_lock(v4);
  v8 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((v7 & 0x20) == 0)
  {
    if ((v8 & 4) == 0 || !TFSInfo::FetchPlistVersion(a1, v16))
    {
      FlatFileVersion = TFSInfo::FetchFlatFileVersion(a1, v16);
      goto LABEL_12;
    }
LABEL_14:
    v11 = (os_unfair_lock_s *)(a1 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    goto LABEL_15;
  }
  if ((v8 & 2) == 0 && !TFSInfo::IsFramework((TFSInfo *)a1))
    goto LABEL_14;
  FlatFileVersion = TFSInfo::FetchPlistVersion(a1, v16);
LABEL_12:
  v10 = FlatFileVersion;
  v11 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (v10)
  {
LABEL_15:
    v12 = v16;
    v16 = 0;
    v13 = *(const void ***)a1;
    *(_QWORD *)a1 = v12;
    if (v13)
      std::default_delete<TVersionData>::operator()[abi:ne180100](a1, v13);
    v6 = 0;
    goto LABEL_18;
  }
  v6 = 4294959222;
LABEL_18:
  os_unfair_lock_lock(v4);
  *(_DWORD *)(a1 + 115) |= 0x20000000u;
  os_unfair_lock_unlock(v4);
  os_unfair_lock_unlock(v11);
LABEL_19:
  v14 = v16;
  v16 = 0;
  if (v14)
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v16, (const void **)&v14->fString.fRef);
  return v6;
}

void sub_1CBCC5C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10)
{
  const void **v11;

  v11 = a10;
  a10 = 0;
  if (v11)
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&a10, v11);
  _Unwind_Resume(exception_object);
}

CFTypeRef std::make_unique[abi:ne180100]<TVersionData>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  CFTypeRef result;

  v2 = operator new();
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_QWORD *)v2 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *(_QWORD *)(v2 + 8) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *(_QWORD *)(v2 + 16) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  *(_QWORD *)(v2 + 24) = &stru_1E8752DF8;
  result = CFRetain(&stru_1E8752DF8);
  *a1 = v2;
  return result;
}

void sub_1CBCC5CC4(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;
  const void **v3;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  MEMORY[0x1D17A53D0](v1, 0x60C40902580DDLL);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOldLocation(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  int v3;
  unint64_t v4;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x100) != 0 || !TFSInfo::HasBeenInited(this))
    return 0xFFFFFFFFLL;
  TFSInfo::GetFinderInfo(this);
  if ((v4 & 0xFFFFFFFF0000) != 0)
    return (v4 >> 16);
  else
    return 0xFFFFFFFFLL;
}

unint64_t TFSInfo::GetOldIconOrigin(TFSInfo *this)
{
  unint64_t result;
  int v3;

  result = TFSInfo::HasBeenInited(this);
  if ((_DWORD)result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v3 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v3 & 0x20) != 0)
      return TFSInfo::GetExtendedFinderInfo(this);
    else
      return 0;
  }
  return result;
}

uint64_t TFSInfo::GetOldViewStyle(TFSInfo *this)
{
  int v2;
  __int16 v4;
  __int16 v5;
  __int16 v6;
  __int16 v7;
  __int16 v8;

  if (TFSInfo::HasBeenInited(this)
    && (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        v2 = *(_DWORD *)((char *)this + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v2 & 0x20) != 0))
  {
    TFSInfo::GetExtendedFinderInfo(this);
    v5 = v4;
    TFSInfo::GetFinderInfo(this);
    if ((v5 & 0x800) != 0)
      v7 = 4;
    else
      v7 = 5;
    if ((v5 & 0x2000) == 0)
      v7 = 3;
    if ((v6 & 0x40) != 0)
      v8 = 2;
    else
      v8 = v7;
    if ((v6 & 0xE00) != 0)
      return 1;
    else
      return v8;
  }
  else
  {
    return 0;
  }
}

unint64_t TFSInfo::GetFlatItemDirEntryCount(TFSInfo *this, int a2)
{
  const __CFString *v4;
  TCFURLInfo *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  unsigned __int8 v9;
  NSObject *v10;
  NSURL *v11;
  void *v12;
  unint64_t v13;
  void *v14;
  const char *v15;
  NSObject *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  TString v21;
  stat buf;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (IsEnhancedAPFSEnabled()
    && (v5 = (TCFURLInfo *)*((_QWORD *)this + 1)) != 0
    && (TCFURLInfo::GetNumberProperty(v5, (const __CFString *)*MEMORY[0x1E0C9B410], v4),
        v6 = (void *)objc_claimAutoreleasedReturnValue(),
        (v7 = v6) != 0))
  {
    v8 = objc_msgSend(v6, "unsignedLongLongValue");
    v9 = v8;
    if (v8 == 65533)
    {
      LogObj(5);
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v11 = (NSURL *)*((id *)this + 1);
        SanitizedURL(v11);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        buf.st_dev = 138543362;
        *(_QWORD *)&buf.st_mode = v12;
        _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_DEBUG, "Unknown child item count found for %{public}@", (uint8_t *)&buf, 0xCu);

      }
      v9 = 0;
      v13 = 0;
    }
    else
    {
      v13 = v8 & 0xFFFFFFFFFFFFFF00;
    }

  }
  else if (a2
         && (v14 = (void *)*((_QWORD *)this + 1)) != 0
         && (v15 = (const char *)objc_msgSend(objc_retainAutorelease(v14), "fileSystemRepresentation")) != 0
         && !stat(v15, &buf)
         && (unsigned __int16)(buf.st_nlink + 1) > 2u)
  {
    v9 = LOBYTE(buf.st_nlink) - 2;
    v13 = (buf.st_nlink + 4294967294) & 0xFFFFFF00;
  }
  else
  {
    LogObj(4);
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = (void *)*((_QWORD *)this + 1);
      if (v17)
      {
        SanitizedURL((NSURL *)v17);
        v18 = objc_claimAutoreleasedReturnValue();
      }
      else
      {
        TFSInfo::Name(this, &v21);
        SanitizedStr(&v21);
        v18 = objc_claimAutoreleasedReturnValue();
      }
      v19 = (void *)v18;
      buf.st_dev = 138543362;
      *(_QWORD *)&buf.st_mode = v18;
      _os_log_impl(&dword_1CBC4A000, v16, OS_LOG_TYPE_ERROR, "Failed to get item count for dataless directory: %{public}@", (uint8_t *)&buf, 0xCu);

      if (v17)
      else
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
    }

    v9 = 0;
    v13 = 0;
  }
  return v13 & 0xFFFFFFFFFFFFFF00 | v9;
}

void sub_1CBCC60D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<NSPersonNameComponents * {__strong}>(uint64_t a1, id *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<NSPersonNameComponents * {__strong}>(*(id **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void TFSInfo::FolderStats(TFSInfo *this@<X0>, _BYTE *a2@<X8>)
{
  os_unfair_lock_s *v4;
  int v5;
  int v6;

  v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v5 & 0x10000000) != 0
    && *((_QWORD *)this + 10)
    && (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        v6 = *(_DWORD *)((char *)this + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v6 & 0x20) != 0))
  {
    TFSInfoOverflow::FolderSizeRecord(*((os_unfair_lock_s **)this + 10), (uint64_t)a2);
  }
  else
  {
    *a2 = 0;
    a2[32] = 0;
  }
  os_unfair_lock_unlock(v4);
}

void sub_1CBCC6334(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void **TFSInfo::SynchronizeVersionsForce(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  TString *v6;
  TString *v7;
  TString *v8;
  TString *v9;
  CFTypeRef v10;
  const void **v11;
  const void **v12;
  TString *v13;
  TString *v14;
  TString *v15;
  unsigned int v17;
  CFTypeRef cf;
  const __CFString *v19;
  CFTypeRef v20;
  CFTypeRef v21;
  CFTypeRef cf1;

  cf1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v21 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v20 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v19 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v6 = *(TString **)a1;
  if (*(_QWORD *)a1)
  {
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v6->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&cf1, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    v7 = *(TString **)a1;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v7[1].fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v21, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    v8 = *(TString **)a1;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v8[2].fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v20, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    v9 = *(TString **)a1;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v9[3].fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v19, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  else
  {
    std::make_unique[abi:ne180100]<TVersionData>((uint64_t *)&cf);
    v10 = cf;
    cf = 0;
    v11 = *(const void ***)a1;
    *(_QWORD *)a1 = v10;
    if (v11)
    {
      std::default_delete<TVersionData>::operator()[abi:ne180100](a1, v11);
      v12 = (const void **)cf;
      cf = 0;
      if (v12)
        std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&cf, v12);
    }
    *(_DWORD *)(a1 + 115) |= 0x20000000u;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  cf = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  if (!TFSInfo::GetShortVersion(*a2, &cf, 0) && !CFEqual(cf1, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (*(CFTypeRef **)a1 != &cf)
      TString::SetStringRefAsImmutable(*(TString **)a1, (TString *)cf);
    v17 = 1936225906;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v17, &v17);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
  if (!TFSInfo::GetLongVersion(*a2, (TString *)&cf, 0) && !CFEqual(v21, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v13 = (TString *)(*(_QWORD *)a1 + 8);
    if (v13 != (TString *)&cf)
      TString::SetStringRefAsImmutable(v13, (TString *)cf);
    v17 = 1986359923;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v17, &v17);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
  if (!TFSInfo::GetSystemVersion(*a2, (TString *)&cf, 0) && !CFEqual(v20, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v14 = (TString *)(*(_QWORD *)a1 + 16);
    if (v14 != (TString *)&cf)
      TString::SetStringRefAsImmutable(v14, (TString *)cf);
    v17 = 1937340018;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v17, &v17);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
  if (!TFSInfo::GetCopyrightString(*a2, (TString *)&cf, 0) && !CFEqual(v19, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v15 = (TString *)(*(_QWORD *)a1 + 24);
    if (v15 != (TString *)&cf)
      TString::SetStringRefAsImmutable(v15, (TString *)cf);
    v17 = 1668313715;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v17, &v17);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v20);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v21);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
}

void sub_1CBCC6734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14)
{
  os_unfair_lock_s *v14;

  os_unfair_lock_unlock(v14);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a14);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsDisconnectedDomain(TFSInfo *this, FPProviderDomain *a2)
{
  TFSInfo *v2;
  TFSInfo *v3;
  _BOOL8 v4;

  v2 = this;
  v3 = v2;
  if (v2)
    v4 = -[TFSInfo disconnectionState](v2, "disconnectionState") != 1;
  else
    v4 = 0;

  return v4;
}

void sub_1CBCC6844(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<__CFString const*>(uint64_t a1, CFTypeRef *a2)
{
  int v2;
  TString *v3;
  TString *v4;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_45;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_45;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_45;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_45;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_45;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_45;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_45;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_45;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_45;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_45;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_45;
      v3 = *(TString **)a1;
      v4 = (TString *)*a2;
      if ((TString *)v3->fString.fRef != v4)
        TString::SetStringRefAsImmutable(v3, v4);
      return 0;
    case 12:
      if (v2 != 12)
        goto LABEL_45;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(*(CFTypeRef **)a1, *a2);
      return 0;
    case 13:
      if (v2 != 13)
        goto LABEL_45;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_45;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_45;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_45;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_45;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_45;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_45;
      return TPropertyValue::SetAs<__CFString const*>(*(TString **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_45;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_45;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_45:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TFSInfo::GetIndex(TFSInfo *this)
{
  return 0xFFFFFFFFLL;
}

void NetworkRefreshCallback(TFSInfo *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  TNode *ConnectionState;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  os_unfair_lock_s *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  FINode *v26;
  char v27;
  uint64_t v28;
  os_unfair_lock_s *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  TNode *v34;
  const TNodePtr *v35;
  unsigned int v36;
  uint64_t v37;
  const TNode *v38;
  uint64_t v39;
  uint64_t v40;
  FINode **v41;
  TNode *v42;
  int v43;
  uint64_t v44;
  TNode *v45;
  int v46;
  uint64_t v47;
  FINode *v48;
  FINode *v49;
  FINode *v50;

  ConnectionState = (TNode *)SFNodeGetConnectionState();
  v10 = (int)ConnectionState;
  if (TNode::IsContextOpen(ConnectionState))
  {
    TNode::GetNWNode(a6, a2, (TNodePtr *)&v50);
    if (TNodeFromFINode(v50))
    {
LABEL_11:
      v12 = TNodeFromFINode(v50);
      if (!a1 || !v12)
        goto LABEL_47;
      v13 = TNodeFromFINode(v50);
      v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
      os_unfair_lock_lock(v14);
      v15 = *(std::__shared_weak_count **)(v13 + 24);
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          v17 = __ldxr(p_shared_owners);
        while (__stxr(v17 + 1, p_shared_owners));
        os_unfair_lock_unlock(v14);
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      else
      {
        os_unfair_lock_unlock(v14);
      }
      v19 = TNodeFromFINode(v50);
      v20 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v19);
      os_unfair_lock_lock(v20);
      v21 = *(std::__shared_weak_count **)(v19 + 24);
      if (v21)
      {
        v22 = (unint64_t *)&v21->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
        os_unfair_lock_unlock(v20);
        v24 = MEMORY[0x38];
        do
          v25 = __ldaxr(v22);
        while (__stlxr(v25 - 1, v22));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
        v26 = v50;
        if (v10 == v24)
          goto LABEL_29;
      }
      else
      {
        os_unfair_lock_unlock(v20);
        v26 = v50;
        if (v10 == MEMORY[0x38])
        {
LABEL_29:
          v27 = 1;
          goto LABEL_40;
        }
      }
      v28 = TNodeFromFINode(v26);
      v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
      os_unfair_lock_lock(v29);
      v30 = *(std::__shared_weak_count **)(v28 + 24);
      if (v30)
      {
        v31 = (unint64_t *)&v30->__shared_owners_;
        do
          v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
        os_unfair_lock_unlock(v29);
        MEMORY[0x38] = v10;
        do
          v33 = __ldaxr(v31);
        while (__stlxr(v33 - 1, v31));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      else
      {
        os_unfair_lock_unlock(v29);
        MEMORY[0x38] = v10;
      }
      v27 = 0;
      v26 = v50;
LABEL_40:
      v34 = (TNode *)TNodeFromFINode(v26);
      if (TNode::ClearInitialPopulationDeferred(v34))
        v36 = 20971520;
      else
        v36 = 0x1000000;
      if ((TGlobalNodes::IsNetworkNode((TGlobalNodes *)0x6D74726D, &v50, v35) & 1) != 0 || SFBrowserGetRootNode() != a2)
      {
        v37 = TNodeFromFINode(v50);
        TNode::HandleSync(v37, v36);
        if ((v27 & 1) != 0)
        {
LABEL_47:

          return;
        }
LABEL_46:
        v38 = (const TNode *)TNodeFromFINode(v50);
        TNode::SendNotification(v38, 2, (id *)&v50, 1853121395, 0);
        goto LABEL_47;
      }
      TNode::GetNetworkNode((TNode *)0x6E74776B, (void **)&v49);
      TNode::GetNetworkNode((TNode *)0x6E747362, (void **)&v48);
      v39 = TNodeFromFINode(v50);
      if (v39 == TNodeFromFINode(v49) || (v40 = TNodeFromFINode(v50), v40 == TNodeFromFINode(v48)))
      {
        v42 = (TNode *)TNodeFromFINode(v49);
        v43 = atomic_load((unsigned int *)TNode::GetNotifierList(v42));
        if (v43 >= 1)
        {
          v44 = TNodeFromFINode(v49);
          TNode::HandleSync(v44, v36);
        }
        v45 = (TNode *)TNodeFromFINode(v48);
        v46 = atomic_load((unsigned int *)TNode::GetNotifierList(v45));
        if (v46 < 1)
        {
LABEL_57:

          if ((v27 & 1) != 0)
            goto LABEL_47;
          goto LABEL_46;
        }
        v41 = &v48;
      }
      else
      {
        v41 = &v50;
      }
      v47 = TNodeFromFINode(*v41);
      TNode::HandleSync(v47, v36);
      goto LABEL_57;
    }
    v11 = TFSInfo::BrowserType(a1);
    switch(v11)
    {
      case 31:
        TGlobalNodes::NetworkNearbyNode(&v49);
        break;
      case 32:
        TGlobalNodes::NetworkSidebarNode(&v49);
        break;
      case 33:
        TGlobalNodes::AirDropNode(&v49);
        break;
      default:
LABEL_10:
        TNode::AddNWNode(a6, a2, &v50);
        goto LABEL_11;
    }
    TNodePtr::operator=((void **)&v50, (void **)&v49);

    goto LABEL_10;
  }
}

void sub_1CBCC6D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::BrowserType(TFSInfo *a1)
{
  os_unfair_lock_s *v2;
  unsigned int v3;
  uint64_t v4;

  v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  if ((TFSInfo *)TFSInfo::gAirDropBrowserRef == a1)
    v3 = 33;
  else
    v3 = 0;
  if ((TFSInfo *)TFSInfo::gNetworkNearbyBrowserRef == a1)
    v4 = 31;
  else
    v4 = v3;
  os_unfair_lock_unlock(v2);
  return v4;
}

CFTypeRef TFSInfo::CreateSFBrowser(int a1)
{
  const void *v1;
  CFTypeRef v2;
  CFTypeRef cf;

  cf = 0;
  if ((a1 - 31) >= 2)
  {
    if (a1 != 33)
      abort();
    cf = CreateSFBrowser(33);
    v1 = (const void *)TFSInfo::SetAirDropBrowserRef((TFSInfo *)cf);
  }
  else
  {
    cf = CreateSFBrowser(31);
    v1 = (const void *)TFSInfo::SetNetworkNearbyBrowserRef((TFSInfo *)cf);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(&cf, v1);
  v2 = cf;
  cf = 0;
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&cf);
  return v2;
}

void sub_1CBCC6F14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef CreateSFBrowser(int a1)
{
  uint64_t v2;
  const void *v3;
  CFTypeRef v4;
  void *v5;
  CFTypeRef v6;
  CFTypeRef cf;

  SFBrowserLock();
  os_unfair_lock_lock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  if ((a1 - 31) >= 3)
    abort();
  v2 = qword_1CBD131D0[(char)(a1 - 31)];
  SFBrowsers();
  v3 = *(const void **)(SFBrowsers(void)::browsers + 8 * v2);
  cf = v3;
  if (v3)
  {
    CFRetain(v3);
    v4 = cf;
  }
  else
  {
    cf = (CFTypeRef)SFBrowserCreate();
    if (cf)
    {
      SFBrowserSetClient();
      TFSVolumeInfo::GetDedicatedGCDQueue(a1);
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      SFBrowserSetDispatchQueue();

      v6 = cf;
    }
    else
    {
      v6 = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(SFBrowsers(void)::browsers + 8 * v2), v6);
    v4 = cf;
  }
  cf = 0;
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&cf);
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  return v4;
}

void sub_1CBCC7068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  va_list va;

  va_start(va, a6);

  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetNetworkNearbyBrowserRef(TFSInfo *a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  v3 = TFSInfo::gNetworkNearbyBrowserRef;
  if (!TFSInfo::gNetworkNearbyBrowserRef)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&TFSInfo::gNetworkNearbyBrowserRef, a1);
    v3 = TFSInfo::gNetworkNearbyBrowserRef;
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1CBCC7104(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetAirDropBrowserRef(TFSInfo *a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&TFSInfo::gAirDropBrowserRef, a1);
  v3 = TFSInfo::gAirDropBrowserRef;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1CBCC7164(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void *TFSInfo::CopySFBrowserRef(TFSInfo *this)
{
  _BOOL8 IsContextOpen;
  int v3;

  IsContextOpen = TNode::IsContextOpen((TNode *)this);
  if (!IsContextOpen)
    return 0;
  v3 = *((unsigned __int8 *)this + 112);
  if (v3 != 33)
  {
    if (v3 == 32 || v3 == 31)
      return TFSInfo::CopyNetworkNearbyBrowserRef((TFSInfo *)IsContextOpen);
    return 0;
  }
  return TFSInfo::CopyAirDropBrowserRef((TFSInfo *)IsContextOpen);
}

void sub_1CBCC7220(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetAliasIsBurnFolder(TFSInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;

  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v6 = *(_DWORD *)((char *)this + 115);
  v5 = (char *)this + 115;
  v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  v8 = (v7 >> 19) & 1;
  v9 = 0x80000;
  if (!a2)
    v9 = 0;
  v10 = v7 & 0xFFFFFFFFFFF7FFFFLL;
  *(_DWORD *)v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

void TFSInfo::SetTemporaryOriginatorInfo(uint64_t a1, void *a2)
{
  id v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  id v10;

  v4 = a2;
  if (v4)
  {
    v10 = v4;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v5 = *(_QWORD *)(a1 + 80);
    if (!v5)
    {
      TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
      v5 = *(_QWORD *)(a1 + 80);
      if (!v5)
        goto LABEL_16;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72));
    v6 = *(unsigned __int8 *)(v5 + 76);
    if (v6 == 3)
    {
      v6 = 2;
      *(_BYTE *)(v5 + 76) = 2;
      *(_QWORD *)v5 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72));
    if (v6 == 2)
    {
      if (!*(_QWORD *)v5)
        goto LABEL_15;
      goto LABEL_16;
    }
    v7 = *(_QWORD *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72));
    v8 = *(unsigned __int8 *)(v7 + 76);
    if (v8 == 2)
    {
      TFSInfoOverflow::MigrateToType(v7, 1);
      v8 = *(unsigned __int8 *)(v7 + 76);
    }
    else if (v8 == 3)
    {
      *(_BYTE *)(v7 + 76) = 1;
      *(_QWORD *)(v7 + 32) = 0;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)(v7 + 16) = 0u;
      *(_DWORD *)(v7 + 32) = 0x80000000;
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72));
LABEL_14:
      v9 = *(_QWORD *)(v7 + 16);
      v5 = v7 + 16;
      if (!v9)
LABEL_15:
        objc_storeStrong((id *)v5, a2);
LABEL_16:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
      v4 = v10;
      goto LABEL_17;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72));
    if (v8 != 1)
      goto LABEL_16;
    goto LABEL_14;
  }
LABEL_17:

}

void sub_1CBCC73E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

const void **TFSInfo::dCPath@<X0>(TFSInfo *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t v6;
  int v7;
  const __CFString *v8;
  __CFString *v9;
  TString v11;
  CFStringRef theString;
  TString v13;

  if (*((_BYTE *)this + 112)
    || (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        v6 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v6 & 0x100000000) != 0)
    || (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        v7 = *(_DWORD *)((char *)this + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v7 & 0x100) != 0))
  {
    if (a2)
      TFSInfo::DisplayName(this, &v13);
    else
      TFSInfo::GetDisplayNameWhileLocked(this, &v13);
    TString::Str(&v13, a3);
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    v8 = (const __CFString *)*((_QWORD *)this + 2);
    theString = v8;
    if (v8)
      CFRetain(v8);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    v9 = (__CFString *)CFURLCopyFileSystemPath((CFURLRef)v8, kCFURLPOSIXPathStyle);
    v13.fString.fRef = v9;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&theString);
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&theString, (TString *)v9);
    if (CFStringGetLength(theString))
    {
      TString::Str((TString *)&theString, a3);
    }
    else
    {
      if (a2)
        TFSInfo::Name(this, &v11);
      else
        TFSInfo::GetNameWhileLocked(this, &v11);
      TString::Str(&v11, a3);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    return TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v13.fString.fRef);
  }
}

void sub_1CBCC7590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<unsigned int>(uint64_t a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_45;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_45;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_45;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_45;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_45;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_45;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_45;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_45;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_45;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_45;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_45;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_45;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_45;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_45;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_45;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_45;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_45;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_45;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_45;
      return TPropertyValue::SetAs<unsigned int>(*(_DWORD **)a1, a2);
    case 20:
      if (v2 != 20)
        goto LABEL_45;
LABEL_41:
      result = 0;
      **(_DWORD **)a1 = *a2;
      return result;
    case 21:
      if (v2 == 21)
        return 4294959246;
      goto LABEL_45;
    case 22:
      if (v2 != 22)
        goto LABEL_45;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_45:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TPropertyReference::SetAs<int>(uint64_t a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      goto LABEL_41;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_47;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      result = 0;
      **(_QWORD **)a1 = (int)*a2;
      break;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      result = TPropertyValue::SetAs<int>(*(_DWORD **)a1, a2);
      break;
    case 20:
      if (v2 == 20)
        goto LABEL_41;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_47;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_41:
      result = 4294959246;
      break;
  }
  return result;
}

uint64_t TPropertyReference::SetAs<Point>(uint64_t a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      result = 0;
      **(_DWORD **)a1 = *a2;
      return result;
    case 9:
      if (v2 != 9)
        goto LABEL_43;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::SetAs<Point>(*(_DWORD **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void TFSInfoOverflow::SetIFSymbol(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  v4 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v3;

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 72));
}

_QWORD *std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,TNWNode&,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x58uLL);
  result = std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<TNWNode&,std::allocator<TNWNode>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCC7AE8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<TNWNode&,std::allocator<TNWNode>,0>(_QWORD *a1, uint64_t a2)
{
  a1[2] = 0;
  *a1 = &unk_1E87507D8;
  a1[1] = 0;
  TNWNode::TNWNode((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1CBCC7B34(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TNWNode>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87507D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TNWNode>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87507D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

const void **std::__shared_ptr_emplace<TNWNode>::__on_zero_shared(uint64_t a1)
{
  return std::__destroy_at[abi:ne180100]<TNWNode,0>(a1 + 24);
}

uint64_t TNWNode::TNWNode(uint64_t a1, uint64_t a2)
{
  const void *v4;
  int v5;

  v4 = *(const void **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  if (v4)
    CFRetain(v4);
  *(_QWORD *)(a1 + 8) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 8), *(TString **)(a2 + 8));
  *(_QWORD *)(a1 + 16) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 16), *(TString **)(a2 + 16));
  *(_QWORD *)(a1 + 24) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), *(TString **)(a2 + 24));
  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = *(id *)(a2 + 40);
  v5 = *(_DWORD *)(a2 + 55);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 55) = v5;
  return a1;
}

void sub_1CBCC7C64(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;
  const void **v3;
  const void **v4;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void sub_1CBCC7CA8()
{
  JUMPOUT(0x1CBCC7C98);
}

const void **std::__destroy_at[abi:ne180100]<TNWNode,0>(uint64_t a1)
{

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 8));
  return TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCC7E64(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCC7F24(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCC7FA0(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1CBCC8020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CFTypeRef *std::pair<TString,TString>::pair[abi:ne180100]<TString,TString,0>(CFTypeRef *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  *a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  a1[1] = *a3;
  *a3 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a3, &stru_1E8752DF8);
  return a1;
}

TString *std::pair<TString,TString>::pair[abi:ne180100]<NSString * {__strong},NSString * {__strong},0>(TString *a1, id *a2, id *a3)
{
  TString *v5;
  TString *v6;

  v5 = (TString *)*a2;
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, v5);

  v6 = (TString *)*a3;
  a1[1].fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1 + 1, v6);

  return a1;
}

void sub_1CBCC81A4(_Unwind_Exception *a1)
{
  const void **v1;
  void *v2;
  const void **v3;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

char *std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

TString *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString> const*,std::pair<TString,TString> const*,std::pair<TString,TString>*>(uint64_t a1, TString **a2, TString **a3, TString *a4)
{
  TString *v4;
  TString **v6;
  _QWORD v8[3];
  char v9;
  TString *v10;
  TString *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::pair<TString,TString>::pair[abi:ne180100](v4, v6);
      v6 += 2;
      v4 = v11 + 2;
      v11 += 2;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1CBCC82BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

TString *std::pair<TString,TString>::pair[abi:ne180100](TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1 + 1, a2[1]);
  return a1;
}

void sub_1CBCC8338(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>::operator()[abi:ne180100]((const void **)a1);
  return a1;
}

const void **std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>::operator()[abi:ne180100](const void **result)
{
  const void **v1;
  const void **v2;
  const void **v3;

  v1 = *(const void ***)result[2];
  v2 = *(const void ***)result[1];
  if (v1 != v2)
  {
    do
    {
      v3 = v1 - 2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1 - 1);
      result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
      v1 = v3;
    }
    while (v3 != v2);
  }
  return result;
}

void std::vector<std::pair<TString,TString>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<TString,TString>>::__base_destruct_at_end[abi:ne180100]((const void **)v2, (const void **)*v2);
    operator delete(**a1);
  }
}

const void **std::vector<std::pair<TString,TString>>::__base_destruct_at_end[abi:ne180100](const void **result, const void **a2)
{
  const void **v3;
  const void **v4;
  const void **v5;

  v3 = result;
  v4 = (const void **)result[1];
  if (v4 != a2)
  {
    do
    {
      v5 = v4 - 2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4 - 1);
      result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
      v4 = v5;
    }
    while (v5 != a2);
  }
  v3[1] = a2;
  return result;
}

TFileDescriptor *std::unique_ptr<TFileDescriptor>::reset[abi:ne180100](TFileDescriptor **a1, TFileDescriptor *a2)
{
  TFileDescriptor *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    TFileDescriptor::~TFileDescriptor(result);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPTag *>>::NSForwardIterator<NSArray<FPTag *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCC855C(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPTag *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCC85D8(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id TFSInfoOverflow::GetIFSymbol(TFSInfoOverflow *this)
{
  os_unfair_lock_s *v2;
  id v3;

  v2 = (os_unfair_lock_s *)((char *)this + 72);
  os_unfair_lock_lock((os_unfair_lock_t)this + 18);
  v3 = *((id *)this + 8);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t std::deque<TString>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    v5 = a1[4];
    v6 = &v2[v5 >> 9];
    v7 = (const void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (const void **)v8)
    {
      do
      {
        v7 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v7) + 1;
        if ((char *)v7 - (_BYTE *)*v6 == 4096)
        {
          v9 = (const void **)v6[1];
          ++v6;
          v7 = v9;
        }
      }
      while (v7 != (const void **)v8);
      v2 = (void **)a1[1];
      v3 = (void **)a1[2];
    }
  }
  *v4 = 0;
  v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v10 >> 3;
  if (v11 == 1)
  {
    v12 = 256;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_16;
    v12 = 512;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<TNodeEventPtr *>::~__split_buffer((uint64_t)a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>(_QWORD *a1, id *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **v11;
  uint64_t v12;
  unint64_t v13;

  v4 = objc_msgSend(*a2, "hash");
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = (unint64_t)v11[1];
      if (v13 == v6)
      {
        if ((std::equal_to<NSString * {__strong}>::operator()(v12, v11[2], *a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t std::equal_to<NSString * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;

  v4 = a2;
  v5 = a3;
  if (v4 == v5)
    v6 = 1;
  else
    v6 = objc_msgSend(v4, "isEqualToString:", v5);

  return v6;
}

void sub_1CBCC88A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  void *i;
  unint64_t v15;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v8 = objc_msgSend(*a2, "hash");
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = *(void **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<NSString * {__strong}>::operator()(a1 + 32, *((void **)i + 2), *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v9;
  *((_QWORD *)i + 2) = **a4;
  *((_QWORD *)i + 3) = 0;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)i = *v24;
LABEL_38:
    *v24 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v16;
  *v16 = i;
  *(_QWORD *)(v23 + 8 * v4) = v16;
  if (*(_QWORD *)i)
  {
    v25 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCC8B0C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::swap(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  v5 = *(void **)a2;
  *(_QWORD *)a2 = 0;
  v6 = *(void **)a1;
  *(_QWORD *)a1 = v5;
  if (v6)
    operator delete(v6);
  v7 = *(void **)a2;
  *(_QWORD *)a2 = v4;
  if (v7)
    operator delete(v7);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v9;
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(a1 + 24) = v12;
  *(_QWORD *)(a2 + 16) = v8;
  *(_QWORD *)(a2 + 24) = v11;
  v13 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = v13;
  if (*(_QWORD *)(a1 + 24))
  {
    v14 = *(_QWORD *)(a1 + 8);
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v15 >= v14)
        v15 %= v14;
    }
    else
    {
      v15 &= v14 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = a1 + 16;
  }
  if (v11)
  {
    v16 = *(_QWORD *)(a2 + 8);
    v17 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v17 >= v16)
        v17 %= v16;
    }
    else
    {
      v17 &= v16 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a2 + 8 * v17) = a2 + 16;
  }
}

