TString *TVersionData::TVersionData(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1 + 1, a2[1]);
  a1[2].fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1 + 2, a2[2]);
  a1[3].fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1 + 3, a2[3]);
  return a1;
}

void sub_1CBCC8DF8(_Unwind_Exception *a1)
{
  const void **v1;
  const void **v2;
  const void **v3;
  const void **v4;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,__SFNode *&,void>@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x58uLL);
  result = std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<__SFNode *&,std::allocator<TNWNode>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCC8E8C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<__SFNode *&,std::allocator<TNWNode>,0>(_QWORD *a1, _QWORD *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1E87507D8;
  TNWNode::TNWNode(a1 + 3, *a2);
  return a1;
}

void sub_1CBCC8EDC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  char *v2;
  uint64_t result;

  v2 = (char *)operator new(0x98uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI7TFSInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_1CBCC8F24(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI7TFSInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24));
  return a1;
}

void sub_1CBCC8F94(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo const&,void>@<X0>(const TFSInfo *a1@<X1>, _QWORD *a2@<X8>)
{
  char *v4;
  uint64_t result;

  v4 = (char *)operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo const&,std::allocator<TFSInfo>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1CBCC8FEC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo const&,std::allocator<TFSInfo>,0>(uint64_t a1, const TFSInfo *a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), a2);
  return a1;
}

void sub_1CBCC9038(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

const void **TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::__shared_ptr_emplace<NSURL * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NSURL * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750928;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<NSURL * {__strong}>::__on_zero_shared(uint64_t a1)
{

}

uint64_t *TPropertyReference::As<double>(uint64_t *result, uint64_t **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 2);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_43;
      result = *a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      goto LABEL_41;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_41;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      goto LABEL_41;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      result = *(uint64_t **)*result;
      break;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      result = TPropertyValue::As<double>((uint64_t *)*result, a2);
      break;
    case 20:
      if (v2 == 20)
        goto LABEL_41;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_41;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_41;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_41:
      result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *TPropertyValue::As<double>(uint64_t *result, uint64_t **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_23;
      result = *a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_23;
      goto LABEL_19;
    case 2:
      if (v2 != 2)
        goto LABEL_23;
      goto LABEL_19;
    case 3:
      if (v2 != 3)
        goto LABEL_23;
      goto LABEL_19;
    case 4:
      if (v2 != 4)
        goto LABEL_23;
      goto LABEL_19;
    case 5:
      if (v2 != 5)
        goto LABEL_23;
      goto LABEL_19;
    case 6:
      if (v2 != 6)
        goto LABEL_23;
      goto LABEL_19;
    case 7:
      if (v2 != 7)
        goto LABEL_23;
      result = (uint64_t *)*result;
      break;
    case 8:
      if (v2 == 8)
        goto LABEL_19;
      goto LABEL_23;
    case 9:
      goto LABEL_19;
    case 10:
      if (v2 != 10)
        goto LABEL_23;
      goto LABEL_19;
    case 11:
      if (v2 != 11)
        goto LABEL_23;
      goto LABEL_19;
    case 12:
      if (v2 != 12)
        goto LABEL_23;
      goto LABEL_19;
    case 13:
      if (v2 != 13)
        goto LABEL_23;
      goto LABEL_19;
    case 14:
      if (v2 != 14)
        goto LABEL_23;
      goto LABEL_19;
    case 15:
      if (v2 != 15)
        goto LABEL_23;
      goto LABEL_19;
    case 16:
      if (v2 != 16)
        goto LABEL_23;
      goto LABEL_19;
    case 17:
      if (v2 != 17)
        goto LABEL_23;
      goto LABEL_19;
    case 18:
      if (v2 != 18)
        goto LABEL_23;
      goto LABEL_19;
    case 19:
      if (v2 != 19)
        goto LABEL_23;
      goto LABEL_19;
    case 20:
      if (v2 != 20)
        goto LABEL_23;
      goto LABEL_19;
    case 21:
      if (v2 != 21)
        goto LABEL_23;
      goto LABEL_19;
    case 22:
      if (v2 != 22)
        goto LABEL_23;
      goto LABEL_19;
    case 23:
      if (v2 != 23)
LABEL_23:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_19:
      result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

unint64_t TPropertyReference::As<unsigned int>(unint64_t a1, unsigned int *a2)
{
  int v2;
  unint64_t v3;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_47;
      LODWORD(a1) = *a2;
      v3 = 0xFFFFE07800000000;
      return v3 | a1;
    case 1:
      if (v2 != 1)
        goto LABEL_47;
      goto LABEL_44;
    case 2:
      if (v2 != 2)
        goto LABEL_47;
      goto LABEL_44;
    case 3:
      if (v2 != 3)
        goto LABEL_47;
      goto LABEL_44;
    case 4:
      if (v2 != 4)
        goto LABEL_47;
      goto LABEL_44;
    case 5:
      if (v2 != 5)
        goto LABEL_47;
      goto LABEL_44;
    case 6:
      if (v2 != 6)
        goto LABEL_47;
      goto LABEL_42;
    case 7:
      if (v2 != 7)
        goto LABEL_47;
      goto LABEL_44;
    case 8:
      if (v2 != 8)
        goto LABEL_47;
      goto LABEL_44;
    case 9:
      goto LABEL_44;
    case 10:
      if (v2 != 10)
        goto LABEL_47;
      goto LABEL_44;
    case 11:
      if (v2 != 11)
        goto LABEL_47;
      goto LABEL_44;
    case 12:
      if (v2 != 12)
        goto LABEL_47;
      goto LABEL_44;
    case 13:
      if (v2 != 13)
        goto LABEL_47;
      goto LABEL_44;
    case 14:
      if (v2 != 14)
        goto LABEL_47;
      goto LABEL_44;
    case 15:
      if (v2 != 15)
        goto LABEL_47;
      goto LABEL_44;
    case 16:
      if (v2 != 16)
        goto LABEL_47;
      goto LABEL_44;
    case 17:
      if (v2 != 17)
        goto LABEL_47;
      goto LABEL_44;
    case 18:
      if (v2 != 18)
        goto LABEL_47;
      goto LABEL_44;
    case 19:
      if (v2 != 19)
        goto LABEL_47;
      a1 = TPropertyValue::As<unsigned int>(*(unsigned int **)a1, a2);
      v3 = a1 & 0xFFFFFFFF00000000;
      return v3 | a1;
    case 20:
      if (v2 != 20)
        goto LABEL_47;
LABEL_42:
      v3 = 0;
      LODWORD(a1) = **(_DWORD **)a1;
      break;
    case 21:
      if (v2 == 21)
        goto LABEL_44;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_47;
      goto LABEL_44;
    case 23:
      if (v2 != 23)
LABEL_47:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_44:
      v3 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      break;
    default:
      v3 = 0xFFFFFFFF00000000;
      break;
  }
  return v3 | a1;
}

unint64_t TPropertyValue::As<unsigned int>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unint64_t v4;

  v2 = a1[4];
  v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_47;
      v3 = *a2;
      v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1)
        goto LABEL_47;
      goto LABEL_44;
    case 2:
      if (v2 != 2)
        goto LABEL_47;
      goto LABEL_44;
    case 3:
      if (v2 != 3)
        goto LABEL_47;
      goto LABEL_44;
    case 4:
      if (v2 != 4)
        goto LABEL_47;
      goto LABEL_44;
    case 5:
      if (v2 != 5)
        goto LABEL_47;
      goto LABEL_44;
    case 6:
      if (v2 != 6)
        goto LABEL_47;
      goto LABEL_42;
    case 7:
      if (v2 != 7)
        goto LABEL_47;
      goto LABEL_44;
    case 8:
      if (v2 != 8)
        goto LABEL_47;
      goto LABEL_44;
    case 9:
      goto LABEL_44;
    case 10:
      if (v2 != 10)
        goto LABEL_47;
      goto LABEL_44;
    case 11:
      if (v2 != 11)
        goto LABEL_47;
      goto LABEL_44;
    case 12:
      if (v2 != 12)
        goto LABEL_47;
      goto LABEL_44;
    case 13:
      if (v2 != 13)
        goto LABEL_47;
      goto LABEL_44;
    case 14:
      if (v2 != 14)
        goto LABEL_47;
      goto LABEL_44;
    case 15:
      if (v2 != 15)
        goto LABEL_47;
      goto LABEL_44;
    case 16:
      if (v2 != 16)
        goto LABEL_47;
      goto LABEL_44;
    case 17:
      if (v2 != 17)
        goto LABEL_47;
      goto LABEL_44;
    case 18:
      if (v2 != 18)
        goto LABEL_47;
      goto LABEL_44;
    case 19:
      if (v2 != 19)
        goto LABEL_47;
      goto LABEL_44;
    case 20:
      if (v2 != 20)
        goto LABEL_47;
LABEL_42:
      v4 = 0;
      v3 = *a1;
      break;
    case 21:
      if (v2 == 21)
        goto LABEL_44;
      goto LABEL_47;
    case 22:
      if (v2 != 22)
        goto LABEL_47;
      goto LABEL_44;
    case 23:
      if (v2 != 23)
LABEL_47:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_44:
      v4 = 0xFFFFE08E00000000;
      v3 = *a2;
      break;
    default:
      v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

unint64_t TPropertyReference::As<BOOL>(unint64_t a1, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;
  unint64_t v4;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_47;
      v3 = 0xE07800000000;
      goto LABEL_44;
    case 1:
      if (v2 != 1)
        goto LABEL_47;
      v4 = 0;
      LODWORD(a1) = **(unsigned __int8 **)a1;
      return v4 | a1;
    case 2:
      if (v2 != 2)
        goto LABEL_47;
      goto LABEL_43;
    case 3:
      if (v2 != 3)
        goto LABEL_47;
      goto LABEL_43;
    case 4:
      if (v2 != 4)
        goto LABEL_47;
      goto LABEL_43;
    case 5:
      if (v2 != 5)
        goto LABEL_47;
      goto LABEL_43;
    case 6:
      if (v2 != 6)
        goto LABEL_47;
      goto LABEL_43;
    case 7:
      if (v2 != 7)
        goto LABEL_47;
      goto LABEL_43;
    case 8:
      if (v2 != 8)
        goto LABEL_47;
      goto LABEL_43;
    case 9:
      v4 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      return v4 | a1;
    case 10:
      if (v2 != 10)
        goto LABEL_47;
      goto LABEL_43;
    case 11:
      if (v2 != 11)
        goto LABEL_47;
      goto LABEL_43;
    case 12:
      if (v2 != 12)
        goto LABEL_47;
      goto LABEL_43;
    case 13:
      if (v2 != 13)
        goto LABEL_47;
      goto LABEL_43;
    case 14:
      if (v2 != 14)
        goto LABEL_47;
      goto LABEL_43;
    case 15:
      if (v2 != 15)
        goto LABEL_47;
      goto LABEL_43;
    case 16:
      if (v2 != 16)
        goto LABEL_47;
      goto LABEL_43;
    case 17:
      if (v2 != 17)
        goto LABEL_47;
      goto LABEL_43;
    case 18:
      if (v2 != 18)
        goto LABEL_47;
      goto LABEL_43;
    case 19:
      if (v2 != 19)
        goto LABEL_47;
      a1 = TPropertyValue::As<BOOL>(*(unsigned __int8 **)a1, a2);
      v4 = a1 & 0xFFFFFFFF00000000;
      return v4 | a1;
    case 20:
      if (v2 == 20)
        goto LABEL_43;
      goto LABEL_47;
    case 21:
      if (v2 != 21)
        goto LABEL_47;
      goto LABEL_43;
    case 22:
      if (v2 != 22)
        goto LABEL_47;
      goto LABEL_43;
    case 23:
      if (v2 != 23)
LABEL_47:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_43:
      v3 = 0xE08E00000000;
LABEL_44:
      v4 = v3 & 0xFFFFFFFFFFFFLL | 0xFFFF000000000000;
      LODWORD(a1) = *a2 | v4;
      break;
    default:
      LODWORD(a1) = 0;
      v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | a1;
}

unint64_t TPropertyValue::As<BOOL>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  unint64_t v5;

  v2 = *((_DWORD *)a1 + 4);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_12;
      v3 = 0xE07800000000;
      goto LABEL_9;
    case 1:
      if (v2 != 1)
        goto LABEL_12;
      v5 = 0;
      v4 = *a1;
      return v5 | v4;
    case 2:
      if (v2 == 2)
        goto LABEL_8;
      goto LABEL_12;
    case 3:
      if (v2 != 3)
        goto LABEL_12;
      goto LABEL_8;
    case 4:
      if (v2 != 4)
        goto LABEL_12;
      goto LABEL_8;
    case 5:
      if (v2 != 5)
        goto LABEL_12;
      goto LABEL_8;
    case 6:
      if (v2 != 6)
        goto LABEL_12;
      goto LABEL_8;
    case 7:
      if (v2 != 7)
        goto LABEL_12;
      goto LABEL_8;
    case 8:
      if (v2 != 8)
        goto LABEL_12;
      goto LABEL_8;
    case 9:
      v5 = 0xFFFFE08E00000000;
      v4 = *a2;
      return v5 | v4;
    case 10:
      if (v2 != 10)
        goto LABEL_12;
      goto LABEL_8;
    case 11:
      if (v2 != 11)
        goto LABEL_12;
      goto LABEL_8;
    case 12:
      if (v2 != 12)
        goto LABEL_12;
      goto LABEL_8;
    case 13:
      if (v2 != 13)
        goto LABEL_12;
      goto LABEL_8;
    case 14:
      if (v2 != 14)
        goto LABEL_12;
      goto LABEL_8;
    case 15:
      if (v2 != 15)
        goto LABEL_12;
      goto LABEL_8;
    case 16:
      if (v2 != 16)
        goto LABEL_12;
      goto LABEL_8;
    case 17:
      if (v2 != 17)
        goto LABEL_12;
      goto LABEL_8;
    case 18:
      if (v2 != 18)
        goto LABEL_12;
      goto LABEL_8;
    case 19:
      if (v2 != 19)
        goto LABEL_12;
      goto LABEL_8;
    case 20:
      if (v2 != 20)
        goto LABEL_12;
      goto LABEL_8;
    case 21:
      if (v2 != 21)
        goto LABEL_12;
      goto LABEL_8;
    case 22:
      if (v2 != 22)
        goto LABEL_12;
      goto LABEL_8;
    case 23:
      if (v2 != 23)
LABEL_12:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_8:
      v3 = 0xE08E00000000;
LABEL_9:
      v5 = v3 & 0xFFFFFFFFFFFFLL | 0xFFFF000000000000;
      v4 = *a2 | v5;
      break;
    default:
      v4 = 0;
      v5 = 0xFFFFFFFF00000000;
      break;
  }
  return v5 | v4;
}

unint64_t TPropertyReference::As<int>(unint64_t a1, unsigned int *a2)
{
  int v2;
  unint64_t v3;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_50;
      LODWORD(a1) = *a2;
      v3 = 0xFFFFE07800000000;
      return v3 | a1;
    case 1:
      if (v2 != 1)
        goto LABEL_50;
      goto LABEL_48;
    case 2:
      if (v2 != 2)
        goto LABEL_50;
      goto LABEL_48;
    case 3:
      if (v2 != 3)
        goto LABEL_50;
      goto LABEL_48;
    case 4:
      if (v2 != 4)
        goto LABEL_50;
      goto LABEL_46;
    case 5:
      if (v2 != 5)
        goto LABEL_50;
      goto LABEL_48;
    case 6:
      if (v2 != 6)
        goto LABEL_50;
      goto LABEL_48;
    case 7:
      if (v2 != 7)
        goto LABEL_50;
      goto LABEL_48;
    case 8:
      if (v2 != 8)
        goto LABEL_50;
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10)
        goto LABEL_50;
      goto LABEL_48;
    case 11:
      if (v2 != 11)
        goto LABEL_50;
      goto LABEL_48;
    case 12:
      if (v2 != 12)
        goto LABEL_50;
      goto LABEL_48;
    case 13:
      if (v2 != 13)
        goto LABEL_50;
      goto LABEL_48;
    case 14:
      if (v2 != 14)
        goto LABEL_50;
      goto LABEL_48;
    case 15:
      if (v2 != 15)
        goto LABEL_50;
      goto LABEL_48;
    case 16:
      if (v2 != 16)
        goto LABEL_50;
      goto LABEL_48;
    case 17:
      if (v2 != 17)
        goto LABEL_50;
      goto LABEL_48;
    case 18:
      if (v2 != 18)
        goto LABEL_50;
      goto LABEL_48;
    case 19:
      if (v2 != 19)
        goto LABEL_50;
      a1 = TPropertyValue::As<int>(*(unsigned int **)a1, a2);
      v3 = a1 & 0xFFFFFFFF00000000;
      return v3 | a1;
    case 20:
      if (v2 != 20)
        goto LABEL_50;
      goto LABEL_48;
    case 21:
      if (v2 != 21)
        goto LABEL_50;
      goto LABEL_48;
    case 22:
      if (v2 != 22)
        goto LABEL_50;
LABEL_46:
      v3 = 0;
      LODWORD(a1) = **(_DWORD **)a1;
      break;
    case 23:
      if (v2 != 23)
LABEL_50:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      v3 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      break;
    default:
      v3 = 0xFFFFFFFF00000000;
      break;
  }
  return v3 | a1;
}

unint64_t TPropertyReference::As<short>(unint64_t a1, unsigned __int16 *a2)
{
  int v2;
  unint64_t v3;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_50;
      LODWORD(a1) = *a2;
      v3 = 0xFFFFE07800000000;
      return v3 | a1;
    case 1:
      if (v2 != 1)
        goto LABEL_50;
      goto LABEL_48;
    case 2:
      if (v2 != 2)
        goto LABEL_50;
      goto LABEL_48;
    case 3:
      if (v2 != 3)
        goto LABEL_50;
      goto LABEL_46;
    case 4:
      if (v2 != 4)
        goto LABEL_50;
      goto LABEL_46;
    case 5:
      if (v2 != 5)
        goto LABEL_50;
      goto LABEL_48;
    case 6:
      if (v2 != 6)
        goto LABEL_50;
      goto LABEL_48;
    case 7:
      if (v2 != 7)
        goto LABEL_50;
      goto LABEL_48;
    case 8:
      if (v2 != 8)
        goto LABEL_50;
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10)
        goto LABEL_50;
      goto LABEL_48;
    case 11:
      if (v2 != 11)
        goto LABEL_50;
      goto LABEL_48;
    case 12:
      if (v2 != 12)
        goto LABEL_50;
      goto LABEL_48;
    case 13:
      if (v2 != 13)
        goto LABEL_50;
      goto LABEL_48;
    case 14:
      if (v2 != 14)
        goto LABEL_50;
      goto LABEL_48;
    case 15:
      if (v2 != 15)
        goto LABEL_50;
      goto LABEL_48;
    case 16:
      if (v2 != 16)
        goto LABEL_50;
      goto LABEL_48;
    case 17:
      if (v2 != 17)
        goto LABEL_50;
      goto LABEL_48;
    case 18:
      if (v2 != 18)
        goto LABEL_50;
      goto LABEL_48;
    case 19:
      if (v2 != 19)
        goto LABEL_50;
      a1 = TPropertyValue::As<short>(*(unsigned __int16 **)a1, a2);
      v3 = a1 & 0xFFFFFFFF00000000;
      return v3 | a1;
    case 20:
      if (v2 != 20)
        goto LABEL_50;
      goto LABEL_48;
    case 21:
      if (v2 != 21)
        goto LABEL_50;
      goto LABEL_48;
    case 22:
      if (v2 != 22)
        goto LABEL_50;
LABEL_46:
      v3 = 0;
      LODWORD(a1) = **(unsigned __int16 **)a1;
      break;
    case 23:
      if (v2 != 23)
LABEL_50:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      v3 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      break;
    default:
      v3 = 0xFFFFFFFF00000000;
      break;
  }
  return v3 | a1;
}

unint64_t TPropertyValue::As<short>(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2;
  unsigned int v3;
  unint64_t v4;

  v2 = *((_DWORD *)a1 + 4);
  v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_50;
      v3 = *a2;
      v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1)
        goto LABEL_50;
      goto LABEL_48;
    case 2:
      if (v2 != 2)
        goto LABEL_50;
      goto LABEL_48;
    case 3:
      if (v2 != 3)
        goto LABEL_50;
      goto LABEL_46;
    case 4:
      if (v2 != 4)
        goto LABEL_50;
      goto LABEL_46;
    case 5:
      if (v2 != 5)
        goto LABEL_50;
      goto LABEL_48;
    case 6:
      if (v2 != 6)
        goto LABEL_50;
      goto LABEL_48;
    case 7:
      if (v2 != 7)
        goto LABEL_50;
      goto LABEL_48;
    case 8:
      if (v2 != 8)
        goto LABEL_50;
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10)
        goto LABEL_50;
      goto LABEL_48;
    case 11:
      if (v2 != 11)
        goto LABEL_50;
      goto LABEL_48;
    case 12:
      if (v2 != 12)
        goto LABEL_50;
      goto LABEL_48;
    case 13:
      if (v2 != 13)
        goto LABEL_50;
      goto LABEL_48;
    case 14:
      if (v2 != 14)
        goto LABEL_50;
      goto LABEL_48;
    case 15:
      if (v2 != 15)
        goto LABEL_50;
      goto LABEL_48;
    case 16:
      if (v2 != 16)
        goto LABEL_50;
      goto LABEL_48;
    case 17:
      if (v2 != 17)
        goto LABEL_50;
      goto LABEL_48;
    case 18:
      if (v2 != 18)
        goto LABEL_50;
      goto LABEL_48;
    case 19:
      if (v2 != 19)
        goto LABEL_50;
      goto LABEL_48;
    case 20:
      if (v2 != 20)
        goto LABEL_50;
      goto LABEL_48;
    case 21:
      if (v2 != 21)
        goto LABEL_50;
      goto LABEL_48;
    case 22:
      if (v2 != 22)
        goto LABEL_50;
LABEL_46:
      v4 = 0;
      v3 = *a1;
      break;
    case 23:
      if (v2 != 23)
LABEL_50:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      v4 = 0xFFFFE08E00000000;
      v3 = *a2;
      break;
    default:
      v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

uint64_t TPropertyValue::SetAs<ISIcon * {__strong}>(id *location, id *a2)
{
  int v2;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},ISIcon * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},ISIcon * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
    objc_storeStrong(location, *a3);
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,ISIcon * const {__strong}&>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,ISIcon * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E8752718[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

uint64_t TPropertyValue::SetAs<IFSymbol * {__strong}>(id *location, id *a2)
{
  int v2;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},IFSymbol * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},IFSymbol * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
    objc_storeStrong(location, *a3);
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,IFSymbol * const {__strong}&>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,IFSymbol * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E8752718[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

const void **TAutoRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

_OWORD *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__emplace_unique_key_args<std::pair<__SFBrowser *,__SFNode *>,std::piecewise_construct_t const&,std::tuple<std::pair<__SFBrowser *,__SFNode *>&&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  uint64_t v10;

  v6 = (void **)std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__find_equal<std::pair<__SFBrowser *,__SFNode *>>((uint64_t)a1, &v10, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((_DWORD *)v7 + 12) = 0;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__find_equal<std::pair<__SFBrowser *,__SFNode *>>(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  char v10;
  unint64_t v11;
  BOOL v12;
  char v13;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    v7 = a3[1];
    while (1)
    {
      v8 = v4;
      v9 = v4[4];
      if (v6 == v9)
      {
        v11 = v8[5];
        if (v7 < v11)
          goto LABEL_11;
        v12 = v11 == v7;
        if (v11 >= v7)
          v13 = 1;
        else
          v13 = -1;
        if (v12)
          v13 = 0;
        if ((v13 & 0x80) == 0)
          goto LABEL_22;
LABEL_19:
        result = v8 + 1;
        v4 = (_QWORD *)v8[1];
        if (!v4)
          goto LABEL_22;
      }
      else
      {
        if (v6 >= v9)
        {
          if (v9 >= v6)
            v10 = 1;
          else
            v10 = -1;
          if ((v10 & 0x80) == 0)
            goto LABEL_22;
          goto LABEL_19;
        }
LABEL_11:
        v4 = (_QWORD *)*v8;
        result = v8;
        if (!*v8)
          goto LABEL_22;
      }
    }
  }
  v8 = result;
LABEL_22:
  *a2 = v8;
  return result;
}

_QWORD *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::find<std::pair<__SFBrowser *,__SFNode *>>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v3;
  _QWORD *result;
  unint64_t v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  BOOL v10;
  char v11;

  v3 = (_QWORD *)(a1 + 8);
  result = std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__lower_bound<std::pair<__SFBrowser *,__SFNode *>>(a1, a2, *(_QWORD **)(a1 + 8), (_QWORD *)(a1 + 8));
  if (v3 == result)
    return v3;
  v5 = result[4];
  if (*a2 >= v5)
    v6 = 1;
  else
    v6 = -1;
  if (*a2 != v5)
  {
    if ((v6 & 0x80) == 0)
      return result;
    return v3;
  }
  v7 = a2[1];
  v8 = result[5];
  v9 = v7 >= v8;
  v10 = v7 == v8;
  v11 = -1;
  if (v9)
    v11 = 1;
  if (v10)
    v11 = 0;
  if (v11 < 0)
    return v3;
  return result;
}

_QWORD *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__lower_bound<std::pair<__SFBrowser *,__SFNode *>>(uint64_t a1, unint64_t *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  char v9;
  unint64_t v10;
  BOOL v11;
  BOOL v12;
  _QWORD *v13;

  result = a4;
  if (a3)
  {
    v5 = *a2;
    v6 = a2[1];
    do
    {
      v7 = a3[4];
      v8 = v7 == v5;
      if (v7 >= v5)
        v9 = 1;
      else
        v9 = -1;
      if (v8)
      {
        v10 = a3[5];
        v11 = v10 == v6;
        v9 = v10 >= v6 ? 1 : -1;
        if (v11)
          v9 = 0;
      }
      v12 = (v9 & 0x80) == 0;
      if (v9 < 0)
        v13 = a3 + 1;
      else
        v13 = a3;
      if (v12)
        result = a3;
      a3 = (_QWORD *)*v13;
    }
    while (*v13);
  }
  return result;
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,__SFNode *&,void>@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,__SFNode *&,std::allocator<TFSInfo>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1CBCCA534(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,__SFNode *&,std::allocator<TFSInfo>,0>(_QWORD *a1, char *a2, uint64_t *a3)
{
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  a1[1] = 0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1CBCCA588(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t *TPropertyReference::As<__CFArray const*>(uint64_t *result, uint64_t **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 2);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_43;
      result = *a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      goto LABEL_41;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_41;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      goto LABEL_41;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      goto LABEL_41;
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      result = *(uint64_t **)*result;
      break;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      result = TPropertyValue::As<__CFArray const*>((uint64_t *)*result, a2);
      break;
    case 20:
      if (v2 == 20)
        goto LABEL_41;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_41;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_41;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_41:
      result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *TPropertyValue::As<__CFArray const*>(uint64_t *result, uint64_t **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_37;
      result = *a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_37;
      goto LABEL_39;
    case 2:
      if (v2 != 2)
        goto LABEL_37;
      goto LABEL_39;
    case 3:
      if (v2 != 3)
        goto LABEL_37;
      goto LABEL_39;
    case 4:
      if (v2 != 4)
        goto LABEL_37;
      goto LABEL_39;
    case 5:
      if (v2 != 5)
        goto LABEL_37;
      goto LABEL_39;
    case 6:
      if (v2 != 6)
        goto LABEL_37;
      goto LABEL_39;
    case 7:
      if (v2 != 7)
        goto LABEL_37;
      goto LABEL_39;
    case 8:
      if (v2 != 8)
        goto LABEL_37;
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10)
        goto LABEL_37;
      goto LABEL_39;
    case 11:
      if (v2 != 11)
        goto LABEL_37;
      goto LABEL_39;
    case 12:
      if (v2 != 12)
        goto LABEL_37;
      goto LABEL_39;
    case 13:
      if (v2 != 13)
        goto LABEL_37;
      goto LABEL_39;
    case 14:
      if (v2 != 14)
        goto LABEL_37;
      goto LABEL_39;
    case 15:
      if (v2 != 15)
        goto LABEL_37;
      goto LABEL_39;
    case 16:
      if (v2 != 16)
        goto LABEL_37;
      goto LABEL_39;
    case 17:
      if (v2 != 17)
        goto LABEL_37;
      result = (uint64_t *)*result;
      break;
    case 18:
      if (v2 != 18)
        goto LABEL_37;
      goto LABEL_39;
    case 19:
      if (v2 == 19)
        goto LABEL_39;
      goto LABEL_37;
    case 20:
      if (v2 != 20)
        goto LABEL_37;
      goto LABEL_39;
    case 21:
      if (v2 != 21)
        goto LABEL_37;
      goto LABEL_39;
    case 22:
      if (v2 != 22)
        goto LABEL_37;
      goto LABEL_39;
    case 23:
      if (v2 != 23)
LABEL_37:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<NSPersonNameComponents * {__strong}>(id *location, id *a2)
{
  int v2;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSPersonNameComponents * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_33;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_33;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_33;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_33;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_33;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_33;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_33;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_33;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_33;
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_33;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_33;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_33;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_33;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_33;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_33;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_33;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_33;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_33;
    case 20:
      if (v2 != 20)
        goto LABEL_33;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_33;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_33;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_33:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSPersonNameComponents * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
    objc_storeStrong(location, *a3);
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSPersonNameComponents * const {__strong}&>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSPersonNameComponents * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E8752718[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

uint64_t TPropertyValue::SetAs<__CFArray const*>(uint64_t a1, CFTypeRef *a2)
{
  int v2;
  CFTypeRef v4;
  const void *v6;

  v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      v4 = *a2;
      v6 = v4;
      if (v4)
        CFRetain(v4);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(a1, (const void **)a1, &v6);
      TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v6);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_39;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_39;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_39;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_39;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_39;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_39;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_39;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_39;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_39;
      return 4294959246;
    case 11:
      if (v2 != 11)
        goto LABEL_39;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_39;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_39;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_39;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_39;
      return 4294959246;
    case 16:
      if (v2 != 16)
        goto LABEL_39;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_39;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 18:
      if (v2 != 18)
        goto LABEL_39;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_39;
    case 20:
      if (v2 != 20)
        goto LABEL_39;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_39;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_39;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_39:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::NSForwardIterator<NSArray<FPItemDecoration *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCCACC4(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCCAD40(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::SetAs<__CFString const*>(TString *this, CFTypeRef *a2)
{
  int fRef;
  CFTypeRef v4;
  TString *v5;
  const void *v7;

  fRef = (int)this[2].fString.fRef;
  switch((char)fRef)
  {
    case 0:
      v4 = *a2;
      v7 = v4;
      if (v4)
        CFRetain(v4);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>((uint64_t)this, (const void **)&this->fString.fRef, &v7);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v7);
      return 0;
    case 1:
      if (fRef != 1)
        goto LABEL_24;
      return 4294959246;
    case 2:
      if (fRef != 2)
        goto LABEL_24;
      return 4294959246;
    case 3:
      if (fRef != 3)
        goto LABEL_24;
      return 4294959246;
    case 4:
      if (fRef != 4)
        goto LABEL_24;
      return 4294959246;
    case 5:
      if (fRef != 5)
        goto LABEL_24;
      return 4294959246;
    case 6:
      if (fRef != 6)
        goto LABEL_24;
      return 4294959246;
    case 7:
      if (fRef != 7)
        goto LABEL_24;
      return 4294959246;
    case 8:
      if (fRef != 8)
        goto LABEL_24;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (fRef != 10)
        goto LABEL_24;
      return 4294959246;
    case 11:
      if (fRef != 11)
        goto LABEL_24;
      v5 = (TString *)*a2;
      if ((TString *)this->fString.fRef != v5)
        TString::SetStringRefAsImmutable(this, v5);
      return 0;
    case 12:
      if (fRef != 12)
        goto LABEL_24;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, *a2);
      return 0;
    case 13:
      if (fRef != 13)
        goto LABEL_24;
      return 4294959246;
    case 14:
      if (fRef == 14)
        return 4294959246;
      goto LABEL_24;
    case 15:
      if (fRef != 15)
        goto LABEL_24;
      return 4294959246;
    case 16:
      if (fRef != 16)
        goto LABEL_24;
      return 4294959246;
    case 17:
      if (fRef != 17)
        goto LABEL_24;
      return 4294959246;
    case 18:
      if (fRef != 18)
        goto LABEL_24;
      return 4294959246;
    case 19:
      if (fRef != 19)
        goto LABEL_24;
      return 4294959246;
    case 20:
      if (fRef != 20)
        goto LABEL_24;
      return 4294959246;
    case 21:
      if (fRef != 21)
        goto LABEL_24;
      return 4294959246;
    case 22:
      if (fRef != 22)
        goto LABEL_24;
      return 4294959246;
    case 23:
      if (fRef != 23)
LABEL_24:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},UTType * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
    objc_storeStrong(location, *a3);
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,UTType * const {__strong}&>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,UTType * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E8752718[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},SYDocumentAttributes * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
    objc_storeStrong(location, *a3);
  else
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,SYDocumentAttributes * const {__strong}&>(a1, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,SYDocumentAttributes * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  char v6;

  v4 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v4 != -1)
    ((void (*)(char *, uint64_t))off_1E8752718[v4])(&v6, a1);
  *(_DWORD *)(a1 + 16) = -1;
  *(_QWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void sub_1CBCCB094(_Unwind_Exception *a1)
{
  std::mutex::unlock(&PresentationNodeMapLock(void)::sMutex);
  _Unwind_Resume(a1);
}

void sub_1CBCCB144(_Unwind_Exception *a1)
{
  std::mutex::unlock(&PresentationNodeMapLock(void)::sMutex);
  _Unwind_Resume(a1);
}

void sub_1CBCCB1D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCCB244(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_1CBCCB2B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCCB358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  objc_sync_exit(v11);

  _Unwind_Resume(a1);
}

void sub_1CBCCB4C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCCB75C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBCCB8F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id ErrorWithOSStatus(int a1, NSString *a2)
{
  NSString *v3;
  NSString *v4;
  void *v5;
  void *v6;
  uint64_t v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (v3)
    {
      v8 = *MEMORY[0x1E0CB2D50];
      v9[0] = v3;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v9, &v8, 1);
      v5 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v5 = 0;
    }
    objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB2F90], a1, v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1CBCCBA0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZN19TFSInfoSynchronizer13FetchChildrenEbb12LSProperties_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "cancel");
}

id __copy_helper_block_ea8_32c65_ZTSKZN19TFSInfoSynchronizer13FetchChildrenEbb12LSPropertiesE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c65_ZTSKZN19TFSInfoSynchronizer13FetchChildrenEbb12LSPropertiesE3__0(uint64_t a1)
{

}

void TFSIterator::~TFSIterator(const void **this)
{
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(this + 3);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(this + 1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(this);
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::begin(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  id v5[17];
  id v6[18];

  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v5, **(void ***)a1);
  v4 = **(void ***)(a1 + 8);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v6, (uint64_t)v5);
  v6[17] = v4;
  iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::ZipIterator(a2, (uint64_t)v6);

}

void sub_1CBCCBB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::end(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  id v5[17];
  id v6[18];

  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)v5, -1, **(void ***)a1);
  v4 = *(void **)(*(_QWORD *)(a1 + 8) + 8);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v6, (uint64_t)v5);
  v6[17] = v4;
  iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::ZipIterator(a2, (uint64_t)v6);

}

void sub_1CBCCBB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

id fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::value_or<decltype(nullptr)>(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 8))
    return 0;
  else
    return *(id *)a1;
}

uint64_t iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::operator++(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 120);
  if (v2 >= *(_QWORD *)(a1 + 112) - 1)
  {
    v3 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    v2 = -1;
    *(_QWORD *)(a1 + 112) = v3;
    *(_QWORD *)(a1 + 120) = -1;
  }
  if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
  {
    objc_enumerationMutation(*(id *)a1);
    v2 = *(_QWORD *)(a1 + 120);
  }
  v4 = *(_QWORD *)(a1 + 136);
  v5 = *(_QWORD *)(a1 + 128) + 1;
  *(_QWORD *)(a1 + 120) = v2 + 1;
  *(_QWORD *)(a1 + 128) = v5;
  *(_QWORD *)(a1 + 136) = v4 + 16;
  return a1;
}

uint64_t std::vector<std::shared_ptr<TFSInfo>>::reserve(char **a1, unint64_t a2)
{
  uint64_t result;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;
  int64x2_t v12;
  char *v13;
  uint64_t v14;
  int64x2_t v15;
  char *v16;
  uint64_t v17;

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v17 = result;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(result, a2);
    v9 = *a1;
    v8 = a1[1];
    if (v8 == *a1)
    {
      v12 = vdupq_n_s64((unint64_t)v8);
      v10 = &v6[v5];
    }
    else
    {
      v10 = &v6[v5];
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        v8 -= 16;
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 16;
        *(_QWORD *)v8 = 0;
        *((_QWORD *)v8 + 1) = 0;
      }
      while (v8 != v9);
      v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5];
    v15 = v12;
    v13 = a1[2];
    a1[2] = &v6[16 * v7];
    v16 = v13;
    v14 = v12.i64[0];
    return std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((uint64_t)&v14);
  }
  return result;
}

void std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

void std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;
  void *v5;

  for (i = *(_QWORD *)(a1 + 8); i != a2; i -= 16)
  {

    v5 = *(void **)(i - 16);
  }
  *(_QWORD *)(a1 + 8) = a2;
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,void>@<X0>(os_unfair_lock_s **a1@<X1>, const char *a2@<X2>, char *a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X5>, unsigned __int8 *a6@<X6>, unsigned __int8 *a7@<X7>, _QWORD *a8@<X8>, char *a9)
{
  _QWORD *v17;
  _QWORD *result;

  v17 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,std::allocator<TFSInfo>,0>(v17, a1, a2, a3, a4, a5, a6, a7, a9);
  *a8 = v17 + 3;
  a8[1] = v17;
  return result;
}

void sub_1CBCCBE3C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,std::allocator<TFSInfo>,0>(_QWORD *a1, os_unfair_lock_s **a2, const char *a3, char *a4, uint64_t *a5, uint64_t *a6, unsigned __int8 *a7, unsigned __int8 *a8, char *a9)
{
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  a1[1] = 0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), a2, a3, a4, *a5, *a6, *a7, *a8, *a9);
  return a1;
}

void sub_1CBCCBEAC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCCBF68(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCCC0EC(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::ZipIterator(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator(a1, a2);
  *(_QWORD *)(result + 136) = *(_QWORD *)(a2 + 136);
  return result;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCCC194(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},FPItem * {__strong},BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, FPItem **a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  char *v8;
  uint64_t result;

  v8 = (char *)operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * {__strong},BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1CBCCC208(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * {__strong},BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, *a3, *a4);
  return a1;
}

void sub_1CBCCC260(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType const&,__SFNode *&,void>@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType const&,__SFNode *&,std::allocator<TFSInfo>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1CBCCC2C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType const&,__SFNode *&,std::allocator<TFSInfo>,0>(_QWORD *a1, char *a2, uint64_t *a3)
{
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  a1[1] = 0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1CBCCC314(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1CBCCC388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)FICustomNode;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1CBCCC694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
  void *v49;
  void *v50;

  if (v50)
    operator delete(v50);

  _Unwind_Resume(a1);
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FINode *>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[17];
  id obj;
  _QWORD v9[8];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator((uint64_t)v7, a2);
  v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    v4 = v12;
    if (v12 >= v11 - 1)
    {
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v9, v10, 4);
      v4 = -1;
      v11 = v5;
      v12 = -1;
    }
    if (v10[4] != *(_QWORD *)v9[2])
    {
      objc_enumerationMutation(obj);
      v4 = v12;
    }
    v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1CBCCC808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

double type_traits_extras::CopyAsHelper<std::vector<long long>>::MakeWithCapacity@<D0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double result;
  __int128 v4;
  uint64_t v5;

  v4 = 0uLL;
  v5 = 0;
  std::vector<long long>::reserve((void **)&v4, a1);
  result = *(double *)&v4;
  *(_OWORD *)a2 = v4;
  *(_QWORD *)(a2 + 16) = v5;
  return result;
}

void sub_1CBCCC874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCCC9FC(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void std::vector<long long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t *std::back_insert_iterator<std::vector<long long>>::operator=[abi:ne180100](uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v4 = *a1;
  v5 = *(_QWORD **)(*a1 + 8);
  v6 = (_QWORD *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    v8 = *(_QWORD **)v4;
    v9 = ((uint64_t)v5 - *(_QWORD *)v4) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = *v6 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v6, v12);
      v8 = *(_QWORD **)v4;
      v5 = *(_QWORD **)(v4 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = &v13[8 * v12];
    *(_QWORD *)v14 = *a2;
    v7 = v14 + 8;
    while (v5 != v8)
    {
      v16 = *--v5;
      *((_QWORD *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(_QWORD *)v4 = v14;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v5 = *a2;
    v7 = v5 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

uint64_t TConditionVariable::WaitWithTimeout(TConditionVariable *this, std::mutex *a2, uint64_t a3)
{
  int v5;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7;

  ++*((_DWORD *)this + 16);
  v7 = std::chrono::steady_clock::now().__d_.__rep_ + 1000 * a3;
  while (*((_DWORD *)this + 16))
  {
    if (std::condition_variable_any::wait_until<std::mutex,std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>((uint64_t)this, a2, &v7))
    {
      v5 = *((_DWORD *)this + 16);
      if (v5)
      {
        *((_DWORD *)this + 16) = v5 - 1;
        return 1;
      }
      return 0;
    }
  }
  return 0;
}

void TConditionVariable::Wait(TConditionVariable *this, std::mutex *a2)
{
  int v2;

  v2 = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = v2 + 1;
  if (v2 != -1)
  {
    do
      std::condition_variable_any::wait<std::mutex>((uint64_t)this, a2);
    while (*((_DWORD *)this + 16));
  }
}

BOOL std::condition_variable_any::wait_until<std::mutex,std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>(uint64_t a1, std::mutex *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3)
{
  std::mutex *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v10;
  std::chrono::steady_clock::time_point v11;
  std::chrono::system_clock::time_point v12;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v13;
  _BOOL8 v14;
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v15;
  unint64_t *v16;
  unint64_t v17;
  std::unique_lock<std::mutex> v19;
  std::mutex *v20;
  std::__shared_weak_count *v21;

  v6 = *(std::mutex **)(a1 + 48);
  v7 = *(std::__shared_weak_count **)(a1 + 56);
  v20 = v6;
  v21 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v19.__m_ = v6;
  v19.__owns_ = 1;
  std::mutex::lock(v6);
  std::mutex::unlock(a2);
  if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_)
  {
    v14 = 1;
    goto LABEL_20;
  }
  v10 = *a3;
  v11.__d_.__rep_ = v10 - std::chrono::steady_clock::now().__d_.__rep_;
  if (v11.__d_.__rep_ >= 1)
  {
    std::chrono::steady_clock::now();
    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    if (v12.__d_.__rep_)
    {
      if (v12.__d_.__rep_ < 1)
      {
        if ((unint64_t)v12.__d_.__rep_ < 0xFFDF3B645A1CAC09)
        {
          v13 = 0x8000000000000000;
          goto LABEL_17;
        }
      }
      else if ((unint64_t)v12.__d_.__rep_ > 0x20C49BA5E353F7)
      {
        v13 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_15;
      }
      v13 = 1000 * v12.__d_.__rep_;
    }
    else
    {
      v13 = 0;
    }
LABEL_15:
    if (v13 > (v11.__d_.__rep_ ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      v15.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
LABEL_18:
      std::condition_variable::__do_timed_wait((std::condition_variable *)a1, &v19, v15);
      std::chrono::steady_clock::now();
      goto LABEL_19;
    }
LABEL_17:
    v15.__d_.__rep_ = v13 + v11.__d_.__rep_;
    goto LABEL_18;
  }
LABEL_19:
  v14 = std::chrono::steady_clock::now().__d_.__rep_ >= *a3;
LABEL_20:
  std::unique_lock<std::mutex>::unlock(&v19);
  std::mutex::lock(a2);
  if (v19.__owns_)
    std::mutex::unlock(v19.__m_);
  if (v7)
  {
    v16 = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v14;
}

void sub_1CBCCCE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  if (this->__owns_)
  {
    std::mutex::unlock(this->__m_);
    this->__owns_ = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    std::condition_variable_any::wait<std::mutex>();
  }
}

void std::condition_variable_any::wait<std::mutex>(uint64_t a1, std::mutex *a2)
{
  std::mutex *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::unique_lock<std::mutex> v10;
  std::mutex *v11;
  std::__shared_weak_count *v12;

  v4 = *(std::mutex **)(a1 + 48);
  v5 = *(std::__shared_weak_count **)(a1 + 56);
  v11 = v4;
  v12 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v10.__m_ = v4;
  v10.__owns_ = 1;
  std::mutex::lock(v4);
  std::mutex::unlock(a2);
  std::condition_variable::wait((std::condition_variable *)a1, &v10);
  std::unique_lock<std::mutex>::unlock(&v10);
  std::mutex::lock(a2);
  if (v10.__owns_)
    std::mutex::unlock(v10.__m_);
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBCCCF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1CBCCD228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
  _Block_object_dispose(&a29, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{

}

void sub_1CBCCD3B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBCCD4E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1CBCCD544()
{
  JUMPOUT(0x1CBCCD538);
}

void TString::SetFromUniChars(TString *this, const unsigned __int16 *a2, CFIndex a3)
{
  __CFString *v4;

  v4 = (__CFString *)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3);
  if (this->fString.fRef)
    CFRelease(this->fString.fRef);
  this->fString.fRef = v4;
}

CFIndex TString::IndexOf(TString *this, const TString *a2)
{
  return TString::IndexOf(this, a2, 0);
}

CFIndex TString::IndexOf(TString *this, const TString *a2, CFIndex a3)
{
  __CFString *fRef;
  const void *v7;
  CFTypeRef v8;
  const __CFString *v9;
  CFRange v11;
  CFRange v12;

  if (a3 < 0)
    return -1;
  if (CFStringGetLength(this->fString.fRef) <= a3 || !CFStringGetLength(a2->fString.fRef))
    return -1;
  fRef = this->fString.fRef;
  v7 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
  if (v7)
  {
    v8 = CFAutorelease(v7);
    v9 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v8);
  }
  else
  {
    v9 = 0;
  }
  v12.length = CFStringGetLength(this->fString.fRef) - a3;
  v12.location = a3;
  if (CFStringFindWithOptions(fRef, v9, v12, 0, &v11))
    return v11.location;
  else
    return -1;
}

BOOL TString::operator<(CFStringRef *a1, CFStringRef *a2)
{
  CFIndex Length;
  CFIndex v5;

  Length = CFStringGetLength(*a1);
  v5 = CFStringGetLength(*a2);
  if (Length != v5)
    return Length < v5;
  if (Length)
    return CFStringCompare(*a1, *a2, 0) == kCFCompareLessThan;
  return 0;
}

void TString::SetLength(TString *this, CFIndex a2)
{
  CFIndex v3;
  CFIndex Length;
  uint64_t v5;
  __CFString *fRef;
  CFIndex v7;
  CFRange v8;
  UniChar *buffer[3];

  if (a2)
  {
    v3 = a2;
    Length = CFStringGetLength(this->fString.fRef);
    if (Length <= v3)
      v5 = v3;
    else
      v5 = Length;
    std::vector<unsigned short>::vector(buffer, v5);
    fRef = this->fString.fRef;
    v7 = CFStringGetLength(this->fString.fRef);
    if (v7 >= v3)
      v8.length = v3;
    else
      v8.length = v7;
    v8.location = 0;
    CFStringGetCharacters(fRef, v8, buffer[0]);
    if (v3 >= 1 && (buffer[0][v3 - 1] & 0xFC00) == 0xD800)
      --v3;
    TString::SetFromUniChars(this, buffer[0], v3);
    if (buffer[0])
    {
      buffer[1] = buffer[0];
      operator delete(buffer[0]);
    }
  }
  else
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1E8752DF8);
  }
}

void sub_1CBCCD788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void TString::SubString(TString *this@<X0>, const _NSRange *a2@<X1>, TString *a3@<X8>)
{
  TString::SubString(this, a2->location, a2->length, a3);
}

void TString::Str(TString *this@<X0>, _QWORD *a2@<X8>)
{
  __CFString *v3;

  v3 = objc_retainAutorelease(objc_retainAutorelease(this->fString.fRef));
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)-[__CFString UTF8String](v3, "UTF8String"));

}

void sub_1CBCCD804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

_QWORD *std::vector<unsigned short>::vector(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned short>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_1CBCCD870(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void ContextMutex(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      TDSMutex::TDSMutex(&ContextMutex(void)::mutex, 1);
    }
  }
}

void sub_1CBCCD924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void NodeContextClose()
{
  const TString *v0;
  void *v1;
  uint8_t *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  TSystemNotificationTask *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  _QWORD block[5];
  _QWORD v17[5];
  TString v18;
  TString v19;
  os_signpost_id_t v20;
  std::mutex v21;
  os_signpost_id_t SignpostID;
  _QWORD v23[5];
  uint8_t buf[24];
  uint8_t *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  TString::TString(&v19, "DS Context");
  TString::TString(&v18, "Close");
  StSignpostMacroHelper::GetOrCreateFinderLog(&v19, v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  ISignpostInterval::ISignpostInterval((uint64_t)&v21, v1);

  SignpostID = ISignpostInterval::MakeSignpostID((ISignpostInterval *)&v21, 0);
  v23[0] = &off_1E874E9F8;
  v23[3] = v23;
  v23[4] = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  std::mutex::lock(&v21);
  v20 = SignpostID;
  *(_QWORD *)buf = &off_1E874EDC0;
  *(_QWORD *)&buf[8] = &v20;
  v25 = buf;
  ISignpostInterval::BeginPriv((uint64_t)&v21, SignpostID, (uint64_t)buf);
  v2 = v25;
  if (v25 == buf)
  {
    v3 = 4;
    v2 = buf;
  }
  else
  {
    if (!v25)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  std::mutex::unlock(&v21);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
  v4 = MEMORY[0x1E0C809B0];
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = __NodeContextClose_block_invoke;
  v17[3] = &__block_descriptor_33_ea8_32c29_ZTSKZ16NodeContextCloseE3__2_e5_v8__0l;
  if (NodeContextClose::onceToken != -1)
    dispatch_once(&NodeContextClose::onceToken, v17);
  ContextMutex();
  TDSMutex::lock(&ContextMutex(void)::mutex);
  v5 = sContextOpenCount == 1;
  if (sContextOpenCount-- <= 1)
  {
    if (v5)
    {
      std::mutex::lock(&gNodeContextCloseAsyncSignpostLock);
      _ZNSt3__115allocate_sharedB8ne180100I50AutoSignpostInterval_logName_NodeContextCloseAsyncNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(buf);
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((uint64_t)&gNodeContextCloseAsyncSignpost, (__int128 *)buf);
      v7 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v8 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      std::mutex::unlock(&gNodeContextCloseAsyncSignpostLock);
      v10 = (TSystemNotificationTask *)TFSInfo::MarkAsUsed((TFSInfo *)1);
      TSystemNotificationTask::FinalizeSystemNotificationTask(v10);
      TNode::Finalize((void *)gNodeContextCloseAsyncGroup);
      v11 = gNodeContextCloseAsyncGroup;
      dispatch_get_global_queue(0, 0);
      v12 = objc_claimAutoreleasedReturnValue();
      block[0] = v4;
      block[1] = 3321888768;
      block[2] = __NodeContextClose_block_invoke_6;
      block[3] = &__block_descriptor_33_ea8_32c29_ZTSKZ16NodeContextCloseE3__3_e5_v8__0l;
      dispatch_group_notify(v11, v12, block);

      LogObj(5);
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1CBC4A000, v13, OS_LOG_TYPE_DEFAULT, "DS Closed", buf, 2u);
      }

    }
    else
    {
      LogObj(5);
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1CBC4A000, v14, OS_LOG_TYPE_ERROR, "Imbalanced # of calls to NodeContextOpen/NodeContextClose", buf, 2u);
      }

      sContextOpenCount = 0;
    }
  }
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&v21);
}

void sub_1CBCCDC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::mutex *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&a26);
  _Unwind_Resume(a1);
}

TNode *SetNodeProperty(TNode *a1, OpaqueNodeRef *a2, const void **a3, __CFString *a4, uint64_t a5)
{
  TNode *v8;
  const TNode *v9;
  uint64_t v10;
  TNode *result;
  uint64_t v12;
  FINode *v13;
  __CFString *v14;

  v14 = a4;
  v8 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  v10 = (uint64_t)v8;
  if ((_DWORD)a2 == 1769370466)
  {
    result = (TNode *)TNode::WeakValidate(v8, v9);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = (TNode *)TNode::Validate(v8, v9);
    if ((_DWORD)result)
      return result;
  }
  TNode::GetSuperRootNode((uint64_t *)&v13, result);
  v12 = TNodeFromFINode(v13);

  if (v10 == v12)
    return 0;
  else
    return (TNode *)TNode::SetProperty(v10, (uint64_t)a2, a3, &v14, 1, a5);
}

void sub_1CBCCDF14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

void ClientNotifierFromNodeNotifier(OpaqueEventNotifier *a1@<X0>, _QWORD *a2@<X8>)
{
  __int128 *v3;
  std::mutex *v4;
  std::mutex *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  OpaqueEventNotifier *v11;
  uint8_t buf[4];
  OpaqueEventNotifier *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  if (a1)
  {
    v3 = NodeChangeNotifierRegistry();
    v5 = v4;
    std::mutex::lock(v4);
    v6 = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(v3, &v11);
    if (v6)
    {
      v7 = v6[4];
      *a2 = v6[3];
      a2[1] = v7;
      if (v7)
      {
        v8 = (unint64_t *)(v7 + 8);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
    }
    else
    {
      LogObj(5);
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134349056;
        v13 = v11;
        _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_ERROR, "Requested client notifier for node notifier not being tracked: %{public}p", buf, 0xCu);
      }

      *a2 = 0;
      a2[1] = 0;
    }
    std::mutex::unlock(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1CBCCE080(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t TNodeRequest::Make@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t result;

  v4 = operator new();
  result = TNodeRequest::TNodeRequest(v4, a1);
  *a2 = v4;
  return result;
}

void sub_1CBCCE0F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1020C403A6C1BAELL);
  _Unwind_Resume(a1);
}

OpaqueNodeRef *NodeCopyParentNode(TNode *a1, OpaqueNodeRef *a2)
{
  uint64_t v2;
  const TNode *v3;
  TNode *v4;
  os_unfair_lock_s *v5;
  TNode *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  os_unfair_lock_s *v12;
  int v13;
  TNode *v14;
  unint64_t *v15;
  unint64_t v16;
  void *fFINode;
  uint64_t v18;
  FINode ***v19;
  FINode **v20;
  FINode **v21;
  OpaqueNodeRef *v22;
  TNodePtr v24;
  id obj;
  id location;

  location = 0;
  v2 = TNode::NodeFromNodeRef(a1, a2);
  v4 = (TNode *)TNode::Validate((TNode *)v2, v3);
  if ((_DWORD)v4)
    goto LABEL_23;
  v5 = (os_unfair_lock_s *)TNode::ParentLock(v4);
  os_unfair_lock_lock(v5);
  TNodePtr::TNodePtr(&v24, *(const TNode **)(v2 + 48));
  os_unfair_lock_unlock(v5);
  TNodePtr::operator=(&location, (void **)&v24.fFINode);

  v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  v9 = *(_QWORD *)(v2 + 16);
  v8 = *(std::__shared_weak_count **)(v2 + 24);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v7);
  v12 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  v13 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v12);
  if (!v8)
    goto LABEL_9;
  v15 = (unint64_t *)&v8->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (v16)
  {
LABEL_9:
    if ((v13 & 0x100) == 0)
      goto LABEL_10;
LABEL_13:
    TNode::GetSuperRootNode((uint64_t *)&obj, v14);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)&v24, (const TNodePtr *)&obj, 0);
    v18 = *(_QWORD *)(TNodeFromFINode((FINode *)obj) + 56);
    if (v18)
      v19 = (FINode ***)(v18 + 64);
    else
      v19 = (FINode ***)&TNode::GetChildren(void)const::sEmptyList;
    v20 = *v19;
    v21 = v19[1];
    while (v20 != v21)
    {
      if (v2 == TNodeFromFINode(*v20))
      {
        objc_storeStrong(&location, obj);
        break;
      }
      ++v20;
    }
    TNode::StPopulating::~StPopulating((TNode::StPopulating *)&v24);
    fFINode = obj;
    goto LABEL_22;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  if ((v13 & 0x100) != 0)
    goto LABEL_13;
LABEL_10:
  if (TNode::IsFirmlink((TNode *)v2))
  {
    TNode::SecondParent((TNode *)v2, &v24);
    TNodePtr::operator=(&location, (void **)&v24.fFINode);
    fFINode = v24.fFINode;
LABEL_22:

  }
LABEL_23:
  v22 = TNodePtr::CopyAsNodeRef((TNodePtr *)&location);

  return v22;
}

void sub_1CBCCE2CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

uint64_t NodeIteratorSize(uint64_t result)
{
  if (result)
    return (*(_QWORD *)(result + 24) - *(_QWORD *)(result + 16)) >> 3;
  return result;
}

void AddToNodeChangeNotifierRegistry(unint64_t a1, uint64_t *a2)
{
  __int128 *v3;
  std::mutex *v4;
  std::mutex *v5;
  unint64_t v6;

  v6 = a1;
  v3 = NodeChangeNotifierRegistry();
  v5 = v4;
  std::mutex::lock(v4);
  std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__emplace_multi<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>(v3, &v6, a2);
  std::mutex::unlock(v5);
}

void sub_1CBCCE394(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void NodeDisposeNotifier(uint64_t a1)
{
  __int128 *v1;
  std::mutex *v2;
  std::mutex *v3;
  _QWORD *v4;
  NSObject *v5;
  uint64_t v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v1 = NodeChangeNotifierRegistry();
  v3 = v2;
  std::mutex::lock(v2);
  v4 = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(v1, &v6);
  if (v4)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(v1, v4, (uint64_t)buf);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf, 0);
  }
  else
  {
    LogObj(5);
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134349056;
      v8 = v6;
      _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_ERROR, "Calling RemoveFromNodeChangeNotifierRegistry on a notifier not being tracked: %{public}p", buf, 0xCu);
    }

  }
  std::mutex::unlock(v3);
}

void sub_1CBCCE49C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t NodeUnregisterChangeNotification(TNode *a1, OpaqueNodeRef *a2, uint64_t a3)
{
  TNode *v6;
  const TNode *v7;
  uint64_t v8;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  TNodePtr v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  if (!a2)
    return 4294959224;
  v6 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  v8 = TNode::WeakValidate(v6, v7);
  if (!(_DWORD)v8)
  {
    -[TNode unregisteringChangeNotification:](a1, "unregisteringChangeNotification:", a3);
    ClientNotifierFromNodeNotifier((OpaqueEventNotifier *)a2, &v14);
    if (v14)
    {
      TNodePtr::TNodePtr(&v13, v6);
      v8 = TNode::UnregisterChangeNotification((uint64_t)v6, (uint64_t)&v14, &v13.fFINode, a3);

    }
    else
    {
      v8 = 4294959224;
    }
    v10 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  return v8;
}

void sub_1CBCCE5A8(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_list va;

  va_start(va, a3);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t _NodeSizingV2(const __CFURL *a1, const __CFURL *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  CFIndex v7;
  const __CFURL *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  _BYTE v27[88];
  int8x16_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  _QWORD v33[4];
  __int128 v34;
  __int128 v35;
  _BYTE v36[27];
  uint64_t v37;
  __int16 v38;
  __int128 v39;
  uint64_t v40;
  int v41;
  char v42;
  TString *v43;
  std::__shared_weak_count *v44;
  TString *v45;
  std::__shared_weak_count *v46;
  _QWORD v47[3];

  v5 = 4294959224;
  if (a1 && a5 && !*(_DWORD *)a5)
  {
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v45);
    if (a2)
      v13 = a2;
    else
      v13 = a1;
    TCFURLInfo::Initialize(v45, v13, 1, 1);
    TCFURLInfo::GetVolumeInfoRecord((CFURLRef *)v45, v47);
    v14 = v47[1];
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v43);
    v7 = TCFURLInfo::Initialize(v43, a1, 1, 1);
    v5 = v7;
    if (!(_DWORD)v7)
    {
      v37 = 0;
      v38 = 0;
      v32 = 0u;
      memset(v33, 0, 27);
      v34 = 0u;
      v35 = 0u;
      memset(v36, 0, sizeof(v36));
      v40 = 0;
      v39 = 0uLL;
      v41 = 0;
      v42 = 1;
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](&v32, (uint64_t *)&v43);
      std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v33, (uint64_t *)&v45);
      v33[2] = v14;
      v39 = *(_OWORD *)(a3 + 8);
      v40 = a4;
      LOBYTE(v33[3]) = (v47[0] & 0x20) != 0;
      BYTE1(v33[3]) = 0;
      if (geteuid())
        BYTE2(v41) = 1;
      TOperationSizer::TOperationSizer((TOperationSizer *)v27, (const TOperationSizer::TOperationSizerParams *)&v32);
      v5 = TOperationSizer::ComputeSize((TOperationSizer *)v27);
      if (!(_DWORD)v5)
      {
        *(int8x16_t *)(a5 + 8) = vextq_s8(v28, v28, 8uLL);
        *(_OWORD *)(a5 + 24) = v29;
        *(_QWORD *)(a5 + 40) = v30;
        *(_OWORD *)(a5 + 48) = v31;
      }
      TOperationSizer::~TOperationSizer((TOperationSizer *)v27);

      v21 = (std::__shared_weak_count *)v33[1];
      if (v33[1])
      {
        v22 = (unint64_t *)(v33[1] + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      v24 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
      if (*((_QWORD *)&v32 + 1))
      {
        v25 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
    }
    v15 = v44;
    if (v44)
    {
      p_shared_owners = (unint64_t *)&v44->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = v46;
    if (!v46)
      goto LABEL_19;
    v19 = (unint64_t *)&v46->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
      if ((_DWORD)v7)
        return v7;
    }
    else
    {
LABEL_19:
      if ((_DWORD)v7)
        return v7;
    }
  }
  return v5;
}

void sub_1CBCCE86C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,id a57)
{
  uint64_t v57;

  TOperationSizer::~TOperationSizer((TOperationSizer *)&a10);
  TOperationSizer::TOperationSizerParams::~TOperationSizerParams(&a57);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v57 - 120);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v57 - 104);
  _Unwind_Resume(a1);
}

void TOperationSizer::TOperationSizerParams::~TOperationSizerParams(id *this)
{

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(this + 2));
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

TNode *NodeGetFIProviderDomain(TNode *a1, OpaqueNodeRef *a2)
{
  TNode *v2;
  const TNode *v3;
  TNode *v4;

  v2 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  if (v2)
  {
    v4 = v2;
    if (TNode::WeakValidate(v2, v3))
    {
      v2 = 0;
    }
    else
    {
      TNode::GetFIProvider(v4);
      v2 = (TNode *)objc_claimAutoreleasedReturnValue();
    }
  }
  return v2;
}

void StSignpostMacroHelper::~StSignpostMacroHelper(StSignpostMacroHelper *this)
{
  StSignpostMacroHelper *v2;
  uint64_t v3;

  std::mutex::lock((std::mutex *)this);
  std::function<void ()(StSignpostMacroHelper *,unsigned long long)>::operator()((uint64_t)this + 120, (uint64_t)this, *((_QWORD *)this + 14));
  std::mutex::unlock((std::mutex *)this);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 19);
  v2 = (StSignpostMacroHelper *)*((_QWORD *)this + 18);
  if (v2 == (StSignpostMacroHelper *)((char *)this + 120))
  {
    v3 = 4;
    v2 = (StSignpostMacroHelper *)((char *)this + 120);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 72);

  std::mutex::~mutex((std::mutex *)this);
}

uint64_t std::function<void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = a3;
  v6 = a2;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v6, &v5);
}

void ISignpostInterval::~ISignpostInterval(id *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(this + 9));

  std::mutex::~mutex((std::mutex *)this);
}

void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  std::mutex::lock((std::mutex *)a1);
  v4 = *(_QWORD *)(a1 + 112);
  v7[0] = &off_1E874EBB0;
  v7[1] = a1;
  v7[2] = a2;
  v8 = v7;
  ISignpostInterval::EventPriv(a1, v4, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }
  std::mutex::unlock((std::mutex *)a1);
}

void sub_1CBCCEADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  std::mutex *v13;
  char *v14;
  char *v16;
  uint64_t v17;

  v16 = a13;
  if (a13 == v14)
  {
    v17 = 4;
    v16 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  std::mutex::unlock(v13);
  _Unwind_Resume(a1);
}

void std::__function::__func<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

__n128 std::__function::__func<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E874EBB0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E874EBB0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, void **a2)
{
  AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}::operator()((uint64_t *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void AutoSignpostInterval_logName_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}::operator()(uint64_t *a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  os_signpost_id_t v7;
  std::string *p_p;
  std::string __p;
  __int128 v10;
  uint8_t buf[4];
  std::string *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *a1;
  v5 = v3;
  v6 = v5;
  v7 = *(_QWORD *)(v4 + 112);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *(_QWORD *)&v10 = a1[1];
    *((_QWORD *)&v10 + 1) = strlen((const char *)v10);
    FormatDetails(&v10, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136446210;
    v12 = p_p;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v6, OS_SIGNPOST_EVENT, v7, "NodeContextCloseAsync", "%{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }

}

void sub_1CBCCECEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ___ZZ15NodeContextOpenENK3__2clEv_block_invoke()
{
  _QWORD block[5];

  LogDSPath();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZL30RegisterForComputerNameChangesv_block_invoke;
  block[3] = &__block_descriptor_33_ea8_32c45_ZTSKZL30RegisterForComputerNameChangesvE3__0_e5_v8__0l;
  if (RegisterForComputerNameChanges(void)::once != -1)
    dispatch_once(&RegisterForComputerNameChanges(void)::once, block);
  return (id)FPItemManagerInstance();
}

void ___ZL30RegisterForComputerNameChangesv_block_invoke()
{
  unsigned __int8 v0;
  const __SCDynamicStore *v1;
  NSObject *v2;
  CFStringRef ComputerName;
  CFMutableArrayRef theArray;

  if ((v0 & 1) == 0
  {
    RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore = (uint64_t)SCDynamicStoreCreate(0, CFSTR("watchForComputerNameChanges"), (SCDynamicStoreCallBack)TNode::ComputerNameChangedCallback, 0);
  }
  if (RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore)
  {
    theArray = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    ComputerName = SCDynamicStoreKeyCreateComputerName(0);
    CFArrayAppendValue(theArray, ComputerName);
    if (SCDynamicStoreSetNotificationKeys((SCDynamicStoreRef)RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore, theArray, 0))
    {
      v1 = (const __SCDynamicStore *)RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore;
      dispatch_get_global_queue(0, 0);
      v2 = objc_claimAutoreleasedReturnValue();
      SCDynamicStoreSetDispatchQueue(v1, v2);

    }
    TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&ComputerName);
    TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)&theArray);
  }
}

void sub_1CBCCEE7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__int128 *NodeChangeNotifierRegistry(void)
{
  unsigned __int8 v0;

  {
    NodeChangeNotifierRegistry(void)::sRegistry = 0u;
    unk_1EF9B9AA8 = 0u;
    dword_1EF9B9AB8 = 1065353216;
  }
  return &NodeChangeNotifierRegistry(void)::sRegistry;
}

_QWORD *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__emplace_multi<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>(_QWORD *a1, unint64_t *a2, uint64_t *a3)
{
  _QWORD *inserted;
  _QWORD *v6[3];

  std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__construct_node<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>((uint64_t)a1, a2, a3, (uint64_t)v6);
  inserted = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi(a1, v6[0]);
  v6[0] = 0;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>>::reset[abi:ne180100]((uint64_t)v6, 0);
  return inserted;
}

void sub_1CBCCEF80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__construct_node<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v7 = a1 + 16;
  result = operator new(0x28uLL);
  *(_QWORD *)a4 = result;
  *(_QWORD *)(a4 + 8) = v7;
  *result = 0;
  result[1] = 0;
  v9 = *a2;
  v11 = *a3;
  v10 = a3[1];
  result[2] = *a2;
  result[3] = v11;
  result[4] = v10;
  if (v10)
  {
    v12 = (unint64_t *)(v10 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    v9 = result[2];
  }
  *(_BYTE *)(a4 + 16) = 1;
  v14 = HIDWORD(v9);
  v15 = 0x9DDFEA08EB382D69 * (((8 * v9) + 8) ^ HIDWORD(v9));
  result[1] = 0x9DDFEA08EB382D69
            * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *inserted;

  v4 = a2 + 2;
  v5 = a2[2];
  v6 = HIDWORD(v5);
  v7 = 0x9DDFEA08EB382D69 * (((8 * v5) + 8) ^ HIDWORD(v5));
  v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  a2[1] = v8;
  inserted = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi_prepare((uint64_t)a1, v8, v4);
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_perform(a1, a2, inserted);
  return a2;
}

_QWORD *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  float v7;
  float v8;
  uint64_t v9;
  _BOOL8 v10;
  size_t v11;
  unint64_t v12;
  size_t v13;
  uint8x8_t v14;
  unint64_t v15;
  _QWORD *v16;
  int v17;
  _QWORD *result;
  unint64_t v19;
  unint64_t v20;
  _BOOL4 v21;
  int v22;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    v9 = 2 * v6;
    v10 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    v11 = v10 | v9;
    v12 = vcvtps_u32_f32(v7 / v8);
    if (v11 <= v12)
      v13 = v12;
    else
      v13 = v11;
    std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__rehash<false>(a1, v13);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v14 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    v15 = a2;
    if (v6 <= a2)
      v15 = a2 % v6;
  }
  else
  {
    v15 = (v6 - 1) & a2;
  }
  v16 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
  if (!v16)
    return 0;
  v17 = 0;
  do
  {
    result = v16;
    v16 = (_QWORD *)*v16;
    if (!v16)
      break;
    v19 = v16[1];
    if (v14.u32[0] > 1uLL)
    {
      v20 = v16[1];
      if (v19 >= v6)
        v20 = v19 % v6;
    }
    else
    {
      v20 = v19 & (v6 - 1);
    }
    if (v20 != v15)
      break;
    v21 = v19 == a2 && v16[2] == *a3;
    v22 = v17 & !v21;
    v17 |= v21;
  }
  while (v22 != 1);
  return result;
}

void std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__do_rehash<false>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      for (i = (_QWORD *)*v7; *v7; i = (_QWORD *)*v7)
      {
        v12 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v12 >= a2)
            v12 %= a2;
        }
        else
        {
          v12 &= a2 - 1;
        }
        if (v12 == v8)
        {
          v7 = i;
        }
        else
        {
          v13 = i;
          if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
          {
            do
            {
              v14 = v13;
              v13 = (_QWORD *)*v13;
            }
            while (v13 && i[2] == v13[2]);
            *v7 = v13;
            *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = i;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
            v7 = i;
            v8 = v12;
          }
        }
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t *StSignpostMacroHelper::GetOrCreateFinderLog(TString *this, const TString *a2)
{
  unsigned __int8 v3;
  const char *v4;
  os_log_t v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t *v8;
  TString **v10;

  if ((v3 & 1) == 0
  {
    StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs = 0u;
    unk_1EF9B9368 = 0u;
    dword_1EF9B9378 = 1065353216;
  }
  std::mutex::lock(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::fMutex);
  if (!std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs, this))
  {
    v4 = (const char *)TString::c_str(this);
    v5 = os_log_create("com.apple.DesktopServices", v4);
    v10 = (TString **)this;
    v6 = std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs, this, (uint64_t)&std::piecewise_construct, &v10);
    v7 = v6[3];
    v6[3] = (uint64_t *)v5;

  }
  v10 = (TString **)this;
  v8 = std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs, this, (uint64_t)&std::piecewise_construct, &v10)[3];
  std::mutex::unlock(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::fMutex);
  return v8;
}

void sub_1CBCCF57C(_Unwind_Exception *a1)
{
  std::mutex::unlock(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::fMutex);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = FowlerNollVoHash::hash(this, this);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef))
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, (__CFString *)v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCCF7F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a10)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, a10);
  _Unwind_Resume(exception_object);
}

TString *std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  TString *v8;
  TString *result;

  v7 = a1 + 16;
  v8 = (TString *)operator new(0x20uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  v8->fString.fRef = 0;
  v8[1].fString.fRef = a2;
  result = std::pair<TString const,NSObject  {objcproto9OS_os_log}* {__strong}>::pair[abi:ne180100]<TString const&>(v8 + 2, *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCCF880(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

TString *std::pair<TString const,NSObject  {objcproto9OS_os_log}* {__strong}>::pair[abi:ne180100]<TString const&>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = 0;
  return a1;
}

void sub_1CBCCF8E0(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,void *>>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a2 + 16));
  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

void std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E874EA50;
  return result;
}

void std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E874EA50;
}

_QWORD *std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  unint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v6 = *a3;
  v7[0] = &off_1E874EEC8;
  v7[1] = &v6;
  v8 = v7;
  ISignpostInterval::EndPriv(v3, v6, (uint64_t)v7);
  result = v8;
  if (v8 == v7)
  {
    v5 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1CBCCFA3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target_type()
{
}

void std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EEC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EEC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  NSObject *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v3 = *a2;
  v4 = v3;
  v5 = **(_QWORD **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v4, OS_SIGNPOST_INTERVAL_END, v5, "Open Extended", "End", v6, 2u);
  }

}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EE70;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EE70;
  a2[1] = v2;
  return result;
}

void std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  NSObject *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v3 = *a2;
  v4 = v3;
  v5 = **(_QWORD **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Open Extended", "Begin", v6, 2u);
  }

}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E874E9A0;
  return result;
}

void std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E874E9A0;
}

_QWORD *std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  unint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v6 = *a3;
  v7[0] = &off_1E874ED68;
  v7[1] = &v6;
  v8 = v7;
  ISignpostInterval::EndPriv(v3, v6, (uint64_t)v7);
  result = v8;
  if (v8 == v7)
  {
    v5 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1CBCCFE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target_type()
{
}

void std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874ED68;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874ED68;
  a2[1] = v2;
  return result;
}

void std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  NSObject *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v3 = *a2;
  v4 = v3;
  v5 = **(_QWORD **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v4, OS_SIGNPOST_INTERVAL_END, v5, "Open", "End", v6, 2u);
  }

}

uint64_t std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874ED10;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874ED10;
  a2[1] = v2;
  return result;
}

void std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  NSObject *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v3 = *a2;
  v4 = v3;
  v5 = **(_QWORD **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Open", "Begin", v6, 2u);
  }

}

uint64_t std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E874E9F8;
  return result;
}

void std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E874E9F8;
}

_QWORD *std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  unint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v6 = *a3;
  v7[0] = &off_1E874EE18;
  v7[1] = &v6;
  v8 = v7;
  ISignpostInterval::EndPriv(v3, v6, (uint64_t)v7);
  result = v8;
  if (v8 == v7)
  {
    v5 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1CBCD0234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target_type()
{
}

void std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EE18;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EE18;
  a2[1] = v2;
  return result;
}

void std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  NSObject *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v3 = *a2;
  v4 = v3;
  v5 = **(_QWORD **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v4, OS_SIGNPOST_INTERVAL_END, v5, "Close", "End", v6, 2u);
  }

}

uint64_t std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EDC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EDC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  NSObject *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v3 = *a2;
  v4 = v3;
  v5 = **(_QWORD **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Close", "Begin", v6, 2u);
  }

}

uint64_t std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I50AutoSignpostInterval_logName_NodeContextCloseAsyncNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x90uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI50AutoSignpostInterval_logName_NodeContextCloseAsyncNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1CBCD056C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI50AutoSignpostInterval_logName_NodeContextCloseAsyncNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_1E874EF20;
  a1[1] = 0;
  AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync((AutoSignpostInterval_logName_NodeContextCloseAsync *)(a1 + 3), 0);
  return a1;
}

void sub_1CBCD05BC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<AutoSignpostInterval_logName_NodeContextCloseAsync>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874EF20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AutoSignpostInterval_logName_NodeContextCloseAsync>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874EF20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<AutoSignpostInterval_logName_NodeContextCloseAsync>::__on_zero_shared(uint64_t a1)
{
  AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync((AutoSignpostInterval_logName_NodeContextCloseAsync *)(a1 + 24));
}

void AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(AutoSignpostInterval_logName_NodeContextCloseAsync *this, void *a2)
{
  void *v4;
  unint64_t v5;
  TString *v6;
  uint64_t v7;
  TString v8;
  AutoSignpostInterval_logName_NodeContextCloseAsync *v9;
  TString *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  LogObj(5);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  TString::TString(&v8, "NodeContextCloseAsync");
  ISignpostInterval::ISignpostInterval((uint64_t)this, v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);

  *((_QWORD *)this + 14) = ISignpostInterval::MakeSignpostID(this, a2);
  std::mutex::lock((std::mutex *)this);
  v5 = *((_QWORD *)this + 14);
  v8.fString.fRef = (__CFString *)&off_1E874EC08;
  v9 = this;
  v10 = &v8;
  ISignpostInterval::BeginPriv((uint64_t)this, v5, (uint64_t)&v8);
  v6 = v10;
  if (v10 == &v8)
  {
    v7 = 4;
    v6 = &v8;
    goto LABEL_5;
  }
  if (v10)
  {
    v7 = 5;
LABEL_5:
    (*((void (**)(void))&v6->fString.fRef->isa + v7))();
  }
  std::mutex::unlock((std::mutex *)this);
}

void sub_1CBCD0730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  std::mutex *v13;
  char *v14;
  char *v16;
  uint64_t v17;

  v16 = a13;
  if (a13 == v14)
  {
    v17 = 4;
    v16 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  std::mutex::unlock(v13);
  ISignpostInterval::~ISignpostInterval((id *)v13);
  _Unwind_Resume(a1);
}

void std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EC08;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EC08;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>((uint64_t *)(a1 + 8), a2);
}

uint64_t std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_logName_NodeContextCloseAsync::AutoSignpostInterval_logName_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>(uint64_t *a1, id *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  os_signpost_id_t v7;
  uint8_t v8[16];

  v3 = *a2;
  v4 = *a1;
  v5 = v3;
  v6 = v5;
  v7 = *(_QWORD *)(v4 + 112);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *(_WORD *)v8 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v7, "NodeContextCloseAsync", "Begin", v8, 2u);
  }

}

void AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync(AutoSignpostInterval_logName_NodeContextCloseAsync *this)
{
  unint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  unint64_t v5[3];
  unint64_t *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  std::mutex::lock((std::mutex *)this);
  v5[0] = *((_QWORD *)this + 14);
  if (std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>((_QWORD *)this + 9, v5))
  {
    v2 = *((_QWORD *)this + 14);
    v5[0] = (unint64_t)&off_1E874EC60;
    v5[1] = (unint64_t)this;
    v6 = v5;
    ISignpostInterval::EndPriv((uint64_t)this, v2, (uint64_t)v5);
    v3 = v6;
    if (v6 == v5)
    {
      v4 = 4;
      v3 = v5;
      goto LABEL_6;
    }
    if (v6)
    {
      v4 = 5;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
  }
  std::mutex::unlock((std::mutex *)this);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 72);

  std::mutex::~mutex((std::mutex *)this);
}

void sub_1CBCD09E0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EC60;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EC60;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>((uint64_t *)(a1 + 8), a2);
}

uint64_t std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_logName_NodeContextCloseAsync::~AutoSignpostInterval_logName_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>(uint64_t *a1, id *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  os_signpost_id_t v7;
  uint8_t v8[16];

  v3 = *a2;
  v4 = *a1;
  v5 = v3;
  v6 = v5;
  v7 = *(_QWORD *)(v4 + 112);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *(_WORD *)v8 = 0;
    _os_signpost_emit_with_name_impl(&dword_1CBC4A000, v6, OS_SIGNPOST_INTERVAL_END, v7, "NodeContextCloseAsync", "End", v8, 2u);
  }

}

_QWORD *std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void>@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x50uLL);
  result = std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::allocator<TNodeTask>,0>(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1CBCD0B78(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::allocator<TNodeTask>,0>(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_1E8750810;
  a1[1] = 0;
  TNodeTask::TNodeTask(a1 + 3);
  return a1;
}

void sub_1CBCD0BC4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TNodeTask>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750810;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TNodeTask>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750810;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__destroy_at[abi:ne180100]<TNodeTask,0>(uint64_t a1)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)(a1 + 24));
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)(a1 + 8));

}

uint64_t TPropertyValue::TPropertyValue<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, CFTypeRef *a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(a1, (CFTypeRef *)a1, a2);
  return a1;
}

void sub_1CBCD0C80(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::TPropertyValue<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, CFTypeRef *a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(a1, (CFTypeRef *)a1, a2);
  return a1;
}

void sub_1CBCD0CC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

id CopyDeep(NSArray *a1)
{
  NSArray *v1;
  NSArray *v2;
  void *v3;
  void *v4;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    CopyDeepCommon(v1, 0);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithArray:", v3);

  }
  else
  {
    v4 = 0;
  }

  return v4;
}

void sub_1CBCD0D44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id CopyDeepCommon(NSArray *a1, BOOL a2)
{
  NSArray *v3;
  void *v4;
  NSArray *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", -[NSArray count](v3, "count"));
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v5 = v3;
  v6 = -[NSArray countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v12;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v12 != v7)
          objc_enumerationMutation(v5);
        CopyDeepHelper(*(NSObject **)(*((_QWORD *)&v11 + 1) + 8 * v8), a2);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "addObject:", v9, (_QWORD)v11);

        ++v8;
      }
      while (v6 != v8);
      v6 = -[NSArray countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v6);
  }

  return v4;
}

void sub_1CBCD0EAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id MutableCopyDeep(NSArray *a1)
{
  NSArray *v1;
  NSArray *v2;
  void *v3;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    CopyDeepCommon(v1, 1);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1CBCD0F34(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ISignpostInterval::ISignpostInterval(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  *(_QWORD *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = v3;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 1065353216;
  return a1;
}

os_signpost_id_t ISignpostInterval::MakeSignpostID(ISignpostInterval *this, void *a2)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 8);
  if (a2)
    return os_signpost_id_make_with_pointer(v2, a2);
  else
    return os_signpost_id_generate(v2);
}

void ISignpostInterval::BeginPriv(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _BOOL4 v6;
  unint64_t v7;

  v7 = a2;
  v6 = os_signpost_enabled(*(os_log_t *)(a1 + 64));
  if (a2)
  {
    if (v6)
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(a1 + 72, &v7, &v7);
      std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(a3, *(void **)(a1 + 64));
    }
  }
}

void std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3;
  id v4;

  v4 = a2;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *))(*(_QWORD *)v3 + 48))(v3, &v4);

}

void sub_1CBCD1060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void ISignpostInterval::EndPriv(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _BOOL4 v6;
  unint64_t v7;

  v7 = a2;
  v6 = os_signpost_enabled(*(os_log_t *)(a1 + 64));
  if (a2)
  {
    if (v6)
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>((_QWORD *)(a1 + 72), &v7);
      std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(a3, *(void **)(a1 + 64));
    }
  }
}

void ISignpostInterval::EventPriv(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  _BOOL4 v6;

  v5 = *(NSObject **)(a1 + 64);
  v6 = os_signpost_enabled(v5);
  if (a2)
  {
    if (v6)
      std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(a3, v5);
  }
}

TString *TGlobalNodes::ComputerName@<X0>(TString *a1@<X8>)
{
  return TString::TString(a1, "Computer", 8uLL);
}

__n128 __copy_helper_block_ea8_32c37_ZTSKZN12TGlobalNodes8BootNodeEvE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

id TGlobalNodes::DataSeparatedICloudLibrariesContainerNode@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  id result;
  _QWORD block[5];

  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes41DataSeparatedICloudLibrariesContainerNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::DataSeparatedICloudLibrariesContainerNode(void)::onceToken != -1)
    dispatch_once(&TGlobalNodes::DataSeparatedICloudLibrariesContainerNode(void)::onceToken, block);
  result = *(id *)(v3 + 88);
  *a1 = result;
  return result;
}

void ___ZN12TGlobalNodes41DataSeparatedICloudLibrariesContainerNodeEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  TNodePtr v18;
  id obj;
  uint64_t v20;
  std::__shared_weak_count *v21;

  TFSVolumeInfo::GetVolumeInfoFor(0x18u, &v20);
  TNodePtr::TNodePtr(&v18, 0);
  v2 = *(std::__shared_weak_count **)(v20 + 64);
  v16 = *(_QWORD *)(v20 + 56);
  v17 = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  v14 = 0;
  v15 = 0;
  TNode::CreateNode((uint64_t)&v18, (uint64_t)&v16, (uint64_t)&v14, (TNodePtr *)&obj);
  v5 = v15;
  if (v15)
  {
    v6 = (unint64_t *)&v15->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v17;
  if (v17)
  {
    v9 = (unint64_t *)&v17->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 88), obj);
  v11 = v21;
  if (v21)
  {
    v12 = (unint64_t *)&v21->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1CBCD133C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, id a13)
{
  uint64_t v13;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v13 - 32);
  _Unwind_Resume(a1);
}

void TGlobalNodes::NetworkNearbyNode(_QWORD *a1@<X8>)
{
  id *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  TNodePtr v20;
  id obj;
  uint64_t v22;
  std::__shared_weak_count *v23;

  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = (id *)(TGlobalNodes::gGlobalNodes + 56);
  if (!TNodeFromFINode(*(FINode **)(TGlobalNodes::gGlobalNodes + 56)))
  {
    TFSVolumeInfo::GetVolumeInfoFor(&v22, 31);
    TNodePtr::TNodePtr(&v20, 0);
    v4 = *(std::__shared_weak_count **)(v22 + 64);
    v18 = *(_QWORD *)(v22 + 56);
    v19 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v16 = 0;
    v17 = 0;
    TNode::CreateNode(&obj, &v20, &v18, &v16);
    v7 = v17;
    if (v17)
    {
      v8 = (unint64_t *)&v17->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = v19;
    if (v19)
    {
      v11 = (unint64_t *)&v19->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    objc_storeStrong(v3, obj);
    v13 = v23;
    if (v23)
    {
      v14 = (unint64_t *)&v23->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  *a1 = *v3;
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1CBCD1518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, id a13, uint64_t a14, char a15)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

void TGlobalNodes::AirDropNode(_QWORD *a1@<X8>)
{
  id *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  TNodePtr v20;
  id obj;
  uint64_t v22;
  std::__shared_weak_count *v23;

  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = (id *)(TGlobalNodes::gGlobalNodes + 64);
  if (!TNodeFromFINode(*(FINode **)(TGlobalNodes::gGlobalNodes + 64)))
  {
    TFSVolumeInfo::GetVolumeInfoFor(&v22, 33);
    TNodePtr::TNodePtr(&v20, 0);
    v4 = *(std::__shared_weak_count **)(v22 + 64);
    v18 = *(_QWORD *)(v22 + 56);
    v19 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v16 = 0;
    v17 = 0;
    TNode::CreateNode(&obj, &v20, &v18, &v16);
    v7 = v17;
    if (v17)
    {
      v8 = (unint64_t *)&v17->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = v19;
    if (v19)
    {
      v11 = (unint64_t *)&v19->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    objc_storeStrong(v3, obj);
    v13 = v23;
    if (v23)
    {
      v14 = (unint64_t *)&v23->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  *a1 = *v3;
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1CBCD170C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, id a13, uint64_t a14, char a15)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

void TGlobalNodes::NetworkSidebarNode(_QWORD *a1@<X8>)
{
  id *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  TNodePtr v20;
  id obj;
  uint64_t v22;
  std::__shared_weak_count *v23;

  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v3 = (id *)(TGlobalNodes::gGlobalNodes + 72);
  if (!TNodeFromFINode(*(FINode **)(TGlobalNodes::gGlobalNodes + 72)))
  {
    TFSVolumeInfo::GetVolumeInfoFor(&v22, 32);
    TNodePtr::TNodePtr(&v20, 0);
    v4 = *(std::__shared_weak_count **)(v22 + 64);
    v18 = *(_QWORD *)(v22 + 56);
    v19 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v16 = 0;
    v17 = 0;
    TNode::CreateNode(&obj, &v20, &v18, &v16);
    v7 = v17;
    if (v17)
    {
      v8 = (unint64_t *)&v17->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = v19;
    if (v19)
    {
      v11 = (unint64_t *)&v19->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    objc_storeStrong(v3, obj);
    v13 = v23;
    if (v23)
    {
      v14 = (unint64_t *)&v23->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  *a1 = *v3;
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1CBCD1900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, id a13, uint64_t a14, char a15)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

uint64_t TGlobalNodes::IsNetworkNode(TGlobalNodes *this, FINode **a2, const TNodePtr *a3)
{
  int v4;
  uint64_t v5;
  uint64_t result;
  FINode **v7;
  uint64_t v8;

  v4 = (int)this;
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1)
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  v5 = TGlobalNodes::gGlobalNodes;
  if (!TGlobalNodes::gGlobalNodes)
    return 0;
  result = TNodeFromFINode(*a2);
  if (!result)
    return result;
  if (v4 == 1836348013)
  {
    v7 = (FINode **)(v5 + 64);
    goto LABEL_12;
  }
  if (v4 == 1853125474)
  {
    v7 = (FINode **)(v5 + 72);
    goto LABEL_12;
  }
  if (v4 != 1853126507)
    return 0;
  v7 = (FINode **)(v5 + 56);
LABEL_12:
  v8 = TNodeFromFINode(*v7);
  return v8 == TNodeFromFINode(*a2);
}

void TGlobalNodes::FinalizeGlobalNode(FINode **this, const TNodePtr *a2)
{
  void *v3;
  TNodeEvent *v4;
  TNode *v5;
  TNode *v6;

  v3 = (void *)MEMORY[0x1D17A5880](this, a2);
  v4 = (TNodeEvent *)TNodeFromFINode(*this);
  TNode::UnRegisterForInternalNotifications(v4, this, 3);
  v5 = (TNode *)TNodeFromFINode(*this);
  TNode::RemoveAllChildren(v5, 0, 0);
  v6 = (TNode *)TNodeFromFINode(*this);
  TNode::RemoveSelf(v6, 0);
  objc_autoreleasePoolPop(v3);
}

void TGlobalNodes::FinalizeNodes(void *a1)
{
  id v1;
  uint64_t v2;
  TNodePtr *v3;
  TNode *v4;
  TNode *v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t i;
  FINode *v14;
  id v15;
  id v16;
  id v17;
  TFSVolumeInfo *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t j;
  TFSVolumeInfo *v22;
  TFSVolumeInfo *v23;
  TFSVolumeInfo *v24;
  FINode **v25;
  const TNodePtr *v26;
  TFSVolumeInfo *v27;
  TFSVolumeInfo *v28;
  char *v29;
  NSObject *v30;
  TFSVolumeInfo **v31;
  uint64_t v32;
  uint64_t (*v33)();
  void *v34;
  TNodePtr v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::gGlobalNodes)
  {
    v30 = v1;
    TGlobalNodes::FinalizeNodes(NSObject  {objcproto17OS_dispatch_group}*)::$_3::operator()(&v30, (id *)TGlobalNodes::gGlobalNodes, 3, 0);
    v35.fFINode = (FINode *)*(id *)(TGlobalNodes::gGlobalNodes + 88);
    v2 = 0;
    v36 = *(id *)(TGlobalNodes::gGlobalNodes + 80);
    v3 = &v35;
    do
    {
      if (TNodeFromFINode((&v35.fFINode)[v2]))
      {
        v4 = (TNode *)TNodeFromFINode((&v35.fFINode)[v2]);
        TNode::UnRegisterForUbiquityAttributes(v4);
        atomic_store(0, (unsigned __int16 *)(TNodeFromFINode((&v35.fFINode)[v2]) + 80));
        v5 = (TNode *)TNodeFromFINode((&v35.fFINode)[v2]);
        TNode::GetVolumeInfo(v5, &v27);
        TFSVolumeInfo::GetVolumeSyncThread(v27, &v31);
        NodeEventRefFromNodeEvent((id *)v31);
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = (std::__shared_weak_count *)v32;
        if (v32)
        {
          v8 = (unint64_t *)(v32 + 8);
          do
            v9 = __ldaxr(v8);
          while (__stlxr(v9 - 1, v8));
          if (!v9)
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
        }
        v10 = (std::__shared_weak_count *)v28;
        if (v28)
        {
          v11 = (unint64_t *)((char *)v28 + 8);
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
        TGlobalNodes::FinalizeNodes(NSObject  {objcproto17OS_dispatch_group}*)::$_3::operator()(&v30, (id *)&v3->fFINode, 0, v6);

      }
      ++v2;
      v3 = &v35 + v2;
    }
    while (v2 != 2);
    for (i = 1; i != -1; --i)

    v35.fFINode = (FINode *)(TGlobalNodes::gGlobalNodes + 56);
    v14 = (FINode *)MEMORY[0x1E0C809B0];
    v31 = (TFSVolumeInfo **)MEMORY[0x1E0C809B0];
    v32 = 3321888768;
    v33 = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__0cvU13block_pointerFvvEEv_block_invoke;
    v34 = &__block_descriptor_33_ea8_32c83_ZTSKZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectE3__0_e5_v8__0l;
    v15 = (id)MEMORY[0x1D17A5A30](&v31);
    v36 = (id)MEMORY[0x1D17A5A30](v15);
    v37 = TGlobalNodes::gGlobalNodes + 64;
    v31 = (TFSVolumeInfo **)v14;
    v32 = 3321888768;
    v33 = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__1cvU13block_pointerFvvEEv_block_invoke;
    v34 = &__block_descriptor_33_ea8_32c83_ZTSKZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectE3__1_e5_v8__0l;
    v16 = (id)MEMORY[0x1D17A5A30](&v31);
    v38 = MEMORY[0x1D17A5A30](v16);
    v39 = TGlobalNodes::gGlobalNodes + 72;
    v31 = (TFSVolumeInfo **)v14;
    v32 = 3321888768;
    v33 = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__2cvU13block_pointerFvvEEv_block_invoke;
    v34 = &__block_descriptor_33_ea8_32c83_ZTSKZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectE3__2_e5_v8__0l;
    v17 = (id)MEMORY[0x1D17A5A30](&v31);
    v40 = MEMORY[0x1D17A5A30](v17);
    v28 = 0;
    v29 = 0;
    v27 = 0;
    v31 = &v27;
    LOBYTE(v32) = 0;
    v18 = (TFSVolumeInfo *)operator new(0x30uLL);
    v19 = 0;
    v27 = v18;
    v28 = v18;
    v29 = (char *)v18 + 48;
    do
    {
      v20 = *(uint64_t *)((char *)&v35 + v19 + 8);
      *(TNodePtr *)((char *)v18 + v19) = *(TNodePtr *)((char *)&v35 + v19);
      *(_QWORD *)((char *)v18 + v19 + 8) = MEMORY[0x1D17A5A30](v20);
      v19 += 16;
    }
    while (v19 != 48);
    v28 = (TFSVolumeInfo *)((char *)v18 + 48);
    for (j = 5; j != -1; j -= 2)

    v23 = v27;
    v24 = v28;
    while (v23 != v24)
    {
      v25 = *(FINode ***)v23;
      v22 = (TFSVolumeInfo *)TNodeFromFINode(**(FINode ***)v23);
      if (v22)
      {
        (*(void (**)(void))(*((_QWORD *)v23 + 1) + 16))();
        TNodePtr::TNodePtr(&v31, (id *)v25);
        TNodePtr::TNodePtr(&v35, 0);
        TNodePtr::operator=((void **)v25, (void **)&v35.fFINode);

        TGlobalNodes::FinalizeGlobalNode((FINode **)&v31, v26);
      }
      v23 = (TFSVolumeInfo *)((char *)v23 + 16);
    }
    TFSVolumeInfo::GarbageCollect(v22);
    v35.fFINode = (FINode *)&v27;
    std::vector<std::pair<std::reference_wrapper<TNodePtr>,void({block_pointer} {__strong})(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v35);

  }
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);

}

void sub_1CBCD1E3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, char a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20)
{
  void *v20;

  a20 = &a11;
  std::vector<std::pair<std::reference_wrapper<TNodePtr>,void({block_pointer} {__strong})(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);

  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

void TGlobalNodes::FinalizeNodes(NSObject  {objcproto17OS_dispatch_group}*)::$_3::operator()(NSObject **a1, id *a2, int a3, void *a4)
{
  NSObject *v7;
  NSObject *v8;
  id v9;
  _QWORD v10[4];
  id v11;
  int v12;

  v7 = a4;
  if (TNodeFromFINode((FINode *)*a2))
  {
    if (!v7)
    {
      dispatch_get_global_queue(0, 0);
      v7 = objc_claimAutoreleasedReturnValue();
    }
    v8 = *a1;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3321888768;
    v10[2] = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0__block_invoke;
    v10[3] = &__block_descriptor_48_ea8_32c167_ZTSKZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_EUlvE__e5_v8__0l;
    v11 = *a2;
    v12 = a3;
    v9 = v11;
    dispatch_group_async(v8, v7, v10);

  }
}

void sub_1CBCD1FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0__block_invoke(uint64_t a1)
{
  id v2;
  int v3;
  id v4;
  _QWORD v5[4];
  id v6;
  int v7;

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3321888768;
  v5[2] = ___ZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEv_block_invoke;
  v5[3] = &__block_descriptor_48_ea8_32c180_ZTSKZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEvEUlvE__e5_v8__0l;
  v2 = *(id *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 40);
  v4 = v2;
  v6 = v4;
  v7 = v3;
  ExceptionSafeBlock(v5);

}

void sub_1CBCD2074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c167_ZTSKZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_EUlvE_(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c167_ZTSKZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_EUlvE_(uint64_t a1)
{

}

void ___ZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEv_block_invoke(uint64_t a1)
{
  FINode **v2;
  TNode *v3;
  int v4;
  uint64_t v5;
  void ***v6;
  uint64_t v7;
  void **v8[3];
  FINode **v9[3];

  v2 = (FINode **)(a1 + 32);
  memset(v9, 0, sizeof(v9));
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v8, (const TNodePtr *)(a1 + 32), 0);
  v3 = (TNode *)TNodeFromFINode(*v2);
  v4 = TNode::ChildRegistrationCount(v3);
  v5 = *(_QWORD *)(TNodeFromFINode(*v2) + 56);
  if (v5)
    v6 = (void ***)(v5 + 64);
  else
    v6 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  if (v9 != (FINode ***)v6)
    std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((uint64_t)v9, *v6, v6[1], v6[1] - *v6);
  v7 = TNodeFromFINode(*v2);
  TChildrenList::Clear(*(TChildrenList **)(v7 + 56));
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v8);
  TNode::RemoveChildrenDeep(v9, *(_DWORD *)(a1 + 40), v4 == 0, 0);
  v8[0] = (void **)v9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v8);
}

void sub_1CBCD21A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12)
{
  a9 = (void **)&a12;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c180_ZTSKZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEvEUlvE_(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c180_ZTSKZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEvEUlvE_(uint64_t a1)
{

}

void std::vector<std::pair<std::reference_wrapper<TNodePtr>,void({block_pointer} {__strong})(void)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void *v5;
  id *v6;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 2;

        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString &,TCatalogInfo &,void>@<X0>(char *a1@<X1>, const TString *a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString &,TCatalogInfo &,std::allocator<TFSInfo>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1CBCD22F8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString &,TCatalogInfo &,std::allocator<TFSInfo>,0>(_QWORD *a1, char *a2, const TString *a3, unsigned __int8 *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, a3, a4);
  return a1;
}

void sub_1CBCD2348(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<TString,false>::__optional_destruct_base[abi:ne180100]<TString>(uint64_t a1, CFTypeRef *a2)
{
  *(_QWORD *)a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  *(_BYTE *)(a1 + 8) = 1;
  return a1;
}

uint64_t *AppNapNodeSet(void)
{
  unsigned __int8 v0;

  {
    qword_1EF9B9AE0 = 0;
    qword_1EF9B9AD8 = 0;
    AppNapNodeSet(void)::sAppNappSet = (uint64_t)&qword_1EF9B9AD8;
  }
  return &AppNapNodeSet(void)::sAppNappSet;
}

uint64_t TNode::FirmlinkParents(TNode *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_DWORD *)(v3 + 32) = 1065353216;
    TNode::FirmlinkParents(void)::map = v3;
  }
  return TNode::FirmlinkParents(void)::map;
}

void sub_1CBCD2484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::AddToAppNapCache(TNode *this)
{
  TNodePtr v2;

  AppNapNodeSet();
  TNodePtr::TNodePtr(&v2, this);
  std::__tree<TNodePtr>::__emplace_unique_key_args<TNodePtr,TNodePtr>((uint64_t **)&AppNapNodeSet(void)::sAppNappSet, &v2.fFINode, (id *)&v2.fFINode);

}

void sub_1CBCD24EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

unint64_t TNode::IsVolume(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v3)
  {
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return (v8 >> 8) & 1;
}

id TNode::CopyInlineProgress(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TProgressInfo *v6;
  int Progress;
  id ProgressDictionary;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  TNodePtr v16;
  TNodePtr v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD v25[2];
  const __CFString *v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v29 = *((_QWORD *)this + 2);
  v30 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v17.fFINode = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25[0] = 0;
  *(_QWORD *)((char *)v25 + 7) = 0;
  v26 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v27 = 0u;
  v28 = 0u;
  TNodePtr::TNodePtr(&v16, this);
  Progress = TProgressMap::GetProgress((TProgressMap *)&v16, &v17, v6);

  if (Progress)
    ProgressDictionary = TProgressInfo::CreateProgressDictionary((TProgressInfo *)&v17);
  else
    ProgressDictionary = 0;

  v9 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v26);
  v12 = v30;
  if (v30)
  {
    v13 = (unint64_t *)&v30->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return ProgressDictionary;
}

void sub_1CBCD2710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  TProgressInfo::~TProgressInfo((TProgressInfo *)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2 - 48);
  _Unwind_Resume(a1);
}

void TNode::Name(TNode *this@<X0>, TString *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = (TFSInfo *)*((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  TFSInfo::Name(v6, a2);
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBCD27FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<DSBladeRunnerFlags>(uint64_t a1, _DWORD *a2)
{
  int v2;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_48;
      goto LABEL_45;
    case 2:
      if (v2 != 2)
        goto LABEL_48;
      goto LABEL_45;
    case 3:
      if (v2 != 3)
        goto LABEL_48;
      goto LABEL_45;
    case 4:
      if (v2 != 4)
        goto LABEL_48;
      goto LABEL_45;
    case 5:
      if (v2 != 5)
        goto LABEL_48;
      result = 0;
      **(_QWORD **)a1 = *a2;
      break;
    case 6:
      if (v2 != 6)
        goto LABEL_48;
      goto LABEL_45;
    case 7:
      if (v2 != 7)
        goto LABEL_48;
      goto LABEL_45;
    case 8:
      if (v2 != 8)
        goto LABEL_48;
      goto LABEL_45;
    case 9:
      if (v2 != 9)
        goto LABEL_48;
      goto LABEL_45;
    case 10:
      if (v2 != 10)
        goto LABEL_48;
      goto LABEL_45;
    case 11:
      if (v2 != 11)
        goto LABEL_48;
      goto LABEL_45;
    case 12:
      if (v2 != 12)
        goto LABEL_48;
      goto LABEL_45;
    case 13:
      if (v2 != 13)
        goto LABEL_48;
      goto LABEL_45;
    case 14:
      if (v2 != 14)
        goto LABEL_48;
      goto LABEL_45;
    case 15:
      if (v2 != 15)
        goto LABEL_48;
      goto LABEL_45;
    case 16:
      if (v2 != 16)
        goto LABEL_48;
      goto LABEL_45;
    case 17:
      if (v2 != 17)
        goto LABEL_48;
      goto LABEL_45;
    case 18:
      if (v2 != 18)
        goto LABEL_48;
      goto LABEL_45;
    case 19:
      if (v2 != 19)
        goto LABEL_48;
      result = TPropertyValue::SetAs<DSBladeRunnerFlags>(*(_DWORD **)a1, a2);
      break;
    case 20:
      if (v2 != 20)
        goto LABEL_48;
      goto LABEL_45;
    case 21:
      if (v2 != 21)
        goto LABEL_48;
      goto LABEL_47;
    case 22:
      if (v2 == 22)
        goto LABEL_45;
      goto LABEL_48;
    case 23:
      if (v2 != 23)
LABEL_48:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_45:
      result = 4294959246;
      break;
  }
  return result;
}

id TNode::GetFIProvider(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  int v9;
  id v10;
  TNode *v11;
  unint64_t *v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  os_unfair_lock_s *v21;
  uint64_t v22;
  int v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  os_unfair_lock_s *v27;
  void *v28;
  void *v29;
  void *v30;
  unsigned __int8 v32;
  TNodePtr v33;
  id v34;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 96));
  v8 = *(_QWORD *)(v4 + 80);
  if (v8
    && (os_unfair_lock_lock((os_unfair_lock_t)(v8 + 72)),
        v9 = *(unsigned __int8 *)(v8 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 72)),
        v9 == 1))
  {
    v10 = *(id *)(v8 + 24);
  }
  else
  {
    v10 = 0;
  }
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_12;
  v12 = (unint64_t *)&v3->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if (v10)
      return v10;
  }
  else
  {
LABEL_12:
    if (v10)
      return v10;
  }
  v14 = (os_unfair_lock_s *)TNode::ParentLock(v11);
  os_unfair_lock_lock(v14);
  TNodePtr::TNodePtr((TNodePtr *)&v34, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v14);
  while (TNodeFromFINode((FINode *)v34))
  {
    v15 = TNodeFromFINode((FINode *)v34);
    v16 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v15);
    os_unfair_lock_lock(v16);
    v18 = *(_QWORD *)(v15 + 16);
    v17 = *(std::__shared_weak_count **)(v15 + 24);
    if (v17)
    {
      v19 = (unint64_t *)&v17->__shared_owners_;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    os_unfair_lock_unlock(v16);
    v21 = (os_unfair_lock_s *)(v18 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(v18 + 96));
    v22 = *(_QWORD *)(v18 + 80);
    if (v22
      && (os_unfair_lock_lock((os_unfair_lock_t)(v22 + 72)),
          v23 = *(unsigned __int8 *)(v22 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v22 + 72)),
          v23 == 1))
    {
      v10 = *(id *)(v22 + 24);
    }
    else
    {
      v10 = 0;
    }
    os_unfair_lock_unlock(v21);
    if (v17)
    {
      v24 = (unint64_t *)&v17->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    if (v10)
    {

      return v10;
    }
    v26 = TNodeFromFINode((FINode *)v34);
    v27 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v26);
    os_unfair_lock_lock(v27);
    TNodePtr::TNodePtr(&v33, *(const TNode **)(v26 + 48));
    os_unfair_lock_unlock(v27);
    TNodePtr::operator=(&v34, (void **)&v33.fFINode);

  }
  FINodeFromTNode(this);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v28, "_uiParent");
  v29 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v29)
    return 0;
  while (1)
  {
    objc_cast<FILocalStorageNode,FINode * {__strong}>(v29);
    v30 = (void *)objc_claimAutoreleasedReturnValue();

    if (v30)
      break;
    objc_msgSend(v29, "_uiParent");
    v10 = (id)objc_claimAutoreleasedReturnValue();

    v29 = v10;
    if (!v10)
      return v10;
  }
  {
    TString::TString((TString *)&TNode::GetFIProvider(void)const::kLocalStorageID, "com.apple.FileProvider.LocalStorage");
  }
  +[FIProviderDomain providerDomainForID:cachePolicy:error:](FIProviderDomain, "providerDomainForID:cachePolicy:error:", TNode::GetFIProvider(void)const::kLocalStorageID, 3, 0);
  v10 = (id)objc_claimAutoreleasedReturnValue();

  return v10;
}

void sub_1CBCD2CA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TNode::SetVolumeInfo(TNode *a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(a1);
  os_unfair_lock_lock(v4);
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1, a2);
  os_unfair_lock_unlock(v4);
}

int *TNode::OperationLockLock(TNode *this)
{
  unsigned __int8 v1;

  {
    TNode::OperationLockLock(void)::sOperationLockLock = 0;
  }
  return &TNode::OperationLockLock(void)::sOperationLockLock;
}

BOOL TNode::IsSynchingAppropriate(TNode *this)
{
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  uint32_t os_unfair_lock_opaque;
  _BOOL8 v5;

  v2 = (os_unfair_lock_s *)TNode::OperationLockLock(this);
  os_unfair_lock_lock(v2);
  v3 = (os_unfair_lock_s *)*((_QWORD *)this + 5);
  if (v3)
  {
    os_unfair_lock_lock(v3);
    os_unfair_lock_opaque = v3[5]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v3);
    if (os_unfair_lock_opaque)
    {
      v5 = 0;
    }
    else
    {
      os_unfair_lock_lock(v3);
      v5 = !v3[1]._os_unfair_lock_opaque && !v3[4]._os_unfair_lock_opaque && v3[3]._os_unfair_lock_opaque == 0;
      os_unfair_lock_unlock(v3);
    }
  }
  else
  {
    v5 = 1;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

BOOL TNode::SynchingSuspended(TNode *this)
{
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  _BOOL8 v4;

  v2 = (os_unfair_lock_s *)TNode::OperationLockLock(this);
  os_unfair_lock_lock(v2);
  v3 = (os_unfair_lock_s *)*((_QWORD *)this + 5);
  if (v3)
  {
    os_unfair_lock_lock(*((os_unfair_lock_t *)this + 5));
    v4 = v3[5]._os_unfair_lock_opaque != 0;
    os_unfair_lock_unlock(v3);
  }
  else
  {
    v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

const void **TNode::Path@<X0>(TNode *this@<X0>, CFTypeRef *a2@<X8>)
{
  TString v4;
  const void *v5[2];

  TNode::GetPath(this, (uint64_t)v5);
  TString::TString(&v4, "", 0);
  fstd::optional_err<TString,int>::value_or<TString>((uint64_t)v5, (CFTypeRef *)&v4.fString.fRef, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
}

void sub_1CBCD2F08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

unint64_t TNode::IsContainer(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v3)
  {
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return (v8 >> 5) & 1;
}

uint64_t TNode::SetComputerName(TNode *this, const TString *a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  TString v13;
  TFSInfo *v14;
  std::__shared_weak_count *v15;
  TNodePtr v16;
  unsigned int v17;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = (TFSInfo *)*((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v14 = v6;
  v15 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  SlashesToColons(a2, &v13);
  TFSInfo::Rename(v6, &v13, 0, (uint64_t)&v16);
  v9 = v17;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fFINode);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  if (v5)
  {
    v10 = (unint64_t *)&v5->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  TNodePtr::TNodePtr(&v16, this);
  TNode::SendNotification(this, 2, (id *)&v16.fFINode, 1886282093, 0);

  return v9;
}

void sub_1CBCD30E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void TNode::Finalize(void *a1)
{
  TFSInfo *v1;
  id v2;

  v2 = a1;
  AppNapNodeSet();
  std::__tree<TNodePtr>::destroy((uint64_t)&AppNapNodeSet(void)::sAppNappSet, (_QWORD *)qword_1EF9B9AD8);
  AppNapNodeSet(void)::sAppNappSet = (uint64_t)&qword_1EF9B9AD8;
  qword_1EF9B9AE0 = 0;
  qword_1EF9B9AD8 = 0;
  TGlobalNodes::FinalizeNodes(v2);
  TNode::FinalizeNWMaps((TNode *)+[FIPresentationNodeMap finalize](FIPresentationNodeMap, "finalize"));
  TFSInfo::Finalize(v1);

}

void sub_1CBCD3184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void TNode::FinalizeNWMaps(TNode *this)
{
  uint64_t v1;
  uint64_t v2;

  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  if (gNWSidebarNodeMap)
  {
    v1 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::~__hash_table(gNWSidebarNodeMap);
    MEMORY[0x1D17A53D0](v1, 0x10A0C408EF24B1CLL);
  }
  gNWSidebarNodeMap = 0;
  if (gAirDropNodeMap)
  {
    v2 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::~__hash_table(gAirDropNodeMap);
    MEMORY[0x1D17A53D0](v2, 0x10A0C408EF24B1CLL);
  }
  gAirDropNodeMap = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

unint64_t TFSInfo::IsMountTrigger(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 15) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TNode::IsNetworkNode(TNode *this, TGlobalNodes *a2)
{
  const TNodePtr *v3;
  uint64_t IsNetworkNode;
  TNodePtr v6;

  TNodePtr::TNodePtr(&v6, this);
  IsNetworkNode = TGlobalNodes::IsNetworkNode(a2, &v6.fFINode, v3);

  return IsNetworkNode;
}

void sub_1CBCD32A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNode::GetParent(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v4);
  TNodePtr::TNodePtr(a2, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v4);
}

void sub_1CBCD32F8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TNode::GetNetworkNode(TNode *this@<X0>, void **a2@<X8>)
{
  void *v3;

  *a2 = 0;
  switch((_DWORD)this)
  {
    case 0x6D74726D:
      TGlobalNodes::AirDropNode(&v3);
      break;
    case 0x6E747362:
      TGlobalNodes::NetworkSidebarNode(&v3);
      break;
    case 0x6E74776B:
      TGlobalNodes::NetworkNearbyNode(&v3);
      break;
    default:
      return;
  }
  TNodePtr::operator=(a2, &v3);

}

void sub_1CBCD3398(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void TNode::ComputerNameChangedCallback(TNode *this, const __SCDynamicStore *a2, const __CFArray *a3, void *a4)
{
  const TNode *v4;
  TPropertyValue v5;
  FINode *v6;

  TGlobalNodes::RootNode((uint64_t *)&v6);
  v4 = (const TNode *)TNodeFromFINode(v6);
  memset(&v5, 0, sizeof(v5));
  TNode::RequestInternalTask(v4, 1023, &v5, 0);
  TPropertyValue::~TPropertyValue(&v5);

}

void sub_1CBCD340C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);

  _Unwind_Resume(a1);
}

void TNode::HandleSyncComputerName(TNode *this)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  FINode *v3;
  FINode *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int v9;
  TNode *v10;
  TString v11;
  TString v12;
  FINode *v13[3];

  TGlobalNodes::RootNode((uint64_t *)v13, (TGlobalNodes *)this);
  TGlobalNodes::ComputerName(&v12);
  v1 = TNodeFromFINode(v13[0]);
  v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v1);
  os_unfair_lock_lock(v2);
  v4 = *(FINode **)(v1 + 16);
  v3 = *(FINode **)(v1 + 24);
  v13[1] = v4;
  v13[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)&v3[1];
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::Name((TFSInfo *)v4, &v11);
  if (v3)
  {
    v7 = (unint64_t *)&v3[1];
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      (*((void (**)(FINode *))v3->super.isa + 2))(v3);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v3);
    }
  }
  v9 = CFEqual(v11.fString.fRef, v12.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
  if (!v9)
  {
    v10 = (TNode *)TNodeFromFINode(v13[0]);
    TNode::SetComputerName(v10, &v12);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);

}

void sub_1CBCD3520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, id a12)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);

  _Unwind_Resume(a1);
}

BOOL TNode::VolumeHasNoVolumeSizes(TNode *this)
{
  std::__shared_weak_count *v1;
  int v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;

  TNode::GetVolumeInfo(this, &v6);
  v1 = v7;
  v2 = *(unsigned __int8 *)(v6 + 115);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  return v2 != 0;
}

BOOL TNode::VolumeIsReadOnly(TNode *this)
{
  std::__shared_weak_count *v1;
  int v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;

  TNode::GetVolumeInfo(this, &v6);
  v1 = v7;
  v2 = *(unsigned __int8 *)(v6 + 104);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  return v2 != 0;
}

BOOL TNode::VolumeSupportsACLs(TNode *this)
{
  std::__shared_weak_count *v1;
  int v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;

  TNode::GetVolumeInfo(this, &v6);
  v1 = v7;
  v2 = *(unsigned __int8 *)(v6 + 118);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  return v2 != 0;
}

__CFURL *TNode::CopyURL(TNode *this)
{
  __CFURL *v2;

  v2 = 0;
  TNode::CopyURL(this, &v2);
  return v2;
}

uint64_t TPropertyValue::TPropertyValue<__CFURL const*>(uint64_t a1, const void **a2)
{
  const void *v3;
  const void *v5;

  v3 = *a2;
  v5 = v3;
  if (v3)
    CFRetain(v3);
  TPropertyValue::TPropertyValue<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(a1, &v5);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v5);
  return a1;
}

void sub_1CBCD3720(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::GetVolume(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  uint64_t v5;
  FINode *v6;

  TGlobalNodes::RootNode((uint64_t *)&v6, (TGlobalNodes *)this);
  v5 = TNodeFromFINode(v6);
  TChildrenList::FindDisplayName(*(TChildrenList **)(v5 + 56), (const TString *)this, a2);

}

void sub_1CBCD3784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNode::FindFPv2Child(TNode *this@<X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  FPItem *v5;
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  os_unfair_lock_s *v11;
  int v12;
  TNode *v13;
  unint64_t *v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  TFSInfo *v18;
  unint64_t *v19;
  unint64_t v20;
  BOOL IsFPv2;
  BOOL v22;
  unint64_t *v23;
  unint64_t v24;
  TChildrenList *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  TFSInfo *v34;
  std::__shared_weak_count *v35;
  TNodePtr v36;
  TFSInfo *v37;
  std::__shared_weak_count *v38;

  v5 = a2;
  v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v5);
  os_unfair_lock_lock(v6);
  v8 = *((_QWORD *)this + 2);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v6);
  v11 = (os_unfair_lock_s *)(v8 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  v12 = *(_DWORD *)(v8 + 115);
  os_unfair_lock_unlock(v11);
  if (!v7)
    goto LABEL_8;
  v14 = (unint64_t *)&v7->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v5)
      goto LABEL_30;
  }
  else
  {
LABEL_8:
    if (!v5)
      goto LABEL_30;
  }
  if ((v12 & 0x20) == 0)
    goto LABEL_30;
  v16 = (os_unfair_lock_s *)TNode::InfoLock(v13);
  os_unfair_lock_lock(v16);
  v18 = (TFSInfo *)*((_QWORD *)this + 2);
  v17 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v37 = v18;
  v38 = v17;
  if (v17)
  {
    v19 = (unint64_t *)&v17->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  os_unfair_lock_unlock(v16);
  IsFPv2 = TFSInfo::IsFPv2(v18, 1);
  v22 = IsFPv2;
  if (v17)
  {
    v23 = (unint64_t *)&v17->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
      if (v22)
        goto LABEL_18;
LABEL_30:
      TNodePtr::TNodePtr(a3, 0);
      goto LABEL_31;
    }
  }
  if (!IsFPv2)
    goto LABEL_30;
LABEL_18:
  a3->fFINode = 0;
  TNodePtr::TNodePtr(&v36, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v37, &v36, 0);

  v25 = (TChildrenList *)*((_QWORD *)this + 7);
  if (v25)
  {
    TChildrenList::FindByFPItem(v25, v5, &v36);
    TNodePtr::operator=((void **)&a3->fFINode, (void **)&v36.fFINode);

  }
  TNode::StPopulating::~StPopulating((FINode **)&v37);
  if (!TNodeFromFINode(a3->fFINode))
  {
    _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v37);
    if (!TFSInfo::Initialize(v37, v5, 0))
    {
      v34 = v37;
      v35 = v38;
      if (v38)
      {
        v29 = (unint64_t *)&v38->__shared_owners_;
        do
          v30 = __ldxr(v29);
        while (__stxr(v30 + 1, v29));
      }
      TNode::FindOrCreateChild(this, &v34, &v36);
      TNodePtr::operator=((void **)&a3->fFINode, (void **)&v36.fFINode);

      v31 = v35;
      if (v35)
      {
        v32 = (unint64_t *)&v35->__shared_owners_;
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
    }
    v26 = v38;
    if (v38)
    {
      v27 = (unint64_t *)&v38->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
LABEL_31:

}

void sub_1CBCD3A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  void *v12;
  id *v13;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a12);

  _Unwind_Resume(a1);
}

uint64_t TNode::CopyPathToCBuffer(TNode *this, char *a2, CFIndex a3)
{
  uint64_t v5;
  const __CFString *v6;
  CFTypeRef v7;
  CFTypeRef v8;
  CFTypeRef cf;
  unsigned int v11;

  TNode::GetPath(this, (uint64_t)&cf);
  v5 = v11;
  if (!v11)
  {
    v6 = (const __CFString *)cf;
    if (cf)
    {
      v7 = CFRetain(cf);
      v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v7);
      if (v6)
      {
        v8 = CFAutorelease(v6);
        v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v8);
      }
    }
    if (CFStringGetCString(v6, a2, a3, 0x8000100u))
      v5 = v11;
    else
      v5 = 4294959236;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  return v5;
}

void sub_1CBCD3B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void **TNode::GetPath@<X0>(TNode *this@<X0>, uint64_t a2@<X8>)
{
  int FullPOSIXPathDetails;
  TString v6;

  v6.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  FullPOSIXPathDetails = TNode::GetFullPOSIXPathDetails((uint64_t)this, &v6);
  fstd::optional_err<TString,int>::optional_err(a2, (TString **)&v6, &FullPOSIXPathDetails);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
}

void sub_1CBCD3BC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::DisplayName(TNode *this@<X0>, TString *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = (TFSInfo *)*((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  TFSInfo::DisplayName(v6, a2);
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBCD3C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL TNode::IsAlias(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  TFSInfo *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _BOOL8 IsAlias;
  unint64_t *v8;
  unint64_t v9;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = (TFSInfo *)*((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  IsAlias = TFSInfo::IsAlias(v4);
  if (v3)
  {
    v8 = (unint64_t *)&v3->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return IsAlias;
}

void sub_1CBCD3D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TNode::ProviderNodeForProviderDomainID(TNode *this@<X0>, _QWORD *a2@<X8>)
{
  TNode *v4;
  TNode *v5;
  FINode **v6;
  FINode **v7;
  TNode *v8;
  void *v9;
  void *v10;
  char v11;
  char v12;
  id v13;
  FINode **v14;
  FINode **v15;
  FINode *v16;
  FINode *v17;
  char v18;

  v4 = this;
  TGlobalNodes::AllProvidersNode(&v16);
  v5 = (TNode *)TNodeFromFINode(v16);
  TNode::CopyChildren(v5, (uint64_t)&v14);
  v13 = 0;
  v6 = v14;
  v7 = v15;
  if (v14 == v15)
    goto LABEL_7;
  while (1)
  {
    v8 = (TNode *)TNodeFromFINode(*v6);
    TNode::GetFIProvider(v8);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "identifier");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = -[TNode isEqual:](v4, "isEqual:", v10);

    if ((v11 & 1) != 0)
      break;
    if (++v6 == v7)
    {
      v6 = v7;
      break;
    }
  }
  if (v6 == v15)
  {
LABEL_7:
    v12 = 0;
    LOBYTE(v17) = 0;
  }
  else
  {
    v17 = *v6;
    v12 = 1;
  }
  v18 = v12;
  std::optional<TNodePtr>::value_or[abi:ne180100]<TNodePtr const&>((uint64_t)&v17, &v13, a2);
  if (v18)

  v17 = (FINode *)&v14;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);

}

void sub_1CBCD3E80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TNode::ProviderNodeForProviderDomain(void *a1@<X0>, int a2@<W1>, void **a3@<X8>)
{
  id v5;
  unsigned __int8 v6;
  TNode *v7;
  uint64_t v8;
  TString *v9;
  uint64_t **v10;
  char v11;
  uint64_t v12;
  TNode *v13;
  TNode *v14;
  void *v15;
  double v16;
  TString ***v17;
  uint64_t v18;
  id v19;
  id v20[2];
  FINode *v21;
  id location;
  TString **p_location;
  id v24;
  TString ***p_p_location;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if ((v6 & 1) == 0
  {
    TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard = 0u;
    unk_1EF9B9B18 = 0u;
    dword_1EF9B9B28 = 1065353216;
  }
  objc_msgSend(v5, "identifier");
  v7 = (TNode *)objc_claimAutoreleasedReturnValue();
  TNode::ProviderNodeForProviderDomainID(v7, a3);

  v8 = TNodeFromFINode((FINode *)*a3);
  if ((a2 & 0x80) == 0 && !v8)
  {
    objc_msgSend(v5, "identifier");
    v9 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    location = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&location, v9);

    std::mutex::lock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
    p_location = (TString **)&location;
    v10 = std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard, (TString *)&location, (uint64_t)&std::piecewise_construct, &p_location);
    p_location = (TString **)pthread_self();
    std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__emplace_unique_key_args<_opaque_pthread_t *,_opaque_pthread_t *>((uint64_t)(v10 + 3), &p_location, &p_location);
    LOBYTE(v10) = v11;
    std::mutex::unlock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
    if ((v10 & 1) != 0)
    {
      p_location = (TString **)&location;
      TGlobalNodes::AllProvidersNode(&v21);
      v12 = TNodeFromFINode(v21);
      TNode::HandleSync(v12, 0x100u);

      objc_msgSend(v5, "identifier");
      v13 = (TNode *)objc_claimAutoreleasedReturnValue();
      TNode::ProviderNodeForProviderDomainID(v13, &v21);
      TNodePtr::operator=(a3, (void **)&v21);

      StDefer<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_0,(void *)0>::~StDefer((TString **)&p_location);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&location);
  }
  if (TNodeFromFINode((FINode *)*a3))
  {
    v14 = (TNode *)TNodeFromFINode((FINode *)*a3);
    TNode::GetFPItem(v14);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    if (v15)
    {
LABEL_20:

      goto LABEL_21;
    }
    if (objc_msgSend(v5, "expectFPItems"))
    {
      objc_msgSend(v5, "domain");
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v15)
      {
        objc_msgSend(v5, "asyncFetchedDomain");
        v15 = (void *)objc_claimAutoreleasedReturnValue();
      }
      objc_initWeak(&location, *a3);
      v16 = 1000.0;
      if ((a2 & 0x40000) == 0)
        v16 = 5.0;
      v21 = *(FINode **)&v16;
      objc_copyWeak(&v19, &location);
      p_p_location = 0;
      p_location = (TString **)&off_1E874ECB8;
      objc_moveWeak(&v24, &v19);
      p_p_location = &p_location;
      objc_destroyWeak(&v19);
      TNode::RootFPItemForDomainWithTimeout(v15, (double *)&v21, (uint64_t)&p_location, v20);

      v17 = p_p_location;
      if (p_p_location == &p_location)
      {
        v18 = 4;
        v17 = &p_location;
      }
      else
      {
        if (!p_p_location)
        {
LABEL_19:
          objc_destroyWeak(&location);
          goto LABEL_20;
        }
        v18 = 5;
      }
      ((void (*)(void))(*v17)[v18])();
      goto LABEL_19;
    }
  }
LABEL_21:

}

void sub_1CBCD41D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id location, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  void *v17;
  id *v18;

  _Unwind_Resume(a1);
}

TString **StDefer<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_0,(void *)0>::~StDefer(TString **a1)
{
  uint64_t *v2;
  pthread_t v4;

  std::mutex::lock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
  v2 = (uint64_t *)std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard, *a1);
  if (v2)
  {
    v4 = pthread_self();
    std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__erase_unique<_opaque_pthread_t *>(v2 + 3, &v4);
    if (!v2[6])
      std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::erase(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard, v2);
  }
  std::mutex::unlock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
  return a1;
}

void sub_1CBCD4364(void *a1)
{
  __clang_call_terminate(a1);
}

void TNode::RootFPItemForDomainWithTimeout(void *a1@<X0>, double *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  id v7;
  void *v8;
  void *v9;
  void ***v10;
  uint64_t v11;
  void ***v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD v18[3];
  _QWORD *v19;
  void **v20[3];
  void ***v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (v7)
  {
    v22[0] = v7;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v22, 1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v18, a3);
    v21 = 0;
    v10 = (void ***)operator new(0x28uLL);
    *v10 = (void **)&off_1E8750130;
    v11 = (uint64_t)v19;
    if (v19)
    {
      if (v19 == v18)
      {
        v10[4] = (void **)(v10 + 1);
        (*(void (**)(_QWORD *))(v18[0] + 24))(v18);
LABEL_8:
        v21 = v10;
        TNode::RootFPItemsForDomainsWithTimeout(v9, a2, (uint64_t)v20, (uint64_t)v17);
        v12 = v21;
        if (v21 == v20)
        {
          v13 = 4;
          v12 = v20;
        }
        else
        {
          if (!v21)
            goto LABEL_13;
          v13 = 5;
        }
        ((void (*)(void))(*v12)[v13])();
LABEL_13:
        v14 = v19;
        if (v19 == v18)
        {
          v15 = 4;
          v14 = v18;
        }
        else
        {
          if (!v19)
          {
LABEL_18:

            v16 = v17[0];
            *a4 = *(id *)v17[0];
            a4[1] = *(id *)(v16 + 8);
            v20[0] = (void **)v17;
            std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](v20);
            goto LABEL_19;
          }
          v15 = 5;
        }
        (*(void (**)(void))(*v14 + 8 * v15))();
        goto LABEL_18;
      }
      v11 = (*(uint64_t (**)(void))(*v19 + 16))();
    }
    v10[4] = (void **)v11;
    goto LABEL_8;
  }
  std::function<void ()(FPItem *,NSError *)>::operator()(a3, 0, 0);
  *a4 = 0;
  a4[1] = 0;
LABEL_19:

}

void sub_1CBCD4548(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL TNode::IsInTrash(TNode *this)
{
  _BOOL8 v2;
  CFIndex Length;
  CFIndex v5;
  int CharacterAtIndex;
  CFStringRef v7;
  char v8;
  CFStringRef theString;
  int v10;

  TNode::GetPath((uint64_t)this, 1, (uint64_t)&theString);
  v2 = 0;
  if (!v10)
  {
    TNode::TrashPathForNode(this, &v7);
    if (v8)
    {
      v2 = 0;
      if (TString::BeginsWith((TString *)&theString, (const TString *)&v7))
      {
        Length = CFStringGetLength(theString);
        if (Length == CFStringGetLength(v7)
          || ((v5 = CFStringGetLength(v7), v5 < 0) || CFStringGetLength(theString) <= v5
            ? (CharacterAtIndex = 0)
            : (CharacterAtIndex = CFStringGetCharacterAtIndex(theString, v5)),
              CharacterAtIndex == (unsigned __int16)TPathName::kPOSIXPathNameSeparator))
        {
          v2 = 1;
        }
      }
      if (v8)
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7);
    }
    else
    {
      v2 = 0;
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v2;
}

void sub_1CBCD46E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::ClearAliasTarget(TNode *this, BOOL a2)
{
  TNodePtr v4;

  TNodePtr::TNodePtr(&v4, 0);
  TNode::SetAliasTarget(this, &v4, a2);

}

void sub_1CBCD4760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNode::SetUnresolvedTarget(TNode *this)
{
  FINode *v2;
  uint64_t v3;
  TNode *v4;
  os_unfair_lock_s *v5;
  FINode *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unsigned int v10;
  CFTypeRef v11;
  int IsContainer;
  int v13;
  unint64_t *v14;
  unint64_t v15;
  int v16;
  CFTypeRef cf;
  FINode *v18[2];
  TString v19;
  BOOL v20[2];

  TNode::GetAliasTarget(this, v18);
  v2 = v18[0];
  v3 = TNodeFromFINode(v18[0]);

  if (v3)
    return;
  *(_WORD *)v20 = 0;
  v19.fString.fRef = &stru_1E8752DF8;
  v4 = (TNode *)CFRetain(&stru_1E8752DF8);
  v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  v7 = *((_QWORD *)this + 2);
  v6 = (FINode *)*((_QWORD *)this + 3);
  v18[0] = (FINode *)v7;
  v18[1] = v6;
  if (v6)
  {
    v8 = (unint64_t *)&v6[1];
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v5);
  v10 = *(unsigned __int8 *)(v7 + 112);
  if (v10 > 0x11)
  {
    if (v10 != 18 && v10 != 35)
      goto LABEL_13;
  }
  else if (*(_BYTE *)(v7 + 112))
  {
    if (v10 == 7)
    {
      TNode::DisplayName(this, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v19.fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      v11 = cf;
      if (cf)
        goto LABEL_14;
      goto LABEL_15;
    }
LABEL_13:
    TNode::DisplayName(this, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v19.fString.fRef, &cf);
    CFRetain(&stru_1E8752DF8);
    v11 = cf;
    if (cf)
LABEL_14:
      CFRelease(v11);
LABEL_15:
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    goto LABEL_16;
  }
  TFSInfo::GetAliasInfoFrom((TFSInfo *)v7, &v20[1], v20, 0, &v19);
LABEL_16:
  v16 = 0;
  IsContainer = TNode::AliasIsContainer(this);
  if (v20[0])
    v13 = 1;
  else
    v13 = IsContainer;
  if (v13 == 1)
    LOBYTE(v16) = 1;
  if (v20[1])
    BYTE1(v16) = 1;
  TNode::GetUnresolvedNode(&v19, (unsigned __int8 *)&v16, &cf);
  TNode::SetAliasTarget(this, (const TNodePtr *)&cf, 1);

  if (v6)
  {
    v14 = (unint64_t *)&v6[1];
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      (*((void (**)(FINode *))v6->super.isa + 2))(v6);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v6);
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
}

void sub_1CBCD495C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

void TNode::GetUnresolvedNode(const TString *a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  TNodePtr v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  LOBYTE(v12.fFINode) = 16;
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString const&,TCatalogInfo const&,void>((char *)&v12, a1, a2, &v13);
  TNodePtr::TNodePtr(&v12, 0);
  v10 = 0;
  v11 = 0;
  TNode::CreateNode(a3, &v12, &v13, &v10);
  v4 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  v7 = v14;
  if (v14)
  {
    v8 = (unint64_t *)&v14->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1CBCD4A94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  id v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, id);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t TNode::OpenScreenShareSync(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TNode *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v15;

  v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v2);
  v3 = *(std::__shared_weak_count **)(a1 + 24);
  v15 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    os_unfair_lock_unlock(v7);
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  else
  {
    os_unfair_lock_unlock(v7);
  }
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return 4294959224;
}

void sub_1CBCD4BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::IsNetworkNeighborhood(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  return 0;
}

uint64_t TNode::OpenServerSync(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TNode *v6;
  unint64_t v7;
  os_unfair_lock_s *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;

  v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v2);
  v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  v8 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v8);
  v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    os_unfair_lock_unlock(v8);
    do
      v12 = __ldaxr(v10);
    while (__stlxr(v12 - 1, v10));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  else
  {
    os_unfair_lock_unlock(v8);
  }
  return 4294959224;
}

void TNode::CloseNodeBrowserIfNecessary(TNode *this, int a2)
{
  uint64_t NotifierList;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  TNode *v10;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  TNode *v15;
  unint64_t v16;
  os_unfair_lock_s *v17;
  std::__shared_weak_count *v18;
  id *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  os_unfair_lock_t v24;
  unsigned __int16 *v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unint64_t *v28;
  unint64_t v29;
  id *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  TFSInfo *v33;
  os_unfair_lock_t lock;
  std::__shared_weak_count *v35;
  id **v36;

  NotifierList = TNode::GetNotifierList(this);
  v6 = *(_QWORD *)(NotifierList + 24);
  v5 = *(std::__shared_weak_count **)(NotifierList + 32);
  lock = (os_unfair_lock_t)v6;
  v35 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_lock((os_unfair_lock_t)v6);
  v9 = *(unsigned __int8 *)(v6 + 5);
  os_unfair_lock_unlock((os_unfair_lock_t)v6);
  if (v9)
  {
    v11 = (os_unfair_lock_s *)TNode::InfoLock(v10);
    os_unfair_lock_lock(v11);
    v12 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    if (v12)
    {
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      os_unfair_lock_unlock(v11);
      do
        v16 = __ldaxr(v13);
      while (__stlxr(v16 - 1, v13));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    else
    {
      os_unfair_lock_unlock(v11);
    }
    v33 = 0;
    v17 = (os_unfair_lock_s *)TNode::InfoLock(v15);
    os_unfair_lock_lock(v17);
    v19 = (id *)*((_QWORD *)this + 2);
    v18 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v30 = v19;
    v31 = v18;
    if (v18)
    {
      v20 = (unint64_t *)&v18->__shared_owners_;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    os_unfair_lock_unlock(v17);
    v36 = (id **)TFSInfo::CopySFBrowserRef((TFSInfo *)v19);
    TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::operator=<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>((const void **)&v33, (const void **)&v36);
    TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)&v36);
    if (v18)
    {
      v22 = (unint64_t *)&v18->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    LOBYTE(v30) = 0;
    TFSInfo::BrowserCloseNode(v33, 0, (BOOL *)&v30);
    v24 = lock;
    os_unfair_lock_lock(lock);
    BYTE1(v24[1]._os_unfair_lock_opaque) = 0;
    os_unfair_lock_unlock(v24);
    v25 = (unsigned __int16 *)((char *)this + 80);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 & 0xFFF7, v25));
    do
      v27 = __ldaxr(v25);
    while (__stlxr(v27 & 0xFFEF, v25));
    if (a2)
    {
      v30 = 0;
      v31 = 0;
      v32 = 0;
      TNode::RemoveAllChildren(this, 0, (TNodeEventPtrs *)&v30);
      TNodeEventPtrs::SendNotifications(&v30);
      v36 = &v30;
      std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v36);
    }
    else
    {
      TNode::RemoveAllChildren(this, 0, 0);
    }
    TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)&v33);
    v5 = v35;
  }
  if (v5)
  {
    v28 = (unint64_t *)&v5->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBCD4FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  const void *v6;
  va_list va;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, const void *);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1CBCD4FEC()
{
  JUMPOUT(0x1CBCD4FDCLL);
}

uint64_t ExternalRegistration::IsNetworkOpened(os_unfair_lock_s *this)
{
  uint64_t v2;

  os_unfair_lock_lock(this);
  v2 = BYTE1(this[1]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(this);
  return v2;
}

const void **TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::operator=<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>(const void **a1, const void **a2)
{
  const void *v4;

  if (a1 != a2)
  {
    v4 = *a1;
    if (*a1)
      CFRelease(v4);
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

BOOL TNode::RemoveAllChildren(TNode *a1, char a2, TNodeEventPtrs *a3)
{
  char v3;
  int v7;
  uint64_t v8;
  void ***v9;
  uint64_t v10;
  _QWORD *v11;
  _BOOL8 v12;
  TNodePtr v14;
  uint64_t v15;
  uint64_t v16;
  FINode *v17[3];
  TNodePtr *v18;

  v3 = atomic_load((unsigned __int16 *)a1 + 40);
  if ((v3 & 2) != 0)
    return 0;
  TNodePtr::TNodePtr(&v14, a1);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v17, &v14, 0);

  v7 = TNode::ChildRegistrationCount(a1);
  v8 = *((_QWORD *)a1 + 7);
  if (v8)
    v9 = (void ***)(v8 + 64);
  else
    v9 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  v15 = 0;
  v16 = 0;
  v14.fFINode = 0;
  std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)&v14, *v9, v9[1], v9[1] - *v9);
  TNode::RemoveChildrenDeep((FINode ***)&v14, a2, v7 == 0, a3);
  v10 = *((_QWORD *)a1 + 7);
  if (v10)
    v11 = (_QWORD *)(v10 + 64);
  else
    v11 = &TNode::GetChildren(void)const::sEmptyList;
  v12 = *v11 == v11[1];
  v18 = &v14;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  TNode::StPopulating::~StPopulating(v17);
  return v12;
}

void sub_1CBCD5170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  FINode *v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, FINode *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va1);
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

void TNode::AddNWNode(int a1, uint64_t a2, FINode **a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  id *v8;
  FINode *v9;
  uint64_t v10;
  uint64_t *v11;

  v10 = a2;
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  TNode::GetNWNodeMap(a1);
  v6 = (uint64_t)v5;
  if (!std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(v5, &v10))
  {
    TNode::GetNetworkNode((TNode *)0x6E74776B, (void **)&v9);
    v7 = TNodeFromFINode(*a3);
    if (v7 != TNodeFromFINode(v9))
    {
      v11 = &v10;
      v8 = (id *)std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__emplace_unique_key_args<__SFNode *,std::piecewise_construct_t const&,std::tuple<__SFNode * const&>,std::tuple<>>(v6, &v10, (uint64_t)&std::piecewise_construct, &v11);
      objc_storeStrong(v8 + 3, *a3);
    }

  }
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

void sub_1CBCD5278(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  _Unwind_Resume(a1);
}

uint64_t TNode::AddServerToSidebarSync(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;

  v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v2);
  v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  return 4294959224;
}

void TNode::RequestSynchronize(TGlobalNodes *a1, int a2)
{
  uint64_t v3;
  TPropertyValue v4;
  int v5;

  v5 = a2;
  TGlobalNodes::RootNode(&v4.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value, a1);
  v3 = TNodeFromFINode((FINode *)v4.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);

  if ((TGlobalNodes *)v3 != a1)
  {
    v4.fData.__impl_.__index = 0;
    std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v4, &v5);
    TNode::RequestInternalTask((const TNode *)a1, 1000, &v4, 0);
    TPropertyValue::~TPropertyValue(&v4);
  }
}

void sub_1CBCD53B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::CopyEnumeratorError(uint64_t a1, void **a2)
{
  int v4;
  TChildrenList *v5;
  void *v6;
  uint64_t v7;
  void *v8;

  v4 = TNode::VirtualType((TNode *)a1);
  if (v4 != 27 && v4)
    return 4294959224;
  v5 = *(TChildrenList **)(a1 + 56);
  if (!v5)
    return 4294959224;
  TChildrenList::GetCollectionStatusObserver(v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "fpError");
  v7 = objc_claimAutoreleasedReturnValue();
  v8 = *a2;
  *a2 = (void *)v7;

  return 0;
}

void sub_1CBCD543C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void TNode::PostFolderSizingTaskRequest(uint64_t a1, uint64_t a2, int a3)
{
  _BOOL8 IsContextOpen;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  os_unfair_lock_s *v12;
  int v13;
  TNode *v14;
  unint64_t *v15;
  unint64_t v16;
  os_unfair_lock_s *v17;
  std::__shared_weak_count *v18;
  TFSVolumeInfo *v19;
  unint64_t *v20;
  unint64_t v21;
  _BOOL4 IsAlias;
  _BOOL4 v23;
  unint64_t *v24;
  unint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  TFSVolumeInfo *v36;
  std::__shared_weak_count *v37;

  IsContextOpen = TNode::IsContextOpen((TNode *)a1);
  if (!IsContextOpen)
    return;
  v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsContextOpen);
  os_unfair_lock_lock(v7);
  v9 = *(_QWORD *)(a1 + 16);
  v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v7);
  v12 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  v13 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v12);
  if (!v8)
    goto LABEL_9;
  v15 = (unint64_t *)&v8->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if ((v13 & 0x20) == 0)
    {
LABEL_10:
      v17 = (os_unfair_lock_s *)TNode::InfoLock(v14);
      os_unfair_lock_lock(v17);
      v19 = *(TFSVolumeInfo **)(a1 + 16);
      v18 = *(std::__shared_weak_count **)(a1 + 24);
      v36 = v19;
      v37 = v18;
      if (v18)
      {
        v20 = (unint64_t *)&v18->__shared_owners_;
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }
      os_unfair_lock_unlock(v17);
      IsAlias = TFSInfo::IsAlias((TFSInfo *)v19);
      v23 = IsAlias;
      if (!v18)
        goto LABEL_17;
      v24 = (unint64_t *)&v18->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
        if (!v23)
          return;
      }
      else
      {
LABEL_17:
        if (!IsAlias)
          return;
      }
    }
  }
  else
  {
LABEL_9:
    if ((v13 & 0x20) == 0)
      goto LABEL_10;
  }
  TNode::GetVolumeInfo((TNode *)a1, &v36);
  if (v36)
  {
    v26 = (unsigned __int16 *)(a1 + 80);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 | 0x40, v26));
    if ((v27 & 0x40) == 0 || a3)
    {
      TFSVolumeInfo::GetFolderSizingThread(v36, &v34);
      if (v34)
        TFolderSizingThread::PostFolderSizingTaskRequest((uint64_t)&v34, a2);
      v28 = v35;
      if (v35)
      {
        v29 = (unint64_t *)&v35->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }
  }
  v31 = v37;
  if (v37)
  {
    v32 = (unint64_t *)&v37->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_1CBCD5660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

unint64_t TNode::IsSymlink(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v3)
  {
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return (v8 >> 6) & 1;
}

void ___ZNK5TNode16AliasIsContainerEv_block_invoke(uint64_t a1)
{
  _QWORD v1[4];
  id v2;

  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 3221225472;
  v1[2] = ___ZNK5TNode16AliasIsContainerEv_block_invoke_2;
  v1[3] = &unk_1E8751520;
  v2 = *(id *)(a1 + 32);
  ExceptionSafeBlock(v1);

}

void sub_1CBCD57A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

void sub_1CBCD5868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, TNodeRequest *a12)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);
  TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&a12);
  _Unwind_Resume(a1);
}

uint64_t TNode::UpdateSizeInfo(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  TNode *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  os_unfair_lock_s *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  TNodePtr v27;
  const TNode *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_8;
  v10 = (unint64_t *)&v3->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v8 & 0x20) == 0)
      return 0;
  }
  else
  {
LABEL_8:
    if ((v8 & 0x20) == 0)
      return 0;
  }
  v28 = this;
  v13 = (os_unfair_lock_s *)TNode::ParentLock(v9);
  os_unfair_lock_lock(v13);
  TNodePtr::TNodePtr(&v27, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v13);
  v26 = 0;
  std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNode *,TNodePtr,decltype(nullptr),void>(&v28, (uint64_t)&v27, &v29);

  v14 = v29;
  v24 = v29;
  v25 = v30;
  if (v30)
  {
    v15 = (unint64_t *)&v30->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  TFSInfoSizer::SizeFolder(v14, &v24, 0);
  v17 = v25;
  if (v25)
  {
    v18 = (unint64_t *)&v25->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v30;
  v12 = *(unsigned int *)(v29 + 64);
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return v12;
}

void sub_1CBCD5A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  _Unwind_Resume(a1);
}

void TNode::RecalculateFreeSpaceAndCapacity(TNode *this, BOOL a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TFSVolumeInfo *v6;
  std::__shared_weak_count *v7;

  TNode::GetVolumeInfo(this, &v6);
  if (v6)
    TFSVolumeInfo::RecalculateFreeSpaceAndCapacity(v6, a2);
  v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1CBCD5AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::SetProperty(uint64_t a1, uint64_t a2, const void **a3, __CFString **a4, int a5, uint64_t a6)
{
  __CFString *v9;
  unsigned int v10;
  os_unfair_lock_s *v12;
  char *v13;
  int64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  char *buffer;
  unint64_t *v21;
  unint64_t v22;
  os_unfair_lock_s *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  os_unfair_lock_s *v31;
  char *v32;
  int64_t v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  unint64_t v38;
  unint64_t *v39;
  void *v41;
  char isKindOfClass;
  const void **v43;
  int v44;
  os_unfair_lock_s *v45;
  char *v46;
  int64_t v47;
  unint64_t *v48;
  unint64_t v49;
  TNode *v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  char *v54;
  unint64_t *v55;
  unint64_t v56;
  os_unfair_lock_s *v57;
  char *v58;
  TFSInfo *v59;
  unint64_t *v60;
  unint64_t v61;
  _BOOL4 IsBootVolume;
  unint64_t *v63;
  unint64_t v64;
  TString *v65;
  TFSInfo *value;
  TFSInfo *v67;
  TString v68;
  std::__shared_weak_count *v69;
  TPropertyValue v70;

  v9 = *a4;
  if (!*a4)
  {
    if ((int)a2 > 1869769062)
    {
      if ((_DWORD)a2 == 1869769063)
      {
        v31 = (os_unfair_lock_s *)TNode::InfoLock(0);
        os_unfair_lock_lock(v31);
        v33 = *(_QWORD *)(a1 + 16);
        v32 = *(char **)(a1 + 24);
        v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = v33;
        v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v32;
        if (v32)
        {
          v34 = (unint64_t *)(v32 + 8);
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
        }
        os_unfair_lock_unlock(v31);
        TNode::GetVolumeInfo((TNode *)a1, &v68);
        v10 = TFSInfo::SetProperty(v33, 0x6F726967u, (uint64_t)a3, (uint64_t)&v68, a6);
        v36 = v69;
        if (v69)
        {
          p_shared_owners = (unint64_t *)&v69->__shared_owners_;
          do
            v38 = __ldaxr(p_shared_owners);
          while (__stlxr(v38 - 1, p_shared_owners));
          if (!v38)
          {
            ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
            std::__shared_weak_count::__release_weak(v36);
          }
        }
        if (!v10)
        {
          TNodePtr::TNodePtr((TNodePtr *)&v68, (const TNode *)a1);
          TNode::SendNotification((const TNode *)a1, 2, (id *)&v68.fString.fRef, 1869769063, 0);

        }
        buffer = v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
        if (!v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
          goto LABEL_44;
        v39 = (unint64_t *)(v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                                 + 8);
        do
          v22 = __ldaxr(v39);
        while (__stlxr(v22 - 1, v39));
LABEL_42:
        if (!v22)
        {
          (*(void (**)(char *))(*(_QWORD *)buffer + 16))(buffer);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buffer);
        }
        goto LABEL_44;
      }
      if ((_DWORD)a2 == 1886282093)
      {
        v23 = (os_unfair_lock_s *)TNode::InfoLock(0);
        os_unfair_lock_lock(v23);
        v25 = *(_QWORD *)(a1 + 16);
        v24 = *(std::__shared_weak_count **)(a1 + 24);
        if (v24)
        {
          v26 = (unint64_t *)&v24->__shared_owners_;
          do
            v27 = __ldxr(v26);
          while (__stxr(v27 + 1, v26));
          os_unfair_lock_unlock(v23);
          v28 = *(unsigned __int8 *)(v25 + 112);
          do
            v29 = __ldaxr(v26);
          while (__stlxr(v29 - 1, v26));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
        else
        {
          os_unfair_lock_unlock(v23);
          v28 = *(unsigned __int8 *)(v25 + 112);
        }
        if (v28)
        {
          FIDSNodeFromTNode((TNode *)a1);
          v41 = (void *)objc_claimAutoreleasedReturnValue();
          objc_opt_class();
          isKindOfClass = objc_opt_isKindOfClass();

          if ((isKindOfClass & 1) != 0)
          {
            v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = 0;
            v43 = TPropertyReference::As<__CFString const*>(a3, (void **)&v70);
            if (v44)
              return 4294967246;
            v65 = (TString *)v43;
            TNode::GetFSInfo((TNode *)a1, &v70);
            value = (TFSInfo *)v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
            TString::TString(&v68, v65);
            TFSInfo::SetItemName(value, &v68);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v68.fString.fRef);
            std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v70);
            TNode::GetFSInfo((TNode *)a1, &v70);
            v67 = (TFSInfo *)v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
            TString::TString(&v68, v65);
            TFSInfo::SetDisplayName(v67, &v68);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v68.fString.fRef);
            std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v70);
            return 0;
          }
        }
      }
    }
    else if ((_DWORD)a2 == 1718903156 || (_DWORD)a2 == 1718904684)
    {
      v12 = (os_unfair_lock_s *)TNode::InfoLock(0);
      os_unfair_lock_lock(v12);
      v14 = *(_QWORD *)(a1 + 16);
      v13 = *(char **)(a1 + 24);
      v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = v14;
      v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v13;
      if (v13)
      {
        v15 = (unint64_t *)(v13 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      os_unfair_lock_unlock(v12);
      TNode::GetVolumeInfo((TNode *)a1, &v68);
      v10 = TFSInfo::SetProperty(v14, a2, (uint64_t)a3, (uint64_t)&v68, 0x10000000);
      v17 = v69;
      if (v69)
      {
        v18 = (unint64_t *)&v69->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      buffer = v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
      if (!v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
        goto LABEL_44;
      v21 = (unint64_t *)(v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                               + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      goto LABEL_42;
    }
    v45 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
    os_unfair_lock_lock(v45);
    v47 = *(_QWORD *)(a1 + 16);
    v46 = *(char **)(a1 + 24);
    v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = v47;
    v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v46;
    if (v46)
    {
      v48 = (unint64_t *)(v46 + 8);
      do
        v49 = __ldxr(v48);
      while (__stxr(v49 + 1, v48));
    }
    os_unfair_lock_unlock(v45);
    TNode::GetVolumeInfo((TNode *)a1, &v68);
    v50 = (TNode *)TFSInfo::SetProperty(v47, a2, (uint64_t)a3, (uint64_t)&v68, 0x10000000);
    v10 = v50;
    v51 = v69;
    if (v69)
    {
      v52 = (unint64_t *)&v69->__shared_owners_;
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
    v54 = v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
    if (v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer)
    {
      v55 = (unint64_t *)(v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer
                               + 8);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      if (!v56)
      {
        (*(void (**)(char *))(*(_QWORD *)v54 + 16))(v54);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v54);
      }
    }
    if ((_DWORD)a2 != 1768124270 || !a5 || v10)
      goto LABEL_3;
    v57 = (os_unfair_lock_s *)TNode::InfoLock(v50);
    os_unfair_lock_lock(v57);
    v59 = *(TFSInfo **)(a1 + 16);
    v58 = *(char **)(a1 + 24);
    v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v59;
    v70.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v58;
    if (v58)
    {
      v60 = (unint64_t *)(v58 + 8);
      do
        v61 = __ldxr(v60);
      while (__stxr(v61 + 1, v60));
    }
    os_unfair_lock_unlock(v57);
    IsBootVolume = TFSInfo::IsBootVolume(v59);
    if (v58)
    {
      v63 = (unint64_t *)(v58 + 8);
      do
        v64 = __ldaxr(v63);
      while (__stlxr(v64 - 1, v63));
      if (!v64)
      {
        (*(void (**)(char *))(*(_QWORD *)v58 + 16))(v58);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v58);
      }
    }
    if (IsBootVolume)
    {
      TNode::HandleSync(a1, 0x10080000u);
      TNodePtr::TNodePtr((TNodePtr *)&v70, (const TNode *)a1);
      TNode::SendNotification((const TNode *)a1, 2, (id *)&v70, 1768124270, 0);

    }
    return 0;
  }
  v68.fString.fRef = *a4;
  TNodeRequest::AddPtrReference((TNodeRequest *)v9);
  TPropertyValue::TPropertyValue(&v70, (const TPropertyReference *)a3);
  TNode::RequestTask(a1, 2, a2, &v70, &v68, 0);
  TPropertyValue::~TPropertyValue(&v70);
  TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef((TNodeRequest **)&v68);
  v10 = 0;
LABEL_3:
  if ((_DWORD)a2 == 1634758244)
    TNode::AddToAppNapCache((TNode *)a1);
LABEL_44:
  if (v10 == -8057)
    return 0;
  else
    return v10;
}

void sub_1CBCD60B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, TPropertyValue *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

unint64_t TNode::NodeIs(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char v11;
  unint64_t *v12;
  unint64_t v13;

  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  v6 = *(TFSInfo **)(a1 + 16);
  v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v9 = TFSInfo::InfoIs(v6, a2);
  if ((a2 & 0x200000) != 0)
    TNode::AliasIsContainer((TNode *)a1);
  if ((a2 & 0x800000) != 0)
  {
    if (TNode::IsInTrash((TNode *)a1))
      v10 = 0x800000;
    else
      v10 = 0;
    if ((a2 & 0x40000000) == 0)
      goto LABEL_16;
  }
  else
  {
    v10 = 0;
    if ((a2 & 0x40000000) == 0)
      goto LABEL_16;
  }
  if ((TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E74776B) & 1) != 0
    || TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E747362))
  {
    v10 |= 0x40000000uLL;
  }
LABEL_16:
  if ((a2 & 0x800000000000) != 0 && TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E74776B))
    v10 |= 0x800000000000uLL;
  if ((a2 & 0x40000000000) != 0 && TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6D74726D))
    v10 |= 0x40000000000uLL;
  if ((a2 & 0x2000000000) != 0)
  {
    v11 = atomic_load((unsigned __int16 *)(a1 + 80));
    v10 |= (unint64_t)(v11 & 2) << 36;
  }
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return v10 | v9;
}

void sub_1CBCD62C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::IsFirmlink(TNode *this)
{
  unsigned int v1;

  v1 = atomic_load((unsigned __int16 *)this + 40);
  return (v1 >> 1) & 1;
}

uint64_t TNode::VolumeIs(uint64_t a1, int *a2)
{
  TNode *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  TNode *v15;
  int v16;
  unint64_t v17;
  os_unfair_lock_s *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t IsLocalVolume;
  int v24;
  unint64_t v25;
  int v27;
  os_unfair_lock_s *v28;
  std::__shared_weak_count *v29;
  TFSVolumeInfo *v30;
  unint64_t *v31;
  unint64_t v32;
  _BOOL4 IsBootVolume;
  unint64_t *v34;
  unint64_t v35;
  TFSVolumeInfo *v36;
  int v37;
  BOOL v38;
  int v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  TFSVolumeInfo *v43;
  std::__shared_weak_count *v44;

  v4 = (TNode *)TNode::VirtualType((TNode *)a1);
  switch((int)v4)
  {
    case 23:
    case 24:
    case 25:
      v5 = 0;
      v6 = *a2;
      v7 = 25;
      goto LABEL_4;
    case 26:
    case 29:
      v5 = 0;
      v8 = *a2 & 0x18;
      goto LABEL_26;
    case 27:
    case 28:
      v5 = 0;
      v6 = *a2;
      v7 = 9;
LABEL_4:
      v8 = v6 & v7;
      goto LABEL_26;
    default:
      v9 = *a2;
      v10 = (os_unfair_lock_s *)TNode::InfoLock(v4);
      os_unfair_lock_lock(v10);
      v12 = *(_QWORD *)(a1 + 16);
      v11 = *(std::__shared_weak_count **)(a1 + 24);
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
        os_unfair_lock_unlock(v10);
        v16 = *(unsigned __int8 *)(v12 + 112);
        do
          v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      else
      {
        os_unfair_lock_unlock(v10);
        v16 = *(unsigned __int8 *)(v12 + 112);
      }
      if (v16 && (v9 & 0xB9) != 0)
        goto LABEL_25;
      v18 = (os_unfair_lock_s *)TNode::InfoLock(v15);
      os_unfair_lock_lock(v18);
      v20 = *(_QWORD *)(a1 + 16);
      v19 = *(std::__shared_weak_count **)(a1 + 24);
      if (v19)
      {
        v21 = (unint64_t *)&v19->__shared_owners_;
        do
          v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
        os_unfair_lock_unlock(v18);
        v24 = *(unsigned __int8 *)(v20 + 112);
        do
          v25 = __ldaxr(v21);
        while (__stlxr(v25 - 1, v21));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      else
      {
        os_unfair_lock_unlock(v18);
        v24 = *(unsigned __int8 *)(v20 + 112);
      }
      if (v24 == 16)
      {
LABEL_25:
        v8 = 0;
        v5 = 4294959224;
LABEL_26:
        *a2 = v8;
        return v5;
      }
      v27 = *a2;
      if ((*a2 & 1) != 0)
      {
        IsLocalVolume = TNode::IsLocalVolume((TNode *)a1);
        v8 = IsLocalVolume;
        v27 = *a2;
      }
      else
      {
        v8 = 0;
      }
      if ((v27 & 2) != 0)
      {
        IsLocalVolume = TNode::IsEjectable((TNode *)a1);
        if ((_DWORD)IsLocalVolume)
          v8 |= 2u;
        v27 = *a2;
        if ((*a2 & 8) == 0)
        {
LABEL_33:
          if ((v27 & 0x10) == 0)
            goto LABEL_34;
          goto LABEL_43;
        }
      }
      else if ((v27 & 8) == 0)
      {
        goto LABEL_33;
      }
      IsLocalVolume = TNode::VolumeHasNoVolumeSizes((TNode *)a1);
      if ((_DWORD)IsLocalVolume)
        v8 |= 8u;
      v27 = *a2;
      if ((*a2 & 0x10) == 0)
      {
LABEL_34:
        if ((v27 & 0x20) == 0)
          goto LABEL_35;
        goto LABEL_46;
      }
LABEL_43:
      IsLocalVolume = TNode::VolumeIsReadOnly((TNode *)a1);
      if ((_DWORD)IsLocalVolume)
        v8 |= 0x10u;
      v27 = *a2;
      if ((*a2 & 0x20) == 0)
      {
LABEL_35:
        if ((v27 & 0x400) == 0)
          goto LABEL_59;
        goto LABEL_49;
      }
LABEL_46:
      IsLocalVolume = TNode::VolumeSupportsACLs((TNode *)a1);
      if ((_DWORD)IsLocalVolume)
        v8 |= 0x20u;
      if ((*a2 & 0x400) != 0)
      {
LABEL_49:
        v28 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocalVolume);
        os_unfair_lock_lock(v28);
        v30 = *(TFSVolumeInfo **)(a1 + 16);
        v29 = *(std::__shared_weak_count **)(a1 + 24);
        v43 = v30;
        v44 = v29;
        if (v29)
        {
          v31 = (unint64_t *)&v29->__shared_owners_;
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
        }
        os_unfair_lock_unlock(v28);
        IsBootVolume = TFSInfo::IsBootVolume((TFSInfo *)v30);
        if (v29)
        {
          v34 = (unint64_t *)&v29->__shared_owners_;
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
        if (IsBootVolume)
          v8 |= 0x400u;
      }
LABEL_59:
      TNode::GetVolumeInfo((TNode *)a1, &v43);
      v36 = v43;
      v37 = *a2;
      v38 = (*a2 & 0x3BDB80) != 0 && v43 == 0;
      v39 = !v38;
      if (v38)
      {
        v5 = 0;
        goto LABEL_111;
      }
      if ((v37 & 0x80) != 0 && (*((_BYTE *)v43 + 126) || *((_BYTE *)v43 + 107) && !*((_BYTE *)v43 + 129)))
        v8 |= 0x80u;
      if ((v37 & 0x100) == 0)
      {
        if ((v37 & 0x200) == 0)
          goto LABEL_71;
LABEL_77:
        if (!*((_BYTE *)v43 + 117))
          v8 |= 0x200u;
        if ((v37 & 0x4000) == 0)
          goto LABEL_72;
        goto LABEL_80;
      }
      if (!*((_BYTE *)v43 + 114))
        v8 |= 0x100u;
      if ((v37 & 0x200) != 0)
        goto LABEL_77;
LABEL_71:
      if ((v37 & 0x4000) == 0)
      {
LABEL_72:
        v5 = 0;
        goto LABEL_85;
      }
LABEL_80:
      if (*((_BYTE *)v43 + 119))
        v5 = 0;
      else
        v5 = 4294959224;
      if (*((_BYTE *)v43 + 130))
        v8 |= 0x4000u;
LABEL_85:
      if ((v37 & 0x200000) != 0)
      {
        if (IsRunningInFinder())
          v8 |= 0x200000u;
        v37 = *a2;
      }
      if ((v37 & 0x400000) != 0 && *((_BYTE *)v36 + 119))
        v8 |= 0x400000u;
      if ((v37 & 0x8000) != 0)
      {
        if (TFSVolumeInfo::VolumeSupportsUNIXPermissions(v36))
          v8 |= 0x8000u;
        v37 = *a2;
      }
      if ((v37 & 0x10000) != 0)
      {
        if (TFSVolumeInfo::VolumeSupportsAFPPermissions(v36))
          v8 |= 0x10000u;
        v37 = *a2;
      }
      if ((v37 & 0x20000) != 0)
      {
        if (TFSVolumeInfo::VolumeSupportsIgnoreOwnership(v36))
          v8 |= 0x20000u;
        v37 = *a2;
      }
      if ((v37 & 0x80000) != 0)
      {
        if (TFSVolumeInfo::VolumeShouldShowCapacity(v36))
          v8 |= 0x80000u;
        v37 = *a2;
      }
      if ((v37 & 0x100000) != 0 && TFSVolumeInfo::VolumeAllowPermissionChanges(v36))
        v8 |= 0x100000u;
LABEL_111:
      v40 = v44;
      if (v44)
      {
        v41 = (unint64_t *)&v44->__shared_owners_;
        do
          v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
      }
      if (v39)
        goto LABEL_26;
      return 4294959224;
  }
}

void sub_1CBCD676C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::IsLocalVolume(TNode *this)
{
  BOOL v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;

  TNode::GetVolumeInfo(this, &v7);
  v2 = v7;
  if (v7)
    v1 = *(_BYTE *)(v7 + 107) != 0;
  v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return (v2 == 0) | v1;
}

uint64_t TNode::IsEjectable(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v16 = *((_QWORD *)this + 2);
  v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  TNode::GetVolumeInfo(this, &v14);
  v6 = IsRunningInFinder();
  v7 = v15;
  if (v15)
  {
    v8 = (unint64_t *)&v15->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v17;
  if (v17)
  {
    v11 = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return v6;
}

void sub_1CBCD6910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void TNode::TrashPathForNode(TNode *this@<X0>, _BYTE *a2@<X8>)
{
  int v4;
  int v5;
  void *v6;
  void *v7;
  TString *v8;
  const __CFString *v9;
  const __CFAllocator *v10;
  CFMutableStringRef MutableCopy;
  const __CFString *v12;
  __CFString *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  TString v17;
  CFTypeRef cf;
  TString v19;
  CFStringRef theString;
  uint64_t v21;
  std::__shared_weak_count *v22;

  TNode::GetVolumeInfo(this, &v21);
  v4 = *(unsigned __int8 *)(v21 + 122);
  if (!(*(_BYTE *)(v21 + 107) | v4))
  {
    *a2 = 0;
    a2[8] = 0;
    goto LABEL_18;
  }
  v5 = UseFileProviderFramework() ^ 1;
  if (!v4)
    LOBYTE(v5) = 1;
  if ((v5 & 1) != 0)
  {
LABEL_12:
    TFSVolumeInfo::TrashPath(*(TFSVolumeInfo **)this, 0, (TString *)&theString);
    if (CFStringGetLength(theString))
    {
      std::__optional_destruct_base<TString,false>::__optional_destruct_base[abi:ne180100]<TString>((uint64_t)a2, (CFTypeRef *)&theString);
    }
    else
    {
      *a2 = 0;
      a2[8] = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_18;
  }
  TNode::GetFIProvider(this);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(v6, "supportsSyncingTrash"))
  {

    goto LABEL_12;
  }
  objc_msgSend(v6, "rootURL");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "path");
  v8 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  theString = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&theString, v8);

  if (CFStringGetLength(theString))
  {
    v9 = theString;
    cf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v9);
    if (&stru_1E8752DF8)
      CFRelease(&stru_1E8752DF8);
    cf = MutableCopy;
    TString::Append((TString *)&cf, (const __CFString *)(unsigned __int16)TPathName::kPOSIXPathNameSeparator);
    v17.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v17, (TString *)CFSTR(".Trash"));
    v12 = (const __CFString *)cf;
    v19.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    v13 = CFStringCreateMutableCopy(v10, 0, v12);
    CFRelease(&stru_1E8752DF8);
    v19.fString.fRef = v13;
    TString::Append(&v19, &v17);
    std::__optional_destruct_base<TString,false>::__optional_destruct_base[abi:ne180100]<TString>((uint64_t)a2, (CFTypeRef *)&v19.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  else
  {
    *a2 = 0;
    a2[8] = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);

LABEL_18:
  v14 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_1CBCD6B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11, const void *a12, char a13)
{
  void *v13;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t TNode::ChildRegistrationCount(TNode *this)
{
  os_unfair_lock_s *v2;
  unsigned int *v3;
  uint64_t v4;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (unsigned int *)*((_QWORD *)this + 9);
  if (v3)
    v4 = atomic_load(v3);
  else
    v4 = 0;
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t TNode::RegisterChangeNotification(TNode *a1, TDSNotifier *a2, uint64_t a3)
{
  uint64_t v3;
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  os_unfair_lock_s *v11;
  int v12;
  TNode *v13;
  unint64_t *v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  FINode *v18;
  unint64_t *v19;
  unint64_t v20;
  _BOOL4 IsAlias;
  unint64_t *v22;
  unint64_t v23;
  TNodePtr v25;
  TNodePtr v26;
  std::__shared_weak_count *v27;

  v3 = a3;
  if ((a3 & 0xE) == 0)
    goto LABEL_22;
  v6 = (os_unfair_lock_s *)TNode::InfoLock(a1);
  os_unfair_lock_lock(v6);
  v8 = *((_QWORD *)a1 + 2);
  v7 = (std::__shared_weak_count *)*((_QWORD *)a1 + 3);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v6);
  v11 = (os_unfair_lock_s *)(v8 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  v12 = *(_DWORD *)(v8 + 115);
  os_unfair_lock_unlock(v11);
  if (!v7)
    goto LABEL_9;
  v14 = (unint64_t *)&v7->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (v15)
  {
LABEL_9:
    if ((v12 & 0x20) != 0)
      goto LABEL_10;
LABEL_21:
    v3 = v3 & 0xFFFFFFF1;
    goto LABEL_22;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if ((v12 & 0x20) == 0)
    goto LABEL_21;
LABEL_10:
  v16 = (os_unfair_lock_s *)TNode::InfoLock(v13);
  os_unfair_lock_lock(v16);
  v18 = (FINode *)*((_QWORD *)a1 + 2);
  v17 = (std::__shared_weak_count *)*((_QWORD *)a1 + 3);
  v26.fFINode = v18;
  v27 = v17;
  if (v17)
  {
    v19 = (unint64_t *)&v17->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  os_unfair_lock_unlock(v16);
  IsAlias = TFSInfo::IsAlias((TFSInfo *)v18);
  if (v17)
  {
    v22 = (unint64_t *)&v17->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (IsAlias)
    goto LABEL_21;
LABEL_22:
  TNodePtr::TNodePtr(&v26, a1);
  TNodePtr::TNodePtr(&v25, a1);
  TDSNotifier::Register(a2, &v26.fFINode, &v25.fFINode, v3);

  return 0;
}

void sub_1CBCD6E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::UnregisterChangeNotification(uint64_t a1, uint64_t a2, FINode **a3, uint64_t a4)
{
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int *NotifierList;
  int v15;
  unsigned int v16;
  NSObject *v17;
  unsigned int *v18;
  int v19;
  unsigned int v20;
  NSObject *v21;
  __CFString *v22;
  TNode *v23;
  os_unfair_lock_s *v24;
  TNode *v25;
  os_unfair_lock_s *v26;
  TNode *v27;
  signed int v28;
  TNode *v29;
  NSObject *v30;
  unsigned int *v31;
  int v32;
  unsigned int v33;
  NSObject *v34;
  unsigned int *v35;
  int v36;
  unsigned int v37;
  NSObject *v38;
  TDSNotifier *v39;
  FINode *v40;
  uint64_t v41;
  os_unfair_lock_s *v42;
  TChildrenList *v43;
  _BOOL4 v44;
  uint64_t v45;
  os_unfair_lock_s *v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  os_unfair_lock_s *v52;
  uint64_t v53;
  int v54;
  __int16 v55;
  unint64_t v56;
  os_unfair_lock_s *v57;
  uint64_t v58;
  int v59;
  __int16 v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  FINode *v64;
  TNodePtr v65;
  _QWORD block[4];
  __CFString *v67;
  TFSVolumeInfo *v68;
  std::__shared_weak_count *v69;
  TString v70;
  TDSNotifier *v71;
  char v72;
  TPropertyValue buf;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v72);
  if ((a4 & 0x40) != 0)
  {
    v8 = (unsigned int *)(TNode::GetNotifierList((TNode *)a1) + 16);
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
    {
      memset(&buf, 0, sizeof(buf));
      TNode::RequestInternalTask((const TNode *)a1, 1020, &buf, 0);
      TPropertyValue::~TPropertyValue(&buf);
    }
  }
  TNode::FindRegistration((TNode *)a1, a2, a3, &v71);
  if (v71)
  {
    if ((a4 & 2) != 0)
    {
      v11 = atomic_load((unsigned int *)v71 + 11);
      if (v11 < 1)
      {
        a4 = a4 & 0xFFFFFFFD;
      }
      else
      {
        v12 = (unsigned int *)((char *)v71 + 44);
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        NotifierList = (unsigned int *)TNode::GetNotifierList((TNode *)a1);
        do
        {
          v15 = __ldaxr(NotifierList);
          v16 = v15 - 1;
        }
        while (__stlxr(v15 - 1, NotifierList));
        if (v15 <= 0)
        {
          LogObj(5);
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v16;
            _os_log_impl(&dword_1CBC4A000, v17, OS_LOG_TYPE_ERROR, "Incorrect childRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
          }

        }
        else if (v15 == 1)
        {
          memset(&buf, 0, sizeof(buf));
          TNode::RequestInternalTask((const TNode *)a1, 1019, &buf, 0);
          TPropertyValue::~TPropertyValue(&buf);
        }
      }
    }
    if ((a4 & 4) != 0)
    {
      --*((_DWORD *)v71 + 12);
      v18 = (unsigned int *)(TNode::GetNotifierList((TNode *)a1) + 4);
      do
      {
        v19 = __ldaxr(v18);
        v20 = v19 - 1;
      }
      while (__stlxr(v19 - 1, v18));
      if (v19 <= 0)
      {
        LogObj(5);
        v30 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v20;
          _os_log_impl(&dword_1CBC4A000, v30, OS_LOG_TYPE_ERROR, "Incorrect deepChildRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
        }

      }
      else if (v19 == 1)
      {
        TNode::GetPath(a1, 1, (uint64_t)&buf);
        TString::TString(&v70, "", 0);
        fstd::optional_err<TString,int>::value_or<TString>((uint64_t)&buf, (CFTypeRef *)&v70.fString.fRef, (TString *)&v68);
        TSystemNotificationTask::StopObservingDirectory((TString **)&v68, (const TString *)1);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v68);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v70.fString.fRef);
        TNode::GetVolumeInfo((TNode *)a1, &v68);
        TNodePtr::TNodePtr((TNodePtr *)&v70, (const TNode *)a1);
        TFSVolumeInfo::GetSynchingGCDQueue(v68);
        v21 = objc_claimAutoreleasedReturnValue();
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3321888768;
        block[2] = ___ZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptions_block_invoke;
        block[3] = &__block_descriptor_40_ea8_32c132_ZTSKZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsE3__0_e5_v8__0l;
        v22 = v70.fString.fRef;
        v67 = v22;
        dispatch_async(v21, block);

        v24 = (os_unfair_lock_s *)TNode::ParentLock(v23);
        os_unfair_lock_lock(v24);
        TNodePtr::TNodePtr(&v65, *(const TNode **)(a1 + 48));
        os_unfair_lock_unlock(v24);
        v25 = (TNode *)TNodeFromFINode(v65.fFINode);
        if (v25)
        {
          v26 = (os_unfair_lock_s *)TNode::ParentLock(v25);
          os_unfair_lock_lock(v26);
          TNodePtr::TNodePtr((TNodePtr *)&v64, *(const TNode **)(a1 + 48));
          os_unfair_lock_unlock(v26);
          v27 = (TNode *)TNodeFromFINode(v64);
          v28 = atomic_load((unsigned int *)(TNode::GetNotifierList(v27) + 4));
          LODWORD(v26) = v28 > 0;

          if (!(_DWORD)v26)
            goto LABEL_65;
        }
        else
        {

        }
        v47 = (os_unfair_lock_s *)TNode::InfoLock(v29);
        os_unfair_lock_lock(v47);
        v49 = *(_QWORD *)(a1 + 16);
        v48 = *(std::__shared_weak_count **)(a1 + 24);
        if (v48)
        {
          p_shared_owners = (unint64_t *)&v48->__shared_owners_;
          do
            v51 = __ldxr(p_shared_owners);
          while (__stxr(v51 + 1, p_shared_owners));
          os_unfair_lock_unlock(v47);
          v52 = (os_unfair_lock_s *)(v49 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v49 + 100));
          v54 = *(_DWORD *)(v49 + 115);
          v53 = v49 + 115;
          v55 = *(_WORD *)(v53 + 4);
          *(_DWORD *)v53 = v54 & 0xF7FFFFFF;
          *(_WORD *)(v53 + 4) = v55;
          os_unfair_lock_unlock(v52);
          do
            v56 = __ldaxr(p_shared_owners);
          while (__stlxr(v56 - 1, p_shared_owners));
          if (!v56)
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }
        else
        {
          os_unfair_lock_unlock(v47);
          v57 = (os_unfair_lock_s *)(v49 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v49 + 100));
          v59 = *(_DWORD *)(v49 + 115);
          v58 = v49 + 115;
          v60 = *(_WORD *)(v58 + 4);
          *(_DWORD *)v58 = v59 & 0xF7FFFFFF;
          *(_WORD *)(v58 + 4) = v60;
          os_unfair_lock_unlock(v57);
        }
LABEL_65:

        v61 = v69;
        if (v69)
        {
          v62 = (unint64_t *)&v69->__shared_owners_;
          do
            v63 = __ldaxr(v62);
          while (__stlxr(v63 - 1, v62));
          if (!v63)
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&buf);
        if ((a4 & 8) == 0)
          goto LABEL_39;
        goto LABEL_32;
      }
    }
    if ((a4 & 8) == 0)
    {
LABEL_39:
      if ((a4 & 0x10) != 0)
      {
        --*((_DWORD *)v71 + 14);
        v35 = (unsigned int *)(TNode::GetNotifierList((TNode *)a1) + 12);
        do
        {
          v36 = __ldaxr(v35);
          v37 = v36 - 1;
        }
        while (__stlxr(v36 - 1, v35));
        if (v36 <= 0)
        {
          LogObj(4);
          v38 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v37;
            _os_log_impl(&dword_1CBC4A000, v38, OS_LOG_TYPE_ERROR, "Incorrect ubiquityRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
          }

        }
        else if (v36 == 1)
        {
          TNode::SetShouldSyncUbiquityAttributes((TNode *)a1, 0);
        }
      }
      v39 = v71;
      if ((a4 & 1) != 0)
      {
        v40 = (FINode *)*((id *)v71 + 2);
        v41 = TNodeFromFINode(v40);
        v42 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v41);
        os_unfair_lock_lock(v42);
        TNodePtr::TNodePtr((TNodePtr *)&buf, *(const TNode **)(v41 + 48));
        os_unfair_lock_unlock(v42);

        if (TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value))
        {
          v43 = *(TChildrenList **)(TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value)
                                  + 56);
          if (v43)
            TChildrenList::DecrementRegisteredChildrenCount(v43);
        }

        v39 = v71;
      }
      v44 = TDSNotifier::DecrementRegistrationCountForOptions((uint64_t)v39, a4);
      TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);

      if (v44)
      {
        v45 = TNode::GetNotifierList((TNode *)a1);
        TNotifierList::RemoveNotifier(v45, &v71);
      }
      goto LABEL_55;
    }
LABEL_32:
    v31 = (unsigned int *)(TNode::GetNotifierList((TNode *)a1) + 8);
    do
    {
      v32 = __ldaxr(v31);
      v33 = v32 - 1;
    }
    while (__stlxr(v32 - 1, v31));
    if (v32 <= 0)
    {
      LogObj(5);
      v34 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v33;
        _os_log_impl(&dword_1CBC4A000, v34, OS_LOG_TYPE_ERROR, "Incorrect spotlightRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
      }

    }
    --*((_DWORD *)v71 + 13);
    atomic_load((unsigned int *)(TNode::GetNotifierList((TNode *)a1) + 8));
    goto LABEL_39;
  }
LABEL_55:
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v71);
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v72);
  return 0;
}

void sub_1CBCD74FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, char a16, uint64_t a17, void *a18, TDSNotifier *a19)
{
  os_unfair_lock_s *v19;
  uint64_t v20;

  os_unfair_lock_unlock(v19);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v20 - 80));
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a19);
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)(v20 - 81));
  _Unwind_Resume(a1);
}

void TNode::FindRegistration(TNode *a1@<X0>, uint64_t a2@<X1>, FINode **a3@<X2>, TDSNotifier **a4@<X8>)
{
  TDSNotifier **v7;
  TDSNotifier **v8;
  uint64_t v9;
  FINode *v10;
  uint64_t v11;
  uint64_t v12;
  TDSNotifier **v13;
  TDSNotifier *v14;
  TDSNotifier *v15;
  TDSNotifier **v16;
  TDSNotifier **v17;
  TDSNotifier ***v18;

  if (*(_QWORD *)(*(_QWORD *)a2 + 40))
  {
    TNode::Notifiers(a1, &v16);
    v7 = v16;
    v8 = v17;
    while (1)
    {
      if (v7 == v8)
      {
        v18 = &v16;
        goto LABEL_13;
      }
      v9 = *(_QWORD *)*v7;
      if (*(_QWORD *)(v9 + 16) == *(_QWORD *)(*(_QWORD *)a2 + 16)
        && *(_QWORD *)(v9 + 40) == *(_QWORD *)(*(_QWORD *)a2 + 40))
      {
        v10 = (FINode *)*((id *)*v7 + 3);
        v11 = TNodeFromFINode(v10);
        v12 = TNodeFromFINode(*a3);

        if (v11 == v12)
          break;
      }
      ++v7;
    }
    v15 = *v7;
    *a4 = *v7;
    if (v15)
      TDSNotifier::AddPtrReference(v15);
LABEL_17:
    v18 = &v16;
    std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
    return;
  }
  TNode::Notifiers(a1, &v16);
  v13 = v16;
  if (v16 != v17)
  {
    while (1)
    {
      v14 = *v13;
      if (*(_QWORD *)(*(_QWORD *)*v13 + 16) == *(_QWORD *)(*(_QWORD *)a2 + 16))
        break;
      if (++v13 == v17)
        goto LABEL_12;
    }
    *a4 = v14;
    TDSNotifier::AddPtrReference(v14);
    goto LABEL_17;
  }
LABEL_12:
  v18 = &v16;
LABEL_13:
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  *a4 = 0;
}

void sub_1CBCD7788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void fstd::optional_err<TString,int>::value_or<TString>(uint64_t a1@<X0>, CFTypeRef *a2@<X1>, TString *a3@<X8>)
{
  if (*(_DWORD *)(a1 + 8))
  {
    a3->fString.fRef = (__CFString *)*a2;
    *a2 = 0;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
  }
  else
  {
    a3->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a3, *(TString **)a1);
  }
}

void sub_1CBCD781C(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void ___ZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptions_block_invoke(uint64_t a1)
{
  _QWORD v1[4];
  id v2;

  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 3321888768;
  v1[2] = ___ZZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsENK3__0clEv_block_invoke;
  v1[3] = &__block_descriptor_40_ea8_32c13_ZTS8TNodePtr_e5_v8__0l;
  v2 = *(id *)(a1 + 32);
  ExceptionSafeBlock(v1);

}

void sub_1CBCD789C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c132_ZTSKZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c132_ZTSKZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsE3__0(uint64_t a1)
{

}

void TNotifierList::RemoveNotifier(uint64_t a1, TDSNotifier **a2)
{
  os_unfair_lock_s *v4;
  TDSNotifier **v5;
  TDSNotifier **v6;
  TDSNotifier **v7;
  TDSNotifier **v8;

  v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v6 = *(TDSNotifier ***)(a1 + 40);
  v5 = *(TDSNotifier ***)(a1 + 48);
  if (v6 != v5)
  {
    while (*v6 != *a2)
    {
      if (++v6 == v5)
      {
        v6 = *(TDSNotifier ***)(a1 + 48);
        break;
      }
    }
  }
  if (v6 != v5)
  {
    if (v6 + 1 == v5)
    {
      v7 = v6;
    }
    else
    {
      v7 = v6;
      do
      {
        TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(v6, v6 + 1);
        ++v7;
        v8 = v6 + 2;
        ++v6;
      }
      while (v8 != v5);
      v5 = *(TDSNotifier ***)(a1 + 48);
    }
    while (v5 != v7)
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(--v5);
    *(_QWORD *)(a1 + 48) = v7;
  }
  os_unfair_lock_unlock(v4);
}

const void **AllowedPaths(void)::$_0::operator()()
{
  SecTaskRef v0;
  void *v1;
  id v2;
  const __CFAllocator *v3;
  id v4;
  TString *v5;
  __CFString *fRef;
  __CFString *MutableCopy;
  uint64_t v8;
  uint64_t v9;
  id v10;
  id v11;
  TString *v12;
  __CFString *v13;
  __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  TString *v18;
  _BOOL4 v19;
  CFIndex Length;
  const __CFString *v21;
  __CFString *v22;
  CFTypeRef v24;
  CFTypeRef cf;
  CFErrorRef error;
  CFStringRef theString[16];
  uint64_t v28;
  id obj;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _BYTE v33[32];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  TString v38;
  TString v39;
  TString v40;

  AllowedPaths(void)::allowedPaths = 0;
  unk_1EDB96AC0 = 0;
  qword_1EDB96AC8 = 0;
  error = 0;
  v0 = SecTaskCreateFromSelf(0);
  cf = v0;
  if (v0)
  {
    v24 = SecTaskCopyValueForEntitlement(v0, CFSTR("com.apple.security.exception.files.home-relative-path.read-write"), &error);
    v1 = (void *)cf_cast<__CFArray const*,void const*>(v24);
    if (v1)
    {
      v2 = v1;
      IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, v2);
      IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)theString, -1, v2);
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      while (obj != theString[0] || v37 != v28)
      {
        v4 = *(id *)(v31 + 8 * v36);
        TString::TString(&v40, "/private/var/mobile", 0x13uLL);
        v5 = (TString *)v4;
        v39.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v39, v5);

        fRef = v40.fString.fRef;
        v38.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        MutableCopy = CFStringCreateMutableCopy(v3, 0, fRef);
        CFRelease(&stru_1E8752DF8);
        v38.fString.fRef = MutableCopy;
        TString::Append(&v38, &v39);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);

        std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&v38.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);

        v8 = v36;
        if (v36 >= v35 - 1)
        {
          v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v33, 4);
          v8 = -1;
          v35 = v9;
          v36 = -1;
        }
        if (v34 != *v32)
        {
          objc_enumerationMutation(obj);
          v8 = v36;
        }
        v36 = v8 + 1;
        ++v37;
      }

      v10 = v2;
      IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, v10);
      IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)theString, -1, v10);
      while (obj != theString[0] || v37 != v28)
      {
        v11 = *(id *)(v31 + 8 * v36);
        TString::TString(&v40, "/var/mobile", 0xBuLL);
        v12 = (TString *)v11;
        v39.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v39, v12);

        v13 = v40.fString.fRef;
        v38.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        v14 = CFStringCreateMutableCopy(v3, 0, v13);
        CFRelease(&stru_1E8752DF8);
        v38.fString.fRef = v14;
        TString::Append(&v38, &v39);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);

        std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&v38.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);

        v15 = v36;
        if (v36 >= v35 - 1)
        {
          v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v33, 4);
          v15 = -1;
          v35 = v16;
          v36 = -1;
        }
        if (v34 != *v32)
        {
          objc_enumerationMutation(obj);
          v15 = v36;
        }
        v36 = v15 + 1;
        ++v37;
      }

    }
    CloudDocsRootURL();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "path");
    v18 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    theString[0] = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)theString, v18);

    if (CFStringGetLength(theString[0]))
    {
      TString::TString((TString *)&obj, "/private/");
      v19 = TString::BeginsWith((TString *)theString, (const TString *)&obj);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
      TString::TString((TString *)&obj, "/private", 8uLL);
      if (v19)
      {
        Length = CFStringGetLength((CFStringRef)obj);
        TString::SubStringFrom((TString *)theString, Length, &v40);
      }
      else
      {
        v21 = (const __CFString *)obj;
        v40.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        v22 = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v21);
        CFRelease(&stru_1E8752DF8);
        v40.fString.fRef = v22;
        TString::Append(&v40, (const TString *)theString);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
      std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (TString **)theString);
      std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (TString **)&v40);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    TString::TString((TString *)&obj, "/private/var/mobile/Containers/Shared/AppGroup", 0x2EuLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TString::TString((TString *)&obj, "/var/mobile/Containers/Shared/AppGroup", 0x26uLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TString::TString((TString *)&obj, "/private/var/mobile/Library/LiveFiles", 0x25uLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TString::TString((TString *)&obj, "/var/mobile/Library/LiveFiles", 0x1DuLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&v24);
  }
  return TRef<__SecTask *,CFRetainReleasePolicy>::~TRef(&cf);
}

void sub_1CBCD7F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, const void *a11, uint64_t a12, const void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,const void *a30)
{
  uint64_t v30;
  uint64_t v31;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v31 - 96));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a30);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a13);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&a10);
  TRef<__SecTask *,CFRetainReleasePolicy>::~TRef(&a11);
  *(_QWORD *)(v31 - 96) = v30;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)(v31 - 96));
  _Unwind_Resume(a1);
}

BOOL RemovePrefix(const TString *a1, TString *this)
{
  _BOOL8 v4;
  CFIndex Length;
  CFTypeRef cf;

  v4 = TString::BeginsWith(this, a1);
  if (v4)
  {
    Length = CFStringGetLength(a1->fString.fRef);
    TString::SubStringFrom(this, Length, (TString *)&cf);
    if (&cf != (CFTypeRef *)this)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&this->fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  return v4;
}

void TNode::HandleListeners(TNode *a1, int a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  TFSVolumeInfo *v7;
  std::__shared_weak_count *v8;

  TNode::GetVolumeInfo(a1, &v7);
  if (v7)
    TFSVolumeInfo::InvalidateFreeSpaceAndCapacityOfContainer(v7);
  TNode::RequestSynchronize((TGlobalNodes *)a1, a2);
  v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1CBCD8284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *TNode::RecursiveChildrenAndSelf@<X0>(TNode *this@<X0>, char a2@<W1>, _QWORD *a3@<X8>)
{
  _BYTE *v6;
  _QWORD *result;
  uint64_t v8;
  const TNode *v9;
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = operator new(0x20uLL);
  *(_QWORD *)v6 = &off_1E8750188;
  v6[8] = a2;
  *((_QWORD *)v6 + 2) = a3;
  *((_QWORD *)v6 + 3) = v10;
  v11 = v6;
  v9 = this;
  std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::operator()((uint64_t)v6, &v9);
  result = v11;
  if (v11 == v10)
  {
    v8 = 4;
    result = v10;
  }
  else
  {
    if (!v11)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1CBCD835C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  void ***v13;
  void ***v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  ((void (*)(void))(*v15)[v16])();
LABEL_6:
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void TNode::RecursiveSyncOfObserveNodes(TNode *this)
{
  id *v1;
  id *v2;
  FINode *v3;
  TGlobalNodes *v4;
  _QWORD v5[3];
  void **v6;

  TNode::RecursiveChildrenAndSelf(this, 1, v5);
  v1 = (id *)v5[0];
  v2 = (id *)v5[1];
  while (v1 != v2)
  {
    v3 = (FINode *)*v1;
    v4 = (TGlobalNodes *)TNodeFromFINode(v3);
    TNode::RequestSynchronize(v4, 0x1000000);

    ++v1;
  }
  v6 = (void **)v5;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v6);
}

void sub_1CBCD841C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  void *v12;

  a12 = (void **)&a9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void TNode::SubscribeForFSNotification(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_8;
  v9 = (unint64_t *)&v3->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (v10)
  {
LABEL_8:
    if ((v8 & 0x20) == 0)
      return;
LABEL_11:
    TChildrenList::SubscribeWithKQueue(*((TChildrenList **)this + 7));
    return;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  if ((v8 & 0x20) != 0)
    goto LABEL_11;
}

uint64_t TNode::SetInitialPopulationDeferred(TNode *this)
{
  unsigned __int16 *v1;
  unsigned int v2;

  v1 = (unsigned __int16 *)((char *)this + 80);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 | 0x20, v1));
  return (v2 >> 5) & 1;
}

CFIndex ___ZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEb_block_invoke(uint64_t a1)
{
  CFIndex result;
  unsigned __int16 *v3;
  unsigned __int16 v4;
  uint64_t v5;

  result = TNodeFromFINode(*(FINode **)(a1 + 32));
  v3 = (unsigned __int16 *)(result + 80);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 & 0xFFDF, v3));
  if ((v4 & 0x20) != 0)
  {
    v5 = TNodeFromFINode(*(FINode **)(a1 + 32));
    return TNode::HandleSync(v5, 0x1400000u);
  }
  return result;
}

id __copy_helper_block_ea8_32c94_ZTSKZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEbE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c94_ZTSKZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEbE3__0(uint64_t a1)
{

}

uint64_t TNode::ClearInitialPopulationDeferred(TNode *this)
{
  unsigned __int16 *v1;
  unsigned int v2;

  v1 = (unsigned __int16 *)((char *)this + 80);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 & 0xFFDF, v1));
  return (v2 >> 5) & 1;
}

const void **TNode::ExternalUnRegistrationProper(uint64_t a1, int a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  TFSInfo *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  const void *v11;
  unint64_t *v12;
  unint64_t v13;
  TNode *v14;
  os_unfair_lock_s *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  const void *v21;

  v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v6);
  v8 = *(TFSInfo **)(a1 + 16);
  v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v6);
  v11 = TFSInfo::CopySFBrowserRef(v8);
  v21 = v11;
  if (v7)
  {
    v12 = (unint64_t *)&v7->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    v11 = v21;
  }
  if (v11)
  {
    TNode::CloseNodeBrowserIfNecessary((TNode *)a1, 1);
    v15 = (os_unfair_lock_s *)TNode::InfoLock(v14);
    os_unfair_lock_lock(v15);
    v16 = *(std::__shared_weak_count **)(a1 + 24);
    if (v16)
    {
      v17 = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      os_unfair_lock_unlock(v15);
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    else
    {
      os_unfair_lock_unlock(v15);
    }
    TNode::RemoveNWNode(a2, a3);
  }
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v21);
}

void sub_1CBCD86FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::RemoveNWNode(int a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v6;

  v6 = a2;
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  TNode::GetNWNodeMap(a1);
  v4 = v3;
  v5 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(v3, &v6);
  if (v5)
    std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::erase(v4, v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

void sub_1CBCD878C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  _Unwind_Resume(a1);
}

void TNode::DoExternalUnRegistration(TNode *this)
{
  uint64_t NotifierList;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  TFSInfo *v10;
  const void *v11;
  id v12;
  void *v13;
  TFSInfo *v14;
  TNode *IsNetworkNode;
  TFSInfo *v16;
  std::__shared_weak_count *RootNode;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  const TNodePtr *v21;
  os_unfair_lock_s *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  TNode *IsNetworkNeighborhood;
  os_unfair_lock_s *v28;
  FINode *v29;
  FINode *v30;
  unint64_t *v31;
  unint64_t v32;
  TNode *v33;
  unint64_t *v34;
  unint64_t v35;
  os_unfair_lock_s *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  TNodePtr v40[2];
  id v41;
  id v42;
  id v43;
  const void *v44[2];
  std::__shared_weak_count *v45;

  NotifierList = TNode::GetNotifierList(this);
  v4 = *(_QWORD *)(NotifierList + 24);
  v3 = *(std::__shared_weak_count **)(NotifierList + 32);
  v44[1] = (const void *)v4;
  v45 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_lock((os_unfair_lock_t)v4);
  v7 = *(unsigned __int8 *)(v4 + 4);
  os_unfair_lock_unlock((os_unfair_lock_t)v4);
  if (v7)
  {
    TNode::UnsubscribeForFSNotification(this);
    os_unfair_lock_lock((os_unfair_lock_t)v4);
    *(_BYTE *)(v4 + 4) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)v4);
  }
  v8 = TNode::VirtualType(this);
  os_unfair_lock_lock((os_unfair_lock_t)v4);
  v9 = *(unsigned __int8 *)(v4 + 5);
  os_unfair_lock_unlock((os_unfair_lock_t)v4);
  if (v9)
  {
    v44[0] = 0;
    if (TNode::IsNetworkNode(this, (TGlobalNodes *)0x6E747362))
    {
      TGlobalNodes::NetworkSidebarNode(&v43);

      v11 = (const void *)TFSInfo::CopyNetworkSidebarBrowserRef(v10);
    }
    else if (TNode::IsNetworkNode(this, (TGlobalNodes *)0x6E74776B))
    {
      TGlobalNodes::NetworkNearbyNode(&v42);

      v11 = TFSInfo::CopyNetworkNearbyBrowserRef(v14);
    }
    else
    {
      IsNetworkNode = (TNode *)TNode::IsNetworkNode(this, (TGlobalNodes *)0x6D74726D);
      if (!(_DWORD)IsNetworkNode)
      {
        v22 = (os_unfair_lock_s *)TNode::InfoLock(IsNetworkNode);
        os_unfair_lock_lock(v22);
        v23 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldxr(v24);
          while (__stxr(v25 + 1, v24));
          os_unfair_lock_unlock(v22);
          do
            v26 = __ldaxr(v24);
          while (__stlxr(v26 - 1, v24));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
        else
        {
          os_unfair_lock_unlock(v22);
        }
        IsNetworkNeighborhood = (TNode *)TNode::IsNetworkNeighborhood(this);
        if ((_DWORD)IsNetworkNeighborhood)
        {
          v28 = (os_unfair_lock_s *)TNode::InfoLock(IsNetworkNeighborhood);
          os_unfair_lock_lock(v28);
          v30 = (FINode *)*((_QWORD *)this + 2);
          v29 = (FINode *)*((_QWORD *)this + 3);
          v40[0].fFINode = v30;
          v40[1].fFINode = v29;
          if (v29)
          {
            v31 = (unint64_t *)&v29[1];
            do
              v32 = __ldxr(v31);
            while (__stxr(v32 + 1, v31));
          }
          os_unfair_lock_unlock(v28);
          v33 = (TNode *)TFSInfo::CopySFBrowserRef((TFSInfo *)v30);
          v44[0] = v33;
          if (v29)
          {
            v34 = (unint64_t *)&v29[1];
            do
              v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              (*((void (**)(FINode *))v29->super.isa + 2))(v29);
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v29);
            }
          }
          v36 = (os_unfair_lock_s *)TNode::InfoLock(v33);
          os_unfair_lock_lock(v36);
          RootNode = (std::__shared_weak_count *)*((_QWORD *)this + 3);
          if (!RootNode)
          {
            os_unfair_lock_unlock(v36);
            goto LABEL_22;
          }
          v37 = (unint64_t *)&RootNode->__shared_owners_;
          do
            v38 = __ldxr(v37);
          while (__stxr(v38 + 1, v37));
          os_unfair_lock_unlock(v36);
          do
            v39 = __ldaxr(v37);
          while (__stlxr(v39 - 1, v37));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))RootNode->__on_zero_shared)(RootNode);
            std::__shared_weak_count::__release_weak(RootNode);
          }
        }
        RootNode = 0;
        goto LABEL_22;
      }
      TGlobalNodes::AirDropNode(&v41);

      v11 = TFSInfo::CopyAirDropBrowserRef(v16);
    }
    v44[0] = v11;
    if (!v11)
    {
LABEL_24:
      TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(v44);
      v3 = v45;
LABEL_25:
      if (!v3)
        return;
      goto LABEL_26;
    }
    RootNode = (std::__shared_weak_count *)SFBrowserGetRootNode();
LABEL_22:
    if (v44[0])
    {
      v18 = TNode::VirtualType(this);
      TNode::ExternalUnRegistrationProper((uint64_t)this, v18, (uint64_t)RootNode);
    }
    goto LABEL_24;
  }
  if (v8 != 26)
  {
    if (!TNode::IsFPv2(this, 1))
    {
      TNodePtr::TNodePtr(v40, this);
      TProgressMap::RemoveSubscriberForExternalProgress(v40, v21);

      if (!v3)
        return;
      goto LABEL_26;
    }
    TChildrenList::StopCollectionStatusObserver(*((TChildrenList **)this + 7));
    goto LABEL_25;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v4);
  v12 = *(id *)(v4 + 8);
  os_unfair_lock_unlock((os_unfair_lock_t)v4);
  if (v12)
  {
    objc_msgSend(v12, "stopObserving");
    os_unfair_lock_lock((os_unfair_lock_t)v4);
    v13 = *(void **)(v4 + 8);
    *(_QWORD *)(v4 + 8) = 0;

    os_unfair_lock_unlock((os_unfair_lock_t)v4);
  }

  if (v3)
  {
LABEL_26:
    v19 = (unint64_t *)&v3->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1CBCD8B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  const void *v7;
  va_list va;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, const void *);
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void TNode::UnsubscribeForFSNotification(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_8;
  v9 = (unint64_t *)&v3->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (v10)
  {
LABEL_8:
    if ((v8 & 0x20) == 0)
      return;
LABEL_11:
    TChildrenList::UnsubscribeWithKQueue(*((TChildrenList **)this + 7));
    return;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  if ((v8 & 0x20) != 0)
    goto LABEL_11;
}

BOOL TNode::IsFPv2(TNode *this, int a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _BOOL8 IsFPv2;
  unint64_t *v10;
  unint64_t v11;

  v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  v6 = (TFSInfo *)*((_QWORD *)this + 2);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  IsFPv2 = TFSInfo::IsFPv2(v6, a2);
  if (v5)
  {
    v10 = (unint64_t *)&v5->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return IsFPv2;
}

void sub_1CBCD8D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN5TNode10RemoveSelfEP14TNodeEventPtrs_block_invoke(uint64_t a1)
{
  _QWORD v2[4];
  id v3;
  char v4;

  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3321888768;
  v2[2] = ___ZZN5TNode10RemoveSelfEP14TNodeEventPtrsENK3__0clEv_block_invoke;
  v2[3] = &__block_descriptor_41_ea8_32c13_ZTS8TNodePtr_e5_v8__0l;
  v3 = *(id *)(a1 + 32);
  v4 = *(_BYTE *)(a1 + 40);
  ExceptionSafeBlock(v2);

}

void sub_1CBCD8DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c48_ZTSKZN5TNode10RemoveSelfEP14TNodeEventPtrsE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZN5TNode10RemoveSelfEP14TNodeEventPtrsE3__0(uint64_t a1)
{

}

void TNode::SendNotifications(TNode *a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  int v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  TNodePtr v9;

  v2 = a2 + 1;
  v3 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v5 = *((_DWORD *)v3 + 7);
      TNodePtr::TNodePtr(&v9, a1);
      TNode::SendNotification(a1, 2, (id *)&v9.fFINode, v5, 0);

      v6 = (_QWORD *)v3[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v3[2];
          v8 = *v7 == (_QWORD)v3;
          v3 = v7;
        }
        while (!v8);
      }
      v3 = v7;
    }
    while (v7 != v2);
  }
}

void sub_1CBCD8E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TNode::DetachFPItemsMetadata(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  TFSInfo *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  id *v9;
  id *v10;
  FINode *v11;
  TNode *v12;
  TFSInfo *v13;
  std::__shared_weak_count *v14;
  TFSInfo **v15;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = (TFSInfo *)*((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v13 = v4;
  v14 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::UpdateFileProvider(v4, 0);
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  TNode::RecursiveChildrenAndSelf(this, 0, &v13);
  v9 = (id *)v13;
  v10 = (id *)&v14->__vftable;
  while (v9 != v10)
  {
    v11 = (FINode *)*v9;
    v12 = (TNode *)TNodeFromFINode(v11);
    TNode::ClearFPItems(v12);

    ++v9;
  }
  v15 = &v13;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
}

void sub_1CBCD8F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TNode::Remove(TNode *this, char a2, TNodeEventPtrs *a3)
{
  os_unfair_lock_s *v6;
  TNodePtr v7;
  FINode *v8[3];

  v6 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v6);
  TNodePtr::TNodePtr(&v7, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v6);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v8, &v7, 0);

  if (*((_QWORD *)this + 7))
    TNode::RemoveAllChildren(this, a2, a3);
  TNode::RemoveSelf(this, a3);
  TNode::StPopulating::~StPopulating(v8);
}

void sub_1CBCD9060(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

void TNode::RestartObservingCollection(TNode *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD block[5];
  TFSVolumeInfo *v7;
  std::__shared_weak_count *v8;

  TNode::GetVolumeInfo(this, &v7);
  TFSVolumeInfo::GetSynchingGCDQueue(v7);
  v2 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN5TNode26RestartObservingCollectionEv_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c48_ZTSKZN5TNode26RestartObservingCollectionEvE3__0_e5_v8__0l;
  block[4] = this;
  dispatch_sync(v2, block);

  v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1CBCD9154(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1 - 32);
  _Unwind_Resume(a1);
}

void ___ZN5TNode26RestartObservingCollectionEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  __CFString *fRef;
  __CFString *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  TString v13;
  std::__shared_weak_count *v14;
  _BYTE buf[24];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (TChildrenList::StopCollectionStatusObserver(*(TChildrenList **)(v1 + 56)))
  {
    TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)v1);
    v12 = 0x4014000000000000;
    TNode::UpdateFPItemIfNeeded((id *)buf, (double *)&v12, 1, 1, 1, &v13);
    if (v14)
      fRef = v13.fString.fRef;
    else
      fRef = 0;
    if (v14)
      v3 = 0;
    else
      v3 = v13.fString.fRef;

    if (v3)
      TNode::FPItemsCollection((TNode *)v1, (FPItem *)v3);
    else
      TNode::FPItemsCollectionFromURL((TNode *)v1);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (v4)
    {
      v5 = *(_QWORD *)(v1 + 56);
      TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)v1);
      TNode::GetVolumeInfo((TNode *)v1, &v13);
      TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)v13.fString.fRef);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      TChildrenList::StartCollectionStatusObserver(v5, v4, (uint64_t)buf, v6, 1);

      v7 = v14;
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }

    }
    else
    {
      LogObj(4);
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        TNode::GetPath(v1, 1, (uint64_t)&v13);
        SanitizedPath(&v13);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v11;
        _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_ERROR, "Restart observing failed, no collection found for node %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);

      }
    }

  }
}

void sub_1CBCD9360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  va_list va;

  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c48_ZTSKZN5TNode26RestartObservingCollectionEvE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void TNode::RestartCollections(TNode *this, int a2)
{
  NSObject *v4;
  _BOOL4 v5;
  void *v6;
  __CFString *fRef;
  __CFString *v8;
  FINode *v9;
  TNode *v10;
  void *v11;
  TString v12;
  __CFString *v13;
  _BYTE buf[24];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  LogObj(4);
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)&v12);
      SanitizedPath(&v12);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v6;
      _os_log_impl(&dword_1CBC4A000, v4, OS_LOG_TYPE_DEFAULT, "Recursively restarting collections for %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);

    }
    TNode::RecursiveChildrenAndSelf(this, 1, &v12);
    fRef = v12.fString.fRef;
    v8 = v13;
    while (fRef != v8)
    {
      v9 = fRef->isa;
      v10 = (TNode *)TNodeFromFINode(v9);
      TNode::RestartObservingCollection(v10);

      fRef = (__CFString *)((char *)fRef + 8);
    }
    *(_QWORD *)buf = &v12;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  }
  else
  {
    if (v5)
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)&v12);
      SanitizedPath(&v12);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v11;
      _os_log_impl(&dword_1CBC4A000, v4, OS_LOG_TYPE_DEFAULT, "Restarting collection for %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);

    }
    TNode::RestartObservingCollection(this);
  }
}

void sub_1CBCD95CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void TNode::ClearFPItems(TNode *this)
{
  id *v2;
  void **v3;
  void **v4;
  void **v5[3];
  id *v6[3];
  void ***v7;
  id v8;
  id **v9;

  if (!TNode::IsFPv2(this, 1))
  {
    memset(v6, 0, sizeof(v6));
    TNode::CopyChildren(this, (uint64_t)v5);
    v2 = v5[0];
    v3 = v5[1];
    v9 = v6;
    while (v2 != v3)
    {
      v4 = (void **)*v2;
      v7 = (void ***)v4;
      v8 = 0;
      std::back_insert_iterator<std::vector<std::pair<TNodePtr,FPItem * {__strong}>>>::operator=[abi:ne180100]((uint64_t **)&v9, (uint64_t)&v7);

      ++v2;
    }
    v7 = v5;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
    TNode::AttachFPItemsMetadata(v6, 0, 1);
    TChildrenList::StopCollectionStatusObserver(*((TChildrenList **)this + 7));
    v5[0] = (void **)v6;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](v5);
  }
}

void sub_1CBCD9700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  a10 = (void **)&a13;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void TNode::UpdateFPItemIfNeeded(id *a1@<X0>, double *a2@<X1>, int a3@<W2>, int a4@<W3>, char a5@<W4>, _QWORD *a6@<X8>)
{
  id v11;
  void **v12;
  id v13;
  uint64_t v14;
  id v15;
  id v16;
  void **v17;
  void **v18;
  void **v19;
  uint64_t v20[3];
  void ***v21;
  char v22;

  v11 = *a1;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v21 = &v17;
  v22 = 0;
  v12 = (void **)operator new(8uLL);
  v17 = v12;
  v18 = v12;
  v19 = v12 + 1;
  v13 = v11;
  *v12 = v13;
  v18 = v12 + 1;
  TNode::UpdateFPItemsIfNeeded((FINode ***)&v17, a2, a3, a4, a5, v20);
  v21 = &v17;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v21);

  v14 = v20[0];
  if (v20[0] == v20[1])
  {
    v15 = 0;
    v16 = 0;
  }
  else
  {
    v15 = *(id *)v20[0];
    v16 = *(id *)(v14 + 8);
  }
  *a6 = v15;
  a6[1] = v16;
  v17 = (void **)v20;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v17);
}

void sub_1CBCD9858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

char *__copy_helper_block_ea8_32c90_ZTSKZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEEE3__0(uint64_t a1, uint64_t a2)
{
  id v4;

  v4 = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = v4;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  return std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)(a1 + 40), *(void ***)(a2 + 40), *(void ***)(a2 + 48), (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3);
}

void sub_1CBCD98C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c90_ZTSKZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEEE3__0(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 40);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v2);

}

id *TNode::UpdateFPItemsMetadata(std::vector<TNodePtr> const&)::$_0::~$_0(id *a1)
{
  void **v3;

  v3 = a1 + 1;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v3);

  return a1;
}

void TNode::Synchronize(uint64_t a1, _QWORD *a2, int a3)
{
  unsigned int v4;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int v10;
  unint64_t v11;

  if ((a3 & 0x10000) != 0)
    v4 = 268959744;
  else
    v4 = 285212672;
  if (*a2)
    goto LABEL_13;
  v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v5);
  v7 = *(_QWORD *)(a1 + 16);
  v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    os_unfair_lock_unlock(v5);
    v10 = *(unsigned __int8 *)(v7 + 112);
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    if (v10)
      goto LABEL_13;
  }
  else
  {
    os_unfair_lock_unlock(v5);
    if (*(_BYTE *)(v7 + 112))
    {
LABEL_13:
      TNode::RequestSynchronize((TGlobalNodes *)a1, 0);
      return;
    }
  }
  TNode::HandleSync(a1, v4);
}

void TNode::UpdateOnDiskProviderRoot(TNode *this)
{
  TNode *v2;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  int v10;
  id v11;
  void *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  TNode *v17;
  FINode *v18;
  NSObject *v19;
  uint64_t v20;
  os_unfair_lock_s *v21;
  std::__shared_weak_count *v22;
  TFSInfo *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  os_unfair_lock_s *v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  os_unfair_lock_s *v34;
  uint64_t v35;
  int v36;
  id v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  TNode *v41;
  TNode *v42;
  unint64_t *v43;
  unint64_t v44;
  FINode *v45;
  id v46[2];
  std::__shared_weak_count *v47;
  __int128 buf;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (UseFileProviderFramework())
  {
    v2 = (TNode *)TNode::VirtualType(this);
    if ((_DWORD)v2 == 27)
    {
      v3 = (os_unfair_lock_s *)TNode::InfoLock(v2);
      os_unfair_lock_lock(v3);
      v5 = *((_QWORD *)this + 2);
      v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
      v46[1] = (id)v5;
      v47 = v4;
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v3);
      v8 = (os_unfair_lock_s *)(v5 + 96);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 96));
      v9 = *(_QWORD *)(v5 + 80);
      if (v9
        && (os_unfair_lock_lock((os_unfair_lock_t)(v9 + 72)),
            v10 = *(unsigned __int8 *)(v9 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v9 + 72)),
            v10 == 1))
      {
        v11 = *(id *)(v9 + 24);
      }
      else
      {
        v11 = 0;
      }
      os_unfair_lock_unlock(v8);
      if (objc_msgSend(v11, "isUsingFPFS"))
      {
        objc_msgSend(v11, "rootURL");
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        if (v12)
        {
          v13 = objc_msgSend(v11, "isiCloudDriveProvider");
          if (v13)
          {
            objc_msgSend(v12, "URLByAppendingPathComponent:", CFSTR("com~apple~CloudDocs"));
            v14 = objc_claimAutoreleasedReturnValue();

            v12 = (void *)v14;
          }
          v46[0] = 0;
          *(_QWORD *)&buf = v12;
          TNode::GetNodeFromURL((CFURLRef *)&buf, (TNodePtr *)v46, 0);
          if (!TNodeFromFINode((FINode *)v46[0])
            || (v15 = TNodeFromFINode((FINode *)v46[0]),
                v16 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v15),
                os_unfair_lock_lock(v16),
                TNodePtr::TNodePtr((TNodePtr *)&buf, *(const TNode **)(v15 + 48)),
                os_unfair_lock_unlock(v16),
                LOBYTE(v16) = TNodeFromFINode((FINode *)buf) == 0,
                (id)buf,
                (v16 & 1) != 0))
          {
            LogObj(4);
            v19 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138543362;
              *(_QWORD *)((char *)&buf + 4) = v11;
              _os_log_impl(&dword_1CBC4A000, v19, OS_LOG_TYPE_ERROR, "No root node found for domain %{public}@", (uint8_t *)&buf, 0xCu);
            }

          }
          else
          {
            if (v13)
            {
              v17 = (TNode *)TNodeFromFINode((FINode *)v46[0]);
              TNode::GetParent(v17, (TNodePtr *)&v45);
              v18 = v45;
            }
            else
            {
              v18 = (FINode *)v46[0];
              v45 = v18;
            }
            v20 = TNodeFromFINode(v18);
            v21 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v20);
            os_unfair_lock_lock(v21);
            v23 = *(TFSInfo **)(v20 + 16);
            v22 = *(std::__shared_weak_count **)(v20 + 24);
            *(_QWORD *)&buf = v23;
            *((_QWORD *)&buf + 1) = v22;
            if (v22)
            {
              v24 = (unint64_t *)&v22->__shared_owners_;
              do
                v25 = __ldxr(v24);
              while (__stxr(v25 + 1, v24));
            }
            os_unfair_lock_unlock(v21);
            TFSInfo::UpdateFileProvider(v23, 0);
            if (v22)
            {
              v26 = (unint64_t *)&v22->__shared_owners_;
              do
                v27 = __ldaxr(v26);
              while (__stlxr(v27 - 1, v26));
              if (!v27)
              {
                ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
                std::__shared_weak_count::__release_weak(v22);
              }
            }
            v28 = TNodeFromFINode(v45);
            v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
            os_unfair_lock_lock(v29);
            v31 = *(_QWORD *)(v28 + 16);
            v30 = *(std::__shared_weak_count **)(v28 + 24);
            if (v30)
            {
              v32 = (unint64_t *)&v30->__shared_owners_;
              do
                v33 = __ldxr(v32);
              while (__stxr(v33 + 1, v32));
            }
            os_unfair_lock_unlock(v29);
            v34 = (os_unfair_lock_s *)(v31 + 96);
            os_unfair_lock_lock((os_unfair_lock_t)(v31 + 96));
            v35 = *(_QWORD *)(v31 + 80);
            if (v35
              && (os_unfair_lock_lock((os_unfair_lock_t)(v35 + 72)),
                  v36 = *(unsigned __int8 *)(v35 + 76),
                  os_unfair_lock_unlock((os_unfair_lock_t)(v35 + 72)),
                  v36 == 1))
            {
              v37 = *(id *)(v35 + 24);
            }
            else
            {
              v37 = 0;
            }
            os_unfair_lock_unlock(v34);
            if (v30)
            {
              v38 = (unint64_t *)&v30->__shared_owners_;
              do
                v39 = __ldaxr(v38);
              while (__stlxr(v39 - 1, v38));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                std::__shared_weak_count::__release_weak(v30);
              }
            }
            if (v37)
            {
              v40 = TNodeFromFINode((FINode *)v46[0]);
              if (v40 != TNodeFromFINode(v45))
              {
                v41 = (TNode *)TNodeFromFINode((FINode *)v46[0]);
                TNode::AttachCreateFPItemIfNeeded(v41, 1);
              }
              v42 = (TNode *)TNodeFromFINode(v45);
              TNode::AttachCreateFPItemIfNeeded(v42, 1);
            }

          }
        }
        v4 = v47;
      }

      if (v4)
      {
        v43 = (unint64_t *)&v4->__shared_owners_;
        do
          v44 = __ldaxr(v43);
        while (__stlxr(v44 - 1, v43));
        if (!v44)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
  }
}

void sub_1CBCD9E40(_Unwind_Exception *a1, void *a2, void *a3, ...)
{
  void *v3;
  void *v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::UpdateFPItemsIfNeeded@<X0>(FINode ***a1@<X0>, double *a2@<X1>, int a3@<W2>, int a4@<W3>, char a5@<W4>, uint64_t *a6@<X8>)
{
  FINode **v9;
  void *v10;
  TNode *v11;
  id v12;
  uint64_t v13;
  os_unfair_lock_s *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  os_unfair_lock_s *v18;
  std::__shared_weak_count *v19;
  TFSInfo *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  int v25;
  void *v26;
  void *v27;
  TNode *v28;
  TNode *v29;
  TNode *v30;
  int v31;
  uint64_t v32;
  os_unfair_lock_s *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  unsigned __int8 *v38;
  int v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t **v42;
  TNode *v43;
  uint64_t **v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  void *v48;
  TNode *v49;
  void *v50;
  TNode *v51;
  TCachedAppLibraryCollections *v52;
  TCachedAppLibraryCollections *v53;
  TString *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  void *v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  double v63;
  id v64;
  void *v65;
  uint64_t **v66;
  id i;
  uint64_t *v68;
  _WORD *v69;
  CFTypeRef *p_cf2;
  uint64_t v71;
  id *j;
  BOOL v73;
  FINode *v74;
  uint64_t **v75;
  uint64_t v76;
  uint64_t v77;
  id v78;
  void *v79;
  uint64_t **v80;
  id k;
  uint64_t *v82;
  _WORD *v83;
  CFTypeRef *v84;
  uint64_t v85;
  id *m;
  BOOL v87;
  id v88;
  void *v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  void *v94;
  double *v95;
  void *v96;
  id obj;
  void *v100;
  FINode ***v102;
  uint64_t v103[5];
  __int16 v104;
  char v105;
  uint64_t v106[5];
  __int16 v107;
  char v108;
  __int128 v109;
  __int128 v110;
  int v111;
  __int128 v112;
  __int128 v113;
  int v114;
  CFTypeRef cf1[2];
  __int128 v116;
  __int128 v117;
  __int128 v118;
  uint64_t v119;
  id v120;
  id location;
  void *v122;
  char *v123;
  id *p_location;
  char v125;
  CFTypeRef cf2;
  std::__shared_weak_count *v127;
  uint64_t v128;
  CFTypeRef *v129;
  _BYTE v130[32];
  CFTypeRef v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  FINode *v135;
  id v136;
  id v137;

  v137 = (id)*MEMORY[0x1E0C80C00];
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::vector(a6, a1[1] - *a1);
  v112 = 0u;
  v113 = 0u;
  v114 = 1065353216;
  v109 = 0u;
  v110 = 0u;
  v111 = 1065353216;
  v9 = *a1;
  v102 = a1;
  if (*a1 != a1[1])
  {
    v95 = a2;
    v10 = 0;
    while (1)
    {
      v11 = (TNode *)TNodeFromFINode(*v9);
      TNode::GetFPItem(v11);
      v12 = (id)objc_claimAutoreleasedReturnValue();
      v13 = TNodeFromFINode(*v9);
      v14 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v13);
      os_unfair_lock_lock(v14);
      TNodePtr::TNodePtr((TNodePtr *)&location, *(const TNode **)(v13 + 48));
      os_unfair_lock_unlock(v14);
      if (v12)
        break;
      if (!TNodeFromFINode((FINode *)location) || !ICloudDriveFPFSEnabled())
        goto LABEL_23;
      v17 = TNodeFromFINode(*v9);
      v18 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v17);
      os_unfair_lock_lock(v18);
      v20 = *(TFSInfo **)(v17 + 16);
      v19 = *(std::__shared_weak_count **)(v17 + 24);
      cf2 = v20;
      v127 = v19;
      if (v19)
      {
        p_shared_owners = (unint64_t *)&v19->__shared_owners_;
        do
          v22 = __ldxr(p_shared_owners);
        while (__stxr(v22 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v18);
      TFSInfo::Name(v20, (TString *)cf1);
      if (v19)
      {
        v23 = (unint64_t *)&v19->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      TString::TString((TString *)&cf2, "Documents", 9uLL);
      v25 = CFEqual(cf1[0], cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(cf1);
      if (!v25)
      {
LABEL_23:

LABEL_24:
        v30 = (TNode *)TNodeFromFINode(*v9);
        v31 = TNode::VirtualType(v30);
        v32 = TNodeFromFINode(*v9);
        v33 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v32);
        os_unfair_lock_lock(v33);
        v35 = *(_QWORD *)(v32 + 16);
        v34 = *(std::__shared_weak_count **)(v32 + 24);
        location = (id)v35;
        v122 = v34;
        if (v34)
        {
          v36 = (unint64_t *)&v34->__shared_owners_;
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
        }
        os_unfair_lock_unlock(v33);
        os_unfair_lock_lock((os_unfair_lock_t)(v35 + 96));
        v38 = *(unsigned __int8 **)(v35 + 80);
        if (v38)
        {
          os_unfair_lock_lock((os_unfair_lock_t)v38 + 18);
          v39 = v38[76];
          os_unfair_lock_unlock((os_unfair_lock_t)v38 + 18);
          if (v39 == 1)
            v38 = (unsigned __int8 *)*((id *)v38 + 3);
          else
            v38 = 0;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v35 + 96));
        objc_msgSend(v38, "domain");
        v135 = (FINode *)objc_claimAutoreleasedReturnValue();

        if (v34)
        {
          v40 = (unint64_t *)&v34->__shared_owners_;
          do
            v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
        if (v31 == 27 && v135)
        {
          objc_initWeak(&location, *v9);
          v122 = v10;
          p_location = (id *)&v135;
          v42 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)&v112, (id *)&v135, (uint64_t)&std::piecewise_construct, &p_location);
          std::pair<FINode * {__weak},unsigned long>::operator=[abi:ne180100]((uint64_t)(v42 + 3), &location);
          objc_destroyWeak(&location);
        }
        else
        {
          v43 = (TNode *)TNodeFromFINode(*v9);
          location = 0;
          TNode::CopyURL(v43, (const __CFURL **)&location);
          v120 = location;
          if (location)
          {
            objc_initWeak(&location, *v9);
            v122 = v10;
            p_location = &v120;
            v44 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>((uint64_t)&v109, (CFTypeRef *)&v120, (uint64_t)&std::piecewise_construct, (const void ***)&p_location);
            std::pair<FINode * {__weak},unsigned long>::operator=[abi:ne180100]((uint64_t)(v44 + 3), &location);
            objc_destroyWeak(&location);
          }
          else
          {
            v45 = *a6;
            v46 = *(void **)(*a6 + 16 * (_QWORD)v10);
            *(_QWORD *)(*a6 + 16 * (_QWORD)v10) = 0;

            v47 = v45 + 16 * (_QWORD)v10;
            v48 = *(void **)(v47 + 8);
            *(_QWORD *)(v47 + 8) = 0;

          }
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v120);
        }

        v12 = 0;
        goto LABEL_44;
      }
      +[FIPresentationNodeMap presentationNodeForKeyNode:](FIPresentationNodeMap, "presentationNodeForKeyNode:", *v9);
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      static_objc_cast<NSString,objc_object * {__strong}>(v26);
      v27 = (void *)objc_claimAutoreleasedReturnValue();

      if (v27
        && (v28 = (TNode *)objc_msgSend(v27, "asTNode"), (v29 = v28) != 0)
        && TNode::VirtualType(v28) == 25)
      {
        TNode::GetFPItem(v29);
        v12 = (id)objc_claimAutoreleasedReturnValue();

        if (v12)
          break;
      }
      else
      {

      }
      v49 = (TNode *)TNodeFromFINode(*v9);
      TNode::GetFIProvider(v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      v96 = v50;
      v51 = (TNode *)TNodeFromFINode((FINode *)location);
      TNode::GetFPItem(v51);
      v100 = (void *)objc_claimAutoreleasedReturnValue();
      if (objc_msgSend(v100, "isContainer")
        && (v52 = (TCachedAppLibraryCollections *)objc_msgSend(v50, "isiCloudDriveProvider"), (_DWORD)v52))
      {
        v53 = (TCachedAppLibraryCollections *)TCachedAppLibraryCollections::Singleton(v52);
        objc_msgSend(v50, "identifier");
        v54 = (TString *)(id)objc_claimAutoreleasedReturnValue();
        cf2 = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable((TString *)&cf2, v54);

        TCachedAppLibraryCollections::CachedCollection(v53, (const TString *)&cf2, 0);
        v94 = (void *)objc_claimAutoreleasedReturnValue();
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);

        *(_OWORD *)cf1 = 0u;
        v116 = 0u;
        v117 = 0u;
        v118 = 0u;
        objc_msgSend(v94, "items");
        obj = (id)objc_claimAutoreleasedReturnValue();
        v55 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", cf1, &cf2, 16);
        if (v55)
        {
          v56 = *(_QWORD *)v116;
LABEL_51:
          v57 = 0;
          while (1)
          {
            if (*(_QWORD *)v116 != v56)
              objc_enumerationMutation(obj);
            v12 = *((id *)cf1[1] + v57);
            objc_msgSend(v12, "fp_appContainerBundleIdentifier");
            v58 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v100, "fp_appContainerBundleIdentifier");
            v59 = (void *)objc_claimAutoreleasedReturnValue();
            v60 = objc_msgSend(v58, "isEqualToString:", v59);

            if ((v60 & 1) != 0)
              break;

            if (v55 == ++v57)
            {
              v55 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", cf1, &cf2, 16);
              if (v55)
                goto LABEL_51;
              goto LABEL_57;
            }
          }
        }
        else
        {
LABEL_57:
          v12 = 0;
        }

      }
      else
      {
        v12 = 0;
      }

      if (!v12)
        goto LABEL_24;
LABEL_5:
      v15 = *a6 + 16 * (_QWORD)v10;
      objc_storeStrong((id *)v15, v12);
      v16 = *(void **)(v15 + 8);
      *(_QWORD *)(v15 + 8) = 0;

      if (a3)
      {
        v135 = *v9;
        v12 = v12;
        v136 = v12;
        v122 = 0;
        v123 = 0;
        location = 0;
        p_location = &location;
        v125 = 0;
        location = operator new(0x10uLL);
        v122 = location;
        v123 = (char *)location + 16;
        v122 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v123, (id *)&v135, &v137, location);
        TNode::AttachFPItemsMetadata((id **)&location, a4, a5);
        p_location = &location;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&p_location);

      }
LABEL_44:

      ++v9;
      v10 = (char *)v10 + 1;
      if (v9 == v102[1])
      {
        v61 = *((_QWORD *)&v113 + 1);
        v62 = *((_QWORD *)&v110 + 1);
        a2 = v95;
        goto LABEL_64;
      }
    }

    goto LABEL_5;
  }
  v62 = 0;
  v61 = 0;
LABEL_64:
  if (v61 | v62)
  {
    v63 = *a2;
    v64 = objc_alloc(MEMORY[0x1E0C99DE8]);
    v65 = (void *)objc_msgSend(v64, "initWithCapacity:", *((_QWORD *)&v113 + 1));
    v66 = (uint64_t **)v113;
    for (i = v65; v66; v66 = (uint64_t **)*v66)
    {
      v68 = v66[2];
      objc_msgSend(i, "addObject:", v68);

    }
    *(double *)cf1 = v63 / (double)(unint64_t)(v61 + v62) * (double)*((unint64_t *)&v113 + 1);
    std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)v106, (uint64_t)&v112);
    LOBYTE(v107) = a3;
    HIBYTE(v107) = a4;
    v108 = a5;
    v129 = 0;
    v69 = operator new(0x38uLL);
    *(_QWORD *)v69 = &off_1E8750080;
    std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__hash_table((uint64_t)(v69 + 4), v106);
    v69[24] = v107;
    *((_BYTE *)v69 + 50) = v108;
    v129 = (CFTypeRef *)v69;
    TNode::RootFPItemsForDomainsWithTimeout(i, (double *)cf1, (uint64_t)&cf2, (uint64_t)&location);
    p_cf2 = v129;
    if (v129 == &cf2)
    {
      v71 = 4;
      p_cf2 = &cf2;
    }
    else
    {
      if (!v129)
      {
LABEL_72:
        std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)v106);
        IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::NSForwardIterator<NSMutableArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)&cf2, i);
        for (j = (id *)location; ; j += 2)
        {
          IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)cf1, -1, i);
          if (cf2 == cf1[0])
          {
            v73 = v134 == v119;

            if (v73)
            {

              cf2 = &location;
              std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&cf2);

              v78 = objc_alloc(MEMORY[0x1E0C99DE8]);
              v79 = (void *)objc_msgSend(v78, "initWithCapacity:", *((_QWORD *)&v110 + 1));
              v80 = (uint64_t **)v110;
              for (k = v79; v80; v80 = (uint64_t **)*v80)
              {
                v82 = v80[2];
                objc_msgSend(k, "addObject:", v82);

              }
              std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)v103, (uint64_t)&v109);
              LOBYTE(v104) = a3;
              HIBYTE(v104) = a4;
              v105 = a5;
              v129 = 0;
              v83 = operator new(0x38uLL);
              *(_QWORD *)v83 = &off_1E87500D8;
              std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__hash_table((uint64_t)(v83 + 4), v103);
              v83[24] = v104;
              *((_BYTE *)v83 + 50) = v105;
              v129 = (CFTypeRef *)v83;
              TNode::FPItemsFromURLsWithTimeout((const __CFArray *)k, (uint64_t)&cf2, (uint64_t)&location);
              v84 = v129;
              if (v129 == &cf2)
              {
                v85 = 4;
                v84 = &cf2;
LABEL_87:
                (*((void (**)(void))*v84 + v85))();
              }
              else if (v129)
              {
                v85 = 5;
                goto LABEL_87;
              }
              std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)v103);
              IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::NSForwardIterator<NSMutableArray<NSURL *>>::NSForwardIterator((uint64_t)&cf2, k);
              for (m = (id *)location; ; m += 2)
              {
                IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)cf1, -1, k);
                if (cf2 == cf1[0])
                {
                  v87 = v134 == v119;

                  if (v87)
                  {

                    cf2 = &location;
                    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&cf2);

                    goto LABEL_100;
                  }
                }
                else
                {

                }
                v88 = *(id *)(v128 + 8 * v133);
                v89 = v88;
                cf1[0] = v88;
                if (v88)
                  CFRetain(v88);
                p_location = (id *)cf1;
                v90 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)&v109, cf1, (uint64_t)&std::piecewise_construct, &p_location);
                TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(cf1);
                fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::operator=((id *)(*a6 + 16 * v90[4]), m);

                v91 = v133;
                if (v133 >= v132 - 1)
                {
                  v92 = objc_msgSend((id)cf2, "countByEnumeratingWithState:objects:count:", &v127, v130, 4);
                  v91 = -1;
                  v132 = v92;
                  v133 = -1;
                }
                if (v131 != *v129)
                {
                  objc_enumerationMutation((id)cf2);
                  v91 = v133;
                }
                ++v134;
                v133 = v91 + 1;
              }
            }
          }
          else
          {

          }
          v74 = (FINode *)*(id *)(v128 + 8 * v133);
          v135 = v74;
          p_location = (id *)&v135;
          v75 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)&v112, (id *)&v135, (uint64_t)&std::piecewise_construct, &p_location);
          fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::operator=((id *)(*a6 + 16 * (_QWORD)v75[4]), j);

          v76 = v133;
          if (v133 >= v132 - 1)
          {
            v77 = objc_msgSend((id)cf2, "countByEnumeratingWithState:objects:count:", &v127, v130, 4);
            v76 = -1;
            v132 = v77;
            v133 = -1;
          }
          if (v131 != *v129)
          {
            objc_enumerationMutation((id)cf2);
            v76 = v133;
          }
          ++v134;
          v133 = v76 + 1;
        }
      }
      v71 = 5;
    }
    (*((void (**)(void))*p_cf2 + v71))();
    goto LABEL_72;
  }
LABEL_100:
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&v109);
  return std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&v112);
}

void sub_1CBCDAAB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,id location)
{

  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&a31);
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&a37);
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  _Unwind_Resume(a1);
}

void TNode::RootFPItemsForDomainsWithTimeout(void *a1@<X0>, double *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  char *v5;
  unint64_t *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  std::mutex *v9;
  unint64_t v10;
  unint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  void *v16;
  id v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::string::__raw *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  dispatch_time_t v43;
  intptr_t v44;
  id v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t j;
  _QWORD *v49;
  NSObject *v50;
  std::string *p_p;
  std::string *v52;
  uint64_t *v53;
  uint64_t **v54;
  uint64_t *v55;
  uint64_t *v56;
  id v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t k;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::mutex *v72;
  uint64_t v73;
  id v74;
  id v75;
  id obj;
  void *v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  void *v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  id v92[2];
  std::__shared_weak_count *v93;
  std::__shared_weak_count *v94;
  std::__shared_weak_count *v95;
  std::mutex *v96;
  std::__shared_weak_count *v97;
  _QWORD *v98;
  std::__shared_weak_count *v99;
  _BYTE v100[128];
  std::string __p;
  std::string *v102;
  _QWORD *v103;
  std::__shared_weak_count *v104;
  std::mutex *v105;
  std::__shared_weak_count *v106;
  _QWORD v107[4];
  char *v108;
  id v109;
  _BYTE v110[24];
  _BYTE *v111;
  _QWORD *v112;
  std::__shared_weak_count *v113;
  std::mutex *v114;
  std::__shared_weak_count *v115;
  _BYTE v116[128];
  uint8_t v117[128];
  __int128 buf;
  uint64_t v119;

  v73 = a4;
  v119 = *MEMORY[0x1E0C80C00];
  v74 = a1;
  v5 = (char *)operator new(0x40uLL);
  *((_QWORD *)v5 + 1) = 0;
  v6 = (unint64_t *)(v5 + 8);
  *((_QWORD *)v5 + 2) = 0;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)v5 = &unk_1E8750848;
  *(_OWORD *)(v5 + 40) = 0u;
  *((_DWORD *)v5 + 14) = 1065353216;
  v98 = v5 + 24;
  v99 = (std::__shared_weak_count *)v5;
  v7 = (std::__shared_weak_count *)operator new(0x58uLL);
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750880;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)850045863;
  v9 = (std::mutex *)&v7[1];
  *(_OWORD *)&v7[1].__shared_owners_ = 0u;
  v7[2].std::__shared_count = 0u;
  *(_OWORD *)&v7[2].__shared_weak_owners_ = 0u;
  v7[3].__shared_owners_ = 0;
  v96 = (std::mutex *)&v7[1];
  v97 = v7;
  v75 = v74;
  v92[0] = v75;
  v92[1] = v5 + 24;
  v93 = (std::__shared_weak_count *)v5;
  do
    v10 = __ldxr(v6);
  while (__stxr(v10 + 1, v6));
  v94 = v7 + 1;
  v95 = v7;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  FPItemManagerInstance();
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  if (v78 && objc_msgSend(v75, "count"))
  {
    v12 = dispatch_group_create();
    v84 = 0u;
    v85 = 0u;
    v86 = 0u;
    v87 = 0u;
    obj = v75;
    v13 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v84, v116, 16);
    if (!v13)
      goto LABEL_61;
    v14 = *(_QWORD *)v85;
    while (1)
    {
      for (i = 0; i != v13; ++i)
      {
        if (*(_QWORD *)v85 != v14)
          objc_enumerationMutation(obj);
        v16 = *(void **)(*((_QWORD *)&v84 + 1) + 8 * i);
        dispatch_group_enter(v12);
        v107[0] = MEMORY[0x1E0C809B0];
        v107[1] = 3321888768;
        v107[2] = ___ZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEE_block_invoke;
        v107[3] = &__block_descriptor_112_ea8_32c174_ZTSKZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEEE3__1_e28_v24__0__FPItem_8__NSError_16l;
        v17 = v16;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v12;
        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)&__p.__r_.__value_.__r.__words[2], a3);
        v103 = v98;
        v104 = v99;
        if (v99)
        {
          v18 = (unint64_t *)&v99->__shared_owners_;
          do
            v19 = __ldxr(v18);
          while (__stxr(v19 + 1, v18));
        }
        v105 = v96;
        v106 = v97;
        if (v97)
        {
          v20 = (unint64_t *)&v97->__shared_owners_;
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        v108 = __p.__r_.__value_.__l.__data_;
        v109 = (id)__p.__r_.__value_.__l.__size_;
        v22 = (uint64_t)v102;
        if (!v102)
          goto LABEL_21;
        if (v102 != (std::string *)&__p.__r_.__value_.__r.__words[2])
        {
          v22 = (*(uint64_t (**)(void))(v102->__r_.__value_.__r.__words[0] + 16))();
LABEL_21:
          v111 = (_BYTE *)v22;
          goto LABEL_23;
        }
        v111 = v110;
        (*(void (**)(std::string::size_type *, _BYTE *))(__p.__r_.__value_.__r.__words[2] + 24))(&__p.__r_.__value_.__r.__words[2], v110);
LABEL_23:
        v112 = v103;
        v113 = v104;
        if (v104)
        {
          v23 = (unint64_t *)&v104->__shared_owners_;
          do
            v24 = __ldxr(v23);
          while (__stxr(v24 + 1, v23));
        }
        v114 = v105;
        v115 = v106;
        if (v106)
        {
          v25 = (unint64_t *)&v106->__shared_owners_;
          do
            v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
        }
        objc_msgSend(v78, "fetchRootItemForProviderDomain:completionHandler:", v17, v107);
        v27 = v106;
        if (v106)
        {
          v28 = (unint64_t *)&v106->__shared_owners_;
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 - 1, v28));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
        }
        v30 = v104;
        if (v104)
        {
          v31 = (unint64_t *)&v104->__shared_owners_;
          do
            v32 = __ldaxr(v31);
          while (__stlxr(v32 - 1, v31));
          if (!v32)
          {
            ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
            std::__shared_weak_count::__release_weak(v30);
          }
        }
        v33 = (std::string::__raw *)v102;
        if (v102 == (std::string *)&__p.__r_.__value_.__r.__words[2])
        {
          v33 = (std::string::__raw *)&__p.__r_.__value_.__r.__words[2];
          v34 = 4;
          goto LABEL_43;
        }
        if (v102)
        {
          v34 = 5;
LABEL_43:
          (*(void (**)(void))(v33->__words[0] + 8 * v34))();
        }

        v35 = v115;
        if (v115)
        {
          v36 = (unint64_t *)&v115->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        v38 = v113;
        if (v113)
        {
          v39 = (unint64_t *)&v113->__shared_owners_;
          do
            v40 = __ldaxr(v39);
          while (__stlxr(v40 - 1, v39));
          if (!v40)
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
        v41 = v111;
        if (v111 == v110)
        {
          v41 = v110;
          v42 = 4;
        }
        else
        {
          if (!v111)
            goto LABEL_59;
          v42 = 5;
        }
        (*(void (**)(void))(*v41 + 8 * v42))();
LABEL_59:

      }
      v13 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v84, v116, 16);
      if (!v13)
      {
LABEL_61:

        v43 = dispatch_time(0, (uint64_t)(*a2 * 1000000000.0));
        v44 = dispatch_group_wait(v12, v43);
        v72 = v96;
        if (v44)
        {
          std::mutex::lock(v96);
          v79 = 0u;
          v80 = 0u;
          v81 = 0u;
          v82 = 0u;
          v45 = obj;
          v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v79, v100, 16);
          if (v46)
          {
            v47 = *(_QWORD *)v80;
            do
            {
              for (j = 0; j != v46; ++j)
              {
                if (*(_QWORD *)v80 != v47)
                  objc_enumerationMutation(v45);
                v83 = *(void **)(*((_QWORD *)&v79 + 1) + 8 * j);
                v49 = v98;
                if (!std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::find<FPProviderDomain * {__strong}>(v98, &v83))
                {
                  *(_QWORD *)&buf = "Timed out (%fs) fetching root item for domain: %{public}@";
                  *((_QWORD *)&buf + 1) = 57;
                  FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>,FPProviderDomain * {__strong}>(&buf, a2, &v83, &__p);
                  LogObj(4);
                  v50 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  {
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    LODWORD(buf) = 136446210;
                    *(_QWORD *)((char *)&buf + 4) = p_p;
                    _os_log_impl(&dword_1CBC4A000, v50, OS_LOG_TYPE_ERROR, "RootFPItemsForDomainsWithTimeout - %{public}s", (uint8_t *)&buf, 0xCu);
                  }

                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    v52 = &__p;
                  else
                    v52 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  objc_msgSend(MEMORY[0x1E0CB35C8], "fp_errorWithPOSIXCode:description:", 100060, CFSTR("%s"), v52, v72, v73);
                  v53 = (uint64_t *)(id)objc_claimAutoreleasedReturnValue();
                  *(_QWORD *)&buf = &v83;
                  v54 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)v49, &v83, (uint64_t)&std::piecewise_construct, (id **)&buf);
                  v55 = v54[3];
                  v54[3] = 0;

                  v56 = v54[4];
                  v54[4] = v53;

                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(__p.__r_.__value_.__l.__data_);
                }
              }
              v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v79, v100, 16);
            }
            while (v46);
          }

          TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)v92, v73);
        }
        else
        {
          std::mutex::lock(v96);
          TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)v92, v73);
        }
        std::mutex::unlock(v72);

        v7 = v95;
        if (v7)
          goto LABEL_93;
        goto LABEL_97;
      }
    }
  }
  if (*(_QWORD *)(a3 + 24))
  {
    v90 = 0u;
    v91 = 0u;
    v88 = 0u;
    v89 = 0u;
    v57 = v75;
    v58 = objc_msgSend(v57, "countByEnumeratingWithState:objects:count:", &v88, v117, 16);
    if (v58)
    {
      v59 = *(_QWORD *)v89;
      do
      {
        for (k = 0; k != v58; ++k)
        {
          if (*(_QWORD *)v89 != v59)
            objc_enumerationMutation(v57);
          std::function<void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(a3, *(void **)(*((_QWORD *)&v88 + 1) + 8 * k), 0, 0);
        }
        v58 = objc_msgSend(v57, "countByEnumeratingWithState:objects:count:", &v88, v117, 16);
      }
      while (v58);
    }

  }
  std::mutex::lock(v9);
  TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)v92, v73);
  std::mutex::unlock(v9);

LABEL_93:
  v61 = (unint64_t *)&v7->__shared_owners_;
  do
    v62 = __ldaxr(v61);
  while (__stlxr(v62 - 1, v61));
  if (!v62)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_97:
  v63 = v93;
  if (v93)
  {
    v64 = (unint64_t *)&v93->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }

  v66 = v97;
  if (v97)
  {
    v67 = (unint64_t *)&v97->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  v69 = v99;
  if (v99)
  {
    v70 = (unint64_t *)&v99->__shared_owners_;
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }

}

void sub_1CBCDB6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::mutex *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,id a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,char a52)
{
  void *v52;

  std::mutex::unlock(a10);

  TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::~$_0(&a45);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a50);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a52);

  _Unwind_Resume(a1);
}

void TNode::FPItemsFromURLsWithTimeout(const __CFArray *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  const __CFArray *v4;
  _QWORD *v6;
  char *v7;
  CFIndex Count;
  const __CFArray *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  id v13;
  void *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  uint64_t **v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  char v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  std::mutex *v26;
  unint64_t *v27;
  unint64_t v28;
  BOOL v29;
  void *v30;
  _BOOL4 v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t j;
  id v38;
  void *v39;
  id v40;
  id v41;
  NSObject *v42;
  NSURL *v43;
  void *v44;
  id v45;
  id v46;
  id v47;
  id v48;
  uint64_t **v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  const __CFArray *obj;
  uint64_t v72;
  void *v73;
  void *v74;
  id v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  _QWORD *v80;
  std::__shared_weak_count *v81;
  std::mutex *v82;
  std::__shared_weak_count *v83;
  id v84;
  std::__shared_weak_count *v85;
  std::mutex *v86;
  std::__shared_weak_count *v87;
  CFArrayRef *p_theArray;
  std::__shared_weak_count *v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  CFArrayRef *v94;
  std::__shared_weak_count *v95;
  char *v96;
  std::__shared_weak_count *v97;
  std::mutex *v98;
  std::__shared_weak_count *v99;
  CFArrayRef theArray;
  const void *v101;
  id v102;
  id v103;
  _BYTE buf[12];
  __int16 v105;
  void *v106;
  _BYTE v107[128];
  _BYTE v108[128];
  uint64_t v109;

  v4 = a1;
  v109 = *MEMORY[0x1E0C80C00];
  theArray = a1;
  v6 = operator new(0x58uLL);
  v6[2] = 0;
  *v6 = &unk_1E8750880;
  v6[1] = 0;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  v6[10] = 0;
  v99 = (std::__shared_weak_count *)v6;
  v6[3] = 850045863;
  v98 = (std::mutex *)(v6 + 3);
  v7 = (char *)operator new(0x40uLL);
  *((_QWORD *)v7 + 2) = 0;
  *(_QWORD *)v7 = &unk_1E874EF58;
  *((_QWORD *)v7 + 1) = 0;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *((_DWORD *)v7 + 14) = 1065353216;
  v73 = v7 + 24;
  v96 = v7 + 24;
  v97 = (std::__shared_weak_count *)v7;
  if (*(_QWORD *)(a2 + 24))
  {
    std::allocate_shared[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)>,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,void>(a2, &v94);
    v4 = theArray;
  }
  else
  {
    v94 = 0;
    v95 = 0;
  }
  Count = CFArrayGetCount(v4);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>((uint64_t)v73, vcvtps_u32_f32((float)(unint64_t)Count / *((float *)v7 + 14)));
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v9 = theArray;
  v10 = -[__CFArray countByEnumeratingWithState:objects:count:](v9, "countByEnumeratingWithState:objects:count:", &v90, v108, 16);
  v69 = a3;
  if (v10)
  {
    v11 = *(_QWORD *)v91;
    do
    {
      for (i = 0; i != v10; ++i)
      {
        if (*(_QWORD *)v91 != v11)
          objc_enumerationMutation(v9);
        v13 = *(id *)(*((_QWORD *)&v90 + 1) + 8 * i);
        v14 = v13;
        LOBYTE(v84) = 0;
        LOBYTE(v85) = 0;
        LOBYTE(v86) = 0;
        LOBYTE(v87) = 0;
        p_theArray = v94;
        v89 = v95;
        if (v95)
        {
          p_shared_owners = (unint64_t *)&v95->__shared_owners_;
          do
            v16 = __ldxr(p_shared_owners);
          while (__stxr(v16 + 1, p_shared_owners));
        }
        v17 = (uint64_t)v96;
        *(_QWORD *)buf = v13;
        if (v13)
          CFRetain(v13);
        v80 = buf;
        v18 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>(v17, (CFTypeRef *)buf, (uint64_t)&std::piecewise_construct, &v80);
        std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0ul,1ul,2ul>((uint64_t)(v18 + 3), (uint64_t)&v84);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
        v19 = v89;
        if (v89)
        {
          v20 = (unint64_t *)&v89->__shared_owners_;
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
        if ((_BYTE)v87)

        if ((_BYTE)v85)
      }
      v10 = -[__CFArray countByEnumeratingWithState:objects:count:](v9, "countByEnumeratingWithState:objects:count:", &v90, v108, 16, v69);
    }
    while (v10);
    v7 = (char *)v97;
    v73 = v96;

    v84 = v73;
    v85 = (std::__shared_weak_count *)v7;
    if (!v7)
    {
      v22 = 1;
      goto LABEL_31;
    }
  }
  else
  {

    v84 = v7 + 24;
    v85 = (std::__shared_weak_count *)v7;
  }
  v23 = (unint64_t *)(v7 + 8);
  do
    v24 = __ldxr(v23);
  while (__stxr(v24 + 1, v23));
  v22 = 0;
LABEL_31:
  v26 = v98;
  v25 = v99;
  v86 = v98;
  v87 = v99;
  if (v99)
  {
    v27 = (unint64_t *)&v99->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v70 = v25;
  p_theArray = &theArray;
  if (theArray)
    v29 = Count == 0;
  else
    v29 = 1;
  if (v29
    || (FPItemManagerInstance(),
        v30 = (void *)objc_claimAutoreleasedReturnValue(),
        v31 = v30 == 0,
        v30,
        v31))
  {
    TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)&v84, v69);
  }
  else
  {
    v80 = v73;
    v81 = (std::__shared_weak_count *)v7;
    if ((v22 & 1) == 0)
    {
      v32 = (unint64_t *)(v7 + 8);
      do
        v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
    }
    v82 = v26;
    v83 = v70;
    if (v70)
    {
      v34 = (unint64_t *)&v70->__shared_owners_;
      do
        v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
    }
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    obj = theArray;
    v36 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v76, v107, 16);
    if (v36)
    {
      v72 = *(_QWORD *)v77;
      do
      {
        for (j = 0; j != v36; ++j)
        {
          if (*(_QWORD *)v77 != v72)
            objc_enumerationMutation(obj);
          v38 = *(id *)(*((_QWORD *)&v76 + 1) + 8 * j);
          FPItemManagerInstance();
          v39 = (void *)objc_claimAutoreleasedReturnValue();
          v40 = v38;
          v75 = 0;
          objc_msgSend(v39, "itemForURL:error:", v40, &v75);
          v74 = (void *)objc_claimAutoreleasedReturnValue();
          v41 = v75;

          if (v41)
          {
            LogObj(4);
            v42 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              v43 = (NSURL *)v40;
              SanitizedURL(v43);
              v44 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              *(_QWORD *)&buf[4] = v41;
              v105 = 2114;
              v106 = v44;
              _os_log_impl(&dword_1CBC4A000, v42, OS_LOG_TYPE_ERROR, "Failed to get FPItem error: %{public}@ for %{public}@", buf, 0x16u);

            }
          }
          v45 = v74;
          v46 = v41;

          v47 = v45;
          v103 = v47;
          v48 = v46;
          v102 = v48;
          std::mutex::lock(v26);
          v101 = v40;
          if (v40)
            CFRetain(v40);
          *(_QWORD *)buf = &v101;
          v49 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)v73, &v101, (uint64_t)&std::piecewise_construct, (_QWORD **)buf);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v101);
          std::optional<FPItem * {__strong}>::operator=[abi:ne180100]<FPItem * {__strong}&,void>((uint64_t)(v49 + 3), &v103);
          std::optional<FPItem * {__strong}>::operator=[abi:ne180100]<FPItem * {__strong}&,void>((uint64_t)(v49 + 5), &v102);
          std::mutex::unlock(v26);

        }
        v36 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v76, v107, 16);
      }
      while (v36);
    }

    std::mutex::lock(v26);
    TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)&v84, v69);
    std::mutex::unlock(v26);
    if (v70)
    {
      v50 = (unint64_t *)&v70->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
        std::__shared_weak_count::__release_weak(v70);
      }
    }
    v52 = v81;
    if (v81)
    {
      v53 = (unint64_t *)&v81->__shared_owners_;
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
    v70 = v87;
  }
  if (v70)
  {
    v55 = (unint64_t *)&v70->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
      std::__shared_weak_count::__release_weak(v70);
    }
  }
  v57 = v85;
  if (v85)
  {
    v58 = (unint64_t *)&v85->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  v60 = v95;
  if (v95)
  {
    v61 = (unint64_t *)&v95->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }
  v63 = v97;
  if (v97)
  {
    v64 = (unint64_t *)&v97->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  v66 = v99;
  if (v99)
  {
    v67 = (unint64_t *)&v99->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
}

void sub_1CBCDBF64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,char a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  std::mutex *v57;

  std::mutex::unlock(v57);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a27);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a33);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a31);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a46);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a48);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a50);
  _Unwind_Resume(a1);
}

void TNode::FPItemFromURLWithTimeout(const void *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  void *v6;
  const __CFArray *v7;
  void ***v8;
  uint64_t v9;
  void ***v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  id v16;
  _QWORD v17[3];
  __CFArray *Mutable;
  _QWORD v19[3];
  _QWORD *v20;
  void **v21[3];
  void ***v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1 || (FPItemManagerInstance(), v6 = (void *)objc_claimAutoreleasedReturnValue(), v6, v6))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(Mutable, a1);
    v7 = Mutable;
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v19, a2);
    v22 = 0;
    v8 = (void ***)operator new(0x28uLL);
    *v8 = (void **)&off_1E8752940;
    v9 = (uint64_t)v20;
    if (v20)
    {
      if (v20 == v19)
      {
        v8[4] = (void **)(v8 + 1);
        (*(void (**)(_QWORD *))(v19[0] + 24))(v19);
LABEL_8:
        v22 = v8;
        TNode::FPItemsFromURLsWithTimeout(v7, (uint64_t)v21, (uint64_t)v17);
        v10 = v22;
        if (v22 == v21)
        {
          v11 = 4;
          v10 = v21;
        }
        else
        {
          if (!v22)
            goto LABEL_13;
          v11 = 5;
        }
        ((void (*)(void))(*v10)[v11])();
LABEL_13:
        v12 = v20;
        if (v20 == v19)
        {
          v13 = 4;
          v12 = v19;
        }
        else
        {
          if (!v20)
          {
LABEL_18:
            v14 = v17[0];
            if (v17[0] == v17[1])
            {
              v15 = 0;
              v16 = 0;
            }
            else
            {
              v15 = *(id *)v17[0];
              v16 = *(id *)(v14 + 8);
            }
            *a3 = v15;
            a3[1] = v16;
            v21[0] = (void **)v17;
            std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](v21);
            TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)&Mutable);
            return;
          }
          v13 = 5;
        }
        (*(void (**)(void))(*v12 + 8 * v13))();
        goto LABEL_18;
      }
      v9 = (*(uint64_t (**)(void))(*v20 + 16))();
    }
    v8[4] = (void **)v9;
    goto LABEL_8;
  }
  if (*(_QWORD *)(a2 + 24))
    std::function<void ()(FPItem *,NSError *)>::operator()(a2, 0, 0);
  *a3 = 0;
  a3[1] = 0;
}

void sub_1CBCDC29C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  _Unwind_Resume(exception_object);
}

void std::function<void ()(FPItem *,NSError *)>::operator()(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5;
  id v6;
  id v7;

  v7 = a2;
  v6 = a3;
  v5 = *(_QWORD *)(a1 + 24);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *, id *))(*(_QWORD *)v5 + 48))(v5, &v7, &v6);

}

void sub_1CBCDC3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>::~tuple(uint64_t a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 32);
  if (*(_BYTE *)(a1 + 24))

  if (*(_BYTE *)(a1 + 8))
  return a1;
}

void TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_0::operator()(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  id v4;
  void *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  id v14;
  void *v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  void *v42;
  __int128 v43;
  _QWORD v44[2];
  id v45[17];
  id v46[19];
  id v47[17];
  id obj;
  _QWORD v49[8];
  _QWORD v50[5];
  uint64_t v51;
  uint64_t v52;
  char *v53;
  _QWORD *v54[5];
  const void *v55[2];

  v4 = **(id **)(a1 + 32);
  v5 = *(void **)a1;
  v6 = *(std::__shared_weak_count **)(a1 + 8);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)v46, v4);
  IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)v45, -1, v4);
  v9 = std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray>>((uint64_t)v46, (uint64_t)v45);

  type_traits_extras::CopyAsHelper<std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::MakeWithCapacity(v9, (uint64_t)&v43);
  if (v6)
  {
    v10 = (unint64_t *)&v6->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, v4);
  IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)v47, -1, v4);
  v41 = a2;
  v42 = v4;
  v46[17] = v5;
  v46[18] = v6;
  if (v6)
  {
    v12 = (unint64_t *)&v6->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  while (obj != v47[0] || v53 != v47[16])
  {
    v14 = *(id *)(v49[1] + 8 * v52);
    v15 = v14;
    v55[0] = v14;
    if (v14)
      CFRetain(v14);
    v54[0] = v55;
    v16 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)v5, v55, (uint64_t)&std::piecewise_construct, v54);
    v17 = (uint64_t)(v16 + 3);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v55);
    v18 = (uint64_t)(v16 + 5);
    v19 = (uint64_t)v16[7];
    if (v19)
    {
      v54[0] = 0;
      std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v17);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      v55[0] = 0;
      std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v18);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      std::function<void ()(__CFURL const*,FPItem *,NSError *)>::operator()(v19, (uint64_t)v15, v20, v21);

    }
    v54[0] = 0;
    std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v17);
    v22 = objc_claimAutoreleasedReturnValue();
    v55[0] = 0;
    std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v18);
    v23 = objc_claimAutoreleasedReturnValue();

    v24 = *((_QWORD *)&v43 + 1);
    if (*((_QWORD *)&v43 + 1) >= v44[0])
    {
      v26 = (uint64_t)(*((_QWORD *)&v43 + 1) - v43) >> 4;
      v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 60)
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      v28 = v44[0] - v43;
      if ((uint64_t)(v44[0] - v43) >> 3 > v27)
        v27 = v28 >> 3;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0)
        v29 = 0xFFFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      v54[4] = v44;
      v30 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)v44, v29);
      v31 = &v30[2 * v26];
      v54[0] = v30;
      v54[1] = v31;
      v54[3] = &v30[2 * v32];
      *v31 = v22;
      v31[1] = v23;
      v54[2] = v31 + 2;
      std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer((uint64_t *)&v43, v54);
      v25 = *((_QWORD *)&v43 + 1);
      std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v54);
    }
    else
    {
      **((_QWORD **)&v43 + 1) = v22;
      *(_QWORD *)(v24 + 8) = v23;
      v25 = v24 + 16;
    }
    *((_QWORD *)&v43 + 1) = v25;

    v33 = v52;
    if (v52 >= v51 - 1)
    {
      v34 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v49, v50, 4);
      v33 = -1;
      v51 = v34;
      v52 = -1;
    }
    if (v50[4] != *(_QWORD *)v49[2])
    {
      objc_enumerationMutation(obj);
      v33 = v52;
    }
    ++v53;
    v52 = v33 + 1;
  }
  if (v6)
  {
    v35 = (unint64_t *)&v6->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  if (v6)
  {
    v37 = (unint64_t *)&v6->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  *(_OWORD *)v41 = v43;
  *(_QWORD *)(v41 + 16) = v44[0];
  v44[0] = 0;
  v43 = 0uLL;
  obj = &v43;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&obj);
  if (v6)
  {
    v39 = (unint64_t *)&v6->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

}

void sub_1CBCDC83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  void *v17;
  uint64_t v18;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  *(_QWORD *)(v18 - 96) = &a17;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v18 - 96));
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a13);

  _Unwind_Resume(a1);
}

void std::function<void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7;
  id v8;
  id v9;
  id v10;

  v10 = a2;
  v9 = a3;
  v8 = a4;
  v7 = *(_QWORD *)(a1 + 24);
  if (!v7)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *, id *, id *))(*(_QWORD *)v7 + 48))(v7, &v10, &v9, &v8);

}

void sub_1CBCDC9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{

  _Unwind_Resume(a1);
}

void TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  std::__shared_weak_count *v4;
  _QWORD *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  id v13;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  id *v23;
  id *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  std::__shared_weak_count *v36;
  __int128 v37;
  unint64_t v38;
  id v39[17];
  id v40[19];
  id v41[17];
  id obj;
  _QWORD v43[8];
  _QWORD v44[5];
  uint64_t v45;
  uint64_t v46;
  char *v47;
  id v48;
  id *v49[7];

  v5 = *(_QWORD **)(a1 + 8);
  v4 = *(std::__shared_weak_count **)(a1 + 16);
  v35 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v40, *(void **)a1);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)v39, -1, *(void **)a1);
  v8 = std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>>((uint64_t)v40, (uint64_t)v39);

  type_traits_extras::CopyAsHelper<std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::MakeWithCapacity(v8, (uint64_t)&v37);
  v36 = v4;
  if (v4)
  {
    v9 = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)&obj, *(void **)a1);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)v41, -1, *(void **)a1);
  v40[17] = v5;
  v40[18] = v4;
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v34 = v4;
  while (obj != v41[0] || v47 != v41[16])
  {
    v13 = *(id *)(v43[1] + 8 * v46);
    v48 = v13;
    if (std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::find<FPProviderDomain * {__strong}>(v5, &v48))
    {
      v49[0] = &v48;
      v14 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)v5, &v48, (uint64_t)&std::piecewise_construct, v49);
      v15 = v14[3];
      v16 = v14[4];
    }
    else
    {
      v16 = 0;
      v15 = 0;
    }

    v17 = *((_QWORD *)&v37 + 1);
    if (*((_QWORD *)&v37 + 1) >= v38)
    {
      v19 = (uint64_t)(*((_QWORD *)&v37 + 1) - v37) >> 4;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 60)
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      v21 = v38 - v37;
      if ((uint64_t)(v38 - v37) >> 3 > v20)
        v20 = v21 >> 3;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
        v22 = 0xFFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      v49[4] = (id *)&v38;
      v23 = (id *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)&v38, v22);
      v24 = &v23[2 * v19];
      v49[0] = v23;
      v49[1] = v24;
      v49[3] = &v23[2 * v25];
      *v24 = v15;
      v24[1] = v16;
      v49[2] = v24 + 2;
      std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer((uint64_t *)&v37, v49);
      v18 = *((_QWORD *)&v37 + 1);
      std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v49);
    }
    else
    {
      **((_QWORD **)&v37 + 1) = v15;
      *(_QWORD *)(v17 + 8) = v16;
      v18 = v17 + 16;
    }
    *((_QWORD *)&v37 + 1) = v18;

    v26 = v46;
    if (v46 >= v45 - 1)
    {
      v27 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v43, v44, 4);
      v26 = -1;
      v45 = v27;
      v46 = -1;
    }
    if (v44[4] != *(_QWORD *)v43[2])
    {
      objc_enumerationMutation(obj);
      v26 = v46;
    }
    ++v47;
    v46 = v26 + 1;
  }
  if (v34)
  {
    v28 = (unint64_t *)&v34->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  if (v36)
  {
    v30 = (unint64_t *)&v36->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  *(_OWORD *)a2 = v37;
  *(_QWORD *)(a2 + 16) = v38;
  v38 = 0;
  v37 = 0uLL;
  obj = &v37;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&obj);
  if (v35)
  {
    v32 = (unint64_t *)&v35->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
}

void sub_1CBCDCD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  id a71;
  uint64_t v71;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  *(_QWORD *)(v71 - 96) = &a15;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v71 - 96));
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void ___ZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  NSObject *v9;
  uint64_t v10;
  std::mutex *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t **v15;
  uint64_t *v16;
  uint64_t *v17;
  _BYTE buf[12];
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = v5;
  v8 = v6;
  if (v8)
  {
    LogObj(4);
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)&buf[4] = v8;
      v19 = 2114;
      v20 = v10;
      _os_log_impl(&dword_1CBC4A000, v9, OS_LOG_TYPE_ERROR, "fetchRootItemForProviderDomain error: %{public}@ for %{public}@", buf, 0x16u);
    }

  }
  v11 = *(std::mutex **)(a1 + 96);
  std::mutex::lock(v11);
  v12 = (uint64_t *)v7;
  v13 = (uint64_t *)v8;
  v14 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)buf = a1 + 32;
  v15 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(v14, (id *)(a1 + 32), (uint64_t)&std::piecewise_construct, (id **)buf);
  v16 = v15[3];
  v15[3] = v12;

  v17 = v15[4];
  v15[4] = v13;

  std::mutex::unlock(v11);
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  if (*(_QWORD *)(a1 + 72))
    std::function<void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(a1 + 48, *(void **)(a1 + 32), v12, v13);

}

void sub_1CBCDCFC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c174_ZTSKZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEEE3__1(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  a1[4] = *(id *)(a2 + 32);
  a1[5] = *(id *)(a2 + 40);
  result = std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)(a1 + 6), a2 + 48);
  v5 = *(_QWORD *)(a2 + 88);
  a1[10] = *(_QWORD *)(a2 + 80);
  a1[11] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(_QWORD *)(a2 + 104);
  a1[12] = *(_QWORD *)(a2 + 96);
  a1[13] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

void sub_1CBCDD08C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c174_ZTSKZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEEE3__1(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 96);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 80);
  v2 = *(_QWORD **)(a1 + 72);
  if (v2 == (_QWORD *)(a1 + 48))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 48);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

}

uint64_t TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_1::~$_1(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 64);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 48);
  v2 = *(_QWORD **)(a1 + 40);
  if (v2 == (_QWORD *)(a1 + 16))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 16);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return a1;
}

id *TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::~$_0(id *a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));

  return a1;
}

void TNode::RootNodeForFPDomain(TNode *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  int v3;
  CFIndex Length;
  TNode *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  const char *v11;
  _QWORD *v12;
  unint64_t *v13;
  dispatch_semaphore_t v14;
  void *v15;
  unint64_t v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t v19;
  void *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  dispatch_time_t v24;
  intptr_t v25;
  id v26;
  void *v27;
  void *v28;
  BOOL v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  const TNode *v34;
  NSObject *v35;
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  unint64_t v38;
  NSObject *v39;
  const char *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  void ***v48;
  FINode **v49;
  FINode **v50;
  TNode *v51;
  void *v52;
  void *v53;
  FPProviderDomain *v54;
  int v55;
  TString *v56;
  BOOL v57;
  char v58;
  char v59;
  char v60;
  NSObject *v61;
  const char *v62;
  TNode *v63;
  void *v64;
  void *v65;
  TNode *v66;
  void *v67;
  int v68;
  TNode *v69;
  void *v70;
  void *v71;
  char v72;
  NSObject *v73;
  id v74;
  id v75;
  const char *v76;
  void *v77;
  uint64_t v78;
  NSObject *v79;
  TNode *v80;
  void *v81;
  id v83;
  BOOL v84;
  TNodePtr v85;
  FIProviderDomain *v86;
  CFTypeRef cf1;
  std::__shared_weak_count *v88;
  _QWORD v89[4];
  __int128 v90;
  NSObject *v91;
  TString v92;
  char v93;
  TNodePtr v94;
  _BYTE v95[22];
  _BYTE v96[12];
  __int128 buf;
  NSObject *v98;
  TString v99;
  char v100;
  uint64_t v101;

  v3 = (int)a2;
  v101 = *MEMORY[0x1E0C80C00];
  if ((UseFileProviderFramework() & 1) == 0 || !FPProviderDomainClass())
  {
    TNodePtr::TNodePtr(a3, 0);
    return;
  }
  Length = CFStringGetLength(*(CFStringRef *)this);
  TGlobalNodes::AllProvidersNode(&v94);
  v6 = (TNode *)TNodeFromFINode(v94.fFINode);
  if ((TNode::IsPopulated(v6) & 1) == 0)
  {
    if (Length)
    {
      LogObj(4);
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf) = 0;
        v8 = "Providers not yet loaded perform manual lookup for other";
        v9 = v7;
        v10 = 2;
LABEL_12:
        _os_log_impl(&dword_1CBC4A000, v9, OS_LOG_TYPE_INFO, v8, (uint8_t *)&buf, v10);
      }
    }
    else
    {
      LogObj(4);
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        v11 = "Main";
        if (v3)
          v11 = "DataSeparated";
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = v11;
        v8 = "Providers not loaded perform manual lookup for %{public}s iCloud";
        v9 = v7;
        v10 = 12;
        goto LABEL_12;
      }
    }

    v12 = operator new(0x20uLL);
    v12[1] = 0;
    v13 = v12 + 1;
    v12[2] = 0;
    *v12 = &unk_1E87508B8;
    v12[3] = 0;
    *(_QWORD *)v95 = v12 + 3;
    *(_QWORD *)&v95[8] = v12;
    v14 = dispatch_semaphore_create(0);
    v15 = (void *)FPProviderDomainClass();
    v89[0] = MEMORY[0x1E0C809B0];
    v89[1] = 3321888768;
    v89[2] = ___ZN5TNode19RootNodeForFPDomainERK7TStringb_block_invoke;
    v89[3] = &__block_descriptor_72_ea8_32c51_ZTSKZN5TNode19RootNodeForFPDomainERK7TStringbE3__1_e34_v24__0__NSDictionary_8__NSError_16l;
    *(_QWORD *)&buf = v12 + 3;
    *((_QWORD *)&buf + 1) = v12;
    do
      v16 = __ldxr(v13);
    while (__stxr(v16 + 1, v13));
    v17 = v14;
    v98 = v17;
    v99.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v99, *(TString **)this);
    v100 = v3;
    v90 = buf;
    if (*((_QWORD *)&buf + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
    v91 = v98;
    v92.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v92, (TString *)v99.fString.fRef);
    v93 = v100;
    objc_msgSend(v15, "beginMonitoringProviderDomainChangesWithHandler:", v89);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v99.fString.fRef);

    v21 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v24 = dispatch_time(0, 10000000000);
    v25 = dispatch_semaphore_wait(v17, v24);
    objc_msgSend((id)FPProviderDomainClass(), "endMonitoringProviderDomainChanges:", v20);
    v26 = **(id **)v95;
    v27 = v26;
    if (v25 || !v26)
    {
      if (!v25)
        goto LABEL_48;
      LogObj(4);
      v39 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
LABEL_47:

LABEL_48:
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v92.fString.fRef);

        v41 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
        if (*((_QWORD *)&v90 + 1))
        {
          v42 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
          do
            v43 = __ldaxr(v42);
          while (__stlxr(v43 - 1, v42));
          if (!v43)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }

        v44 = *(std::__shared_weak_count **)&v95[8];
        if (*(_QWORD *)&v95[8])
        {
          v45 = (unint64_t *)(*(_QWORD *)&v95[8] + 8);
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }
        goto LABEL_58;
      }
      LOWORD(buf) = 0;
      v40 = "Manual lookup of provider timed out";
    }
    else
    {
      objc_msgSend(v26, "storageURLs");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = objc_msgSend(v28, "count") == 0;

      if (v29)
        goto LABEL_48;
      +[FIProviderDomain providerDomainForDomain:](FIProviderDomain, "providerDomainForDomain:", v27);
      v86 = (FIProviderDomain *)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)&buf = 0;
      LOBYTE(v85.fFINode) = 1;
      std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},decltype(nullptr),BOOL,void>(&v86, (uint64_t)&buf, (unsigned __int8 *)&v85, &cf1);

      buf = 0uLL;
      TNode::CreateNode(&v85, &v94, &cf1, &buf);
      v30 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
      if (*((_QWORD *)&buf + 1))
      {
        v31 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      TNode::StPopulating::StPopulating((TNode::StPopulating *)&buf, &v94, 0);
      v84 = 0;
      v33 = TNodeFromFINode(v94.fFINode);
      TChildrenList::AddNewChild(*(TChildrenList **)(v33 + 56), &v85, &v84, &v83);
      if (v84)
      {
        v34 = (const TNode *)TNodeFromFINode(v94.fFINode);
        TNode::SendNotification(v34, 3, &v83, 0, 0);
      }
      LogObj(4);
      v35 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)v96 = 138543362;
        *(_QWORD *)&v96[4] = v27;
        _os_log_impl(&dword_1CBC4A000, v35, OS_LOG_TYPE_INFO, "Found provider from manual lookup %{public}@", v96, 0xCu);
      }

      TNode::StPopulating::~StPopulating((FINode **)&buf);
      v36 = v88;
      if (v88)
      {
        p_shared_owners = (unint64_t *)&v88->__shared_owners_;
        do
          v38 = __ldaxr(p_shared_owners);
        while (__stlxr(v38 - 1, p_shared_owners));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
      if (*(_QWORD *)v95)
        goto LABEL_48;
      LogObj(4);
      v39 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        goto LABEL_47;
      LOWORD(buf) = 0;
      v40 = "Failed to find provider with manual lookup";
    }
    _os_log_impl(&dword_1CBC4A000, v39, OS_LOG_TYPE_ERROR, v40, (uint8_t *)&buf, 2u);
    goto LABEL_47;
  }
LABEL_58:
  buf = 0uLL;
  v98 = 0;
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v95, &v94, 0);
  v47 = *(_QWORD *)(TNodeFromFINode(v94.fFINode) + 56);
  if (v47)
    v48 = (void ***)(v47 + 64);
  else
    v48 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  if (&buf != (__int128 *)v48)
    std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((uint64_t)&buf, *v48, v48[1], v48[1] - *v48);
  TNode::StPopulating::~StPopulating((FINode **)v95);
  v85.fFINode = 0;
  v49 = (FINode **)*((_QWORD *)&buf + 1);
  v50 = (FINode **)buf;
  if ((_QWORD)buf == *((_QWORD *)&buf + 1))
    goto LABEL_78;
  do
  {
    v51 = (TNode *)TNodeFromFINode(*v50);
    TNode::GetFIProvider(v51);
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v52, "domain");
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    if (v53
      && (objc_msgSend(v52, "domain"),
          v54 = (FPProviderDomain *)objc_claimAutoreleasedReturnValue(),
          v55 = IsDefaultFPDomain(v54),
          v54,
          v53,
          v55))
    {

    }
    else if (Length)
    {
      objc_msgSend(v52, "identifier");
      v56 = (TString *)(id)objc_claimAutoreleasedReturnValue();
      cf1 = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable((TString *)&cf1, v56);

      v57 = CFEqual(cf1, *(CFTypeRef *)this) == 0;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);

      if (!v57)
        goto LABEL_76;
    }
    else
    {
      if (v3)
        v58 = objc_msgSend(v52, "isDataSeparatedDomain");
      else
        v58 = objc_msgSend(v52, "isMainiCloudDriveDomain");
      v59 = v58;

      if ((v59 & 1) != 0)
        goto LABEL_76;
    }
    ++v50;
  }
  while (v50 != v49);
  v50 = v49;
LABEL_76:
  if (v50 == *((FINode ***)&buf + 1))
  {
LABEL_78:
    v60 = 0;
    v95[0] = 0;
  }
  else
  {
    *(_QWORD *)v95 = *v50;
    v60 = 1;
  }
  v95[8] = v60;
  std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>((uint64_t)v95, (TNodePtr *)v96);
  if (v95[8])

  if (!Length && TNodeFromFINode(*(FINode **)v96))
  {
    LogObj(4);
    v61 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
    {
      if (v3)
        v62 = "Enterprise";
      else
        v62 = "";
      v63 = (TNode *)TNodeFromFINode(*(FINode **)v96);
      TNode::GetFIProvider(v63);
      v64 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v64, "identifier");
      v65 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v95 = 136446466;
      *(_QWORD *)&v95[4] = v62;
      *(_WORD *)&v95[12] = 2114;
      *(_QWORD *)&v95[14] = v65;
      _os_log_impl(&dword_1CBC4A000, v61, OS_LOG_TYPE_INFO, "FPProvider for %{public}s iCloud Drive is %{public}@", v95, 0x16u);

    }
  }
  if (TNodeFromFINode(*(FINode **)v96))
  {
    v66 = (TNode *)TNodeFromFINode(*(FINode **)v96);
    TNode::GetFIProvider(v66);
    v67 = (void *)objc_claimAutoreleasedReturnValue();
    v68 = objc_msgSend(v67, "supportsEnumeration");

    if (v68)
    {
      v69 = (TNode *)TNodeFromFINode(*(FINode **)v96);
      TNode::GetFIProvider(v69);
      v70 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v70, "domain");
      v71 = (void *)objc_claimAutoreleasedReturnValue();
      v72 = objc_msgSend(v71, "isEnabled");

      if ((v72 & 1) != 0)
      {
        TNodePtr::TNodePtr(a3, (id *)v96);
      }
      else
      {
        cf1 = 0;
        objc_msgSend(v70, "rootURL");
        v77 = (void *)objc_claimAutoreleasedReturnValue();
        if (v77)
        {
          if (objc_msgSend(v70, "isiCloudDriveProvider"))
          {
            objc_msgSend(v77, "URLByAppendingPathComponent:isDirectory:", CFSTR("com~apple~CloudDocs"), 1);
            v78 = objc_claimAutoreleasedReturnValue();

            v77 = (void *)v78;
          }
          *(_QWORD *)v95 = v77;
          TNode::GetNodeFromURL(v95, &cf1, 0);
          TNodePtr::TNodePtr(a3, (id *)&cf1);

        }
        else
        {
          LogObj(4);
          v79 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            v80 = (TNode *)TNodeFromFINode(*(FINode **)v96);
            TNode::GetFIProvider(v80);
            v81 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v95 = 138543362;
            *(_QWORD *)&v95[4] = v81;
            _os_log_impl(&dword_1CBC4A000, v79, OS_LOG_TYPE_ERROR, "FPProvider storageURLs is empty for %{public}@", v95, 0xCu);

          }
          TNodePtr::TNodePtr(a3, 0);
        }

      }
      goto LABEL_112;
    }
  }
  if (Length)
  {
    LogObj(4);
    v73 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      v74 = objc_retainAutorelease(*(id *)this);
      *(_DWORD *)v95 = 138543362;
      *(_QWORD *)&v95[4] = v74;
      v75 = v74;
      _os_log_impl(&dword_1CBC4A000, v73, OS_LOG_TYPE_INFO, "Could not find a provider for %{public}@ ", v95, 0xCu);

    }
    goto LABEL_106;
  }
  if (v3)
  {
    LogObj(4);
    v73 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v95 = 0;
      v76 = "Could not find a provider which is isDataSeparatedDomain";
LABEL_105:
      _os_log_impl(&dword_1CBC4A000, v73, OS_LOG_TYPE_INFO, v76, v95, 2u);
    }
  }
  else
  {
    LogObj(4);
    v73 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v95 = 0;
      v76 = "Could not find a provider which is isMainiCloudDriveDomain";
      goto LABEL_105;
    }
  }
LABEL_106:

  TNodePtr::TNodePtr(a3, 0);
LABEL_112:

  *(_QWORD *)v95 = &buf;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)v95);

}

void sub_1CBCDDCC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  void *v28;
  void *v29;
  uint64_t v30;

  a17 = (void **)(v30 - 144);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a17);

  _Unwind_Resume(a1);
}

void ___ZN5TNode19RootNodeForFPDomainERK7TStringb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  NSObject *v9;
  id v10;
  uint64_t v11;
  void **v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  void *v18;
  NSObject *v19;
  void *v20;
  void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint8_t v26[4];
  void *v27;
  uint8_t buf[4];
  id v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = v5;
  v8 = v6;
  if (v8)
  {
    LogObj(4);
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v29 = v8;
      _os_log_impl(&dword_1CBC4A000, v9, OS_LOG_TYPE_ERROR, "Failed to begin local provider lookup with error %{public}@", buf, 0xCu);
    }

    goto LABEL_24;
  }
  if (CFStringGetLength(*(CFStringRef *)(a1 + 56)))
  {
    v10 = objc_retainAutorelease(*(id *)(a1 + 56));
    objc_msgSend(v7, "objectForKeyedSubscript:", v10);
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = *(void ***)(a1 + 32);
    v13 = *v12;
    *v12 = (void *)v11;

    goto LABEL_24;
  }
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  objc_msgSend(v7, "allValues", 0);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, buf, 16);
  if (!v15)
    goto LABEL_18;
  v16 = *(_QWORD *)v23;
  while (2)
  {
    for (i = 0; i != v15; ++i)
    {
      if (*(_QWORD *)v23 != v16)
        objc_enumerationMutation(v14);
      v18 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * i);
      if (*(_BYTE *)(a1 + 64))
      {
        if (objc_msgSend(*(id *)(*((_QWORD *)&v22 + 1) + 8 * i), "isDataSeparatedDomain"))
        {
          objc_storeStrong(*(id **)(a1 + 32), v18);
          LogObj(4);
          v19 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            objc_msgSend(v18, "identifier");
            v20 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v26 = 138543362;
            v27 = v20;
            _os_log_impl(&dword_1CBC4A000, v19, OS_LOG_TYPE_INFO, "FPProvider for Enterprise iCloud Drive is %{public}@", v26, 0xCu);

          }
          goto LABEL_23;
        }
        if (*(_BYTE *)(a1 + 64))
          continue;
      }
      if (objc_msgSend(v18, "isMainiCloudDriveDomain"))
      {
        objc_storeStrong(*(id **)(a1 + 32), v18);
        LogObj(4);
        v19 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          objc_msgSend(v18, "identifier");
          v21 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)v26 = 138543362;
          v27 = v21;
          _os_log_impl(&dword_1CBC4A000, v19, OS_LOG_TYPE_INFO, "FPProvider for iCloud Drive is %{public}@", v26, 0xCu);

        }
LABEL_23:

        goto LABEL_24;
      }
    }
    v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, buf, 16);
    if (v15)
      continue;
    break;
  }
LABEL_18:

LABEL_24:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));

}

void sub_1CBCDE234(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c51_ZTSKZN5TNode19RootNodeForFPDomainERK7TStringbE3__1(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id v7;

  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(id *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = &stru_1E8752DF8;
  *(_QWORD *)(a1 + 48) = v7;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 56), *(TString **)(a2 + 56));
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
}

void sub_1CBCDE324(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  const void **v3;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c51_ZTSKZN5TNode19RootNodeForFPDomainERK7TStringbE3__1(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 56));

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

uint64_t TNode::RootNodeForFPDomain(TString const&,BOOL)::$_1::~$_1(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1);
}

void TNode::NodeForDomainAndItemID(TNode *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  void *v6;
  int v7;
  TNode *v8;
  void *v9;
  void *v10;
  char v11;
  FINode *v12;
  TNode *v13;
  void *v14;
  TString *v15;
  id v16;
  dispatch_semaphore_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  id v20;
  void *v21;
  void *v22;
  unint64_t v23;
  NSObject *v24;
  NSObject *v25;
  unint64_t v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  FINode *v34;
  TNodePtr v35;
  FINode *v36;
  FINode *v37;
  TString v38;
  std::__shared_weak_count *v39;
  std::__shared_weak_count *v40;
  NSObject *v41;
  _QWORD v42[5];
  std::__shared_weak_count *v43;
  NSObject *v44;
  id *v45;
  std::__shared_weak_count *v46;

  TNode::RootNodeForFPDomain(this, 0, (TNodePtr *)&v37);
  if (CFStringGetLength(a2->fString.fRef)
    && TNodeFromFINode(v37)
    && (NS_FileProviderRootContainerItemIdentifier(),
        v6 = (void *)objc_claimAutoreleasedReturnValue(),
        v7 = operator==((void **)&a2->fString.fRef, v6),
        v6,
        !v7))
  {
    v8 = (TNode *)TNodeFromFINode(v37);
    TNode::GetFIProvider(v8);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "domain");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_msgSend(v10, "isEnabled");

    if ((v11 & 1) != 0)
    {
      v12 = v37;
      v13 = (TNode *)TNodeFromFINode(v12);
      TNode::GetFIProvider(v13);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "identifier");
      v15 = (TString *)objc_claimAutoreleasedReturnValue();
      v38.fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(&v38, v15);

      FPItemManagerInstance();
      v16 = (id)objc_claimAutoreleasedReturnValue();

      if (v16)
      {
        v17 = dispatch_semaphore_create(0);
        v36 = v12;
        v18 = (std::__shared_weak_count *)operator new(0x20uLL);
        v18->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        v18->__shared_weak_owners_ = 0;
        v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750960;
        v18[1].__vftable = 0;
        v45 = (id *)&v18[1].__vftable;
        v46 = v18;
        v20 = objc_alloc(MEMORY[0x1E0CAAC70]);
        v21 = (void *)objc_msgSend(v20, "initWithProviderDomainID:itemIdentifier:", v38.fString.fRef, a2->fString.fRef);
        FPItemManagerInstance();
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        v42[0] = MEMORY[0x1E0C809B0];
        v42[1] = 3321888768;
        v42[2] = ___ZL23FPItemForProviderWithIDRK7TStringS1__block_invoke;
        v42[3] = &__block_descriptor_56_ea8_32c50_ZTSKZL23FPItemForProviderWithIDRK7TStringS1_E3__0_e28_v24__0__FPItem_8__NSError_16l;
        v39 = v18 + 1;
        v40 = v18;
        do
          v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
        v24 = v17;
        v25 = v24;
        v41 = v24;
        v42[4] = v18 + 1;
        v43 = v18;
        do
          v26 = __ldxr(p_shared_owners);
        while (__stxr(v26 + 1, p_shared_owners));
        v44 = v24;
        objc_msgSend(v22, "fetchItemForItemID:completionHandler:", v21, v42);
        do
          v27 = __ldaxr(p_shared_owners);
        while (__stlxr(v27 - 1, p_shared_owners));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }

        dispatch_semaphore_wait(v25, 0xFFFFFFFFFFFFFFFFLL);
        v16 = *v45;

        v28 = v43;
        if (v43)
        {
          v29 = (unint64_t *)&v43->__shared_owners_;
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }

        v31 = v46;
        if (v46)
        {
          v32 = (unint64_t *)&v46->__shared_owners_;
          do
            v33 = __ldaxr(v32);
          while (__stlxr(v33 - 1, v32));
          if (!v33)
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }

        v12 = v36;
      }
      v34 = v12;
      v42[0] = v34;
      v35.fFINode = (FINode *)v42;
      NodeForProviderWithFPItem(v35, (FPItem *)v16, a3);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);
    }
    else
    {
      TNodePtr::TNodePtr(a3, 0);
    }
  }
  else
  {
    TNodePtr::TNodePtr(a3, (id *)&v37);
  }

}

void sub_1CBCDE6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, const void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v26);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a13);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v27 - 96);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);

  _Unwind_Resume(a1);
}

void NodeForProviderWithFPItem(TNodePtr a1@<0:X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  FPItem *v5;
  void *v6;
  void *v7;
  _QWORD *v8;
  TNode *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  void **v14;
  char v15;
  FINode *v16;
  FPItem *v17;
  id v18;

  v18 = (id)*MEMORY[0x1E0C80C00];
  v5 = a2;
  if (v5
    && TNodeFromFINode((FINode *)a1.fFINode->super.isa)
    && (FPItemManagerInstance(), v6 = (void *)objc_claimAutoreleasedReturnValue(), v6, v6)
    && (-[FPItem fileURL](v5, "fileURL"), v7 = (void *)objc_claimAutoreleasedReturnValue(), v7, v7))
  {
    a3->fFINode = 0;
    -[FPItem fileURL](v5, "fileURL");
    v8 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    v11 = v8;
    TNode::GetNodeFromURL(&v11, a3, 0);

    if (TNodeFromFINode(a3->fFINode))
    {
      v9 = (TNode *)TNodeFromFINode(a3->fFINode);
      TNode::GetFPItem(v9);
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v10)
      {
        v16 = a3->fFINode;
        v17 = v5;
        v12 = 0;
        v13 = 0;
        v11 = 0;
        v14 = (void **)&v11;
        v15 = 0;
        v11 = operator new(0x10uLL);
        v12 = v11;
        v13 = v11 + 2;
        v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v13, (id *)&v16, &v18, v11);
        TNode::AttachFPItemsMetadata(&v11, 1, 1);
        v14 = (void **)&v11;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v14);

      }
    }
  }
  else
  {
    TNodePtr::TNodePtr(a3, 0);
  }

}

void sub_1CBCDE968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, id a14, id a15)
{
  void *v15;
  id *v16;

  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

const void **TNode::FPItemNodeFromObjectID@<X0>(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  CFIndex v5;
  __CFString *v6;
  TString *v7;
  __CFString *v8;
  TString *v9;
  CFTypeRef cf;
  TString v12;
  TString v13;

  v13.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v12.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::TString((TString *)&cf, "/");
  v5 = TString::IndexOf((TString *)this, (const TString *)&cf, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  if (v5 < 0)
  {
    if (&v13 != (TString *)this)
      TString::SetStringRefAsImmutable(&v13, *(TString **)this);
  }
  else if (v5)
  {
    TString::SubString((TString *)this, 0, v5, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v13.fString.fRef, &cf);
    CFRetain(&stru_1E8752DF8);
    if (cf)
      CFRelease(cf);
    cf = &stru_1E8752DF8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v5 < CFStringGetLength(*(CFStringRef *)this) - 1)
    {
      TString::SubStringFrom((TString *)this, v5 + 1, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v12.fString.fRef, &cf);
      CFRetain(&stru_1E8752DF8);
      if (cf)
        CFRelease(cf);
      cf = &stru_1E8752DF8;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
  }
  v6 = v13.fString.fRef;
  -[__CFString stringByRemovingPercentEncoding](v6, "stringByRemovingPercentEncoding");
  v7 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  if ((TString *)v13.fString.fRef != v7)
    TString::SetStringRefAsImmutable(&v13, v7);

  v8 = v12.fString.fRef;
  -[__CFString stringByRemovingPercentEncoding](v8, "stringByRemovingPercentEncoding");
  v9 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  if ((TString *)v12.fString.fRef != v9)
    TString::SetStringRefAsImmutable(&v12, v9);

  TNode::NodeForDomainAndItemID((TNode *)&v13, &v12, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
}

void sub_1CBCDEBC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

void TNode::ResolveBRContainer(TNode *this)
{
  FINode *v2;
  FINode *fFINode;
  void *v4;
  void *v5;
  FINode *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  void *v12;
  TNodePtr v13;
  TNodePtr v14;

  if (ICloudDriveFPFSEnabled())
  {
    TNode::CFURL(this, &v14);
    v2 = v14.fFINode;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v14.fFINode);
  }
  else
  {
    v2 = 0;
  }
  TNodePtr::TNodePtr(&v14, this);
  fFINode = v14.fFINode;
  if (v2)
  {
    v13.fFINode = v2;
    v14.fFINode = 0;
    TNode::GetNodeFromURL((CFURLRef *)&v13, &v14, 0);
    if (TNodeFromFINode(v14.fFINode))
    {
      +[FIPresentationNodeMap shared](FIPresentationNodeMap, "shared");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "presentationNodeForKeyNode:", v14.fFINode);
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_cast<FIDSNode,FINode * {__strong}>(v5);
      v6 = (FINode *)objc_claimAutoreleasedReturnValue();

      if (v6 && v6 != fFINode)
      {

        v7 = 1;
        goto LABEL_13;
      }
      if (v6)
      {
LABEL_17:

        goto LABEL_18;
      }
    }
    v7 = 0;
LABEL_13:
    TNode::SetAliasTarget(this, &v14, 0);
    if (fFINode && TNodeFromFINode(v14.fFINode))
    {
      +[FIPresentationNodeMap shared](FIPresentationNodeMap, "shared");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "registerPresentationNode:forNode:clearOlderKeyNodes:", fFINode, v14.fFINode, v7);

      v10 = TNodeFromFINode(v14.fFINode);
      v11 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v10);
      os_unfair_lock_lock(v11);
      TNodePtr::TNodePtr(&v13, *(const TNode **)(v10 + 48));
      os_unfair_lock_unlock(v11);
      +[FIPresentationNodeMap shared](FIPresentationNodeMap, "shared");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "registerPresentationNode:forNode:", fFINode, v13.fFINode);

    }
    v6 = 0;
    goto LABEL_17;
  }
  TNode::ClearAliasTarget(this, 0);
  if (fFINode)
  {
    +[FIPresentationNodeMap shared](FIPresentationNodeMap, "shared");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "unregisterAllForPresentationNode:", fFINode);

  }
LABEL_18:

}

void sub_1CBCDEE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void ___ZN5TNode11AddNewChildERK8TNodePtrRbbb_block_invoke(uint64_t a1)
{
  TNode *v2;
  TNode *v3;
  void *v4;
  NSObject *v5;
  TNode *v6;
  void *v7;
  int v8;
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 32));
  TNode::AttachCreateFPItemIfNeeded(v2, 1);
  v3 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 32));
  TNode::GetFPItem(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
    LogObj(4);
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 32));
      TNode::GetFPItem(v6);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = 138543362;
      v9 = v7;
      _os_log_impl(&dword_1CBC4A000, v5, OS_LOG_TYPE_DEFAULT, "FPItem found asynchronously %{public}@", (uint8_t *)&v8, 0xCu);

    }
  }
}

void sub_1CBCDEF80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c47_ZTSKZN5TNode11AddNewChildERK8TNodePtrRbbbE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c47_ZTSKZN5TNode11AddNewChildERK8TNodePtrRbbbE3__0(uint64_t a1)
{

}

id __copy_helper_block_ea8_32c53_ZTSKZN5TNode31SetShouldSyncUbiquityAttributesEbE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c53_ZTSKZN5TNode31SetShouldSyncUbiquityAttributesEbE3__0(uint64_t a1)
{

}

void TNode::UnRegisterForUbiquityAttributes(TNode *this)
{
  TChildrenList *v1;

  v1 = (TChildrenList *)*((_QWORD *)this + 7);
  if (v1)
    TChildrenList::ClearCollectionStatusObserver(v1);
}

uint64_t TNode::SetPrefetchPropertiesOnSync(TNode *this)
{
  std::__shared_weak_count *v2;
  TFSVolumeInfo *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _BOOL4 v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned __int16 v9;
  _BOOL4 Dir;
  unint64_t *v11;
  unint64_t v12;
  char v14;
  TFSVolumeInfo *v15;
  std::__shared_weak_count *v16;

  v3 = *(TFSVolumeInfo **)this;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  v15 = *(TFSVolumeInfo **)this;
  v16 = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  if (!v3)
  {
    v7 = 0;
    if (!v2)
      return v7;
    goto LABEL_15;
  }
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v14);
  v6 = TFSVolumeInfo::ShouldUseReadDir(v3) && TNode::ShouldUseReadDir(this);
  v8 = (unsigned __int16 *)((char *)this + 80);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 | 0x800, v8));
  Dir = TFSVolumeInfo::ShouldUseReadDir(v15);
  if (Dir)
    Dir = TNode::ShouldUseReadDir(this);
  v7 = v6 ^ Dir;
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v14);
  v2 = v16;
  if (v16)
  {
LABEL_15:
    v11 = (unint64_t *)&v2->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v7;
}

void sub_1CBCDF108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL TNode::ShouldUseReadDir(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  unint64_t v8;
  unsigned __int16 v9;
  TGlobalNodes *IsLocalVolume;
  _BOOL8 v11;
  FINode *v13;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    v7 = *(unsigned __int8 *)(v4 + 112);
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    if (v7)
      return 0;
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*(_BYTE *)(v4 + 112))
      return 0;
  }
  v9 = atomic_load((unsigned __int16 *)this + 40);
  if ((v9 & 0x800) == 0)
  {
    IsLocalVolume = (TGlobalNodes *)TNode::IsLocalVolume(this);
    if ((IsLocalVolume & 1) == 0)
    {
      TGlobalNodes::BootNode((uint64_t *)&v13, IsLocalVolume);
      v11 = TNodeFromFINode(v13) != (_QWORD)this;

      return v11;
    }
  }
  return 0;
}

void sub_1CBCDF220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::vector<TNodePtr>::push_back[abi:ne180100](uint64_t a1, id *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;

  v6 = *(_QWORD *)(a1 + 16);
  v4 = a1 + 16;
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *(_QWORD *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *(_QWORD *)a1;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[8 * v10];
    v18 = &v14[8 * v13];
    TNodePtr::TNodePtr(v16, a2);
    v17 = v16 + 8;
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, &v15);
    v9 = *(_QWORD *)(a1 + 8);
    result = std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = (uint64_t)TNodePtr::TNodePtr(*(_QWORD **)(v4 - 8), a2);
    v9 = v7 + 8;
    *(_QWORD *)(a1 + 8) = v7 + 8;
  }
  *(_QWORD *)(a1 + 8) = v9;
  return result;
}

void sub_1CBCDF320(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TNode::RemoveChildrenDeep(FINode ***a1, char a2, int a3, TNodeEventPtrs *a4)
{
  FINode **v4;
  FINode **v5;
  FINode *v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  os_unfair_lock_s *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  os_unfair_lock_s *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  os_unfair_lock_s *v27;
  int v28;
  unint64_t *v29;
  unint64_t v30;
  TNode *v31;
  TNode *v32;
  uint64_t v33;
  os_unfair_lock_s *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  os_unfair_lock_s *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  TNode *v43;
  TNode *v44;

  v5 = *a1;
  v4 = a1[1];
  if (v4 != *a1)
  {
    if ((a2 & 2) == 0)
      a3 = 1;
    do
    {
      v9 = *--v4;
      v10 = TNodeFromFINode(v9);
      v11 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v10);
      os_unfair_lock_lock(v11);
      v13 = *(_QWORD *)(v10 + 16);
      v12 = *(std::__shared_weak_count **)(v10 + 24);
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v11);
      v16 = (os_unfair_lock_s *)(v13 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
      v17 = *(unsigned __int16 *)(v13 + 119);
      v18 = *(unsigned int *)(v13 + 115);
      os_unfair_lock_unlock(v16);
      if (v12)
      {
        v19 = (unint64_t *)&v12->__shared_owners_;
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      if (((v18 | (v17 << 32)) & 0x100000000) != 0)
        continue;
      v21 = TNodeFromFINode(*v4);
      v22 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v21);
      os_unfair_lock_lock(v22);
      v24 = *(_QWORD *)(v21 + 16);
      v23 = *(std::__shared_weak_count **)(v21 + 24);
      if (v23)
      {
        v25 = (unint64_t *)&v23->__shared_owners_;
        do
          v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
      }
      os_unfair_lock_unlock(v22);
      v27 = (os_unfair_lock_s *)(v24 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v24 + 100));
      v28 = *(_DWORD *)(v24 + 115);
      os_unfair_lock_unlock(v27);
      if (v23)
      {
        v29 = (unint64_t *)&v23->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      if ((v28 & 4) != 0)
      {
        v31 = (TNode *)TNodeFromFINode(*v4);
        TDeviceManagementMonitor::UnRegisterApp(v31, v32);
      }
      v33 = TNodeFromFINode(*v4);
      v34 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v33);
      os_unfair_lock_lock(v34);
      v36 = *(_QWORD *)(v33 + 16);
      v35 = *(std::__shared_weak_count **)(v33 + 24);
      if (v35)
      {
        v37 = (unint64_t *)&v35->__shared_owners_;
        do
          v38 = __ldxr(v37);
        while (__stxr(v38 + 1, v37));
      }
      os_unfair_lock_unlock(v34);
      v39 = (os_unfair_lock_s *)(v36 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v36 + 100));
      v40 = *(_DWORD *)(v36 + 115);
      os_unfair_lock_unlock(v39);
      if (v35)
      {
        v41 = (unint64_t *)&v35->__shared_owners_;
        do
          v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }
      if ((v40 & 0x20) != 0)
      {
        v43 = (TNode *)TNodeFromFINode(*v4);
        if ((a3 & TNode::RemoveAllChildren(v43)) == 1)
        {
LABEL_36:
          if ((a2 & 1) != 0)
            TNodeFromFINode(*v4);
          v44 = (TNode *)TNodeFromFINode(*v4);
          TNode::RemoveSelf(v44, a4);
        }
      }
      else if ((a3 & 1) != 0)
      {
        goto LABEL_36;
      }
    }
    while (v4 != v5);
  }
}

unint64_t TFSInfo::UserCanWrite(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 13) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TNode::IsSticky(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  TNode *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  os_unfair_lock_s *v13;
  std::__shared_weak_count *v14;
  TFSInfo *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_8;
  v10 = (unint64_t *)&v3->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v8 & 0x20) == 0)
      return 0;
  }
  else
  {
LABEL_8:
    if ((v8 & 0x20) == 0)
      return 0;
  }
  v13 = (os_unfair_lock_s *)TNode::InfoLock(v9);
  os_unfair_lock_lock(v13);
  v15 = (TFSInfo *)*((_QWORD *)this + 2);
  v14 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v14)
  {
    v16 = (unint64_t *)&v14->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  os_unfair_lock_unlock(v13);
  v12 = (TFSInfo::GetMode(v15) >> 9) & 1;
  if (v14)
  {
    v18 = (unint64_t *)&v14->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  return v12;
}

void sub_1CBCDF710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL TNode::UserCanChangePermissions(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  TFSInfo *v6;
  _BOOL4 IsRoot;
  unint64_t *v8;
  unint64_t v9;
  _BOOL8 IsOwner;
  std::__shared_weak_count *v11;
  _BOOL8 v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v16 = *((_QWORD *)this + 2);
  v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  IsRoot = TFSInfo::UserIsRoot(v6);
  if (v3)
  {
    v8 = (unint64_t *)&v3->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  IsOwner = TNode::UserIsOwner(this);
  if (!IsRoot)
    return IsOwner;
  TNode::GetVolumeInfo(this, &v16);
  v11 = v17;
  v12 = *(_BYTE *)(v16 + 107) != 0;
  if (v17)
  {
    v13 = (unint64_t *)&v17->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v12;
}

void sub_1CBCDF828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL TNode::UserIsOwner(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  TNode *v7;
  int v8;
  unint64_t v9;
  _BOOL8 IsOwner;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  TFSInfo *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    v8 = *(unsigned __int8 *)(v4 + 112);
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    if (v8)
      return 1;
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*(_BYTE *)(v4 + 112))
      return 1;
  }
  v12 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v12);
  v14 = (TFSInfo *)*((_QWORD *)this + 2);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v12);
  IsOwner = TFSInfo::UserIsOwner(v14);
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  return IsOwner;
}

void sub_1CBCDF964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::UserCanListContent(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  TNode *v7;
  int v8;
  unint64_t v9;
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  os_unfair_lock_s *v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v20;
  unint64_t v21;
  os_unfair_lock_s *v22;
  int v23;
  TNode *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  os_unfair_lock_s *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    os_unfair_lock_unlock(v2);
    v8 = *(unsigned __int8 *)(v4 + 112);
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
    v8 = *(unsigned __int8 *)(v4 + 112);
  }
  v10 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v10);
  v12 = *((_QWORD *)this + 2);
  v11 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (!v8)
  {
    if (v11)
    {
      v20 = (unint64_t *)&v11->__shared_owners_;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    os_unfair_lock_unlock(v10);
    v22 = (os_unfair_lock_s *)(v12 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
    v23 = *(_DWORD *)(v12 + 115);
    os_unfair_lock_unlock(v22);
    if (!v11)
      goto LABEL_26;
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if ((v23 & 0x20) == 0)
        return 0;
    }
    else
    {
LABEL_26:
      if ((v23 & 0x20) == 0)
        return 0;
    }
    v28 = (os_unfair_lock_s *)TNode::InfoLock(v24);
    os_unfair_lock_lock(v28);
    v30 = *((_QWORD *)this + 2);
    v29 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    if (v29)
    {
      v31 = (unint64_t *)&v29->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    os_unfair_lock_unlock(v28);
    os_unfair_lock_lock((os_unfair_lock_t)(v30 + 100));
    v27 = ((unint64_t)*(unsigned int *)(v30 + 115) >> 14) & 1;
    os_unfair_lock_unlock((os_unfair_lock_t)(v30 + 100));
    if (v29)
    {
      v33 = (unint64_t *)&v29->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    return v27;
  }
  if (v11)
  {
    v13 = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  os_unfair_lock_unlock(v10);
  v15 = (os_unfair_lock_s *)(v12 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
  v16 = *(_DWORD *)(v12 + 115);
  os_unfair_lock_unlock(v15);
  if (!v11)
    goto LABEL_17;
  v17 = (unint64_t *)&v11->__shared_owners_;
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if ((v16 & 0x20) == 0)
      return TNode::AliasIsContainer(this);
  }
  else
  {
LABEL_17:
    if ((v16 & 0x20) == 0)
      return TNode::AliasIsContainer(this);
  }
  return 1;
}

uint64_t TNode::FetchExtendedUserAccess(TNode *this)
{
  os_unfair_lock_s *v2;
  TFSInfo *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  dispatch_semaphore_t v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  dispatch_time_t v20;
  intptr_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD block[4];
  NSObject *v34;
  TFSInfo *v35;
  std::__shared_weak_count *v36;
  FINode *v37;
  TFSVolumeInfo *v38;
  std::__shared_weak_count *v39;
  id *v40;
  std::__shared_weak_count *v41;
  TNodePtr v42;
  TFSInfo *v43;
  std::__shared_weak_count *v44;
  TFSInfo *v45;
  std::__shared_weak_count *v46;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v3 = (TFSInfo *)*((_QWORD *)this + 2);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  v45 = v3;
  v46 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  if ((TFSInfo::HasExtendedUserAccess(v3) & 1) != 0)
    goto LABEL_35;
  if (!pthread_main_np())
  {
    TFSInfo::SetExtendedUserAccess(v3);
LABEL_35:
    v28 = 1;
    goto LABEL_36;
  }
  v7 = dispatch_semaphore_create(0);
  v43 = v3;
  v44 = v4;
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  TNodePtr::TNodePtr(&v42, this);
  TNode::GetVolumeInfo(this, &v38);
  TFSVolumeInfo::GetPropertyUpdateThread(v38, &v40);
  NodeEventRefFromNodeEvent(v40);
  v10 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZNK5TNode23FetchExtendedUserAccessEv_block_invoke;
  block[3] = &unk_1E87510B8;
  v35 = v3;
  v36 = v4;
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v7;
  v34 = v13;
  v37 = v42.fFINode;
  dispatch_async(v10, block);

  v14 = v41;
  if (v41)
  {
    v15 = (unint64_t *)&v41->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v39;
  if (v39)
  {
    v18 = (unint64_t *)&v39->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = dispatch_time(0, 1000000);
  v21 = dispatch_semaphore_wait(v13, v20);

  v22 = v36;
  if (v36)
  {
    v23 = (unint64_t *)&v36->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  v25 = v44;
  if (v44)
  {
    v26 = (unint64_t *)&v44->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  if (!v21)
    goto LABEL_35;
  v28 = 0;
LABEL_36:
  v29 = v46;
  if (v46)
  {
    v30 = (unint64_t *)&v46->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  return v28;
}

void sub_1CBCDFE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v11 - 64);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v11 - 48);
  _Unwind_Resume(a1);
}

void ___ZNK5TNode23FetchExtendedUserAccessEv_block_invoke(uint64_t a1)
{
  int v2;
  const TNode *v3;

  v2 = TFSInfo::SetExtendedUserAccess(*(TFSInfo **)(a1 + 40));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  if (v2)
  {
    v3 = (const TNode *)TNodeFromFINode(*(FINode **)(a1 + 56));
    TNode::SendNotification(v3, 2, (id *)(a1 + 56), 1970495843, 0);
  }
}

id __copy_helper_block_ea8_40c34_ZTSNSt3__110shared_ptrI7TFSInfoEE56c13_ZTS8TNodePtr(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  id result;

  v3 = *(_QWORD *)(a2 + 48);
  a1[5] = *(_QWORD *)(a2 + 40);
  a1[6] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  result = *(id *)(a2 + 56);
  a1[7] = result;
  return result;
}

uint64_t __destroy_helper_block_ea8_40c34_ZTSNSt3__110shared_ptrI7TFSInfoEE56c13_ZTS8TNodePtr(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
}

unint64_t TNode::UserCanDelete(TNode *this)
{
  TNode *ExtendedUserAccess;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  ExtendedUserAccess = (TNode *)TNode::FetchExtendedUserAccess(this);
  if (!(_DWORD)ExtendedUserAccess)
    return 1;
  v3 = (os_unfair_lock_s *)TNode::InfoLock(ExtendedUserAccess);
  os_unfair_lock_lock(v3);
  v5 = *((_QWORD *)this + 2);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v3);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
  v8 = ((unint64_t)*(unsigned int *)(v5 + 115) >> 22) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 100));
  if (v4)
  {
    v9 = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v8;
}

unint64_t TNode::UserCanDeleteChild(TNode *this)
{
  TNode *ExtendedUserAccess;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  ExtendedUserAccess = (TNode *)TNode::FetchExtendedUserAccess(this);
  if (!(_DWORD)ExtendedUserAccess)
    return 1;
  v3 = (os_unfair_lock_s *)TNode::InfoLock(ExtendedUserAccess);
  os_unfair_lock_lock(v3);
  v5 = *((_QWORD *)this + 2);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v3);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
  v8 = ((unint64_t)*(unsigned int *)(v5 + 115) >> 23) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 100));
  if (v4)
  {
    v9 = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v8;
}

unint64_t TFSInfo::UserCanAddDeleteChild(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 23) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TFSInfo::IsResumableCopyTarget(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = (*(unsigned __int16 *)((char *)this + 119) >> 12) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

unint64_t TFSInfo::UserCanAddFile(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 20) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

unint64_t TFSInfo::UserCanAddFolder(TFSInfo *this)
{
  os_unfair_lock_s *v2;
  unint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 21) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

void TNode::UnRegisterForInternalNotifications(TNodeEvent *a1, FINode **a2, uint64_t a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  TNodeEvent::GetInternalClientNotifier(a1, &v9);
  TNode::UnregisterChangeNotification((uint64_t)a1, (uint64_t)&v9, a2, a3);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1CBCE0288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::KQueue(TNode *this)
{
  uint64_t v1;

  KQueueLock();
  os_unfair_lock_lock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  v1 = TNode::gKQueue;
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  return v1;
}

void KQueueLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      KQueueLock(void)::gkQueueLock = 0;
    }
  }
}

void TNode::AddkQueueNotification(TNode *this)
{
  KQueueLock();
  os_unfair_lock_lock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  if (!TNode::gKQueueRegistrationCount++)
    TNode::gKQueue = kqueue();
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
}

void sub_1CBCE0374(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  _Unwind_Resume(a1);
}

void TNode::RemovekQueueNotification(TNode *this)
{
  KQueueLock();
  os_unfair_lock_lock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  if (!--TNode::gKQueueRegistrationCount)
  {
    close(TNode::gKQueue);
    TNode::gKQueue = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
}

void sub_1CBCE03E0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  _Unwind_Resume(a1);
}

unint64_t TNode::AdjustedSyncQuanta(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  double v11;
  double v12;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (!v3)
    goto LABEL_8;
  v9 = (unint64_t *)&v3->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v8 & 0x20) == 0)
      goto LABEL_9;
  }
  else
  {
LABEL_8:
    if ((v8 & 0x20) == 0)
    {
LABEL_9:
      v11 = 200000.0;
      goto LABEL_12;
    }
  }
  v11 = (double)(unint64_t)(10 * TChildrenList::GetLastSyncDuration(*((TChildrenList **)this + 7)));
LABEL_12:
  v12 = fmax(v11, 500000.0);
  if ((unint64_t)v12 >= 0x4C4B40)
    return 5000000;
  else
    return (unint64_t)v12;
}

uint64_t TNode::AdjustedResizeQuanta(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  TNode *v9;
  unint64_t *v10;
  unint64_t v11;
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  os_unfair_lock_s *v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t LastResizeDuration;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = *((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  v7 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  v8 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v7);
  if (v3)
  {
    v10 = (unint64_t *)&v3->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
      if ((v8 & 0x100) == 0)
        goto LABEL_9;
      return 2000000;
    }
  }
  if ((v8 & 0x100) != 0)
    return 2000000;
LABEL_9:
  v12 = (os_unfair_lock_s *)TNode::InfoLock(v9);
  os_unfair_lock_lock(v12);
  v14 = *((_QWORD *)this + 2);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v12);
  v17 = (os_unfair_lock_s *)(v14 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
  v18 = *(_DWORD *)(v14 + 115);
  os_unfair_lock_unlock(v17);
  if (!v13)
    goto LABEL_16;
  v19 = (unint64_t *)&v13->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if ((v18 & 0x20) == 0)
      return 5000000;
  }
  else
  {
LABEL_16:
    if ((v18 & 0x20) == 0)
      return 5000000;
  }
  LastResizeDuration = TChildrenList::GetLastResizeDuration(*((TChildrenList **)this + 7));
  if ((unint64_t)(5 * LastResizeDuration) >= 0x4C4B40)
    return 5000000;
  else
    return 5 * LastResizeDuration;
}

void TNode::SetTimerToDispatchResizeRequest(id **a1, uint64_t a2)
{
  FINode *v4;
  TNode *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  TFSVolumeInfo *v14;
  std::__shared_weak_count *v15;

  if (*a1)
  {
    v4 = (FINode *)**a1;
    if (TNodeFromFINode(v4))
    {
      v5 = (TNode *)TNodeFromFINode(v4);
      TNode::GetVolumeInfo(v5, &v14);
      if (v14)
      {
        TFSVolumeInfo::GetFolderSizingThread(v14, &v12);
        if (v12)
          TFolderSizingThread::SetTimerToDispatchResizeRequest(&v12, (uint64_t *)a1, a2);
        v6 = v13;
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v8 = __ldaxr(p_shared_owners);
          while (__stlxr(v8 - 1, p_shared_owners));
          if (!v8)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
      }
      v9 = v15;
      if (v15)
      {
        v10 = (unint64_t *)&v15->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }

  }
}

void sub_1CBCE0750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v11;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);

  _Unwind_Resume(a1);
}

void TNode::DispatchResizeRequestNow(id **a1)
{
  uint64_t v2;
  FINode *v3;

  if (TNode::IsContextOpen((TNode *)a1))
  {
    v3 = (FINode *)**a1;
    v2 = TNodeFromFINode(v3);
    TNode::PostFolderSizingTaskRequest(v2, a1, 1);

  }
}

void sub_1CBCE07E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void TNode::SetTimerToDispatchSyncRequest(TNode *a1, uint64_t a2, int a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  TFSVolumeInfo *v14;
  std::__shared_weak_count *v15;

  TNode::GetVolumeInfo(a1, &v14);
  if (v14)
  {
    TFSVolumeInfo::GetVolumeSyncThread(v14, &v12);
    if (v12)
      TNode::SetTimerToDispatchSyncRequest((uint64_t)a1, (uint64_t)&v12, a2, a3);
    v6 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  v9 = v15;
  if (v15)
  {
    v10 = (unint64_t *)&v15->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_1CBCE08D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void TNode::SetTimerToDispatchSyncRequest(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  TNode *v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  os_unfair_lock_s *v14;
  int v15;
  unint64_t *v16;
  unint64_t v17;
  char v18;
  unsigned __int16 *v19;
  unsigned __int16 v20;
  NSObject *v21;
  dispatch_source_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  NSObject *v26;
  unint64_t *v27;
  unint64_t v28;
  TTime *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  dispatch_time_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  TVolumeSyncThread *v37;
  std::__shared_weak_count *v38;
  TNodePtr v39;
  uint64_t v40;
  _QWORD handler[5];
  std::__shared_weak_count *v42;
  NSObject *v43;
  FINode *v44;
  uint64_t v45;

  v8 = (TNode *)TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)a2);
  if ((v8 & 1) != 0)
    return;
  if ((a4 & 0x80000) != 0)
    goto LABEL_11;
  v9 = (os_unfair_lock_s *)TNode::InfoLock(v8);
  os_unfair_lock_lock(v9);
  v11 = *(_QWORD *)(a1 + 16);
  v10 = *(std::__shared_weak_count **)(a1 + 24);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v9);
  v14 = (os_unfair_lock_s *)(v11 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
  v15 = *(_DWORD *)(v11 + 115);
  os_unfair_lock_unlock(v14);
  if (v10)
  {
    v16 = (unint64_t *)&v10->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if ((v15 & 0x20) == 0)
        goto LABEL_11;
LABEL_13:
      if ((a4 & 0x400000) == 0)
      {
        v19 = (unsigned __int16 *)(a1 + 80);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 | 4, v19));
        if ((v20 & 4) != 0)
          return;
      }
      v18 = 1;
      goto LABEL_18;
    }
  }
  if ((v15 & 0x20) != 0)
    goto LABEL_13;
LABEL_11:
  v18 = 0;
LABEL_18:
  NodeEventRefFromNodeEvent(*(id **)a2);
  v21 = objc_claimAutoreleasedReturnValue();
  v22 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 1uLL, v21);

  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptions_block_invoke;
  handler[3] = &__block_descriptor_72_ea8_32c114_ZTSKZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsE3__0_e5_v8__0l;
  v23 = *(std::__shared_weak_count **)(a2 + 8);
  v37 = *(TVolumeSyncThread **)a2;
  v38 = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  v26 = v22;
  TNodePtr::TNodePtr(&v39, (const TNode *)a1);
  LOBYTE(v40) = v18;
  HIDWORD(v40) = a4;
  handler[4] = v37;
  v42 = v38;
  if (v38)
  {
    v27 = (unint64_t *)&v38->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v43 = v26;
  v44 = v39.fFINode;
  v45 = v40;
  dispatch_source_set_event_handler(v26, handler);

  if (v38)
  {
    v30 = (unint64_t *)&v38->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v32 = TTime::MicrosecondsSinceStartup(v29);
  v33 = dispatch_time(0, 1000 * (a3 - v32));
  dispatch_source_set_timer(v26, v33, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v26);

  v34 = v42;
  if (v42)
  {
    v35 = (unint64_t *)&v42->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

}

void sub_1CBCE0BB8(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  CopyURLForFPItem(FPItem *,BOOL)::$_0::~$_0(v2);

  _Unwind_Resume(a1);
}

id TNode::FPItemsCollectionFromURL(TNode *this)
{
  void *v2;
  NSObject *v3;
  void *v4;
  __CFString *v5;
  NSURL *v6;
  void *v7;
  void *v8;
  __CFString *v9;
  NSObject *v10;
  __CFString *v11;
  TString *v12;
  uint64_t v13;
  id v14;
  __CFString *v15;
  NSObject *v16;
  __CFString *v17;
  NSObject *v18;
  __CFString *v19;
  __CFString *v20;
  id v21;
  NSObject *v23;
  __CFString *v24;
  TNodePtr v25;
  id v26;
  id v27;
  id v28;
  id v29;
  __CFString *v30;
  TString v31[3];
  TString *v32;
  _BYTE buf[24];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  TNode::GetFIProvider(this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v2)
  {
    LogObj(4);
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)v31);
      SanitizedPath(v31);
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v4;
      _os_log_impl(&dword_1CBC4A000, v3, OS_LOG_TYPE_INFO, "No provider found for collection, looking up by url %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v31[0].fString.fRef);

    }
    TNode::CFURL(this, v31);
    +[FIProviderDomain providerDomainForURL:cachePolicy:error:](FIProviderDomain, "providerDomainForURL:cachePolicy:error:", v31[0].fString.fRef, 3, 0);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v31[0].fString.fRef);
  }
  TNode::CFURL(this, v31);
  v5 = v31[0].fString.fRef;
  -[__CFString URLByStandardizingPath](v5, "URLByStandardizingPath");
  v6 = (NSURL *)objc_claimAutoreleasedReturnValue();

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v31[0].fString.fRef);
  FPItemManagerInstance();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = 0;
  v8 = (void *)objc_msgSend(v7, "newCollectionWithItemAtURL:error:", v6, &v28);
  v9 = (__CFString *)v28;

  if (!v8 && v2)
  {
    LogObj(4);
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      SanitizedURL(v6);
      v11 = (__CFString *)objc_claimAutoreleasedReturnValue();
      LODWORD(v31[0].fString.fRef) = 138543362;
      *(__CFString **)((char *)&v31[0].fString.fRef + 4) = v11;
      _os_log_impl(&dword_1CBC4A000, v10, OS_LOG_TYPE_DEFAULT, "Collection not found by url, Attempting fetch of FPItem for %{public}@", (uint8_t *)v31, 0xCu);

    }
    v32 = 0;
    TNode::FPItemFromURLWithTimeout(v6, (uint64_t)v31, &v26);
    v12 = v32;
    if (v32 == v31)
    {
      v13 = 4;
      v12 = v31;
    }
    else
    {
      if (!v32)
      {
LABEL_14:
        v14 = v26;
        if (v26)
        {
          v15 = (__CFString *)v26;
          LogObj(4);
          v16 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v31[0].fString.fRef) = 138543362;
            *(__CFString **)((char *)&v31[0].fString.fRef + 4) = v15;
            _os_log_impl(&dword_1CBC4A000, v16, OS_LOG_TYPE_DEFAULT, "Found FPItem %{public}@", (uint8_t *)v31, 0xCu);
          }

          TNodePtr::TNodePtr(&v25, this);
          TNodePtr::TNodePtr(&v29, (id *)&v25.fFINode);
          v17 = v15;
          v30 = v17;
          memset(v31, 0, sizeof(v31));
          *(_QWORD *)buf = v31;
          buf[8] = 0;
          v31[0].fString.fRef = (__CFString *)operator new(0x10uLL);
          v31[1] = v31[0];
          v31[2].fString.fRef = (__CFString *)&v31[0].fString.fRef->data;
          v31[1].fString.fRef = (__CFString *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v31[2], &v29, (id *)&v31[0].fString.fRef, &v31[0].fString.fRef->isa);
          TNode::AttachFPItemsMetadata(v31, 1, 1);
          *(_QWORD *)buf = v31;
          std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);

          TNode::FPItemsCollection(this, (FPItem *)v17);
          v8 = (void *)objc_claimAutoreleasedReturnValue();
          if (v8)
          {
            LogObj(4);
            v18 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v31[0].fString.fRef) = 138543362;
              *(__CFString **)((char *)&v31[0].fString.fRef + 4) = v17;
              _os_log_impl(&dword_1CBC4A000, v18, OS_LOG_TYPE_DEFAULT, "Found collection after lookup of FPItem %{public}@", (uint8_t *)v31, 0xCu);
            }

          }
        }
        else
        {
          LogObj(4);
          v17 = (__CFString *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
          {
            SanitizedURL(v6);
            v19 = (__CFString *)objc_claimAutoreleasedReturnValue();
            v20 = (__CFString *)v27;
            LODWORD(v31[0].fString.fRef) = 138543618;
            *(__CFString **)((char *)&v31[0].fString.fRef + 4) = v19;
            WORD2(v31[1].fString.fRef) = 2114;
            *(__CFString **)((char *)&v31[1].fString.fRef + 6) = v20;
            _os_log_impl(&dword_1CBC4A000, (os_log_t)v17, OS_LOG_TYPE_ERROR, "Unable to find FPItem for URL '%{public}@' state of folder may be stale. %{public}@", (uint8_t *)v31, 0x16u);

          }
          v8 = 0;
        }

        goto LABEL_25;
      }
      v13 = 5;
    }
    (*((void (**)(void))&v12->fString.fRef->isa + v13))();
    goto LABEL_14;
  }
LABEL_25:
  if (v8)
  {
    objc_msgSend(v8, "setShowHiddenFiles:", 1);
    v21 = v8;
  }
  else if (v9 && -[__CFString code](v9, "code") != 22)
  {
    LogObj(4);
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      SanitizedURL(v6);
      v24 = (__CFString *)objc_claimAutoreleasedReturnValue();
      LODWORD(v31[0].fString.fRef) = 138543618;
      *(__CFString **)((char *)&v31[0].fString.fRef + 4) = v24;
      WORD2(v31[1].fString.fRef) = 2114;
      *(__CFString **)((char *)&v31[1].fString.fRef + 6) = v9;
      _os_log_impl(&dword_1CBC4A000, v23, OS_LOG_TYPE_ERROR, "Unable to load collection for url %{public}@ with error: %{public}@", (uint8_t *)v31, 0x16u);

    }
  }

  return v8;
}

void sub_1CBCE10F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id *std::pair<TNodePtr,FPItem * {__strong}>::~pair(id *a1)
{

  return a1;
}

uint64_t TNode::GetNodeFromBookmarkData(uint64_t *a1, void **a2, char a3)
{
  uint64_t v6;
  const void *v7;
  __CFError *v8;
  CFIndex NodeFromURL;
  const void *v11;
  const void *v12;
  TNodePtr v13;

  TNodePtr::TNodePtr(&v13, 0);
  TNodePtr::operator=(a2, (void **)&v13.fFINode);

  v6 = *a1;
  if (*a1)
  {
    v13.fFINode = 0;
    v7 = (const void *)MEMORY[0x1D17A4D94](*MEMORY[0x1E0C9AE00], v6, ((a3 & 3) << 8) ^ 0x100u, 0, 0, 0, &v13);
    v12 = v7;
    if (v13.fFINode)
    {
      NodeFromURL = TCFURLInfo::TranslateCFError((TCFURLInfo *)v13.fFINode, v8);
      if ((_DWORD)NodeFromURL)
      {
LABEL_9:
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v12);
        TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v13.fFINode);
        return NodeFromURL;
      }
      v7 = v12;
    }
    else if (!v7)
    {
      NodeFromURL = 4294959232;
      goto LABEL_9;
    }
    v11 = v7;
    NodeFromURL = TNode::GetNodeFromURL(&v11, a2, 0);
    goto LABEL_9;
  }
  return 4294959236;
}

void sub_1CBCE1368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  const void *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

id objc_cast<FILocalStorageNode,FINode * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

BOOL TNode::EqualDisplayName(TNode *this, const TString *a2)
{
  _BOOL8 v3;
  CFTypeRef cf1;

  TNode::DisplayName(this, (TString *)&cf1);
  v3 = CFEqual(cf1, a2->fString.fRef) != 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v3;
}

void sub_1CBCE1420(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::MarkAsUsed(TNode *this)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  TFSInfo *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  v4 = (TFSInfo *)*((_QWORD *)this + 2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::MarkAsUsed(v4);
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1CBCE14E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TNode::AddVolumeToSuperRoot(TNode *this, TNodePtr *a2)
{
  TNode *v3;
  const TNode *v4;
  void *v5;
  FINode *v6[3];
  BOOL v7;
  TNodePtr v8;

  TGlobalNodes::RootNode((uint64_t *)&v8, (TGlobalNodes *)this);
  v7 = 0;
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v6, &v8, 0);
  v3 = (TNode *)TNodeFromFINode(v8.fFINode);
  TNode::AddNewChild((uint64_t *)&v5, v3, (const TNodePtr *)this, &v7, 0, 1);
  TNodePtr::operator=((void **)this, &v5);

  TNode::StPopulating::~StPopulating(v6);
  if (v7)
  {
    v4 = (const TNode *)TNodeFromFINode(v8.fFINode);
    TNode::SendNotification(v4, 3, (id *)this, 0, 0);
  }

}

void sub_1CBCE159C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

uint64_t TNode::AddVolume(uint64_t a1, uint64_t a2, void **a3)
{
  TGlobalNodes *v6;
  uint64_t v7;
  uint64_t v8;
  Class v9;
  Class isa;
  unint64_t *v11;
  unint64_t v12;
  FINode *v13;
  int NodeFromURL;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v22;
  os_unfair_lock_s *v23;
  TNode *v24;
  uint64_t v25;
  os_unfair_lock_s *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  os_unfair_lock_s *v31;
  int v32;
  unint64_t *v33;
  unint64_t v34;
  unsigned int v35;
  uint64_t v36;
  os_unfair_lock_s *v37;
  TNode *v38;
  uint64_t v39;
  FINode *fFINode;
  os_unfair_lock_s *v41;
  FINode *v42;
  int v43;
  uint64_t v44;
  os_unfair_lock_s *v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  os_unfair_lock_s *v50;
  int v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v55;
  os_unfair_lock_s *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  os_unfair_lock_s *v61;
  int v62;
  unint64_t *v63;
  unint64_t v64;
  TNode *v65;
  FINode *v66;
  TNodePtr v67;
  TNodePtr v68;
  TNodePtr v69;
  std::__shared_weak_count *v70;
  TNodePtr v71;
  std::__shared_weak_count *v72;
  id v73;

  TNodePtr::TNodePtr(&v71, 0);
  TNodePtr::operator=(a3, (void **)&v71.fFINode);

  TGlobalNodes::RootNode((uint64_t *)&v73, v6);
  v71.fFINode = 0;
  v72 = 0;
  v7 = TFSVolumeInfo::AddVolume(a1, a2, &v71);
  v8 = v7;
  if ((_DWORD)v7 && (_DWORD)v7 != -8057)
  {
    TNodePtr::TNodePtr(&v69, 0);
    TNodePtr::operator=(a3, (void **)&v69.fFINode);

    goto LABEL_19;
  }
  isa = v71.fFINode[7].super.isa;
  v9 = v71.fFINode[8].super.isa;
  v69.fFINode = (FINode *)isa;
  v70 = (std::__shared_weak_count *)v9;
  if (v9)
  {
    v11 = (unint64_t *)((char *)v9 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  if (isa)
  {
    os_unfair_lock_lock((os_unfair_lock_t)isa + 25);
    v13 = (FINode *)*((_QWORD *)isa + 2);
    v67.fFINode = v13;
    if (v13)
      CFRetain(v13);
    os_unfair_lock_unlock((os_unfair_lock_t)isa + 25);
    v68.fFINode = v67.fFINode;
    NodeFromURL = TNode::GetNodeFromURL(&v68, a3, 0);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v67.fFINode);
    if (NodeFromURL)
    {
      TNodePtr::TNodePtr(&v68, 0);
      TNodePtr::operator=(a3, (void **)&v68.fFINode);
LABEL_11:

LABEL_12:
      TNodePtr::TNodePtr(&v68, 0);
      TNodePtr::operator=(a3, (void **)&v68.fFINode);

      v8 = 4294967253;
      goto LABEL_13;
    }
    v22 = TNodeFromFINode((FINode *)*a3);
    v23 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v22);
    os_unfair_lock_lock(v23);
    TNodePtr::TNodePtr(&v68, *(const TNode **)(v22 + 48));
    os_unfair_lock_unlock(v23);
    if (TNodeFromFINode(v68.fFINode))
    {
      v24 = (TNode *)TNodeFromFINode(v68.fFINode);
      TNode::SetPrefetchPropertiesOnSync(v24);
    }
    v25 = TNodeFromFINode((FINode *)*a3);
    v26 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v25);
    os_unfair_lock_lock(v26);
    v28 = *(_QWORD *)(v25 + 16);
    v27 = *(std::__shared_weak_count **)(v25 + 24);
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        v30 = __ldxr(p_shared_owners);
      while (__stxr(v30 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v26);
    v31 = (os_unfair_lock_s *)(v28 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v28 + 100));
    v32 = *(_DWORD *)(v28 + 115);
    os_unfair_lock_unlock(v31);
    if (!v27)
      goto LABEL_34;
    v33 = (unint64_t *)&v27->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
      if ((v32 & 0x100) == 0)
      {
LABEL_35:
        v35 = 10;
        while (1)
        {
          v36 = TNodeFromFINode((FINode *)*a3);
          v37 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v36);
          os_unfair_lock_lock(v37);
          TNodePtr::TNodePtr(&v67, *(const TNode **)(v36 + 48));
          os_unfair_lock_unlock(v37);
          TNodePtr::operator=((void **)&v68.fFINode, (void **)&v67.fFINode);

          if (TNodeFromFINode(v68.fFINode))
          {
            v38 = (TNode *)TNodeFromFINode(v68.fFINode);
            TNode::SetPrefetchPropertiesOnSync(v38);
            v39 = TNodeFromFINode(v68.fFINode);
            TNode::HandleSync(v39, 0x11000000u);
          }
          usleep(0x186A0u);
          fFINode = v69.fFINode;
          v41 = (os_unfair_lock_s *)&v69.fFINode[12].super.isa + 1;
          os_unfair_lock_lock((os_unfair_lock_t)&v69.fFINode[12].super.isa + 1);
          v42 = (FINode *)fFINode[2].super.isa;
          v66 = v42;
          if (v42)
            CFRetain(v42);
          os_unfair_lock_unlock(v41);
          v67.fFINode = v66;
          v43 = TNode::GetNodeFromURL(&v67, a3, 0);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v66);
          if (v43)
            goto LABEL_11;
          v44 = TNodeFromFINode((FINode *)*a3);
          v45 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v44);
          os_unfair_lock_lock(v45);
          v47 = *(_QWORD *)(v44 + 16);
          v46 = *(std::__shared_weak_count **)(v44 + 24);
          if (v46)
          {
            v48 = (unint64_t *)&v46->__shared_owners_;
            do
              v49 = __ldxr(v48);
            while (__stxr(v49 + 1, v48));
          }
          os_unfair_lock_unlock(v45);
          v50 = (os_unfair_lock_s *)(v47 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v47 + 100));
          v51 = *(_DWORD *)(v47 + 115);
          os_unfair_lock_unlock(v50);
          if (v46)
          {
            v52 = (unint64_t *)&v46->__shared_owners_;
            do
              v53 = __ldaxr(v52);
            while (__stlxr(v53 - 1, v52));
            if (!v53)
            {
              ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
              std::__shared_weak_count::__release_weak(v46);
            }
          }
          if ((v51 & 0x100) == 0 && v35-- > 1)
            continue;
          break;
        }
      }
    }
    else
    {
LABEL_34:
      if ((v32 & 0x100) == 0)
        goto LABEL_35;
    }

    if (TNodeFromFINode((FINode *)*a3))
    {
      v55 = TNodeFromFINode((FINode *)*a3);
      v56 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v55);
      os_unfair_lock_lock(v56);
      v58 = *(_QWORD *)(v55 + 16);
      v57 = *(std::__shared_weak_count **)(v55 + 24);
      if (v57)
      {
        v59 = (unint64_t *)&v57->__shared_owners_;
        do
          v60 = __ldxr(v59);
        while (__stxr(v60 + 1, v59));
      }
      os_unfair_lock_unlock(v56);
      v61 = (os_unfair_lock_s *)(v58 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v58 + 100));
      v62 = *(_DWORD *)(v58 + 115);
      os_unfair_lock_unlock(v61);
      if (v57)
      {
        v63 = (unint64_t *)&v57->__shared_owners_;
        do
          v64 = __ldaxr(v63);
        while (__stlxr(v64 - 1, v63));
        if (!v64)
        {
          ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
          std::__shared_weak_count::__release_weak(v57);
        }
      }
      if ((v62 & 0x100) != 0)
      {
        v65 = (TNode *)TNodeFromFINode((FINode *)*a3);
        TNode::SetVolumeInfo(v65, (uint64_t *)&v71);
        v8 = 0;
        goto LABEL_13;
      }
    }
    goto LABEL_12;
  }
LABEL_13:
  v15 = v70;
  if (v70)
  {
    v16 = (unint64_t *)&v70->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
LABEL_19:
  v18 = v72;
  if (v72)
  {
    v19 = (unint64_t *)&v72->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  return v8;
}

void sub_1CBCE1AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, void *a16)
{
  os_unfair_lock_s *v16;

  os_unfair_lock_unlock(v16);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a14);

  _Unwind_Resume(a1);
}

uint64_t TNode::RemoveVolume(const void **a1)
{
  const void *v1;
  uint64_t v2;
  os_unfair_lock_s *v3;
  uint64_t v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  TNodePtr v10;
  const void *v11;
  FINode *v12;

  v1 = *a1;
  v11 = v1;
  if (v1)
    CFRetain(v1);
  TNode::GetVolumeNode(&v12, &v11, 0);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v11);
  if (TNodeFromFINode(v12)
    && (v2 = TNodeFromFINode(v12),
        v3 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v2),
        os_unfair_lock_lock(v3),
        TNodePtr::TNodePtr(&v10, *(const TNode **)(v2 + 48)),
        os_unfair_lock_unlock(v3),
        v4 = TNodeFromFINode(v10.fFINode),
        v10.fFINode,
        v4))
  {
    v5 = TNodeFromFINode(v12);
    v6 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v5);
    os_unfair_lock_lock(v6);
    TNodePtr::TNodePtr(&v10, *(const TNode **)(v5 + 48));
    os_unfair_lock_unlock(v6);
    v7 = TNodeFromFINode(v10.fFINode);
    TNode::HandleSync(v7, 0x1000000u);

    v8 = 0;
  }
  else
  {
    v8 = 4294959240;
  }

  return v8;
}

void sub_1CBCE1C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12)
{
  os_unfair_lock_s *v12;
  os_unfair_lock_s *v13;

  v13 = v12;
  os_unfair_lock_unlock(v13);

  _Unwind_Resume(a1);
}

void TNode::HandleFolderSizingRequests(id **a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  os_unfair_lock_s *v8;
  int v9;
  TTime *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  os_unfair_lock_s *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  TNode *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  TNode *v23;
  int v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  FINode *v28;
  std::__shared_weak_count *v29;

  v28 = (FINode *)**a1;
  if (TNode::IsContextOpen((TNode *)v28))
  {
    v2 = TNodeFromFINode(v28);
    v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
    os_unfair_lock_lock(v3);
    v5 = *(_QWORD *)(v2 + 16);
    v4 = *(std::__shared_weak_count **)(v2 + 24);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v3);
    v8 = (os_unfair_lock_s *)(v5 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
    v9 = *(_DWORD *)(v5 + 115);
    os_unfair_lock_unlock(v8);
    if (!v4)
      goto LABEL_9;
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      if ((v9 & 0x20) == 0)
        goto LABEL_27;
    }
    else
    {
LABEL_9:
      if ((v9 & 0x20) == 0)
        goto LABEL_27;
    }
    v13 = TTime::MicrosecondsSinceStartup(v10);
    v14 = TNodeFromFINode(v28);
    v15 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v14);
    os_unfair_lock_lock(v15);
    v16 = *(std::__shared_weak_count **)(v14 + 24);
    v29 = v16;
    if (v16)
    {
      v17 = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    os_unfair_lock_unlock(v15);
    v19 = (TNode *)TNodeFromFINode(v28);
    v20 = TNode::AdjustedResizeQuanta(v19);
    v21 = TNodeFromFINode(v28);
    v22 = TChildrenList::LastResizeTime(*(TChildrenList **)(v21 + 56)) + v20;
    if (v13 >= v22
      && (v23 = (TNode *)TNodeFromFINode(v28), TNode::IsSynchingAppropriate(v23))
      && (v24 = atomic_load((unsigned int *)(*(_QWORD *)(TNodeFromFINode(v28) + 56) + 196)), v24 <= 1))
    {
      TNode::HandleFolderSizingRequest(a1);
    }
    else
    {
      if (v13 >= v22)
        v25 = v13 + 2000000;
      else
        v25 = v22;
      TNode::SetTimerToDispatchResizeRequest(a1, v25);
    }
    if (v29)
    {
      v26 = (unint64_t *)&v29->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
  }
LABEL_27:

}

void sub_1CBCE1E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11)
{

  _Unwind_Resume(a1);
}

void TNode::HandleFolderSizingRequest(id **a1)
{
  FINode *v2;
  unsigned __int16 *v3;
  unsigned __int16 v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  os_unfair_lock_s *v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  os_unfair_lock_s *v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  FINode *v25;
  TNode *v26;
  uint64_t v27;
  os_unfair_lock_s *v28;
  uint64_t v29;
  os_unfair_lock_s *v30;
  TNode *v31;
  TNode *v32;
  TNode *v33;
  TNode *v34;
  int v35;
  uint64_t v36;
  TTime *v37;
  TChildrenList *v38;
  uint64_t v39;
  uint64_t v40;
  os_unfair_lock_s *v41;
  FINode *fFINode;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  FINode *v51;
  std::__shared_weak_count *v52;
  TNodePtr v53;
  std::__shared_weak_count *v54;
  TNodePtr v55;
  FINode *v56;

  v2 = (FINode *)**a1;
  v56 = v2;
  if (TNodeFromFINode(v2))
  {
    v3 = (unsigned __int16 *)(TNodeFromFINode(v2) + 80);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 & 0xFFBF, v3));
    if (*((_DWORD *)*a1 + 13) != 1003)
    {
      TNodeTask::SetRequestStatus((TNodeTask *)*a1, 1002);
      v5 = TNodeFromFINode(v56);
      v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v5);
      os_unfair_lock_lock(v6);
      v8 = *(_QWORD *)(v5 + 16);
      v7 = *(std::__shared_weak_count **)(v5 + 24);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v10 = __ldxr(p_shared_owners);
        while (__stxr(v10 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v6);
      v11 = (os_unfair_lock_s *)(v8 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
      v12 = *(_DWORD *)(v8 + 115);
      os_unfair_lock_unlock(v11);
      if (!v7)
        goto LABEL_12;
      v13 = (unint64_t *)&v7->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        if ((v12 & 0x20) == 0)
          goto LABEL_45;
      }
      else
      {
LABEL_12:
        if ((v12 & 0x20) == 0)
          goto LABEL_45;
      }
      v15 = TNodeFromFINode(v56);
      v16 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v15);
      os_unfair_lock_lock(v16);
      v18 = *(_QWORD *)(v15 + 16);
      v17 = *(std::__shared_weak_count **)(v15 + 24);
      if (v17)
      {
        v19 = (unint64_t *)&v17->__shared_owners_;
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + 1, v19));
      }
      os_unfair_lock_unlock(v16);
      v21 = (os_unfair_lock_s *)(v18 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v18 + 100));
      v22 = *(_DWORD *)(v18 + 115);
      os_unfair_lock_unlock(v21);
      if (v17)
      {
        v23 = (unint64_t *)&v17->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v25 = v56;
      if ((v22 & 0x100) != 0)
      {
        v32 = (TNode *)TNodeFromFINode(v56);
        TNode::RecalculateFreeSpaceAndCapacity(v32, 1);
        v33 = (TNode *)TNodeFromFINode(v56);
        TNode::SetSizesAreValid(v33, 1);
        goto LABEL_45;
      }
      v26 = (TNode *)TNodeFromFINode(v56);
      if (!TNode::SynchingSuspended(v26))
      {
        v27 = TNodeFromFINode(v56);
        v28 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v27);
        os_unfair_lock_lock(v28);
        TNodePtr::TNodePtr(&v53, *(const TNode **)(v27 + 48));
        os_unfair_lock_unlock(v28);
        if (TNodeFromFINode(v53.fFINode))
        {
          v29 = TNodeFromFINode(v25);
          v30 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v29);
          os_unfair_lock_lock(v30);
          TNodePtr::TNodePtr(&v55, *(const TNode **)(v29 + 48));
          os_unfair_lock_unlock(v30);
          v31 = (TNode *)TNodeFromFINode(v55.fFINode);
          LODWORD(v29) = atomic_load((unsigned int *)(TNode::GetNotifierList(v31) + 4));

          v25 = v56;
          if ((int)v29 > 0)
          {
LABEL_32:
            v37 = (TTime *)TNodeFromFINode(v25);
            v38 = (TChildrenList *)*((_QWORD *)v37 + 7);
            v39 = TTime::MicrosecondsSinceStartup(v37);
            TChildrenList::SetLastResizeTime(v38, v39);
            v40 = TNodeFromFINode(v25);
            v41 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v40);
            os_unfair_lock_lock(v41);
            TNodePtr::TNodePtr(&v55, *(const TNode **)(v40 + 48));
            os_unfair_lock_unlock(v41);
            std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,void>((uint64_t)&v56, (uint64_t)&v55, (uint64_t)a1, &v53);

            fFINode = v53.fFINode;
            v51 = v53.fFINode;
            v52 = v54;
            if (v54)
            {
              v43 = (unint64_t *)&v54->__shared_owners_;
              do
                v44 = __ldxr(v43);
              while (__stxr(v44 + 1, v43));
            }
            TFSInfoSizer::SizeFolder((uint64_t)fFINode, (uint64_t *)&v51, 0xF4240uLL);
            v45 = v52;
            if (v52)
            {
              v46 = (unint64_t *)&v52->__shared_owners_;
              do
                v47 = __ldaxr(v46);
              while (__stlxr(v47 - 1, v46));
              if (!v47)
              {
                ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                std::__shared_weak_count::__release_weak(v45);
              }
            }
            v48 = v54;
            if (v54)
            {
              v49 = (unint64_t *)&v54->__shared_owners_;
              do
                v50 = __ldaxr(v49);
              while (__stlxr(v50 - 1, v49));
              if (!v50)
              {
                ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
                std::__shared_weak_count::__release_weak(v48);
              }
            }
            goto LABEL_45;
          }
        }
        else
        {

        }
        v34 = (TNode *)TNodeFromFINode(v25);
        v35 = atomic_load((unsigned int *)(TNode::GetNotifierList(v34) + 4));
        v25 = v56;
        if (v35 <= 0)
        {
          v36 = TNodeFromFINode(v56);
          if (!TNode::IsDeferredForSymlink(v36, (uint64_t (*)(_QWORD *))TFSInfo::IsPackage, 0))goto LABEL_45;
        }
        goto LABEL_32;
      }
    }
  }
LABEL_45:

}

void sub_1CBCE2284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  os_unfair_lock_s *v15;

  os_unfair_lock_unlock(v15);

  _Unwind_Resume(a1);
}

uint64_t TNode::GetCachedPackageSize(TNode *this)
{
  return -2;
}

uint64_t TNode::SizingGeneration(TNode *this)
{
  uint64_t v2;
  uint64_t v3;

  SizingGenerationMutex();
  TDSMutex::lock(&SizingGenerationMutex(void)::sMutex);
  v2 = *((_QWORD *)this + 7);
  if (v2)
    v3 = *(unsigned int *)(v2 + 180);
  else
    v3 = 0;
  TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
  return v3;
}

void SizingGenerationMutex(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      TDSMutex::TDSMutex(&SizingGenerationMutex(void)::sMutex, 0);
    }
  }
}

void sub_1CBCE23D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::SetSizeProperties(TNode *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  TNode *v14;
  uint64_t v15;
  int v16;
  os_unfair_lock_s *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  os_unfair_lock_s *v22;
  os_unfair_lock_s *v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  uint64_t v26;
  os_unfair_lock_s *v27;
  uint64_t v28;
  os_unfair_lock_s *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  os_unfair_lock_s *v33;
  uint64_t v34;
  TFSInfoOverflow *Overflow;
  uint64_t v36;
  TNode *v37;
  os_unfair_lock_s *v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50[4];
  char v51;

  v48 = 0;
  v49 = 0;
  v47 = (uint64_t *)&v48;
  SizingGenerationMutex();
  v14 = (TNode *)TDSMutex::lock(&SizingGenerationMutex(void)::sMutex);
  v15 = *((_QWORD *)this + 7);
  if (v15 && ((v16 = *(_DWORD *)(v15 + 180), a6 < 0) || v16 <= a6))
  {
    *(_DWORD *)(v15 + 180) = v16 + 1;
    v17 = (os_unfair_lock_s *)TNode::InfoLock(v14);
    os_unfair_lock_lock(v17);
    v19 = *((_QWORD *)this + 2);
    v18 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v46 = v18;
    if (v18)
    {
      p_shared_owners = (unint64_t *)&v18->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v17);
    v22 = (os_unfair_lock_s *)(v19 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 96));
    v23 = *(os_unfair_lock_s **)(v19 + 80);
    if (v23)
    {
      TFSInfoOverflow::FolderSizeRecord(v23, (uint64_t)v50);
      if (v51)
        v24 = v50[3];
      else
        v24 = -1;
    }
    else
    {
      v24 = -1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 96));
    if (v24 != a5)
    {
      LODWORD(v50[0]) = 1685480308;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v47, (unsigned int *)v50, v50);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 96));
    v25 = *(os_unfair_lock_s **)(v19 + 80);
    if (v25)
    {
      TFSInfoOverflow::FolderSizeRecord(v25, (uint64_t)v50);
      if (v51)
        v26 = v50[2];
      else
        v26 = -1;
    }
    else
    {
      v26 = -1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 96));
    if (v26 != a4)
    {
      LODWORD(v50[0]) = 1684237940;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v47, (unsigned int *)v50, v50);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 96));
    v27 = *(os_unfair_lock_s **)(v19 + 80);
    if (v27)
    {
      TFSInfoOverflow::FolderSizeRecord(v27, (uint64_t)v50);
      if (v51)
        v28 = v50[1];
      else
        v28 = -1;
    }
    else
    {
      v28 = -1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 96));
    if (v28 != a3)
    {
      LODWORD(v50[0]) = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v47, (unsigned int *)v50, v50);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 96));
    v29 = *(os_unfair_lock_s **)(v19 + 80);
    if (v29 && (TFSInfoOverflow::FolderSizeRecord(v29, (uint64_t)v50), v51))
      v30 = v50[0];
    else
      v30 = -1;
    os_unfair_lock_unlock(v22);
    if (v30 != a2)
    {
      LODWORD(v50[0]) = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v47, (unsigned int *)v50, v50);
    }
    if (v49)
    {
      v31 = operator new();
      v32 = -2;
      if (!a7)
        v32 = a2;
      *(_QWORD *)v31 = v32;
      *(_QWORD *)(v31 + 8) = a3;
      *(_QWORD *)(v31 + 16) = a4;
      *(_QWORD *)(v31 + 24) = a5;
      v50[0] = v31;
      v33 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v31);
      os_unfair_lock_lock(v33);
      v34 = *((_QWORD *)this + 2);
      os_unfair_lock_lock((os_unfair_lock_t)(v34 + 96));
      Overflow = TFSInfo::GetOrCreateOverflow((TFSInfo *)v34);
      TFSInfoOverflow::SetFolderSizeRecord((uint64_t)Overflow, v50);
      os_unfair_lock_unlock((os_unfair_lock_t)(v34 + 96));
      os_unfair_lock_unlock(v33);
      v36 = v50[0];
      v50[0] = 0;
      if (v36)
        MEMORY[0x1D17A53D0](v36, 0x1000C40E0EAB150);
    }
    TNode::SetSizesAreValid(this, 1);
    v38 = (os_unfair_lock_s *)TNode::InfoLock(v37);
    os_unfair_lock_lock(v38);
    v40 = *((_QWORD *)this + 2);
    v39 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    if (v39)
    {
      v41 = (unint64_t *)&v39->__shared_owners_;
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
      os_unfair_lock_unlock(v38);
      os_unfair_lock_lock((os_unfair_lock_t)(v40 + 100));
      *(_DWORD *)(v40 + 115) |= 0x8000000u;
      os_unfair_lock_unlock((os_unfair_lock_t)(v40 + 100));
      do
        v43 = __ldaxr(v41);
      while (__stlxr(v43 - 1, v41));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    else
    {
      os_unfair_lock_unlock(v38);
      os_unfair_lock_lock((os_unfair_lock_t)(v40 + 100));
      *(_DWORD *)(v40 + 115) |= 0x8000000u;
      os_unfair_lock_unlock((os_unfair_lock_t)(v40 + 100));
    }
    if (v46)
    {
      v44 = (unint64_t *)&v46->__shared_owners_;
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
    TNode::SendNotifications(this, &v47);
  }
  else
  {
    TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&v47, v48);
}

void sub_1CBCE27E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, _QWORD *a12)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&a11, a12);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEE_block_invoke(uint64_t a1)
{
  return TNode::HandleVolumeAdded(a1 + 32, *(_DWORD *)(a1 + 48) == 1024);
}

uint64_t __copy_helper_block_ea8_32c75_ZTSKZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c75_ZTSKZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEEE3__0(uint64_t a1)
{
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 32);
}

uint64_t TNode::HandleStoreProperty(uint64_t a1, FINode **a2)
{
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  __CFString *v7;
  const void *v8;
  int v9;

  v3 = (const void *)(*(_QWORD *)a1 + 24);
  v4 = TNodeFromFINode(*a2);
  v5 = *(unsigned int *)(*(_QWORD *)a1 + 20);
  v9 = 19;
  v7 = 0;
  v8 = v3;
  return TNode::SetProperty(v4, v5, &v8, &v7, 1, 0);
}

uint64_t TNode::HandleResolveAlias(id **a1, FINode **a2)
{
  unsigned int *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  const TNode *v8;
  int v9;
  TNodeRequest *v11;
  id obj;

  obj = 0;
  v4 = (unsigned int *)(*a1 + 3);
  LODWORD(v11) = 0;
  v5 = TPropertyValue::As<NodeRequestOptions>(v4, (unsigned int *)&v11);
  v6 = TNodeFromFINode(*a2);
  v11 = 0;
  LODWORD(v7) = TNode::FollowAlias(v6, (TNodePtr *)&obj, &v11, v5 & 0xFFFF7FFF);
  if (TNodeFromFINode((FINode *)obj))
    v7 = v7;
  else
    v7 = 4294959232;
  if (!(_DWORD)v7)
    objc_storeStrong(*a1, obj);
  v8 = (const TNode *)TNodeFromFINode(*a2);
  if ((_DWORD)v7)
    v9 = 24;
  else
    v9 = 21;
  TNode::SendNotification(v8, v9, (id *)a2, 0, v7);

  return v7;
}

void sub_1CBCE2A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

CFIndex TNode::HandleFetchBookmarkData(uint64_t *a1, TNodePtr *a2)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  char *v6;
  TFSInfo *v7;
  unint64_t *v8;
  unint64_t v9;
  CFIndex v10;
  CFIndex v11;
  unint64_t *v12;
  unint64_t v13;
  TNodeEvent *v14;
  TDSNotifier ***v15;
  TNodeEvent *v16;
  TDSNotifier **v18[3];
  TDSNotifier **v19[3];
  TDSNotifier *v20;
  TPropertyValue v21;
  id v22;
  __CFData *v23;

  v23 = 0;
  v4 = TNodeFromFINode(a2->fFINode);
  v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  v7 = *(TFSInfo **)(v4 + 16);
  v6 = *(char **)(v4 + 24);
  v21.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v7;
  v21.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer = v6;
  if (v6)
  {
    v8 = (unint64_t *)(v6 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v5);
  v10 = TFSInfo::CopyBookmarkDataTo(v7, &v23);
  v11 = v10;
  if (!v6)
    goto LABEL_8;
  v12 = (unint64_t *)(v6 + 8);
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    (*(void (**)(char *))(*(_QWORD *)v6 + 16))(v6);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v6);
    if ((_DWORD)v11)
      goto LABEL_12;
  }
  else
  {
LABEL_8:
    if ((_DWORD)v10)
    {
LABEL_12:
      memset(&v21, 0, sizeof(v21));
      v20 = 0;
      TNodeEvent::CreateNodeEvent(25, (id *)&a2->fFINode, 0, &v21, a1, &v20, &v22);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v20);
      TPropertyValue::~TPropertyValue(&v21);
      v16 = (TNodeEvent *)TNodeEventPtr::operator->(&v22);
      v15 = v18;
      TNodeEvent::NotifyNode(v18, v16, a2, 1);
      goto LABEL_13;
    }
  }
  if (!v23)
    goto LABEL_12;
  TNodeFromFINode(a2->fFINode);
  TPropertyValue::TPropertyValue<__CFData const*>((uint64_t)&v21, (const void **)&v23);
  v20 = 0;
  TNodeEvent::CreateNodeEvent(25, (id *)&a2->fFINode, 0, &v21, a1, &v20, &v22);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v20);
  TPropertyValue::~TPropertyValue(&v21);
  v14 = (TNodeEvent *)TNodeEventPtr::operator->(&v22);
  v15 = v19;
  TNodeEvent::NotifyNode(v19, v14, a2, 1);
LABEL_13:
  v21.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v15;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v21);
  TNodeEventPtr::~TNodeEventPtr(&v22);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&v23);
  return v11;
}

void sub_1CBCE2BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, TDSNotifier *a15, uint64_t a16)
{
  uint64_t v16;

  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a15);
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a16);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)(v16 - 56));
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleFetchNodeRequest(id **a1)
{
  TString *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  id *v7;
  uint64_t NodeFromPath;
  uint64_t NodeFromURL;
  id v10;
  uint64_t *v12;
  uint64_t *v13;
  id obj;
  TString v15;

  obj = 0;
  v15.fString.fRef = 0;
  v2 = (TString *)TPropertyValue::As<__CFString const*>((const void **)*a1 + 3, (void **)&v15.fString.fRef);
  v3 = (uint64_t *)(*a1 + 3);
  v15.fString.fRef = 0;
  v4 = TPropertyValue::As<__CFURL const*>(v3, (uint64_t **)&v15);
  v13 = v4;
  v5 = (uint64_t *)(*a1 + 3);
  v15.fString.fRef = 0;
  v6 = TPropertyValue::As<__CFData const*>(v5, (uint64_t **)&v15);
  v12 = v6;
  v7 = *a1;
  if (v2)
  {
    v15.fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(&v15, v2);
    NodeFromPath = TNode::GetNodeFromPath(&v15);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    if (!(_DWORD)NodeFromPath)
      goto LABEL_9;
  }
  else
  {
    if (v4)
    {
      NodeFromURL = TNode::GetNodeFromURL(&v13, &obj, *((unsigned int *)*a1 + 12));
    }
    else
    {
      if (!v6)
      {
        v10 = 0;
        goto LABEL_10;
      }
      NodeFromURL = TNode::GetNodeFromBookmarkData((uint64_t *)&v12, &obj, *((_DWORD *)*a1 + 12));
    }
    NodeFromPath = NodeFromURL;
    if (!(_DWORD)NodeFromURL)
    {
LABEL_9:
      v7 = *a1;
      v10 = obj;
LABEL_10:
      objc_storeStrong(v7, v10);
      NodeFromPath = 0;
    }
  }

  return NodeFromPath;
}

void sub_1CBCE2D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{

  _Unwind_Resume(a1);
}

uint64_t TNode::HandleDisconnectShareRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = TNodeFromFINode(*a2);
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = TNode::OpenServerSync(v3);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v7;
}

void sub_1CBCE2E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleAddServerToSidebarRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = TNodeFromFINode(*a2);
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = TNode::AddServerToSidebarSync(v3);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v7;
}

void sub_1CBCE2EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleRemoveServerFromSidebarRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = TNodeFromFINode(*a2);
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = TNode::AddServerToSidebarSync(v3);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v7;
}

void sub_1CBCE2F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleOpenScreenShareRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = TNodeFromFINode(*a2);
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = TNode::OpenScreenShareSync(v3);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v7;
}

void sub_1CBCE3000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleOpenServerRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = TNodeFromFINode(*a2);
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = TNode::OpenServerSync(v3);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v7;
}

void sub_1CBCE30A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TNode::HandleFPProviderError(uint64_t a1, FINode **a2)
{
  const TNode *v3;

  v3 = (const TNode *)TNodeFromFINode(*a2);
  TNode::SendNotification(v3, 2, (id *)a2, 1969385844, 0);
}

uint64_t TNode::HandleVolumeAdded(uint64_t a1, int a2)
{
  uint64_t *v3;
  TNodePtr *v4;
  uint64_t v5;
  TGlobalNodes *v6;
  const TNode *v7;
  void *v9;
  FINode *v10;

  v9 = 0;
  v10 = 0;
  v3 = TPropertyValue::As<__CFURL const*>((uint64_t *)(*(_QWORD *)a1 + 24), (uint64_t **)&v10);
  if (v3)
  {
    v5 = TNode::AddVolume((uint64_t)v3, 0, &v9);
    if (!(_DWORD)v5)
    {
      TNode::AddVolumeToSuperRoot((TNode *)&v9, v4);
      if (a2)
      {
        TGlobalNodes::RootNode((uint64_t *)&v10, v6);
        v7 = (const TNode *)TNodeFromFINode(v10);
        TNode::SendNotification(v7, 10, &v9, 0, 0);

      }
      v5 = 0;
    }
  }
  else
  {
    v5 = 4294967253;
  }

  return v5;
}

void sub_1CBCE318C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

uint64_t TNode::HandleMarkAsUsed(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  unint64_t v10;
  TNode *v12;

  v3 = TNodeFromFINode(*a2);
  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  v6 = *(_QWORD *)(v3 + 16);
  v5 = *(std::__shared_weak_count **)(v3 + 24);
  if (!v5)
  {
    os_unfair_lock_unlock(v4);
    if (*(_BYTE *)(v6 + 112))
      return 0;
LABEL_11:
    v12 = (TNode *)TNodeFromFINode(*a2);
    TNode::MarkAsUsed(v12);
    return 0;
  }
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  os_unfair_lock_unlock(v4);
  v9 = *(unsigned __int8 *)(v6 + 112);
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (!v9)
    goto LABEL_11;
  return 0;
}

uint64_t TNode::HandleSubscribeWithKQueue(uint64_t a1, FINode **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  TChildrenList *v5;
  TNode *v7;
  int v8;
  TNode *v9;
  int v10;
  timespec timeout;
  kevent changelist;
  FINode *v13;
  char v14[8];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v2 = TNodeFromFINode(*a2);
  *(_QWORD *)v14 = 0;
  v3 = TNode::FollowAlias(v2, (TNodePtr *)&v13, (TNodeRequest **)v14, 8);
  if (!(_DWORD)v3)
  {
    if (TNodeFromFINode(v13)
      && (v4 = TNodeFromFINode(v13), (v5 = *(TChildrenList **)(v4 + 56)) != 0)
      && !TChildrenList::IncrementSubscriptionCount(*(TChildrenList **)(v4 + 56)))
    {
      v7 = (TNode *)TNodeFromFINode(v13);
      v3 = TNode::CopyPathToCBuffer(v7, v14, 1024);
      if (!(_DWORD)v3)
      {
        v8 = open(v14, 0x8000, 0);
        if (v8 >= 1)
        {
          v9 = (TNode *)TChildrenList::SetSubscriptionFileDescriptor(v5, v8);
          TNode::AddkQueueNotification(v9);
          changelist.ident = v8;
          *(_QWORD *)&changelist.filter = 0x2B0025FFFCLL;
          changelist.data = 0;
          changelist.udata = (void *)TNodeFromFINode(v13);
          timeout.tv_sec = 0;
          timeout.tv_nsec = 0;
          v10 = TNode::KQueue((TNode *)changelist.udata);
          kevent(v10, &changelist, 1, 0, 0, &timeout);
        }
      }
    }
    else
    {
      v3 = 0;
    }
  }

  return v3;
}

void sub_1CBCE33BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{

  _Unwind_Resume(a1);
}

uint64_t TNode::HandleUnsubscribeWithKQueue(uint64_t a1, FINode **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  TChildrenList *v6;
  int SubscriptionFileDescriptor;
  TNode *v8;
  int v9;
  TNode *v10;
  timespec timeout;
  kevent changelist;
  TNodePtr v13;

  v13.fFINode = 0;
  v2 = TNodeFromFINode(*a2);
  changelist.ident = 0;
  v3 = TNode::FollowAlias(v2, &v13, (TNodeRequest **)&changelist, 8);
  if (!(_DWORD)v3)
  {
    if (TNodeFromFINode(v13.fFINode))
    {
      v5 = TNodeFromFINode(v13.fFINode);
      v6 = *(TChildrenList **)(v5 + 56);
      if (v6)
      {
        if (TChildrenList::DecrementSubscriptionCount(*(TChildrenList **)(v5 + 56)) == 1)
        {
          SubscriptionFileDescriptor = TChildrenList::GetSubscriptionFileDescriptor(v6);
          if (SubscriptionFileDescriptor >= 1)
          {
            v8 = (TNode *)TChildrenList::SetSubscriptionFileDescriptor(v6, 0);
            timeout.tv_nsec = 0;
            changelist.ident = SubscriptionFileDescriptor;
            *(_DWORD *)&changelist.filter = 196604;
            memset(&changelist.fflags, 0, 20);
            timeout.tv_sec = 0;
            v9 = TNode::KQueue(v8);
            kevent(v9, &changelist, 1, 0, 0, &timeout);
            v10 = (TNode *)close(SubscriptionFileDescriptor);
            TNode::RemovekQueueNotification(v10);
          }
        }
      }
    }
  }

  return v3;
}

void sub_1CBCE34E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

uint64_t TNode::HandleVolumeDeleted(uint64_t a1, FINode **a2)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  TFSInfo *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  const void *v12;

  v2 = TNodeFromFINode(*a2);
  v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
  os_unfair_lock_lock(v3);
  v5 = *(TFSInfo **)(v2 + 16);
  v4 = *(std::__shared_weak_count **)(v2 + 24);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v3);
  TFSInfo::GetVolumeID(v5, &v12);
  v8 = TNode::RemoveVolume(&v12);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v12);
  if (v4)
  {
    v9 = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v8;
}

void sub_1CBCE35CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va1);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleRegisterInternalNotificationTask(uint64_t a1, FINode **a2)
{
  TNodeEvent *v3;

  if (TNodeFromFINode(*a2))
  {
    v3 = (TNodeEvent *)TNodeFromFINode(*a2);
    TNode::RegisterForInternalNotifications(v3, a2, 3);
  }
  return 0;
}

uint64_t TPropertyValue::TPropertyValue<__CFData const*>(uint64_t a1, const void **a2)
{
  const void *v3;
  const void *v5;

  v3 = *a2;
  v5 = v3;
  if (v3)
    CFRetain(v3);
  TPropertyValue::TPropertyValue<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(a1, &v5);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
  return a1;
}

void sub_1CBCE367C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::InlineProgressCancel(TNode *this)
{
  TNodePtr v1;

  TNodePtr::TNodePtr(&v1, this);
  TProgressMap::CancelProgress((TProgressMap *)&v1, (const TNodePtr *)1);

}

void sub_1CBCE36D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

int *NWMapSpinlock(void)
{
  unsigned __int8 v0;

  {
    NWMapSpinlock(void)::sNWMapSpinlock = 0;
  }
  return &NWMapSpinlock(void)::sNWMapSpinlock;
}

double TNode::GetNWNodeMap(int a1)
{
  uint64_t v1;
  double result;
  uint64_t v3;

  if ((a1 - 31) >= 2)
  {
    if (a1 != 33)
      abort();
    if (!gAirDropNodeMap)
    {
      v3 = operator new();
      result = 0.0;
      *(_OWORD *)v3 = 0u;
      *(_OWORD *)(v3 + 16) = 0u;
      *(_DWORD *)(v3 + 32) = 1065353216;
      gAirDropNodeMap = v3;
    }
  }
  else if (!gNWSidebarNodeMap)
  {
    v1 = operator new();
    result = 0.0;
    *(_OWORD *)v1 = 0u;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_DWORD *)(v1 + 32) = 1065353216;
    gNWSidebarNodeMap = v1;
  }
  return result;
}

void TNode::GetNWNode(int a1@<W0>, uint64_t a2@<X1>, TNodePtr *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  v7 = a2;
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  TNode::GetNWNodeMap(a1);
  v6 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(v5, &v7);
  if (v6)
    a3->fFINode = (FINode *)(id)v6[3];
  else
    TNodePtr::TNodePtr(a3, 0);
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

void sub_1CBCE3850(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  _Unwind_Resume(a1);
}

void ___ZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptions_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  id v6;
  id v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  id v11;
  id v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[5];
  std::__shared_weak_count *v19;
  id v20;
  id v21;
  unint64_t v22;

  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3321888768;
  v18[2] = ___ZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEv_block_invoke;
  v18[3] = &__block_descriptor_72_ea8_32c127_ZTSKZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEvEUlvE__e5_v8__0l;
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v6 = *(id *)(a1 + 56);
  v7 = *(id *)(a1 + 48);
  v8 = *(unsigned __int8 *)(a1 + 64) | ((unint64_t)*(unsigned int *)(a1 + 68) << 32);
  v18[4] = v3;
  v19 = v2;
  if (v2)
  {
    v9 = (unint64_t *)&v2->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = v6;
  v20 = v11;
  v12 = v7;
  v21 = v12;
  v22 = v8;
  ExceptionSafeBlock(v18);

  if (v2)
  {
    v13 = (unint64_t *)&v2->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  v15 = v19;
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_1CBCE39CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *a16, void *a17)
{
  std::__shared_weak_count *v17;
  void *v18;
  void *v19;
  unint64_t *p_shared_owners;
  unint64_t v22;

  if (a15)
    TOperationSizer::ComputeSizeWithTimeout(a15);

  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c114_ZTSKZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsE3__0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id result;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = *(id *)(a2 + 48);
  result = *(id *)(a2 + 56);
  a1[7] = result;
  a1[8] = *(_QWORD *)(a2 + 64);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c114_ZTSKZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsE3__0(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

uint64_t std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<TTempProperties&,BOOL,0>(uint64_t a1, __int128 *a2, _BYTE *a3)
{
  __int128 v6;

  v6 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v6;
  *(_QWORD *)(a1 + 24) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), *((TString **)a2 + 3));
  *(_QWORD *)(a1 + 32) = *((id *)a2 + 4);
  *(_BYTE *)(a1 + 40) = *a3;
  return a1;
}

void sub_1CBCE3B38(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<true,0>(uint64_t a1, __int128 *a2, _BYTE *a3)
{
  __int128 v6;

  v6 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v6;
  *(_QWORD *)(a1 + 24) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), *((TString **)a2 + 3));
  *(_QWORD *)(a1 + 32) = *((id *)a2 + 4);
  *(_BYTE *)(a1 + 40) = *a3;
  return a1;
}

void sub_1CBCE3BC0(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

TString *std::deque<TString>::__append<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>,0>(_QWORD *a1, char *a2, TString **a3, char *a4, TString **a5)
{
  unint64_t v5;

  if (a5 == a3)
    v5 = 0;
  else
    v5 = (((uint64_t)a5 - *(_QWORD *)a4) >> 3) + ((a4 - a2) << 6) - (((uint64_t)a3 - *(_QWORD *)a2) >> 3);
  return std::deque<TString>::__append_with_size[abi:ne180100]<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>>(a1, a2, a3, v5);
}

TString *std::deque<TString>::__append_with_size[abi:ne180100]<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>>(_QWORD *a1, _QWORD *a2, TString **a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  TString *v13;
  uint64_t v14;
  TString *result;
  uint64_t v16;
  TString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  TString **v21;
  uint64_t fRef;
  _QWORD v23[2];

  v8 = a1[1];
  v9 = a1[2];
  if (v9 == v8)
    v10 = 0;
  else
    v10 = ((v9 - v8) << 6) - 1;
  v11 = a1[5] + a1[4];
  v12 = v10 - v11;
  if (a4 > v12)
  {
    std::deque<TString>::__add_back_capacity(a1, a4 - v12);
    v8 = a1[1];
    v9 = a1[2];
    v11 = a1[4] + a1[5];
  }
  v13 = (TString *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8)
    v14 = 0;
  else
    v14 = (uint64_t)v13->fString.fRef + 8 * (v11 & 0x1FF);
  v23[0] = v8 + 8 * (v11 >> 9);
  v23[1] = v14;
  result = (TString *)std::__deque_iterator<TString,TString*,TString&,TString**,long,512l>::operator+[abi:ne180100]((uint64_t)v23, a4);
  if (v14 != v16)
  {
    v17 = result;
    v18 = v16;
    do
    {
      if (v13 == v17)
        v19 = v18;
      else
        v19 = (uint64_t)&v13->fString.fRef[128];
      if (v14 == v19)
      {
        v19 = v14;
      }
      else
      {
        v20 = 0;
        do
        {
          result = std::construct_at[abi:ne180100]<TString,TString const&,TString*>((TString *)(v14 + v20), a3++);
          if ((TString **)((char *)a3 - *a2) == (TString **)4096)
          {
            v21 = (TString **)a2[1];
            ++a2;
            a3 = v21;
          }
          v20 += 8;
        }
        while (v14 + v20 != v19);
      }
      a1[5] += (v19 - v14) >> 3;
      if (v13 == v17)
        break;
      fRef = (uint64_t)v13[1].fString.fRef;
      ++v13;
      v14 = fRef;
    }
    while (fRef != v18);
  }
  return result;
}

void sub_1CBCE3D60(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 40) += v2 >> 3;
  _Unwind_Resume(a1);
}

_QWORD *std::__deque_iterator<TString,TString*,TString&,TString**,long,512l>::operator+[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v4;

  result = *(_QWORD **)a1;
  if (a2)
  {
    v4 = a2 + ((uint64_t)(*(_QWORD *)(a1 + 8) - *result) >> 3);
    if (v4 < 1)
      result -= (unint64_t)(511 - v4) >> 9;
    else
      result += (unint64_t)v4 >> 9;
  }
  return result;
}

_QWORD *std::optional<TNodePtr>::value_or[abi:ne180100]<TNodePtr const&>@<X0>(uint64_t a1@<X0>, id *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  if (*(_BYTE *)(a1 + 8))
    return TNodePtr::TNodePtr(a3, (id *)a1);
  result = *a2;
  *a3 = result;
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,void *>>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::mutex::~mutex((std::mutex *)(a2 + 32));

  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

_QWORD *std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__init_with_size[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<TNodePtr>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1CBCE3ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  TDSNotifier *v8;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = *(TDSNotifier **)(a2 + v7);
      *(_QWORD *)(a4 + v7) = v8;
      if (v8)
        TDSNotifier::AddPtrReference(v8);
      v7 += 8;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1CBCE3F4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 8;
    do
    {
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)(v4 + v2));
      v2 -= 8;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void ___ZZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsENK3__0clEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = TNodeFromFINode(*(FINode **)(a1 + 32));
  TChildrenList::ClearSizesFetchedForUnobservedNodes(*(TChildrenList **)(v1 + 56));
}

id __copy_helper_block_ea8_32c13_ZTS8TNodePtr(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c13_ZTS8TNodePtr(uint64_t a1)
{

}

uint64_t std::vector<TString>::push_back[abi:ne180100](uint64_t a1, TString **a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  TString *v16;
  TString *v17;
  char *v18;
  uint64_t v19;

  v6 = *(_QWORD *)(a1 + 16);
  v4 = a1 + 16;
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *(_QWORD *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *(_QWORD *)a1;
    v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = (TString *)&v14[8 * v10];
    v18 = &v14[8 * v13];
    std::construct_at[abi:ne180100]<TString,TString const&,TString*>(v16, a2);
    v17 = v16 + 1;
    std::vector<TString>::__swap_out_circular_buffer((CFTypeRef *)a1, &v15);
    v9 = *(_QWORD *)(a1 + 8);
    result = std::__split_buffer<TString>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = (uint64_t)std::construct_at[abi:ne180100]<TString,TString const&,TString*>(*(TString **)(v4 - 8), a2);
    v9 = v7 + 8;
    *(_QWORD *)(a1 + 8) = v7 + 8;
  }
  *(_QWORD *)(a1 + 8) = v9;
  return result;
}

void sub_1CBCE40AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void ___ZZN5TNode10RemoveSelfEP14TNodeEventPtrsENK3__0clEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const TNode *v3;
  FINode *v4[3];
  TNodePtr v5;

  TGlobalNodes::RootNode((uint64_t *)&v5, (TGlobalNodes *)a1);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v4, &v5, 0);
  v2 = TNodeFromFINode(v5.fFINode);
  if (TChildrenList::RemoveChild(*(TChildrenList **)(v2 + 56), (const TNodePtr *)(a1 + 32)) && *(_BYTE *)(a1 + 40))
  {
    v3 = (const TNode *)TNodeFromFINode(v5.fFINode);
    TNode::SendNotification(v3, 4, (id *)(a1 + 32), 0, 0);
  }
  TNode::StPopulating::~StPopulating(v4);

}

void sub_1CBCE4158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{

  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo&,void>@<X0>(const TFSInfo *a1@<X1>, _QWORD *a2@<X8>)
{
  char *v4;
  uint64_t result;

  v4 = (char *)operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo&,std::allocator<TFSInfo>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1CBCE41C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo&,std::allocator<TFSInfo>,0>(uint64_t a1, const TFSInfo *a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), a2);
  return a1;
}

void sub_1CBCE420C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::back_insert_iterator<std::vector<std::pair<TNodePtr,FPItem * {__strong}>>>::operator=[abi:ne180100](uint64_t **a1, uint64_t a2)
{
  uint64_t *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *a1;
  v5 = (_QWORD *)(*a1)[1];
  if ((unint64_t)v5 >= v4[2])
  {
    v8 = std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__push_back_slow_path<std::pair<TNodePtr,FPItem * {__strong}>>(v4, a2);
  }
  else
  {
    v6 = TNodePtr::TNodePtr(v5, (id *)a2);
    v7 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = 0;
    v6[1] = v7;
    v8 = (uint64_t)(v6 + 2);
  }
  v4[1] = v8;
  return a1;
}

uint64_t std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__push_back_slow_path<std::pair<TNodePtr,FPItem * {__strong}>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[5];

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 4;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 3 > v5)
    v5 = v8 >> 3;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
    v9 = 0xFFFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v15[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[16 * v4];
  v15[0] = v10;
  v15[1] = v11;
  v15[3] = &v10[16 * v9];
  TNodePtr::TNodePtr(v11, (id *)a2);
  v12 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *((_QWORD *)v11 + 1) = v12;
  v15[2] = v11 + 16;
  std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__swap_out_circular_buffer(a1, v15);
  v13 = a1[1];
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_1CBCE4360(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      TNodePtr::TNodePtr((_QWORD *)(v7 - 16), (id *)(v9 - 16));
      v10 = *(_QWORD *)(v9 - 8);
      *(_QWORD *)(v9 - 8) = 0;
      *(_QWORD *)(v7 - 8) = v10;
      v7 = *((_QWORD *)&v16 + 1) - 16;
      *((_QWORD *)&v16 + 1) -= 16;
      v9 -= 16;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id *i;

  for (i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {

    i = (id *)(*(_QWORD *)(a2 + 32) + 16);
  }
}

void std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;

  }
}

uint64_t std::__tree<Property>::__erase_unique<Property>(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  uint64_t *v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = *(_DWORD *)(v2 + 28);
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (v6)
      v4 = v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28))
    return 0;
  std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

_QWORD *std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::vector(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (_QWORD *)a1[1];
    v5 = &v4[2 * a2];
    v6 = 16 * a2;
    do
    {
      fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::optional_err(v4);
      v4 += 2;
      v6 -= 16;
    }
    while (v6);
    a1[1] = v5;
  }
  return a1;
}

void sub_1CBCE4674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::optional_err(_QWORD *a1)
{
  *a1 = 0;
  objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB2F90], -1, 0);
  a1[1] = objc_claimAutoreleasedReturnValue();
  return a1;
}

void sub_1CBCE46E0(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0ul,1ul,2ul>(uint64_t a1, uint64_t a2)
{
  std::__optional_storage_base<FPItem * {__strong},false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<FPItem * {__strong},false>>(a1, (uint64_t *)a2);
  std::__optional_storage_base<FPItem * {__strong},false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<FPItem * {__strong},false>>(a1 + 16, (uint64_t *)(a2 + 16));
  return std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](a1 + 32, (__int128 *)(a2 + 32));
}

void std::__optional_storage_base<FPItem * {__strong},false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<FPItem * {__strong},false>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  id v4;
  uint64_t v5;

  if (*(unsigned __int8 *)(a1 + 8) == *((unsigned __int8 *)a2 + 8))
  {
    if (*(_BYTE *)(a1 + 8))
    {
      v3 = *a2;
      *a2 = 0;
      v4 = *(id *)a1;
      *(_QWORD *)a1 = v3;

    }
  }
  else if (*(_BYTE *)(a1 + 8))
  {

    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    v5 = *a2;
    *a2 = 0;
    *(_QWORD *)a1 = v5;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[17];
  id obj;
  _QWORD v9[8];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)v7, a2);
  v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    v4 = v12;
    if (v12 >= v11 - 1)
    {
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v9, v10, 4);
      v4 = -1;
      v11 = v5;
      v12 = -1;
    }
    if (v10[4] != *(_QWORD *)v9[2])
    {
      objc_enumerationMutation(obj);
      v4 = v12;
    }
    v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1CBCE488C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

void type_traits_extras::CopyAsHelper<std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::MakeWithCapacity(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3;
  uint64_t v4;
  void **v5;

  v3 = 0uLL;
  v4 = 0;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::reserve((uint64_t *)&v3, a1);
  *(_OWORD *)a2 = v3;
  *(_QWORD *)(a2 + 16) = v4;
  v4 = 0;
  v3 = 0uLL;
  v5 = (void **)&v3;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_1CBCE4910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCE4A94(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 16 * v6;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1CBCE4B28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *a3 = 0;
      a3[1] = 0;
      *(_OWORD *)(v8 - 16) = v9;
      v8 -= 16;
      v7 -= 16;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v8;
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::function<void ()(__CFURL const*,FPItem *,NSError *)>::operator()(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6;
  id v7;
  id v8;
  uint64_t v9;

  v9 = a2;
  v8 = a3;
  v7 = a4;
  v6 = *(_QWORD *)(a1 + 24);
  if (!v6)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *, id *, id *))(*(_QWORD *)v6 + 48))(v6, &v9, &v8, &v7);

}

void sub_1CBCE4CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{

  _Unwind_Resume(a1);
}

id std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    return *(id *)a1;
  else
    return 0;
}

uint64_t std::optional<FPItem * {__strong}>::operator=[abi:ne180100]<FPItem * {__strong}&,void>(uint64_t a1, id *a2)
{
  int v3;
  id v4;
  void *v5;

  v3 = *(unsigned __int8 *)(a1 + 8);
  v4 = *a2;
  if (v3)
  {
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;

  }
  else
  {
    *(_QWORD *)a1 = v4;
    *(_BYTE *)(a1 + 8) = 1;
  }
  return a1;
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[17];
  id obj;
  _QWORD v9[8];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v7, a2);
  v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    v4 = v12;
    if (v12 >= v11 - 1)
    {
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v9, v10, 4);
      v4 = -1;
      v11 = v5;
      v12 = -1;
    }
    if (v10[4] != *(_QWORD *)v9[2])
    {
      objc_enumerationMutation(obj);
      v4 = v12;
    }
    v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1CBCE4E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

void std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>(uint64_t a1@<X0>, TNodePtr *a2@<X8>)
{
  if (*(_BYTE *)(a1 + 8))
    TNodePtr::TNodePtr(a2, (id *)a1);
  else
    TNodePtr::TNodePtr(a2, 0);
}

void ___ZL23FPItemForProviderWithIDRK7TStringS1__block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v6;

  v6 = a2;
  if (!a3)
    objc_storeStrong(*(id **)(a1 + 32), a2);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));

}

id __copy_helper_block_ea8_32c50_ZTSKZL23FPItemForProviderWithIDRK7TStringS1_E3__0(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  id result;

  v3 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  result = *(id *)(a2 + 48);
  a1[6] = result;
  return result;
}

uint64_t __destroy_helper_block_ea8_32c50_ZTSKZL23FPItemForProviderWithIDRK7TStringS1_E3__0(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v1);
}

void std::__shared_ptr_emplace<FPItem * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750960;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<FPItem * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750960;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<FPItem * {__strong}>::__on_zero_shared(uint64_t a1)
{

}

uint64_t std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__push_back_slow_path<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[5];

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v14[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[24 * v9];
  TNodePtr::TNodePtr(v11, (id *)a2);
  *(_OWORD *)(v11 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v14[2] = v11 + 24;
  std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1CBCE50A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      TNodePtr::TNodePtr((_QWORD *)(v7 - 24), (id *)(v9 - 24));
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(v9 - 16);
      *(_QWORD *)(v9 - 16) = 0;
      *(_QWORD *)(v9 - 8) = 0;
      v7 = *((_QWORD *)&v15 + 1) - 24;
      *((_QWORD *)&v15 + 1) -= 24;
      v9 -= 24;
    }
    while (v9 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id *i;

  for (i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(i + 1));

    i = (id *)(*(_QWORD *)(a2 + 32) + 24);
  }
}

void std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](i - 16);

  }
}

void std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

void std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;
  void *v5;

  for (i = *(_QWORD *)(a1 + 8); i != a2; i -= 24)
  {
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](i - 16);
    v5 = *(void **)(i - 24);

  }
  *(_QWORD *)(a1 + 8) = a2;
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>(uint64_t a1, id *a2, id *a3, _QWORD *a4)
{
  _QWORD *v4;
  id *v6;
  _QWORD *v7;
  _QWORD v9[3];
  char v10;
  _QWORD *v11;
  _QWORD *v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  if (a2 == a3)
  {
    v7 = a4;
  }
  else
  {
    v6 = a2;
    v7 = v12;
    do
    {
      *v4 = *v6;
      v4[1] = v6[1];
      v7 += 2;
      v6 += 2;
      v4 = v7;
    }
    while (v6 != a3);
    v12 = v7;
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v7;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>(*(_QWORD *)a1, **(_QWORD **)(a1 + 16), **(_QWORD **)(a1 + 16), **(_QWORD **)(a1 + 8), **(_QWORD **)(a1 + 8));
  return a1;
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  void *v7;

  if (a3 != a5)
  {
    v6 = a3;
    do
    {

      v7 = *(void **)(v6 - 16);
      v6 -= 16;

    }
    while (v6 != a5);
  }
}

void TFSInfoOverflow::SetFolderSizeRecord(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  v5 = *a2;
  *a2 = 0;
  v6 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v5;
  if (v6)
    MEMORY[0x1D17A53D0](v6, 0x1000C40E0EAB150);
  os_unfair_lock_unlock(v4);
}

uint64_t *TPropertyValue::As<__CFURL const*>(uint64_t *result, uint64_t **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_35;
      result = *a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_35;
      goto LABEL_39;
    case 2:
      if (v2 != 2)
        goto LABEL_35;
      goto LABEL_39;
    case 3:
      if (v2 != 3)
        goto LABEL_35;
      goto LABEL_39;
    case 4:
      if (v2 != 4)
        goto LABEL_35;
      goto LABEL_39;
    case 5:
      if (v2 != 5)
        goto LABEL_35;
      goto LABEL_39;
    case 6:
      if (v2 != 6)
        goto LABEL_35;
      goto LABEL_39;
    case 7:
      if (v2 != 7)
        goto LABEL_35;
      goto LABEL_39;
    case 8:
      if (v2 != 8)
        goto LABEL_35;
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10)
        goto LABEL_35;
      goto LABEL_39;
    case 11:
      if (v2 != 11)
        goto LABEL_35;
      goto LABEL_39;
    case 12:
      if (v2 != 12)
        goto LABEL_35;
      goto LABEL_39;
    case 13:
      if (v2 != 13)
        goto LABEL_35;
      goto LABEL_39;
    case 14:
      if (v2 != 14)
        goto LABEL_35;
      goto LABEL_39;
    case 15:
      if (v2 != 15)
        goto LABEL_35;
      goto LABEL_39;
    case 16:
      if (v2 != 16)
        goto LABEL_35;
      result = (uint64_t *)*result;
      break;
    case 17:
      if (v2 != 17)
        goto LABEL_35;
      goto LABEL_39;
    case 18:
      if (v2 != 18)
        goto LABEL_35;
      goto LABEL_39;
    case 19:
      if (v2 == 19)
        goto LABEL_39;
      goto LABEL_35;
    case 20:
      if (v2 != 20)
        goto LABEL_35;
      goto LABEL_39;
    case 21:
      if (v2 != 21)
        goto LABEL_35;
      goto LABEL_39;
    case 22:
      if (v2 != 22)
        goto LABEL_35;
      goto LABEL_39;
    case 23:
      if (v2 != 23)
LABEL_35:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

const void **TPropertyValue::As<__CFString const*>(const void **result, void **a2)
{
  int v2;

  v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_27;
      result = (const void **)*a2;
      break;
    case 1:
      if (v2 != 1)
        goto LABEL_27;
      goto LABEL_39;
    case 2:
      if (v2 != 2)
        goto LABEL_27;
      goto LABEL_39;
    case 3:
      if (v2 != 3)
        goto LABEL_27;
      goto LABEL_39;
    case 4:
      if (v2 != 4)
        goto LABEL_27;
      goto LABEL_39;
    case 5:
      if (v2 != 5)
        goto LABEL_27;
      goto LABEL_39;
    case 6:
      if (v2 != 6)
        goto LABEL_27;
      goto LABEL_39;
    case 7:
      if (v2 != 7)
        goto LABEL_27;
      goto LABEL_39;
    case 8:
      if (v2 != 8)
        goto LABEL_27;
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10)
        goto LABEL_27;
      goto LABEL_39;
    case 11:
      if (v2 != 11)
        goto LABEL_27;
      result = (const void **)AsPriv<__CFString const*,TString>(result);
      break;
    case 12:
      if (v2 != 12)
        goto LABEL_27;
      result = (const void **)*result;
      break;
    case 13:
      if (v2 != 13)
        goto LABEL_27;
      goto LABEL_39;
    case 14:
      if (v2 != 14)
        goto LABEL_27;
      goto LABEL_39;
    case 15:
      if (v2 != 15)
        goto LABEL_27;
      goto LABEL_39;
    case 16:
      if (v2 != 16)
        goto LABEL_27;
      goto LABEL_39;
    case 17:
      if (v2 != 17)
        goto LABEL_27;
      goto LABEL_39;
    case 18:
      if (v2 != 18)
        goto LABEL_27;
      goto LABEL_39;
    case 19:
      if (v2 == 19)
        goto LABEL_39;
      goto LABEL_27;
    case 20:
      if (v2 != 20)
        goto LABEL_27;
      goto LABEL_39;
    case 21:
      if (v2 != 21)
        goto LABEL_27;
      goto LABEL_39;
    case 22:
      if (v2 != 22)
        goto LABEL_27;
      goto LABEL_39;
    case 23:
      if (v2 != 23)
LABEL_27:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      result = (const void **)*a2;
      break;
    default:
      return result;
  }
  return result;
}

const void *AsPriv<__CFString const*,TString>(const void **a1)
{
  const void *result;
  CFTypeRef v2;

  result = RetainCF<__CFString const*>(a1);
  if (result)
  {
    v2 = CFAutorelease(result);
    return static_cf_cast<__CFString const*,void const*>(v2);
  }
  return result;
}

void ___ZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEv_block_invoke(uint64_t a1)
{
  unsigned __int16 *v2;
  unsigned __int16 v3;
  TGlobalNodes *v4;

  if (*(_BYTE *)(a1 + 64))
  {
    v2 = (unsigned __int16 *)(TNodeFromFINode(*(FINode **)(a1 + 48)) + 80);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 & 0xFFFB, v2));
  }
  if ((TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)(a1 + 32)) & 1) == 0)
  {
    v4 = (TGlobalNodes *)TNodeFromFINode(*(FINode **)(a1 + 48));
    TNode::RequestSynchronize(v4, *(_DWORD *)(a1 + 68));
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 56));
}

id __copy_helper_block_ea8_32c127_ZTSKZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEvEUlvE_(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id result;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = *(id *)(a2 + 48);
  result = *(id *)(a2 + 56);
  a1[7] = result;
  a1[8] = *(_QWORD *)(a2 + 64);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c127_ZTSKZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEvEUlvE_(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

uint64_t std::__tree<TNodePtr>::__erase_unique<TNodePtr>(uint64_t **a1, FINode **a2)
{
  uint64_t v3;

  v3 = std::__tree<TNodePtr>::find<TNodePtr>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  std::__tree<TNodePtr>::erase(a1, v3);
  return 1;
}

uint64_t std::__tree<TNodePtr>::find<TNodePtr>(uint64_t a1, FINode **a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v3 = a1 + 8;
  v4 = std::__tree<TNodePtr>::__lower_bound<TNodePtr>(a1, a2, *(_QWORD *)(a1 + 8), a1 + 8);
  if (v3 == v4)
    return v3;
  v5 = v4;
  v6 = TNodeFromFINode(*a2);
  if (v6 < TNodeFromFINode(*(FINode **)(v5 + 32)))
    return v3;
  return v5;
}

uint64_t *std::__tree<TNodePtr>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

uint64_t std::__tree<TNodePtr>::__lower_bound<TNodePtr>(uint64_t a1, FINode **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t v7;
  unint64_t v8;
  uint64_t *v9;

  if (a3)
  {
    v5 = a3;
    do
    {
      v7 = TNodeFromFINode(*(FINode **)(v5 + 32));
      v8 = TNodeFromFINode(*a2);
      v9 = (uint64_t *)(v5 + 8);
      if (v7 >= v8)
      {
        v9 = (uint64_t *)v5;
        a4 = v5;
      }
      v5 = *v9;
    }
    while (*v9);
  }
  return a4;
}

uint64_t *std::__tree<TNodePtr>::__emplace_unique_key_args<TNodePtr,TNodePtr>(uint64_t **a1, FINode **a2, id *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = std::__tree<TNodePtr>::__find_equal<TNodePtr>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x28uLL);
    TNodePtr::TNodePtr(v6 + 4, a3);
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<TNodePtr>::__find_equal<TNodePtr>(uint64_t a1, _QWORD *a2, FINode **a3)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;

  v5 = (uint64_t *)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = TNodeFromFINode(*a3);
        if (v8 >= TNodeFromFINode((FINode *)v7[4]))
          break;
        v4 = (uint64_t *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      v9 = TNodeFromFINode((FINode *)v7[4]);
      if (v9 >= TNodeFromFINode(*a3))
        break;
      v5 = v7 + 1;
      v4 = (uint64_t *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (uint64_t *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t TPropertyReference::SetAs<__CFDictionary const*>(uint64_t a1, id *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1)
        goto LABEL_44;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_44;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_44;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_44;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_44;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_44;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_44;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_44;
      return 4294959246;
    case 9:
      if (v2 != 9)
        goto LABEL_44;
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_44;
      SetAsPriv<__CFDictionary const*,NSObject * {__strong}>(a2, *(id **)a1);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_44;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_44;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_44;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_44;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_44;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(*(CFTypeRef **)a1, *a2);
      return 0;
    case 16:
      if (v2 != 16)
        goto LABEL_44;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_44;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_44;
      return 4294959246;
    case 19:
      if (v2 != 19)
        goto LABEL_44;
      return TPropertyValue::SetAs<__CFDictionary const*>(*(id **)a1, a2);
    case 20:
      if (v2 == 20)
        return 4294959246;
      goto LABEL_44;
    case 21:
      if (v2 != 21)
        goto LABEL_44;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_44;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_44:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void SetAsPriv<__CFDictionary const*,NSObject * {__strong}>(id *a1, id *location)
{
  objc_storeStrong(location, *a1);
}

uint64_t TPropertyValue::SetAs<__CFDictionary const*>(id *location, id *a2)
{
  int v2;
  id v4;
  const void *v6;

  v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      v4 = *a2;
      v6 = v4;
      if (v4)
        CFRetain(v4);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>((uint64_t)location, (const void **)location, &v6);
      TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v6);
      return 0;
    case 1:
      if (v2 != 1)
        goto LABEL_35;
      return 4294959246;
    case 2:
      if (v2 != 2)
        goto LABEL_35;
      return 4294959246;
    case 3:
      if (v2 != 3)
        goto LABEL_35;
      return 4294959246;
    case 4:
      if (v2 != 4)
        goto LABEL_35;
      return 4294959246;
    case 5:
      if (v2 != 5)
        goto LABEL_35;
      return 4294959246;
    case 6:
      if (v2 != 6)
        goto LABEL_35;
      return 4294959246;
    case 7:
      if (v2 != 7)
        goto LABEL_35;
      return 4294959246;
    case 8:
      if (v2 != 8)
        goto LABEL_35;
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10)
        goto LABEL_35;
      SetAsPriv<__CFDictionary const*,NSObject * {__strong}>(a2, location);
      return 0;
    case 11:
      if (v2 != 11)
        goto LABEL_35;
      return 4294959246;
    case 12:
      if (v2 != 12)
        goto LABEL_35;
      return 4294959246;
    case 13:
      if (v2 != 13)
        goto LABEL_35;
      return 4294959246;
    case 14:
      if (v2 != 14)
        goto LABEL_35;
      return 4294959246;
    case 15:
      if (v2 != 15)
        goto LABEL_35;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)location, *a2);
      return 0;
    case 16:
      if (v2 != 16)
        goto LABEL_35;
      return 4294959246;
    case 17:
      if (v2 != 17)
        goto LABEL_35;
      return 4294959246;
    case 18:
      if (v2 != 18)
        goto LABEL_35;
      return 4294959246;
    case 19:
      if (v2 == 19)
        return 4294959246;
      goto LABEL_35;
    case 20:
      if (v2 != 20)
        goto LABEL_35;
      return 4294959246;
    case 21:
      if (v2 != 21)
        goto LABEL_35;
      return 4294959246;
    case 22:
      if (v2 != 22)
        goto LABEL_35;
      return 4294959246;
    case 23:
      if (v2 != 23)
LABEL_35:
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__tree<TNodePtr>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<TNodePtr>::destroy(a1, *a2);
    std::__tree<TNodePtr>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

TChildrenList *std::unique_ptr<TChildrenList>::reset[abi:ne180100](TChildrenList **a1, TChildrenList *a2)
{
  TChildrenList *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    TChildrenList::~TChildrenList(result);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

uint64_t std::default_delete<TNotifierList>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void **v4;

  if (a2)
  {
    v4 = (void **)(a2 + 40);
    std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](&v4);
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a2 + 24);
    return MEMORY[0x1D17A53D0](a2, 0x1020C40F61775ADLL);
  }
  return result;
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,void>@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,std::allocator<TFSInfo>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1CBCE5FA4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,std::allocator<TFSInfo>,0>(_QWORD *a1, char *a2, uint64_t *a3)
{
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  a1[1] = 0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1CBCE5FF8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = FowlerNollVoHash::hash(this, this);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef))
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE6268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;

  v7 = a1 + 16;
  v8 = operator new(0x40uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = std::pair<TString const,std::unordered_set<_opaque_pthread_t *>>::pair[abi:ne180100]<TString const&>((uint64_t)(v8 + 2), *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCE62F4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  const void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TString const,std::unordered_set<_opaque_pthread_t *>>::pair[abi:ne180100]<TString const&>(uint64_t a1, TString **a2)
{
  *(_QWORD *)a1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  return a1;
}

void sub_1CBCE6364(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100](uint64_t a1, const void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(__p + 3));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(__p + 2);
  }
  if (__p)
    operator delete(__p);
}

_QWORD *std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__emplace_unique_key_args<_opaque_pthread_t *,_opaque_pthread_t *>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE6600(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__erase_unique<_opaque_pthread_t *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t *result;

  result = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(a1, a2);
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  const void **v3;
  void *__p;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (const void **)__p;
  __p = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

uint64_t std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::~__func(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));
  return a1;
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::~__func(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));
  JUMPOUT(0x1D17A53D0);
}

id *std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::__clone(uint64_t a1)
{
  id *v1;
  id *v2;

  v1 = (id *)(a1 + 8);
  v2 = (id *)operator new(0x10uLL);
  *v2 = &off_1E874ECB8;
  objc_copyWeak(v2 + 1, v1);
  return v2;
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_1E874ECB8;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::destroy(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::destroy_deallocate(id *a1)
{
  objc_destroyWeak(a1 + 1);
  operator delete(a1);
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::operator()(uint64_t a1, id *a2)
{
  id *v2;
  id v3;
  FINode *WeakRetained;
  const TNode *v5;
  id *v6;
  id *v7;
  id *v8;
  id **v9;
  char v10;
  TNodePtr v11;
  id v12;
  id v13;

  v13 = (id)*MEMORY[0x1E0C80C00];
  v2 = (id *)(a1 + 8);
  v3 = *a2;
  WeakRetained = (FINode *)objc_loadWeakRetained(v2);
  v5 = (const TNode *)TNodeFromFINode(WeakRetained);
  if (v5)
  {
    TNodePtr::TNodePtr(&v11, v5);
    v12 = v3;
    v7 = 0;
    v8 = 0;
    v6 = 0;
    v9 = &v6;
    v10 = 0;
    v6 = (id *)operator new(0x10uLL);
    v7 = v6;
    v8 = v6 + 2;
    v7 = (id *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v8, (id *)&v11.fFINode, &v13, v6);
    TNode::AttachFPItemsMetadata(&v6, 0, 1);
    v9 = &v6;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v9);

  }
}

void sub_1CBCE6888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, id a14, id a15)
{
  void *v15;
  void *v16;

  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::target_type()
{
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString const&,TCatalogInfo const&,void>@<X0>(char *a1@<X1>, const TString *a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString const&,TCatalogInfo const&,std::allocator<TFSInfo>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1CBCE6988(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString const&,TCatalogInfo const&,std::allocator<TFSInfo>,0>(_QWORD *a1, char *a2, const TString *a3, unsigned __int8 *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, a3, a4);
  return a1;
}

void sub_1CBCE69D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, FPItem **a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  char *v8;
  uint64_t result;

  v8 = (char *)operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1CBCE6A48(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, *a3, *a4);
  return a1;
}

void sub_1CBCE6AA0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,decltype(nullptr),void>@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x50uLL);
  result = std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<decltype(nullptr),std::allocator<TNodeTask>,0>(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1CBCE6AF8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<decltype(nullptr),std::allocator<TNodeTask>,0>(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_1E8750810;
  a1[1] = 0;
  std::construct_at[abi:ne180100]<TNodeTask,decltype(nullptr),TNodeTask*>((uint64_t)(a1 + 3));
  return a1;
}

void sub_1CBCE6B44(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<TNodeTask,decltype(nullptr),TNodeTask*>(uint64_t a1)
{
  TDSNotifier *v3;

  v3 = 0;
  TNodeTask::TNodeTask(a1);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v3);
  return a1;
}

void sub_1CBCE6B94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNode *,TNodePtr,decltype(nullptr),void>@<X0>(const TNode **a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x80uLL);
  result = std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNode *,TNodePtr,decltype(nullptr),std::allocator<TFSInfoSizer>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1CBCE6C04(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNode *,TNodePtr,decltype(nullptr),std::allocator<TFSInfoSizer>,0>(_QWORD *a1, const TNode **a2, uint64_t a3)
{
  a1[2] = 0;
  *a1 = &unk_1E8750570;
  a1[1] = 0;
  std::construct_at[abi:ne180100]<TFSInfoSizer,TNode *,TNodePtr,decltype(nullptr),TFSInfoSizer*>((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1CBCE6C50(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFSInfoSizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750570;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSInfoSizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750570;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<TFSInfoSizer>::__on_zero_shared(uint64_t a1)
{
  std::__destroy_at[abi:ne180100]<TFSInfoSizer,0>((id *)(a1 + 24));
}

uint64_t std::construct_at[abi:ne180100]<TFSInfoSizer,TNode *,TNodePtr,decltype(nullptr),TFSInfoSizer*>(uint64_t a1, const TNode **a2, uint64_t a3)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v9;
  std::__shared_weak_count *v10;
  TNodePtr v11;

  TNodePtr::TNodePtr(&v11, *a2);
  v9 = 0;
  v10 = 0;
  TFSInfoSizer::TFSInfoSizer(a1, &v11, a3, &v9, 0);
  v5 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  return a1;
}

void sub_1CBCE6D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, id a12)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a10);

  _Unwind_Resume(a1);
}

void std::__destroy_at[abi:ne180100]<TFSInfoSizer,0>(id *a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 9));

}

const void **TPropertyReference::As<__CFString const*>(const void **result, void **a2)
{
  int v2;
  const void **v3;

  v2 = *((_DWORD *)result + 2);
  v3 = (const void **)a2;
  switch((char)v2)
  {
    case 0:
      if (v2)
        goto LABEL_43;
      return (const void **)*a2;
    case 1:
      if (v2 != 1)
        goto LABEL_43;
      goto LABEL_41;
    case 2:
      if (v2 != 2)
        goto LABEL_43;
      goto LABEL_41;
    case 3:
      if (v2 != 3)
        goto LABEL_43;
      goto LABEL_41;
    case 4:
      if (v2 != 4)
        goto LABEL_43;
      goto LABEL_41;
    case 5:
      if (v2 != 5)
        goto LABEL_43;
      goto LABEL_41;
    case 6:
      if (v2 != 6)
        goto LABEL_43;
      goto LABEL_41;
    case 7:
      if (v2 != 7)
        goto LABEL_43;
      goto LABEL_41;
    case 8:
      if (v2 != 8)
        goto LABEL_43;
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10)
        goto LABEL_43;
      goto LABEL_41;
    case 11:
      if (v2 != 11)
        goto LABEL_43;
      return (const void **)AsPriv<__CFString const*,TString>((const void **)*result);
    case 12:
      if (v2 != 12)
        goto LABEL_43;
      v3 = (const void **)*result;
      goto LABEL_41;
    case 13:
      if (v2 != 13)
        goto LABEL_43;
      goto LABEL_41;
    case 14:
      if (v2 != 14)
        goto LABEL_43;
      goto LABEL_41;
    case 15:
      if (v2 != 15)
        goto LABEL_43;
      goto LABEL_41;
    case 16:
      if (v2 != 16)
        goto LABEL_43;
      goto LABEL_41;
    case 17:
      if (v2 != 17)
        goto LABEL_43;
      goto LABEL_41;
    case 18:
      if (v2 != 18)
        goto LABEL_43;
      goto LABEL_41;
    case 19:
      if (v2 != 19)
        goto LABEL_43;
      return TPropertyValue::As<__CFString const*>((const void **)*result, a2);
    case 20:
      if (v2 == 20)
        goto LABEL_41;
      goto LABEL_43;
    case 21:
      if (v2 != 21)
        goto LABEL_43;
      goto LABEL_41;
    case 22:
      if (v2 != 22)
        goto LABEL_43;
      goto LABEL_41;
    case 23:
      if (v2 != 23)
LABEL_43:
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_41:
      result = (const void **)*v3;
      break;
    default:
      return result;
  }
  return result;
}

void std::__shared_ptr_emplace<ExternalRegistration>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87506F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ExternalRegistration>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87506F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<ExternalRegistration>::__on_zero_shared(uint64_t a1)
{

}

void std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

__n128 std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E8750188;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E8750188;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::operator()(uint64_t a1, const TNode **a2)
{
  TNode *v3;
  int v4;
  TNode *v5;
  id *v6;
  id *v7;
  FINode *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  os_unfair_lock_s *v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  FINode *v21;
  _QWORD v22[3];
  uint64_t v23;
  void **v24;

  TNodePtr::TNodePtr((TNodePtr *)&v21, *a2);
  if (!*(_BYTE *)(a1 + 8)
    || (v3 = (TNode *)TNodeFromFINode(v21), v4 = atomic_load((unsigned int *)TNode::GetNotifierList(v3)), v4 >= 1))
  {
    std::vector<TNodePtr>::push_back[abi:ne180100](*(_QWORD *)(a1 + 16), (id *)&v21);
  }
  v5 = (TNode *)TNodeFromFINode(v21);
  TNode::CopyChildren(v5, (uint64_t)v22);
  v6 = (id *)v22[0];
  v7 = (id *)v22[1];
  while (v6 != v7)
  {
    v8 = (FINode *)*v6;
    v9 = TNodeFromFINode(v8);
    v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
    os_unfair_lock_lock(v10);
    v12 = *(_QWORD *)(v9 + 16);
    v11 = *(std::__shared_weak_count **)(v9 + 24);
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v10);
    v15 = (os_unfair_lock_s *)(v12 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
    v16 = *(_DWORD *)(v12 + 115);
    os_unfair_lock_unlock(v15);
    if (v11)
    {
      v17 = (unint64_t *)&v11->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if ((v16 & 0x20) != 0)
    {
      v19 = *(_QWORD *)(a1 + 24);
      v23 = TNodeFromFINode(v8);
      v20 = *(_QWORD *)(v19 + 24);
      if (!v20)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v20 + 48))(v20, &v23);
    }

    ++v6;
  }
  v24 = (void **)v22;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v24);

}

void sub_1CBCE7174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::target_type()
{
}

void *std::__hash_table<std::__hash_value_type<TNodePtr,TNodePtr>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,TNodePtr>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr&&>,std::tuple<>>(uint64_t a1, FINode **a2, uint64_t a3, id **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v7 = (unint64_t)*a2 >> 2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v4 = (unint64_t)*a2 >> 2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v7)
        {
          v15 = TNodeFromFINode(*((FINode **)i + 2));
          if (v15 == TNodeFromFINode(*a2))
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v8)
              v14 %= v8;
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v4)
            break;
        }
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v7;
  TNodePtr::TNodePtr((_QWORD *)i + 2, *a4);
  *((_QWORD *)i + 3) = 0;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    v19 = 1;
    if (v8 >= 3)
      v19 = (v8 & (v8 - 1)) != 0;
    v20 = v19 | (2 * v8);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)i = *v24;
LABEL_38:
    *v24 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v16;
  *v16 = i;
  *(_QWORD *)(v23 + 8 * v4) = v16;
  if (*(_QWORD *)i)
  {
    v25 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v25 >= v8)
        v25 %= v8;
    }
    else
    {
      v25 &= v8 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE743C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;
      objc_destroyWeak(v2 + 3);

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  void *v2;
  id v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *(id *)v2;
      objc_destroyWeak((id *)v2 + 3);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::pair<FINode * {__weak},unsigned long>::operator=[abi:ne180100](uint64_t a1, id *location)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained(location);
  objc_storeWeak((id *)a1, WeakRetained);

  *(_QWORD *)(a1 + 8) = location[1];
  return a1;
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = objc_msgSend(*a2, "hash");
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if ((std::equal_to<FPProviderDomain * {__strong}>::operator()(a1 + 32, i[2], *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE7810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *a12, uint64_t a13)
{
  if (a12)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, a12);
  _Unwind_Resume(exception_object);
}

id std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, id **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  id result;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *v8 = 0;
  v8[1] = a2;
  result = **a3;
  v8[3] = 0;
  v8[4] = 0;
  v8[2] = result;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

uint64_t std::equal_to<FPProviderDomain * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;

  v4 = a2;
  v5 = a3;
  if (v4 == v5)
    v6 = 1;
  else
    v6 = objc_msgSend(v4, "isEqual:", v5);

  return v6;
}

void sub_1CBCE78FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    objc_destroyWeak(a2 + 3);

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>(uint64_t a1, CFTypeRef *a2, uint64_t a3, const void ***a4)
{
  CFHashCode v4;
  CFHashCode v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = CFHash(*a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if ((IsEqual(i[2], *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE7BB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

const void **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const void ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  void *v8;
  const void **result;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100]<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>((const void **)v8 + 2, *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCE7C44(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

const void **std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100]<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(const void **a1, const void **a2)
{
  const void *v3;

  v3 = *a2;
  *a1 = *a2;
  if (v3)
    CFRetain(v3);
  a1[1] = 0;
  a1[2] = 0;
  return a1;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    objc_destroyWeak((id *)__p + 3);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)__p + 2);
  }
  if (__p)
    operator delete(__p);
}

uint64_t std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map(uint64_t a1, uint64_t a2)
{
  id *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(id **)(a2 + 16); i; i = (id *)*i)
    std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1CBCE7D3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(uint64_t a1, id *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint64_t ***v12;
  uint64_t **i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[3];

  v7 = objc_msgSend(*a2, "hash");
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = (uint64_t **)*i)
      {
        v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if ((std::equal_to<FPProviderDomain * {__strong}>::operator()(a1 + 32, i[2], *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(a1, v8, a3, (uint64_t)v24);
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9)
          v22 %= v9;
      }
      else
      {
        v22 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  i = (uint64_t **)v24[0];
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE7FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, uint64_t a11)
{
  if (a10)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, a10);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  void *v8;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  *((_QWORD *)v8 + 2) = *(id *)a3;
  objc_copyWeak((id *)v8 + 3, (id *)(a3 + 8));
  *((_QWORD *)v8 + 4) = *(_QWORD *)(a3 + 16);
  *(_BYTE *)(a4 + 16) = 1;
}

_QWORD *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E8750080;
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E8750080;
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  JUMPOUT(0x1D17A53D0);
}

_WORD *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v2;
  _WORD *v3;

  v2 = a1 + 8;
  v3 = operator new(0x38uLL);
  *(_QWORD *)v3 = &off_1E8750080;
  std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)(v3 + 4), v2);
  v3[24] = *(_WORD *)(a1 + 48);
  *((_BYTE *)v3 + 50) = *(_BYTE *)(a1 + 50);
  return v3;
}

void sub_1CBCE8104(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int16 v5;

  *(_QWORD *)a2 = &off_1E8750080;
  result = std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map(a2 + 8, a1 + 8);
  v5 = *(_WORD *)(a1 + 48);
  *(_BYTE *)(a2 + 50) = *(_BYTE *)(a1 + 50);
  *(_WORD *)(a2 + 48) = v5;
  return result;
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(a1 + 8);
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy_deallocate(void *a1)
{
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(_BYTE *a1, id *a2, void **a3, void **a4)
{
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  id v9;
  uint64_t **v10;
  FINode *WeakRetained;
  FINode *v12;
  id v13;
  BOOL v14;
  const TNode *v15;
  id *v16;
  id *v17;
  id *v18;
  id v19;
  id **v20;
  char v21;
  TNodePtr v22;
  id v23;
  id v24;

  v24 = (id)*MEMORY[0x1E0C80C00];
  v5 = (uint64_t)(a1 + 8);
  v6 = *a3;
  v7 = *a4;
  v19 = *a2;
  v8 = v6;
  v9 = v7;
  v16 = &v19;
  v10 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(v5, &v19, (uint64_t)&std::piecewise_construct, &v16);
  WeakRetained = (FINode *)objc_loadWeakRetained((id *)v10 + 3);
  v12 = WeakRetained;
  if (WeakRetained)
  {
    -[FINode fpItem](WeakRetained, "fpItem");
    v13 = (id)objc_claimAutoreleasedReturnValue();
    if (v13 == v8)
    {

    }
    else
    {
      v14 = a1[48] == 0;

      if (!v14)
      {
        v15 = (const TNode *)TNodeFromFINode(v12);
        TNodePtr::TNodePtr(&v22, v15);
        v23 = v8;
        v17 = 0;
        v18 = 0;
        v16 = 0;
        v20 = &v16;
        v21 = 0;
        v16 = (id *)operator new(0x10uLL);
        v17 = v16;
        v18 = v16 + 2;
        v17 = (id *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v18, (id *)&v22.fFINode, &v24, v16);
        TNode::AttachFPItemsMetadata(&v16, a1[49], a1[50]);
        v20 = &v16;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);

      }
    }
  }

}

void sub_1CBCE8324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void **a14, uint64_t a15, id a16, id a17)
{
  void *v17;
  void *v18;
  void *v19;

  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a14);

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target_type()
{
}

uint64_t std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)result = v2;
  *(_QWORD *)(result + 8) = a2[1];
  a2[1] = 0;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  *(_QWORD *)(result + 16) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::NSForwardIterator<NSMutableArray<FPProviderDomain *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCE84F0(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCE856C(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id *fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::operator=(id *a1, id *a2)
{
  objc_storeStrong(a1, *a2);
  objc_storeStrong(a1 + 1, a2[1]);
  return a1;
}

uint64_t std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map(uint64_t a1, uint64_t a2)
{
  CFTypeRef *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(CFTypeRef **)(a2 + 16); i; i = (CFTypeRef *)*i)
    std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1CBCE8618(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  CFHashCode v3;
  CFHashCode v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint64_t ***v12;
  uint64_t **i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[3];

  v7 = CFHash(*a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = (uint64_t **)*i)
      {
        v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if ((IsEqual(i[2], *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>(a1, v8, a3, (uint64_t)v24);
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9)
          v22 %= v9;
      }
      else
      {
        v22 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  i = (uint64_t **)v24[0];
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE8874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100]((uint64_t)(v8 + 2), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCE8904(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  const void *v4;

  v4 = *(const void **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  if (v4)
    CFRetain(v4);
  objc_copyWeak((id *)(a1 + 8), (id *)(a2 + 8));
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  return a1;
}

_QWORD *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E87500D8;
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E87500D8;
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  JUMPOUT(0x1D17A53D0);
}

_WORD *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v2;
  _WORD *v3;

  v2 = a1 + 8;
  v3 = operator new(0x38uLL);
  *(_QWORD *)v3 = &off_1E87500D8;
  std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)(v3 + 4), v2);
  v3[24] = *(_WORD *)(a1 + 48);
  *((_BYTE *)v3 + 50) = *(_BYTE *)(a1 + 50);
  return v3;
}

void sub_1CBCE8A34(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int16 v5;

  *(_QWORD *)a2 = &off_1E87500D8;
  result = std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map(a2 + 8, a1 + 8);
  v5 = *(_WORD *)(a1 + 48);
  *(_BYTE *)(a2 + 50) = *(_BYTE *)(a1 + 50);
  *(_WORD *)(a2 + 48) = v5;
  return result;
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(a1 + 8);
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy_deallocate(void *a1)
{
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::operator()(_BYTE *a1, void ***a2, id *a3, void **a4)
{
  void **v5;
  void *v6;
  id v7;
  id v8;
  id *v9;
  FINode *WeakRetained;
  id v11;
  BOOL v12;
  const TNode *v13;
  void ***v14;
  _QWORD *v15;
  _QWORD *v16;
  void ****v17;
  char v18;
  TNodePtr v19;
  id v20;
  id v21;

  v21 = (id)*MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = *a4;
  v7 = *a3;
  v8 = v6;
  v17 = (void ****)v5;
  if (v5)
    CFRetain(v5);
  v14 = (void ***)&v17;
  v9 = (id *)std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)(a1 + 8), (CFTypeRef *)&v17, (uint64_t)&std::piecewise_construct, &v14);
  WeakRetained = (FINode *)objc_loadWeakRetained(v9 + 3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v17);
  if (WeakRetained)
  {
    -[FINode fpItem](WeakRetained, "fpItem");
    v11 = (id)objc_claimAutoreleasedReturnValue();
    if (v11 == v7)
    {

    }
    else
    {
      v12 = a1[48] == 0;

      if (!v12)
      {
        v13 = (const TNode *)TNodeFromFINode(WeakRetained);
        TNodePtr::TNodePtr(&v19, v13);
        v20 = v7;
        v15 = 0;
        v16 = 0;
        v14 = 0;
        v17 = &v14;
        v18 = 0;
        v14 = (void ***)operator new(0x10uLL);
        v15 = v14;
        v16 = v14 + 2;
        v15 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v16, (id *)&v19.fFINode, &v21, v14);
        TNode::AttachFPItemsMetadata((id **)&v14, a1[49], a1[50]);
        v17 = &v14;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);

      }
    }
  }

}

void sub_1CBCE8C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, id a14, id a15)
{
  void *v15;
  void *v16;
  void *v17;

  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::target_type()
{
}

void *std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>(uint64_t a1, CFTypeRef *a2, uint64_t a3, _QWORD **a4)
{
  CFHashCode v4;
  CFHashCode v8;
  CFHashCode v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  void *i;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;

  v8 = CFHash(*a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = *(void **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((IsEqual(*((const void **)i + 2), *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  i = operator new(0x28uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v9;
  v17 = *a4;
  *((_QWORD *)i + 2) = **a4;
  *v17 = 0;
  *((_QWORD *)i + 3) = 0;
  *((_QWORD *)i + 4) = 0;
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    v20 = 1;
    if (v10 >= 3)
      v20 = (v10 & (v10 - 1)) != 0;
    v21 = v20 | (2 * v10);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v23);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v24 = *(_QWORD *)a1;
  v25 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v25)
  {
    *(_QWORD *)i = *v25;
LABEL_38:
    *v25 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v16;
  *v16 = i;
  *(_QWORD *)(v24 + 8 * v4) = v16;
  if (*(_QWORD *)i)
  {
    v26 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10)
        v26 %= v10;
    }
    else
    {
      v26 &= v10 - 1;
    }
    v25 = (_QWORD *)(*(_QWORD *)a1 + 8 * v26);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCE8F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::NSForwardIterator<NSMutableArray<NSURL *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCE9024(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCE90A0(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E8752940;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E8752940;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x28uLL);
  *v2 = &off_1E8752940;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1CBCE91C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E8752940;
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

_QWORD *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

void std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::operator()(uint64_t a1, uint64_t a2, id *a3, void **a4)
{
  void *v5;
  id v6;
  id v7;

  v5 = *a4;
  v7 = *a3;
  v6 = v5;
  if (*(_QWORD *)(a1 + 32))
    std::function<void ()(FPItem *,NSError *)>::operator()(a1 + 8, v7, v6);

}

void sub_1CBCE92D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::target_type()
{
}

void std::__shared_ptr_emplace<std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874EF58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874EF58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::~__hash_table(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

const void **std::__destroy_at[abi:ne180100]<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,0>(uint64_t a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 40);
  if (*(_BYTE *)(a1 + 32))

  if (*(_BYTE *)(a1 + 16))
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)>,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x38uLL);
  result = std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::__shared_ptr_emplace[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCE9484(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::__shared_ptr_emplace[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0>(_QWORD *a1, uint64_t a2)
{
  a1[2] = 0;
  *a1 = &unk_1E874EF90;
  a1[1] = 0;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1CBCE94D0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874EF90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E874EF90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 24);
  result = *(_QWORD **)(a1 + 48);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>(uint64_t a1, CFTypeRef *a2, uint64_t a3, _QWORD **a4)
{
  CFHashCode v4;
  CFHashCode v8;
  CFHashCode v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[2];
  char v28;

  v8 = CFHash(*a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if ((IsEqual(i[2], *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  v16 = operator new(0x48uLL);
  v27[0] = v16;
  v27[1] = a1 + 16;
  *v16 = 0;
  v16[1] = v9;
  v17 = *a4;
  v16[2] = **a4;
  *v17 = 0;
  *((_BYTE *)v16 + 24) = 0;
  *((_BYTE *)v16 + 32) = 0;
  *((_BYTE *)v16 + 40) = 0;
  *((_BYTE *)v16 + 48) = 0;
  v16[7] = 0;
  v16[8] = 0;
  v28 = 1;
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    v20 = 1;
    if (v10 >= 3)
      v20 = (v10 & (v10 - 1)) != 0;
    v21 = v20 | (2 * v10);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v23);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v25 >= v10)
          v25 %= v10;
      }
      else
      {
        v25 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (uint64_t **)v27[0];
  v27[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1CBCE97DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

_QWORD *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E8750130;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E8750130;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x28uLL);
  *v2 = &off_1E8750130;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1CBCE9940(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E8750130;
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

_QWORD *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

void std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(uint64_t a1, uint64_t a2, id *a3, void **a4)
{
  void *v5;
  id v6;
  id v7;

  v5 = *a4;
  v7 = *a3;
  v6 = v5;
  if (*(_QWORD *)(a1 + 32))
    std::function<void ()(FPItem *,NSError *)>::operator()(a1 + 8, v7, v6);

}

void sub_1CBCE9A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target_type()
{
}

void std::__shared_ptr_emplace<std::unordered_map<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750848;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_map<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750848;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::~__hash_table(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,0>(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,0>(id *a1)
{

}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::find<FPProviderDomain * {__strong}>(_QWORD *a1, id *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **v11;
  uint64_t v12;
  unint64_t v13;

  v4 = objc_msgSend(*a2, "hash");
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = (unint64_t)v11[1];
      if (v6 == v13)
      {
        if ((std::equal_to<FPProviderDomain * {__strong}>::operator()(v12, v11[2], *a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = objc_msgSend(*a2, "hash");
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if ((std::equal_to<FPProviderDomain * {__strong}>::operator()(a1 + 32, i[2], *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1CBCE9F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, id **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::pair[abi:ne180100]<FPProviderDomain * const&>(v8 + 2, *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCE9F88(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

_QWORD *std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::pair[abi:ne180100]<FPProviderDomain * const&>(_QWORD *a1, id *a2)
{
  *a1 = *a2;
  fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::optional_err(a1 + 1);
  return a1;
}

void sub_1CBCE9FD8(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  id *v2;

  v2 = *(id **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,0>(v2 + 2);
    operator delete(v2);
  }
}

void FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>,FPProviderDomain * {__strong}>(__int128 *a1@<X0>, double *a2@<X1>, void **a3@<X2>, std::string *a4@<X8>)
{
  unint64_t v7;
  std::string *p_p;
  std::string::size_type size;
  std::string *v10;
  std::string v11;
  __int128 v12;
  std::string __p;

  memset(&__p, 0, sizeof(__p));
  v12 = *a1;
  do
  {
    v7 = FormatOneDetails<std::chrono::duration<double,std::ratio<1l,1l>>>((const std::string::value_type **)&v12, &__p, a2);
    if ((_DWORD)v7)
    {
      *((_BYTE *)&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v7) == 7);
  FormatDetails<FPProviderDomain * {__strong}>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v10 = std::string::insert(&v11, 0, (const std::string::value_type *)p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1CBCEA110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a15 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<std::chrono::duration<double,std::ratio<1l,1l>>>(const std::string::value_type **a1, std::string *this, double *a3)
{
  const std::string::value_type *v3;
  const std::string::value_type *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t i;
  uint64_t v12;
  unint64_t v13;
  const std::string::value_type *v14;
  BOOL v15;
  const std::string::value_type *v16;
  size_t v17;
  const void *v18;
  void *p_dst;
  std::string *p_p;
  std::string::size_type size;
  const void *v22;
  void *v23;
  std::string *v24;
  std::string::size_type v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  std::string::size_type v31;
  std::string *v32;
  void *v33;
  const void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  std::string *v38;
  std::string::size_type v39;
  const std::string::value_type *v40;
  const std::string::value_type *v41;
  void *v43[2];
  unint64_t v44;
  std::string v45;
  std::string __dst;
  std::string __p;
  const void *v48;
  unint64_t v49;
  unsigned int v50;

  v3 = a1[1];
  if (v3)
  {
    v7 = *a1;
    v8 = (unsigned __int8 *)&v3[(_QWORD)*a1];
    v9 = 1;
    v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1CBD2B109[i])
        {
          v12 = 0;
          v9 = 1;
          if (v10 != v8)
          {
            v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              v14 = a1[1];
              v15 = (unint64_t)v14 >= v13;
              v16 = &v14[-v13];
              if (!v15)
LABEL_93:
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&v48);
              v17 = v49;
              if (v49)
              {
                switch(v50)
                {
                  case 1u:
                  case 2u:
                  case 3u:
                    goto LABEL_90;
                  case 4u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
                      goto LABEL_94;
                    v18 = v48;
                    if (v49 >= 0x17)
                    {
                      v26 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v26 = v49 | 7;
                      v27 = v26 + 1;
                      p_dst = operator new(v26 + 1);
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                      __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    *((_BYTE *)p_dst + v17) = 0;
                    std::string::basic_string[abi:ne180100]<0>(&__p, "??? (hex)");
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
                    goto LABEL_56;
                  case 5u:
                    std::to_string(&__dst, *a3);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
                    goto LABEL_56;
                  case 6u:
                    std::to_string(&__dst, *a3);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
                    goto LABEL_56;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&v48, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v24 = &__p;
                    else
                      v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      v25 = __p.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v24, v25);
                    goto LABEL_87;
                  case 8u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
LABEL_94:
                      std::string::__throw_length_error[abi:ne180100]();
                    v22 = v48;
                    if (v49 >= 0x17)
                    {
                      v29 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v29 = v49 | 7;
                      v30 = v29 + 1;
                      v23 = operator new(v29 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v30 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
                      v23 = &__dst;
                    }
                    memmove(v23, v22, v17);
                    *((_BYTE *)v23 + v17) = 0;
                    ExtractEmbeddedFormat(&__dst, &__p);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    v31 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    v32 = &__p;
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      v31 = __p.__r_.__value_.__l.__size_;
                      v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    v45.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
                    v45.__r_.__value_.__l.__size_ = v31;
                    FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>>((__int128 *)&v45, &__dst);
                    v33 = (void *)v49;
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v34 = v48;
                    if (v49 >= 0x17)
                    {
                      v36 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v36 = v49 | 7;
                      v37 = v36 + 1;
                      v35 = operator new(v36 + 1);
                      v43[1] = v33;
                      v44 = v37 | 0x8000000000000000;
                      v43[0] = v35;
                    }
                    else
                    {
                      HIBYTE(v44) = v49;
                      v35 = v43;
                      if (!v49)
                        goto LABEL_75;
                    }
                    memmove(v35, v34, (size_t)v33);
LABEL_75:
                    *((_BYTE *)v33 + (_QWORD)v35) = 0;
                    ExtendedFormatAdaptor((char *)v43, (uint64_t)&__dst, &v45);
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v38 = &v45;
                    else
                      v38 = (std::string *)v45.__r_.__value_.__r.__words[0];
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v39 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
                    else
                      v39 = v45.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v38, v39);
                    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v45.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v44) < 0)
                      operator delete(v43[0]);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_87:
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    {
                      v28 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_89:
                      operator delete(v28);
                    }
LABEL_90:
                    v40 = a1[1];
                    v41 = &v40[-v49];
                    if ((unint64_t)v40 < v49)
                      goto LABEL_93;
                    v9 = 0;
                    *a1 += v49;
                    a1[1] = v41;
                    v12 = v50;
                    break;
                  default:
                    std::to_string(&__dst, *a3);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
LABEL_56:
                    std::string::append(this, (const std::string::value_type *)p_p, size);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__p.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_90;
                    v28 = (void *)__dst.__r_.__value_.__r.__words[0];
                    goto LABEL_89;
                }
              }
              else
              {
                v12 = 0;
                v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8)
        continue;
      break;
    }
    v12 = 0;
  }
  else
  {
    v12 = 0;
    v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1CBCEA614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

void FormatDetails<FPProviderDomain * {__strong}>(__int128 *a1@<X0>, void **a2@<X1>, std::string *a3@<X8>)
{
  unint64_t v5;
  std::string *v6;
  std::string::size_type size;
  std::string *v8;
  std::string v9;
  __int128 v10;
  std::string v11;

  memset(&v11, 0, sizeof(v11));
  v10 = *a1;
  do
  {
    v5 = FormatOneDetails<FPProviderDomain * {__strong}>((const std::string::value_type **)&v10, &v11, a2);
    if ((_DWORD)v5)
    {
      *((_BYTE *)&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v5) == 7);
  FormatDetails(&v10, &v9);
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v11;
  else
    v6 = (std::string *)v11.__r_.__value_.__r.__words[0];
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v11.__r_.__value_.__r.__words[2]);
  else
    size = v11.__r_.__value_.__l.__size_;
  v8 = std::string::insert(&v9, 0, (const std::string::value_type *)v6, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
LABEL_13:
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
}

void sub_1CBCEA794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v15 - 17) < 0)
    operator delete(*(void **)(v15 - 40));
  _Unwind_Resume(exception_object);
}

void FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>>(__int128 *a1@<X0>, std::string *a2@<X8>)
{
  unint64_t v3;
  std::string *v4;
  std::string::size_type size;
  std::string *v6;
  std::string v7;
  __int128 v8;
  std::string v9;

  memset(&v9, 0, sizeof(v9));
  v8 = *a1;
  do
  {
    v3 = FormatOneDetails<std::chrono::duration<double,std::ratio<1l,1l>>>((int)&v8, &v9);
    if ((_DWORD)v3)
    {
      *((_BYTE *)&a2->__r_.__value_.__s + 23) = 0;
      a2->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v3) == 7);
  FormatDetails(&v8, &v7);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v4 = &v9;
  else
    v4 = (std::string *)v9.__r_.__value_.__r.__words[0];
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  else
    size = v9.__r_.__value_.__l.__size_;
  v6 = std::string::insert(&v7, 0, (const std::string::value_type *)v4, size);
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
LABEL_13:
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
}

void sub_1CBCEA89C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v15 - 17) < 0)
    operator delete(*(void **)(v15 - 40));
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<FPProviderDomain * {__strong}>(const std::string::value_type **a1, std::string *this, void **a3)
{
  const std::string::value_type *v3;
  const std::string::value_type *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t i;
  uint64_t v12;
  unint64_t v13;
  const std::string::value_type *v14;
  BOOL v15;
  const std::string::value_type *v16;
  std::string::size_type v17;
  const void *v18;
  std::string *p_dst;
  std::string *p_p;
  std::string::size_type size;
  const void *v22;
  std::string *v23;
  std::string *v24;
  std::string::size_type v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  std::string::size_type v31;
  std::string *v32;
  void *v33;
  const void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  std::string *v38;
  std::string::size_type v39;
  const std::string::value_type *v40;
  const std::string::value_type *v41;
  void *v43[2];
  unint64_t v44;
  std::string v45;
  std::string __dst;
  std::string __p;
  const void *v48;
  unint64_t v49;
  unsigned int v50;

  v3 = a1[1];
  if (v3)
  {
    v7 = *a1;
    v8 = (unsigned __int8 *)&v3[(_QWORD)*a1];
    v9 = 1;
    v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1CBD2B109[i])
        {
          v12 = 0;
          v9 = 1;
          if (v10 != v8)
          {
            v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              v14 = a1[1];
              v15 = (unint64_t)v14 >= v13;
              v16 = &v14[-v13];
              if (!v15)
LABEL_93:
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&v48);
              v17 = v49;
              if (v49)
              {
                switch(v50)
                {
                  case 1u:
                  case 2u:
                  case 3u:
                    goto LABEL_90;
                  case 4u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
                      goto LABEL_94;
                    v18 = v48;
                    if (v49 >= 0x17)
                    {
                      v26 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v26 = v49 | 7;
                      v27 = v26 + 1;
                      p_dst = (std::string *)operator new(v26 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    p_dst->__r_.__value_.__s.__data_[v17] = 0;
                    HexDescriptionPrinterGlue<FPProviderDomain * {__strong},void>::dump((uint64_t)&__dst, a3, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
                    goto LABEL_56;
                  case 5u:
                    Description<FPProviderDomain * {__strong}>(a3, &__dst);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
                    goto LABEL_56;
                  case 6u:
                    Description<FPProviderDomain * {__strong}>(a3, &__dst);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
                    goto LABEL_56;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&v48, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v24 = &__p;
                    else
                      v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      v25 = __p.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v24, v25);
                    goto LABEL_87;
                  case 8u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
LABEL_94:
                      std::string::__throw_length_error[abi:ne180100]();
                    v22 = v48;
                    if (v49 >= 0x17)
                    {
                      v29 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v29 = v49 | 7;
                      v30 = v29 + 1;
                      v23 = (std::string *)operator new(v29 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v30 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                    }
                    else
                    {
                      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
                      v23 = &__dst;
                    }
                    memmove(v23, v22, v17);
                    v23->__r_.__value_.__s.__data_[v17] = 0;
                    ExtractEmbeddedFormat(&__dst, &__p);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    v31 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    v32 = &__p;
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      v31 = __p.__r_.__value_.__l.__size_;
                      v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    v45.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
                    v45.__r_.__value_.__l.__size_ = v31;
                    FormatDetails<FPProviderDomain * {__strong}>(&__dst, &v45, a3);
                    v33 = (void *)v49;
                    if (v49 > 0x7FFFFFFFFFFFFFF7)
                      std::string::__throw_length_error[abi:ne180100]();
                    v34 = v48;
                    if (v49 >= 0x17)
                    {
                      v36 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17)
                        v36 = v49 | 7;
                      v37 = v36 + 1;
                      v35 = operator new(v36 + 1);
                      v43[1] = v33;
                      v44 = v37 | 0x8000000000000000;
                      v43[0] = v35;
                    }
                    else
                    {
                      HIBYTE(v44) = v49;
                      v35 = v43;
                      if (!v49)
                        goto LABEL_75;
                    }
                    memmove(v35, v34, (size_t)v33);
LABEL_75:
                    *((_BYTE *)v33 + (_QWORD)v35) = 0;
                    ExtendedFormatAdaptor((char *)v43, (uint64_t)&__dst, &v45);
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v38 = &v45;
                    else
                      v38 = (std::string *)v45.__r_.__value_.__r.__words[0];
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v39 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
                    else
                      v39 = v45.__r_.__value_.__l.__size_;
                    std::string::append(this, (const std::string::value_type *)v38, v39);
                    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v45.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v44) < 0)
                      operator delete(v43[0]);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_87:
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    {
                      v28 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_89:
                      operator delete(v28);
                    }
LABEL_90:
                    v40 = a1[1];
                    v41 = &v40[-v49];
                    if ((unint64_t)v40 < v49)
                      goto LABEL_93;
                    v9 = 0;
                    *a1 += v49;
                    a1[1] = v41;
                    v12 = v50;
                    break;
                  default:
                    Description<FPProviderDomain * {__strong}>(a3, &__dst);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      p_p = &__p;
                    else
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    else
                      size = __p.__r_.__value_.__l.__size_;
LABEL_56:
                    std::string::append(this, (const std::string::value_type *)p_p, size);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__p.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      goto LABEL_90;
                    v28 = (void *)__dst.__r_.__value_.__r.__words[0];
                    goto LABEL_89;
                }
              }
              else
              {
                v12 = 0;
                v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8)
        continue;
      break;
    }
    v12 = 0;
  }
  else
  {
    v12 = 0;
    v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1CBCEADA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

_QWORD *HexDescriptionPrinterGlue<FPProviderDomain * {__strong},void>::dump@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  uint64_t v7;
  void *__p[2];
  char v9;
  char __str[16];
  uint64_t v11;
  _QWORD v12[10];
  char v13;
  _QWORD v14[20];

  v14[19] = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a1 + 8);
  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong((char *)a1, (uint64_t)__p);
    if (v9 >= 0)
      snprintf(__str, 0x64uLL, (const char *)__p, *a2);
    else
      snprintf(__str, 0x64uLL, (const char *)__p[0], *a2);
    if (v9 < 0)
      operator delete(__p[0]);
    return std::string::basic_string[abi:ne180100]<0>(a3, __str);
  }
  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__str);
    *(_DWORD *)((char *)v12 + *(_QWORD *)(v11 - 24)) = *(_DWORD *)((_BYTE *)v12 + *(_QWORD *)(v11 - 24)) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, a3);
    *(_QWORD *)__str = *MEMORY[0x1E0DE4F50];
    v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    *(_QWORD *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v11 = v7;
    v12[0] = MEMORY[0x1E0DE4FB8] + 16;
    if (v13 < 0)
      operator delete((void *)v12[8]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return (_QWORD *)MEMORY[0x1D17A5364](v14);
  }
}

void sub_1CBCEAFC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *Description<FPProviderDomain * {__strong}>@<X0>(void **a1@<X0>, _QWORD *a2@<X8>)
{
  void *v3;
  id v4;
  uint64_t v5;
  char *v6;

  v3 = *a1;
  if (v3)
  {
    objc_msgSend(v3, "description");
    v4 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v5 = objc_msgSend(v4, "UTF8String");

    if (v5)
      v6 = (char *)v5;
    else
      v6 = "<nil>";
  }
  else
  {
    v6 = "0x0";
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v6);
}

void sub_1CBCEB044(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::tuple<FPProviderDomain * {__strong}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87508B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::tuple<FPProviderDomain * {__strong}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87508B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<std::tuple<FPProviderDomain * {__strong}>>::__on_zero_shared(uint64_t a1)
{

}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},decltype(nullptr),BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, uint64_t a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  char *v8;
  uint64_t result;

  v8 = (char *)operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},decltype(nullptr),BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1CBCEB104(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},decltype(nullptr),BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, uint64_t a3, unsigned __int8 *a4)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87507A0;
  *(_QWORD *)(a1 + 8) = 0;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, 0, *a4);
  return a1;
}

void sub_1CBCEB15C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<TNodePtr>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87508F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<TNodePtr>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87508F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,void>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x80uLL);
  result = std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,std::allocator<TFSInfoSizer>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1CBCEB214(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,std::allocator<TFSInfoSizer>,0>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[2] = 0;
  *a1 = &unk_1E8750570;
  a1[1] = 0;
  TFSInfoSizer::TFSInfoSizer(a1 + 3, a2, a3, a4, 0);
  return a1;
}

void sub_1CBCEB264(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2 >> 2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2 >> 2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__emplace_unique_key_args<__SFNode *,std::piecewise_construct_t const&,std::tuple<__SFNode * const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD **a4)
{
  uint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v7 = *a2 >> 2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2 >> 2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4)
            break;
        }
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *v13;
  *v13 = i;
  *(_QWORD *)(v20 + 8 * v4) = v13;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1CBCEB560(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<__SFNode *,TNodePtr>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<__SFNode *,TNodePtr>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  id *v3;
  void *__p;
  char v6;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6)

    operator delete(v3);
  }
  return v2;
}

uint64_t std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void TChildrenList::SubscribeWithKQueue(TChildrenList *this)
{
  const TNode *v1;
  TPropertyValue v2;

  v1 = (const TNode *)*((_QWORD *)this + 12);
  memset(&v2, 0, sizeof(v2));
  TNode::RequestInternalTask(v1, 1008, &v2, 0);
  TPropertyValue::~TPropertyValue(&v2);
}

void sub_1CBCEB6CC(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a10);
  _Unwind_Resume(a1);
}

void TChildrenList::UnsubscribeWithKQueue(TChildrenList *this)
{
  const TNode *v1;
  TPropertyValue v2;

  v1 = (const TNode *)*((_QWORD *)this + 12);
  memset(&v2, 0, sizeof(v2));
  TNode::RequestInternalTask(v1, 1009, &v2, 0);
  TPropertyValue::~TPropertyValue(&v2);
}

void sub_1CBCEB724(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a10);
  _Unwind_Resume(a1);
}

uint64_t TChildrenList::GetLastSyncDuration(TChildrenList *this)
{
  return *((_QWORD *)this + 14);
}

uint64_t TChildrenList::GetLastResizeDuration(TChildrenList *this)
{
  return *((_QWORD *)this + 17);
}

TChildrenList *TChildrenList::SetLastResizeDuration(TChildrenList *this, uint64_t a2)
{
  *((_QWORD *)this + 17) = a2;
  return this;
}

uint64_t TChildrenList::GetSubscriptionFileDescriptor(TChildrenList *this)
{
  return *((unsigned int *)this + 44);
}

TChildrenList *TChildrenList::SetSubscriptionFileDescriptor(TChildrenList *this, int a2)
{
  *((_DWORD *)this + 44) = a2;
  return this;
}

uint64_t TChildrenList::IncrementSubscriptionCount(TChildrenList *this)
{
  unsigned int *v1;
  uint64_t result;

  v1 = (unsigned int *)((char *)this + 188);
  do
    result = __ldaxr(v1);
  while (__stlxr(result + 1, v1));
  return result;
}

uint64_t TChildrenList::DecrementSubscriptionCount(TChildrenList *this)
{
  unsigned int *v1;
  uint64_t result;

  v1 = (unsigned int *)((char *)this + 188);
  do
    result = __ldaxr(v1);
  while (__stlxr(result - 1, v1));
  return result;
}

TChildrenList *TChildrenList::DecrementRegisteredChildrenCount(TChildrenList *this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)((char *)this + 192);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  return this;
}

uint64_t TChildrenList::LastSyncStartTime(TChildrenList *this)
{
  return *((_QWORD *)this + 15);
}

uint64_t TChildrenList::LastResizeTime(TChildrenList *this)
{
  return *((_QWORD *)this + 16);
}

TChildrenList *TChildrenList::SetLastResizeTime(TChildrenList *this, uint64_t a2)
{
  *((_QWORD *)this + 16) = a2;
  return this;
}

id TChildrenList::NSProgressSubscriber(TChildrenList *this)
{
  id v2;

  TDSMutex::lock((TDSMutex *)this);
  v2 = *((id *)this + 21);
  TDSMutex::unlock((TDSMutex *)this);
  return v2;
}

unint64_t TChildrenList::ChildrenCount(TChildrenList *this)
{
  return atomic_load((unint64_t *)this + 20);
}

void TChildrenList::Clear(TChildrenList *this)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  TChildrenList::DetachChildren(this);
  v2 = *((_QWORD *)this + 8);
  for (i = *((_QWORD *)this + 9); i != v2; i -= 8)
  {
    v4 = *(void **)(i - 8);

  }
  *((_QWORD *)this + 9) = v2;
  *((_QWORD *)this + 19) = 0;
}

TChildrenList *TChildrenList::InvalidateSortOrder(TChildrenList *this)
{
  *((_QWORD *)this + 19) = 0;
  return this;
}

id *std::vector<TNodePtr>::insert(uint64_t a1, id *a2, id *a3)
{
  id *v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  id *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  id *v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  id *v24;
  id *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  id *v30;
  char *v31;
  char *v32;
  char *v34;
  char *v35;
  id *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  _QWORD v40[5];

  v4 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if (v6 >= v7)
  {
    v9 = *(id **)a1;
    v10 = ((uint64_t)(v6 - *(_QWORD *)a1) >> 3) + 1;
    if (v10 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = (char *)a2 - (char *)v9;
    v12 = a2 - v9;
    v13 = v7 - (_QWORD)v9;
    if (v13 >> 2 > v10)
      v10 = v13 >> 2;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v10;
    v39 = a1 + 16;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(a1 + 16, v14);
    else
      v15 = 0;
    v16 = (id *)&v15[8 * v12];
    v35 = v15;
    v36 = v16;
    v37 = (char *)v16;
    v38 = &v15[8 * v14];
    if (v12 == v14)
    {
      if (v11 < 1)
      {
        if (v9 == v4)
          v18 = 1;
        else
          v18 = v11 >> 2;
        v40[4] = v8;
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v8, v18);
        v21 = v19;
        v22 = &v19[8 * (v18 >> 2)];
        v23 = &v19[8 * v20];
        v24 = v36;
        v25 = v36;
        v26 = v22;
        v27 = v37 - (char *)v36;
        if (v37 != (char *)v36)
        {
          v34 = &v19[8 * v20];
          v26 = &v22[v27 & 0xFFFFFFFFFFFFFFF8];
          v28 = 8 * (v27 >> 3);
          v29 = &v19[8 * (v18 >> 2)];
          v30 = v36;
          do
          {
            v29 = (char *)(TNodePtr::TNodePtr(v29, v30++) + 1);
            v28 -= 8;
          }
          while (v28);
          v25 = (id *)v37;
          v23 = v34;
        }
        v31 = v35;
        v32 = v38;
        v35 = v21;
        v36 = (id *)v22;
        v40[0] = v31;
        v40[1] = v24;
        v37 = v26;
        v38 = v23;
        v40[2] = v25;
        v40[3] = v32;
        std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v40);
        v16 = (id *)v26;
      }
      else
      {
        v17 = v12 + 2;
        if (v12 >= -1)
          v17 = v12 + 1;
        v16 -= v17 >> 1;
        v36 = v16;
        v37 = (char *)v16;
      }
    }
    *v16 = *a3;
    v37 += 8;
    v4 = std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, &v35, v4);
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v35);
  }
  else if (a2 == (id *)v6)
  {
    *a2 = *a3;
    *(_QWORD *)(a1 + 8) = v4 + 1;
  }
  else
  {
    std::vector<TNodePtr>::__move_range(a1, (uint64_t)a2, v6, (uint64_t)(a2 + 1));
    if (v4 <= a3)
      a3 += *(_QWORD *)(a1 + 8) > (unint64_t)a3;
    objc_storeStrong(v4, *a3);
  }
  return v4;
}

void sub_1CBCEBA84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TChildrenList::FindByFPItem(TChildrenList *this@<X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  FPItem *v5;
  FPItem *v6;
  FINode **v7;
  FINode **v8;
  FPItem *v9;
  TNode *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  int v16;
  NSObject *v17;
  char v19;
  FPItem *v20;
  TNodePtr *v21;
  FPItem *v22;
  FINode *v23;
  char v24;
  uint8_t buf[4];
  FPItem *v26;
  __int16 v27;
  void *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v22 = v5;
  if (v5)
  {
    v21 = a3;
    v20 = v5;
    v6 = v20;
    v8 = (FINode **)*((_QWORD *)this + 8);
    v7 = (FINode **)*((_QWORD *)this + 9);
    v9 = v6;
    if (v8 != v7)
    {
      while (1)
      {
        v10 = (TNode *)TNodeFromFINode(*v8);
        TNode::GetFPItem(v10);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        if ((objc_msgSend(v11, "isEqualToItem:", v9) & 1) != 0)
          break;
        -[FPItem formerIdentifier](v9, "formerIdentifier");
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v11, "itemIdentifier");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        if ((objc_msgSend(v12, "isEqualToString:", v13) & 1) != 0)
        {
          -[FPItem providerDomainID](v9, "providerDomainID");
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v11, "providerDomainID");
          v15 = (void *)objc_claimAutoreleasedReturnValue();
          v16 = objc_msgSend(v14, "isEqualToString:", v15);

          if (v16)
          {
            LogObj(4);
            v17 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138543618;
              v26 = v20;
              v27 = 2114;
              v28 = v11;
              _os_log_impl(&dword_1CBC4A000, v17, OS_LOG_TYPE_DEBUG, "Found new item matching to stitched childItem\n%{public}@\n%{public}@", buf, 0x16u);
            }

            break;
          }
        }
        else
        {

        }
        if (++v8 == v7)
        {
          v8 = v7;
          goto LABEL_15;
        }
      }

    }
LABEL_15:

    if (v8 == *((FINode ***)this + 9))
    {
      v19 = 0;
      LOBYTE(v23) = 0;
    }
    else
    {
      v23 = *v8;
      v19 = 1;
    }
    v24 = v19;

    std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>((uint64_t)&v23, v21);
    if (v24)

  }
  else
  {
    TNodePtr::TNodePtr(a3, 0);
  }

}

void sub_1CBCEBCD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void TChildrenList::FindByFileIdentifier(TChildrenList *this@<X0>, uint64_t a2@<X1>, TNodePtr *a3@<X8>)
{
  FINode **v4;
  FINode **v5;
  uint64_t v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  TFSInfo *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t ObjectIdentifier;
  unint64_t *v15;
  unint64_t v16;
  char v17;
  FINode *v18;
  char v19;

  v4 = (FINode **)*((_QWORD *)this + 8);
  v5 = (FINode **)*((_QWORD *)this + 9);
  if (v4 == v5)
    goto LABEL_15;
  while (1)
  {
    v8 = TNodeFromFINode(*v4);
    v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    v11 = *(TFSInfo **)(v8 + 16);
    v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v9);
    ObjectIdentifier = TFSInfo::GetObjectIdentifier(v11);
    if (v10)
    {
      v15 = (unint64_t *)&v10->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if (ObjectIdentifier == a2)
      break;
    if (++v4 == v5)
    {
      v4 = v5;
      break;
    }
  }
  if (v4 == *((FINode ***)this + 9))
  {
LABEL_15:
    v17 = 0;
    LOBYTE(v18) = 0;
  }
  else
  {
    v18 = *v4;
    v17 = 1;
  }
  v19 = v17;
  std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>((uint64_t)&v18, a3);
  if (v19)

}

void sub_1CBCEBE98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, char a12)
{
  if (a12)

  _Unwind_Resume(exception_object);
}

void TChildrenList::FindDisplayName(TChildrenList *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  FINode **v6;
  FINode **v7;
  TNode *v8;
  _BOOL4 v9;
  char v10;
  TNodePtr v11;
  _BYTE v12[24];

  TNodePtr::TNodePtr(&v11, *((const TNode **)this + 12));
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v12, &v11, 0);

  v7 = (FINode **)*((_QWORD *)this + 8);
  v6 = (FINode **)*((_QWORD *)this + 9);
  if (v7 == v6)
    goto LABEL_8;
  do
  {
    v8 = (TNode *)TNodeFromFINode(*v7);
    v9 = TNode::EqualDisplayName(v8, a2);
    v7 += !v9;
    v10 = v7 == v6 || v9;
  }
  while ((v10 & 1) == 0);
  if (v7 == v6)
LABEL_8:
    TNodePtr::TNodePtr(a3, 0);
  else
    a3->fFINode = *v7;
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v12);
}

void sub_1CBCEBFA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)va);
  _Unwind_Resume(a1);
}

void TChildrenList::ClearSizesFetchedForUnobservedNodes(TChildrenList *this)
{
  FINode **i;
  TNode *v3;
  uint64_t v5;
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  uint64_t v17;
  int v18;
  __int16 v19;
  TNodePtr v20;
  _BYTE v21[24];

  TNodePtr::TNodePtr(&v20, *((const TNode **)this + 12));
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v21, &v20, 0);

  for (i = (FINode **)*((_QWORD *)this + 8); i != *((FINode ***)this + 9); ++i)
  {
    v3 = (TNode *)TNodeFromFINode(*i);
    if (!atomic_load((unsigned int *)(TNode::GetNotifierList(v3) + 4)))
    {
      v5 = TNodeFromFINode(*i);
      v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v5);
      os_unfair_lock_lock(v6);
      v8 = *(_QWORD *)(v5 + 16);
      v7 = *(std::__shared_weak_count **)(v5 + 24);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v10 = __ldxr(p_shared_owners);
        while (__stxr(v10 + 1, p_shared_owners));
        os_unfair_lock_unlock(v6);
        v11 = (os_unfair_lock_s *)(v8 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
        v13 = *(_DWORD *)(v8 + 115);
        v12 = v8 + 115;
        v14 = *(_WORD *)(v12 + 4);
        *(_DWORD *)v12 = v13 & 0xF7FFFFFF;
        *(_WORD *)(v12 + 4) = v14;
        os_unfair_lock_unlock(v11);
        do
          v15 = __ldaxr(p_shared_owners);
        while (__stlxr(v15 - 1, p_shared_owners));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      else
      {
        os_unfair_lock_unlock(v6);
        v16 = (os_unfair_lock_s *)(v8 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
        v18 = *(_DWORD *)(v8 + 115);
        v17 = v8 + 115;
        v19 = *(_WORD *)(v17 + 4);
        *(_DWORD *)v17 = v18 & 0xF7FFFFFF;
        *(_WORD *)(v17 + 4) = v19;
        os_unfair_lock_unlock(v16);
      }
    }
  }
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v21);
}

void sub_1CBCEC130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

BOOL TChildrenList::StopCollectionStatusObserver(TChildrenList *this)
{
  os_unfair_lock_s *v2;
  _BOOL8 v3;

  v2 = (os_unfair_lock_s *)TChildrenList::InternalLock(this);
  os_unfair_lock_lock(v2);
  objc_msgSend(*((id *)this + 13), "stopObserving");
  v3 = *((_QWORD *)this + 13) != 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1CBCEC1A0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TChildrenList::ClearCollectionStatusObserver(TChildrenList *this)
{
  os_unfair_lock_s *v2;
  void *v3;

  v2 = (os_unfair_lock_s *)TChildrenList::InternalLock(this);
  os_unfair_lock_lock(v2);
  objc_msgSend(*((id *)this + 13), "stopObserving");
  v3 = (void *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;

  os_unfair_lock_unlock(v2);
}

void sub_1CBCEC1F4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id *std::vector<TNodePtr>::__insert_with_size[abi:ne180100]<std::__wrap_iter<TNodePtr*>,std::__wrap_iter<TNodePtr*>>(uint64_t a1, id *a2, void **a3, void **a4, uint64_t a5)
{
  id *v5;
  void **v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  id *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  void **v22;
  uint64_t v23;
  _QWORD *v24;
  void *v25;
  void **v26;
  char *v27;
  uint64_t v28;
  char *v29;
  void *v30;
  void **v32;
  _QWORD v33[5];

  v5 = a2;
  if (a5 < 1)
    return v5;
  v7 = a3;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    v13 = *(id **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 3);
    if (v14 >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v15 = a2 - v13;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 2 > v14)
      v14 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v33[4] = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v9, v17);
    else
      v18 = 0;
    v27 = &v18[8 * v15];
    v33[0] = v18;
    v33[1] = v27;
    v33[3] = &v18[8 * v17];
    v28 = 8 * a5;
    v29 = &v27[8 * a5];
    do
    {
      v30 = *v7++;
      *(_QWORD *)v27 = v30;
      v27 += 8;
      v28 -= 8;
    }
    while (v28);
    v33[2] = v29;
    v5 = std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, v33, v5);
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v33);
    return v5;
  }
  v19 = v12 - (_QWORD)a2;
  v20 = (uint64_t)(v12 - (_QWORD)a2) >> 3;
  if (v20 >= a5)
  {
    v26 = &a3[a5];
LABEL_18:
    std::vector<TNodePtr>::__move_range(a1, (uint64_t)v5, v12, (uint64_t)&v5[a5]);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>((int)v33, v7, v26, v5);
    return v5;
  }
  v22 = &a3[v20];
  v32 = v22;
  v23 = *(_QWORD *)(v9 - 8);
  if (v22 != a4)
  {
    v24 = *(_QWORD **)(v9 - 8);
    do
    {
      v25 = *v22++;
      *v24++ = v25;
      v23 += 8;
    }
    while (v22 != a4);
  }
  *(_QWORD *)(a1 + 8) = v23;
  v26 = v32;
  if (v19 >= 1)
    goto LABEL_18;
  return v5;
}

void sub_1CBCEC3A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void **std::vector<TNodePtr>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  id *v9;
  void **result;
  _QWORD *v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;

  v7 = *(_QWORD *)(a1 + 8);
  v8 = v7 - a4;
  v9 = (id *)(a2 + v7 - a4);
  if ((unint64_t)v9 >= a3)
  {
    result = *(void ***)(a1 + 8);
  }
  else
  {
    result = *(void ***)(a1 + 8);
    do
    {
      v12 = TNodePtr::TNodePtr(result, v9++);
      result = (void **)(v12 + 1);
    }
    while ((unint64_t)v9 < a3);
  }
  *(_QWORD *)(a1 + 8) = result;
  if (v7 != a4)
  {
    v13 = (void **)(v7 - 8);
    v14 = 8 * (v8 >> 3);
    v15 = a2 - 8;
    do
    {
      result = TNodePtr::operator=(v13--, (void **)(v15 + v14));
      v14 -= 8;
    }
    while (v14);
  }
  return result;
}

id *std::vector<TNodePtr>::__swap_out_circular_buffer(id **a1, _QWORD *a2, id *a3)
{
  id *v3;
  id *v6;
  id *v7;
  id *v8;
  id *v9;
  id *v10;
  _QWORD *v11;
  id *v12;
  id *v13;
  id *v14;

  v3 = a3;
  v6 = (id *)a2[1];
  v7 = *a1;
  v8 = v6;
  if (v7 != a3)
  {
    v8 = (id *)a2[1];
    v9 = a3;
    do
      v8 = (id *)TNodePtr::TNodePtr(v8 - 1, --v9);
    while (v9 != v7);
  }
  a2[1] = v8;
  v10 = a1[1];
  v11 = (_QWORD *)a2[2];
  if (v10 != v3)
  {
    do
      TNodePtr::TNodePtr(v11++, v3++);
    while (v3 != v10);
    v8 = (id *)a2[1];
  }
  a2[2] = v11;
  v12 = *a1;
  *a1 = v8;
  a2[1] = v12;
  v13 = a1[1];
  a1[1] = (id *)a2[2];
  a2[2] = v13;
  v14 = a1[2];
  a1[2] = (id *)a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

BOOL TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(FINode **a1, FINode **a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  TFSInfo *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _BOOL8 v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  TFSInfo *v22;
  std::__shared_weak_count *v23;
  TFSInfo *v24;
  std::__shared_weak_count *v25;

  v3 = TNodeFromFINode(*a1);
  v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  v6 = *(TFSInfo **)(v3 + 16);
  v5 = *(std::__shared_weak_count **)(v3 + 24);
  v24 = v6;
  v25 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v4);
  v9 = TNodeFromFINode(*a2);
  v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
  os_unfair_lock_lock(v10);
  v11 = *(std::__shared_weak_count **)(v9 + 24);
  v22 = *(TFSInfo **)(v9 + 16);
  v23 = v11;
  if (v11)
  {
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v10);
  v14 = TFSInfo::LessThan(v6, &v22);
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v25;
  if (v25)
  {
    v19 = (unint64_t *)&v25->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return v14;
}

void sub_1CBCEC66C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,false>(id *a1, void **a2, uint64_t a3, char a4)
{
  void **v6;
  id *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  void **v14;
  void **v15;
  uint64_t v16;
  void **v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  _BOOL4 v22;
  FINode **v23;
  BOOL v25;
  uint64_t v26;
  id *v27;
  FINode **v28;
  uint64_t v29;
  BOOL v30;
  void **v31;
  int64_t v32;
  int64_t v33;
  int64_t v34;
  uint64_t v35;
  id *v36;
  void **v37;
  void **v38;
  uint64_t v39;
  uint64_t v40;
  void **v41;
  uint64_t v42;
  void **v43;
  void **v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  void **v49;
  void **v50;
  id *v52;
  void **v53;
  void **v54;
  id *v55;
  void *v56;
  void **v57;
  id *v58;

  v6 = a2;
  v7 = a1;
  v54 = a2;
  v55 = a1;
  while (2)
  {
    v8 = (char *)v6 - (char *)v7;
    v9 = v6 - v7;
    switch(v9)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v54 = v6 - 1;
        if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v6 - 1, (FINode **)v7))
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v55, &v54);
        return;
      case 3uLL:
        v54 = v6 - 1;
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v7, v7 + 1, v6 - 1);
        return;
      case 4uLL:
        v54 = v6 - 1;
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v7, v7 + 1, v7 + 2, v6 - 1);
        return;
      case 5uLL:
        v54 = v6 - 1;
        std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,0>(v7, v7 + 1, v7 + 2, v7 + 3, v6 - 1);
        return;
      default:
        if (v8 <= 191)
        {
          v23 = (FINode **)(v7 + 1);
          v25 = v7 == v6 || v23 == (FINode **)v6;
          if ((a4 & 1) != 0)
          {
            if (!v25)
            {
              v26 = 0;
              v27 = v7;
              do
              {
                v28 = (FINode **)v27;
                v27 = (id *)v23;
                if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v23, v28))
                {
                  TNodePtr::TNodePtr(&v58, v27);
                  v29 = v26;
                  while (1)
                  {
                    TNodePtr::operator=((id *)((char *)v7 + v29 + 8), (id *)((char *)v7 + v29));
                    if (!v29)
                      break;
                    v30 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)((char *)v7 + v29 - 8));
                    v29 -= 8;
                    if (!v30)
                    {
                      v31 = (id *)((char *)v7 + v29 + 8);
                      goto LABEL_72;
                    }
                  }
                  v31 = v7;
LABEL_72:
                  TNodePtr::operator=(v31, (void **)&v58);

                }
                v23 = (FINode **)(v27 + 1);
                v26 += 8;
              }
              while (v27 + 1 != v6);
            }
          }
          else if (!v25)
          {
            do
            {
              v52 = (id *)v23;
              if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v23, (FINode **)v7))
              {
                TNodePtr::TNodePtr(&v58, v52);
                do
                {
                  TNodePtr::operator=(v7 + 1, v7);
                  --v7;
                }
                while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v7));
                TNodePtr::operator=(v7 + 1, (void **)&v58);

              }
              v23 = (FINode **)(v52 + 1);
              v7 = v52;
            }
            while (v52 + 1 != v6);
          }
          return;
        }
        if (!a3)
        {
          if (v7 != v6)
          {
            v53 = v6;
            v32 = (v9 - 2) >> 1;
            v33 = v32;
            do
            {
              v34 = v33;
              if (v32 >= v33)
              {
                v35 = (2 * v33) | 1;
                v36 = &v7[v35];
                if (2 * v33 + 2 < (uint64_t)v9
                  && TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v7[v35], (FINode **)v36 + 1))
                {
                  ++v36;
                  v35 = 2 * v34 + 2;
                }
                v37 = &v7[v34];
                if (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v36, (FINode **)v37))
                {
                  TNodePtr::TNodePtr(&v58, &v7[v34]);
                  do
                  {
                    v38 = v36;
                    TNodePtr::operator=(v37, v36);
                    if (v32 < v35)
                      break;
                    v39 = (2 * v35) | 1;
                    v36 = &v7[v39];
                    v35 = 2 * v35 + 2;
                    if (v35 >= (uint64_t)v9)
                    {
                      v35 = v39;
                    }
                    else if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v7[v39], (FINode **)v36 + 1))
                    {
                      ++v36;
                    }
                    else
                    {
                      v35 = v39;
                    }
                    v37 = v38;
                  }
                  while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v36, (FINode **)&v58));
                  TNodePtr::operator=(v38, (void **)&v58);

                }
              }
              v33 = v34 - 1;
            }
            while (v34);
            v40 = (unint64_t)v8 >> 3;
            v41 = v53;
            do
            {
              TNodePtr::TNodePtr(&v57, v7);
              v42 = 0;
              v43 = v7;
              do
              {
                v44 = &v43[v42 + 1];
                v45 = (2 * v42) | 1;
                v46 = 2 * v42 + 2;
                if (v46 < v40
                  && TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v43[v42 + 1], (FINode **)&v43[v42 + 2]))
                {
                  ++v44;
                  v45 = v46;
                }
                TNodePtr::operator=(v43, v44);
                v43 = v44;
                v42 = v45;
              }
              while (v45 <= (uint64_t)((unint64_t)(v40 - 2) >> 1));
              if (v44 == --v41)
              {
                TNodePtr::operator=(v44, (void **)&v57);
              }
              else
              {
                TNodePtr::operator=(v44, v41);
                TNodePtr::operator=(v41, (void **)&v57);
                v47 = (char *)v44 - (char *)v7 + 8;
                if (v47 >= 9)
                {
                  v48 = (((unint64_t)v47 >> 3) - 2) >> 1;
                  v49 = &v7[v48];
                  if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v49, (FINode **)v44))
                  {
                    TNodePtr::TNodePtr(&v58, v44);
                    do
                    {
                      v50 = v49;
                      TNodePtr::operator=(v44, v49);
                      if (!v48)
                        break;
                      v48 = (v48 - 1) >> 1;
                      v49 = &v7[v48];
                      v44 = v50;
                    }
                    while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v49, (FINode **)&v58));
                    TNodePtr::operator=(v50, (void **)&v58);

                  }
                }
              }

            }
            while (v40-- > 2);
          }
          return;
        }
        v10 = v9 >> 1;
        v11 = v6 - 1;
        if ((unint64_t)v8 < 0x401)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(&v7[v9 >> 1], v7, v11);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v7, &v7[v9 >> 1], v11);
          v12 = 8 * v10 - 8;
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v55 + 1, (id *)((char *)v55 + v12), v54 - 2);
          v13 = 8 * v10 + 8;
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v55 + 2, (id *)((char *)v55 + v13), v54 - 3);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>((id *)((char *)v55 + v12), &v55[v10], (id *)((char *)v55 + v13));
          v58 = &v55[v10];
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v55, &v58);
        }
        --a3;
        if ((a4 & 1) != 0)
        {
          v14 = v54;
        }
        else
        {
          v14 = v54;
          if (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v55 - 1, (FINode **)v55))
          {
            v19 = v55;
            v57 = v54;
            v58 = v55;
            TNodePtr::TNodePtr(&v56, v55);
            if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v56, (FINode **)v54 - 1))
            {
              v20 = v19;
              do
                v58 = ++v20;
              while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v56, (FINode **)v20));
            }
            else
            {
              v21 = v19 + 1;
              do
              {
                v20 = v21;
                v58 = v21;
                if (v21 >= v54)
                  break;
                v22 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v56, (FINode **)v21);
                v21 = v20 + 1;
              }
              while (!v22);
            }
            if (v20 < v54)
            {
              do
                v57 = --v14;
              while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v56, (FINode **)v14));
            }
            if (v20 < v14)
            {
              do
              {
                std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v58, &v57);
                do
                  ++v58;
                while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v56, (FINode **)v58));
                do
                  --v57;
                while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v56, (FINode **)v57));
                v20 = v58;
              }
              while (v58 < v57);
            }
            if (v20 - 1 != v19)
              TNodePtr::operator=(v19, v20 - 1);
            TNodePtr::operator=(v20 - 1, &v56);
            v7 = v58;

            goto LABEL_48;
          }
        }
        v15 = v55;
        v57 = v14;
        TNodePtr::TNodePtr(&v56, v55);
        v16 = 0;
        do
          v58 = &v15[++v16];
        while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v58, (FINode **)&v56));
        v17 = &v15[v16];
        if (v16 == 1)
        {
          do
          {
            if (v17 >= v14)
              break;
            v57 = --v14;
          }
          while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v14, (FINode **)&v56));
        }
        else
        {
          do
            v57 = --v14;
          while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v14, (FINode **)&v56));
        }
        v7 = &v15[v16];
        if (v17 < v14)
        {
          do
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v58, &v57);
            do
              ++v58;
            while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v58, (FINode **)&v56));
            do
              --v57;
            while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v57, (FINode **)&v56));
            v7 = v58;
          }
          while (v58 < v57);
        }
        if (v7 - 1 != v15)
          TNodePtr::operator=(v15, v7 - 1);
        TNodePtr::operator=(v7 - 1, &v56);

        if (v17 < v14)
          goto LABEL_34;
        v18 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v55, v7 - 1);
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v7, v54))
        {
          if (v18)
          {
LABEL_49:
            v55 = v7;
            goto LABEL_50;
          }
LABEL_34:
          std::__introsort<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,false>(v55, v7 - 1, a3, a4 & 1);
LABEL_48:
          a4 = 0;
          goto LABEL_49;
        }
        if ((v18 & 1) == 0)
        {
          v54 = v7 - 1;
          v7 = v55;
LABEL_50:
          v6 = v54;
          continue;
        }
        return;
    }
  }
}

void sub_1CBCECE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(id **a1, void ***a2)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = *a1;
  v3 = *a2;
  TNodePtr::TNodePtr(&v4, *a1);
  TNodePtr::operator=(v2, v3);
  TNodePtr::operator=(v3, &v4);

}

void std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,0>(id *a1, void **a2, void **a3, void **a4, void **a5)
{
  void **v10;
  FINode **v11;
  FINode **v12;
  FINode **v13;
  id *v14;

  v13 = (FINode **)a2;
  v14 = a1;
  v11 = (FINode **)a4;
  v12 = (FINode **)a3;
  v10 = a5;
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a2, a3, a4);
  if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a5, (FINode **)a4))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v11, &v10);
    if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v11, (FINode **)a3))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v12, (void ***)&v11);
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v12, (FINode **)a2))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v13, (void ***)&v12);
        if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v13, (FINode **)a1))
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v14, (void ***)&v13);
      }
    }
  }
}

void std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(id *a1, void **a2, void **a3)
{
  BOOL v5;
  _BOOL4 v6;
  id **v7;
  FINode ***v8;
  FINode **v9;
  FINode **v10;
  id *v11;

  v10 = (FINode **)a2;
  v11 = a1;
  v9 = (FINode **)a3;
  v5 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a2, (FINode **)a1);
  v6 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a3, (FINode **)a2);
  if (v5)
  {
    if (v6)
    {
      v7 = &v11;
    }
    else
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v11, (void ***)&v10);
      if (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v9, v10))
        return;
      v7 = (id **)&v10;
    }
    v8 = &v9;
    goto LABEL_10;
  }
  if (v6)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v10, (void ***)&v9);
    if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v10, (FINode **)v11))
    {
      v7 = &v11;
      v8 = &v10;
LABEL_10:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(v7, (void ***)v8);
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(id *a1, void **a2)
{
  void **v2;
  _BOOL8 v4;
  id *v5;
  FINode **v6;
  int v7;
  void **v8;
  void *v10;
  void **v11;
  id *v12;

  v2 = a2;
  v11 = a2;
  v12 = a1;
  v4 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      v11 = a2 - 1;
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a2 - 1, (FINode **)a1))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v12, &v11);
      return v4;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a1 + 1, a2 - 1);
      return v4;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return v4;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return v4;
    default:
      v5 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a1 + 1, a1 + 2);
      v6 = (FINode **)(a1 + 3);
      if (v6 == (FINode **)v2)
        return 1;
      v7 = 0;
      break;
  }
  while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v6, (FINode **)v5))
  {
LABEL_12:
    v5 = (id *)v6++;
    if (v6 == (FINode **)v2)
      return 1;
  }
  TNodePtr::TNodePtr(&v10, (id *)v6);
  do
  {
    v8 = v5;
    TNodePtr::operator=(v5 + 1, v5);
    if (v5 == v12)
      break;
    --v5;
  }
  while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v10, (FINode **)v8 - 1));
  TNodePtr::operator=(v8, &v10);
  if (++v7 != 8)
  {

    v2 = v11;
    goto LABEL_12;
  }
  v4 = v6 + 1 == (FINode **)v11;

  return v4;
}

void sub_1CBCED1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(id *a1, void **a2, void **a3, void **a4)
{
  void **v8;
  FINode **v9;
  FINode **v10;
  id *v11;

  v10 = (FINode **)a2;
  v11 = a1;
  v8 = a4;
  v9 = (FINode **)a3;
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a2, a3);
  if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a4, (FINode **)a3))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v9, &v8);
    if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v9, (FINode **)a2))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v10, (void ***)&v9);
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v10, (FINode **)a1))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v11, (void ***)&v10);
    }
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<TNodePtr,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

TString *ShortDescription(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  unint64_t end_iter;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  __CFString *v9;
  TString *result;
  int v11;
  unint64_t v12;
  const char *v13;
  uint64_t *v14;
  const char *v15;
  uint64_t v16;
  __CFString *v17;
  CFStringRef theString;
  CFStringRef v19;

  if (!(_DWORD)a1)
    return (TString *)CFSTR("Invalid");
  v1 = a1;
  v2 = 1;
  v3 = a1;
  do
  {
    if ((v2 & ~v3) == 0)
      break;
    v3 &= ~v2;
    v2 *= 2;
  }
  while (v3);
  end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a1);
  v5 = end_iter;
  v7 = v6;
  v8 = HIDWORD(end_iter);
  v9 = &stru_1E8752DF8;
  theString = &stru_1E8752DF8;
  result = (TString *)CFRetain(&stru_1E8752DF8);
  if (v5 != v1 || v3 != (_DWORD)v8 || v2 != v7)
  {
    while (2)
    {
      v11 = v3 & v2;
      v12 = 4;
      v13 = "Self";
      switch(v3 & v2)
      {
        case 0:
          v14 = TString::KEmptyString(result);
          v19 = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          TString::SetStringRefAsImmutable((TString *)&v19, (TString *)*v14);
          goto LABEL_24;
        case 1:
          goto LABEL_23;
        case 2:
          v13 = "Child";
          v12 = 5;
          goto LABEL_23;
        case 3:
        case 5:
        case 6:
        case 7:
          __break(1u);
          return result;
        case 4:
          v13 = "ChildDeep";
          v12 = 9;
          goto LABEL_23;
        case 8:
          v13 = "ChildSpotlight";
          v12 = 14;
          goto LABEL_23;
        default:
          v15 = "PrefetchChildrenProperties";
          if (v11 != 32)
            v15 = "SelfSpotlight";
          v16 = 26;
          if (v11 != 32)
            v16 = 13;
          if (v11 == 16)
            v13 = "UbiquityStatus";
          else
            v13 = v15;
          if (v11 == 16)
            v12 = 14;
          else
            v12 = v16;
LABEL_23:
          TString::TString((TString *)&v19, v13, v12);
LABEL_24:
          if (CFStringGetLength(theString) && CFStringGetLength(v19))
            TString::Append((TString *)&theString, (const __CFString *)" | ");
          TString::Append((TString *)&theString, (const TString *)&v19);
          result = (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
          if (v3)
          {
            do
            {
              v3 &= ~v2;
              v2 *= 2;
            }
            while (v3 && (v2 & ~v3) != 0);
          }
          if (v5 != v1 || v3 != (_DWORD)v8 || v2 != v7)
            continue;
          v9 = (__CFString *)theString;
          break;
      }
      break;
    }
  }
  v17 = objc_retainAutorelease(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return (TString *)v17;
}

void sub_1CBCED4E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBCED5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c62_ZTSKZ49__FINodeObserver_observerForFINode_withObserver__E3__2(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  objc_copyWeak((id *)(a1 + 40), (id *)(a2 + 40));
}

void __destroy_helper_block_ea8_32c62_ZTSKZ49__FINodeObserver_observerForFINode_withObserver__E3__2(uint64_t a1)
{
  id *v1;

  v1 = (id *)(a1 + 32);
  objc_destroyWeak((id *)(a1 + 40));
  objc_destroyWeak(v1);
}

void sub_1CBCED7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1CBCED85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c60_ZTSKZ47__FINodeObserver_observerForProxy_subjectNode__E3__4(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
}

void __destroy_helper_block_ea8_32c60_ZTSKZ47__FINodeObserver_observerForProxy_subjectNode__E3__4(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 32));
}

void sub_1CBCED9F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1CBCEDA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FINodeObserver;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1CBCEDC60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  const void *v5;
  va_list va;
  const void *v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  va_list va2;
  const void *v13;
  va_list va3;
  va_list va4;

  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v7 = va_arg(va2, const void *);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v11 = va_arg(va3, const void *);
  va_copy(va4, va3);
  v13 = va_arg(va4, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  _Unwind_Resume(a1);
}

void NodeObservedOptionsCountRegistry::StartedObserving(void *a1, uint64_t a2)
{
  uint64_t v3;
  void **v4;
  void ***v5;
  void **v6;
  char *v7;
  int v8;
  uint64_t v9;
  unint64_t end_iter;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v18;
  _QWORD *v20;
  unsigned int v21;
  unint64_t v22;
  id v23;
  void ***v24;
  void ***v25;
  uint64_t v26;
  void ****v27;

  v23 = a1;
  std::mutex::lock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  v3 = NodeObservedOptionsCountRegistry::gRegistry;
  if (!NodeObservedOptionsCountRegistry::gRegistry)
  {
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v4 = (void **)operator new();
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *((_DWORD *)v4 + 8) = 1065353216;
    v27 = (void ****)v4;
    v5 = v24;
    if (v24 != v25)
    {
      do
      {
        v6 = v5[3];
        if (!v6)
          std::__throw_bad_function_call[abi:ne180100]();
        (*((void (**)(void **))*v6 + 6))(v6);
        v5 += 4;
      }
      while (v5 != v25);
      v4 = (void **)v27;
    }
    v27 = 0;
    _ZNSt3__110unique_ptrIZL10MakeUniqueI32NodeObservedOptionsCountRegistryJEENS0_IT_NS_14default_deleteIS3_EEEEDpOT0_E19MakeInstanceEnablerNS4_ISA_EEED1B8ne180100Ev((uint64_t *)&v27);
    v27 = &v24;
    std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
    std::unique_ptr<NodeObservedOptionsCountRegistry>::reset[abi:ne180100](&NodeObservedOptionsCountRegistry::gRegistry, (uint64_t)v4);
    v3 = NodeObservedOptionsCountRegistry::gRegistry;
  }
  v24 = (void ***)&v23;
  v7 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__emplace_unique_key_args<FINode * {__strong},std::piecewise_construct_t const&,std::tuple<FINode * const {__strong}&>,std::tuple<>>(v3, &v23, (uint64_t)&std::piecewise_construct, (id **)&v24);
  if ((_DWORD)a2)
  {
    v8 = 1;
    v9 = a2;
    do
    {
      if ((v8 & ~(_DWORD)v9) == 0)
        break;
      v9 = v9 & ~v8;
      v8 *= 2;
    }
    while ((_DWORD)v9);
  }
  else
  {
    v9 = 0;
    v8 = 1;
  }
  end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a2);
  v12 = end_iter;
  v13 = (uint64_t)(v7 + 24);
  v14 = a2 | (unint64_t)(v9 << 32);
  v15 = HIDWORD(end_iter);
  v22 = HIDWORD(end_iter);
LABEL_14:
  v16 = v11;
  v18 = HIDWORD(v14) != (_DWORD)v15 || v8 != (_DWORD)v11;
  while ((_DWORD)v14 != v12 || v18)
  {
    LODWORD(v27) = v8 & HIDWORD(v14);
    v24 = (void ***)&v27;
    v20 = std::__hash_table<std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::__unordered_map_hasher<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::hash<NodeNotificationOptions>,std::equal_to<NodeNotificationOptions>,true>,std::__unordered_map_equal<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::equal_to<NodeNotificationOptions>,std::hash<NodeNotificationOptions>,true>,std::allocator<std::__hash_value_type<NodeNotificationOptions,unsigned long>>>::__emplace_unique_key_args<NodeNotificationOptions,std::piecewise_construct_t const&,std::tuple<NodeNotificationOptions const&>,std::tuple<>>(v13, (unsigned int *)&v27, (uint64_t)&std::piecewise_construct, (_DWORD **)&v24);
    ++v20[3];
    if (HIDWORD(v14))
    {
      v21 = HIDWORD(v14) & ~v8;
      v14 = v14 | ((unint64_t)v21 << 32);
      v8 *= 2;
      v11 = v16;
      for (LODWORD(v15) = v22; v21; v8 *= 2)
      {
        if ((v8 & ~v21) == 0)
          break;
        v21 &= ~v8;
        v14 = v14 | ((unint64_t)v21 << 32);
      }
      goto LABEL_14;
    }
  }
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);

}

void sub_1CBCEDF5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, char a12, uint64_t a13, uint64_t a14, void **a15)
{
  a15 = (void **)&a12;
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](&a15);
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);

  _Unwind_Resume(a1);
}

void NodeObservedOptionsCountRegistry::StoppedObserving(void *a1, uint64_t a2)
{
  uint64_t **v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  NSObject *v8;
  unint64_t end_iter;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v18;
  uint64_t *v20;
  uint64_t v21;
  unsigned int v22;
  NSObject *v23;
  void *v24;
  uint64_t *v25;
  id v26;
  uint8_t buf[4];
  id v28;
  __int16 v29;
  id v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  std::mutex::lock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  if (NodeObservedOptionsCountRegistry::gRegistry)
  {
    v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>((_QWORD *)NodeObservedOptionsCountRegistry::gRegistry, &v26);
    if (v3)
    {
      if ((_DWORD)a2)
      {
        v4 = 1;
        v5 = a2;
        do
        {
          if ((v4 & ~(_DWORD)v5) == 0)
            break;
          v5 = v5 & ~v4;
          v4 *= 2;
        }
        while ((_DWORD)v5);
      }
      else
      {
        v5 = 0;
        v4 = 1;
      }
      end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a2);
      v10 = end_iter;
      v12 = v11;
      v13 = 0;
      v25 = (uint64_t *)v3;
      v14 = v3 + 3;
      v15 = a2 | (unint64_t)(v5 << 32);
      v16 = HIDWORD(end_iter);
LABEL_16:
      v18 = HIDWORD(v15) != (_DWORD)v16 || v4 != v12;
      while ((_DWORD)v15 != v10 || v18)
      {
        *(_DWORD *)buf = v4 & HIDWORD(v15);
        v20 = std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::find<TPropertyRecord>(v14, (unsigned int *)buf);
        if (v20)
        {
          v21 = v20[3] - 1;
          v20[3] = v21;
          if (!v21)
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(v14, v20);
          if (HIDWORD(v15))
          {
LABEL_32:
            v22 = HIDWORD(v15) & ~v4;
            v15 = v15 | ((unint64_t)v22 << 32);
            for (v4 *= 2; v22; v4 *= 2)
            {
              if ((v4 & ~v22) == 0)
                break;
              v22 &= ~v4;
              v15 = v15 | ((unint64_t)v22 << 32);
            }
            goto LABEL_16;
          }
        }
        else
        {
          v13 = *(_DWORD *)buf | v13;
          if (HIDWORD(v15))
            goto LABEL_32;
        }
      }
      if ((_DWORD)v13)
      {
        LogObj(5);
        v23 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          ShortDescription(v13);
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543618;
          v28 = v24;
          v29 = 2114;
          v30 = v26;
          _os_log_impl(&dword_1CBC4A000, v23, OS_LOG_TYPE_ERROR, "Unbalanced observing of '%{public}@' changes on %{public}@", buf, 0x16u);

        }
      }
      if (!v25[6])
        std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::erase((_QWORD *)NodeObservedOptionsCountRegistry::gRegistry, v25);
      if (!*(_QWORD *)(NodeObservedOptionsCountRegistry::gRegistry + 24))
        std::unique_ptr<NodeObservedOptionsCountRegistry>::reset[abi:ne180100](&NodeObservedOptionsCountRegistry::gRegistry, 0);
    }
    else
    {
      LogObj(5);
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v28 = v26;
        _os_log_impl(&dword_1CBC4A000, v8, OS_LOG_TYPE_ERROR, "Calling StoppedObserving on a node not being observed: %{public}@", buf, 0xCu);
      }

    }
  }
  else
  {
    LogObj(5);
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      ShortDescription(a2);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543618;
      v28 = v7;
      v29 = 2114;
      v30 = v26;
      _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_ERROR, "Unbalanced observing of '%{public}@' changes on %{public}@. Registry is nil.", buf, 0x16u);

    }
  }
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);

}

void sub_1CBCEE2E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  _Unwind_Resume(a1);
}

NodeObservedOptionsCountRegistry *NodeObservedOptionsCountRegistry::AllObservedOptions(NodeObservedOptionsCountRegistry *this, FINode *a2)
{
  NodeObservedOptionsCountRegistry *v2;
  uint64_t **v3;
  uint64_t *v4;
  id v6;

  v2 = this;
  v6 = v2;
  if (v2)
  {
    std::mutex::lock(&NodeObservedOptionsCountRegistry::gRegistryLock);
    if (NodeObservedOptionsCountRegistry::gRegistry
      && (v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>((_QWORD *)NodeObservedOptionsCountRegistry::gRegistry, &v6)) != 0&& (v4 = v3[5]) != 0)
    {
      LODWORD(v2) = 0;
      do
      {
        v2 = (NodeObservedOptionsCountRegistry *)(*((_DWORD *)v4 + 4) | v2);
        v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    else
    {
      v2 = 0;
    }
    std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);

  }
  return v2;
}

void sub_1CBCEE3D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);

  _Unwind_Resume(a1);
}

void PullEventsFromQueue(unint64_t a1)
{
  void *v2;
  int NextEvent;
  id v4;
  id v5;

  v2 = 0;
  while (1)
  {
    v5 = v2;
    NextEvent = NodeEventGetNextEvent(&v5, a1);
    v4 = v5;

    if (!NextEvent)
      break;
    v2 = v4;
    NodeDispatchEvent(v4);
  }

}

void sub_1CBCEE464(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t *_ZNSt3__110unique_ptrIZL10MakeUniqueI32NodeObservedOptionsCountRegistryJEENS0_IT_NS_14default_deleteIS3_EEEEDpOT0_E19MakeInstanceEnablerNS4_ISA_EEED1B8ne180100Ev(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::~__hash_table(v2);
    MEMORY[0x1D17A53D0](v3, 0x10A0C408EF24B1CLL);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(v2 + 3));

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (!v2)
    return;
  v4 = (char *)v1[1];
  v5 = **a1;
  if (v4 == v2)
    goto LABEL_10;
  do
  {
    v6 = v4 - 32;
    v7 = (char *)*((_QWORD *)v4 - 1);
    if (v4 - 32 == v7)
    {
      v7 = v4 - 32;
      v8 = 4;
    }
    else
    {
      if (!v7)
        goto LABEL_8;
      v8 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_8:
    v4 = v6;
  }
  while (v6 != v2);
  v5 = **a1;
LABEL_10:
  v1[1] = v2;
  operator delete(v5);
}

uint64_t std::unique_ptr<NodeObservedOptionsCountRegistry>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::~__hash_table(result);
    JUMPOUT(0x1D17A53D0);
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__emplace_unique_key_args<FINode * {__strong},std::piecewise_construct_t const&,std::tuple<FINode * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  char *v14;
  unint64_t v15;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v8 = objc_msgSend(*a2, "hash");
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          v15 = *((_QWORD *)v14 + 1);
          if (v15 == v9)
          {
            if ((std::equal_to<FINode * {__strong}>::operator()(a1 + 32, *((void **)v14 + 2), *a2) & 1) != 0)
              return v14;
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10)
                v15 %= v10;
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v4)
              break;
          }
          v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  v14 = (char *)operator new(0x40uLL);
  *(_QWORD *)v14 = 0;
  *((_QWORD *)v14 + 1) = v9;
  *((_QWORD *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v14 = *v24;
LABEL_38:
    *v24 = v14;
    goto LABEL_39;
  }
  *(_QWORD *)v14 = *v16;
  *v16 = v14;
  *(_QWORD *)(v23 + 8 * v4) = v16;
  if (*(_QWORD *)v14)
  {
    v25 = *(_QWORD *)(*(_QWORD *)v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v14;
}

void sub_1CBCEE86C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(a2 + 3));

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(uint64_t result)
{
  int v1;
  int v2;

  v1 = 1;
  if ((_DWORD)result)
  {
    v2 = result;
    while ((v1 & ~v2) != 0)
    {
      v2 &= ~v1;
      v1 *= 2;
      if (!v2)
        return result;
    }
    do
    {
      v2 &= ~v1;
      v1 *= 2;
    }
    while (v2);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::__unordered_map_hasher<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::hash<NodeNotificationOptions>,std::equal_to<NodeNotificationOptions>,true>,std::__unordered_map_equal<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::equal_to<NodeNotificationOptions>,std::hash<NodeNotificationOptions>,true>,std::allocator<std::__hash_value_type<NodeNotificationOptions,unsigned long>>>::__emplace_unique_key_args<NodeNotificationOptions,std::piecewise_construct_t const&,std::tuple<NodeNotificationOptions const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x20uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *v11 = *v20;
LABEL_38:
    *v20 = v11;
    goto LABEL_39;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v21 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1CBCEEB20(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  id *v3;
  id *v5;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&v5);
  v3 = v5;
  v5 = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

void FIProviderDomainFetcher::FIProviderDomainFetcher(FIProviderDomainFetcher *this)
{
  NSObject *v2;

  *(_QWORD *)this = 850045863;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = 0;
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = objc_claimAutoreleasedReturnValue();
  *((_QWORD *)this + 8) = dispatch_queue_create("DomainFetcher", v2);

  *((_QWORD *)this + 9) = objc_alloc_init(MEMORY[0x1E0C99E10]);
  *((_BYTE *)this + 80) = 0;
  *((_QWORD *)this + 11) = dispatch_semaphore_create(0);
}

void sub_1CBCEEC08(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

void FIProviderDomainFetcher::Start(FIProviderDomainFetcher *this)
{
  void *v2;
  __int128 v3;
  NSObject *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;
  NSObject *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  id v15;
  uint8_t buf[4];
  void *v17;
  __int16 v18;
  id v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 8));
  std::mutex::lock((std::mutex *)this);
  objc_msgSend(*((id *)this + 9), "firstObject");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  std::mutex::unlock((std::mutex *)this);
  if (v2)
  {
    *(_QWORD *)&v3 = 138543618;
    v14 = v3;
    do
    {
      LogObj(4);
      v4 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        objc_msgSend(v2, "domainID");
        v5 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        v17 = v5;
        _os_log_impl(&dword_1CBC4A000, v4, OS_LOG_TYPE_DEFAULT, "Looking up domain for id '%@'", buf, 0xCu);

      }
      v6 = (void *)FPProviderDomainClass();
      objc_msgSend(v2, "domainID");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = objc_msgSend(v2, "cachePolicy");
      v15 = 0;
      objc_msgSend(v6, "providerDomainWithID:cachePolicy:error:", v7, v8, &v15);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = v15;

      if (!v9)
      {
        LogObj(4);
        v11 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(v2, "domainID");
          v12 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = v14;
          v17 = v12;
          v18 = 2114;
          v19 = v10;
          _os_log_impl(&dword_1CBC4A000, v11, OS_LOG_TYPE_ERROR, "Failed to find domain for %{public}@ with error: %{public}@", buf, 0x16u);

        }
      }
      std::mutex::lock((std::mutex *)this);
      objc_msgSend(v2, "setAsyncFetchedDomain:", v9);
      objc_msgSend(v2, "setAsyncError:", v10);
      objc_msgSend(*((id *)this + 9), "removeObject:", v2);
      objc_msgSend(v2, "setAsyncResultAvailable:", 1);
      dispatch_semaphore_signal(*((dispatch_semaphore_t *)this + 11));
      if (v9)
        *((_BYTE *)this + 80) = 1;
      objc_msgSend(*((id *)this + 9), "firstObject", v14);
      v13 = objc_claimAutoreleasedReturnValue();

      std::mutex::unlock((std::mutex *)this);
      v2 = (void *)v13;
    }
    while (v13);
  }
}

void sub_1CBCEEE80(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t FIProviderDomainFetcher::Queue(id *this, FIProviderDomain *a2)
{
  FIProviderDomain *v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD block[5];

  v3 = a2;
  v4 = objc_msgSend(this[9], "count");
  objc_msgSend(this[9], "addObject:", v3);
  if (!v4)
  {
    v5 = this[8];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN23FIProviderDomainFetcher5QueueEP16FIProviderDomain_block_invoke;
    block[3] = &__block_descriptor_40_ea8_32c63_ZTSKZN23FIProviderDomainFetcher5QueueEP16FIProviderDomainE3__0_e5_v8__0l;
    block[4] = this;
    dispatch_async(v5, block);
  }

  return 0;
}

void sub_1CBCEEF8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN23FIProviderDomainFetcher5QueueEP16FIProviderDomain_block_invoke(uint64_t a1)
{
  FIProviderDomainFetcher::Start(*(FIProviderDomainFetcher **)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_32c63_ZTSKZN23FIProviderDomainFetcher5QueueEP16FIProviderDomainE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

id FIProviderDomainFetcher::FindQueuedDomain(FIProviderDomainFetcher *this, NSString *a2)
{
  NSString *v3;
  void *v4;
  NSString *v5;
  uint64_t v6;
  void *v7;
  _QWORD v9[4];
  NSString *v10;

  v3 = a2;
  v4 = (void *)*((_QWORD *)this + 9);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3321888768;
  v9[2] = ___ZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSString_block_invoke;
  v9[3] = &__block_descriptor_40_ea8_32c66_ZTSKZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSStringE3__0_e33_B32__0__FIProviderDomain_8Q16_B24l;
  v5 = v3;
  v10 = v5;
  v6 = objc_msgSend(v4, "indexOfObjectPassingTest:", v9);
  if (v6 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v7 = 0;
  }
  else
  {
    objc_msgSend(*((id *)this + 9), "objectAtIndexedSubscript:", v6);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v7;
}

void sub_1CBCEF060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

uint64_t ___ZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSString_block_invoke(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  void *v6;
  uint64_t v7;

  objc_msgSend(a2, "domainID");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "isEqual:", *(_QWORD *)(a1 + 32));

  if ((_DWORD)v7)
    *a4 = 1;
  return v7;
}

void sub_1CBCEF0D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c66_ZTSKZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSStringE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c66_ZTSKZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSStringE3__0(uint64_t a1)
{

}

FIProviderDomain *FIProviderDomainFetcher::FetchDomainForID(uint64_t a1, void *a2, uint64_t a3, void *a4, void **a5)
{
  id v9;
  id v10;
  void *v11;
  NSObject *v12;
  TString *v13;
  void *v14;
  void *v15;
  FIProviderDomain *v16;
  FIProviderDomain *v18;
  void *v19;
  FIProviderDomain *v20;
  id v21;
  NSObject *v22;
  NSObject *v23;
  dispatch_time_t v24;
  NSObject *v25;
  TString *v26;
  void *v27;
  TString *v28;
  void *v29;
  void *v30;
  NSObject *v31;
  NSObject *v32;
  void *v33;
  TString v34;
  uint8_t buf[4];
  id v36;
  __int16 v37;
  void *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  v10 = a4;
  if ((UseFileProviderFramework() & 1) == 0)
  {
    v16 = 0;
    goto LABEL_16;
  }
  std::mutex::lock((std::mutex *)a1);
  if (*(_BYTE *)(a1 + 80))
  {
    std::mutex::unlock((std::mutex *)a1);
LABEL_4:
    objc_msgSend((id)FPProviderDomainClass(), "providerDomainWithID:cachePolicy:error:", v9, a3, a5);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (a5 && *a5)
    {
      LogObj(4);
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = (TString *)v9;
        v34.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v34, v13);

        SanitizedStr(&v34);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = *a5;
        *(_DWORD *)buf = 138412546;
        v36 = v14;
        v37 = 2114;
        v38 = v15;
        _os_log_impl(&dword_1CBC4A000, v12, OS_LOG_TYPE_ERROR, "Error fetching domainID '%@': %{public}@", buf, 0x16u);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);

      }
    }
    if (v11)
      v16 = -[FIProviderDomain initWithDomain:]([FIProviderDomain alloc], "initWithDomain:", v11);
    else
      v16 = 0;

    goto LABEL_16;
  }
  FIProviderDomainFetcher::FindQueuedDomain((FIProviderDomainFetcher *)a1, (NSString *)v9);
  v16 = (FIProviderDomain *)objc_claimAutoreleasedReturnValue();
  if (v16)
  {
    std::mutex::unlock((std::mutex *)a1);
    goto LABEL_16;
  }
  v18 = [FIProviderDomain alloc];
  objc_msgSend(v10, "URLByStandardizingPath");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = -[FIProviderDomain initWithDomainID:cachePolicy:rootURL:domain:](v18, "initWithDomainID:cachePolicy:rootURL:domain:", v9, a3, v19, 0);

  v21 = (id)FIProviderDomainFetcher::Queue((id *)a1, v20);
  std::mutex::unlock((std::mutex *)a1);
  if (!v20)
    goto LABEL_4;
  LogObj(4);
  v22 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1CBC4A000, v22, OS_LOG_TYPE_DEFAULT, "Waiting for first domain result", buf, 2u);
  }

  v23 = *(NSObject **)(a1 + 88);
  v24 = dispatch_time(0, 1000000000);
  if (dispatch_semaphore_wait(v23, v24))
  {
    LogObj(4);
    v25 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v26 = (TString *)v9;
      v34.fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(&v34, v26);

      SanitizedStr(&v34);
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      v36 = v27;
      _os_log_impl(&dword_1CBC4A000, v25, OS_LOG_TYPE_ERROR, "Domain fetch for providerDomainID timed out: %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);

    }
  }
  else
  {
    LogObj(4);
    v25 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v28 = (TString *)v9;
      v34.fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(&v34, v28);

      SanitizedStr(&v34);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543362;
      v36 = v29;
      _os_log_impl(&dword_1CBC4A000, v25, OS_LOG_TYPE_DEFAULT, "Domain fetch for providerDomainID finished before timeout: %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);

    }
  }

  if (!-[FIProviderDomain asyncResultAvailable](v20, "asyncResultAvailable"))
  {
LABEL_33:
    v16 = v20;
    goto LABEL_16;
  }
  -[FIProviderDomain asyncFetchedDomain](v20, "asyncFetchedDomain");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v30)
  {
    LogObj(4);
    v32 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      -[FIProviderDomain asyncError](v20, "asyncError");
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138543618;
      v36 = v9;
      v37 = 2114;
      v38 = v33;
      _os_log_impl(&dword_1CBC4A000, v32, OS_LOG_TYPE_ERROR, "Waited and received no domain for %{public}@ error: %{public}@", buf, 0x16u);

    }
    goto LABEL_33;
  }
  LogObj(4);
  v31 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v36 = v30;
    _os_log_impl(&dword_1CBC4A000, v31, OS_LOG_TYPE_DEFAULT, "Waited and received result for domain: %{public}@", buf, 0xCu);
  }

  v16 = -[FIProviderDomain initWithDomain:]([FIProviderDomain alloc], "initWithDomain:", v30);
LABEL_16:

  return v16;
}

void sub_1CBCEF630(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

FIProviderDomain *FIProviderDomainFetcher::FetchDomainForURL(std::mutex *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v9;
  int v10;
  void *v11;
  FIProviderDomain *v12;
  void *v13;
  FIProviderDomain *v14;

  v9 = a2;
  std::mutex::lock(a1);
  v10 = a1[1].__m_.__opaque[8];
  std::mutex::unlock(a1);
  if (!v10)
  {
    objc_msgSend(v9, "fp_fpfsProviderDomainID:", a3);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (v11)
    {
      if ((_DWORD)a3)
        v13 = 0;
      else
        v13 = v9;
      FIProviderDomainFetcher::FetchDomainForID((uint64_t)a1, v11, a4, v13, 0);
      v12 = (FIProviderDomain *)objc_claimAutoreleasedReturnValue();
      goto LABEL_9;
    }
LABEL_10:
    v14 = 0;
    goto LABEL_11;
  }
  objc_msgSend((id)FPProviderDomainClass(), "providerDomainForURL:error:", v9, a5);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v11)
    goto LABEL_10;
  v12 = -[FIProviderDomain initWithDomain:]([FIProviderDomain alloc], "initWithDomain:", v11);
LABEL_9:
  v14 = v12;
LABEL_11:

  return v14;
}

void sub_1CBCEF874(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t FIProviderDomainFetcher::Singleton(FIProviderDomainFetcher *this)
{
  unsigned __int8 v1;
  FIProviderDomainFetcher *v3;

  {
    v3 = (FIProviderDomainFetcher *)operator new();
    FIProviderDomainFetcher::FIProviderDomainFetcher(v3);
    FIProviderDomainFetcher::Singleton(void)::fetcher = (uint64_t)v3;
  }
  return FIProviderDomainFetcher::Singleton(void)::fetcher;
}

void sub_1CBCEF910(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x1080C405B080FE4);
  _Unwind_Resume(a1);
}

void sub_1CBCEF9F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1CBCEFB78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1CBCEFC18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id objc_cast<FIProviderDomain,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

void sub_1CBCEFDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  void *v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

void sub_1CBCEFED4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCEFFBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBCF006C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCF0110(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCF01CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCF026C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCF030C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCF0470(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCF04FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF0690(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF0738(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF0794(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF07FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF0864(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF08F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCF0960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void FSInfoVirtualTypeToString(TString *a1@<X0>, TString *a2@<X8>)
{
  uint64_t *v3;

  if (a1 < 0x24 && ((0xFFFFF18FFuLL >> (char)a1) & 1) != 0)
  {
    TString::TString(a2, off_1E87529B0[(char)a1]);
  }
  else
  {
    v3 = TString::KEmptyString(a1);
    a2->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a2, (TString *)*v3);
  }
}

void sub_1CBCF0AC8(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t StringToFSInfoVirtualType(const TString *a1)
{
  unsigned __int8 v2;
  CFTypeRef cf1;

  cf1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)&cf1, 0);
  TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kNonVirtual", 11);
  if (CFEqual(cf1, a1->fString.fRef))
  {
    v2 = 0;
  }
  else
  {
    TString::SetStringRefAsImmutable((TString *)&cf1, 0);
    TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kComputer", 9);
    if (CFEqual(cf1, a1->fString.fRef))
    {
      v2 = 1;
    }
    else
    {
      TString::SetStringRefAsImmutable((TString *)&cf1, 0);
      TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kVirtualFolder", 14);
      if (CFEqual(cf1, a1->fString.fRef))
      {
        v2 = 2;
      }
      else
      {
        TString::SetStringRefAsImmutable((TString *)&cf1, 0);
        TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kVirtualAlias", 13);
        if (CFEqual(cf1, a1->fString.fRef))
        {
          v2 = 3;
        }
        else
        {
          TString::SetStringRefAsImmutable((TString *)&cf1, 0);
          TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kVirtualDocument", 16);
          if (CFEqual(cf1, a1->fString.fRef))
          {
            v2 = 4;
          }
          else
          {
            TString::SetStringRefAsImmutable((TString *)&cf1, 0);
            TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kQueryAlias", 11);
            if (CFEqual(cf1, a1->fString.fRef))
            {
              v2 = 5;
            }
            else
            {
              TString::operator=((TString *)&cf1, "kQueryHitsContainer");
              if (CFEqual(cf1, a1->fString.fRef))
              {
                v2 = 6;
              }
              else
              {
                TString::operator=((TString *)&cf1, "kQueryHit");
                if (CFEqual(cf1, a1->fString.fRef))
                {
                  v2 = 7;
                }
                else
                {
                  TString::operator=((TString *)&cf1, "kDesktop");
                  if (CFEqual(cf1, a1->fString.fRef))
                  {
                    v2 = 11;
                  }
                  else
                  {
                    TString::operator=((TString *)&cf1, "kTrash");
                    if (CFEqual(cf1, a1->fString.fRef))
                    {
                      v2 = 12;
                    }
                    else
                    {
                      TString::operator=((TString *)&cf1, "kUnresolvedAlias");
                      if (CFEqual(cf1, a1->fString.fRef))
                      {
                        v2 = 16;
                      }
                      else
                      {
                        TString::operator=((TString *)&cf1, "kDevices");
                        if (CFEqual(cf1, a1->fString.fRef))
                        {
                          v2 = 17;
                        }
                        else
                        {
                          TString::operator=((TString *)&cf1, "kPlaces");
                          if (CFEqual(cf1, a1->fString.fRef))
                          {
                            v2 = 18;
                          }
                          else
                          {
                            TString::operator=((TString *)&cf1, "kSavedSearches");
                            if (CFEqual(cf1, a1->fString.fRef))
                            {
                              v2 = 19;
                            }
                            else
                            {
                              TString::operator=((TString *)&cf1, "kPublishedFolders");
                              if (CFEqual(cf1, a1->fString.fRef))
                              {
                                v2 = 20;
                              }
                              else
                              {
                                TString::operator=((TString *)&cf1, "kTags");
                                if (CFEqual(cf1, a1->fString.fRef))
                                {
                                  v2 = 21;
                                }
                                else
                                {
                                  TString::operator=((TString *)&cf1, "kAllTags");
                                  if (CFEqual(cf1, a1->fString.fRef))
                                  {
                                    v2 = 22;
                                  }
                                  else
                                  {
                                    TString::operator=((TString *)&cf1, "kAllCloudLibs");
                                    if (CFEqual(cf1, a1->fString.fRef))
                                    {
                                      v2 = 23;
                                    }
                                    else
                                    {
                                      TString::operator=((TString *)&cf1, "kAllDataSeparatedCloudLibs");
                                      if (CFEqual(cf1, a1->fString.fRef))
                                      {
                                        v2 = 24;
                                      }
                                      else
                                      {
                                        TString::operator=((TString *)&cf1, "kCloudLib");
                                        if (CFEqual(cf1, a1->fString.fRef))
                                        {
                                          v2 = 25;
                                        }
                                        else
                                        {
                                          TString::operator=((TString *)&cf1, "kAllFPProviders");
                                          if (CFEqual(cf1, a1->fString.fRef))
                                          {
                                            v2 = 26;
                                          }
                                          else
                                          {
                                            TString::operator=((TString *)&cf1, "kFPProvider");
                                            if (CFEqual(cf1, a1->fString.fRef))
                                            {
                                              v2 = 27;
                                            }
                                            else
                                            {
                                              TString::operator=((TString *)&cf1, "kFPv2Item");
                                              if (CFEqual(cf1, a1->fString.fRef))
                                              {
                                                v2 = 28;
                                              }
                                              else
                                              {
                                                TString::operator=((TString *)&cf1, "kITunesDevicesContainer");
                                                if (CFEqual(cf1, a1->fString.fRef))
                                                {
                                                  v2 = 29;
                                                }
                                                else
                                                {
                                                  TString::operator=((TString *)&cf1, "kITunesDevice");
                                                  if (CFEqual(cf1, a1->fString.fRef))
                                                  {
                                                    v2 = 30;
                                                  }
                                                  else
                                                  {
                                                    TString::operator=((TString *)&cf1, "kNetworkNearby");
                                                    if (CFEqual(cf1, a1->fString.fRef))
                                                    {
                                                      v2 = 31;
                                                    }
                                                    else
                                                    {
                                                      TString::operator=((TString *)&cf1, "kNetworkSidebar");
                                                      if (CFEqual(cf1, a1->fString.fRef))
                                                      {
                                                        v2 = 32;
                                                      }
                                                      else
                                                      {
                                                        TString::operator=((TString *)&cf1, "kAirDrop");
                                                        if (CFEqual(cf1, a1->fString.fRef))
                                                        {
                                                          v2 = 33;
                                                        }
                                                        else
                                                        {
                                                          TString::operator=((TString *)&cf1, "kRecentDocuments");
                                                          if (CFEqual(cf1, a1->fString.fRef))
                                                          {
                                                            v2 = 34;
                                                          }
                                                          else
                                                          {
                                                            TString::operator=((TString *)&cf1, "kICloudContainer");
                                                            if (CFEqual(cf1, a1->fString.fRef))
                                                              v2 = 35;
                                                            else
                                                              v2 = -1;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v2;
}

void sub_1CBCF102C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TReplicaRegistry::Remove(TReplicaRegistry *this, FINode *a2)
{
  FINode *v3;
  void *v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;
  OpaqueNodeRef **v11;
  uint64_t v12;
  OpaqueNodeRef *v13;
  uint64_t v14;
  const void *v15;
  size_t v16;
  unint64_t v17;

  v3 = a2;
  -[FINode original](v3, "original");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "nodeRef");

  v17 = v5;
  v6 = (_QWORD *)*((_QWORD *)this + 1);
  if (v6)
  {
    v7 = (_QWORD *)((char *)this + 8);
    do
    {
      v8 = v6[4];
      v9 = v8 >= v5;
      if (v8 >= v5)
        v10 = v6;
      else
        v10 = v6 + 1;
      if (v9)
        v7 = v6;
      v6 = (_QWORD *)*v10;
    }
    while (*v10);
    if (v7 != (_QWORD *)((char *)this + 8) && v5 >= v7[4])
    {
      v11 = (OpaqueNodeRef **)v7[5];
      if (v11 != (OpaqueNodeRef **)v7[6])
      {
        v12 = -(uint64_t)v11;
        while (1)
        {
          v13 = *v11;
          if (v13 == -[FINode nodeRef](v3, "nodeRef"))
            break;
          v11 += 2;
          v12 -= 16;
          if (v11 == (OpaqueNodeRef **)v7[6])
            goto LABEL_20;
        }
        v14 = -v12;
        v15 = (const void *)(16 - v12);
        v16 = v7[6] - (16 - v12);
        if (v16)
          memmove((void *)v14, v15, v16);
        v11 = (OpaqueNodeRef **)(v14 + v16);
        v7[6] = v11;
      }
LABEL_20:
      if ((OpaqueNodeRef **)v7[5] == v11)
        std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::__erase_unique<OpaqueNodeRef *>((uint64_t)this, &v17);
    }
  }

}

void sub_1CBCF115C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id TReplicaRegistry::CopyReplicaFINodes(TReplicaRegistry *this, OpaqueNodeRef *a2)
{
  char *v2;
  _QWORD *v3;
  _QWORD *v4;
  char *v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v11;
  _QWORD *i;
  void *v13;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  v2 = (char *)this + 8;
  v3 = v4;
  if (!v4)
    goto LABEL_12;
  v5 = v2;
  do
  {
    v6 = v3[4];
    v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2)
      v8 = v3;
    else
      v8 = v3 + 1;
    if (v7)
      v5 = (char *)v3;
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v5 != v2 && *((_QWORD *)v5 + 4) <= (unint64_t)a2)
  {
    v9 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", (uint64_t)(*((_QWORD *)v5 + 6) - *((_QWORD *)v5 + 5)) >> 4);
    v11 = (_QWORD *)*((_QWORD *)v5 + 5);
    for (i = (_QWORD *)*((_QWORD *)v5 + 6); v11 != i; v11 += 2)
    {
      +[FINode nodeFromNodeRef:](FINode, "nodeFromNodeRef:", *v11);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "addObject:", v13);

    }
  }
  else
  {
LABEL_12:
    v9 = 0;
  }
  return v9;
}

void sub_1CBCF1250(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF12C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF131C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FIReplicaNode;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void TReplicaRegistry::RemoveReplica(TReplicaRegistry *this, FINode *a2)
{
  TDSMutex *Mutex;
  TReplicaRegistry *v3;

  v3 = this;
  Mutex = (TDSMutex *)TReplicaRegistry::GetMutex(v3);
  TDSMutex::lock(Mutex);
  if (TReplicaRegistry::gReplicaRegistry)
    TReplicaRegistry::Remove((TReplicaRegistry *)TReplicaRegistry::gReplicaRegistry, (FINode *)v3);
  TDSMutex::unlock(Mutex);

}

void sub_1CBCF13A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TDSMutex *v10;

  TDSMutex::unlock(v10);

  _Unwind_Resume(a1);
}

void sub_1CBCF1460(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCF1574(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::__erase_unique<OpaqueNodeRef *>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = (uint64_t *)(a1 + 8);
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4])
    return 0;
  std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;
  void *v4;

  v3 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(a1, a2);
  v4 = (void *)a2[5];
  if (v4)
  {
    a2[6] = (uint64_t)v4;
    operator delete(v4);
  }
  operator delete(a2);
  return v3;
}

uint64_t DSDebugStateString()
{
  return 0;
}

_QWORD *std::vector<std::weak_ptr<TClientChangeNotifier>>::emplace_back<std::shared_ptr<TClientChangeNotifier> &>(uint64_t *a1, __int128 *a2)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  void *v23[5];

  v6 = a1[2];
  v4 = a1 + 2;
  v5 = v6;
  v7 = (_QWORD *)*(v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v12 = ((uint64_t)v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v14 = v5 - *a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v23[4] = v4;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)v4, v15);
    v17 = &v16[16 * v12];
    v23[0] = v16;
    v23[1] = v17;
    v23[3] = &v16[16 * v18];
    v19 = *a2;
    *(_OWORD *)v17 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 16);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23[2] = v17 + 16;
    std::vector<std::weak_ptr<TClientChangeNotifier>>::__swap_out_circular_buffer(a1, v23);
    v11 = (_QWORD *)a1[1];
    std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::~__split_buffer(v23);
  }
  else
  {
    *v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    v7[1] = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 16);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v11;
  return v11 - 2;
}

void sub_1CBCF175C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t TClientChangeNotifier::TClientChangeNotifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  id v12;
  id v13;
  uint64_t v14;
  id v15;
  _QWORD *v16;
  uint64_t v17;
  void (*v18)(void);
  _QWORD v20[3];
  _QWORD *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v12 = a6;
  v13 = a7;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v14 = *(_QWORD *)(a3 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 32) = v14;
  *(_QWORD *)(a1 + 40) = a4;
  v15 = v12;
  *(_QWORD *)(a1 + 48) = v15;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  if (v13)
  {
    *(_QWORD *)(a1 + 88) = &unk_1E874FEC8;
    *(_QWORD *)(a1 + 96) = MEMORY[0x1D17A5A30](v13);
    *(_QWORD *)(a1 + 112) = a1 + 88;
    v20[0] = &off_1E874EB58;
  }
  else
  {
    v20[0] = &off_1E874EB00;
    v20[1] = a5;
  }
  v21 = v20;
  std::__function::__value_func<void ()(OpaqueEventQueue *)>::swap[abi:ne180100](v20, (_QWORD *)(a1 + 56));
  v16 = v21;
  if (v21 == v20)
  {
    v17 = 4;
    v16 = v20;
    goto LABEL_8;
  }
  if (v21)
  {
    v17 = 5;
LABEL_8:
    (*(void (**)(void))(*v16 + 8 * v17))();
  }
  v18 = *(void (**)(void))(a1 + 24);
  if (v18 && *(_QWORD *)(a1 + 16))
    v18();

  return a1;
}

void sub_1CBCF18D8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  id *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v9;
  uint64_t v10;

  v9 = *(_QWORD **)(v1 + 112);
  if (v9 == v7)
  {
    v10 = 4;
  }
  else
  {
    if (!v9)
      goto LABEL_6;
    v10 = 5;
    v7 = *(_QWORD **)(v1 + 112);
  }
  (*(void (**)(_QWORD *))(*v7 + 8 * v10))(v7);
LABEL_6:
  TClientChangeNotifier::TClientChangeNotifier(v6, v5, v4, v1);

  _Unwind_Resume(a1);
}

void TClientChangeNotifier::~TClientChangeNotifier(uint64_t (**this)(void))
{
  TClientChangeNotifier *v1;
  uint64_t (*v2)(void);
  TDSMutex *RegistrationLock;
  uint64_t v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  TClientChangeNotifier *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  TClientChangeNotifier *v17;
  unint64_t *v18;
  unint64_t v19;
  __int128 v20;
  std::__shared_weak_count *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  char v27;

  v1 = (TClientChangeNotifier *)this;
  v2 = this[4];
  if (v2)
  {
    this = (uint64_t (**)(void))this[2];
    if (this)
      this = (uint64_t (**)(void))v2();
  }
  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock((TDSNotifier *)this);
  TDSMutex::lock(RegistrationLock);
  v5 = (_QWORD *)TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList;
  v4 = qword_1EF9B9C18;
  while (1)
  {
    if (v5 == (_QWORD *)v4)
    {
      v12 = v4;
      goto LABEL_33;
    }
    v6 = (std::__shared_weak_count *)v5[1];
    if (!v6)
      break;
    v7 = std::__shared_weak_count::lock(v6);
    if (!v7)
      break;
    v8 = v7;
    v9 = (TClientChangeNotifier *)*v5;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v8);
    }
    if (!v9 || v9 == v1)
      break;
    v5 += 2;
  }
  if (v5 == (_QWORD *)v4 || (v13 = v5 + 2, v5 + 2 == (_QWORD *)v4))
  {
    v12 = (uint64_t)v5;
  }
  else
  {
    v12 = (uint64_t)v5;
    do
    {
      v14 = (std::__shared_weak_count *)v5[3];
      v5 = v13;
      if (v14)
      {
        v15 = std::__shared_weak_count::lock(v14);
        if (v15)
        {
          v16 = v15;
          v17 = (TClientChangeNotifier *)*v5;
          v18 = (unint64_t *)&v15->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v16);
          }
          if (v17 && v17 != v1)
          {
            v20 = *(_OWORD *)v5;
            *v5 = 0;
            v5[1] = 0;
            v21 = *(std::__shared_weak_count **)(v12 + 8);
            *(_OWORD *)v12 = v20;
            if (v21)
              std::__shared_weak_count::__release_weak(v21);
            v12 += 16;
          }
        }
      }
      v13 = v5 + 2;
    }
    while (v5 + 2 != (_QWORD *)v4);
  }
LABEL_33:
  std::vector<std::weak_ptr<TClientChangeNotifier>>::erase((uint64_t)&TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList, v12, (__int128 *)qword_1EF9B9C18);
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v27);
  v22 = (_QWORD *)*((_QWORD *)v1 + 14);
  if (v22 == (_QWORD *)((char *)v1 + 88))
  {
    v23 = 4;
    v22 = (_QWORD *)((char *)v1 + 88);
  }
  else
  {
    if (!v22)
      goto LABEL_38;
    v23 = 5;
  }
  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_38:
  v24 = (_QWORD *)*((_QWORD *)v1 + 10);
  if (v24 == (_QWORD *)((char *)v1 + 56))
  {
    v25 = 4;
    v24 = (_QWORD *)((char *)v1 + 56);
  }
  else
  {
    if (!v24)
      goto LABEL_43;
    v25 = 5;
  }
  (*(void (**)(void))(*v24 + 8 * v25))();
LABEL_43:

  v26 = (std::__shared_weak_count *)*((_QWORD *)v1 + 1);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
}

TDSNotifier **ReleaseNotifier(TDSNotifier *a1)
{
  TDSNotifier *v2;

  v2 = a1;
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v2);
}

TDSNotifier **TDSNotifier::HandleDeferredTickleOnMainRunLoop(TDSNotifier *this, __CFRunLoopTimer *a2, void *a3)
{
  __CFRunLoop *Main;
  TDSNotifier *v7;

  v7 = (TDSNotifier *)a2;
  if (a2)
  {
    TRefCount::Retain<int>((unsigned int *)a2 + 9);
    TDSNotifier::HandleDeferredTickle((TDSNotifier *)a2);
  }
  Main = CFRunLoopGetMain();
  CFRunLoopRemoveTimer(Main, (CFRunLoopTimerRef)this, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v7);
}

void sub_1CBCF1BC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

uint64_t TDSNotifier::TDSNotifier(uint64_t a1, uint64_t *a2, id *a3, id *a4)
{
  id *v7;
  id *v8;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v7 = (id *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v8 = (id *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = 0x100000000;
  *(_QWORD *)(a1 + 53) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)a1, a2);
  objc_storeStrong(v7, *a3);
  objc_storeStrong(v8, *a4);
  *(_QWORD *)(a1 + 72) = 200000;
  return a1;
}

void ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke(uint64_t a1)
{
  TClientChangeNotifier::HandleEvents(*(TClientChangeNotifier **)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__0(uint64_t a1)
{
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 32);
}

void ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[4];
  uint64_t v12;
  std::__shared_weak_count *v13;

  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3321888768;
  v11[2] = ___ZZN21TClientChangeNotifier6WakeUpEvENK3__1clEv_block_invoke;
  v11[3] = &__block_descriptor_48_ea8_32c57_ZTSKZZN21TClientChangeNotifier6WakeUpEvENK3__1clEvEUlvE__e5_v8__0l;
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
    v12 = v1;
    v13 = v2;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 32);
    v13 = 0;
  }
  ExceptionSafeBlock(v11);
  if (v2)
  {
    v6 = (unint64_t *)&v2->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_1CBCF1D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;

  if (a14)
    ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2_cold_2(a14);
  ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2_cold_1(v14 == 0, v14);
  _Unwind_Resume(a1);
}

void TDSNotifier::Register(TDSNotifier *a1, FINode **a2, FINode **a3, uint64_t a4)
{
  TDSMutex *RegistrationLock;
  TNode *v9;
  uint64_t v10;
  TNode *v11;
  uint64_t NotifierList;
  uint64_t v13;
  os_unfair_lock_s *v14;
  uint64_t v15;
  TNode *v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  os_unfair_lock_s *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  os_unfair_lock_s *v25;
  int v26;
  unint64_t *v27;
  unint64_t v28;
  TNode *v29;
  const TNode *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int v33;
  TNode *v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  NSObject *v38;
  TNode *v39;
  TNode *v40;
  TNode *v41;
  TNodeEvent *v42;
  TDSNotifier *v43;
  TNode *v44;
  int v45;
  TNode *v46;
  int IsPopulated;
  int v48;
  const TNode *v49;
  TGlobalNodes *v50;
  uint64_t v51;
  os_unfair_lock_s *v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  os_unfair_lock_s *v57;
  int v58;
  unint64_t *v59;
  unint64_t v60;
  TNode *v61;
  TNode *v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  NSObject *v67;
  uint64_t v68;
  os_unfair_lock_s *v69;
  std::__shared_weak_count *v70;
  uint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  os_unfair_lock_s *v74;
  int v75;
  unint64_t *v76;
  unint64_t v77;
  TNode *v78;
  TNode *v79;
  unsigned int v80;
  TNode *v81;
  unsigned int *v82;
  unsigned int v83;
  unsigned int v84;
  NSObject *v85;
  TFSInfo *v86;
  TNode *v87;
  unsigned int *v88;
  unsigned int v89;
  unsigned int v90;
  TNode *v91;
  NSObject *v92;
  TDSNotifier *v93;
  int v94;
  unsigned int *v95;
  unsigned int v96;
  TNode *v97;
  TString v98;
  TString v99;
  TDSNotifier *v100;
  char v101;
  TPropertyValue buf;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock(a1);
  TDSMutex::lock(RegistrationLock);
  v9 = (TNode *)TNodeFromFINode(*a2);
  TNode::FindRegistration(v9, (uint64_t)a1, a3, &v100);
  if (!v100)
  {
    v10 = operator new();
    buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = TDSNotifier::TDSNotifier(v10, (uint64_t *)a1, (id *)a2, (id *)a3);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(&v100, (TDSNotifier **)&buf);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&buf);
    v11 = (TNode *)TNodeFromFINode(*a2);
    NotifierList = TNode::GetNotifierList(v11);
    TNotifierList::AddNotifier(NotifierList, (uint64_t *)&v100);
  }
  if ((a4 & 1) != 0)
  {
    v13 = TNodeFromFINode(*a2);
    v14 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v13);
    os_unfair_lock_lock(v14);
    TNodePtr::TNodePtr((TNodePtr *)&buf, *(const TNode **)(v13 + 48));
    os_unfair_lock_unlock(v14);
    if (TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value))
    {
      v15 = TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);
      TChildrenList::IncrementRegisteredChildrenCount(*(TChildrenList **)(v15 + 56));
    }

  }
  if ((a4 & 0x40) == 0)
    goto LABEL_11;
  v16 = (TNode *)TNodeFromFINode(*a2);
  v17 = (unsigned int *)(TNode::GetNotifierList(v16) + 16);
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 + 1, v17));
  if (!v18)
  {
    v30 = (const TNode *)TNodeFromFINode(*a2);
    memset(&buf, 0, sizeof(buf));
    TNode::RequestInternalTask(v30, 1004, &buf, 0);
    TPropertyValue::~TPropertyValue(&buf);
    if ((a4 & 2) == 0)
      goto LABEL_50;
  }
  else
  {
LABEL_11:
    if ((a4 & 2) == 0)
      goto LABEL_50;
  }
  v19 = TNodeFromFINode(*a2);
  v20 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v19);
  os_unfair_lock_lock(v20);
  v22 = *(_QWORD *)(v19 + 16);
  v21 = *(std::__shared_weak_count **)(v19 + 24);
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v20);
  v25 = (os_unfair_lock_s *)(v22 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v22 + 100));
  v26 = *(_DWORD *)(v22 + 115);
  os_unfair_lock_unlock(v25);
  if (!v21)
    goto LABEL_19;
  v27 = (unint64_t *)&v21->__shared_owners_;
  do
    v28 = __ldaxr(v27);
  while (__stlxr(v28 - 1, v27));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
    if ((v26 & 0x20) != 0)
      goto LABEL_25;
  }
  else
  {
LABEL_19:
    if ((v26 & 0x20) != 0)
      goto LABEL_25;
  }
  v29 = (TNode *)TNodeFromFINode(*a2);
  if (!TNode::AliasIsContainer(v29))
    goto LABEL_50;
LABEL_25:
  v31 = atomic_load((unsigned int *)v100 + 11);
  v32 = (unsigned int *)((char *)v100 + 44);
  do
    v33 = __ldaxr(v32);
  while (__stlxr(v33 + 1, v32));
  v34 = (TNode *)TNodeFromFINode(*a2);
  v35 = TNode::GetNotifierList(v34);
  do
  {
    v36 = __ldaxr((unsigned int *)v35);
    v37 = v36 + 1;
  }
  while (__stlxr(v36 + 1, (unsigned int *)v35));
  if ((v36 & 0x80000000) != 0)
  {
    LogObj(5);
    v38 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
      buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v37;
      _os_log_impl(&dword_1CBC4A000, v38, OS_LOG_TYPE_ERROR, "Incorrect childRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
    }

  }
  else if (!v36)
  {
    atomic_store(1u, (unsigned __int8 *)(v35 + 20));
  }
  if (!v31)
  {
    v39 = (TNode *)TNodeFromFINode(*a2);
    if ((TNode::AliasIsContainer(v39) & 1) == 0)
    {
      v40 = (TNode *)TNodeFromFINode(*a2);
      if ((TNode::IsPopulated(v40) & 1) == 0)
      {
        v41 = (TNode *)TNodeFromFINode(*a2);
        if (TNode::IsInitialPopulating(v41))
        {
          TNodeFromFINode(*a2);
          TFSInfo::MarkAsUsed((TFSInfo *)9);
          TNodeEvent::CreateNodeEvent(9, (id *)a2, 0, &buf);
          v42 = (TNodeEvent *)TNodeEventPtr::operator->(&buf);
          TNodeEvent::Notify(v42, &v100, 1);
          TNodeEventPtr::~TNodeEventPtr((id *)&buf);
        }
      }
      v43 = v100;
      *((_DWORD *)v100 + 8) = a4;
      TReferenceCounted::Make<TDSNotifier *>(1852798054, (uint64_t)v43, (uint64_t *)&v99);
      v44 = (TNode *)TNodeFromFINode(*a2);
      if (TNode::VirtualType(v44))
      {
        v45 = 0;
      }
      else
      {
        v46 = (TNode *)TNodeFromFINode(*a2);
        IsPopulated = TNode::IsPopulated(v46);
        if (IsPopulated)
          v45 = 0x40000;
        else
          v45 = 0;
        if ((a4 & 0x20) != 0)
        {
          v97 = (TNode *)TNodeFromFINode(*a2);
          v48 = TNode::SetPrefetchPropertiesOnSync(v97) & (IsPopulated ^ 1);
          goto LABEL_47;
        }
      }
      v48 = 0;
LABEL_47:
      v49 = (const TNode *)TNodeFromFINode(*a2);
      TPropertyValue::TPropertyValue<TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>((uint64_t)&buf, (uint64_t *)&v99);
      TNode::RequestInternalTask(v49, 1003, &buf, v45);
      TPropertyValue::~TPropertyValue(&buf);
      if (v48)
      {
        v50 = (TGlobalNodes *)TNodeFromFINode(*a2);
        TNode::RequestSynchronize(v50, 0);
      }
      TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef((TReferenceCounted **)&v99);
    }
  }
LABEL_50:
  if ((a4 & 4) == 0)
    goto LABEL_70;
  v51 = TNodeFromFINode(*a2);
  v52 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v51);
  os_unfair_lock_lock(v52);
  v54 = *(_QWORD *)(v51 + 16);
  v53 = *(std::__shared_weak_count **)(v51 + 24);
  if (v53)
  {
    v55 = (unint64_t *)&v53->__shared_owners_;
    do
      v56 = __ldxr(v55);
    while (__stxr(v56 + 1, v55));
  }
  os_unfair_lock_unlock(v52);
  v57 = (os_unfair_lock_s *)(v54 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v54 + 100));
  v58 = *(_DWORD *)(v54 + 115);
  os_unfair_lock_unlock(v57);
  if (!v53)
    goto LABEL_58;
  v59 = (unint64_t *)&v53->__shared_owners_;
  do
    v60 = __ldaxr(v59);
  while (__stlxr(v60 - 1, v59));
  if (!v60)
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    if ((v58 & 0x20) == 0)
    {
LABEL_59:
      v61 = (TNode *)TNodeFromFINode(*a2);
      if (!TNode::AliasIsContainer(v61))
        goto LABEL_70;
    }
  }
  else
  {
LABEL_58:
    if ((v58 & 0x20) == 0)
      goto LABEL_59;
  }
  ++*((_DWORD *)v100 + 12);
  v62 = (TNode *)TNodeFromFINode(*a2);
  v63 = (unsigned int *)(TNode::GetNotifierList(v62) + 4);
  do
  {
    v64 = __ldaxr(v63);
    v65 = v64 + 1;
  }
  while (__stlxr(v64 + 1, v63));
  if ((v64 & 0x80000000) != 0)
  {
    LogObj(5);
    v67 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
      buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v65;
      _os_log_impl(&dword_1CBC4A000, v67, OS_LOG_TYPE_ERROR, "Incorrect deepChildRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
    }

  }
  else if (!v64)
  {
    v66 = TNodeFromFINode(*a2);
    TNode::GetPath(v66, 1, (uint64_t)&buf);
    TString::TString(&v98, "", 0);
    fstd::optional_err<TString,int>::value_or<TString>((uint64_t)&buf, (CFTypeRef *)&v98.fString.fRef, &v99);
    TSystemNotificationTask::StartObservingDirectory((TString **)&v99, (const TString *)1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v99.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v98.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&buf);
  }
LABEL_70:
  if ((a4 & 8) == 0)
    goto LABEL_90;
  v68 = TNodeFromFINode(*a2);
  v69 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v68);
  os_unfair_lock_lock(v69);
  v71 = *(_QWORD *)(v68 + 16);
  v70 = *(std::__shared_weak_count **)(v68 + 24);
  if (v70)
  {
    v72 = (unint64_t *)&v70->__shared_owners_;
    do
      v73 = __ldxr(v72);
    while (__stxr(v73 + 1, v72));
  }
  os_unfair_lock_unlock(v69);
  v74 = (os_unfair_lock_s *)(v71 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v71 + 100));
  v75 = *(_DWORD *)(v71 + 115);
  os_unfair_lock_unlock(v74);
  if (!v70)
    goto LABEL_78;
  v76 = (unint64_t *)&v70->__shared_owners_;
  do
    v77 = __ldaxr(v76);
  while (__stlxr(v77 - 1, v76));
  if (!v77)
  {
    ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
    std::__shared_weak_count::__release_weak(v70);
    if ((v75 & 0x20) == 0)
    {
LABEL_79:
      v78 = (TNode *)TNodeFromFINode(*a2);
      if (!TNode::AliasIsContainer(v78))
        goto LABEL_90;
    }
  }
  else
  {
LABEL_78:
    if ((v75 & 0x20) == 0)
      goto LABEL_79;
  }
  v79 = (TNode *)TNodeFromFINode(*a2);
  v80 = atomic_load((unsigned int *)(TNode::GetNotifierList(v79) + 8));
  v81 = (TNode *)TNodeFromFINode(*a2);
  v82 = (unsigned int *)(TNode::GetNotifierList(v81) + 8);
  do
  {
    v83 = __ldaxr(v82);
    v84 = v83 + 1;
  }
  while (__stlxr(v83 + 1, v82));
  if ((v83 & 0x80000000) != 0)
  {
    LogObj(5);
    v85 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
      buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v84;
      _os_log_impl(&dword_1CBC4A000, v85, OS_LOG_TYPE_ERROR, "Incorrect spotlightRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
    }

  }
  ++*((_DWORD *)v100 + 13);
  if (!v80)
  {
    v86 = (TFSInfo *)TNodeFromFINode(*a2);
    TFSInfo::MarkAsUsed(v86);
  }
LABEL_90:
  if ((a4 & 0x10) != 0)
  {
    ++*((_DWORD *)v100 + 14);
    v87 = (TNode *)TNodeFromFINode(*a2);
    v88 = (unsigned int *)(TNode::GetNotifierList(v87) + 12);
    do
    {
      v89 = __ldaxr(v88);
      v90 = v89 + 1;
    }
    while (__stlxr(v89 + 1, v88));
    if ((v89 & 0x80000000) != 0)
    {
      LogObj(4);
      v92 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
      {
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v90;
        _os_log_impl(&dword_1CBC4A000, v92, OS_LOG_TYPE_ERROR, "Incorrect ubiquityRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
      }

    }
    else if (!v89)
    {
      v91 = (TNode *)TNodeFromFINode(*a2);
      TNode::SetShouldSyncUbiquityAttributes(v91, 1);
    }
  }
  v93 = v100;
  v94 = TDSNotifier::CountForOptions(a4);
  v95 = (unsigned int *)((char *)v93 + 40);
  do
    v96 = __ldaxr(v95);
  while (__stlxr(v96 + v94, v95));
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v100);
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v101);
}

void sub_1CBCF25B0(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, int a7, int a8, __int16 a9, char a10, char a11, TPropertyValue *a12, TDSNotifier *a13, int a14, __int16 a15, char a16, char a17)
{
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a13);
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&a17);
  _Unwind_Resume(a1);
}

uint64_t TDSNotifier::CountForOptions(uint64_t a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t end_iter;
  int v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  unint64_t v9;
  unsigned int v11;

  if ((_DWORD)a1)
  {
    v1 = 1;
    v2 = a1;
    do
    {
      if ((v1 & ~(_DWORD)v2) == 0)
        break;
      v2 = v2 & ~v1;
      v1 *= 2;
    }
    while ((_DWORD)v2);
  }
  else
  {
    v2 = 0;
    v1 = 1;
  }
  v3 = a1 | (unint64_t)(v2 << 32);
  end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a1);
  v6 = 0;
  while (v3 != end_iter || v1 != v5)
  {
    v7 = (v1 & HIDWORD(v3)) - 1;
    v8 = v7 > 0x3F;
    v9 = (1 << v7) & 0x800000000000808BLL;
    if (v8 || v9 == 0)
      v6 = v6;
    else
      v6 = (v6 + 1);
    if (HIDWORD(v3))
    {
      v11 = HIDWORD(v3) & ~v1;
      v3 = v3 | ((unint64_t)v11 << 32);
      for (v1 *= 2; v11; v1 *= 2)
      {
        if ((v1 & ~v11) == 0)
          break;
        v11 &= ~v1;
        v3 = v3 | ((unint64_t)v11 << 32);
      }
    }
  }
  return v6;
}

BOOL TDSNotifier::DecrementRegistrationCountForOptions(uint64_t a1, uint64_t a2)
{
  int v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  v3 = TDSNotifier::CountForOptions(a2);
  v4 = (unsigned int *)(a1 + 40);
  do
  {
    v5 = __ldaxr(v4);
    v6 = v5 - v3;
  }
  while (__stlxr(v6, v4));
  return v6 == 0;
}

void sub_1CBCF2888(_Unwind_Exception *a1, uint64_t a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a11);

  _Unwind_Resume(a1);
}

void sub_1CBCF29B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c50_ZTSKZ37__DSProvidersObserver_startObserving_E3__6(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c50_ZTSKZ37__DSProvidersObserver_startObserving_E3__6(uint64_t a1)
{

}

void sub_1CBCF2E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  uint64_t v15;

  TPropertyValue::~TPropertyValue((TPropertyValue *)(v15 - 240));

  _Unwind_Resume(a1);
}

void sub_1CBCF2FA4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1CBCF30B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_1CBCF31CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c74_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E3__9(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c74_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E3__9(uint64_t a1)
{

}

void sub_1CBCF330C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c75_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E4__10(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
}

void __destroy_helper_block_ea8_32c75_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E4__10(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 32));
}

void sub_1CBCF3578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  std::mutex *v23;

  std::mutex::unlock(v23);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c53_ZTSKZ39__DSFPItemStatusObserver_stopObserving_E4__11(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c53_ZTSKZ39__DSFPItemStatusObserver_stopObserving_E4__11(uint64_t a1)
{

}

void sub_1CBCF3830(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  void *v13;

  TPropertyValue::~TPropertyValue((TPropertyValue *)&a13);

  _Unwind_Resume(a1);
}

void sub_1CBCF3AE0(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  void *v13;
  void *v14;
  void *v15;

  TPropertyValue::~TPropertyValue((TPropertyValue *)&a13);

  _Unwind_Resume(a1);
}

void sub_1CBCF3D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;
  void *v10;

  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);

  _Unwind_Resume(a1);
}

void sub_1CBCF3E64(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::weak_ptr<TClientChangeNotifier>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = (_OWORD *)(a7 - 16);
    do
    {
      v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((_QWORD *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
    v1 += 16;
  }
}

void **std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v4;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  while (v1 != v2)
  {
    *(_QWORD *)(a1 + 16) = v1 - 16;
    v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      v1 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t std::vector<std::weak_ptr<TClientChangeNotifier>>::erase(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  char v10;

  if ((__int128 *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *>((uint64_t)&v10, a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v8 = *(std::__shared_weak_count **)(v7 - 8);
        if (v8)
          std::__shared_weak_count::__release_weak(v8);
        v7 -= 16;
      }
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

__int128 *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 *v5;
  __int128 v7;
  std::__shared_weak_count *v8;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      v7 = *v5;
      *(_QWORD *)v5 = 0;
      *((_QWORD *)v5 + 1) = 0;
      v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8)
        std::__shared_weak_count::__release_weak(v8);
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t __copy_helper_block_ea8_32c57_ZTSKZZN21TClientChangeNotifier6WakeUpEvENK3__1clEvEUlvE_(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c57_ZTSKZZN21TClientChangeNotifier6WakeUpEvENK3__1clEvEUlvE_(uint64_t a1)
{
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 32);
}

char *std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__push_back_slow_path<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>(char **a1, uint64_t *a2)
{
  char *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  int64x2_t v18;
  char *v19;
  char *v21;
  int64x2_t v22;
  char *v23;
  _QWORD *v24;

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 3;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 2 > v5)
    v5 = v8 >> 2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v9 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v24 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[8 * v4];
  v21 = v10;
  v22.i64[0] = (uint64_t)v11;
  v22.i64[1] = (uint64_t)v11;
  v23 = &v10[8 * v9];
  v12 = *a2;
  *(_QWORD *)v11 = *a2;
  if (v12)
  {
    TRefCount::Retain<int>((unsigned int *)(v12 + 36));
    v13 = (char *)v22.i64[1];
    v11 = (char *)v22.i64[0];
  }
  else
  {
    v13 = &v10[8 * v4];
  }
  v14 = v13 + 8;
  v22.i64[1] = (uint64_t)(v13 + 8);
  v16 = *a1;
  v15 = a1[1];
  if (v15 == *a1)
  {
    v18 = vdupq_n_s64((unint64_t)v15);
  }
  else
  {
    do
    {
      v17 = *((_QWORD *)v15 - 1);
      v15 -= 8;
      *((_QWORD *)v11 - 1) = v17;
      v11 -= 8;
      *(_QWORD *)v15 = 0;
    }
    while (v15 != v16);
    v18 = *(int64x2_t *)a1;
    v14 = (char *)v22.i64[1];
  }
  *a1 = v11;
  a1[1] = v14;
  v22 = v18;
  v19 = a1[2];
  a1[2] = v23;
  v23 = v19;
  v21 = (char *)v18.i64[0];
  std::__split_buffer<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::~__split_buffer((uint64_t)&v21);
  return v14;
}

void sub_1CBCF4328(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<NSString *>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[17];
  id obj;
  _QWORD v9[8];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)v7, a2);
  v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    v4 = v12;
    if (v12 >= v11 - 1)
    {
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v9, v10, 4);
      v4 = -1;
      v11 = v5;
      v12 = -1;
    }
    if (v10[4] != *(_QWORD *)v9[2])
    {
      objc_enumerationMutation(obj);
      v4 = v12;
    }
    v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1CBCF4420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

id type_traits_extras::CopyAsHelper<NSMutableArray<FPProviderDomain *> * {__strong}>::MakeWithCapacity(uint64_t a1)
{
  return (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", a1);
}

void std::__shared_ptr_emplace<std::shared_ptr<TClientChangeNotifier> MakeShared<TClientChangeNotifier,NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&>(NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&)::MakeInstanceEnabler,std::allocator<std::allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E874EFC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::shared_ptr<TClientChangeNotifier> MakeShared<TClientChangeNotifier,NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&>(NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&)::MakeInstanceEnabler,std::allocator<std::allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E874EFC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<std::shared_ptr<TClientChangeNotifier> MakeShared<TClientChangeNotifier,NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&>(NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&)::MakeInstanceEnabler,std::allocator<std::allocator>>::__on_zero_shared(uint64_t a1)
{
  TClientChangeNotifier::~TClientChangeNotifier((uint64_t (**)(void))(a1 + 24));
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::~__func(uint64_t a1)
{

  return a1;
}

void std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::~__func(uint64_t a1)
{

  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::__clone()
{
  return 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::target_type()
{
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E874EB00;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E874EB00;
  a2[1] = v2;
  return result;
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::operator()(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  v3 = *a2;
  TBlockingEventQueue::EventQueueFromID(*a2, &v7);
  if (v7)
    (*(void (**)(unint64_t))(a1 + 8))(v3);
  v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1CBCF465C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2_cold_2(a10);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::target_type()
{
}

_QWORD *std::__function::__value_func<void ()(OpaqueEventQueue *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1CBCF4824(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E874EB58;
  return result;
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E874EB58;
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::operator()(uint64_t a1, unint64_t *a2)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  TBlockingEventQueue *v5;
  std::__shared_weak_count *v6;

  TBlockingEventQueue::EventQueueFromID(*a2, &v5);
  if (v5)
    TBlockingEventQueue::Tickle(v5);
  v2 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void sub_1CBCF48F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2_cold_2(a10);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::target_type()
{
}

const void **TAutoRef<__CFRunLoopTimer *,CFRetainReleasePolicy>::~TAutoRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

_QWORD *std::shared_ptr<TClientChangeNotifier>::shared_ptr[abi:ne180100]<TClientChangeNotifier,void>(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
LABEL_5:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4)
    goto LABEL_5;
  return a1;
}

void std::__throw_bad_weak_ptr[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE4F80] + 16;
  __cxa_throw(exception, MEMORY[0x1E0DE4E28], MEMORY[0x1E0DE43F0]);
}

void std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E8750028;
  return result;
}

void std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E8750028;
}

uint64_t std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::target_type()
{
}

void sub_1CBCF4D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  va_list va;

  va_start(va, a7);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCF4E5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCF503C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{
  void *v29;
  void *v30;

  objc_sync_exit(v29);
  _Unwind_Resume(a1);
}

void sub_1CBCF5280(_Unwind_Exception *a1, void *a2, void *a3, ...)
{
  TDSNotifier *v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, TDSNotifier *);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCF53EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t TNWNode::TNWNode(uint64_t a1, CFTypeRef cf)
{
  const __CFSet *v3;
  const __CFSet *v4;
  NSString *v5;
  const __CFSet *v6;
  int IsNeighborhood;
  __int16 v8;
  __int16 v9;
  const __CFSet *v10;
  CFSetRef theSet;

  *(_QWORD *)a1 = cf;
  if (cf)
    CFRetain(cf);
  v3 = (const __CFSet *)SFNodeCopyKindString();
  theSet = v3;
  *(_QWORD *)(a1 + 8) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 8), (TString *)v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theSet);
  *(_QWORD *)(a1 + 16) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v4 = (const __CFSet *)SFNodeCopySecondaryName();
  theSet = v4;
  *(_QWORD *)(a1 + 24) = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), (TString *)v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theSet);
  v5 = (NSString *)SFNodeCopyTypeIdentifier();
  TypeForUTI(v5);
  *(_QWORD *)(a1 + 32) = objc_claimAutoreleasedReturnValue();

  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = SFNodeGetPriority();
  *(_BYTE *)(a1 + 56) = SFNodeGetConnectionState();
  *(_WORD *)(a1 + 57) &= 0xFFFCu;
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFFB | (4 * (SFNodeIsServer() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFF7 | (8 * (SFNodeIsSharePoint() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFEF | (16 * (SFNodeSupportsFileSharing() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFDF | (32 * (SFNodeSupportsScreenSharing() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFBF | ((SFNodeIsMounted() != 0) << 6);
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xF87F | ((SFNodeIsContainer() != 0) << 7);
  v6 = (const __CFSet *)SFNodeCopyKinds();
  theSet = v6;
  if (v6)
  {
    *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFFE | (CFSetContainsValue(v6, (const void *)*MEMORY[0x1E0D975E8]) != 0);
    *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFEFF | ((CFSetContainsValue(theSet, (const void *)*MEMORY[0x1E0D975E0]) != 0) << 8);
    *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFDFF | ((CFSetContainsValue(theSet, (const void *)*MEMORY[0x1E0D975D8]) != 0) << 9);
  }
  TRef<__CFSet const*,TRetainReleasePolicy<__CFSet const*>>::~TRef((const void **)&theSet);
  IsNeighborhood = SFNodeIsNeighborhood();
  v8 = *(_WORD *)(a1 + 57);
  if (IsNeighborhood | v8 & 0x100)
    v9 = 2;
  else
    v9 = HIBYTE(*(_WORD *)(a1 + 57)) & 2;
  *(_WORD *)(a1 + 57) = v8 & 0xFFFD | v9;
  if ((v8 & 4) != 0)
  {
    v10 = (const __CFSet *)SFNodeCopyUserName();
    theSet = v10;
    if (*(const __CFSet **)(a1 + 16) != v10)
      TString::SetStringRefAsImmutable((TString *)(a1 + 16), (TString *)v10);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theSet);
  }
  return a1;
}

void sub_1CBCF5754(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  const void **v3;
  const void **v4;
  const void **v5;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)v2);
  _Unwind_Resume(a1);
}

const void **TRef<__CFSet const*,TRetainReleasePolicy<__CFSet const*>>::~TRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

id CopyDeep(NSDictionary *a1)
{
  NSDictionary *v1;
  NSDictionary *v2;
  void *v3;
  void *v4;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    CopyDeepCommon(v1, 0);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithDictionary:", v3);

  }
  else
  {
    v4 = 0;
  }

  return v4;
}

void sub_1CBCF58BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id CopyDeepCommon(NSDictionary *a1, int a2)
{
  NSDictionary *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  NSObject *v10;
  void *v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", -[NSDictionary count](v3, "count"));
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  -[NSDictionary allKeys](v3, "allKeys", 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v14;
    do
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v14 != v7)
          objc_enumerationMutation(v5);
        v9 = *(_QWORD *)(*((_QWORD *)&v13 + 1) + 8 * i);
        -[NSDictionary objectForKeyedSubscript:](v3, "objectForKeyedSubscript:", v9);
        v10 = objc_claimAutoreleasedReturnValue();
        CopyDeepHelper(v10, a2);
        v11 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v4, "setObject:forKeyedSubscript:", v11, v9);
      }
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
    }
    while (v6);
  }

  return v4;
}

void sub_1CBCF5A48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id MutableCopyDeep(NSDictionary *a1)
{
  NSDictionary *v1;
  NSDictionary *v2;
  void *v3;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    CopyDeepCommon(v1, 1);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1CBCF5AE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(const void **a1, char *__s)
{
  int v4;
  size_t v5;
  const void *v6;

  v4 = *((char *)a1 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  if (v5 != strlen(__s))
    return 0;
  if (v4 >= 0)
    v6 = a1;
  else
    v6 = *a1;
  return memcmp(v6, __s, v5) == 0;
}

void TFSVolumeInfo::RecalculateFreeSpaceAndCapacity(TFSVolumeInfo *this, int a2)
{
  TFSInfo *v4;
  const __CFURL *v5;
  unint64_t *v6;
  unint64_t v7;
  const __CFURL *CFURLRef;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  const __CFArray *v18;
  const __CFDictionary *v19;
  uint64_t v20;
  CFIndex Count;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  void *value;
  CFDictionaryRef theDict;
  uint64_t v28;
  uint64_t valuePtr;
  CFURLRef url[3];
  _QWORD v31[3];

  v31[2] = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 123) && !*((_BYTE *)this + 128))
  {
    v4 = (TFSInfo *)*((_QWORD *)this + 7);
    v5 = (const __CFURL *)*((_QWORD *)this + 8);
    url[1] = *((CFURLRef *)this + 7);
    url[2] = v5;
    if (v5)
    {
      v6 = (unint64_t *)((char *)v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    if (v4)
      CFURLRef = TFSInfo::CreateCFURLRef(v4);
    else
      CFURLRef = 0;
    url[0] = CFURLRef;
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    v9 = *((_QWORD *)this + 18);
    v10 = *((_QWORD *)this + 19);
    v28 = v10;
    valuePtr = v9;
    v11 = *((_QWORD *)this + 20);
    v12 = *((_QWORD *)this + 21);
    v13 = *((unsigned __int8 *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
    if (v13)
    {
      v11 = 0;
      v12 = -2;
      v28 = -2;
      valuePtr = -2;
    }
    else if (CFURLRef)
    {
      v25 = v10;
      v14 = (void *)*MEMORY[0x1E0C9B7D0];
      CFURLClearResourcePropertyCacheForKey(CFURLRef, (CFStringRef)*MEMORY[0x1E0C9B7D0]);
      v15 = (void *)*MEMORY[0x1E0C9B690];
      CFURLClearResourcePropertyCacheForKey(url[0], (CFStringRef)*MEMORY[0x1E0C9B690]);
      v16 = v14;
      v31[0] = v16;
      v17 = v15;
      v31[1] = v17;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v31, 2);
      v18 = (const __CFArray *)objc_claimAutoreleasedReturnValue();
      v19 = CFURLCopyResourcePropertiesForKeys(url[0], v18, 0);
      theDict = v19;

      v20 = v25;
      if (v19)
      {
        Count = CFDictionaryGetCount(v19);
        if (Count >= 1)
        {
          if (a2 && v11 < 0)
          {
            if (TFSVolumeInfo::gFullEnvironment && *((_BYTE *)this + 107) && !*((_BYTE *)this + 114))
            {
              TFSVolumeInfo::UpdateReusableSpaceOnVolumes((TFSVolumeInfo *)Count);
              os_unfair_lock_lock((os_unfair_lock_t)this + 78);
              v11 = *((_QWORD *)this + 20);
              os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
            }
            else
            {
              v11 = 0;
            }
          }
          value = 0;
          if (CFDictionaryGetValueIfPresent(theDict, v16, (const void **)&value))
            CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &valuePtr);
          if (CFDictionaryGetValueIfPresent(theDict, v17, (const void **)&value))
          {
            CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &v28);
            v20 = v28;
          }
          if ((valuePtr | v20) >= 0)
            v12 = valuePtr - v20;
          else
            v12 = -2;
          TFSVolumeInfo::GetReclaimableSpace(this);
        }
      }
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&theDict);
    }
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    v22 = v28;
    *((_QWORD *)this + 18) = valuePtr;
    *((_QWORD *)this + 19) = v22;
    *((_QWORD *)this + 20) = v11;
    *((_QWORD *)this + 21) = v12;
    *((_BYTE *)this + 131) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)url);
    if (v5)
    {
      v23 = (unint64_t *)((char *)v5 + 8);
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        (*(void (**)(const __CFURL *))(*(_QWORD *)v5 + 16))(v5);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v5);
      }
    }
  }
}

void sub_1CBCF5E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  const void *v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  va_list va1;
  va_list va2;

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, const void *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, const void *);
  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va1);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

TFSVolumeInfo *TFSVolumeInfo::GetFolderSizingThread@<X0>(TFSVolumeInfo *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *((_QWORD *)this + 45);
  *a2 = *((_QWORD *)this + 44);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

void TFSVolumeInfo::UpdateIterationPerfData(TFSVolumeInfo *this, const TString *a2, double a3, int a4, uint64_t a5)
{
  int v7;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  v7 = (int)a2;
  PerfCountersSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&PerfCountersSpinlock(void)::sPerfCountersSpinlock);
  v10 = (void *)sPerfCounters;
  if (!sPerfCounters)
  {
    v11 = objc_opt_new();
    v12 = (void *)sPerfCounters;
    sPerfCounters = v11;

    v10 = (void *)sPerfCounters;
  }
  objc_msgSend(v10, "objectForKeyedSubscript:", objc_retainAutorelease(*(id *)this));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v13)
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "setObject:forKeyedSubscript:", &unk_1E875ADB8, CFSTR("iterationCount"));
    objc_msgSend((id)sPerfCounters, "setObject:forKeyedSubscript:", v14, objc_retainAutorelease(*(id *)this));
    v13 = v14;
  }
  v15 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("iterationCount"));
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<NSNumber,objc_object * {__strong}>(v16);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "numberWithLong:", objc_msgSend(v17, "longValue") + 1);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v18, CFSTR("iterationCount"));

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a3);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v19, CFSTR("duration"));

  if (v7)
    v20 = &unk_1E875ADD0;
  else
    v20 = &unk_1E875ADB8;
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v20, CFSTR("shouldHaveUsedReaddir"));
  if (a4)
    v21 = &unk_1E875ADD0;
  else
    v21 = &unk_1E875ADB8;
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v21, CFSTR("didUseReaddir"));
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", a5);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v22, CFSTR("numberOfItems"));

  os_unfair_lock_unlock((os_unfair_lock_t)&PerfCountersSpinlock(void)::sPerfCountersSpinlock);
}

void sub_1CBCF60A4(_Unwind_Exception *a1)
{
  void *v1;

  os_unfair_lock_unlock((os_unfair_lock_t)&PerfCountersSpinlock(void)::sPerfCountersSpinlock);
  _Unwind_Resume(a1);
}

void PerfCountersSpinlock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      PerfCountersSpinlock(void)::sPerfCountersSpinlock = 0;
    }
  }
}

id objc_cast<NSNumber,objc_object * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

void TFSVolumeInfo::TrashPath(TFSVolumeInfo *this@<X0>, uint64_t a2@<X1>, TString *a3@<X8>)
{
  os_unfair_lock_s *v6;
  TString **v7;
  _BOOL4 v8;
  TString *v9;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  const void *v13;
  NSURL *v14;
  void *v15;
  id v16;
  int v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  _BOOL4 v22;
  void *v23;
  _BOOL4 v24;
  TString *v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  void *v29;
  const char *v30;
  int v31;
  NSObject *v32;
  const char *v33;
  void *v34;
  uint64_t *v35;
  NSURL *v36;
  void *v37;
  void *v38;
  void *v39;
  id v40;
  id v41;
  TString v42;
  _BYTE buf[12];
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  void *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v7 = (TString **)((char *)this + 400);
  if (*((_BYTE *)this + 408))
  {
    a3->fString.fRef = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable(a3, *v7);
    os_unfair_lock_unlock(v6);
  }
  else
  {
    os_unfair_lock_unlock(v6);
    TFSVolumeInfo::GetMountPoint(this, &v42);
    *(_QWORD *)buf = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)buf, (TString *)CFSTR("/System/Volumes/Update/"));
    v8 = TString::BeginsWith(&v42, (const TString *)buf);
    v9 = (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    if (v8
      || (TString::TString((TString *)buf, "/private/var/mobile", 0x13uLL),
          v11 = CFEqual(v42.fString.fRef, *(CFTypeRef *)buf),
          v9 = (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf),
          v11))
    {
      v10 = TString::KEmptyString(v9);
      a3->fString.fRef = &stru_1E8752DF8;
      CFRetain(&stru_1E8752DF8);
      TString::SetStringRefAsImmutable(a3, (TString *)*v10);
    }
    else
    {
      v12 = *((_QWORD *)this + 7);
      if (!v12)
        goto LABEL_11;
      os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
      v13 = *(const void **)(v12 + 16);
      *(_QWORD *)buf = v13;
      if (v13)
        CFRetain(v13);
      os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
      v14 = (NSURL *)*(id *)buf;
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
      v36 = v14;
      if (v14)
      {
        objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        v41 = 0;
        objc_msgSend(v15, "URLForDirectory:inDomain:appropriateForURL:create:error:", 102, 2, v36, a2, &v41);
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        v16 = v41;

        v17 = 1;
        v18 = v16;
      }
      else
      {
LABEL_11:
        v36 = 0;
        v37 = 0;
        v18 = 0;
        v17 = 0;
      }
      v39 = v18;
      objc_msgSend(v18, "userInfo");
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "objectForKeyedSubscript:", *MEMORY[0x1E0CB3388]);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_cast<NSError,objc_object * {__strong}>(v20);
      v38 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v38, "domain");
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = v21 == (void *)*MEMORY[0x1E0CB2FE0] && objc_msgSend(v38, "code") == 30;

      objc_msgSend(v39, "domain");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      v24 = v23 == (void *)*MEMORY[0x1E0CB28A8] && objc_msgSend(v39, "code") == 3328;

      v26 = v17 ^ 1;
      if (!v39)
        v26 = 1;
      if (((v26 | (v22 || v24)) & 1) == 0)
      {
        LogObj(5);
        v27 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          SanitizedURL(v36);
          v28 = objc_claimAutoreleasedReturnValue();
          v29 = (void *)v28;
          v30 = "get";
          *(_DWORD *)buf = 136446722;
          if ((_DWORD)a2)
            v30 = "create";
          *(_QWORD *)&buf[4] = v30;
          v44 = 2114;
          v45 = v28;
          v46 = 2114;
          v47 = v39;
          _os_log_impl(&dword_1CBC4A000, v27, OS_LOG_TYPE_ERROR, "Failed to %{public}s trash on volume: %{public}@. error: %{public}@", buf, 0x20u);

        }
      }
      if (v37)
        v31 = 1;
      else
        v31 = a2;
      if ((v31 | v22) == 1)
      {
        os_unfair_lock_lock(v6);
        objc_msgSend(v37, "path");
        v40 = (id)objc_claimAutoreleasedReturnValue();
        std::optional<TString>::operator=[abi:ne180100]<NSString * {__strong},void>((uint64_t)this + 400, &v40);

        if (!v39)
        {
          LogObj(5);
          v32 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            if ((_DWORD)a2)
              v33 = "Created";
            else
              v33 = "Found";
            if (!*((_BYTE *)this + 408))
              std::__throw_bad_optional_access[abi:ne180100]();
            SanitizedPath((TString *)this + 50);
            v34 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = v33;
            v44 = 2114;
            v45 = (uint64_t)v34;
            _os_log_impl(&dword_1CBC4A000, v32, OS_LOG_TYPE_DEBUG, "%{public}s volume trash: %{public}@", buf, 0x16u);

          }
        }
        if (!*((_BYTE *)this + 408))
          std::__throw_bad_optional_access[abi:ne180100]();
        a3->fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(a3, *v7);
        os_unfair_lock_unlock(v6);
      }
      else
      {
        v35 = TString::KEmptyString(v25);
        a3->fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(a3, (TString *)*v35);
      }

    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);
  }
}

void sub_1CBCF66C4(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, ...)
{
  void *v8;
  os_unfair_lock_s *v9;
  va_list va;

  va_start(va, a8);

  os_unfair_lock_unlock(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetMountPoint(TFSVolumeInfo *this@<X0>, TString *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 11));
  os_unfair_lock_unlock(v4);
}

void sub_1CBCF6874(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::optional<TString>::operator=[abi:ne180100]<NSString * {__strong},void>(uint64_t a1, id *a2)
{
  TString *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (TString *)*a2;
    if (*(TString **)a1 != v3)
      TString::SetStringRefAsImmutable((TString *)a1, v3);

  }
  else
  {
    std::construct_at[abi:ne180100]<TString,NSString * {__strong},TString*>((TString *)a1, a2);
    *(_BYTE *)(a1 + 8) = 1;
  }
  return a1;
}

void sub_1CBCF68FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

FILE *ReadHiddenList(uint64_t a1, char *__filename)
{
  FILE *result;
  FILE *v4;
  const char *v5;
  size_t v6;
  TString v7;
  char __s[767];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  result = fopen(__filename, "r");
  if (result)
  {
    v4 = result;
    while (fgets(__s, 765, v4))
    {
      v5 = &__s[strspn(__s, " \t")];
      v6 = strcspn(v5, "\n\r\f");
      TString::TString(&v7, v5, v6);
      std::vector<TString>::push_back[abi:ne180100](a1, (TString **)&v7);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
    }
    return (FILE *)fclose(v4);
  }
  return result;
}

void sub_1CBCF6A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::vector<TString>>::operator=[abi:ne180100]<std::vector<TString>,void>(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    std::vector<TString>::__vdeallocate((void **)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

BOOL TFSVolumeInfo::IsHiddenFile(TFSVolumeInfo *this, const TString *a2)
{
  TDSMutex *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  _BOOL8 v9;
  BOOL v10;

  if (!TFSVolumeInfo::MayHaveHiddenList(this))
    return 0;
  v4 = (TDSMutex *)((char *)this + 224);
  TDSMutex::lock((TDSMutex *)((char *)this + 224));
  v5 = *((_QWORD *)this + 24);
  v6 = *((_QWORD *)this + 25);
  if (v5 == v6)
  {
    v9 = 0;
  }
  else
  {
    v7 = v5 + 8;
    do
    {
      v8 = CFEqual(a2->fString.fRef, *(CFTypeRef *)(v7 - 8));
      v9 = v8 != 0;
      if (v8)
        v10 = 1;
      else
        v10 = v7 == v6;
      v7 += 8;
    }
    while (!v10);
  }
  TDSMutex::unlock(v4);
  return v9;
}

void sub_1CBCF6B3C(_Unwind_Exception *a1)
{
  TDSMutex *v1;

  TDSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::GetVolumeFormat(TFSVolumeInfo *this)
{
  return *((__int16 *)this + 36);
}

uint64_t TFSVolumeInfo::VolumeSupportsUNIXPermissions(TFSVolumeInfo *this)
{
  return (*((_DWORD *)this + 18) < 0x15u) & (0x18003Cu >> *((_DWORD *)this + 18));
}

BOOL TFSVolumeInfo::VolumeSupportsAFPPermissions(TFSVolumeInfo *this)
{
  return *((_DWORD *)this + 18) == 13;
}

uint64_t TFSVolumeInfo::VolumeSupportsIgnoreOwnership(TFSVolumeInfo *this)
{
  return (*((_DWORD *)this + 18) < 0x15u) & (0x10000Cu >> *((_DWORD *)this + 18));
}

BOOL TFSVolumeInfo::VolumeShouldShowCapacity(TFSVolumeInfo *this)
{
  return (*((_DWORD *)this + 18) & 0xFFFFFFF7) != 6;
}

uint64_t TFSVolumeInfo::VolumeAllowPermissionChanges(TFSVolumeInfo *this)
{
  return *((unsigned __int8 *)this + 137);
}

const void **TFSVolumeInfo::VolumeFormatString@<X0>(TFSVolumeInfo *this@<X0>, const void **a2@<X8>)
{
  CFTypeRef v4;
  const void *v5;
  CFTypeRef v6;
  const __CFString *v7;
  CFURLRef v8;
  CFTypeRef cf;
  CFTypeRef v11;
  CFStringRef theString;

  *a2 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TFSVolumeInfo::GetMountPoint(this, (TString *)&theString);
  if (CFStringGetLength(theString) >= 1)
  {
    if (theString && (v4 = CFRetain(theString), (v5 = static_cf_cast<__CFString const*,void const*>(v4)) != 0))
    {
      v6 = CFAutorelease(v5);
      v7 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v6);
    }
    else
    {
      v7 = 0;
    }
    v8 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, kCFURLPOSIXPathStyle, 1u);
    v11 = v8;
    if (v8)
    {
      TCFURLInfo::StringProperty(v8, (const __CFString *)*MEMORY[0x1E0C9B6F8], (TString *)&cf);
      if (&cf != a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1E8752DF8);
        if (cf)
          CFRelease(cf);
        cf = &stru_1E8752DF8;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v11);
  }
  if (!CFStringGetLength((CFStringRef)*a2))
  {
    TString::TString((TString *)&v11, "?", 1uLL);
    if (&v11 != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &v11);
      CFRetain(&stru_1E8752DF8);
      if (v11)
        CFRelease(v11);
      v11 = &stru_1E8752DF8;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v11);
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1CBCF6D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  const void **v4;
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  _Unwind_Resume(a1);
}

BOOL TFSVolumeInfo::VolumeFormatFetched(TFSVolumeInfo *this)
{
  os_unfair_lock_s *v2;
  _BOOL8 v3;

  v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v3 = CFStringGetLength(*((CFStringRef *)this + 12)) > 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1CBCF6DB0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetVolumeFormatString(TFSVolumeInfo *this@<X0>, TString *a2@<X8>)
{
  __CFString *v4;

  if (!TFSVolumeInfo::VolumeFormatFetched(this))
  {
    TFSVolumeInfo::VolumeFormatString(this, (const void **)&v4);
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    if ((__CFString **)((char *)this + 96) != &v4)
      TString::SetStringRefAsImmutable((TString *)this + 12, (TString *)v4);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4);
  }
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 12));
}

void sub_1CBCF6E58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_s *v10;

  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetUUID(TFSVolumeInfo *this@<X0>, TString *a2@<X8>)
{
  a2->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 49));
}

void sub_1CBCF6EBC(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::ReusableSpaceOnVolume(TFSVolumeInfo *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  const __CFURL *v6;
  unint64_t *v7;
  unint64_t v8;
  __CFString *v9;
  __CFString *v10;
  void *v11;
  const void *v12;
  const void *Value;
  const __CFNumber *v14;
  const void *v16;
  __CFString *v17;
  _QWORD valuePtr[2];
  CFURLRef anURL;
  _QWORD v20[2];
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 48) || !*((_BYTE *)this + 107))
    return 0;
  v3 = *((_QWORD *)this + 7);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  valuePtr[0] = v3;
  valuePtr[1] = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 100));
  v6 = *(const __CFURL **)(v3 + 16);
  anURL = v6;
  if (v6)
    CFRetain(v6);
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 100));
  if (v2)
  {
    v7 = (unint64_t *)&v2->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  valuePtr[0] = 0;
  v9 = (__CFString *)CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  v17 = v9;
  if (v9)
  {
    v20[0] = CFSTR("CACHE_DELETE_VOLUME");
    v10 = v9;
    v20[1] = CFSTR("CACHE_DELETE_URGENCY");
    v21[0] = v10;
    v21[1] = &unk_1E875ADE8;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v21, v20, 2);
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    v12 = (const void *)CacheDeleteCopyPurgeableSpaceWithInfo();
    v16 = v12;
    if (v12)
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)v12, CFSTR("CACHE_DELETE_AMOUNT"));
      v14 = (const __CFNumber *)static_cf_cast<__CFString const*,void const*>(Value);
      if (v14)
      {
        if (!CFNumberGetValue(v14, kCFNumberLongLongType, valuePtr))
          valuePtr[0] = 0;
      }
    }
    TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v16);

    v1 = valuePtr[0];
  }
  else
  {
    v1 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&anURL);
  return v1;
}

void sub_1CBCF7080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  const void *v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, const void *);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

const void **TFSVolumeInfo::UpdateReusableSpaceOnVolumes(TFSVolumeInfo *this)
{
  void *v1;
  uint64_t v2;
  uint64_t i;
  void *v4;
  void *v5;
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t j;
  void *v11;
  uint64_t v12;
  TString *v13;
  uint64_t VolumeMap;
  uint64_t *v15;
  __CFString *v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_weak_owners;
  unint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  const void *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  __int128 v37;
  char *v38;
  const void **k;
  const void **v40;
  const void *v41;
  const TNode *v42;
  const TNode *v43;
  id obj;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  void *v49;
  const void *v50;
  const void *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  TString v54;
  char v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  __int128 v58;
  _QWORD v59[2];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  _OWORD v68[2];
  int v69;
  void *v70;
  FINode *v71;
  __int128 v72;
  char *v73;
  _QWORD *v74;
  _BYTE v75[128];
  _BYTE v76[128];
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v70 = (void *)CacheDeleteCopyPurgeableSpaceWithInfo();
  objc_msgSend(v70, "objectForKey:", CFSTR("CACHE_DELETE_PURGEABLE_BY_CONTAINER"));
  memset(v68, 0, sizeof(v68));
  v69 = 1065353216;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0u;
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v47, "allKeys");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  obj = v1;
  v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v64, v76, 16);
  if (v2)
  {
    v46 = *(_QWORD *)v65;
    do
    {
      v48 = v2;
      for (i = 0; i != v48; ++i)
      {
        if (*(_QWORD *)v65 != v46)
          objc_enumerationMutation(obj);
        v4 = *(void **)(*((_QWORD *)&v64 + 1) + 8 * i);
        objc_msgSend(v47, "objectForKey:", v4);
        v5 = (void *)objc_claimAutoreleasedReturnValue();
        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        v49 = v5;
        objc_msgSend(v5, "allValues");
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = 0;
        v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v60, v75, 16);
        if (v8)
        {
          v9 = *(_QWORD *)v61;
          do
          {
            for (j = 0; j != v8; ++j)
            {
              if (*(_QWORD *)v61 != v9)
                objc_enumerationMutation(v6);
              objc_msgSend(*(id *)(*((_QWORD *)&v60 + 1) + 8 * j), "objectForKey:", CFSTR("CACHE_DELETE_SHARED_PURGEABLE"));
              v11 = (void *)objc_claimAutoreleasedReturnValue();
              v12 = objc_msgSend(v11, "longLongValue");

              v7 = (uint64_t *)((char *)v7 + v12);
            }
            v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v60, v75, 16);
          }
          while (v8);
        }

        v13 = v4;
        v54.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v54, v13);

        if (operator==((CFTypeRef *)&v54.fString.fRef, "unknown container"))
        {
          TString::SetStringRefAsImmutable(&v54, 0);
          TString::SetFromUTF8(&v54, (const UInt8 *)"disk1", 5);
        }
        v71 = (FINode *)&v54;
        std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)v68, &v54, (uint64_t)&std::piecewise_construct, (TString ***)&v71)[3] = v7;
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v54.fString.fRef);

      }
      v1 = obj;
      v2 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v76, 16);
    }
    while (v2);
  }

  v58 = 0uLL;
  v59[0] = 0;
  VolumeMap = GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  v15 = *(uint64_t **)(VolumeMap + 16);
  if (v15)
  {
    while (1)
    {
      v16 = (__CFString *)v15[2];
      v54.fString.fRef = v16;
      if (v16)
        CFRetain(v16);
      v55 = *((_BYTE *)v15 + 24);
      v17 = (std::__shared_weak_count *)v15[5];
      v56 = v15[4];
      v57 = v17;
      if (!v17)
        break;
      p_shared_weak_owners = (unint64_t *)&v17->__shared_weak_owners_;
      do
        v19 = __ldxr(p_shared_weak_owners);
      while (__stxr(v19 + 1, p_shared_weak_owners));
      v52 = 0;
      v53 = 0;
      if (!v57)
        goto LABEL_29;
      v53 = std::__shared_weak_count::lock(v57);
      if (v53)
      {
        v20 = v56;
        v52 = v56;
        if (v56)
        {
          if (CFStringGetLength(*(CFStringRef *)(v56 + 80)))
          {
            v71 = (FINode *)(v20 + 80);
            v21 = std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)v68, (TString *)(v20 + 80), (uint64_t)&std::piecewise_construct, (TString ***)&v71)[3];
            v20 = v52;
          }
          else
          {
            v21 = (uint64_t *)TFSVolumeInfo::ReusableSpaceOnVolume((TFSVolumeInfo *)v20);
          }
          if (v21 != *(uint64_t **)(v20 + 160))
          {
            v25 = *(const void **)(v20 + 40);
            v51 = v25;
            if (v25)
              CFRetain(v25);
            v26 = (_QWORD *)*((_QWORD *)&v58 + 1);
            if (*((_QWORD *)&v58 + 1) >= v59[0])
            {
              v28 = (_QWORD *)v58;
              v29 = (uint64_t)(*((_QWORD *)&v58 + 1) - v58) >> 3;
              v30 = v29 + 1;
              if ((unint64_t)(v29 + 1) >> 61)
                std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
              v31 = v59[0] - v58;
              if ((uint64_t)(v59[0] - v58) >> 2 > v30)
                v30 = v31 >> 2;
              if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
                v32 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v32 = v30;
              v74 = v59;
              if (v32)
              {
                v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v59, v32);
                v26 = (_QWORD *)*((_QWORD *)&v58 + 1);
                v28 = (_QWORD *)v58;
              }
              else
              {
                v33 = 0;
              }
              v34 = &v33[8 * v29];
              v35 = &v33[8 * v32];
              v73 = v35;
              *(_QWORD *)v34 = v51;
              v51 = 0;
              *((_QWORD *)&v72 + 1) = v34 + 8;
              if (v26 == v28)
              {
                v27 = v34 + 8;
              }
              else
              {
                do
                {
                  v36 = *--v26;
                  *((_QWORD *)v34 - 1) = v36;
                  v34 -= 8;
                  *v26 = 0;
                }
                while (v26 != v28);
                v27 = (_QWORD *)*((_QWORD *)&v72 + 1);
                v35 = v73;
              }
              v37 = v58;
              *(_QWORD *)&v58 = v34;
              *((_QWORD *)&v58 + 1) = v27;
              v72 = v37;
              v38 = (char *)v59[0];
              v59[0] = v35;
              v73 = v38;
              v71 = (FINode *)v37;
              std::__split_buffer<ROSPVolumeID>::~__split_buffer((uint64_t)&v71);
            }
            else
            {
              **((_QWORD **)&v58 + 1) = v51;
              v27 = v26 + 1;
              v51 = 0;
            }
            *((_QWORD *)&v58 + 1) = v27;
            TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v51);
            os_unfair_lock_lock((os_unfair_lock_t)(v20 + 312));
            *(_QWORD *)(v52 + 160) = v21;
            os_unfair_lock_unlock((os_unfair_lock_t)(v20 + 312));
          }
        }
        goto LABEL_29;
      }
LABEL_34:
      if (v57)
        std::__shared_weak_count::__release_weak(v57);
      TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v54.fString.fRef);
      v15 = (uint64_t *)*v15;
      if (!v15)
        goto LABEL_59;
    }
    v52 = 0;
    v53 = 0;
LABEL_29:
    v22 = v53;
    if (v53)
    {
      p_shared_owners = (unint64_t *)&v53->__shared_owners_;
      do
        v24 = __ldaxr(p_shared_owners);
      while (__stlxr(v24 - 1, p_shared_owners));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    goto LABEL_34;
  }
LABEL_59:
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  v40 = (const void **)*((_QWORD *)&v58 + 1);
  for (k = (const void **)v58; k != v40; ++k)
  {
    v41 = *k;
    v50 = v41;
    if (v41)
      CFRetain(v41);
    TNode::GetVolumeNode(&v50, (TNodePtr *)&v71);
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v50);
    if (TNodeFromFINode(v71))
    {
      v42 = (const TNode *)TNodeFromFINode(v71);
      TNode::SendNotification(v42, 2, (id *)&v71, 1919251312, 0);
      v43 = (const TNode *)TNodeFromFINode(v71);
      TNode::SendNotification(v43, 2, (id *)&v71, 1718776688, 0);
    }

  }
  v71 = (FINode *)&v58;
  std::vector<ROSPVolumeID>::__destroy_vector::operator()[abi:ne180100]((void ***)&v71);
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table((uint64_t)v68);

  return TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&v70);
}

void sub_1CBCF76A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, char a17, uint64_t a18, void **a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,const void *a49)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a16);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  std::pair<VolumeKey const,std::weak_ptr<TFSVolumeInfo>>::~pair((uint64_t)&a19);
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  a19 = (void **)&a23;
  std::vector<ROSPVolumeID>::__destroy_vector::operator()[abi:ne180100](&a19);
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table((uint64_t)&a43);

  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef(&a49);
  _Unwind_Resume(a1);
}

const void **std::pair<VolumeKey const,std::weak_ptr<TFSVolumeInfo>>::~pair(uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)a1);
}

uint64_t TFSVolumeInfo::GetReclaimableSpace(TFSVolumeInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v3 = *((_QWORD *)this + 20) & ~(*((uint64_t *)this + 20) >> 63);
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL TFSVolumeInfo::SpaceAndCapacityAreUpToDate(TFSVolumeInfo *this, int a2)
{
  os_unfair_lock_s *v4;
  _BOOL8 v5;
  BOOL v6;

  v4 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v5 = *((_BYTE *)this + 131) != 0;
  if (*((_BYTE *)this + 131))
    v6 = a2 == 0;
  else
    v6 = 1;
  if (!v6)
    v5 = *((_QWORD *)this + 20) >= 0;
  os_unfair_lock_unlock(v4);
  return v5;
}

void TFSVolumeInfo::InvalidateFreeSpaceAndCapacityOfContainer(TFSVolumeInfo *this)
{
  uint64_t VolumeMap;
  uint64_t *v3;
  const void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  TFSVolumeInfo *v15;
  unsigned __int8 *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  const void *v19;
  char v20;
  unsigned __int8 *v21;
  std::__shared_weak_count *v22;

  if (*((_BYTE *)this + 32))
  {
    VolumeMap = GetVolumeMap();
    VolumeInfoLock();
    os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
    v3 = *(uint64_t **)(VolumeMap + 16);
    if (v3)
    {
      while (1)
      {
        v4 = (const void *)v3[2];
        v19 = v4;
        if (v4)
          CFRetain(v4);
        v20 = *((_BYTE *)v3 + 24);
        v5 = (std::__shared_weak_count *)v3[5];
        v21 = (unsigned __int8 *)v3[4];
        v22 = v5;
        if (!v5)
          goto LABEL_35;
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v7 = __ldxr(p_shared_weak_owners);
        while (__stxr(v7 + 1, p_shared_weak_owners));
        if (!v22)
          goto LABEL_35;
        v8 = std::__shared_weak_count::lock(v22);
        if (v8)
          break;
LABEL_33:
        if (v22)
          std::__shared_weak_count::__release_weak(v22);
LABEL_35:
        TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v19);
        v3 = (uint64_t *)*v3;
        if (!v3)
          goto LABEL_36;
      }
      v9 = v8;
      v10 = (os_unfair_lock_s *)v21;
      if (v21 && v21[32])
      {
        v11 = v21[23];
        if ((v11 & 0x80u) == 0)
          v12 = v21[23];
        else
          v12 = *((_QWORD *)v21 + 1);
        v13 = *((unsigned __int8 *)this + 23);
        v14 = (char)v13;
        if ((v13 & 0x80u) != 0)
          v13 = *((_QWORD *)this + 1);
        if (v12 == v13)
        {
          if (v14 >= 0)
            v15 = this;
          else
            v15 = *(TFSVolumeInfo **)this;
          if ((v11 & 0x80) == 0)
          {
            if (v21[23])
            {
              v16 = v21;
              while (*v16 == *(_BYTE *)v15)
              {
                ++v16;
                v15 = (TFSVolumeInfo *)((char *)v15 + 1);
                if (!--v11)
                  goto LABEL_28;
              }
              goto LABEL_29;
            }
            goto LABEL_28;
          }
          if (!memcmp(*(const void **)v21, v15, *((_QWORD *)v21 + 1)))
          {
LABEL_28:
            os_unfair_lock_lock(v10 + 78);
            HIBYTE(v10[32]._os_unfair_lock_opaque) = 0;
            os_unfair_lock_unlock(v10 + 78);
          }
        }
      }
LABEL_29:
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      goto LABEL_33;
    }
LABEL_36:
    os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    *((_BYTE *)this + 131) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
  }
}

void sub_1CBCF7A6C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::VolumeSize(TFSVolumeInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v3 = *((_QWORD *)this + 21);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TFSVolumeInfo::GetCapacity(TFSVolumeInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v3 = *((_QWORD *)this + 18);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TFSVolumeInfo::GetFreeSpace(TFSVolumeInfo *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  v3 = *((_QWORD *)this + 19);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t std::optional<TString>::operator=[abi:ne180100]<TString,void>(uint64_t a1, const void **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if ((const void **)a1 != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)a1, a2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1E8752DF8);
    }
  }
  else
  {
    std::construct_at[abi:ne180100]<TString,TString,TString*>((CFTypeRef *)a1, a2);
    *(_BYTE *)(a1 + 8) = 1;
  }
  return a1;
}

TString *TString::operator+@<X0>(const __CFString **a1@<X0>, const TString *a2@<X1>, TString *a3@<X8>)
{
  const __CFString *v5;
  CFMutableStringRef MutableCopy;

  v5 = *a1;
  a3->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v5);
  if (a3->fString.fRef)
    CFRelease(a3->fString.fRef);
  a3->fString.fRef = MutableCopy;
  return TString::Append(a3, a2);
}

void sub_1CBCF7C0C(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

__n128 std::__optional_storage_base<std::pair<std::string,unsigned char>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::pair<std::string,unsigned char>,false>>(uint64_t a1, __n128 *a2)
{
  __n128 result;

  if (*(unsigned __int8 *)(a1 + 32) == a2[2].n128_u8[0])
  {
    if (*(_BYTE *)(a1 + 32))
    {
      if (*(char *)(a1 + 23) < 0)
        operator delete(*(void **)a1);
      result = *a2;
      *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = result;
      a2[1].n128_u8[7] = 0;
      a2->n128_u8[0] = 0;
      *(_BYTE *)(a1 + 24) = a2[1].n128_u8[8];
    }
  }
  else if (*(_BYTE *)(a1 + 32))
  {
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
    *(_BYTE *)(a1 + 32) = 0;
  }
  else
  {
    result = *a2;
    *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(_BYTE *)(a1 + 24) = a2[1].n128_u8[8];
    *(_BYTE *)(a1 + 32) = 1;
  }
  return result;
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5048] + 16;
  __cxa_throw(exception, MEMORY[0x1E0DE4E90], MEMORY[0x1E0DE4380]);
}

TString *std::construct_at[abi:ne180100]<TString,NSString * {__strong},TString*>(TString *a1, id *a2)
{
  TString *v3;

  v3 = (TString *)*a2;
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, v3);

  return a1;
}

void sub_1CBCF7D60(_Unwind_Exception *a1)
{
  void *v1;
  const void **v2;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<ROSPVolumeID>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<ROSPVolumeID>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,void>@<X0>(unsigned __int8 *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,std::allocator<TFSInfo>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCF7E84(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,std::allocator<TFSInfo>,0>(_QWORD *a1, unsigned __int8 *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2);
  return a1;
}

void sub_1CBCF7ED4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::pair<VolumeKey const,std::weak_ptr<TFSVolumeInfo>>::~pair((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

_QWORD *std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>@<X0>(const TFSVolumeInfo **a1@<X1>, const char **a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x28uLL);
  result = std::__shared_ptr_emplace<TVolumeSyncThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,char const*&,std::allocator<TVolumeSyncThread>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1CBCF7F78(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TVolumeSyncThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,char const*&,std::allocator<TVolumeSyncThread>,0>(_QWORD *a1, const TFSVolumeInfo **a2, const char **a3)
{
  a1[2] = 0;
  *a1 = &unk_1E8750650;
  a1[1] = 0;
  TVolumeSyncThread::TVolumeSyncThread((TVolumeSyncThread *)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1CBCF7FCC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TVolumeSyncThread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750650;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TVolumeSyncThread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750650;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

_QWORD *std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>@<X0>(const TFSVolumeInfo **a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x28uLL);
  result = std::__shared_ptr_emplace<TFolderSizingThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,std::allocator<TFolderSizingThread>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCF8070(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFolderSizingThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,std::allocator<TFolderSizingThread>,0>(_QWORD *a1, const TFSVolumeInfo **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1E87506C0;
  TFolderSizingThread::TFolderSizingThread((TFolderSizingThread *)(a1 + 3), *a2);
  return a1;
}

void sub_1CBCF80C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFolderSizingThread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87506C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFolderSizingThread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87506C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint64_t ***v13;
  uint64_t **i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v8 = FowlerNollVoHash::hash(this, this);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v10)
        v4 = v8 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v8;
    }
    v13 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (uint64_t **)*i)
      {
        v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef))
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, (__CFString *)v9, a4, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (uint64_t **)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1CBCF838C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

TString *std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  TString *v8;
  TString *result;

  v7 = a1 + 16;
  v8 = (TString *)operator new(0x20uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  v8->fString.fRef = 0;
  v8[1].fString.fRef = a2;
  result = std::pair<TString const,long long>::pair[abi:ne180100]<TString const&>(v8 + 2, *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1CBCF83F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

TString *std::pair<TString const,long long>::pair[abi:ne180100]<TString const&>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = 0;
  return a1;
}

void sub_1CBCF8454(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I13TFSVolumeInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  char *v2;
  uint64_t result;

  v2 = (char *)operator new(0x1C0uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI13TFSVolumeInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_1CBCF849C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI13TFSVolumeInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_1E87505A8;
  *(_QWORD *)(a1 + 8) = 0;
  TFSVolumeInfo::TFSVolumeInfo((TFSVolumeInfo *)(a1 + 24));
  return a1;
}

void sub_1CBCF84E8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFSVolumeInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87505A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSVolumeInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E87505A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t TFSInfoSizer::TFSInfoSizer(uint64_t a1, id *a2, id *a3, uint64_t *a4, uint64_t a5)
{
  id *v9;
  _QWORD *v10;

  v9 = (id *)(a1 + 8);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  v10 = (_QWORD *)(a1 + 72);
  objc_storeStrong((id *)a1, *a2);
  objc_storeStrong(v9, *a3);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v10, a4);
  *(_QWORD *)(a1 + 88) = a5;
  *(_BYTE *)(a1 + 96) = 0;
  return a1;
}

void TFSInfoSizerCompanion::~TFSInfoSizerCompanion(id *this)
{
  void **v2;

  *this = &off_1E874FE20;

  v2 = this + 2;
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void **v2;

  *this = &off_1E874FE20;

  v2 = this + 2;
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1D17A53D0](this, 0xA1C409A6BAFF5);
}

uint64_t TFSInfoSizerCompanion::NewIteration(uint64_t a1, CFIndex *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  FINode *v7;
  CFIndex v8;
  TNode *v9;
  id v10;
  TNode *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  TNode *v18;
  CFIndex v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  uint64_t v30;
  os_unfair_lock_s *v31;
  std::__shared_weak_count *v32;
  TFSInfo *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  TNode *v41;
  uint64_t CachedPackageSize;
  uint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  char *v48;
  _BYTE v49[32];
  uint64_t v50;
  __int128 v51;
  TString v52;
  id v53;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  v4 = (uint64_t *)(a1 + 16);
  v53 = 0;
  if (v5 == v6)
  {
    v10 = *(id *)(a1 + 40);
    v53 = v10;
  }
  else
  {
    v7 = (FINode *)*(id *)(v6 - 64);
    if (TNodeFromFINode(v7))
    {
      v8 = *a2;
      TCFURLInfo::CheckPrefetchState(*a2, 1);
      if ((*(_WORD *)(v8 + 76) & 4) != 0)
      {
        v11 = (TNode *)TNodeFromFINode(v7);
        TCFURLInfo::Name((TCFURLInfo *)*a2, &v52);
        TNode::FindChild(v11, (TNode *)&v52, 0, 0, (void **)&v48);
      }
      else
      {
        v9 = (TNode *)TNodeFromFINode(v7);
        TCFURLInfo::Name((TCFURLInfo *)*a2, &v52);
        TNode::FindChildButDontSynchronize(v9, (TNode *)&v52, (void **)&v48);
      }
      TNodePtr::operator=(&v53, (void **)&v48);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v52.fString.fRef);
    }

    v10 = v53;
  }
  v12 = *(_QWORD **)(a1 + 8);
  v14 = v12[11];
  v13 = v12[12];
  v15 = v12[13];
  v16 = v12[16];
  v48 = (char *)v10;
  v17 = TNodeFromFINode((FINode *)v53);
  if (v17)
  {
    v18 = (TNode *)TNodeFromFINode((FINode *)v53);
    LODWORD(v17) = TNode::SizingGeneration(v18);
  }
  *(_DWORD *)v49 = v17;
  v49[4] = 0;
  *(_QWORD *)&v49[8] = v15;
  *(_QWORD *)&v49[16] = v16;
  *(_QWORD *)&v49[24] = v13;
  v50 = v14;
  v19 = a2[1];
  *(_QWORD *)&v51 = *a2;
  *((_QWORD *)&v51 + 1) = v19;
  if (v19)
  {
    v20 = (unint64_t *)(v19 + 8);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v22 = *(_QWORD **)(a1 + 24);
  if ((unint64_t)v22 >= *(_QWORD *)(a1 + 32))
  {
    v26 = std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__push_back_slow_path<TFSInfoSizerCompanion::TFolderStatistics>(v4, (uint64_t)&v48);
    v27 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
    *(_QWORD *)(a1 + 24) = v26;
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldaxr(p_shared_owners);
      while (__stlxr(v29 - 1, p_shared_owners));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
  }
  else
  {
    v23 = TNodePtr::TNodePtr(v22, (id *)&v48);
    v24 = *(_OWORD *)v49;
    v25 = *(_OWORD *)&v49[16];
    v23[5] = v50;
    *(_OWORD *)(v23 + 3) = v25;
    *(_OWORD *)(v23 + 1) = v24;
    *((_OWORD *)v23 + 3) = v51;
    v51 = 0uLL;
    *(_QWORD *)(a1 + 24) = v23 + 8;
  }

  if (v5 == v6 || !TNodeFromFINode((FINode *)v53))
  {
    v39 = 0;
  }
  else
  {
    v30 = TNodeFromFINode((FINode *)v53);
    v31 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v30);
    os_unfair_lock_lock(v31);
    v33 = *(TFSInfo **)(v30 + 16);
    v32 = *(std::__shared_weak_count **)(v30 + 24);
    if (v32)
    {
      v34 = (unint64_t *)&v32->__shared_owners_;
      do
        v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
    }
    os_unfair_lock_unlock(v31);
    TFSInfo::FolderStats(v33, &v48);
    if (v49[24])
    {
      v36 = *(_QWORD *)(a1 + 8);
      v37 = *(_QWORD *)v49;
      v38 = &v48[*(_QWORD *)(v36 + 104)];
      *(int64x2_t *)(v36 + 88) = vaddq_s64(*(int64x2_t *)(v36 + 88), (int64x2_t)vextq_s8(*(int8x16_t *)&v49[8], *(int8x16_t *)&v49[8], 8uLL));
      *(_QWORD *)(v36 + 104) = v38;
      *(_QWORD *)(v36 + 128) += v37;
      v39 = 1;
    }
    else
    {
      v40 = TNodeFromFINode((FINode *)v53);
      if (TNode::IsDeferredForSymlink(v40, (uint64_t (*)(_QWORD *))TFSInfo::IsPackage, 0))
      {
        v41 = (TNode *)TNodeFromFINode((FINode *)v53);
        CachedPackageSize = TNode::GetCachedPackageSize(v41);
        v39 = 0;
        if (CachedPackageSize != -2 && v43 != -2)
        {
          v44 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)(v44 + 104) += CachedPackageSize;
          *(_QWORD *)(v44 + 128) += v43;
          v39 = 1;
          *(int64x2_t *)(v44 + 88) = vaddq_s64(*(int64x2_t *)(v44 + 88), vdupq_n_s64(1uLL));
        }
      }
      else
      {
        v39 = 0;
      }
    }
    if (v32)
    {
      v45 = (unint64_t *)&v32->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
  }

  return v39;
}

void sub_1CBCF8A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void TFSInfoSizerCompanion::FinishIteration(TFSInfoSizerCompanion *this, char a2)
{
  char *v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  __int128 v8;
  FINode *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  int v15;
  FINode v16;
  TNode *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  int v30;
  int v31;
  TNode *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  TNodePtr v43;
  std::__shared_weak_count *v44;
  FINode *v45[2];
  std::__shared_weak_count *v46;
  id v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  FINode *v51;
  std::__shared_weak_count *v52;

  v4 = (char *)this + 16;
  v5 = *((_QWORD *)this + 3);
  v6 = *(id *)(v5 - 64);
  v47 = v6;
  v7 = *(_QWORD *)(v5 - 24);
  v8 = *(_OWORD *)(v5 - 56);
  v49 = *(_OWORD *)(v5 - 40);
  v48 = v8;
  v50 = v7;
  v9 = *(FINode **)(v5 - 16);
  v51 = v9;
  v10 = *(std::__shared_weak_count **)(v5 - 8);
  v52 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__base_destruct_at_end[abi:ne180100]((uint64_t)v4, *((_QWORD *)this + 3) - 64);
  v45[1] = v9;
  v46 = v10;
  if (v10)
  {
    v13 = (unint64_t *)&v10->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v45[0] = (FINode *)v6;
  v15 = v48;
  if (TNodeFromFINode(v45[0]))
  {
    v16.super.isa = v9->super.isa;
    v17 = (TNode *)TNodeFromFINode(v45[0]);
    TNode::CFURL(v17, &v43);
    LOBYTE(v16.super.isa) = IsEqual(v16.super.isa, v43.fFINode);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v43.fFINode);
    if (((uint64_t)v16.super.isa & 1) == 0)
    {
      TNodePtr::TNodePtr(&v43, 0);
      TNodePtr::operator=((void **)v45, (void **)&v43.fFINode);

    }
  }
  if ((a2 & 1) == 0)
  {
    v18 = *((_QWORD *)&v48 + 1);
    v41 = v49;
    v42 = v50;
    v19 = (_QWORD *)*((_QWORD *)this + 1);
    v20 = v19[11];
    v21 = v19[13];
    v22 = v19[16];
    v40 = BYTE4(v48);
    v23 = v19[12] - *((_QWORD *)&v49 + 1);
    if (!TNodeFromFINode(v45[0]) && (v23 > 1000 || *((_QWORD *)this + 3) - *((_QWORD *)this + 2) <= 0xBFuLL))
    {
      v43.fFINode = (FINode *)v9->super.isa;
      TNode::GetNodeFromURL((CFURLRef *)&v43, (TNodePtr *)v45, 0);
    }
    if (TNodeFromFINode(v45[0]))
    {
      v24 = TNodeFromFINode(v45[0]);
      v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
      os_unfair_lock_lock(v25);
      v27 = *(_QWORD *)(v24 + 16);
      v26 = *(std::__shared_weak_count **)(v24 + 24);
      v43.fFINode = (FINode *)v27;
      v44 = v26;
      if (v26)
      {
        v28 = (unint64_t *)&v26->__shared_owners_;
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      os_unfair_lock_unlock(v25);
      os_unfair_lock_lock((os_unfair_lock_t)(v27 + 100));
      v30 = *(_DWORD *)(v27 + 115);
      os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 100));
      if ((v30 & 0x2000000) != 0
        || (os_unfair_lock_lock((os_unfair_lock_t)(v27 + 100)),
            v31 = *(_DWORD *)(v27 + 115),
            os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 100)),
            (v31 & 0x10000000) == 0)
        && *(_BYTE *)(v27 + 112) != 7)
      {
        v32 = (TNode *)TNodeFromFINode(v45[0]);
        TNode::SetSizeProperties(v32, v21 - v18, v22 - v41, v23, v20 - v42, v15, v40 != 0);
      }
      if (v26)
      {
        v33 = (unint64_t *)&v26->__shared_owners_;
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v10 = v46;
    }
  }

  if (v10)
  {
    v35 = (unint64_t *)&v10->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v37 = v52;
  if (v52)
  {
    v38 = (unint64_t *)&v52->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }

}

void sub_1CBCF8DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, id);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

uint64_t TFSInfoSizerCompanion::SetContainsDatalessFolders(uint64_t this)
{
  uint64_t v1;
  uint64_t i;

  v1 = *(_QWORD *)(this + 16);
  for (i = *(_QWORD *)(this + 24); i != v1; i -= 64)
  {
    if (*(_BYTE *)(i - 52))
      break;
    *(_BYTE *)(i - 52) = 1;
  }
  return this;
}

BOOL TFSInfoSizer::ShouldCancel(id *this, void *a2)
{
  return !this || TFSInfoSizer::IsCanceled(this);
}

BOOL TFSInfoSizer::IsCanceled(id *this)
{
  FINode *v2;
  FINode *v3;
  uint64_t v4;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  os_unfair_lock_s *v10;
  int v11;
  unint64_t *v12;
  unint64_t v13;
  _DWORD *v14;
  _BOOL8 v15;
  TNode *v16;
  unsigned int v17;
  TNode *v18;
  unsigned int v19;
  TNode *v20;
  TNode *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  TNode *v27;
  uint64_t NotifierList;
  os_unfair_lock_s *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  std::__shared_weak_count *v33;

  v2 = (FINode *)*this;
  v3 = (FINode *)this[1];
  if (TNodeFromFINode(v2))
  {
    v4 = TNodeFromFINode(v2);
    v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
    os_unfair_lock_lock(v5);
    v7 = *(_QWORD *)(v4 + 16);
    v6 = *(std::__shared_weak_count **)(v4 + 24);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    os_unfair_lock_unlock(v5);
    v10 = (os_unfair_lock_s *)(v7 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v7 + 100));
    v11 = *(_DWORD *)(v7 + 115);
    os_unfair_lock_unlock(v10);
    if (!v6)
      goto LABEL_9;
    v12 = (unint64_t *)&v6->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      if ((v11 & 2) == 0)
        goto LABEL_10;
    }
    else
    {
LABEL_9:
      if ((v11 & 2) == 0)
        goto LABEL_10;
    }
    if (this[9])
    {
      if (TNodeFromFINode(v3))
      {
        v20 = (TNode *)TNodeFromFINode(v3);
        if (!atomic_load((unsigned int *)TNode::GetNotifierList(v20)))
        {
          if (!TNodeFromFINode(v2))
            goto LABEL_12;
          v27 = (TNode *)TNodeFromFINode(v2);
          NotifierList = TNode::GetNotifierList(v27);
          v29 = (os_unfair_lock_s *)(NotifierList + 64);
          os_unfair_lock_lock((os_unfair_lock_t)(NotifierList + 64));
          v31 = *(_QWORD *)(NotifierList + 40);
          v30 = *(_QWORD *)(NotifierList + 48);
          os_unfair_lock_unlock(v29);
          if (v31 == v30)
            goto LABEL_12;
        }
      }
    }
    goto LABEL_22;
  }
LABEL_10:
  v14 = this[9];
  if (v14)
  {
    if (v14[13] == 1003
      || TNodeFromFINode(v2)
      && (v16 = (TNode *)TNodeFromFINode(v2), (v17 = atomic_load((unsigned int *)(TNode::GetNotifierList(v16) + 4))) == 0)
      && (!TNodeFromFINode(v3)
       || (v18 = (TNode *)TNodeFromFINode(v3),
           (v19 = atomic_load((unsigned int *)(TNode::GetNotifierList(v18) + 4))) == 0)))
    {
LABEL_12:
      v15 = 1;
      goto LABEL_29;
    }
  }
LABEL_22:
  if (TNodeFromFINode(v2))
  {
    v22 = (TNode *)TNodeFromFINode(v2);
    TNode::GetVolumeInfo(v22, &v32);
    v23 = v33;
    v15 = *(_BYTE *)(v32 + 123) != 0;
    if (v33)
    {
      v24 = (unint64_t *)&v33->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }
  else
  {
    v15 = 0;
  }
LABEL_29:

  return v15;
}

void sub_1CBCF9088(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void TFSInfoSizer::SizeFolder(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  os_unfair_lock_s *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  TNode *v21;
  uint64_t v22;
  const __CFString *v23;
  unint64_t v24;
  const void *v25;
  uint64_t v26;
  int v27;
  TString *v28;
  TNode *v29;
  uint64_t IsSynchingAppropriate;
  int v31;
  TOperationSizer *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  TTime *v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int v45;
  TNode *v46;
  void *v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  NSObject *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  _QWORD v64[10];
  _QWORD block[4];
  TFSVolumeInfo *v66[10];
  TFSVolumeInfo *v67[2];
  _QWORD v68[2];
  TOperationSizer *v69;
  uint64_t v70;
  id v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74[2];
  TOperationSizer *v75;
  uint64_t v76;
  __int128 v77;
  _QWORD v78[4];
  __int128 v79;
  __int128 v80;
  _BYTE v81[27];
  uint64_t v82;
  __int16 v83;
  uint64_t v84;
  BOOL (*v85)(id *, void *);
  _QWORD *v86;
  int v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD v91[3];
  _QWORD v92[3];
  TString *v93;
  std::__shared_weak_count *v94;
  const void *v95[2];
  std::__shared_weak_count *v96;

  v6 = TNodeFromFINode(*(FINode **)a1);
  v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v6);
  os_unfair_lock_lock(v7);
  v9 = *(_QWORD *)(v6 + 16);
  v8 = *(std::__shared_weak_count **)(v6 + 24);
  if (!v8)
  {
    os_unfair_lock_unlock(v7);
    if (*(_BYTE *)(v9 + 112))
      return;
    goto LABEL_11;
  }
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  os_unfair_lock_unlock(v7);
  v12 = *(unsigned __int8 *)(v9 + 112);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (!v12)
  {
LABEL_11:
    v14 = TNodeFromFINode(*(FINode **)a1);
    v15 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v14);
    os_unfair_lock_lock(v15);
    v17 = *(_QWORD *)(v14 + 16);
    v16 = *(std::__shared_weak_count **)(v14 + 24);
    v95[1] = (const void *)v17;
    v96 = v16;
    if (v16)
    {
      v18 = (unint64_t *)&v16->__shared_owners_;
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
    os_unfair_lock_unlock(v15);
    os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
    v20 = *(_DWORD *)(v17 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 100));
    if ((v20 & 0x20) != 0)
    {
      v21 = (TNode *)TNodeFromFINode(*(FINode **)a1);
      *(_DWORD *)(a1 + 48) = TNode::SizingGeneration(v21);
      if ((TFSInfo::IsDataless((TFSInfo *)v17, v22, v23) & 1) == 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
        v24 = *(unsigned int *)(v17 + 115) | ((unint64_t)*(unsigned __int16 *)(v17 + 119) << 32);
        os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 100));
        if ((v24 & 0x400000000) == 0)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
          v25 = *(const void **)(v17 + 16);
          v95[0] = v25;
          if (v25)
          {
            CFRetain(v25);
            os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 100));
            _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v93);
            if (!TCFURLInfo::Initialize(v93, (const __CFURL *)v95[0], 1, 0)
              && !TCFURLInfo::GetVolumeInfoRecord((CFURLRef *)v93, v92))
            {
              v26 = v92[1];
              v91[1] = 0;
              v91[2] = 0;
              v91[0] = a1;
              std::make_shared[abi:ne180100]<TFSInfoSizerCompanion,TNodePtr &,void>((id *)a1, &v89);
              v82 = 0;
              v83 = 0;
              v77 = 0u;
              memset(v78, 0, 27);
              v79 = 0u;
              v80 = 0u;
              memset(v81, 0, sizeof(v81));
              v85 = 0;
              v86 = 0;
              v84 = 0;
              v87 = 0;
              v88 = 1;
              std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](&v77, (uint64_t *)&v93);
              std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100](v78, (uint64_t *)&v93);
              v78[2] = v26;
              v85 = TFSInfoSizer::ShouldCancel;
              v86 = v91;
              BYTE2(v87) = 1;
              if ((IsRunningInFinder() & 1) != 0)
              {
                LOBYTE(v27) = 1;
              }
              else
              {
                v28 = v93;
                TCFURLInfo::CheckPrefetchState((CFIndex)v93, 1);
                v27 = (WORD2(v28[9].fString.fRef) >> 2) & 1;
              }
              LOBYTE(v78[3]) = v27;
              BYTE1(v78[3]) = v27;
              std::allocate_shared[abi:ne180100]<TOperationSizer,std::allocator<TOperationSizer>,TOperationSizer::TOperationSizerParams &,void>((const TOperationSizer::TOperationSizerParams *)&v77, &v75);
              v29 = (TNode *)TNodeFromFINode(*(FINode **)a1);
              IsSynchingAppropriate = TNode::IsSynchingAppropriate(v29);
              if (LOBYTE(v78[3]))
                v31 = 0;
              else
                v31 = IsSynchingAppropriate;
              if (v31 == 1)
              {
                v32 = v75;
                v74[0] = v89;
                v74[1] = v90;
                if (v90)
                {
                  v33 = (unint64_t *)(v90 + 8);
                  do
                    v34 = __ldxr(v33);
                  while (__stxr(v34 + 1, v33));
                }
                std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)v32 + 45, v74);
                IsSynchingAppropriate = std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v74);
              }
              *(_QWORD *)(v89 + 8) = v75;
              *(_QWORD *)(a1 + 56) = TTime::MicrosecondsSinceStartup((TTime *)IsSynchingAppropriate);
              v69 = v75;
              v70 = v76;
              if (v76)
              {
                v35 = (unint64_t *)(v76 + 8);
                do
                  v36 = __ldxr(v35);
                while (__stxr(v36 + 1, v35));
              }
              v37 = *(id *)a1;
              v39 = *a2;
              v38 = a2[1];
              v71 = v37;
              v72 = v39;
              v73 = v38;
              if (v38)
              {
                v40 = (unint64_t *)(v38 + 8);
                do
                  v41 = __ldxr(v40);
                while (__stxr(v41 + 1, v40));
              }
              v42 = (TTime *)TOperationSizer::ComputeSizeWithTimeout(v75, a3);
              if ((_DWORD)v42)
              {
                v43 = TTime::MicrosecondsSinceStartup(v42) - *(_QWORD *)(a1 + 56);
                v44 = (unsigned int *)(*(_QWORD *)(TNodeFromFINode(*(FINode **)a1) + 56) + 196);
                do
                  v45 = __ldaxr(v44);
                while (__stlxr(v45 + 1, v44));
                v46 = (TNode *)TNodeFromFINode(*(FINode **)a1);
                TNode::GetVolumeInfo(v46, v67);
                TFSVolumeInfo::GetFolderSizingThread(v67[0], v68);
                v47 = *(void **)v68[0];
                block[0] = MEMORY[0x1E0C809B0];
                block[1] = 3321888768;
                block[2] = ___ZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEy_block_invoke;
                block[3] = &__block_descriptor_112_ea8_32c64_ZTSKZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEyE3__1_e5_v8__0l;
                v64[0] = v75;
                v64[1] = v76;
                if (v76)
                {
                  v48 = (unint64_t *)(v76 + 8);
                  do
                    v49 = __ldxr(v48);
                  while (__stxr(v49 + 1, v48));
                }
                v50 = a2[1];
                v64[2] = *a2;
                v64[3] = v50;
                if (v50)
                {
                  v51 = (unint64_t *)(v50 + 8);
                  do
                    v52 = __ldxr(v51);
                  while (__stxr(v52 + 1, v51));
                }
                v64[4] = v69;
                v64[5] = v70;
                if (v70)
                {
                  v53 = (unint64_t *)(v70 + 8);
                  do
                    v54 = __ldxr(v53);
                  while (__stxr(v54 + 1, v53));
                }
                v64[6] = v71;
                v64[7] = v72;
                v64[8] = v73;
                if (v73)
                {
                  v55 = (unint64_t *)(v73 + 8);
                  do
                    v56 = __ldxr(v55);
                  while (__stxr(v56 + 1, v55));
                }
                v64[9] = v43;
                v57 = v47;
                TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::$_1(v66, (uint64_t)v64);
                dispatch_async(v57, block);

                TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::~$_1((uint64_t)v64);
                std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v68);
                std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)v67);
                TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::~$_1((uint64_t)v66);
              }
              else
              {
                v58 = TTime::MicrosecondsSinceStartup(v42);
                TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::operator()((TChildrenList *)&v69, 0, v58 - *(_QWORD *)(a1 + 56));
              }
              TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0((uint64_t)&v69);
              std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v75);
              TOperationSizer::TOperationSizerParams::~TOperationSizerParams((id *)&v77);
              std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v89);
            }
            v59 = v94;
            if (v94)
            {
              v60 = (unint64_t *)&v94->__shared_owners_;
              do
                v61 = __ldaxr(v60);
              while (__stlxr(v61 - 1, v60));
              if (!v61)
              {
                ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
                std::__shared_weak_count::__release_weak(v59);
              }
            }
            v16 = v96;
          }
          else
          {
            os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 100));
          }
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v95);
        }
      }
    }
    if (v16)
    {
      v62 = (unint64_t *)&v16->__shared_owners_;
      do
        v63 = __ldaxr(v62);
      while (__stlxr(v63 - 1, v62));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
}

void sub_1CBCF9618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,id a47)
{
  uint64_t v47;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a34);
  TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0((uint64_t)&a38);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a45);
  TOperationSizer::TOperationSizerParams::~TOperationSizerParams(&a47);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v47 - 168);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v47 - 104);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)(v47 - 88));
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v47 - 80);
  _Unwind_Resume(a1);
}

id std::make_shared[abi:ne180100]<TFSInfoSizerCompanion,TNodePtr &,void>@<X0>(id *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  id result;

  v4 = operator new(0x48uLL);
  v4[2] = 0;
  *v4 = &unk_1E8750730;
  v4[1] = 0;
  v4[3] = &off_1E874FE20;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  result = *a1;
  v4[8] = result;
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

id __copy_helper_block_ea8_32c64_ZTSKZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEyE3__1(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  id result;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(_QWORD *)(a2 + 56);
  a1[6] = *(_QWORD *)(a2 + 48);
  a1[7] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = *(_QWORD *)(a2 + 72);
  a1[8] = *(_QWORD *)(a2 + 64);
  a1[9] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  result = *(id *)(a2 + 80);
  v15 = *(_QWORD *)(a2 + 88);
  v14 = *(_QWORD *)(a2 + 96);
  a1[10] = result;
  a1[11] = v15;
  a1[12] = v14;
  if (v14)
  {
    v16 = (unint64_t *)(v14 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  a1[13] = *(_QWORD *)(a2 + 104);
  return result;
}

_QWORD *TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::$_1(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = *(_QWORD *)a2;
  a1[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(_QWORD *)(a2 + 24);
  a1[2] = *(_QWORD *)(a2 + 16);
  a1[3] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = *(id *)(a2 + 48);
  v15 = *(_QWORD *)(a2 + 56);
  v14 = *(_QWORD *)(a2 + 64);
  a1[6] = v13;
  a1[7] = v15;
  a1[8] = v14;
  if (v14)
  {
    v16 = (unint64_t *)(v14 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  a1[9] = *(_QWORD *)(a2 + 72);
  return a1;
}

uint64_t __destroy_helper_block_ea8_32c64_ZTSKZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEyE3__1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 32;
  v3 = a1 + 64;
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 88);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 48);
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

uint64_t TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 56);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 16);
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1);
}

TChildrenList *TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::operator()(TChildrenList *result, int a2, uint64_t a3)
{
  int v3;
  FINode **v6;
  TNode *v7;
  int isa;
  uint64_t v9;

  v3 = *(_DWORD *)(*(_QWORD *)result + 40);
  *(_DWORD *)(*((_QWORD *)result + 3) + 64) = v3;
  if (!v3)
  {
    v6 = (FINode **)result;
    v7 = (TNode *)TNodeFromFINode(*((FINode **)result + 2));
    if (a2)
      isa = (int)v6[3][6].super.isa;
    else
      isa = -1;
    TNode::SetSizeProperties(v7, (uint64_t)(*v6)[13].super.isa, (uint64_t)(*v6)[16].super.isa, (uint64_t)(*v6)[12].super.isa, (uint64_t)(*v6)[11].super.isa, isa, HIBYTE((*v6)[20].super.isa));
    v9 = TNodeFromFINode(v6[2]);
    return TChildrenList::SetLastResizeDuration(*(TChildrenList **)(v9 + 56), a3);
  }
  return result;
}

uint64_t TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0(uint64_t a1)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 24);

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1);
}

void std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

void std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;
  void *v5;

  for (i = *(_QWORD *)(a1 + 8); i != a2; i -= 64)
  {
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](i - 16);
    v5 = *(void **)(i - 64);

  }
  *(_QWORD *)(a1 + 8) = a2;
}

uint64_t std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__push_back_slow_path<TFSInfoSizerCompanion::TFolderStatistics>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  _QWORD v16[5];

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 6;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 58)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 5 > v5)
    v5 = v8 >> 5;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0)
    v9 = 0x3FFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v16[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[64 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[64 * v9];
  TNodePtr::TNodePtr(v11, (id *)a2);
  v12 = *(_OWORD *)(a2 + 8);
  v13 = *(_OWORD *)(a2 + 24);
  *((_QWORD *)v11 + 5) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(v11 + 24) = v13;
  *(_OWORD *)(v11 + 8) = v12;
  *((_OWORD *)v11 + 3) = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v16[2] = v11 + 64;
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__swap_out_circular_buffer(a1, v16);
  v14 = a1[1];
  std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_1CBCF9C28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 6);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  v15 = 0;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      TNodePtr::TNodePtr((_QWORD *)(v7 - 64), (id *)(v9 - 64));
      v10 = *(_OWORD *)(v9 - 56);
      v11 = *(_OWORD *)(v9 - 40);
      *(_QWORD *)(v7 - 24) = *(_QWORD *)(v9 - 24);
      *(_OWORD *)(v7 - 40) = v11;
      *(_OWORD *)(v7 - 56) = v10;
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(v9 - 16);
      *(_QWORD *)(v9 - 16) = 0;
      *(_QWORD *)(v9 - 8) = 0;
      v7 = *((_QWORD *)&v17 + 1) - 64;
      *((_QWORD *)&v17 + 1) -= 64;
      v9 -= 64;
    }
    while (v9 != a5);
    v12 = v17;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>,std::reverse_iterator<std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>,std::reverse_iterator<std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>,std::reverse_iterator<std::reverse_iterator<TFSInfoSizerCompanion::TFolderStatistics*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id *i;

  for (i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(i + 6));

    i = (id *)(*(_QWORD *)(a2 + 32) + 64);
  }
}

uint64_t std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 64;
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](i - 16);

  }
}

void std::__shared_ptr_emplace<TFSInfoSizerCompanion>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750730;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSInfoSizerCompanion>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750730;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__shared_ptr_emplace<TFSInfoSizerCompanion>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 32))(a1 + 24);
}

_QWORD *std::allocate_shared[abi:ne180100]<TOperationSizer,std::allocator<TOperationSizer>,TOperationSizer::TOperationSizerParams &,void>@<X0>(const TOperationSizer::TOperationSizerParams *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x190uLL);
  result = std::__shared_ptr_emplace<TOperationSizer>::__shared_ptr_emplace[abi:ne180100]<TOperationSizer::TOperationSizerParams &,std::allocator<TOperationSizer>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1CBCF9FE0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TOperationSizer>::__shared_ptr_emplace[abi:ne180100]<TOperationSizer::TOperationSizerParams &,std::allocator<TOperationSizer>,0>(_QWORD *a1, const TOperationSizer::TOperationSizerParams *a2)
{
  a1[2] = 0;
  *a1 = &unk_1E8750618;
  a1[1] = 0;
  TOperationSizer::TOperationSizer((TOperationSizer *)(a1 + 3), a2);
  return a1;
}

void sub_1CBCFA02C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TOperationSizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750618;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TOperationSizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8750618;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<TOperationSizer>::__on_zero_shared(uint64_t a1)
{
  TOperationSizer::~TOperationSizer((TOperationSizer *)(a1 + 24));
}

uint64_t ScreenTimeApps(void)
{
  unsigned __int8 v0;
  _QWORD *v2;

  {
    v2 = (_QWORD *)operator new();
    v2[2] = 0;
    v2[1] = 0;
    *v2 = v2 + 1;
    ScreenTimeApps(void)::sScreenTimeAppNodes = (uint64_t)v2;
  }
  return ScreenTimeApps(void)::sScreenTimeAppNodes;
}

void sub_1CBCFA110(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TDeviceManagementMonitor::Instance(TDeviceManagementMonitor *this)
{
  unsigned __int8 v1;
  TDeviceManagementMonitor *v3;

  {
    v3 = (TDeviceManagementMonitor *)operator new();
    TDeviceManagementMonitor::TDeviceManagementMonitor(v3);
    TDeviceManagementMonitor::Instance(void)::monitor = (uint64_t)v3;
  }
  return TDeviceManagementMonitor::Instance(void)::monitor;
}

void sub_1CBCFA19C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

void TDeviceManagementMonitor::TDeviceManagementMonitor(TDeviceManagementMonitor *this)
{
  id v2;
  uint64_t v3;
  void *v4;
  _QWORD v5[5];

  *(_QWORD *)this = 0;
  v2 = objc_alloc((Class)getDMFApplicationPolicyMonitorClass());
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3321888768;
  v5[2] = ___ZN24TDeviceManagementMonitorC2Ev_block_invoke;
  v5[3] = &__block_descriptor_33_ea8_32c42_ZTSKZN24TDeviceManagementMonitorC1EvE3__0_e5_v8__0l;
  v3 = objc_msgSend(v2, "initWithPolicyChangeHandler:", v5);
  v4 = *(void **)this;
  *(_QWORD *)this = v3;

}

void sub_1CBCFA250(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void ___ZN24TDeviceManagementMonitorC2Ev_block_invoke()
{
  ExceptionSafeBlock(&__block_literal_global_7);
}

void TDeviceManagementMonitor::AddNode(TDeviceManagementMonitor *this, TNode *a2)
{
  uint64_t **v3;
  TNodePtr v4;

  DeviceManagementLock();
  os_unfair_lock_lock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  v3 = (uint64_t **)ScreenTimeApps();
  TNodePtr::TNodePtr(&v4, a2);
  std::__tree<TNodePtr>::__emplace_unique_key_args<TNodePtr,TNodePtr>(v3, &v4.fFINode, (id *)&v4.fFINode);

  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
}

void sub_1CBCFA2E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  _Unwind_Resume(a1);
}

void DeviceManagementLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      DeviceManagementLock(void)::sDeviceManagementLock = 0;
    }
  }
}

void TDeviceManagementMonitor::RegisterApp(TNode *this, TNode *a2)
{
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  TDeviceManagementMonitor *v8;
  int v9;
  unint64_t v10;
  TDeviceManagementMonitor *v11;

  v3 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v3);
  v5 = *((_QWORD *)this + 2);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    os_unfair_lock_unlock(v3);
    v9 = *(unsigned __int8 *)(v5 + 112);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    os_unfair_lock_unlock(v3);
    v9 = *(unsigned __int8 *)(v5 + 112);
  }
  if (v9 != 7)
  {
    v11 = (TDeviceManagementMonitor *)TDeviceManagementMonitor::Instance(v8);
    TDeviceManagementMonitor::AddNode(v11, this);
  }
}

void TDeviceManagementMonitor::RemoveNode(TDeviceManagementMonitor *this, TNode *a2)
{
  uint64_t **v3;
  TNodePtr v4;

  DeviceManagementLock();
  os_unfair_lock_lock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  v3 = (uint64_t **)ScreenTimeApps();
  TNodePtr::TNodePtr(&v4, a2);
  std::__tree<TNodePtr>::__erase_unique<TNodePtr>(v3, &v4.fFINode);

  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
}

void sub_1CBCFA480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  _Unwind_Resume(a1);
}

void TDeviceManagementMonitor::UnRegisterApp(TNode *this, TNode *a2)
{
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  TDeviceManagementMonitor *v8;
  int v9;
  unint64_t v10;
  TDeviceManagementMonitor *v11;

  v3 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v3);
  v5 = *((_QWORD *)this + 2);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    os_unfair_lock_unlock(v3);
    v9 = *(unsigned __int8 *)(v5 + 112);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    os_unfair_lock_unlock(v3);
    v9 = *(unsigned __int8 *)(v5 + 112);
  }
  if (v9 != 7)
  {
    v11 = (TDeviceManagementMonitor *)TDeviceManagementMonitor::Instance(v8);
    TDeviceManagementMonitor::RemoveNode(v11, this);
  }
}

void ___ZN24TDeviceManagementMonitor19PolicyChangeHandlerEv_block_invoke()
{
  uint64_t v0;
  uint64_t *v1;
  uint64_t v2;
  os_unfair_lock_s *v3;
  std::__shared_weak_count *v4;
  TFSInfo *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  const TNode *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  FINode *v15;
  uint64_t *v16;
  _QWORD *v17[2];

  v17[0] = 0;
  v17[1] = 0;
  v16 = (uint64_t *)v17;
  DeviceManagementLock();
  os_unfair_lock_lock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  v0 = ScreenTimeApps();
  if (&v16 != (uint64_t **)v0)
    std::__tree<TNodePtr>::__assign_multi<std::__tree_const_iterator<TNodePtr,std::__tree_node<TNodePtr,void *> *,long>>(&v16, *(id **)v0, (id *)(v0 + 8));
  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  v1 = v16;
  if (v16 != (uint64_t *)v17)
  {
    do
    {
      v15 = (FINode *)(id)v1[4];
      v2 = TNodeFromFINode(v15);
      v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
      os_unfair_lock_lock(v3);
      v5 = *(TFSInfo **)(v2 + 16);
      v4 = *(std::__shared_weak_count **)(v2 + 24);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }
      os_unfair_lock_unlock(v3);
      v8 = TFSInfo::ApplicationDMFPolicy(v5);
      if (v8 != TFSInfo::FetchApplicationDMFPolicy(v5))
      {
        v9 = (const TNode *)TNodeFromFINode(v15);
        TNode::SendNotification(v9, 2, (id *)&v15, 1684893817, 0);
      }
      if (v4)
      {
        v10 = (unint64_t *)&v4->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }

      v12 = (uint64_t *)v1[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (uint64_t *)v1[2];
          v14 = *v13 == (_QWORD)v1;
          v1 = v13;
        }
        while (!v14);
      }
      v1 = v13;
    }
    while (v13 != (uint64_t *)v17);
  }
  std::__tree<TNodePtr>::destroy((uint64_t)&v16, v17[0]);
}

void sub_1CBCFA6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, _QWORD *a13)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  std::__tree<TNodePtr>::destroy((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

Class initDMFApplicationPolicyMonitor(void)
{
  Class Class;

  if (DeviceManagementLibrary(void)::frameworkLibrary
    || (DeviceManagementLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/DeviceManagement.framework/DeviceManagement", 2)) != 0)
  {
    Class = objc_getClass("DMFApplicationPolicyMonitor");
    classDMFApplicationPolicyMonitor = (uint64_t)Class;
    getDMFApplicationPolicyMonitorClass = (uint64_t (*)(void))DMFApplicationPolicyMonitorFunction;
  }
  else
  {
    Class = (Class)classDMFApplicationPolicyMonitor;
  }
  return Class;
}

id DMFApplicationPolicyMonitorFunction(void)
{
  return (id)classDMFApplicationPolicyMonitor;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<TNodePtr,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t **std::__tree<TNodePtr>::__assign_multi<std::__tree_const_iterator<TNodePtr,std::__tree_node<TNodePtr,void *> *,long>>(uint64_t **result, id *a2, id *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  id *v9;
  uint64_t *leaf_high;
  id *v11;
  BOOL v12;
  id *v13;
  id *v14;
  uint64_t **v15;
  uint64_t *v16;
  FINode **v17;
  uint64_t v18;

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v15 = result;
    v16 = v8;
    v17 = (FINode **)v8;
    if (v8)
    {
      v16 = std::__tree<TNodePtr>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        v9 = a2;
        do
        {
          objc_storeStrong((id *)v8 + 4, v9[4]);
          leaf_high = std::__tree<TNodePtr>::__find_leaf_high((uint64_t)v5, &v18, v17 + 4);
          std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(v5, v18, (uint64_t **)leaf_high, (uint64_t *)v17);
          v17 = (FINode **)v16;
          if (v16)
            v16 = std::__tree<TNodePtr>::_DetachedTreeCache::__detach_next((uint64_t)v16);
          v11 = (id *)v9[1];
          if (v11)
          {
            do
            {
              a2 = v11;
              v11 = (id *)*v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (id *)v9[2];
              v12 = *a2 == v9;
              v9 = a2;
            }
            while (!v12);
          }
          v8 = (uint64_t *)v17;
          if (v17)
            v12 = a2 == a3;
          else
            v12 = 1;
          v9 = a2;
        }
        while (!v12);
      }
    }
    result = (uint64_t **)std::__tree<TNodePtr>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      result = (uint64_t **)std::__tree<TNodePtr>::__emplace_multi<TNodePtr const&>(v5, a2 + 4);
      v13 = (id *)a2[1];
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = (id *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (id *)a2[2];
          v12 = *v14 == a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_1CBCFA960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__tree<TNodePtr>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<TNodePtr>::__find_leaf_high(uint64_t a1, _QWORD *a2, FINode **a3)
{
  uint64_t *v4;
  uint64_t *v5;
  unint64_t v7;
  uint64_t *result;

  v5 = (uint64_t *)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v5 = v4;
        v7 = TNodeFromFINode(*a3);
        if (v7 >= TNodeFromFINode((FINode *)v5[4]))
          break;
        v4 = (uint64_t *)*v5;
        result = v5;
        if (!*v5)
          goto LABEL_8;
      }
      v4 = (uint64_t *)v5[1];
    }
    while (v4);
    result = v5 + 1;
  }
  else
  {
    result = (uint64_t *)(a1 + 8);
  }
LABEL_8:
  *a2 = v5;
  return result;
}

_QWORD *std::__tree<TNodePtr>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<TNodePtr>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  std::__tree<TNodePtr>::destroy(*(_QWORD *)a1, *(_QWORD **)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (_QWORD *)v2[2];
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<TNodePtr>::destroy(*(_QWORD *)a1, v2);
  }
  return a1;
}

void *std::__tree<TNodePtr>::__emplace_multi<TNodePtr const&>(uint64_t **a1, id *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t *leaf_high;
  uint64_t v8[3];
  char v9;

  v4 = (uint64_t)(a1 + 1);
  v5 = operator new(0x28uLL);
  v8[2] = v4;
  *((_QWORD *)v5 + 4) = *a2;
  v9 = 1;
  leaf_high = std::__tree<TNodePtr>::__find_leaf_high((uint64_t)a1, v8, (FINode **)v5 + 4);
  std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v8[0], (uint64_t **)leaf_high, (uint64_t *)v5);
  return v5;
}

void sub_1CBCFAB28(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__tree_node_destructor<std::allocator<std::__tree_node<TNodePtr,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void sub_1CBCFABEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCFAC94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCFADB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1CBCFB0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

char ***std::back_insert_iterator<std::vector<NSObject  {objcproto14FINodeIterator}* {__strong}>>::operator=[abi:ne180100](char ***a1, uint64_t *a2)
{
  char **v4;
  char *v5;
  char **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  char *v23;
  char *v24;
  _QWORD v26[2];
  char *v27;
  char *v28;
  uint64_t v29;

  v4 = *a1;
  v5 = (*a1)[1];
  v6 = *a1;
  v9 = (unint64_t)v6[2];
  v7 = (uint64_t)(v6 + 2);
  v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    v12 = (v5 - *v4) >> 3;
    if ((unint64_t)(v12 + 1) >> 61)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v13 = v8 - (_QWORD)*v4;
    v14 = v13 >> 2;
    if (v13 >> 2 <= (unint64_t)(v12 + 1))
      v14 = v12 + 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v15 = v14;
    v29 = v7;
    if (v15)
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v7, v15);
    else
      v16 = 0;
    v17 = &v16[8 * v12];
    v18 = &v16[8 * v15];
    v28 = v18;
    v19 = *a2;
    *a2 = 0;
    *(_QWORD *)v17 = v19;
    v11 = v17 + 8;
    v27 = v17 + 8;
    v21 = *v4;
    v20 = v4[1];
    if (v20 == *v4)
    {
      v23 = v4[1];
    }
    else
    {
      do
      {
        v22 = *((_QWORD *)v20 - 1);
        v20 -= 8;
        *(_QWORD *)v20 = 0;
        *((_QWORD *)v17 - 1) = v22;
        v17 -= 8;
      }
      while (v20 != v21);
      v23 = *v4;
      v20 = v4[1];
      v11 = v27;
      v18 = v28;
    }
    *v4 = v17;
    v26[0] = v23;
    v26[1] = v23;
    v4[1] = v11;
    v27 = v20;
    v24 = v4[2];
    v4[2] = v18;
    v28 = v24;
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v26);
  }
  else
  {
    v10 = *a2;
    *a2 = 0;
    *(_QWORD *)v5 = v10;
    v11 = v5 + 8;
  }
  v4[1] = v11;
  return a1;
}

uint64_t TPathName::AsOldStyleFullPath(TPathName *this, const TString *a2, TString *a3)
{
  TPathName::FullPath(this, a2, a3, (const __CFString *)0x3A);
  return 0;
}

uint64_t TPathName::FullPath(TPathName *this, const TString *a2, TString *a3, const __CFString *a4)
{
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const TString *v11;
  uint64_t v12;
  int v13;
  const TString *v14;
  int v15;
  char v16;
  const TString *v17;
  CFTypeRef cf1;
  TString v20;

  v20.fString.fRef = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  v8 = *((_QWORD *)this + 4);
  v9 = *((_QWORD *)this + 1);
  v10 = (_QWORD *)(v9 + 8 * (v8 >> 9));
  if (*((_QWORD *)this + 2) == v9)
  {
    if ((_DWORD)a4 != 58)
      goto LABEL_24;
    v11 = 0;
    v12 = 0;
    goto LABEL_10;
  }
  v11 = (const TString *)(*v10 + 8 * (*((_QWORD *)this + 4) & 0x1FFLL));
  v12 = *(_QWORD *)(v9 + (((*((_QWORD *)this + 5) + v8) >> 6) & 0x3FFFFFFFFFFFFF8))
      + 8 * ((*((_QWORD *)this + 5) + v8) & 0x1FF);
  if ((_DWORD)a4 == 58)
  {
    if (v11 != (const TString *)v12)
    {
      TPathName::VolumesDirectory((TString *)&cf1);
      v13 = CFEqual(cf1, v11->fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (v13)
      {
        if ((const TString *)((char *)++v11 - *v10) == (const TString *)4096)
        {
          v14 = (const TString *)v10[1];
          ++v10;
          v11 = v14;
        }
        v15 = 1;
        goto LABEL_14;
      }
    }
LABEL_10:
    if (&v20 != a2)
      TString::SetStringRefAsImmutable(&v20, (TString *)a2->fString.fRef);
    v16 = 0;
    v15 = 1;
    goto LABEL_23;
  }
  v15 = 0;
LABEL_14:
  v16 = 1;
LABEL_23:
  while (v11 != (const TString *)v12)
  {
    if ((v16 & 1) == 0)
      TString::Append(&v20, a4);
    if (v15)
    {
      ColonsToSlashes(v11, (TString *)&cf1);
      TString::Append(&v20, (const TString *)&cf1);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    }
    else
    {
      TString::Append(&v20, v11);
    }
    if ((const TString *)((char *)++v11 - *v10) == (const TString *)4096)
    {
      v17 = (const TString *)v10[1];
      ++v10;
      v11 = v17;
    }
    v16 = 0;
  }
LABEL_24:
  if (&v20 != a3)
    TString::SetStringRefAsImmutable(a3, (TString *)v20.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
  return 0;
}

void sub_1CBCFB458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

uint64_t TNodeRequest::TNodeRequest(uint64_t a1, uint64_t a2)
{
  TNodePtr v5;
  TNodePtr v6;

  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  TNodePtr::TNodePtr(&v6, 0);
  TNodePtr::TNodePtr(&v5, 0);
  TDSNotifier::Make(a2, (uint64_t)&v6, (uint64_t)&v5, (uint64_t *)(a1 + 24));

  *(_DWORD *)(a1 + 32) = 0;
  return a1;
}

void sub_1CBCFB514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  uint64_t v10;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v10);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c13_ZTS8TNodePtr40c47_ZTSRKNSt3__110shared_ptrI17TVolumeSyncThreadEE56c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE(_QWORD *a1, uint64_t a2)
{
  id result;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  result = *(id *)(a2 + 32);
  v6 = *(_QWORD *)(a2 + 40);
  v5 = *(_QWORD *)(a2 + 48);
  a1[4] = result;
  a1[5] = v6;
  a1[6] = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *(_QWORD *)(a2 + 64);
  a1[7] = *(_QWORD *)(a2 + 56);
  a1[8] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  return result;
}

void __destroy_helper_block_ea8_32c13_ZTS8TNodePtr40c47_ZTSRKNSt3__110shared_ptrI17TVolumeSyncThreadEE56c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE(uint64_t a1)
{

}

id CopyDeep(NSSet *a1)
{
  NSSet *v1;
  NSSet *v2;
  void *v3;
  void *v4;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    CopyDeepCommon(v1, 0);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E60]), "initWithSet:", v3);

  }
  else
  {
    v4 = 0;
  }

  return v4;
}

void sub_1CBCFB62C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id CopyDeepCommon(NSSet *a1, BOOL a2)
{
  NSSet *v3;
  void *v4;
  NSSet *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E20]), "initWithCapacity:", -[NSSet count](v3, "count"));
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v5 = v3;
  v6 = -[NSSet countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v12;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v12 != v7)
          objc_enumerationMutation(v5);
        CopyDeepHelper(*(NSObject **)(*((_QWORD *)&v11 + 1) + 8 * v8), a2);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "addObject:", v9, (_QWORD)v11);

        ++v8;
      }
      while (v6 != v8);
      v6 = -[NSSet countByEnumeratingWithState:objects:count:](v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v6);
  }

  return v4;
}

void sub_1CBCFB794(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id MutableCopyDeep(NSSet *a1)
{
  NSSet *v1;
  NSSet *v2;
  void *v3;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    CopyDeepCommon(v1, 1);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1CBCFB81C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id NewFileCoordinator(void)
{
  void *v0;

  v0 = (void *)objc_opt_new();
  objc_msgSend(v0, "setPurposeIdentifier:", CFSTR("com.apple.desktopservices.copyengine"));
  return v0;
}

void sub_1CBCFB864(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CoordinationRecordingLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      CoordinationRecordingLock(void)::gCoordinationRecordingLock = 0;
    }
  }
}

void TFileCoordinationRecord::TFileCoordinationRecord(TFileCoordinationRecord *this, NSFileCoordinator *a2)
{
  NSFileCoordinator *v3;

  v3 = a2;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = v3;
  *((_BYTE *)this + 36) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 10) = 0;
}

void TFileCoordinationRecord::~TFileCoordinationRecord(TFileCoordinationRecord *this)
{
  uint64_t v2;
  uint64_t *v3;
  _DWORD *v4;

  v2 = *(_QWORD *)this;
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  if (*((_BYTE *)this + 36))
  {
    CoordinationRecordingLock();
    os_unfair_lock_lock((os_unfair_lock_t)&CoordinationRecordingLock(void)::gCoordinationRecordingLock);
    v4 = (_DWORD *)((char *)this + 32);
    v3 = std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)gPendingCoordinations, (int *)this + 8, (uint64_t)&std::piecewise_construct, &v4)[5];
    objc_msgSend(v3, "removeObject:", *((_QWORD *)this + 3));
    if (!objc_msgSend(v3, "count"))
      std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__erase_unique<int>(gPendingCoordinations, (int *)this + 8);

    os_unfair_lock_unlock((os_unfair_lock_t)&CoordinationRecordingLock(void)::gCoordinationRecordingLock);
  }

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

const void **TFileCoordinationRecord::CoordinateReading@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  __CFURL *v13;

  std::shared_ptr<TCFURLInfo>::operator=[abi:ne180100]((_QWORD *)(a1 + 8), a2);
  v13 = (__CFURL *)TFileCoordinationRecord::CopyURLForCoordinatedReading(a1, (id **)a2, a3);
  v8 = *a2;
  if (v13 != *(__CFURL **)*a2)
  {
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(a4);
    if (!TCFURLInfo::Initialize((TString *)*a4, v13, 1, 1))
      return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v13);
    std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)a4);
    v8 = *a2;
  }
  v9 = a2[1];
  *a4 = v8;
  a4[1] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v13);
}

void sub_1CBCFBA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  uint64_t v9;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v9);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

id TFileCoordinationRecord::CopyURLForCoordinatedReading(uint64_t a1, id **a2, int a3)
{
  id v6;
  void *v7;
  id *v8;
  void *v9;
  id v10;
  void *v11;
  void *v12;
  char v13;
  id v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  NSObject *v20;
  id v21;
  id v22;
  id v23;
  dispatch_time_t v24;
  void *v25;
  id v26;
  _QWORD v28[7];
  id v29;
  _QWORD handler[4];
  id v31;
  id v32;
  const void *v33;
  id v34;

  v6 = **a2;
  v7 = (void *)objc_msgSend(v6, "copy");
  v34 = v7;
  v8 = *a2;
  TCFURLInfo::CheckPrefetchState((CFIndex)v8, 1);
  if (((*((unsigned __int16 *)v8 + 38) | (*((unsigned __int8 *)v8 + 78) << 16)) & 0x40000) != 0)
  {
    v9 = (void *)_CFURLCopyLogicalURLOfPromiseAtURL();
    v33 = v9;
    if (v9)
    {
      v10 = v9;

      v6 = v10;
    }
    if (a3)
    {
      objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "path");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v13 = objc_msgSend(v11, "fileExistsAtPath:", v12);

      if ((v13 & 1) != 0)
      {
        v14 = v7;
        TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&v33);
        v15 = v14;
        goto LABEL_20;
      }
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&v33);
  }
  LOBYTE(v33) = 0;
  v16 = MEMORY[0x1E0C809B0];
  if (a3)
  {
    v17 = 262145;
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      objc_msgSend(MEMORY[0x1E0CB3600], "_nextClaimIdentifier");
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      dispatch_get_global_queue(0, 0);
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v19);

      v21 = *(id *)(a1 + 24);
      handler[0] = v16;
      handler[1] = 3221225472;
      handler[2] = ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke;
      handler[3] = &unk_1E8752B88;
      v31 = v21;
      v32 = v18;
      v22 = v18;
      v23 = v21;
      dispatch_source_set_event_handler(v20, handler);
      v24 = dispatch_time(0, 10000000000);
      dispatch_source_set_timer(v20, v24, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      dispatch_resume(v20);

    }
    else
    {
      v20 = 0;
    }
  }
  else
  {
    v20 = 0;
    v17 = 1;
  }
  v25 = *(void **)(a1 + 24);
  v28[6] = a1;
  v29 = 0;
  v28[0] = v16;
  v28[1] = 3321888768;
  v28[2] = ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke_2;
  v28[3] = &__block_descriptor_56_ea8_32c105_ZTSKZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEbE3__0_e24_v24__0__NSURL_8___v___16l;
  v28[4] = &v34;
  v28[5] = &v33;
  objc_msgSend(v25, "_coordinateReadingItemAtURL:options:error:byAccessor:", v6, v17, &v29, v28);
  v26 = v29;
  if (v20)
    dispatch_source_cancel(v20);
  if (!(_BYTE)v33)
  {
    if (a3)
      objc_msgSend(v26, "code");
    *(_DWORD *)(a1 + 40) = -8095;
  }
  v15 = v34;

  v14 = v34;
LABEL_20:

  return v15;
}

void sub_1CBCFBD80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;

  _Unwind_Resume(a1);
}

uint64_t ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_cancelClaimWithIdentifier:", *(_QWORD *)(a1 + 40));
}

void ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void **v8;
  uint64_t v9;
  void **v10;
  void *v11;
  uint64_t v12;
  void *v13;
  id v14;

  v5 = a2;
  v6 = a3;
  v14 = v5;
  v7 = v6;
  v8 = *(void ***)(a1 + 48);
  if (v14)
  {
    v9 = objc_msgSend(v14, "copy");
    v10 = *(void ***)(a1 + 32);
    v11 = *v10;
    *v10 = (void *)v9;

  }
  v12 = objc_msgSend(v7, "copy");
  v13 = *v8;
  *v8 = (void *)v12;

  **(_BYTE **)(a1 + 40) = 1;
}

void sub_1CBCFBEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c105_ZTSKZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEbE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a1[2] = result;
  return result;
}

uint64_t **std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  int v8;
  uint64_t **v9;
  int v10;
  _DWORD *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((_QWORD *)v11 + 5) = 0;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__erase_unique<int>(uint64_t a1, int *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t *v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = *(_DWORD *)(v2 + 32);
    v6 = v5 < v3;
    if (v5 >= v3)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (!v6)
      v4 = v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32))
    return 0;
  std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

void TFolderSizingThread::SetTimerToDispatchResizeRequest(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  dispatch_source_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  NSObject *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  TTime *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  dispatch_time_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD handler[5];
  std::__shared_weak_count *v35;
  NSObject *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;

  v6 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(*a1 + 8));
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEy_block_invoke;
  handler[3] = &__block_descriptor_72_ea8_32c113_ZTSKZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyE3__0_e5_v8__0l;
  v8 = *a1;
  v7 = (std::__shared_weak_count *)a1[1];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = v6;
  v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12)
  {
    v14 = (unint64_t *)&v12->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  handler[4] = v8;
  v35 = v7;
  if (v7)
  {
    v16 = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v18 = v11;
  v19 = v18;
  v36 = v18;
  v37 = v13;
  v38 = v12;
  if (v12)
  {
    v20 = (unint64_t *)&v12->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
    dispatch_source_set_event_handler(v18, handler);
    do
      v22 = __ldaxr(v20);
    while (__stlxr(v22 - 1, v20));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  else
  {
    dispatch_source_set_event_handler(v18, handler);
  }

  if (v7)
  {
    v24 = (unint64_t *)&v7->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v26 = TTime::MicrosecondsSinceStartup(v23);
  v27 = dispatch_time(0, 1000 * (a3 - v26));
  dispatch_source_set_timer(v19, v27, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v19);
  v28 = v38;
  if (v38)
  {
    v29 = (unint64_t *)&v38->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  v31 = v35;
  if (v35)
  {
    v32 = (unint64_t *)&v35->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

}

void sub_1CBCFC278(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0(v2);

  _Unwind_Resume(a1);
}

void ___ZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEy_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD v8[5];
  std::__shared_weak_count *v9;

  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3321888768;
  v8[2] = ___ZZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyENK3__0clEv_block_invoke;
  v8[3] = &__block_descriptor_48_ea8_32c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE_e5_v8__0l;
  v2 = *(std::__shared_weak_count **)(a1 + 64);
  v8[4] = *(_QWORD *)(a1 + 56);
  v9 = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  ExceptionSafeBlock(v8);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  v5 = v9;
  if (v9)
  {
    v6 = (unint64_t *)&v9->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1CBCFC348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
    ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke_cold_2(a14);
  _Unwind_Resume(exception_object);
}

id __copy_helper_block_ea8_32c113_ZTSKZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyE3__0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id result;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result = *(id *)(a2 + 48);
  v9 = *(_QWORD *)(a2 + 56);
  v8 = *(_QWORD *)(a2 + 64);
  a1[6] = result;
  a1[7] = v9;
  a1[8] = v8;
  if (v8)
  {
    v10 = (unint64_t *)(v8 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c113_ZTSKZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyE3__0(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 56);

  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v2);
}

void TFolderSizingThread::PostFolderSizingTaskRequest(uint64_t a1, uint64_t a2)
{
  id v4;
  NSObject *v5;
  id *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[4];
  id *v16;
  std::__shared_weak_count *v17;

  v4 = **(id **)a2;
  v5 = *(NSObject **)(*(_QWORD *)a1 + 8);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEE_block_invoke;
  v15[3] = &__block_descriptor_48_ea8_32c108_ZTSKZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEE3__0_e5_v8__0l;
  v6 = *(id **)a2;
  v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v16 = v6;
    v17 = v7;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    dispatch_async(v5, v15);
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    v16 = v6;
    v17 = 0;
    dispatch_async(v5, v15);
  }
  v12 = v17;
  if (v17)
  {
    v13 = (unint64_t *)&v17->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

}

void ___ZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEE_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD v7[5];
  std::__shared_weak_count *v8;

  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3321888768;
  v7[2] = ___ZZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEENK3__0clEv_block_invoke;
  v7[3] = &__block_descriptor_48_ea8_32c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE_e5_v8__0l;
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  v7[4] = *(_QWORD *)(a1 + 32);
  v8 = v1;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldxr(p_shared_owners);
    while (__stxr(v3 + 1, p_shared_owners));
  }
  ExceptionSafeBlock(v7);
  v4 = v8;
  if (v8)
  {
    v5 = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1CBCFC5D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
    ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke_cold_2(a14);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c108_ZTSKZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c108_ZTSKZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEE3__0(uint64_t a1)
{
  return std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](a1 + 32);
}

void ___ZZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyENK3__0clEv_block_invoke(uint64_t a1)
{
  TNode::DispatchResizeRequestNow((id **)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_32c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEENK3__0clEv_block_invoke(uint64_t a1)
{
  TNode::HandleFolderSizingRequests((id **)(a1 + 32));
}

void sub_1CBCFC6B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCFCA90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCFCB70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCFCBF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCFCC54(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCFCD50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  _Unwind_Resume(a1);
}

const void **GetDocumentContainerInfo@<X0>(_BYTE *a1@<X8>)
{
  const char *identifier;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  int v14;
  void *v15;
  void *v16;
  const void *v18[2];
  _QWORD v19[5];
  TString v20;
  id v21;

  identifier = (const char *)container_get_identifier();
  TString::TString(&v20, identifier);
  objc_msgSend(MEMORY[0x1E0CA5870], "bundleRecordWithApplicationIdentifier:error:", v20.fString.fRef, 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "URL");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
    objc_msgSend(v3, "URL");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "URLByAppendingPathComponent:isDirectory:", CFSTR("Info.plist"), 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v18[0] = 0;
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithContentsOfURL:options:error:", v6, 2, v18);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = (id)v18[0];
    v9 = v8;
    if (v7)
    {
      v21 = 0;
      objc_msgSend(MEMORY[0x1E0CB38B0], "propertyListWithData:options:format:error:", v7, 0, 0, &v21);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = v21;

      objc_cast<NSDictionary,objc_object * {__strong}>(v10);
      v12 = (void *)objc_claimAutoreleasedReturnValue();

      if (v12)
      {
        v13 = v12;
        v14 = 0;
      }
      else
      {
        v14 = objc_msgSend(v11, "code");
      }

    }
    else
    {
      v14 = objc_msgSend(v8, "code");
      v12 = 0;
      v11 = v9;
    }

    if (!v14)
    {
      objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("NSUbiquitousContainers"));
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_cast<NSDictionary,objc_object * {__strong}>(v15);
      v16 = (void *)objc_claimAutoreleasedReturnValue();

      LOBYTE(v21) = 0;
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3321888768;
      v19[2] = ___ZL24GetDocumentContainerInfoP18container_object_s_block_invoke;
      v19[3] = &__block_descriptor_40_ea8_32c59_ZTSKZL24GetDocumentContainerInfoP18container_object_sE3__0_e15_v32__0_8_16_B24l;
      v19[4] = &v21;
      objc_msgSend(v16, "enumerateKeysAndObjectsUsingBlock:", v19);
      std::pair<TString,BOOL>::pair[abi:ne180100]<TString const&,BOOL &,0>((uint64_t)v18, (TString **)&v20, &v21);
      std::pair<TString,BOOL>::pair[abi:ne180100]((uint64_t)a1, (uint64_t)v18);
      a1[16] = 1;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v18);

      goto LABEL_12;
    }

  }
  *a1 = 0;
  a1[16] = 0;
LABEL_12:

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
}

void sub_1CBCFCFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  va_list va;

  va_start(va, a9);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBCFD068()
{
  JUMPOUT(0x1CBCFD058);
}

BOOL TContainerFetcher::IsVisible(_BYTE *a1, void *a2)
{
  id v3;
  void *v4;
  _BOOL8 v5;
  void *v6;
  void *v7;
  char v8;
  char v9;
  void *v10;
  TString *v11;
  TCFURLInfo *Length;
  uint64_t *PropertyStoreName;
  TString v15;
  CFStringRef theString;

  v3 = a2;
  v4 = v3;
  if (!*a1 || !a1[1])
  {
    if (!objc_msgSend(v3, "count"))
      goto LABEL_10;
    if (!*a1)
    {
      objc_msgSend(v4, "objectForKeyedSubscript:", *MEMORY[0x1E0C999F0]);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_cast<NSNumber,objc_object * {__strong}>(v6);
      v7 = (void *)objc_claimAutoreleasedReturnValue();

      v8 = objc_msgSend(v7, "BOOLValue");
      v9 = v7 ? v8 : 1;

      if ((v9 & 1) != 0)
      {
LABEL_10:
        v5 = 0;
        goto LABEL_18;
      }
    }
    objc_msgSend(v4, "objectForKeyedSubscript:", *MEMORY[0x1E0C99A90]);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_cast<NSString,objc_object * {__strong}>(v10);
    v11 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    theString = &stru_1E8752DF8;
    CFRetain(&stru_1E8752DF8);
    TString::SetStringRefAsImmutable((TString *)&theString, v11);

    Length = (TCFURLInfo *)CFStringGetLength(theString);
    if (Length)
    {
      if (!*a1)
      {
        TString::TString(&v15, ".", 1uLL);
        v5 = !TString::BeginsWith((TString *)&theString, &v15);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        goto LABEL_17;
      }
      PropertyStoreName = TCFURLInfo::GetPropertyStoreName(Length);
      if (!CFEqual(theString, (CFTypeRef)*PropertyStoreName))
      {
        v5 = !operator==((CFTypeRef *)&theString, ".localized");
        goto LABEL_17;
      }
    }
    v5 = 0;
LABEL_17:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_18;
  }
  v5 = 1;
LABEL_18:

  return v5;
}

void sub_1CBCFD200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  void *v10;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

void TContainerFetcher::FetchContainers(TContainerFetcher *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t count_results;
  void *v10;
  NSObject *v11;
  NSObject *v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  TString *v22;
  id v23;
  void *v25;
  id v26;
  id v27;
  __int128 v28;
  uint64_t v29;
  _QWORD v30[17];
  _BYTE v31[48];
  char v32;
  TNodePtr v33;
  id obj;
  _QWORD v35[2];
  _QWORD v36[4];
  _BYTE buf[12];
  uint64_t v38;
  _QWORD *v39;
  _QWORD v40[5];
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  TString v45;
  const __CFString *v46;
  id v47;
  char v48;
  _QWORD v49[4];

  v49[1] = *MEMORY[0x1E0C80C00];
  v28 = 0uLL;
  v29 = 0;
  v27 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v26 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v3 = *MEMORY[0x1E0C999D0];
  v4 = *MEMORY[0x1E0C99A28];
  v36[0] = *MEMORY[0x1E0C999D0];
  v36[1] = v4;
  v5 = *MEMORY[0x1E0C99AA8];
  v36[2] = *MEMORY[0x1E0C999B8];
  v36[3] = v5;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v36, 4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = v6;
  if (!*(_BYTE *)this)
  {
    v7 = *MEMORY[0x1E0C99A90];
    v35[0] = *MEMORY[0x1E0C999F0];
    v35[1] = v7;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v35, 2);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "arrayByAddingObjectsFromArray:", v8);
    v25 = (void *)objc_claimAutoreleasedReturnValue();

  }
  container_query_create();
  container_query_set_class();
  container_query_set_include_other_owners();
  container_query_set_persona_unique_string();
  container_query_operation_set_flags();
  count_results = container_query_count_results();
  if (count_results < 0)
  {
    if (container_query_get_last_error())
    {
      v10 = (void *)container_error_copy_unlocalized_description();
      if (v10)
      {
        LogObj(5);
        v11 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v10;
          _os_log_impl(&dword_1CBC4A000, v11, OS_LOG_TYPE_ERROR, "Container query failed %{public}s", buf, 0xCu);
        }

        free(v10);
      }
    }
    else
    {
      LogObj(5);
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = count_results;
        _os_log_impl(&dword_1CBC4A000, v12, OS_LOG_TYPE_ERROR, "Container query failed %ld", buf, 0xCu);
      }

    }
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    container_query_iterate_results_sync();
  }
  container_query_free();
  if ((count_results & 0x8000000000000000) == 0)
  {
    v23 = v27;
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)buf, v23);
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v30, -1, v23);
    while (1)
    {
      if (*(_QWORD *)buf == v30[0] && v43 == v30[16])
      {

        *(_OWORD *)a2 = v28;
        a2[2] = v29;
        v29 = 0;
        v28 = 0uLL;
        break;
      }
      v13 = *(id *)(v38 + 8 * v42);
      objc_msgSend(v13, "URLByAppendingPathComponent:isDirectory:", CFSTR("Documents/"), 1);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      v49[0] = v3;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v49, 1);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "resourceValuesForKeys:error:", v15, 0);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "objectForKeyedSubscript:", v3);
      v17 = (void *)objc_claimAutoreleasedReturnValue();

      if (v17)
      {
        obj = 0;
        *(_QWORD *)&v44 = v13;
        if (!TNode::GetNodeFromURL((CFURLRef *)&v44, (TNodePtr *)&obj, 0)
          && TNodeFromFINode((FINode *)obj))
        {
          v44 = 0uLL;
          v45.fString.fRef = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          v46 = &stru_1E8752DF8;
          CFRetain(&stru_1E8752DF8);
          v47 = 0;
          v48 = 0;
          objc_storeStrong((id *)&v44, obj);
          TNodePtr::TNodePtr(&v33, 0);
          TNodePtr::operator=((void **)&v44 + 1, (void **)&v33.fFINode);

          objc_msgSend(v26, "objectForKeyedSubscript:", v13);
          v22 = (TString *)(id)objc_claimAutoreleasedReturnValue();
          if ((TString *)v45.fString.fRef != v22)
            TString::SetStringRefAsImmutable(&v45, v22);

          std::__optional_destruct_base<TAppContainerInfo,false>::__optional_destruct_base[abi:ne180100]<TAppContainerInfo>((uint64_t)v31, (uint64_t)&v44);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v46);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v45.fString.fRef);

          goto LABEL_24;
        }

      }
      LogObj(5);
      v18 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v13, "lastPathComponent");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        LODWORD(v44) = 138412290;
        *(_QWORD *)((char *)&v44 + 4) = v19;
        _os_log_impl(&dword_1CBC4A000, v18, OS_LOG_TYPE_ERROR, "Failed to create node for container %@", (uint8_t *)&v44, 0xCu);

      }
      v31[0] = 0;
      v32 = 0;
LABEL_24:

      if (v32)
        std::vector<TAppContainerInfo>::push_back[abi:ne180100]((uint64_t *)&v28, (uint64_t)v31);
      std::__optional_destruct_base<TAppContainerInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v31);
      v20 = v42;
      if (v42 >= v41 - 1)
      {
        v21 = objc_msgSend(*(id *)buf, "countByEnumeratingWithState:objects:count:", &buf[8], v40, 4);
        v20 = -1;
        v41 = v21;
        v42 = -1;
      }
      if (v40[4] != *v39)
      {
        objc_enumerationMutation(*(id *)buf);
        v20 = v42;
      }
      ++v43;
      v42 = v20 + 1;
    }
  }

  *(_QWORD *)buf = &v28;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_1CBCFD8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,void *a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void **a50)
{
  container_query_free();

  a50 = (void **)&a29;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](&a50);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK17TContainerFetcher15FetchContainersEv_block_invoke(uint64_t a1)
{
  _BYTE *v2;
  const char *path;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v14;
  int v15;
  id v16;
  char v17;
  void *v18;
  void *v19;
  const void *v20;
  char v21;
  char v22;
  id v23;
  TString v24;

  v2 = *(_BYTE **)(a1 + 56);
  path = (const char *)container_get_path();
  TString::TString(&v24, path);
  objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", v24.fString.fRef, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)MEMORY[0x1E0C99E98];
  -[__CFString stringByAppendingPathComponent:](v24.fString.fRef, "stringByAppendingPathComponent:", CFSTR("Documents"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "fileURLWithPath:isDirectory:", v6, 1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v4, "resourceValuesForKeys:error:", **(_QWORD **)(a1 + 40), 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v8 || !TContainerFetcher::IsVisible(v2, v8))
    goto LABEL_7;
  v9 = *MEMORY[0x1E0C999D0];
  objc_msgSend(v8, "objectForKeyedSubscript:", *MEMORY[0x1E0C999D0]);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<NSNumber,objc_object * {__strong}>(v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v11, "BOOLValue") & 1) == 0)
  {
LABEL_6:

LABEL_7:
    goto LABEL_8;
  }
  objc_msgSend(v8, "objectForKeyedSubscript:", *MEMORY[0x1E0C99A28]);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<NSNumber,objc_object * {__strong}>(v19);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v12, "BOOLValue") & 1) != 0)
  {

    goto LABEL_6;
  }
  objc_msgSend(v8, "objectForKeyedSubscript:", *MEMORY[0x1E0C999B8]);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<NSNumber,objc_object * {__strong}>(v18);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = objc_msgSend(v14, "BOOLValue");

  if ((v17 & 1) != 0)
    goto LABEL_8;
  v23 = 0;
  v15 = objc_msgSend(v7, "getResourceValue:forKey:error:", &v23, v9, 0);
  v16 = v23;
  v8 = v16;
  if (!v15 || (objc_msgSend(v16, "BOOLValue") & 1) == 0)
    goto LABEL_7;

  GetDocumentContainerInfo(&v20);
  if (v22)
  {
    if (!v21
      || (objc_msgSend(**(id **)(a1 + 48), "setObject:forKeyedSubscript:", v20, v4),
          objc_msgSend(**(id **)(a1 + 32), "addObject:", v4),
          v22))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v20);
    }
  }
LABEL_8:

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v24.fString.fRef);
  return 1;
}

void sub_1CBCFDCB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  const void *v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, const void *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  if ((_BYTE)v10)
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1CBCFDD64()
{
  JUMPOUT(0x1CBCFDD54);
}

__n128 __copy_helper_block_ea8_32c51_ZTSKZNK17TContainerFetcher15FetchContainersEvE3__1(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

BOOL TContainerFetcher::DirectoryHasVisibleContent(TContainerFetcher *this, const TNodePtr *a2)
{
  TNode *v4;
  NSURL *v5;
  _BOOL8 HasVisibleContent;

  if (!TNodeFromFINode(a2->fFINode))
    return 0;
  v4 = (TNode *)TNodeFromFINode(a2->fFINode);
  v5 = (NSURL *)TNode::CopyURL(v4);
  HasVisibleContent = TContainerFetcher::DirectoryHasVisibleContent(this, v5);

  return HasVisibleContent;
}

void sub_1CBCFDDD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL TContainerFetcher::DirectoryHasVisibleContent(TContainerFetcher *this, NSURL *a2)
{
  NSURL *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  id v7;
  NSObject *v8;
  void *v9;
  _BOOL8 v10;
  void *v11;
  id v12;
  void *v13;
  _BOOL4 IsVisible;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  id v23;
  _QWORD v24[17];
  _QWORD v25[2];
  uint64_t v26;
  _BYTE buf[12];
  __int16 v28;
  _BYTE v29[10];
  _QWORD *v30;
  _QWORD v31[5];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (v3)
  {
    if (!*((_QWORD *)this + 1))
    {
      if (*(_BYTE *)this)
      {
        if (*((_BYTE *)this + 1))
        {
          *((_QWORD *)this + 1) = MEMORY[0x1E0C9AA60];

        }
        else
        {
          v26 = *MEMORY[0x1E0C99A90];
          objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v26, 1);
          v21 = objc_claimAutoreleasedReturnValue();
          v22 = (void *)*((_QWORD *)this + 1);
          *((_QWORD *)this + 1) = v21;

        }
      }
      else
      {
        v18 = *MEMORY[0x1E0C99A90];
        v25[0] = *MEMORY[0x1E0C999F0];
        v25[1] = v18;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v25, 2);
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = (void *)*((_QWORD *)this + 1);
        *((_QWORD *)this + 1) = v19;

      }
    }
    objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = *((_QWORD *)this + 1);
    v23 = 0;
    objc_msgSend(v4, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", v3, v5, 0, &v23);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v23;

    if (!v6)
    {
      LogObj(5);
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        SanitizedURL(v3);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138543618;
        *(_QWORD *)&buf[4] = v9;
        v28 = 2114;
        *(_QWORD *)v29 = v7;
        _os_log_impl(&dword_1CBC4A000, v8, OS_LOG_TYPE_ERROR, "Got Error trying to get content of %{public}@, %{public}@", buf, 0x16u);

      }
    }
    if (*(_BYTE *)this && *((_BYTE *)this + 1))
    {
      v10 = objc_msgSend(v6, "count") != 0;
    }
    else
    {
      IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)buf, v6);
      IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v24, -1, v6);
      while (1)
      {
        v11 = *(void **)buf;
        if (*(_QWORD *)buf == v24[0] && v34 == v24[16])
          break;
        v12 = *(id *)(*(_QWORD *)&v29[2] + 8 * v33);
        objc_msgSend(v12, "resourceValuesForKeys:error:", *((_QWORD *)this + 1), 0);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        IsVisible = TContainerFetcher::IsVisible(this, v13);

        if (IsVisible)
        {
          v10 = 1;
          v11 = (void *)v24[0];
          goto LABEL_25;
        }
        v15 = v33;
        if (v33 >= v32 - 1)
        {
          v16 = objc_msgSend(*(id *)buf, "countByEnumeratingWithState:objects:count:", &buf[8], v31, 4);
          v15 = -1;
          v32 = v16;
          v33 = -1;
        }
        if (v31[4] != *v30)
        {
          objc_enumerationMutation(*(id *)buf);
          v15 = v33;
        }
        v33 = v15 + 1;
        ++v34;
      }
      v10 = 0;
LABEL_25:

    }
  }
  else
  {
    v10 = 0;
  }

  return v10;
}

void sub_1CBCFE10C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t TContainerFetcher::FetchContainersAndDocumentsFolders@<X0>(TContainerFetcher *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  TContainerFetcher *v8[2];

  TContainerFetcher::FetchContainers(this, a2);
  v4 = *a2;
  v5 = a2[1];
  v8[0] = this;
  while (1)
  {
    if (v4 == v5)
    {
      v4 = v5;
      return std::vector<TAppContainerInfo>::erase((uint64_t)a2, v4, a2[1]);
    }
    if ((TContainerFetcher::FetchContainersAndDocumentsFolders(void)const::$_0::operator()(v8, v4) & 1) != 0)
      break;
    v4 += 48;
  }
  if (v4 != v5)
  {
    for (i = v4 + 48; i != v5; i += 48)
    {
      if ((TContainerFetcher::FetchContainersAndDocumentsFolders(void)const::$_0::operator()(v8, i) & 1) == 0)
      {
        TAppContainerInfo::operator=(v4, i);
        v4 += 48;
      }
    }
  }
  return std::vector<TAppContainerInfo>::erase((uint64_t)a2, v4, a2[1]);
}

void sub_1CBCFE238(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void TContainerFetcher::FetchContainersAndDocumentsFolders(TContainerFetcher *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4;
  id v5;
  NSObject *v6;
  void *v7;
  _BOOL4 v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  TString *v11;
  TString *v12;
  uint64_t v13;
  uint64_t v14;
  id v16;
  __int128 v17;
  uint64_t v18;
  id v19[17];
  id v20[17];
  _QWORD v21[17];
  id obj;
  _QWORD v23[8];
  _QWORD v24[5];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[48];
  char v29;
  TNodePtr v30;
  TNodePtr v31;
  __int128 buf;
  TString v33;
  TString v34;
  id v35;
  char v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v16 = a2;
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)v20, v16);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::IDContainerIteratorAdaptor((uint64_t)v19, -1, v16);
  v4 = std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>>((uint64_t)v20, (uint64_t)v19);

  type_traits_extras::CopyAsHelper<std::vector<TAppContainerInfo>>::MakeWithCapacity(v4, (uint64_t)&v17);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)&obj, v16);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::IDContainerIteratorAdaptor((uint64_t)v21, -1, v16);
  while (obj != (id)v21[0] || v27 != v21[16])
  {
    v5 = *(id *)(v23[1] + 8 * v26);
    if (objc_msgSend(v5, "isManaged"))
    {
      LogObj(4);
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v5;
        _os_log_impl(&dword_1CBC4A000, v6, OS_LOG_TYPE_DEBUG, "Ignoring local app library because EDS does not support Local Storage App Libraries: %{public}@", (uint8_t *)&buf, 0xCu);
      }

      v28[0] = 0;
      v29 = 0;
    }
    else
    {
      v31.fFINode = 0;
      objc_msgSend(v5, "documentsURL");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)&buf = v7;
      v8 = TNode::GetNodeFromURL((CFURLRef *)&buf, &v31, 0) == 0;

      if (v8)
      {
        v9 = TNodeFromFINode(v31.fFINode);
        v10 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v9);
        os_unfair_lock_lock(v10);
        TNodePtr::TNodePtr(&v30, *(const TNode **)(v9 + 48));
        os_unfair_lock_unlock(v10);
        *(_QWORD *)&buf = v30.fFINode;
        *((_QWORD *)&buf + 1) = v31.fFINode;
        objc_msgSend(v5, "bundleID");
        v11 = (TString *)(id)objc_claimAutoreleasedReturnValue();
        v33.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v33, v11);

        objc_msgSend(v5, "displayName");
        v12 = (TString *)(id)objc_claimAutoreleasedReturnValue();
        v34.fString.fRef = &stru_1E8752DF8;
        CFRetain(&stru_1E8752DF8);
        TString::SetStringRefAsImmutable(&v34, v12);

        v35 = v5;
        v36 = 0;

        if (TContainerFetcher::DirectoryHasVisibleContent(a1, &v31))
          v36 = 1;
        std::__optional_destruct_base<TAppContainerInfo,false>::__optional_destruct_base[abi:ne180100]<TAppContainerInfo>((uint64_t)v28, (uint64_t)&buf);

        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v33.fString.fRef);

      }
      else
      {
        v28[0] = 0;
        v29 = 0;
      }

    }
    if (v29)
      std::vector<TAppContainerInfo>::push_back[abi:ne180100]((uint64_t *)&v17, (uint64_t)v28);
    std::__optional_destruct_base<TAppContainerInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v28);
    v13 = v26;
    if (v26 >= v25 - 1)
    {
      v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v23, v24, 4);
      v13 = -1;
      v25 = v14;
      v26 = -1;
    }
    if (v24[4] != *(_QWORD *)v23[2])
    {
      objc_enumerationMutation(obj);
      v13 = v26;
    }
    ++v27;
    v26 = v13 + 1;
  }

  *(_OWORD *)a3 = v17;
  *(_QWORD *)(a3 + 16) = v18;
  v17 = 0uLL;
  v18 = 0;
  obj = &v17;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&obj);

}

void sub_1CBCFE648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  id a67;
  uint64_t v67;

  *(_QWORD *)(v67 - 216) = &a13;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)(v67 - 216));

  _Unwind_Resume(a1);
}

void ___ZL24GetDocumentContainerInfoP18container_object_s_block_invoke(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  void *v6;
  void *v7;
  int v8;
  id v9;

  objc_cast<NSDictionary,objc_object * {__strong}>(a3);
  v9 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("NSUbiquitousContainerIsDocumentScopePublic"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_cast<NSNumber,objc_object * {__strong}>(v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v7, "BOOLValue");

  if (v8)
  {
    **(_BYTE **)(a1 + 32) = 1;
    *a4 = 1;
  }

}

void sub_1CBCFE828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c59_ZTSKZL24GetDocumentContainerInfoP18container_object_sE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t std::pair<TString,BOOL>::pair[abi:ne180100]<TString const&,BOOL &,0>(uint64_t a1, TString **a2, _BYTE *a3)
{
  *(_QWORD *)a1 = &stru_1E8752DF8;
  CFRetain(&stru_1E8752DF8);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_BYTE *)(a1 + 8) = *a3;
  return a1;
}

void sub_1CBCFE8B4(_Unwind_Exception *a1)
{
  const void **v1;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TString,BOOL>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a2, &stru_1E8752DF8);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  return a1;
}

void TAppContainerInfo::~TAppContainerInfo(TAppContainerInfo *this)
{

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 2);

}

uint64_t std::__optional_destruct_base<TAppContainerInfo,false>::__optional_destruct_base[abi:ne180100]<TAppContainerInfo>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;

  v4 = TNodePtr::TNodePtr((_QWORD *)a1, (id *)a2);
  TNodePtr::TNodePtr(v4 + 1, (id *)(a2 + 8));
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 16), &stru_1E8752DF8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 24), &stru_1E8752DF8);
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a1 + 32) = v5;
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 48) = 1;
  return a1;
}

uint64_t std::vector<TAppContainerInfo>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    if (v10 + 1 > 0x555555555555555)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    v12 = 2 * v11;
    if (2 * v11 <= v10 + 1)
      v12 = v10 + 1;
    if (v11 >= 0x2AAAAAAAAAAAAAALL)
      v13 = 0x555555555555555;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[48 * v10];
    v18 = &v14[48 * v13];
    std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>((uint64_t)v16, a2);
    v17 = v16 + 48;
    std::vector<TAppContainerInfo>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 48;
    a1[1] = v7 + 48;
  }
  a1[1] = v9;
  return result;
}

void sub_1CBCFEAF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;

  v4 = TNodePtr::TNodePtr((_QWORD *)a1, (id *)a2);
  TNodePtr::TNodePtr(v4 + 1, (id *)(a2 + 8));
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 16), &stru_1E8752DF8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 24), &stru_1E8752DF8);
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a1 + 32) = v5;
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  return a1;
}

uint64_t *std::vector<TAppContainerInfo>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 48;
    v4 -= 48;
    result = (uint64_t *)std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>(v6, v4);
  }
  a2[1] = v6;
  v7 = *v3;
  *v3 = v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

uint64_t std::__split_buffer<TAppContainerInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 48;
    std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(i - 48);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__optional_destruct_base<TAppContainerInfo,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 48))
  {

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));

  }
  return a1;
}

uint64_t std::vector<TAppContainerInfo>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TAppContainerInfo *,TAppContainerInfo *,TAppContainerInfo *,0>(a3, *(_QWORD *)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v7 -= 48;
        std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(v7);
      }
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TAppContainerInfo *,TAppContainerInfo *,TAppContainerInfo *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      TAppContainerInfo::operator=(a3, v4);
      v4 += 48;
      a3 += 48;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t TAppContainerInfo::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;

  TNodePtr::operator=((void **)a1, (void **)a2);
  TNodePtr::operator=((void **)(a1 + 8), (void **)(a2 + 8));
  if (a1 != a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 16), (const void **)(a2 + 16));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 16), &stru_1E8752DF8);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 24), (const void **)(a2 + 24));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 24), &stru_1E8752DF8);
  }
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  v5 = *(void **)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v4;

  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  return a1;
}

uint64_t TContainerFetcher::FetchContainersAndDocumentsFolders(void)const::$_0::operator()(TContainerFetcher **a1, uint64_t a2)
{
  TContainerFetcher *v3;
  TNode *v4;
  _BOOL4 HasVisibleContent;
  uint64_t v6;
  TString v8;
  id obj;

  v3 = *a1;
  v4 = (TNode *)TNodeFromFINode(*(FINode **)a2);
  TString::TString(&v8, "Documents", 9uLL);
  TNode::FindChild(v4, (TNode *)&v8, 0, 0, &obj);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
  if (TNodeFromFINode((FINode *)obj))
  {
    objc_storeStrong((id *)(a2 + 8), obj);
    HasVisibleContent = TContainerFetcher::DirectoryHasVisibleContent(v3, (const TNodePtr *)&obj);
    if (HasVisibleContent)
      *(_BYTE *)(a2 + 40) = 1;
    v6 = !HasVisibleContent;
  }
  else
  {
    v6 = 1;
  }

  return v6;
}

void sub_1CBCFEF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[17];
  id obj;
  _QWORD v9[8];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)v7, a2);
  v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    v4 = v12;
    if (v12 >= v11 - 1)
    {
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v9, v10, 4);
      v4 = -1;
      v11 = v5;
      v12 = -1;
    }
    if (v10[4] != *(_QWORD *)v9[2])
    {
      objc_enumerationMutation(obj);
      v4 = v12;
    }
    v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1CBCFF03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{

  _Unwind_Resume(a1);
}

void type_traits_extras::CopyAsHelper<std::vector<TAppContainerInfo>>::MakeWithCapacity(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3;
  uint64_t v4;
  void **v5;

  v3 = 0uLL;
  v4 = 0;
  std::vector<TAppContainerInfo>::reserve((uint64_t *)&v3, a1);
  *(_OWORD *)a2 = v3;
  *(_QWORD *)(a2 + 16) = v4;
  v4 = 0;
  v3 = 0uLL;
  v5 = (void **)&v3;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_1CBCFF0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(id *)a2;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 128) = -1;
  if (v4 && objc_msgSend(v4, "count") && (v7 = *(_QWORD *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    v8 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 112) = v8;
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *v6 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    v9 = *(_QWORD *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *v5 = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
            v11 = -1;
            *v6 = -1;
          }
          if (*(_QWORD *)(a1 + 104) != **(_QWORD **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            v11 = *v6;
          }
          v13 = *(_QWORD *)(a1 + 128) + 1;
          *(_QWORD *)(a1 + 120) = ++v11;
          *(_QWORD *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(_QWORD *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1CBCFF244(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = v3;
  *(_QWORD *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  if (v3 && objc_msgSend(v3, "count"))
  {
    *(_QWORD *)(a1 + 112) = objc_msgSend(*(id *)a1, "countByEnumeratingWithState:objects:count:", a1 + 8, a1 + 72, 4);
    *(_QWORD *)(a1 + 104) = **(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1CBCFF304(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 128) = objc_msgSend(v4, "count");

  return a1;
}

void sub_1CBCFF380(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::vector<TAppContainerInfo>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 48 * v6;
    std::vector<TAppContainerInfo>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1CBCFF434(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1CBCFF4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBCFF610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBCFF714(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCFF7E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1CBCFFAE4(_Unwind_Exception *a1, id *a2, void *a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  va_list va;

  va_start(va, a3);
  +[FIDSNode_FPv2 makeWithCoder:]::$_0::~$_0(a2);
  +[FIDSNode_FPv2 makeWithCoder:]::$_0::~$_0((id *)va);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100](v6 - 96);

  _Unwind_Resume(a1);
}

void sub_1CBCFFC78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c44_ZTSKZ31__FIDSNode_FPv2_makeWithCoder__E3__0(_QWORD *a1, uint64_t a2)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  id result;

  v4 = *(id *)(a2 + 32);
  v6 = *(_QWORD *)(a2 + 40);
  v5 = *(_QWORD *)(a2 + 48);
  a1[4] = v4;
  a1[5] = v6;
  a1[6] = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  a1[7] = *(id *)(a2 + 56);
  result = *(id *)(a2 + 64);
  a1[8] = result;
  return result;
}

void __destroy_helper_block_ea8_32c44_ZTSKZ31__FIDSNode_FPv2_makeWithCoder__E3__0(id *a1)
{

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 5));
}

void sub_1CBCFFE24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1CBCFFE8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBCFFED0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBD000D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id FIDSNodeSubclassForVirtualType(unsigned int a1)
{
  void *v1;

  if (a1 <= 0x23 && ((0xFFFFF18FFuLL >> a1) & 1) != 0)
  {
    objc_opt_class();
    v1 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v1 = 0;
  }
  return v1;
}

void sub_1CBD00424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  va_list va;

  va_start(va, a12);

  objc_sync_exit(v13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBD0057C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;

  objc_sync_exit(v9);

  _Unwind_Resume(a1);
}

void sub_1CBD006FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBD00864(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBD009B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD00AC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  os_unfair_lock_s *v11;

  os_unfair_lock_unlock(v11);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1CBD00DDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);
  v4 = v3;

  TProgressInfo::~TProgressInfo((TProgressInfo *)va);
  _Unwind_Resume(a1);
}

void sub_1CBD00FC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);

  TProgressInfo::~TProgressInfo((TProgressInfo *)va);
  _Unwind_Resume(a1);
}

void sub_1CBD010B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBD01244(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1CBD012F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1CBD01380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD01458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD01530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD016D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBD019F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1CBD01C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

id objc_cast<UTType,NSObject * {__strong}>(void *a1)
{
  id v2;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2;
}

void sub_1CBD01D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBD01E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD02000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1CBD02254(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1CBD0236C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD0246C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBD0258C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1CBD0267C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD027F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  void *v13;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1CBD02988(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a10);
  _Unwind_Resume(a1);
}

void sub_1CBD02A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
  TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1CBD031B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  const void *v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  va_list va1;
  va_list va2;

  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  v13 = va_arg(va1, const void *);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v17 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  _Unwind_Resume(a1);
}

void sub_1CBD03524()
{
  JUMPOUT(0x1CBD03510);
}

void sub_1CBD0360C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, void **a14)
{
  void *v14;

  a14 = (void **)&a10;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](&a14);
  TNodeEventPtr::~TNodeEventPtr(&a13);

  _Unwind_Resume(a1);
}

void sub_1CBD0375C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id a15, void **a16)
{
  void *v16;

  a16 = (void **)&a10;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](&a16);

  _Unwind_Resume(a1);
}

void TNode::CreateCustomNode(TNode *this, FIDSNode *a2)
{
  TNode *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  const char *ClassName;
  std::__shared_weak_count *v11;
  TNodePtr v12;
  char v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  int v16;

  v2 = this;
  v16 = 1;
  v13 = 4;
  ClassName = object_getClassName(v2);
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,char const*,TCatalogInfo &,void>(&v13, &ClassName, (unsigned __int8 *)&v16, &v14);
  v3 = -[TNode asTNode](v2, "asTNode");
  TNodePtr::TNodePtr(&v12, 0);
  ClassName = 0;
  v11 = 0;
  TNode::TNode(v3, &v12, &v14, &ClassName);
  v4 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  +[FINode trackNodeCreated:](FINode, "trackNodeCreated:", v2);
  v7 = v15;
  if (v15)
  {
    v8 = (unint64_t *)&v15->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

}

void sub_1CBD038C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  id v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, id);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va);

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<FIDSNode_FPv2 * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8752C18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<FIDSNode_FPv2 * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E8752C18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

void std::__shared_ptr_emplace<FIDSNode_FPv2 * {__strong}>::__on_zero_shared(uint64_t a1)
{

}

_QWORD *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,char const*,TCatalogInfo &,void>@<X0>(char *a1@<X1>, const char **a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x98uLL);
  result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,char const*,TCatalogInfo &,std::allocator<TFSInfo>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1CBD039AC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,char const*,TCatalogInfo &,std::allocator<TFSInfo>,0>(_QWORD *a1, char *a2, const char **a3, unsigned __int8 *a4)
{
  a1[2] = 0;
  *a1 = &unk_1E87507A0;
  a1[1] = 0;
  std::construct_at[abi:ne180100]<TFSInfo,FSInfoVirtualType,char const*,TCatalogInfo &,TFSInfo*>((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_1CBD039F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<TFSInfo,FSInfoVirtualType,char const*,TCatalogInfo &,TFSInfo*>(uint64_t a1, char *a2, const char **a3, unsigned __int8 *a4)
{
  char v6;
  TString v8;

  v6 = *a2;
  TString::TString(&v8, *a3);
  TFSInfo::TFSInfo(a1, v6, &v8, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
  return a1;
}

void sub_1CBD03A6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void DeEscapeFormatFragment(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  size_t v3;
  const void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *__p[2];
  char v9;
  std::string::value_type __s[8];
  char v11;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v4 = *(const void **)a1;
  if (v3 >= 0x17)
  {
    v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17)
      v6 = v3 | 7;
    v7 = v6 + 1;
    v5 = operator new(v6 + 1);
    a2->__r_.__value_.__l.__size_ = v3;
    a2->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    a2->__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
    goto LABEL_8;
  }
  *((_BYTE *)&a2->__r_.__value_.__s + 23) = v3;
  v5 = a2;
  if (v3)
LABEL_8:
    memmove(v5, v4, v3);
  *((_BYTE *)v5 + v3) = 0;
  v11 = 2;
  strcpy(__s, "%%");
  v9 = 1;
  LOWORD(__p[0]) = 37;
  ReplaceAll(a2, __s, 2uLL, (const std::string::value_type *)__p, 1uLL);
  if (v9 < 0)
    operator delete(__p[0]);
  if (v11 < 0)
    operator delete(*(void **)__s);
  v11 = 2;
  strcpy(__s, "{{");
  v9 = 1;
  LOWORD(__p[0]) = 123;
  ReplaceAll(a2, __s, 2uLL, (const std::string::value_type *)__p, 1uLL);
  if (v9 < 0)
    operator delete(__p[0]);
  if (v11 < 0)
    operator delete(*(void **)__s);
  v11 = 2;
  strcpy(__s, "}}");
  v9 = 1;
  LOWORD(__p[0]) = 125;
  ReplaceAll(a2, __s, 2uLL, (const std::string::value_type *)__p, 1uLL);
  if (v9 < 0)
    operator delete(__p[0]);
  if (v11 < 0)
    operator delete(*(void **)__s);
}

void sub_1CBD03C40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (*(char *)(v20 + 23) < 0)
    operator delete(*(void **)v20);
  _Unwind_Resume(exception_object);
}

BOOL std::string_view::starts_with[abi:ne180100](_QWORD *a1, void *__s2, size_t a3)
{
  return a1[1] >= a3 && std::string_view::compare[abi:ne180100](a1, 0, a3, __s2, a3) == 0;
}

_QWORD *std::sub_match<char const*>::str[abi:ne180100]@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  if (*((_BYTE *)result + 16))
    return std::string::__init_with_size[abi:ne180100]<char *,char *>(a2, (char *)*result, (char *)result[1], result[1] - *result);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

_QWORD *std::match_results<char const*>::str[abi:ne180100]@<X0>(_QWORD *result@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[1] - *result) >> 3) <= a2)
    v3 = (uint64_t)(result + 3);
  else
    v3 = *result + 24 * a2;
  if (*(_BYTE *)(v3 + 16))
    return std::string::__init_with_size[abi:ne180100]<char *,char *>(a3, *(char **)v3, *(char **)(v3 + 8), *(_QWORD *)(v3 + 8) - *(_QWORD *)v3);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  return result;
}

double ReplaceAll(std::string *this, std::string::value_type *__s, std::string::size_type __n, const std::string::value_type *a4, std::string::size_type a5)
{
  std::string::size_type v10;
  double result;
  std::string::size_type v12;
  std::string::size_type size;
  std::string::size_type v14;
  std::string *v15;
  std::string::size_type v16;
  std::string::size_type v17;
  std::string::size_type i;
  std::string::size_type v19;
  std::string *v20;
  std::string::size_type v21;
  std::string v22;
  std::string v23;
  char v24;

  if (__n != a5 && SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0 && this->__r_.__value_.__l.__size_ > 0x3E8)
  {
    v10 = std::string::find(this, __s, 0, __n);
    if (v10 == -1)
      return result;
    v12 = v10;
    memset(&v23, 0, sizeof(v23));
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    else
      size = this->__r_.__value_.__l.__size_;
    std::string::reserve(&v23, size);
    v14 = 0;
    while (1)
    {
      if (v12 != v14)
      {
        std::string::basic_string(&v22, this, v14, v12 - v14, (std::allocator<char> *)&v24);
        v15 = (v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v22
            : (std::string *)v22.__r_.__value_.__r.__words[0];
        v16 = (v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? HIBYTE(v22.__r_.__value_.__r.__words[2])
            : v22.__r_.__value_.__l.__size_;
        std::string::append(&v23, (const std::string::value_type *)v15, v16);
        if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
          break;
      }
      if (a5)
        goto LABEL_18;
LABEL_19:
      v14 = v12 + __n;
      v12 = std::string::find(this, __s, v12 + __n, __n);
      if (v12 == -1)
      {
        v19 = HIBYTE(this->__r_.__value_.__r.__words[2]);
        if ((v19 & 0x80u) != 0)
          v19 = this->__r_.__value_.__l.__size_;
        std::string::basic_string(&v22, this, v14, v19 - v14, (std::allocator<char> *)&v24);
        if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v20 = &v22;
        else
          v20 = (std::string *)v22.__r_.__value_.__r.__words[0];
        if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v21 = HIBYTE(v22.__r_.__value_.__r.__words[2]);
        else
          v21 = v22.__r_.__value_.__l.__size_;
        std::string::append(&v23, (const std::string::value_type *)v20, v21);
        if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v22.__r_.__value_.__l.__data_);
        if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
          operator delete(this->__r_.__value_.__l.__data_);
        result = *(double *)&v23.__r_.__value_.__l.__data_;
        *this = v23;
        return result;
      }
    }
    operator delete(v22.__r_.__value_.__l.__data_);
    if (!a5)
      goto LABEL_19;
LABEL_18:
    std::string::append(&v23, a4, a5);
    goto LABEL_19;
  }
  v17 = std::string::find(this, __s, 0, __n);
  if (v17 != -1)
  {
    for (i = v17; i != -1; i = std::string::find(this, __s, i + a5, __n))
      std::string::replace(this, i, __n, a4, a5);
  }
  return result;
}

void sub_1CBD03F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void ExtractEmbeddedFormat(std::string *__str@<X0>, _QWORD *a2@<X8>)
{
  std::string::size_type size;
  std::string *v5;
  unsigned __int8 *v6;
  std::string *v7;
  uint64_t v8;
  int64_t v9;
  int64_t v10;
  std::string *v11;
  size_t v12;
  const void *v13;
  std::string::size_type v14;
  std::string::size_type v15;
  _QWORD *v16;
  _QWORD v17[2];
  std::string v18;

  std::string::basic_string(&v18, __str, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v17);
  size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v18;
  else
    v5 = (std::string *)v18.__r_.__value_.__r.__words[0];
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v18.__r_.__value_.__l.__size_;
  if (size)
  {
    v6 = (unsigned __int8 *)v5 + size;
    v7 = v5;
LABEL_8:
    v8 = 0;
    while (v7->__r_.__value_.__s.__data_[0] != asc_1CBD2B109[v8])
    {
      if (++v8 == 3)
      {
        v7 = (std::string *)((char *)v7 + 1);
        if (v7 != (std::string *)v6)
          goto LABEL_8;
        v7 = (std::string *)v6;
        break;
      }
    }
    v9 = (char *)v7 - (char *)v5;
    if (v7 == (std::string *)v6)
      v10 = 0;
    else
      v10 = v9 + 1;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_17;
  }
  else
  {
    v10 = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
LABEL_17:
      operator delete(v18.__r_.__value_.__l.__data_);
  }
  if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = __str;
  else
    v11 = (std::string *)__str->__r_.__value_.__r.__words[0];
  v17[0] = (char *)v11 + v10;
  v17[1] = strlen((const char *)v11 + v10);
  ParseFormat(v17, (uint64_t)&v18);
  v12 = v18.__r_.__value_.__l.__size_;
  if (v18.__r_.__value_.__l.__size_ >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v13 = (const void *)v18.__r_.__value_.__r.__words[0];
  if (v18.__r_.__value_.__l.__size_ >= 0x17)
  {
    v14 = (v18.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18.__r_.__value_.__l.__size_ | 7) != 0x17)
      v14 = v18.__r_.__value_.__l.__size_ | 7;
    v15 = v14 + 1;
    v16 = operator new(v14 + 1);
    a2[1] = v12;
    a2[2] = v15 | 0x8000000000000000;
    *a2 = v16;
    a2 = v16;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v18.__r_.__value_.__s.__data_[8];
    if (!v12)
      goto LABEL_29;
  }
  memmove(a2, v13, v12);
LABEL_29:
  *((_BYTE *)a2 + v12) = 0;
}

void PrependEachLine(const void **a1@<X0>, const void **a2@<X1>, std::string *a3@<X8>)
{
  void **v4;
  std::string::size_type v5;
  void *__p[2];
  unsigned __int8 v7;

  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, a1, (uint64_t)a3);
  std::operator+<char>();
  if ((v7 & 0x80u) == 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if ((v7 & 0x80u) == 0)
    v5 = v7;
  else
    v5 = (std::string::size_type)__p[1];
  ReplaceAll(a3, "\n", 1uLL, (const std::string::value_type *)v4, v5);
  if ((char)v7 < 0)
    operator delete(__p[0]);
}

void sub_1CBD04194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v15 + 23) < 0)
    operator delete(*(void **)v15);
  _Unwind_Resume(exception_object);
}

uint64_t std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  size_t v5;
  size_t v6;
  uint64_t result;
  char *v8;
  const void *v9;
  char *v10;
  const void *v11;

  if (*((char *)a1 + 23) >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  if (*((char *)a2 + 23) >= 0)
    v6 = *((unsigned __int8 *)a2 + 23);
  else
    v6 = (size_t)a2[1];
  result = std::string::basic_string[abi:ne180100](a3, v6 + v5);
  if (*(char *)(result + 23) >= 0)
    v8 = (char *)result;
  else
    v8 = *(char **)result;
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0)
      v9 = a1;
    else
      v9 = *a1;
    result = (uint64_t)memmove(v8, v9, v5);
  }
  v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0)
      v11 = a2;
    else
      v11 = *a2;
    result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

void AppendEachLine(const void **a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  size_t v5;
  void **v6;
  const void *v7;
  void **v8;
  std::string::size_type v9;
  void *__p[2];
  unsigned __int8 v11;

  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, (const void **)a2, (uint64_t)a3);
  if (*(char *)(a2 + 23) >= 0)
    v5 = *(unsigned __int8 *)(a2 + 23);
  else
    v5 = *(_QWORD *)(a2 + 8);
  v6 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v5 + 1);
  if ((v11 & 0x80u) != 0)
    v6 = (void **)__p[0];
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0)
      v7 = (const void *)a2;
    else
      v7 = *(const void **)a2;
    memmove(v6, v7, v5);
  }
  *(_WORD *)((char *)v6 + v5) = 10;
  if ((v11 & 0x80u) == 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  if ((v11 & 0x80u) == 0)
    v9 = v11;
  else
    v9 = (std::string::size_type)__p[1];
  ReplaceAll(a3, "\n", 1uLL, (const std::string::value_type *)v8, v9);
  if ((char)v11 < 0)
    operator delete(__p[0]);
}

void sub_1CBD04364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;

  if (a14 < 0)
    operator delete(__p);
  if (*(char *)(v14 + 23) < 0)
    operator delete(*(void **)v14);
  _Unwind_Resume(exception_object);
}

void ExtendedFormatPrefixAndPostfix(char *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned __int8 v4;
  uint64_t v5;
  char *v6;
  void **v7;
  unint64_t v8;
  void **v9;
  BOOL v10;
  char **v11;
  char **v12;
  void **v13;
  _BYTE *v14;
  void **v15;
  void **v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unsigned __int8 v21;
  char *v22;
  char *v23;
  char *v24;
  size_t v25;
  std::vector<std::csub_match>::pointer begin;
  unint64_t v27;
  std::vector<std::csub_match>::pointer p_p;
  __int128 v29;
  uint64_t v30;
  std::match_results<const char *> __p;
  char v32[8];
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  void *v36[8];
  char v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  char v41;
  uint64_t v42;

  v36[6] = 0;
  v36[7] = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  memset(v36, 0, 41);
  if ((v4 & 1) == 0
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPattern, "[{]([^{}%]*:)?([^}%]*)[%}](.|\\n)*", 0);
  }
  v5 = a1[23];
  if ((v5 & 0x80u) == 0)
    v6 = a1;
  else
    v6 = *(char **)a1;
  if ((v5 & 0x80u) != 0)
    v5 = *((_QWORD *)a1 + 1);
  if (!std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(v6, &v6[v5], (uint64_t)v36, (uint64_t)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPattern, 0))
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    goto LABEL_45;
  }
  v7 = (void **)v36[0];
  v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v36[1] - (char *)v36[0]) >> 3);
  v9 = (void **)((char *)v36[0] + 64);
  if (v8 <= 2)
    v9 = &v36[5];
  if (*(_BYTE *)v9)
  {
    v10 = v8 > 2;
    if (v8 <= 2)
      v11 = (char **)&v36[3];
    else
      v11 = (char **)((char *)v36[0] + 48);
    v12 = (char **)((char *)v36[0] + 56);
    if (!v10)
      v12 = (char **)&v36[4];
    std::string::__init_with_size[abi:ne180100]<char *,char *>(&v34, *v11, *v12, *v12 - *v11);
    v7 = (void **)v36[0];
    v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v36[1] - (char *)v36[0]) >> 3);
  }
  else
  {
    v34 = 0uLL;
    v35 = 0;
  }
  v13 = v7 + 6;
  if (v8 <= 2)
    v13 = &v36[3];
  v14 = *v13;
  v15 = v7 + 8;
  if (v8 <= 2)
    v15 = &v36[5];
  if (*(_BYTE *)v15)
  {
    v16 = v7 + 7;
    if (v8 <= 2)
      v16 = &v36[4];
    v17 = (char *)((_BYTE *)*v16 - v14);
  }
  else
  {
    v17 = 0;
  }
  v18 = &v14[(_QWORD)v17 - v42];
  if (a1[23] >= 0)
    v19 = a1;
  else
    v19 = *(char **)a1;
  __p.__matches_.__begin_ = (std::vector<std::csub_match>::pointer)&v18[(_QWORD)v19];
  __p.__matches_.__end_ = (std::vector<std::csub_match>::pointer)strlen(&v18[(_QWORD)v19]);
  ParseFormat(&__p, (uint64_t)v32);
  v20 = v33;
  if (v33)
  {
    memset(&__p.__prefix_, 0, 17);
    memset(&__p.__suffix_, 0, 17);
    __p.__ready_ = 0;
    __p.__position_start_ = 0;
    memset(&__p, 0, 41);
    if ((v21 & 1) == 0
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPostfix, "([^}]*)[}](.|\\n)*", 0);
    }
    v22 = &v18[v20];
    if (a1[23] >= 0)
      v23 = a1;
    else
      v23 = *(char **)a1;
    v24 = &v22[(_QWORD)v23];
    v25 = strlen(&v22[(_QWORD)v23]);
    if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPostfix, v24, &v24[v25], &__p, 4160))
    {
      if (!__p.__suffix_.matched)
      {
        begin = __p.__matches_.__begin_;
        v27 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__matches_.__end_ - (char *)__p.__matches_.__begin_) >> 3);
        if (v27 <= 1)
          p_p = (std::vector<std::csub_match>::pointer)&__p;
        else
          p_p = __p.__matches_.__begin_;
        if (p_p[1].matched)
        {
          if (v27 <= 1)
            begin = (std::vector<std::csub_match>::pointer)&__p;
          std::string::__init_with_size[abi:ne180100]<char *,char *>(&v29, (char *)begin[1].first, (char *)begin[1].second, begin[1].second - begin[1].first);
        }
        else
        {
          v29 = 0uLL;
          v30 = 0;
        }
        std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>((std::string *)a2, &v34, &v29);
        if (SHIBYTE(v30) < 0)
          operator delete((void *)v29);
        goto LABEL_40;
      }
      __p.__matches_.__end_ = __p.__matches_.__begin_;
    }
    std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,char const(&)[1],0>((std::string *)a2, &v34, "");
LABEL_40:
    if (__p.__matches_.__begin_)
    {
      __p.__matches_.__end_ = __p.__matches_.__begin_;
      operator delete(__p.__matches_.__begin_);
    }
    goto LABEL_43;
  }
  std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,char const(&)[1],0>((std::string *)a2, &v34, "");
LABEL_43:
  if (SHIBYTE(v35) < 0)
    operator delete((void *)v34);
LABEL_45:
  if (v36[0])
  {
    v36[1] = v36[0];
    operator delete(v36[0]);
  }
}

void sub_1CBD0471C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v38;
  void *v40;

  if (__p)
    operator delete(__p);
  if (a38 < 0)
    operator delete(a33);
  v40 = *(void **)(v38 - 160);
  if (v40)
  {
    *(_QWORD *)(v38 - 152) = v40;
    operator delete(v40);
  }
  _Unwind_Resume(a1);
}

void ExtendedFormatAdaptor(char *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  std::string __p;
  void *v8[2];
  unsigned __int8 v9;
  void *v10[2];
  unsigned __int8 v11;

  ExtendedFormatPrefixAndPostfix(a1, (uint64_t)v8);
  v5 = v9;
  if ((v9 & 0x80u) != 0)
    v5 = (unint64_t)v8[1];
  if (v5)
    goto LABEL_7;
  v6 = v11;
  if ((v11 & 0x80u) != 0)
    v6 = (unint64_t)v10[1];
  if (v6)
  {
LABEL_7:
    PrependEachLine((const void **)a2, (const void **)v8, &__p);
    AppendEachLine((const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)v10, a3);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
  if ((char)v11 < 0)
    operator delete(v10[0]);
  if ((char)v9 < 0)
    operator delete(v8[0]);
}

void sub_1CBD0489C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::pair<std::string,std::string>::~pair((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void WidenHexFormatStringSpecifierToLongLong(char *__s1@<X0>, uint64_t a2@<X8>)
{
  const char *v4;
  unsigned __int8 v5;
  uint64_t v6;
  char *v7;
  char *v8;
  unint64_t v9;
  void **v10;
  void **v11;
  unsigned int v12;
  BOOL v13;
  char **v14;
  char **v15;
  void **v16;
  std::string::size_type v17;
  void **v18;
  std::string::size_type v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  unint64_t v24;
  void **v25;
  unsigned int v26;
  BOOL v27;
  char **v28;
  char **v29;
  void **v30;
  std::string::size_type v31;
  void **p_p;
  std::string::size_type v33;
  std::string *v34;
  __int128 v35;
  void *__p;
  std::string::size_type v37;
  uint64_t v38;
  void *v39;
  std::string::size_type v40;
  uint64_t v41;
  std::string v42;
  std::string v43;
  std::string v44;
  void *v45[8];
  char v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  char v50;
  uint64_t v51;

  if ((__s1[23] & 0x80000000) == 0)
  {
    v4 = __s1;
    if (*(_WORD *)__s1 != 30757)
      goto LABEL_3;
LABEL_17:
    *(_BYTE *)(a2 + 23) = 4;
    strcpy((char *)a2, "%llx");
    return;
  }
  v4 = *(const char **)__s1;
  if (!strncmp(*(const char **)__s1, "%x", 2uLL))
    goto LABEL_17;
LABEL_3:
  if (!strncmp(v4, "%p", 2uLL))
  {
    *(_BYTE *)(a2 + 23) = 2;
    strcpy((char *)a2, "%p");
  }
  else
  {
    if ((v5 & 1) == 0
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&WidenHexFormatStringSpecifierToLongLong(std::string const&)::hexFormatPattern, "(%)([+\\- #0]?[0-9]*)(hh|h|ll|l|j|z|t)?([xXp])(.|\\n)*", 0);
    }
    v45[6] = 0;
    v45[7] = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v50 = 0;
    v51 = 0;
    memset(v45, 0, 41);
    v6 = __s1[23];
    if ((v6 & 0x80u) == 0)
      v7 = __s1;
    else
      v7 = *(char **)__s1;
    if ((v6 & 0x80u) != 0)
      v6 = *((_QWORD *)__s1 + 1);
    if (std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(v7, &v7[v6], (uint64_t)v45, (uint64_t)&WidenHexFormatStringSpecifierToLongLong(std::string const&)::hexFormatPattern, 0))
    {
      v8 = (char *)v45[0];
      v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v45[1] - (char *)v45[0]) >> 3);
      if (v9 <= 1)
        v10 = v45;
      else
        v10 = (void **)v45[0];
      if (*((_BYTE *)v10 + 40))
      {
        std::string::__init_with_size[abi:ne180100]<char *,char *>(&v42, (char *)v10[3], (char *)v10[4], (_BYTE *)v10[4] - (_BYTE *)v10[3]);
        v8 = (char *)v45[0];
        v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v45[1] - (char *)v45[0]) >> 3);
      }
      else
      {
        memset(&v42, 0, sizeof(v42));
      }
      v11 = (void **)(v8 + 64);
      if (v9 <= 2)
        v11 = &v45[5];
      v12 = *(unsigned __int8 *)v11;
      if (v12)
      {
        v13 = v9 > 2;
        if (v9 <= 2)
          v14 = (char **)&v45[3];
        else
          v14 = (char **)(v8 + 48);
        v15 = (char **)(v8 + 56);
        if (!v13)
          v15 = (char **)&v45[4];
        std::string::__init_with_size[abi:ne180100]<char *,char *>(&v39, *v14, *v15, *v15 - *v14);
        v12 = HIBYTE(v41);
        v16 = (void **)v39;
        v17 = v40;
      }
      else
      {
        v17 = 0;
        v16 = 0;
        v39 = 0;
        v40 = 0;
        v41 = 0;
      }
      if ((v12 & 0x80u) == 0)
        v18 = &v39;
      else
        v18 = v16;
      if ((v12 & 0x80u) == 0)
        v19 = v12;
      else
        v19 = v17;
      v20 = std::string::append(&v42, (const std::string::value_type *)v18, v19);
      v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v43.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      v22 = std::string::append(&v43, "ll", 2uLL);
      v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      v44.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v45[1] - (char *)v45[0]) >> 3);
      v25 = (void **)((char *)v45[0] + 112);
      if (v24 <= 4)
        v25 = &v45[5];
      v26 = *(unsigned __int8 *)v25;
      if (v26)
      {
        v27 = v24 > 4;
        if (v24 <= 4)
          v28 = (char **)&v45[3];
        else
          v28 = (char **)((char *)v45[0] + 96);
        v29 = (char **)((char *)v45[0] + 104);
        if (!v27)
          v29 = (char **)&v45[4];
        std::string::__init_with_size[abi:ne180100]<char *,char *>(&__p, *v28, *v29, *v29 - *v28);
        v26 = HIBYTE(v38);
        v30 = (void **)__p;
        v31 = v37;
      }
      else
      {
        v31 = 0;
        v30 = 0;
        __p = 0;
        v37 = 0;
        v38 = 0;
      }
      if ((v26 & 0x80u) == 0)
        p_p = &__p;
      else
        p_p = v30;
      if ((v26 & 0x80u) == 0)
        v33 = v26;
      else
        v33 = v31;
      v34 = std::string::append(&v44, (const std::string::value_type *)p_p, v33);
      v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)&v34->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v35;
      v34->__r_.__value_.__l.__size_ = 0;
      v34->__r_.__value_.__r.__words[2] = 0;
      v34->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v38) < 0)
        operator delete(__p);
      if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v44.__r_.__value_.__l.__data_);
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v43.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41) < 0)
        operator delete(v39);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
    }
    else if (__s1[23] < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)a2, *(const std::string::value_type **)__s1, *((_QWORD *)__s1 + 1));
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)__s1;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)__s1 + 2);
    }
    if (v45[0])
    {
      v45[1] = v45[0];
      operator delete(v45[0]);
    }
  }
}

void sub_1CBD04CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43)
{
  _Unwind_Resume(a1);
}

uint64_t std::string_view::find[abi:ne180100](uint64_t *a1, char *a2, int64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v6;
  void *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  int v13;
  uint64_t v14;
  char *v15;

  v4 = a1[1];
  if (v4 < a4)
    return -1;
  if (a3)
  {
    v6 = *a1;
    v7 = (void *)(*a1 + a4);
    v8 = (char *)(v6 + v4);
    v9 = v6 + v4 - (_QWORD)v7;
    if (v9 >= a3)
    {
      v13 = *a2;
      do
      {
        v14 = v9 - a3;
        if (v14 == -1)
          break;
        v15 = (char *)memchr(v7, v13, v14 + 1);
        if (!v15)
          break;
        v10 = v15;
        if (!memcmp(v15, a2, a3))
          goto LABEL_6;
        v7 = v10 + 1;
        v9 = v8 - (v10 + 1);
      }
      while (v9 >= a3);
    }
    v10 = v8;
LABEL_6:
    if (v10 == v8)
      return -1;
    else
      return (uint64_t)&v10[-v6];
  }
  return a4;
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,char const(&)[1],0>(std::string *this, __int128 *a2, char *__s)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::string::basic_string[abi:ne180100]<0>(this[1].__r_.__value_.__r.__words, __s);
  return this;
}

void sub_1CBD04F18(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(std::string *this, __int128 *a2, __int128 *a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_1CBD04FAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

std::regex_traits<char> *std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](std::regex_traits<char> *a1, char *a2, int a3)
{
  std::regex_traits<char> *v6;
  size_t v7;

  v6 = std::regex_traits<char>::regex_traits(a1);
  LODWORD(v6[1].__loc_.__locale_) = a3;
  *(_OWORD *)((char *)&v6[1].__loc_.__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v6[1].__col_ + 4) = 0u;
  HIDWORD(v6[2].__ct_) = 0;
  v7 = strlen(a2);
  if (std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>((uint64_t)a1, (std::basic_regex<char> *)a2, (std::basic_regex<char> *)&a2[v7]) != (std::basic_regex<char> *)&a2[v7])std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)17>();
  return a1;
}

void sub_1CBD0503C(_Unwind_Exception *a1)
{
  std::locale *v1;

  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v1[5]);
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::regex_traits<char> *__cdecl std::regex_traits<char>::regex_traits(std::regex_traits<char> *this)
{
  const std::locale *v2;

  v2 = (const std::locale *)MEMORY[0x1D17A5328]();
  this->__ct_ = (const std::ctype<char> *)std::locale::use_facet(v2, MEMORY[0x1E0DE4A90]);
  this->__col_ = (const std::collate<char> *)std::locale::use_facet(&this->__loc_, MEMORY[0x1E0DE4C08]);
  return this;
}

void sub_1CBD050A0(_Unwind_Exception *a1)
{
  std::locale *v1;

  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(uint64_t a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  unsigned int v8;

  v6 = (_QWORD *)operator new();
  *v6 = &unk_1E8750210;
  v7 = (_QWORD *)operator new();
  v7[1] = v6;
  std::shared_ptr<std::__empty_state<char>>::reset[abi:ne180100]<std::__empty_state<char>,void>((_QWORD *)(a1 + 40), (uint64_t)v7);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a1 + 40);
  v8 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if (v8 > 0x3F)
  {
    switch(v8)
    {
      case 0x40u:
        return std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>((std::basic_regex<char> *)a1, a2, a3);
      case 0x80u:
        return (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_grep<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
      case 0x100u:
        return std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<char const*>((std::basic_regex<char> *)a1, a2, a3);
      default:
        goto LABEL_14;
    }
  }
  else if (v8)
  {
    if (v8 != 16)
    {
      if (v8 != 32)
LABEL_14:
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)14>();
      return std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>((std::basic_regex<char> *)a1, a2, a3);
    }
    return (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
  }
  else
  {
    return (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)a2, (char *)a3);
  }
}

void sub_1CBD05208(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)17>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 17);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0525C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<std::__empty_state<char>>::reset[abi:ne180100]<std::__empty_state<char>,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, char *a3)
{
  std::__owns_one_state<char> *end;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  std::__node<char> *v9;
  std::__owns_one_state<char> *v10;
  std::__node<char> *first;
  std::__owns_one_state<char> *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  std::__node<char> *v15;
  std::__owns_one_state<char> *v16;
  std::__node<char> *v17;

  end = a1->__end_;
  v7 = a2;
  do
  {
    v8 = v7;
    v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(a1, (char *)v7, a3);
  }
  while (v7 != v8);
  if (v8 == a2)
  {
    v9 = (std::__node<char> *)operator new();
    v10 = a1->__end_;
    first = v10->__first_;
    v9[1].__vftable = (std::__node<char>_vtbl *)first;
    v10->__first_ = v9;
    a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
  }
  if (v8 != (unsigned __int8 *)a3)
  {
    while (*v8 == 124)
    {
      v12 = a1->__end_;
      v13 = v8 + 1;
      v14 = v8 + 1;
      do
      {
        v8 = v14;
        v14 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(a1, (char *)v14, a3);
      }
      while (v14 != v8);
      if (v8 == v13)
      {
        v15 = (std::__node<char> *)operator new();
        v16 = a1->__end_;
        v17 = v16->__first_;
        v15[1].__vftable = (std::__node<char>_vtbl *)v17;
        v16->__first_ = v15;
        a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
      }
      std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v12);
      if (v8 == (unsigned __int8 *)a3)
        return a3;
    }
    return (char *)v8;
  }
  return a3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  char *v4;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;

  v3 = a2;
  if (a2 == a3)
    return (char *)a2;
  v4 = (char *)a3;
  if (*a2 == 94)
  {
    v6 = operator new();
    v7 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    v8 = *(_QWORD *)(a1 + 56);
    v9 = *(_QWORD *)(v8 + 8);
    *(_QWORD *)v6 = &unk_1E87504A8;
    *(_QWORD *)(v6 + 8) = v9;
    *(_BYTE *)(v6 + 16) = v7;
    *(_QWORD *)(v8 + 8) = v6;
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    ++v3;
  }
  if (v3 != (unsigned __int8 *)v4)
  {
    do
    {
      v10 = v3;
      v3 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>((std::basic_regex<char> *)a1, (char *)v3, v4);
    }
    while (v3 != v10);
    if (v10 != (unsigned __int8 *)v4)
    {
      if (v10 + 1 != (unsigned __int8 *)v4 || *v10 != 36)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
      v11 = operator new();
      v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      v13 = *(_QWORD *)(a1 + 56);
      v14 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)v11 = &unk_1E8750508;
      *(_QWORD *)(v11 + 8) = v14;
      *(_BYTE *)(v11 + 16) = v12;
      *(_QWORD *)(v13 + 8) = v11;
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    }
  }
  return v4;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  std::basic_regex<char> *v3;
  std::__owns_one_state<char> *end;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  std::__owns_one_state<char> *v9;
  unsigned __int8 *v10;

  v3 = a3;
  end = a1->__end_;
  v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>((uint64_t)a1, a2, a3);
  if (v7 == (unsigned __int8 *)a2)
LABEL_9:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  v8 = v7;
  while (v8 != (unsigned __int8 *)v3)
  {
    if (*v8 != 124)
      return (std::basic_regex<char> *)v8;
    v9 = a1->__end_;
    v10 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>((uint64_t)a1, (std::basic_regex<char> *)(v8 + 1), v3);
    if (v10 == v8 + 1)
      goto LABEL_9;
    v8 = v10;
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v9);
  }
  return v3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_grep<char const*>(std::basic_regex<char> *a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  std::__owns_one_state<char> *end;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  std::__node<char> *v9;
  std::__owns_one_state<char> *v10;
  std::__node<char> *first;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  std::__owns_one_state<char> *v15;
  std::__node<char> *v16;
  std::__owns_one_state<char> *v17;
  std::__node<char> *v18;

  end = a1->__end_;
  v7 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v7)
    v8 = v7;
  else
    v8 = a3;
  if (v8 == __s)
  {
    v9 = (std::__node<char> *)operator new();
    v10 = a1->__end_;
    first = v10->__first_;
    v9[1].__vftable = (std::__node<char>_vtbl *)first;
    v10->__first_ = v9;
    a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
  }
  else
  {
    std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>((uint64_t)a1, __s, v8);
  }
  if (v8 == a3)
    v12 = v8;
  else
    v12 = v8 + 1;
  while (v12 != a3)
  {
    v13 = (unsigned __int8 *)memchr(v12, 10, a3 - v12);
    if (v13)
      v14 = v13;
    else
      v14 = a3;
    v15 = a1->__end_;
    if (v14 == v12)
    {
      v16 = (std::__node<char> *)operator new();
      v17 = a1->__end_;
      v18 = v17->__first_;
      v16[1].__vftable = (std::__node<char>_vtbl *)v18;
      v17->__first_ = v16;
      a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>((uint64_t)a1, v12, v14);
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v15);
    if (v14 == a3)
      v12 = v14;
    else
      v12 = v14 + 1;
  }
  return a3;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *__s, std::basic_regex<char> *a3)
{
  std::__owns_one_state<char> *end;
  std::basic_regex<char> *v7;
  std::basic_regex<char> *v8;
  std::__node<char> *v9;
  std::__owns_one_state<char> *v10;
  std::__node<char> *first;
  std::basic_regex<char> *v12;
  std::basic_regex<char> *v13;
  std::basic_regex<char> *v14;
  std::__owns_one_state<char> *v15;
  std::__node<char> *v16;
  std::__owns_one_state<char> *v17;
  std::__node<char> *v18;

  end = a1->__end_;
  v7 = (std::basic_regex<char> *)memchr(__s, 10, (char *)a3 - (char *)__s);
  if (v7)
    v8 = v7;
  else
    v8 = a3;
  if (v8 == __s)
  {
    v9 = (std::__node<char> *)operator new();
    v10 = a1->__end_;
    first = v10->__first_;
    v9[1].__vftable = (std::__node<char>_vtbl *)first;
    v10->__first_ = v9;
    a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
  }
  else
  {
    std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, __s, v8);
  }
  if (v8 == a3)
    v12 = v8;
  else
    v12 = (std::basic_regex<char> *)((char *)&v8->__traits_.__loc_.__locale_ + 1);
  while (v12 != a3)
  {
    v13 = (std::basic_regex<char> *)memchr(v12, 10, (char *)a3 - (char *)v12);
    if (v13)
      v14 = v13;
    else
      v14 = a3;
    v15 = a1->__end_;
    if (v14 == v12)
    {
      v16 = (std::__node<char> *)operator new();
      v17 = a1->__end_;
      v18 = v17->__first_;
      v16[1].__vftable = (std::__node<char>_vtbl *)v18;
      v17->__first_ = v16;
      a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, v12, v14);
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v15);
    if (v14 == a3)
      v12 = v14;
    else
      v12 = (std::basic_regex<char> *)((char *)&v14->__traits_.__loc_.__locale_ + 1);
  }
  return a3;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)14>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 14);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD058FC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__end_state<char>::~__end_state()
{
  JUMPOUT(0x1D17A53D0);
}

void std::__end_state<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

_QWORD *std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E8750998;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1CBD05994(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void (__cdecl ***std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

void std::__empty_state<char>::__exec(const std::__empty_state<char> *this, std::__empty_state<char>::__state *a2)
{
  a2->__do_ = -994;
  a2->__node_ = this->__first_;
}

void std::__owns_one_state<char>::~__owns_one_state(std::__owns_one_state<char> *this)
{
  std::__node<char> *first;

  first = this->__first_;
  if (first)
    ((void (*)(std::__node<char> *))first->~__node_0)(first);
}

{
  std::__node<char> *first;

  first = this->__first_;
  if (first)
    ((void (*)(std::__node<char> *))first->~__node_0)(first);
  JUMPOUT(0x1D17A53D0);
}

void std::basic_regex<char,std::regex_traits<char>>::__push_alternation(std::basic_regex<char> *this, std::__owns_one_state<char> *__sa, std::__owns_one_state<char> *__sb)
{
  std::__node<char> *v6;
  std::__node<char> *first;
  std::__node<char> *v8;
  std::__node<char> *v9;
  std::__node<char> *v10;
  std::__node<char> *v11;

  v6 = (std::__node<char> *)operator new();
  first = __sb->__first_;
  v6[1].__vftable = (std::__node<char>_vtbl *)__sa->__first_;
  v6[2].__vftable = (std::__node<char>_vtbl *)first;
  v6->__vftable = (std::__node<char>_vtbl *)&unk_1E87501E0;
  __sa->__first_ = v6;
  __sb->__first_ = 0;
  v8 = (std::__node<char> *)operator new();
  v9 = this->__end_->__first_;
  v8[1].__vftable = (std::__node<char>_vtbl *)v9;
  __sb->__first_ = v8;
  this->__end_->__first_ = 0;
  v10 = (std::__node<char> *)operator new();
  v11 = __sb->__first_;
  v10->__vftable = (std::__node<char>_vtbl *)&unk_1E87509D0;
  v10[1].__vftable = (std::__node<char>_vtbl *)v11;
  this->__end_->__first_ = v10;
  this->__end_ = (std::__owns_one_state<char> *)__sb->__first_;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  unsigned __int8 *result;
  std::__owns_one_state<char> *end;
  unsigned int marked_count;
  unsigned __int8 *v9;

  result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    end = a1->__end_;
    marked_count = a1->__marked_count_;
    v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
    result = (unsigned __int8 *)a2;
    if (v9 != (unsigned __int8 *)a2)
      return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v9, (unsigned __int8 *)a3, end, marked_count + 1, a1->__marked_count_ + 1);
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  char *v3;
  int v6;
  char *v7;
  BOOL v8;
  char *v9;
  int v11;
  char *v12;
  unsigned int v13;
  uint64_t v14;
  BOOL v15;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;
  char *v18;
  int v20;
  BOOL v21;
  unsigned int marked_count;
  std::basic_regex<char> v23;

  v3 = a2;
  if (a2 == a3)
    return v3;
  v6 = *a2;
  if (v6 <= 91)
  {
    if (v6 != 36)
    {
      v8 = v6 == 40;
      v7 = a2 + 1;
      v8 = !v8 || v7 == a3;
      if (!v8)
      {
        v8 = *v7 == 63;
        v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          v11 = *v9;
          if (v11 == 33)
          {
            std::regex_traits<char>::regex_traits(&v23.__traits_);
            memset(&v23.__flags_, 0, 40);
            v23.__flags_ = this->__flags_;
            v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v23, v3 + 3, a3);
            marked_count = v23.__marked_count_;
            std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v23, 1, this->__marked_count_);
            this->__marked_count_ += marked_count;
            if (v12 == a3 || *v12 != 41)
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
            goto LABEL_31;
          }
          if (v11 == 61)
          {
            std::regex_traits<char>::regex_traits(&v23.__traits_);
            memset(&v23.__flags_, 0, 40);
            v23.__flags_ = this->__flags_;
            v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v23, v3 + 3, a3);
            v13 = v23.__marked_count_;
            std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v23, 0, this->__marked_count_);
            this->__marked_count_ += v13;
            if (v12 == a3 || *v12 != 41)
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
LABEL_31:
            v3 = v12 + 1;
            std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&v23.__start_);
            std::locale::~locale(&v23.__traits_.__loc_);
            return v3;
          }
        }
      }
      return v3;
    }
    v14 = operator new();
    v15 = (this->__flags_ & 0x5F0) == 1024;
    end = this->__end_;
    first = end->__first_;
LABEL_21:
    *(_QWORD *)v14 = v18 + 16;
    *(_QWORD *)(v14 + 8) = first;
    *(_BYTE *)(v14 + 16) = v15;
    end->__first_ = (std::__node<char> *)v14;
    this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
    return ++v3;
  }
  if (v6 != 92)
  {
    if (v6 != 94)
      return v3;
    v14 = operator new();
    v15 = (this->__flags_ & 0x5F0) == 1024;
    end = this->__end_;
    first = end->__first_;
    goto LABEL_21;
  }
  if (a2 + 1 != a3)
  {
    v20 = a2[1];
    if (v20 == 66)
    {
      v21 = 1;
    }
    else
    {
      if (v20 != 98)
        return v3;
      v21 = 0;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(this, v21);
    v3 += 2;
  }
  return v3;
}

void sub_1CBD05F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  std::locale::~locale(&a9);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(std::basic_regex<char> *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v6;
  std::__node<char> *v7;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;
  int *p_open_count;
  unsigned __int8 *v12;
  unsigned int marked_count;
  unsigned __int8 *v14;

  v3 = a2;
  if (a2 == a3)
    return v3;
  v6 = (char)*a2;
  if (v6 > 62)
  {
    if (v6 > 91)
    {
      if (v6 == 92)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(this, a2, a3);
      if (v6 != 123)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(this, a2, a3);
    }
    else
    {
      if (v6 == 91)
        return (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, (char *)a2, (char *)a3);
      if (v6 != 63)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(this, a2, a3);
    }
LABEL_29:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>();
  }
  if (v6 == 40)
  {
    if (a2 + 1 == a3)
      goto LABEL_30;
    if (a2 + 2 != a3 && a2[1] == 63 && a2[2] == 58)
    {
      p_open_count = &this->__open_count_;
      ++this->__open_count_;
      v12 = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, a2 + 3, a3);
      if (v12 == a3)
        goto LABEL_30;
      v3 = v12;
      if (*v12 != 41)
        goto LABEL_30;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(this);
      marked_count = this->__marked_count_;
      p_open_count = &this->__open_count_;
      ++this->__open_count_;
      v14 = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, v3 + 1, a3);
      if (v14 == a3 || (v3 = v14, *v14 != 41))
LABEL_30:
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
      std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(this, marked_count);
    }
    --*p_open_count;
    return ++v3;
  }
  if (v6 == 46)
  {
    v7 = (std::__node<char> *)operator new();
    end = this->__end_;
    first = end->__first_;
    v7->__vftable = (std::__node<char>_vtbl *)&unk_1E8750A00;
    v7[1].__vftable = (std::__node<char>_vtbl *)first;
    end->__first_ = v7;
    this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
    return ++v3;
  }
  if ((v6 - 42) < 2)
    goto LABEL_29;
  return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(this, a2, a3);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t a5, size_t a6)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  size_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  size_t v18;
  BOOL v19;
  BOOL v20;
  std::__owns_one_state<char> *v21;
  BOOL v22;
  unsigned __int8 *v23;
  unsigned __int8 *v25;
  int v26;
  int v27;
  size_t __max;

  if (a2 == a3)
    return a2;
  v6 = a6;
  v7 = a5;
  v10 = a1;
  v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  v12 = (char)*a2;
  if (v12 > 62)
  {
    if (v12 == 63)
    {
      v13 = a2 + 1;
      if (v11)
        v20 = 1;
      else
        v20 = v13 == a3;
      if (!v20 && *v13 == 63)
      {
        v13 = a2 + 2;
        a5 = a5;
        a6 = a6;
        v14 = 0;
        v18 = 1;
        goto LABEL_33;
      }
      a5 = a5;
      a6 = a6;
      v14 = 0;
      v18 = 1;
      goto LABEL_45;
    }
    if (v12 != 123)
      return a2;
    v15 = a2 + 1;
    v16 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>(a1, a2 + 1, a3, (int *)&__max);
    if (v16 != v15)
    {
      if (v16 != a3)
      {
        v17 = (char)*v16;
        if (v17 != 44)
        {
          if (v17 == 125)
          {
            v13 = v16 + 1;
            if (!v11 && v13 != a3 && *v13 == 63)
            {
              v13 = v16 + 2;
              v14 = (int)__max;
              a5 = v7;
              a6 = v6;
              a1 = v10;
              v18 = (int)__max;
LABEL_33:
              v21 = __s;
              v22 = 0;
LABEL_46:
              std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v14, v18, v21, a5, a6, v22);
              return v13;
            }
            v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            v18 = (int)__max;
LABEL_45:
            v21 = __s;
            v22 = 1;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
        v23 = v16 + 1;
        if (v16 + 1 == a3)
          goto LABEL_58;
        if (*v23 == 125)
        {
          v13 = v16 + 2;
          if (!v11 && v13 != a3 && *v13 == 63)
          {
            v13 = v16 + 3;
            v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            goto LABEL_26;
          }
          v14 = (int)__max;
          a5 = v7;
          a6 = v6;
          a1 = v10;
LABEL_36:
          v18 = -1;
          goto LABEL_45;
        }
        v27 = -1;
        v25 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>(v10, v23, a3, &v27);
        if (v25 != v23 && v25 != a3 && *v25 == 125)
        {
          v18 = v27;
          v14 = (int)__max;
          if (v27 >= (int)__max)
          {
            v13 = v25 + 1;
            v22 = 1;
            if (!v11 && v13 != a3)
            {
              v26 = v25[1];
              v22 = v26 != 63;
              if (v26 == 63)
                v13 = v25 + 2;
            }
            a5 = v7;
            a6 = v6;
            a1 = v10;
            v21 = __s;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
LABEL_58:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
  }
  if (v12 == 42)
  {
    v13 = a2 + 1;
    if (v11)
      v19 = 1;
    else
      v19 = v13 == a3;
    if (!v19 && *v13 == 63)
    {
      v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      v14 = 0;
      goto LABEL_26;
    }
    a5 = a5;
    a6 = a6;
    v14 = 0;
    goto LABEL_36;
  }
  if (v12 == 43)
  {
    v13 = a2 + 1;
    if (!v11 && v13 != a3 && *v13 == 63)
    {
      v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      v14 = 1;
LABEL_26:
      v18 = -1;
      goto LABEL_33;
    }
    a5 = a5;
    a6 = a6;
    v14 = 1;
    goto LABEL_36;
  }
  return a2;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(std::basic_regex<char> *this, BOOL a2)
{
  uint64_t v4;
  std::__node<char> *first;

  v4 = operator new();
  first = this->__end_->__first_;
  *(_QWORD *)v4 = &unk_1E8750300;
  *(_QWORD *)(v4 + 8) = first;
  std::locale::locale((std::locale *)(v4 + 16), &this->__traits_.__loc_);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)&this->__traits_.__ct_;
  *(_BYTE *)(v4 + 40) = a2;
  this->__end_->__first_ = (std::__node<char> *)v4;
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(std::basic_regex<char> *this, const std::basic_regex<char> *a2, BOOL a3, unsigned int a4)
{
  std::__node<char> *v8;

  v8 = (std::__node<char> *)operator new();
  std::__lookahead<char,std::regex_traits<char>>::__lookahead[abi:ne180100]((uint64_t)v8, (uint64_t)a2, a3, (uint64_t)this->__end_->__first_, a4);
  this->__end_->__first_ = v8;
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
}

void sub_1CBD065A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x10E1C4030FC3181);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 6);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD065FC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void (__cdecl ***std::__l_anchor_multiline<char>::~__l_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__l_anchor_multiline<char>::~__l_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__l_anchor_multiline<char>::__exec(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t v4;

  if (*(_BYTE *)(a2 + 92))
  {
    if (*(_QWORD *)(a2 + 16) != *(_QWORD *)(a2 + 8) || (*(_BYTE *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      v4 = 0;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(_BYTE *)(result + 16))
      goto LABEL_12;
    v2 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10)
      goto LABEL_12;
  }
  *(_DWORD *)a2 = -994;
  v4 = *(_QWORD *)(result + 8);
LABEL_13:
  *(_QWORD *)(a2 + 80) = v4;
  return result;
}

void (__cdecl ***std::__r_anchor_multiline<char>::~__r_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__r_anchor_multiline<char>::~__r_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__r_anchor_multiline<char>::__exec(uint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  int v3;
  BOOL v4;
  uint64_t v5;

  v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(_BYTE *)(a2 + 88) & 2) == 0
    || *(_BYTE *)(result + 16) && ((v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    v5 = *(_QWORD *)(result + 8);
  }
  else
  {
    v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(_QWORD *)(a2 + 80) = v5;
  return result;
}

std::locale *std::__word_boundary<char,std::regex_traits<char>>::~__word_boundary(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750300;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  return a1;
}

void std::__word_boundary<char,std::regex_traits<char>>::~__word_boundary(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750300;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__word_boundary<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;

  v2 = *(unsigned __int8 **)(a2 + 8);
  v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3)
    goto LABEL_17;
  v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(_BYTE *)(a2 + 88) & 8) == 0)
    {
      v6 = *(v3 - 1);
      goto LABEL_13;
    }
LABEL_17:
    v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) + 16) + 4 * v6) & 0x500) != 0)
        {
          v10 = 1;
          goto LABEL_25;
        }
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  v7 = *(v4 - 1);
  v8 = *v4;
  v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) + 16) + 4 * v7) & 0x500) != 0;
  v11 = (_DWORD)v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) + 16) + 4 * v8) & 0x500) != 0;
  v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    v12 = 0;
    v13 = -993;
  }
  else
  {
    v12 = *(_QWORD *)(result + 8);
    v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(_QWORD *)(a2 + 80) = v12;
  return result;
}

uint64_t std::__lookahead<char,std::regex_traits<char>>::__lookahead[abi:ne180100](uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  *(_QWORD *)a1 = &unk_1E8750240;
  *(_QWORD *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 64) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 80) = a5;
  *(_BYTE *)(a1 + 84) = a3;
  return a1;
}

void (__cdecl ***std::__lookahead<char,std::regex_traits<char>>::~__lookahead(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  std::locale *v2;
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750240;
  v2 = (std::locale *)(a1 + 2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 7));
  std::locale::~locale(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  return a1;
}

void std::__lookahead<char,std::regex_traits<char>>::~__lookahead(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::locale *v2;
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750240;
  v2 = (std::locale *)(a1 + 2);
  std::shared_ptr<TClientChangeNotifier>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 7));
  std::locale::~locale(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  JUMPOUT(0x1D17A53D0);
}

void std::__lookahead<char,std::regex_traits<char>>::__exec(uint64_t a1, uint64_t a2)
{
  std::vector<std::csub_match>::size_type v4;
  uint64_t v5;
  const char *v6;
  BOOL v7;
  char v8;
  std::sub_match<const char *> *begin;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  std::sub_match<const char *> *v15;
  uint64_t v16;
  std::vector<std::csub_match> __p;
  std::vector<std::csub_match>::value_type v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  std::vector<std::csub_match>::value_type v22;
  char v23;
  uint64_t v24;

  v19 = 0;
  v20 = 0;
  v21 = 0;
  memset(&v22, 0, 17);
  v23 = 0;
  v24 = 0;
  memset(&__p, 0, sizeof(__p));
  v4 = (*(_DWORD *)(a1 + 44) + 1);
  v5 = *(_QWORD *)(a2 + 16);
  v18.first = *(const char **)(a2 + 24);
  v18.second = v18.first;
  v18.matched = 0;
  std::vector<std::sub_match<char const*>>::assign(&__p, v4, &v18);
  v19 = v5;
  v20 = v5;
  v21 = 0;
  v22 = v18;
  v24 = v5;
  v23 = 1;
  v6 = *(const char **)(a2 + 16);
  if (*(_BYTE *)(a2 + 92))
    v7 = v6 == *(const char **)(a2 + 8);
  else
    v7 = 0;
  v8 = v7;
  if (*(unsigned __int8 *)(a1 + 84) == std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1 + 16, v6, *(const char **)(a2 + 24), (uint64_t *)&__p, *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u, v8))
  {
    *(_DWORD *)a2 = -993;
    *(_QWORD *)(a2 + 80) = 0;
    begin = __p.__begin_;
    goto LABEL_13;
  }
  *(_DWORD *)a2 = -994;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 8);
  begin = __p.__begin_;
  v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_ - (char *)__p.__begin_) >> 3);
  if (v10 < 2)
  {
LABEL_13:
    if (!begin)
      return;
    goto LABEL_14;
  }
  v11 = 0;
  v12 = *(_DWORD *)(a1 + 80);
  v13 = *(_QWORD *)(a2 + 32);
  v14 = 1;
  do
  {
    v15 = &begin[v14];
    v16 = v13 + 24 * (v12 + v11);
    *(std::pair<const char *, const char *> *)v16 = v15->std::pair<const char *, const char *>;
    *(_BYTE *)(v16 + 16) = v15->matched;
    v14 = (v11 + 2);
    ++v11;
  }
  while (v10 > v14);
LABEL_14:
  __p.__end_ = begin;
  operator delete(begin);
}

void sub_1CBD06C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::match_results<char const*>::__init(std::match_results<const char *> *this, unsigned int __s, const char *__f, const char *__l, BOOL __no_update_pos)
{
  std::match_results<const char *>::value_type *p_unmatched;

  this->__unmatched_.first = __l;
  p_unmatched = &this->__unmatched_;
  this->__unmatched_.second = __l;
  this->__unmatched_.matched = 0;
  std::vector<std::sub_match<char const*>>::assign(&this->__matches_, __s, &this->__unmatched_);
  this->__prefix_.first = __f;
  this->__prefix_.second = __f;
  this->__prefix_.matched = 0;
  this->__suffix_ = *p_unmatched;
  if (!__no_update_pos)
    this->__position_start_ = __f;
  this->__ready_ = 1;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  uint64_t v6;
  _OWORD *v12;
  signed int v13;
  _OWORD *v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD *v17;
  _OWORD *v18;
  const char *v19;
  _OWORD *v20;
  __int128 v21;
  uint64_t v22;
  _OWORD *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _BYTE *v31;
  unsigned int v32;
  uint64_t v33;
  char v34;
  uint64_t *v36;
  const char *v37;
  _BYTE v39[56];
  void *__p[2];
  _QWORD v41[4];
  std::vector<std::csub_match>::value_type __x;
  _OWORD *v43;
  _OWORD *v44;
  unint64_t v45;

  v43 = 0;
  v44 = 0;
  v45 = 0;
  v6 = *(_QWORD *)(a1 + 40);
  if (v6)
  {
    __x.first = a3;
    __x.second = a3;
    __x.matched = 0;
    *(_DWORD *)v39 = 0;
    memset(&v39[8], 0, 48);
    *(_OWORD *)__p = 0u;
    memset(v41, 0, 21);
    v44 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v43, (uint64_t)v39);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*(_QWORD *)&v39[32])
    {
      *(_QWORD *)&v39[40] = *(_QWORD *)&v39[32];
      operator delete(*(void **)&v39[32]);
    }
    v36 = a4;
    v12 = v44;
    *((_DWORD *)v44 - 24) = 0;
    *((_QWORD *)v12 - 11) = a2;
    *((_QWORD *)v12 - 10) = a2;
    *((_QWORD *)v12 - 9) = a3;
    std::vector<std::sub_match<char const*>>::resize((std::vector<std::csub_match> *)(v12 - 4), *(unsigned int *)(a1 + 28), &__x);
    std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)((char *)v44 - 40), *(unsigned int *)(a1 + 32));
    v37 = a3;
    v13 = (_DWORD)a3 - (_DWORD)a2;
    v14 = v44;
    *((_QWORD *)v44 - 2) = v6;
    *((_DWORD *)v14 - 2) = a5;
    *((_BYTE *)v14 - 4) = a6;
    v15 = 1;
    while (2)
    {
      if ((v15 & 0xFFF) == 0 && (int)(v15 >> 12) >= v13)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
      v17 = v14 - 1;
      v16 = *((_QWORD *)v14 - 2);
      v18 = v14 - 6;
      if (v16)
        (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v16 + 16))(v16, v14 - 6);
      switch(*(_DWORD *)v18)
      {
        case 0xFFFFFC18:
          v19 = (const char *)*((_QWORD *)v14 - 10);
          if ((a5 & 0x20) != 0 && v19 == a2 || (a5 & 0x1000) != 0 && v19 != v37)
            goto LABEL_16;
          v27 = *v36;
          *(_QWORD *)v27 = a2;
          *(_QWORD *)(v27 + 8) = v19;
          *(_BYTE *)(v27 + 16) = 1;
          v28 = *((_QWORD *)v14 - 8);
          v29 = *((_QWORD *)v14 - 7) - v28;
          if (v29)
          {
            v30 = 0xAAAAAAAAAAAAAAABLL * (v29 >> 3);
            v31 = (_BYTE *)(v28 + 16);
            v32 = 1;
            do
            {
              v33 = v27 + 24 * v32;
              *(_OWORD *)v33 = *((_OWORD *)v31 - 1);
              v34 = *v31;
              v31 += 24;
              *(_BYTE *)(v33 + 16) = v34;
            }
            while (v30 > v32++);
          }
          v6 = 1;
          break;
        case 0xFFFFFC1D:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_23;
        case 0xFFFFFC1F:
LABEL_16:
          v20 = v44 - 6;
          std::__destroy_at[abi:ne180100]<std::__state<char>,0>((_QWORD *)v44 - 12);
          v44 = v20;
          goto LABEL_23;
        case 0xFFFFFC20:
          v21 = *(v14 - 5);
          *(_OWORD *)v39 = *v18;
          *(_OWORD *)&v39[16] = v21;
          memset(&v39[32], 0, 24);
          std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v39[32], *((__int128 **)v14 - 8), *((__int128 **)v14 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v14 - 7) - *((_QWORD *)v14 - 8)) >> 3));
          __p[0] = 0;
          __p[1] = 0;
          v41[0] = 0;
          std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *((__int128 **)v14 - 5), *((__int128 **)v14 - 4), (uint64_t)(*((_QWORD *)v14 - 4) - *((_QWORD *)v14 - 5)) >> 4);
          v22 = *v17;
          *(_QWORD *)((char *)&v41[1] + 5) = *(_QWORD *)((char *)v14 - 11);
          v41[1] = v22;
          (*(void (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)*v17 + 24))(*v17, 1, v14 - 6);
          (*(void (**)(_QWORD, _QWORD, _BYTE *))(*(_QWORD *)v41[1] + 24))(v41[1], 0, v39);
          v23 = v44;
          if ((unint64_t)v44 >= v45)
          {
            v44 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v43, (uint64_t)v39);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }
          else
          {
            v24 = *(_OWORD *)&v39[16];
            *v44 = *(_OWORD *)v39;
            v23[1] = v24;
            *((_QWORD *)v23 + 4) = 0;
            *((_QWORD *)v23 + 5) = 0;
            *((_QWORD *)v23 + 6) = 0;
            *((_QWORD *)v23 + 7) = 0;
            v23[2] = *(_OWORD *)&v39[32];
            *((_QWORD *)v23 + 6) = *(_QWORD *)&v39[48];
            memset(&v39[32], 0, 24);
            *((_QWORD *)v23 + 8) = 0;
            *((_QWORD *)v23 + 9) = 0;
            *(_OWORD *)((char *)v23 + 56) = *(_OWORD *)__p;
            *((_QWORD *)v23 + 9) = v41[0];
            __p[0] = 0;
            __p[1] = 0;
            v41[0] = 0;
            v25 = v41[1];
            *(_QWORD *)((char *)v23 + 85) = *(_QWORD *)((char *)&v41[1] + 5);
            *((_QWORD *)v23 + 10) = v25;
            v44 = v23 + 6;
          }
          if (*(_QWORD *)&v39[32])
          {
            *(_QWORD *)&v39[40] = *(_QWORD *)&v39[32];
            operator delete(*(void **)&v39[32]);
          }
LABEL_23:
          v14 = v44;
          ++v15;
          if (v43 != v44)
            continue;
          v6 = 0;
          break;
        default:
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
      }
      break;
    }
  }
  *(_QWORD *)v39 = &v43;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)v39);
  return v6;
}

void sub_1CBD070B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  uint64_t v18;

  std::__state<char>::~__state(&a13);
  a13 = v18 - 112;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

void std::vector<std::sub_match<char const*>>::assign(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __u)
{
  std::sub_match<const char *> *value;
  std::sub_match<const char *> *begin;
  unint64_t v8;
  std::vector<std::csub_match>::size_type v9;
  unint64_t v10;
  std::vector<std::csub_match>::pointer v11;
  std::sub_match<const char *> *v12;
  std::vector<std::csub_match>::size_type v13;
  std::pair<const char *, const char *> v14;
  std::vector<std::csub_match>::pointer end;
  std::vector<std::csub_match>::size_type v16;
  std::vector<std::csub_match>::size_type v17;
  std::vector<std::csub_match>::value_type *v18;
  std::sub_match<const char *> *v19;
  std::vector<std::csub_match>::size_type v20;
  std::pair<const char *, const char *> v21;

  value = this->__end_cap_.__value_;
  begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3) >= __n)
  {
    end = this->__end_;
    v16 = end - begin;
    if (v16 >= __n)
      v17 = __n;
    else
      v17 = end - begin;
    if (v17)
    {
      v18 = begin;
      do
      {
        *v18++ = *__u;
        --v17;
      }
      while (v17);
    }
    if (__n <= v16)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      v19 = &end[__n - v16];
      v20 = 24 * __n - 24 * v16;
      do
      {
        v21 = __u->std::pair<const char *, const char *>;
        *(_QWORD *)&end->matched = *(_QWORD *)&__u->matched;
        end->std::pair<const char *, const char *> = v21;
        ++end;
        v20 -= 24;
      }
      while (v20);
      this->__end_ = v19;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n > 0xAAAAAAAAAAAAAAALL)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)value >> 3);
    v9 = 2 * v8;
    if (2 * v8 <= __n)
      v9 = __n;
    if (v8 >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v9;
    std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](this, v10);
    v11 = this->__end_;
    v12 = &v11[__n];
    v13 = 24 * __n;
    do
    {
      v14 = __u->std::pair<const char *, const char *>;
      *(_QWORD *)&v11->matched = *(_QWORD *)&__u->matched;
      v11->std::pair<const char *, const char *> = v14;
      ++v11;
      v13 -= 24;
    }
    while (v13);
    this->__end_ = v12;
  }
}

char *std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

_QWORD *std::__state<char>::~__state(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void std::vector<std::sub_match<char const*>>::resize(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __sz, std::vector<std::csub_match>::const_reference __x)
{
  std::vector<std::csub_match>::size_type v3;
  BOOL v4;
  std::vector<std::csub_match>::size_type v5;

  v3 = 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3);
  v4 = __sz >= v3;
  v5 = __sz - v3;
  if (v5 != 0 && v4)
  {
    std::vector<std::sub_match<char const*>>::__append(this, v5, __x);
  }
  else if (!v4)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

void std::vector<std::pair<unsigned long,char const*>>::resize(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __sz)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<std::pair<unsigned long,char const*>>::__append(this, __sz - v2);
  }
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 12);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD073B8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 16);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD07404(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v16[5];

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL)
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x155555555555555)
    v9 = 0x2AAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v16[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__state<char>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[96 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[96 * v9];
  v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  *((_QWORD *)v11 + 5) = 0;
  *((_QWORD *)v11 + 6) = 0;
  *((_QWORD *)v11 + 4) = 0;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((_QWORD *)v11 + 6) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *((_QWORD *)v11 + 7) = 0;
  *((_QWORD *)v11 + 8) = 0;
  *((_QWORD *)v11 + 9) = 0;
  *(_OWORD *)(v11 + 56) = *(_OWORD *)(a2 + 56);
  *((_QWORD *)v11 + 9) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  v13 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v11 + 85) = *(_QWORD *)(a2 + 85);
  *((_QWORD *)v11 + 10) = v13;
  v16[2] = v11 + 96;
  std::vector<std::__state<char>>::__swap_out_circular_buffer(a1, v16);
  v14 = a1[1];
  std::__split_buffer<std::__state<char>>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_1CBD07550(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::__state<char>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::__state<char>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::__state<char>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(96 * a2);
}

__n128 std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __n128 result;
  uint64_t v12;

  if (a3 != a5)
  {
    v7 = 0;
    do
    {
      v8 = a7 + v7;
      v9 = a3 + v7;
      v10 = *(_OWORD *)(a3 + v7 - 80);
      *(_OWORD *)(v8 - 96) = *(_OWORD *)(a3 + v7 - 96);
      *(_OWORD *)(v8 - 80) = v10;
      *(_QWORD *)(v8 - 56) = 0;
      *(_QWORD *)(v8 - 48) = 0;
      *(_QWORD *)(v8 - 64) = 0;
      *(_OWORD *)(v8 - 64) = *(_OWORD *)(a3 + v7 - 64);
      *(_QWORD *)(v8 - 48) = *(_QWORD *)(a3 + v7 - 48);
      *(_QWORD *)(v9 - 64) = 0;
      *(_QWORD *)(v9 - 56) = 0;
      *(_QWORD *)(v9 - 48) = 0;
      *(_QWORD *)(v8 - 40) = 0;
      *(_QWORD *)(v8 - 32) = 0;
      *(_QWORD *)(v8 - 24) = 0;
      result = *(__n128 *)(a3 + v7 - 40);
      *(__n128 *)(v8 - 40) = result;
      *(_QWORD *)(v8 - 24) = *(_QWORD *)(a3 + v7 - 24);
      *(_QWORD *)(v9 - 40) = 0;
      *(_QWORD *)(v9 - 32) = 0;
      *(_QWORD *)(v9 - 24) = 0;
      v12 = *(_QWORD *)(a3 + v7 - 16);
      *(_QWORD *)(v8 - 11) = *(_QWORD *)(a3 + v7 - 11);
      *(_QWORD *)(v8 - 16) = v12;
      v7 -= 96;
    }
    while (a3 + v7 != a5);
  }
  return result;
}

void std::__destroy_at[abi:ne180100]<std::__state<char>,0>(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
}

uint64_t std::__split_buffer<std::__state<char>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 96;
    std::__destroy_at[abi:ne180100]<std::__state<char>,0>((_QWORD *)(i - 96));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::sub_match<char const*>>::__append(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __x)
{
  std::__compressed_pair<std::csub_match *> *p_end_cap;
  std::sub_match<const char *> *v7;
  std::sub_match<const char *> *value;
  std::sub_match<const char *> *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  std::sub_match<const char *> *v15;
  std::vector<std::csub_match>::size_type v16;
  std::pair<const char *, const char *> v17;
  std::sub_match<const char *> *v18;
  std::sub_match<const char *> *v19;
  std::vector<std::csub_match>::size_type v20;
  std::pair<const char *, const char *> *v21;
  std::pair<const char *, const char *> v22;
  std::sub_match<const char *> *v23;
  std::sub_match<const char *> *end;
  std::vector<std::csub_match>::pointer begin;
  std::pair<const char *, const char *> v26;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v7 = value;
  v9 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v9) >> 3) >= __n)
  {
    if (__n)
    {
      v15 = &v9[__n];
      v16 = 24 * __n;
      do
      {
        v17 = __x->std::pair<const char *, const char *>;
        *(_QWORD *)&v9->matched = *(_QWORD *)&__x->matched;
        v9->std::pair<const char *, const char *> = v17;
        ++v9;
        v16 -= 24;
      }
      while (v16);
      v9 = v15;
    }
    this->__end_ = v9;
  }
  else
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)this->__begin_) >> 3);
    v11 = v10 + __n;
    if (v10 + __n > 0xAAAAAAAAAAAAAAALL)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v11;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v13);
    else
      v14 = 0;
    v18 = (std::sub_match<const char *> *)&v14[24 * v10];
    v19 = &v18[__n];
    v20 = 24 * __n;
    v21 = v18;
    do
    {
      v22 = __x->std::pair<const char *, const char *>;
      v21[1].first = *(const char **)&__x->matched;
      *v21 = v22;
      v21 = (std::pair<const char *, const char *> *)((char *)v21 + 24);
      v20 -= 24;
    }
    while (v20);
    v23 = (std::sub_match<const char *> *)&v14[24 * v13];
    begin = this->__begin_;
    end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        v26 = end[-1].std::pair<const char *, const char *>;
        *(_QWORD *)&v18[-1].matched = *(_QWORD *)&end[-1].matched;
        v18[-1].std::pair<const char *, const char *> = v26;
        --v18;
        --end;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v18;
    this->__end_ = v19;
    this->__end_cap_.__value_ = v23;
    if (end)
      operator delete(end);
  }
}

void std::vector<std::pair<unsigned long,char const*>>::__append(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __n)
{
  std::__compressed_pair<std::pair<unsigned long, const char *> *, std::allocator<std::pair<unsigned long, const char *>>> *p_end_cap;
  std::pair<unsigned long, const char *> *v5;
  std::pair<unsigned long, const char *> *value;
  std::pair<unsigned long, const char *> *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  std::pair<unsigned long, const char *> *v14;
  std::pair<unsigned long, const char *> *v15;
  std::pair<unsigned long, const char *> *v16;
  std::pair<unsigned long, const char *> *end;
  std::vector<std::pair<unsigned long, const char *>>::pointer begin;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  v7 = p_end_cap[-1].__value_;
  if (__n <= value - v7)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 16 * __n);
      v7 += __n;
    }
    this->__end_ = v7;
  }
  else
  {
    v8 = (char *)v7 - (char *)this->__begin_;
    v9 = __n + (v8 >> 4);
    if (v9 >> 60)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = (char *)v5 - (char *)this->__begin_;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)p_end_cap, v12);
    else
      v13 = 0;
    v14 = (std::pair<unsigned long, const char *> *)&v13[16 * v10];
    v15 = (std::pair<unsigned long, const char *> *)&v13[16 * v12];
    bzero(v14, 16 * __n);
    v16 = &v14[__n];
    begin = this->__begin_;
    end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        v14[-1] = end[-1];
        --v14;
        --end;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v14;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v15;
    if (end)
      operator delete(end);
  }
}

char *std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v7 = v8;
      v7 += 24;
      a2 = (__int128 *)((char *)a2 + 24);
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1CBD07A18(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  _OWORD *v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_OWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1CBD07A88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v5;
  unsigned __int8 *result;

  if (a2 == a3 || *a2 != 92)
    return a2;
  v5 = a2 + 1;
  if (a2 + 1 == a3)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  result = std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<char const*>(a1, a2 + 1, a3);
  if (result == v5)
  {
    result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_character_class_escape<char const*>(a1, (char *)a2 + 1, (char *)a3);
    if (result == v5)
    {
      result = std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2 + 1, a3, 0);
      if (result == v5)
        return a2;
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>(uint64_t a1, char *a2, char *a3)
{
  char *v5;
  std::__bracket_expression<char, std::regex_traits<char>> *started;
  uint64_t *v7;
  char *v8;

  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3)
      goto LABEL_20;
    v5 = a2[1] == 94 ? a2 + 2 : a2 + 1;
    started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list((std::basic_regex<char> *)a1, a2[1] == 94);
    if (v5 == a3)
      goto LABEL_20;
    v7 = (uint64_t *)started;
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v5 == 93)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)started, 93);
      ++v5;
    }
    if (v5 == a3)
      goto LABEL_20;
    do
    {
      v8 = v5;
      v5 = std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(a1, v5, a3, v7);
    }
    while (v5 != v8);
    if (v8 == a3)
      goto LABEL_20;
    if (*v8 == 45)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v7, 45);
      ++v8;
    }
    if (v8 == a3 || *v8 != 93)
LABEL_20:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
    return v8 + 1;
  }
  return a2;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(std::basic_regex<char> *this)
{
  uint64_t v2;
  unsigned int v3;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;

  if ((this->__flags_ & 2) == 0)
  {
    v2 = operator new();
    v3 = this->__marked_count_ + 1;
    this->__marked_count_ = v3;
    end = this->__end_;
    first = end->__first_;
    *(_QWORD *)v2 = &unk_1E8750A60;
    *(_QWORD *)(v2 + 8) = first;
    *(_DWORD *)(v2 + 16) = v3;
    end->__first_ = (std::__node<char> *)v2;
    this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
  }
}

void std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(std::basic_regex<char> *this, unsigned int a2)
{
  uint64_t v4;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;

  if ((this->__flags_ & 2) == 0)
  {
    v4 = operator new();
    end = this->__end_;
    first = end->__first_;
    *(_QWORD *)v4 = &unk_1E8750A30;
    *(_QWORD *)(v4 + 8) = first;
    *(_DWORD *)(v4 + 16) = a2;
    end->__first_ = (std::__node<char> *)v4;
    this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
  }
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 11);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD07DDC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(std::basic_regex<char> *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3;
  int v4;
  BOOL v5;

  v3 = a2;
  if (a2 != a3)
  {
    v4 = (char)*a2;
    v5 = (v4 - 36) > 0x3A || ((1 << (*a2 - 36)) & 0x7800000080004F1) == 0;
    if (v5 && (v4 - 123) >= 3)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v4);
      ++v3;
    }
  }
  return v3;
}

void (__cdecl ***std::__match_any_but_newline<char>::~__match_any_but_newline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__match_any_but_newline<char>::~__match_any_but_newline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 3);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD07F30(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v4;
  unsigned int v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;

  if (a2 == a3)
    return a2;
  v4 = *a2;
  v5 = v4 - 48;
  if (v4 == 48)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v5);
    return a2 + 1;
  }
  if ((v4 - 49) > 8)
    return a2;
  v6 = a3;
  v7 = a2 + 1;
  if (a2 + 1 != a3)
  {
    while (1)
    {
      v8 = *v7;
      if ((v8 - 48) > 9)
        break;
      if (v5 >= 0x19999999)
        goto LABEL_16;
      ++v7;
      v5 = v8 + 10 * v5 - 48;
      if (v7 == a3)
        goto LABEL_12;
    }
    v6 = v7;
LABEL_12:
    if (!v5)
      goto LABEL_16;
  }
  if (v5 > a1->__marked_count_)
LABEL_16:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(a1, v5);
  return v6;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_character_class_escape<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  char *v3;
  int v4;
  BOOL v5;
  BOOL v6;
  std::__bracket_expression<char, std::regex_traits<char>> *started;
  int v8;
  BOOL v9;
  std::__bracket_expression<char, std::regex_traits<char>> *v10;

  v3 = a2;
  if (a2 == a3)
    return v3;
  v4 = *a2;
  if (v4 > 99)
  {
    if (v4 == 119)
    {
      v5 = 0;
      goto LABEL_15;
    }
    if (v4 == 115)
    {
      v9 = 0;
      goto LABEL_17;
    }
    if (v4 != 100)
      return v3;
    v6 = 0;
LABEL_12:
    started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(a1, v6);
    v8 = started->__mask_ | 0x400;
LABEL_18:
    started->__mask_ = v8;
    goto LABEL_19;
  }
  switch(v4)
  {
    case 'D':
      v6 = 1;
      goto LABEL_12;
    case 'S':
      v9 = 1;
LABEL_17:
      started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(a1, v9);
      v8 = started->__mask_ | 0x4000;
      goto LABEL_18;
    case 'W':
      v5 = 1;
LABEL_15:
      v10 = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(a1, v5);
      v10->__mask_ |= 0x500u;
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v10, 95);
LABEL_19:
      ++v3;
      break;
  }
  return v3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4)
{
  unsigned __int8 *v4;
  uint64_t v5;
  std::basic_regex<char>::value_type v6;
  char v7;
  int v8;
  int v9;
  char v10;
  int v11;
  char v12;
  int v13;
  char v14;
  std::basic_regex<char>::value_type v15;
  unsigned __int8 v16;
  std::basic_regex<char>::value_type v17;
  __int16 v18;

  v4 = a2;
  if (a2 != a3)
  {
    v5 = *a2;
    v6 = v5;
    if ((char)v5 > 109)
    {
      v7 = 0;
      switch((char)v5)
      {
        case 'n':
          if (!a4)
          {
            v6 = 10;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((_BYTE *)a4 + 23) = 1;
          }
          v18 = 10;
          goto LABEL_81;
        case 'r':
          if (!a4)
          {
            v6 = 13;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((_BYTE *)a4 + 23) = 1;
          }
          v18 = 13;
          goto LABEL_81;
        case 't':
          if (!a4)
          {
            v6 = 9;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((_BYTE *)a4 + 23) = 1;
          }
          v18 = 9;
          goto LABEL_81;
        case 'u':
          if (v4 + 1 == a3)
            goto LABEL_91;
          v8 = v4[1];
          if ((v8 & 0xF8) != 0x30 && (v8 & 0xFE) != 0x38 && (v8 | 0x20u) - 97 >= 6)
            goto LABEL_91;
          v4 += 2;
          if (v4 == a3)
            goto LABEL_91;
          v9 = *v4;
          v10 = -48;
          if ((v9 & 0xF8) == 0x30 || (v9 & 0xFE) == 0x38)
            goto LABEL_28;
          v9 |= 0x20u;
          if ((v9 - 97) >= 6)
            goto LABEL_91;
          v10 = -87;
LABEL_28:
          v7 = 16 * (v10 + v9);
LABEL_29:
          if (v4 + 1 == a3)
            goto LABEL_91;
          v11 = v4[1];
          v12 = -48;
          if ((v11 & 0xF8) == 0x30 || (v11 & 0xFE) == 0x38)
            goto LABEL_34;
          v11 |= 0x20u;
          if ((v11 - 97) >= 6)
            goto LABEL_91;
          v12 = -87;
LABEL_34:
          if (v4 + 2 == a3)
            goto LABEL_91;
          v13 = v4[2];
          v14 = -48;
          if ((v13 & 0xF8) == 0x30 || (v13 & 0xFE) == 0x38)
            goto LABEL_39;
          v13 |= 0x20u;
          if ((v13 - 97) >= 6)
            goto LABEL_91;
          v14 = -87;
LABEL_39:
          v15 = v14 + v13 + 16 * (v12 + v11 + v7);
          if (a4)
          {
            if (*((char *)a4 + 23) < 0)
            {
              a4[1] = 1;
              a4 = (uint64_t *)*a4;
            }
            else
            {
              *((_BYTE *)a4 + 23) = 1;
            }
            *(_BYTE *)a4 = v15;
            *((_BYTE *)a4 + 1) = 0;
          }
          else
          {
            std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v15);
          }
          v4 += 3;
          return v4;
        case 'v':
          if (!a4)
          {
            v6 = 11;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((_BYTE *)a4 + 23) = 1;
          }
          v18 = 11;
          break;
        case 'x':
          goto LABEL_29;
        default:
          goto LABEL_53;
      }
      goto LABEL_81;
    }
    if ((char)v5 == 48)
    {
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((_BYTE *)a4 + 23) = 1;
        }
        *(_WORD *)a4 = 0;
        return ++v4;
      }
      v6 = 0;
      goto LABEL_69;
    }
    if ((char)v5 != 99)
    {
      if ((char)v5 == 102)
      {
        if (a4)
        {
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((_BYTE *)a4 + 23) = 1;
          }
          v18 = 12;
LABEL_81:
          *(_WORD *)a4 = v18;
          return ++v4;
        }
        v6 = 12;
LABEL_69:
        std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v6);
        return ++v4;
      }
LABEL_53:
      if ((char)v5 != 95 && ((char)v5 < 0 || (a1->__traits_.__ct_->__tab_[v5] & 0x500) == 0))
      {
        if (a4)
        {
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((_BYTE *)a4 + 23) = 1;
          }
          *(_BYTE *)a4 = v5;
          *((_BYTE *)a4 + 1) = 0;
          return ++v4;
        }
        goto LABEL_69;
      }
LABEL_91:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
    }
    if (v4 + 1 == a3)
      goto LABEL_91;
    v16 = v4[1];
    if (((v16 & 0xDF) - 65) > 0x19u)
      goto LABEL_91;
    v17 = v16 & 0x1F;
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((_BYTE *)a4 + 23) = 1;
      }
      *(_BYTE *)a4 = v17;
      *((_BYTE *)a4 + 1) = 0;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v17);
    }
    v4 += 2;
  }
  return v4;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_char(std::basic_regex<char> *this, std::basic_regex<char>::value_type __c)
{
  uint64_t v2;
  std::basic_regex<_CharT, _Traits>::flag_type flags;
  uint64_t v5;
  std::__owns_one_state<char> *end;
  std::__node<char> *v7;
  uint64_t v8;
  std::__node<char> *first;

  v2 = __c;
  flags = this->__flags_;
  if ((flags & 1) != 0)
  {
    v8 = operator new();
    std::__match_char_icase<char,std::regex_traits<char>>::__match_char_icase[abi:ne180100](v8, (uint64_t)this, v2, (uint64_t)this->__end_->__first_);
LABEL_6:
    this->__end_->__first_ = (std::__node<char> *)v8;
    goto LABEL_7;
  }
  if ((flags & 8) != 0)
  {
    v8 = operator new();
    first = this->__end_->__first_;
    *(_QWORD *)v8 = &unk_1E87504D8;
    *(_QWORD *)(v8 + 8) = first;
    std::locale::locale((std::locale *)(v8 + 16), &this->__traits_.__loc_);
    *(_OWORD *)(v8 + 24) = *(_OWORD *)&this->__traits_.__ct_;
    *(_BYTE *)(v8 + 40) = v2;
    goto LABEL_6;
  }
  v5 = operator new();
  end = this->__end_;
  v7 = end->__first_;
  *(_QWORD *)v5 = &unk_1E87502A0;
  *(_QWORD *)(v5 + 8) = v7;
  *(_BYTE *)(v5 + 16) = v2;
  end->__first_ = (std::__node<char> *)v5;
LABEL_7:
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
}

void sub_1CBD085A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x10E1C4010F5D982);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 4);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD085FC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(std::basic_regex<char> *this, int __i)
{
  std::basic_regex<_CharT, _Traits>::flag_type flags;
  uint64_t v5;
  std::__owns_one_state<char> *end;
  std::__node<char> *v7;
  std::locale *v8;
  std::locale *v9;
  std::__node<char> *first;
  char *v11;

  flags = this->__flags_;
  if ((flags & 1) != 0)
  {
    v8 = (std::locale *)operator new();
    v9 = v8;
    first = this->__end_->__first_;
LABEL_6:
    v8->__locale_ = (std::locale::__imp *)(v11 + 16);
    v8[1].__locale_ = (std::locale::__imp *)first;
    std::locale::locale(v8 + 2, &this->__traits_.__loc_);
    *(_OWORD *)&v9[3].__locale_ = *(_OWORD *)&this->__traits_.__ct_;
    LODWORD(v9[5].__locale_) = __i;
    this->__end_->__first_ = (std::__node<char> *)v9;
    goto LABEL_7;
  }
  if ((flags & 8) != 0)
  {
    v8 = (std::locale *)operator new();
    v9 = v8;
    first = this->__end_->__first_;
    goto LABEL_6;
  }
  v5 = operator new();
  end = this->__end_;
  v7 = end->__first_;
  *(_QWORD *)v5 = &unk_1E874FE98;
  *(_QWORD *)(v5 + 8) = v7;
  *(_DWORD *)(v5 + 16) = __i;
  end->__first_ = (std::__node<char> *)v5;
LABEL_7:
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
}

uint64_t std::__match_char_icase<char,std::regex_traits<char>>::__match_char_icase[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)a1 = &unk_1E8750448;
  *(_QWORD *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 40) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 8) + 40))(*(_QWORD *)(a2 + 8), a3);
  return a1;
}

void sub_1CBD08778(_Unwind_Exception *a1)
{
  void (__cdecl ***v1)(std::__owns_one_state<char> *__hidden);
  std::locale *v2;
  void (__cdecl **v4)(std::__owns_one_state<char> *__hidden);

  std::locale::~locale(v2);
  v4 = v1[1];
  if (v4)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v4 + 1))(v4);
  _Unwind_Resume(a1);
}

std::locale *std::__match_char_icase<char,std::regex_traits<char>>::~__match_char_icase(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750448;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  return a1;
}

void std::__match_char_icase<char,std::regex_traits<char>>::~__match_char_icase(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750448;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__match_char_icase<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (v4 = result,
        result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(result + 24) + 40))(*(_QWORD *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(_QWORD *)(a2 + 16);
    v5 = *(_QWORD *)(v4 + 8);
  }
  *(_QWORD *)(a2 + 80) = v5;
  return result;
}

std::locale *std::__match_char_collate<char,std::regex_traits<char>>::~__match_char_collate(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E87504D8;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  return a1;
}

void std::__match_char_collate<char,std::regex_traits<char>>::~__match_char_collate(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E87504D8;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__match_char_collate<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t v3;

  v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(_QWORD *)(a2 + 16) = v2 + 1;
    v3 = *(_QWORD *)(result + 8);
  }
  *(_QWORD *)(a2 + 80) = v3;
  return result;
}

void (__cdecl ***std::__match_char<char>::~__match_char(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__match_char<char>::~__match_char(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__match_char<char>::__exec(uint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t v3;

  v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(_QWORD *)(a2 + 16) = v2 + 1;
    v3 = *(_QWORD *)(result + 8);
  }
  *(_QWORD *)(a2 + 80) = v3;
  return result;
}

std::locale *std::__back_ref_icase<char,std::regex_traits<char>>::~__back_ref_icase(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750330;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  return a1;
}

void std::__back_ref_icase<char,std::regex_traits<char>>::~__back_ref_icase(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750330;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__back_ref_icase<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v3 = *(_QWORD *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(_BYTE *)(v3 + 16))
  {
    v4 = *(_QWORD *)(v3 + 8) - *(_QWORD *)v3;
    v5 = *(_QWORD *)(a2 + 16);
    if (*(_QWORD *)(a2 + 24) - v5 >= v4)
    {
      v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(_QWORD *)(a2 + 16) = v5 + v4;
        v6 = *(_QWORD *)(v7 + 8);
        goto LABEL_10;
      }
      v8 = 0;
      while (1)
      {
        v9 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v7 + 24) + 40))(*(_QWORD *)(v7 + 24), *(char *)(*(_QWORD *)v3 + v8));
        result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v7 + 24) + 40))(*(_QWORD *)(v7 + 24), *(char *)(*(_QWORD *)(a2 + 16) + v8));
        if (v9 != (_DWORD)result)
          break;
        if (v4 == ++v8)
        {
          v5 = *(_QWORD *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(_QWORD *)(a2 + 80) = v6;
  return result;
}

std::locale *std::__back_ref_collate<char,std::regex_traits<char>>::~__back_ref_collate(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750418;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  return a1;
}

void std::__back_ref_collate<char,std::regex_traits<char>>::~__back_ref_collate(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1E8750418;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__back_ref_collate<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;

  v2 = *(_DWORD *)(result + 40) - 1;
  v3 = *(_QWORD *)(a2 + 32);
  if (*(_BYTE *)(v3 + 24 * v2 + 16))
  {
    v4 = (unsigned __int8 **)(v3 + 24 * v2);
    v5 = *v4;
    v6 = v4[1] - *v4;
    v7 = *(_QWORD *)(a2 + 16);
    if (*(_QWORD *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(_QWORD *)(a2 + 16) = v7 + v6;
        v8 = *(_QWORD *)(result + 8);
        goto LABEL_9;
      }
      v9 = *(unsigned __int8 **)(a2 + 16);
      v10 = v6;
      while (1)
      {
        v12 = *v5++;
        v11 = v12;
        v13 = *v9++;
        if (v11 != v13)
          break;
        if (!--v10)
          goto LABEL_8;
      }
    }
  }
  v8 = 0;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(_QWORD *)(a2 + 80) = v8;
  return result;
}

void (__cdecl ***std::__back_ref<char>::~__back_ref(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__back_ref<char>::~__back_ref(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

unsigned int *std::__back_ref<char>::__exec(unsigned int *result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unsigned int v5;
  unsigned int *v6;
  uint64_t v7;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = result[4];
  v3 = *(_QWORD *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a2 + 40) - v3) >> 3) < v2)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  v5 = v2 - 1;
  if (*(_BYTE *)(v3 + 24 * v5 + 16)
    && (v6 = result,
        v7 = v3 + 24 * v5,
        result = *(unsigned int **)v7,
        v8 = *(_QWORD *)(v7 + 8) - *(_QWORD *)v7,
        v9 = *(_QWORD *)(a2 + 16),
        *(_QWORD *)(a2 + 24) - v9 >= v8)
    && (result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !(_DWORD)result))
  {
    *(_DWORD *)a2 = -994;
    *(_QWORD *)(a2 + 16) = v9 + v8;
    v10 = *((_QWORD *)v6 + 1);
  }
  else
  {
    v10 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(_QWORD *)(a2 + 80) = v10;
  return result;
}

std::__bracket_expression<char, std::regex_traits<char>> *__cdecl std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(std::basic_regex<char> *this, BOOL __negate)
{
  std::__bracket_expression<char, std::regex_traits<char>> *v4;

  v4 = (std::__bracket_expression<char, std::regex_traits<char>> *)operator new();
  std::__bracket_expression<char,std::regex_traits<char>>::__bracket_expression[abi:ne180100]((uint64_t)v4, (uint64_t)this, (uint64_t)this->__end_->__first_, __negate, this->__flags_ & 1, (this->__flags_ & 8) != 0);
  this->__end_->__first_ = v4;
  this->__end_ = v4;
  return v4;
}

void sub_1CBD08F8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17A53D0](v1, 0x10F1C4061CF1F02);
  _Unwind_Resume(a1);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](uint64_t a1, uint64_t a2)
{
  char v2;
  unint64_t v4;
  _BYTE *v5;
  unint64_t *v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  _BYTE *v22;
  char v23;
  unint64_t v24;
  _BYTE *v25;
  unint64_t v26;
  unint64_t v27;
  size_t v28;
  _BYTE *v29;
  char v30;
  _BYTE *v31;
  char v32;

  v2 = a2;
  if (*(_BYTE *)(a1 + 169))
  {
    v2 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), a2);
    v5 = *(_BYTE **)(a1 + 48);
    v4 = *(_QWORD *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      v6 = (unint64_t *)(a1 + 40);
      v7 = *(_QWORD *)(a1 + 40);
      v8 = &v5[-v7];
      v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        v10 = v4 - v7;
        if (2 * v10 > v9)
          v9 = 2 * v10;
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
          v11 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v11 = v9;
        if (v11)
          v12 = operator new(v11);
        else
          v12 = 0;
        v20 = &v8[(_QWORD)v12];
        v21 = (char *)v12 + v11;
        v8[(_QWORD)v12] = v2;
        v19 = (uint64_t)&v8[(_QWORD)v12 + 1];
        if (v5 != (_BYTE *)v7)
        {
          v22 = &v5[~v7];
          do
          {
            v23 = *--v5;
            (v22--)[(_QWORD)v12] = v23;
          }
          while (v5 != (_BYTE *)v7);
LABEL_45:
          v5 = (_BYTE *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    goto LABEL_22;
  }
  v6 = (unint64_t *)(a1 + 40);
  v5 = *(_BYTE **)(a1 + 48);
  v13 = *(_QWORD *)(a1 + 56);
  if (!*(_BYTE *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      v24 = *v6;
      v25 = &v5[-*v6];
      v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        v27 = v13 - v24;
        if (2 * v27 > v26)
          v26 = 2 * v27;
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL)
          v28 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
          v12 = operator new(v28);
        else
          v12 = 0;
        v20 = &v25[(_QWORD)v12];
        v21 = (char *)v12 + v28;
        v25[(_QWORD)v12] = v2;
        v19 = (uint64_t)&v25[(_QWORD)v12 + 1];
        if (v5 != (_BYTE *)v24)
        {
          v31 = &v5[~v24];
          do
          {
            v32 = *--v5;
            (v31--)[(_QWORD)v12] = v32;
          }
          while (v5 != (_BYTE *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    *v5 = v2;
    v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13)
    goto LABEL_22;
  v14 = *v6;
  v15 = &v5[-*v6];
  v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0)
    goto LABEL_50;
  v17 = v13 - v14;
  if (2 * v17 > v16)
    v16 = 2 * v17;
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL)
    v18 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v18 = v16;
  if (v18)
    v12 = operator new(v18);
  else
    v12 = 0;
  v20 = &v15[(_QWORD)v12];
  v21 = (char *)v12 + v18;
  v15[(_QWORD)v12] = v2;
  v19 = (uint64_t)&v15[(_QWORD)v12 + 1];
  if (v5 != (_BYTE *)v14)
  {
    v29 = &v5[~v14];
    do
    {
      v30 = *--v5;
      (v29--)[(_QWORD)v12] = v30;
    }
    while (v5 != (_BYTE *)v14);
    goto LABEL_45;
  }
LABEL_46:
  v12 = v20;
LABEL_47:
  *(_QWORD *)(a1 + 40) = v12;
  *(_QWORD *)(a1 + 48) = v19;
  *(_QWORD *)(a1 + 56) = v21;
  if (v5)
    operator delete(v5);
LABEL_49:
  *(_QWORD *)(a1 + 48) = v19;
}

uint64_t std::__bracket_expression<char,std::regex_traits<char>>::__bracket_expression[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  const std::locale *v11;
  __int128 v12;
  std::string::size_type size;
  std::string *v14;
  BOOL v15;
  std::locale v17;
  std::string v18;

  *(_QWORD *)(a1 + 8) = a3;
  v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  v12 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 24) = v12;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_BYTE *)(a1 + 168) = a4;
  *(_BYTE *)(a1 + 169) = a5;
  *(_BYTE *)(a1 + 170) = a6;
  std::locale::locale(&v17, v11);
  std::locale::name(&v18, &v17);
  size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v18.__r_.__value_.__l.__size_;
  if (size == 1)
  {
    v14 = (std::string *)v18.__r_.__value_.__r.__words[0];
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v14 = &v18;
    v15 = v14->__r_.__value_.__s.__data_[0] != 67;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_9;
  }
  else
  {
    v15 = 1;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
LABEL_9:
      operator delete(v18.__r_.__value_.__l.__data_);
  }
  std::locale::~locale(&v17);
  *(_BYTE *)(a1 + 171) = v15;
  return a1;
}

void sub_1CBD092F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD *a10)
{
  void (__cdecl ***v10)(std::__owns_one_state<char> *__hidden);
  std::locale *v11;
  void **v12;
  void (__cdecl **v14)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v15)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v16)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v17)(std::__owns_one_state<char> *__hidden);

  std::locale::~locale((std::locale *)&a9);
  a10 = v10 + 17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  v14 = v10[14];
  if (v14)
  {
    v10[15] = v14;
    operator delete(v14);
  }
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  v15 = v10[8];
  if (v15)
  {
    v10[9] = v15;
    operator delete(v15);
  }
  v16 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))*v12;
  if (*v12)
  {
    v10[6] = v16;
    operator delete(v16);
  }
  std::locale::~locale(v11);
  v17 = v10[1];
  if (v17)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v17 + 1))(v17);
  _Unwind_Resume(a1);
}

std::locale *std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  std::locale::__imp *locale;
  std::locale::__imp *v3;
  std::locale::__imp *v4;
  std::locale::__imp *v5;
  std::locale *v7;

  v7 = a1 + 17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }
  v7 = a1 + 11;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
  v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }
  v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }
  std::locale::~locale(a1 + 2);
  v5 = a1[1].__locale_;
  if (v5)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)v5 + 8))(v5);
  return a1;
}

uint64_t std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  std::locale::__imp *locale;
  std::locale::__imp *v3;
  std::locale::__imp *v4;
  std::locale::__imp *v5;
  std::locale *v7;

  v7 = a1 + 17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }
  v7 = a1 + 11;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
  v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }
  v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }
  std::locale::~locale(a1 + 2);
  v5 = a1[1].__locale_;
  if (v5)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)v5 + 8))(v5);
  return MEMORY[0x1D17A53D0](a1, 0x10F1C4061CF1F02);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__exec(const std::__bracket_expression<char, std::regex_traits<char>> *this, std::__bracket_expression<char, std::regex_traits<char>>::__state *a2)
{
  char *current;
  char *last;
  signed __int8 v6;
  signed __int8 v7;
  std::vector<std::pair<char, char>>::pointer begin;
  uint64_t v9;
  uint64_t v10;
  char *p_second;
  std::pair<std::string, std::string> *v13;
  uint64_t v14;
  unint64_t v15;
  _BOOL4 negate;
  int v17;
  uint64_t v18;
  size_t v19;
  unsigned __int8 v20;
  std::vector<char>::pointer v21;
  unint64_t v22;
  int v23;
  std::regex_traits<char>::char_class_type v24;
  int v25;
  std::vector<char>::pointer end;
  std::vector<char>::pointer v27;
  char *v28;
  std::vector<std::pair<std::string, std::string>>::pointer v29;
  std::vector<std::pair<std::string, std::string>>::pointer v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  std::vector<std::string>::pointer v34;
  uint64_t v35;
  int64_t v36;
  uint64_t v37;
  unint64_t v38;
  void *v39;
  size_t v40;
  size_t v41;
  uint64_t v42;
  BOOL v43;
  std::string *v44;
  std::string::size_type v45;
  int v46;
  std::string *v47;
  void **v48;
  uint64_t v49;
  size_t v50;
  int v51;
  std::regex_traits<char>::char_class_type v52;
  int v53;
  std::vector<std::string>::pointer v54;
  uint64_t v55;
  int64_t v56;
  uint64_t v57;
  unint64_t v58;
  size_t v59;
  void *v60;
  size_t v61;
  uint64_t v62;
  BOOL v63;
  std::string *v64;
  std::string::size_type size;
  int v66;
  std::string *v67;
  void **p_p;
  uint64_t v69;
  int v70;
  std::regex_traits<char>::char_class_type mask;
  const std::ctype_base::mask *tab;
  std::ctype_base::mask v73;
  std::regex_traits<char>::char_class_type neg_mask;
  int v75;
  std::__node<char> *first;
  int v77;
  std::string *v78;
  _BOOL4 v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void *__p;
  size_t v84;
  char v85;
  unsigned __int8 v86;
  unsigned __int8 v87;
  uint64_t v88;

  current = a2->__current_;
  last = a2->__last_;
  if (current == last)
  {
    v18 = 0;
    negate = this->__negate_;
    goto LABEL_155;
  }
  if (!this->__might_have_digraph_ || current + 1 == last)
    goto LABEL_27;
  v6 = *current;
  v86 = *current;
  v7 = current[1];
  v87 = v7;
  if (this->__icase_)
  {
    v86 = ((uint64_t (*)(const std::ctype<char> *, _QWORD))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v6);
    v87 = ((uint64_t (*)(const std::ctype<char> *, _QWORD))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v7);
  }
  std::regex_traits<char>::__lookup_collatename<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v88, (uint64_t)&__p);
  if ((v85 & 0x80000000) == 0)
  {
    if (v85)
      goto LABEL_8;
LABEL_27:
    negate = 0;
    v18 = 1;
    goto LABEL_28;
  }
  v19 = v84;
  operator delete(__p);
  if (!v19)
    goto LABEL_27;
LABEL_8:
  begin = this->__digraphs_.__begin_;
  v9 = (char *)this->__digraphs_.__end_ - (char *)begin;
  if (v9)
  {
    v10 = v9 >> 1;
    if ((unint64_t)(v9 >> 1) <= 1)
      v10 = 1;
    p_second = &begin->second;
    do
    {
      if (v86 == *(p_second - 1) && v87 == *p_second)
        goto LABEL_152;
      p_second += 2;
      --v10;
    }
    while (v10);
  }
  if (!this->__collate_ || this->__ranges_.__begin_ == this->__ranges_.__end_)
  {
    negate = 0;
  }
  else
  {
    std::regex_traits<char>::transform<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v88);
    v13 = this->__ranges_.__begin_;
    if (this->__ranges_.__end_ == v13)
    {
LABEL_24:
      negate = 0;
      v17 = 0;
    }
    else
    {
      v14 = 0;
      v15 = 0;
      while ((int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v13[v14].first.__r_.__value_.__r.__words, &__p) << 24) > 0xFFFFFF|| (int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, (void **)&this->__ranges_.__begin_[v14].second.__r_.__value_.__l.__data_) << 24) >= 0x1000000)
      {
        ++v15;
        v13 = this->__ranges_.__begin_;
        ++v14;
        if (v15 >= 0xAAAAAAAAAAAAAAABLL * (((char *)this->__ranges_.__end_ - (char *)v13) >> 4))
          goto LABEL_24;
      }
      negate = 1;
      v17 = 5;
    }
    if (v85 < 0)
      operator delete(__p);
    if (negate)
      goto LABEL_129;
  }
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_)
    goto LABEL_134;
  std::regex_traits<char>::__transform_primary<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v88, (uint64_t)&__p);
  v54 = this->__equivalences_.__begin_;
  v55 = v85;
  v56 = (char *)this->__equivalences_.__end_ - (char *)v54;
  if (v56)
  {
    v57 = 0;
    v58 = v56 / 24;
    v60 = __p;
    v59 = v84;
    if (v85 >= 0)
      v61 = v85;
    else
      v61 = v84;
    if (v58 <= 1)
      v62 = 1;
    else
      v62 = v56 / 24;
    v63 = 1;
    while (1)
    {
      v64 = &v54[v57];
      size = HIBYTE(v64->__r_.__value_.__r.__words[2]);
      v66 = (char)size;
      if ((size & 0x80u) != 0)
        size = v64->__r_.__value_.__l.__size_;
      if (v61 == size)
      {
        if (v66 >= 0)
          v67 = &v54[v57];
        else
          v67 = (std::string *)v64->__r_.__value_.__r.__words[0];
        if ((v55 & 0x80) == 0)
        {
          if ((_DWORD)v55)
          {
            p_p = &__p;
            v69 = v55;
            do
            {
              if (*(unsigned __int8 *)p_p != v67->__r_.__value_.__s.__data_[0])
                goto LABEL_122;
              p_p = (void **)((char *)p_p + 1);
              v67 = (std::string *)((char *)v67 + 1);
              --v69;
            }
            while (v69);
            negate = 1;
            v17 = 5;
            goto LABEL_126;
          }
          negate = 1;
          if (v63)
            goto LABEL_154;
LABEL_134:
          if ((char)v86 < 0)
          {
            neg_mask = this->__neg_mask_;
            goto LABEL_147;
          }
          mask = this->__mask_;
          tab = this->__traits_.__ct_->__tab_;
          v73 = tab[v86];
          if ((v73 & mask) == 0 && (v86 != 95 || (mask & 0x80) == 0)
            || (char)v87 < 0
            || (tab[v87] & mask) == 0 && ((mask & 0x80) == 0 || v87 != 95))
          {
            neg_mask = this->__neg_mask_;
            if ((v73 & neg_mask) != 0 || v86 == 95 && (neg_mask & 0x80) != 0)
            {
LABEL_151:
              v75 = negate;
              goto LABEL_153;
            }
LABEL_147:
            if (((char)v87 & 0x80000000) == 0)
            {
              if ((this->__traits_.__ct_->__tab_[v87] & neg_mask) != 0)
                goto LABEL_151;
              v75 = 1;
              if (v87 == 95 && (neg_mask & 0x80) != 0)
                goto LABEL_151;
LABEL_153:
              negate = v75;
LABEL_154:
              v18 = 2;
              goto LABEL_155;
            }
          }
LABEL_152:
          v75 = 1;
          goto LABEL_153;
        }
        v80 = v58;
        v82 = v55;
        v70 = memcmp(v60, v67, v59);
        v58 = v80;
        v55 = v82;
        if (!v70)
          break;
      }
LABEL_122:
      v63 = ++v57 < v58;
      if (v57 == v62)
        goto LABEL_125;
    }
    v17 = 5;
    negate = 1;
    goto LABEL_127;
  }
  v63 = 0;
LABEL_125:
  v17 = 0;
LABEL_126:
  if ((v55 & 0x80) != 0)
LABEL_127:
    operator delete(__p);
  if (!v63)
    goto LABEL_134;
LABEL_129:
  if (v17)
    goto LABEL_154;
  v18 = 2;
LABEL_28:
  v20 = *a2->__current_;
  v86 = v20;
  if (this->__icase_)
  {
    v20 = ((uint64_t (*)(const std::ctype<char> *, _QWORD))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, (char)v20);
    v86 = v20;
  }
  v21 = this->__chars_.__begin_;
  v22 = this->__chars_.__end_ - v21;
  if (v22)
  {
    if (v22 <= 1)
      v22 = 1;
    while (1)
    {
      v23 = *v21++;
      if (v23 == v20)
        break;
      if (!--v22)
        goto LABEL_35;
    }
LABEL_46:
    negate = 1;
    goto LABEL_155;
  }
LABEL_35:
  v24 = this->__neg_mask_;
  if (v24 || this->__neg_chars_.__begin_ != this->__neg_chars_.__end_)
  {
    if ((v20 & 0x80) != 0 || (this->__traits_.__ct_->__tab_[v20] & v24) == 0)
      v25 = (v20 == 95) & (v24 >> 7);
    else
      LOBYTE(v25) = 1;
    end = this->__neg_chars_.__end_;
    v27 = (std::vector<char>::pointer)memchr(this->__neg_chars_.__begin_, (char)v20, end - this->__neg_chars_.__begin_);
    v28 = v27 ? v27 : end;
    if ((v25 & 1) == 0 && v28 == end)
      goto LABEL_46;
  }
  v29 = this->__ranges_.__begin_;
  v30 = this->__ranges_.__end_;
  if (v29 != v30)
  {
    if (this->__collate_)
    {
      std::regex_traits<char>::transform<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v87);
      v29 = this->__ranges_.__begin_;
      v30 = this->__ranges_.__end_;
    }
    else
    {
      v85 = 1;
      LOWORD(__p) = v20;
    }
    if (v30 == v29)
    {
LABEL_57:
      v33 = 0;
    }
    else
    {
      v31 = 0;
      v32 = 0;
      while ((int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v29[v31].first.__r_.__value_.__r.__words, &__p) << 24) > 0xFFFFFF|| (int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, (void **)&this->__ranges_.__begin_[v31].second.__r_.__value_.__l.__data_) << 24) >= 0x1000000)
      {
        ++v32;
        v29 = this->__ranges_.__begin_;
        ++v31;
        if (v32 >= 0xAAAAAAAAAAAAAAABLL * (((char *)this->__ranges_.__end_ - (char *)v29) >> 4))
          goto LABEL_57;
      }
      v33 = 1;
      negate = 1;
    }
    if (v85 < 0)
      operator delete(__p);
    if ((v33 & 1) != 0)
      goto LABEL_155;
  }
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_)
    goto LABEL_90;
  std::regex_traits<char>::__transform_primary<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v87, (uint64_t)&__p);
  v34 = this->__equivalences_.__begin_;
  v35 = v85;
  v36 = (char *)this->__equivalences_.__end_ - (char *)v34;
  if (v36)
  {
    v81 = v18;
    v37 = 0;
    v38 = v36 / 24;
    v39 = __p;
    v40 = v84;
    if (v85 >= 0)
      v41 = v85;
    else
      v41 = v84;
    if (v38 <= 1)
      v42 = 1;
    else
      v42 = v36 / 24;
    v43 = 1;
    while (1)
    {
      v44 = &v34[v37];
      v45 = HIBYTE(v44->__r_.__value_.__r.__words[2]);
      v46 = (char)v45;
      if ((v45 & 0x80u) != 0)
        v45 = v44->__r_.__value_.__l.__size_;
      if (v41 == v45)
      {
        if (v46 >= 0)
          v47 = &v34[v37];
        else
          v47 = (std::string *)v44->__r_.__value_.__r.__words[0];
        if ((v35 & 0x80) != 0)
        {
          v79 = negate;
          v50 = v41;
          v78 = v34;
          v51 = memcmp(v39, v47, v40);
          v34 = v78;
          v41 = v50;
          negate = v79;
          if (!v51)
          {
            negate = 1;
            v18 = v81;
            goto LABEL_88;
          }
        }
        else
        {
          if (!(_DWORD)v35)
          {
            negate = 1;
            v18 = v81;
            if (!v43)
              goto LABEL_90;
            goto LABEL_155;
          }
          v48 = &__p;
          v49 = v35;
          while (*(unsigned __int8 *)v48 == v47->__r_.__value_.__s.__data_[0])
          {
            v48 = (void **)((char *)v48 + 1);
            v47 = (std::string *)((char *)v47 + 1);
            if (!--v49)
            {
              negate = 1;
              goto LABEL_85;
            }
          }
        }
      }
      v43 = ++v37 < v38;
      if (v37 == v42)
      {
LABEL_85:
        v18 = v81;
        if ((v35 & 0x80) == 0)
          goto LABEL_89;
        goto LABEL_88;
      }
    }
  }
  v43 = 0;
  if (v85 < 0)
LABEL_88:
    operator delete(__p);
LABEL_89:
  if (!v43)
  {
LABEL_90:
    if ((char)v86 < 0)
      goto LABEL_155;
    v52 = this->__mask_;
    if ((this->__traits_.__ct_->__tab_[v86] & v52) == 0)
    {
      v53 = (v52 >> 7) & 1;
      if (v86 != 95)
        v53 = 0;
      if (v53 != 1)
        goto LABEL_155;
    }
    goto LABEL_46;
  }
LABEL_155:
  if (negate == this->__negate_)
  {
    first = 0;
    v77 = -993;
  }
  else
  {
    a2->__current_ += v18;
    first = this->__first_;
    v77 = -995;
  }
  a2->__do_ = v77;
  a2->__node_ = first;
}

void std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::regex_traits<char>::transform<char *>(uint64_t a1, char *a2, char *a3)
{
  unint64_t v4;
  void **v5;
  void *__p[2];
  unsigned __int8 v7;

  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  v4 = v7;
  if ((v7 & 0x80u) == 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  if ((v7 & 0x80u) != 0)
    v4 = (unint64_t)__p[1];
  (*(void (**)(_QWORD, void **, char *))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16), v5, (char *)v5 + v4);
  if ((char)v7 < 0)
    operator delete(__p[0]);
}

void sub_1CBD09DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, void **a2)
{
  size_t v2;
  size_t v3;
  int v4;
  void *v5;
  size_t v6;

  v2 = *((unsigned __int8 *)a1 + 23);
  v3 = a1[1];
  if ((v2 & 0x80u) != 0)
  {
    a1 = (_QWORD *)*a1;
    v2 = v3;
  }
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = a2;
  else
    v5 = *a2;
  if (v4 >= 0)
    v6 = *((unsigned __int8 *)a2 + 23);
  else
    v6 = (size_t)a2[1];
  return std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(a1, v2, v5, v6);
}

void std::regex_traits<char>::__lookup_collatename<char *>(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  std::string *p_s;
  unint64_t v7;
  unint64_t v8;
  std::string::size_type size;
  std::string *v10;
  int v11;
  uint64_t v12;
  std::string v13;
  std::string __s;

  std::string::__init_with_size[abi:ne180100]<char *,char *>(&__s, a2, a3, a3 - a2);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_)
      goto LABEL_9;
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((_BYTE *)&__s.__r_.__value_.__s + 23))
      return;
    p_s = &__s;
  }
  std::__get_collation_name(&v13, (const char *)p_s);
  *(_OWORD *)a4 = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
  v7 = v13.__r_.__value_.__r.__words[2];
  *(_QWORD *)(a4 + 16) = *((_QWORD *)&v13.__r_.__value_.__l + 2);
  v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a4 + 8);
  if (v8)
    goto LABEL_9;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __s.__r_.__value_.__l.__size_;
    if (__s.__r_.__value_.__l.__size_ >= 3)
      goto LABEL_9;
    v10 = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
      return;
    v10 = &__s;
  }
  (*(void (**)(std::string *__return_ptr, _QWORD, std::string *, char *))(**(_QWORD **)(a1 + 16) + 32))(&v13, *(_QWORD *)(a1 + 16), v10, (char *)v10 + size);
  if (*(char *)(a4 + 23) < 0)
    operator delete(*(void **)a4);
  *(std::string *)a4 = v13;
  if ((*(char *)(a4 + 23) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(a4 + 23);
    if (v11 != 12 && v11 != 1)
    {
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_25;
  }
  v12 = *(_QWORD *)(a4 + 8);
  if (v12 == 1 || v12 == 12)
  {
LABEL_25:
    std::string::operator=((std::string *)a4, &__s);
    goto LABEL_9;
  }
  **(_BYTE **)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
}

void sub_1CBD09F64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;

  if (*(char *)(v17 + 23) < 0)
    operator delete(*(void **)v17);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::__init_with_size[abi:ne180100]<char *,char *>(_QWORD *result, char *a2, char *a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a4 > 0x16)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    *v4 = result;
    v4 = result;
  }
  else
  {
    *((_BYTE *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    v10 = *a2++;
    *(_BYTE *)v4 = v10;
    v4 = (_QWORD *)((char *)v4 + 1);
  }
  *(_BYTE *)v4 = 0;
  return result;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(const void *a1, size_t a2, void *__s2, size_t a4)
{
  size_t v7;
  int v8;

  if (a4 >= a2)
    v7 = a2;
  else
    v7 = a4;
  v8 = memcmp(a1, __s2, v7);
  if (v8)
  {
    if ((v8 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (a2 == a4)
      return 0;
    if (a2 >= a4)
      return 1;
  }
  return 255;
}

void std::regex_traits<char>::__transform_primary<char *>(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v6;
  void **v7;
  uint64_t v8;
  int v9;
  _BYTE *v10;
  void *__p[2];
  unsigned __int8 v12;

  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  v6 = v12;
  if ((v12 & 0x80u) == 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  if ((v12 & 0x80u) != 0)
    v6 = (unint64_t)__p[1];
  (*(void (**)(_QWORD, void **, char *))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16), v7, (char *)v7 + v6);
  v8 = *(unsigned __int8 *)(a4 + 23);
  v9 = (char)v8;
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a4 + 8);
  if (v8 != 1)
  {
    if (v8 == 12)
    {
      if (v9 >= 0)
        v10 = (_BYTE *)a4;
      else
        v10 = *(_BYTE **)a4;
      v10[11] = v10[3];
    }
    else if (v9 < 0)
    {
      **(_BYTE **)a4 = 0;
      *(_QWORD *)(a4 + 8) = 0;
    }
    else
    {
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 23) = 0;
    }
  }
  if ((char)v12 < 0)
    operator delete(__p[0]);
}

void sub_1CBD0A170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 5);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0A1C4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  char *v4;
  int v5;
  uint64_t v6;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  char v13;
  int v14;
  char *v15;
  int v16;
  char *v17;
  char *v18;
  __int128 *v19;
  int v20;
  _BYTE *v21;
  char *v22;
  uint64_t v24;
  void *__p[2];
  uint64_t v26;
  void *v27[2];
  uint64_t v28;
  void *v29[2];
  uint64_t v30;
  __int128 v31;
  uint64_t v32;

  v4 = a2;
  if (a2 == a3)
    return v4;
  v5 = *a2;
  if (v5 == 93)
    return v4;
  v6 = (uint64_t)a4;
  v9 = 0;
  v10 = 0;
  v31 = 0uLL;
  v32 = 0;
  if (a2 + 1 != a3 && v5 == 91)
  {
    v11 = a2[1];
    switch(v11)
    {
      case '.':
        v4 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, a2 + 2, a3, (uint64_t)&v31);
        v9 = HIBYTE(v32);
        v10 = *((_QWORD *)&v31 + 1);
        break;
      case ':':
        v12 = std::basic_regex<char,std::regex_traits<char>>::__parse_character_class<char const*>(a1, a2 + 2, a3, (uint64_t)a4);
        goto LABEL_11;
      case '=':
        v12 = std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(a1, a2 + 2, a3, a4);
LABEL_11:
        v6 = v12;
        v13 = 0;
        goto LABEL_44;
      default:
        v10 = 0;
        v9 = 0;
        break;
    }
  }
  v14 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if ((v9 & 0x80u) == 0)
    v10 = v9;
  if (v10)
  {
    v15 = v4;
    goto LABEL_28;
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1B0 | 0x40) == 0x40)
  {
    v16 = *v4;
    if (v16 == 92)
    {
      v17 = v4 + 1;
      if (v14)
        v18 = std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v17, a3, (uint64_t *)&v31);
      else
        v18 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)v17, (unsigned __int8 *)a3, (uint64_t)&v31, v6);
      v15 = v18;
      goto LABEL_28;
    }
  }
  else
  {
    LOBYTE(v16) = *v4;
  }
  if ((v9 & 0x80) != 0)
  {
    v19 = (__int128 *)v31;
    *((_QWORD *)&v31 + 1) = 1;
  }
  else
  {
    HIBYTE(v32) = 1;
    v19 = &v31;
  }
  *(_BYTE *)v19 = v16;
  *((_BYTE *)v19 + 1) = 0;
  v15 = v4 + 1;
LABEL_28:
  if (v15 == a3
    || (v20 = *v15, v20 == 93)
    || (v21 = v15 + 1, v15 + 1 == a3)
    || v20 != 45
    || *v21 == 93)
  {
    if (SHIBYTE(v32) < 0)
    {
      if (*((_QWORD *)&v31 + 1))
      {
        if (*((_QWORD *)&v31 + 1) != 1)
        {
          v22 = (char *)v31;
LABEL_42:
          std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100](v6, *v22, v22[1]);
          goto LABEL_43;
        }
        v22 = (char *)v31;
        goto LABEL_40;
      }
    }
    else if (HIBYTE(v32))
    {
      v22 = (char *)&v31;
      if (HIBYTE(v32) != 1)
        goto LABEL_42;
LABEL_40:
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](v6, *v22);
    }
LABEL_43:
    v13 = 1;
    v4 = v15;
    goto LABEL_44;
  }
  v29[0] = 0;
  v29[1] = 0;
  v30 = 0;
  v4 = v15 + 2;
  if (v15 + 2 != a3 && *v21 == 91 && *v4 == 46)
  {
    v24 = std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, v15 + 3, a3, (uint64_t)v29);
LABEL_60:
    v4 = (char *)v24;
    goto LABEL_61;
  }
  if ((v14 | 0x40) == 0x40)
  {
    LODWORD(v21) = *v21;
    if ((_DWORD)v21 == 92)
    {
      if (v14)
        v24 = (uint64_t)std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v15 + 2, a3, (uint64_t *)v29);
      else
        v24 = (uint64_t)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)v15 + 2, (unsigned __int8 *)a3, (uint64_t)v29, v6);
      goto LABEL_60;
    }
  }
  else
  {
    LOBYTE(v21) = *v21;
  }
  HIBYTE(v30) = 1;
  LOWORD(v29[0]) = v21;
LABEL_61:
  *(_OWORD *)v27 = v31;
  v28 = v32;
  v32 = 0;
  v31 = 0uLL;
  *(_OWORD *)__p = *(_OWORD *)v29;
  v26 = v30;
  v29[0] = 0;
  v29[1] = 0;
  v30 = 0;
  std::__bracket_expression<char,std::regex_traits<char>>::__add_range[abi:ne180100](v6, (char *)v27, (char *)__p);
  if (SHIBYTE(v26) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v28) < 0)
    operator delete(v27[0]);
  if (SHIBYTE(v30) < 0)
    operator delete(v29[0]);
  v13 = 1;
LABEL_44:
  if (SHIBYTE(v32) < 0)
    operator delete((void *)v31);
  if ((v13 & 1) != 0)
    return v4;
  return (char *)v6;
}

void sub_1CBD0A548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;

  if (a28 < 0)
    operator delete(__p);
  if (*(char *)(v28 - 49) < 0)
    operator delete(*(void **)(v28 - 72));
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  uint64_t i;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  void *__p[2];
  unsigned __int8 v16;
  void *v17;
  uint64_t v18;
  unsigned __int8 v19;

  if (a3 - a2 < 2 || a3 - 1 == a2)
    goto LABEL_33;
  for (i = 0; a2[i] != 61 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i)
      goto LABEL_33;
  }
  if (&a2[i] == a3)
LABEL_33:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  std::regex_traits<char>::__lookup_collatename<char *>(a1, a2, &a2[i], (uint64_t)&v17);
  if (((char)v19 & 0x80000000) == 0)
  {
    v8 = v19;
    if (v19)
    {
      v9 = (char *)&v17;
      goto LABEL_14;
    }
LABEL_34:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  }
  v8 = v18;
  if (!v18)
    goto LABEL_34;
  v9 = (char *)v17;
LABEL_14:
  std::regex_traits<char>::__transform_primary<char *>(a1, v9, &v9[v8], (uint64_t)__p);
  v10 = v16;
  if ((v16 & 0x80u) != 0)
    v10 = (unint64_t)__p[1];
  if (v10)
  {
    std::__bracket_expression<char,std::regex_traits<char>>::__add_equivalence[abi:ne180100](a4, (__int128 *)__p);
  }
  else
  {
    v11 = v19;
    if ((v19 & 0x80u) != 0)
      v11 = v18;
    if (v11 == 2)
    {
      v13 = (char *)&v17;
      if ((v19 & 0x80u) != 0)
        v13 = (char *)v17;
      std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100]((uint64_t)a4, *v13, v13[1]);
    }
    else
    {
      if (v11 != 1)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
      v12 = (char *)&v17;
      if ((v19 & 0x80u) != 0)
        v12 = (char *)v17;
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)a4, *v12);
    }
  }
  if ((char)v16 < 0)
    operator delete(__p[0]);
  if ((char)v19 < 0)
    operator delete(v17);
  return (uint64_t)&a2[i + 2];
}

void sub_1CBD0A74C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_character_class<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t i;
  int v7;

  if (a3 - a2 < 2 || a3 - 1 == a2)
    goto LABEL_11;
  for (i = 0; a2[i] != 58 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i)
      goto LABEL_11;
  }
  if (&a2[i] == a3)
LABEL_11:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  v7 = std::regex_traits<char>::__lookup_classname<char const*>(a1, a2, &a2[i], *(_BYTE *)(a1 + 24) & 1);
  if (!v7)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)2>();
  *(_DWORD *)(a4 + 160) |= v7;
  return (uint64_t)&a2[i + 2];
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t i;
  unint64_t v7;
  unint64_t v8;
  __int128 v10;
  unint64_t v11;

  if (a3 - a2 < 2 || a3 - 1 == a2)
    goto LABEL_15;
  for (i = 0; a2[i] != 46 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i)
      goto LABEL_15;
  }
  if (&a2[i] == a3)
LABEL_15:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  std::regex_traits<char>::__lookup_collatename<char *>(a1, a2, &a2[i], (uint64_t)&v10);
  if (*(char *)(a4 + 23) < 0)
    operator delete(*(void **)a4);
  *(_OWORD *)a4 = v10;
  v7 = v11;
  *(_QWORD *)(a4 + 16) = v11;
  v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a4 + 8);
  if (v8 - 1 >= 2)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  return (uint64_t)&a2[i + 2];
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  int v6;
  int v7;
  int v8;

  if (a2 == a3)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  v6 = (char)*a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119)
          return std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2, a3, (uint64_t *)a4);
        *(_DWORD *)(a5 + 160) |= 0x500u;
        std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](a5, 95);
        return a2 + 1;
      }
      v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (v6 == 98)
      {
        if (*(char *)(a4 + 23) < 0)
        {
          *(_QWORD *)(a4 + 8) = 1;
          a4 = *(_QWORD *)a4;
        }
        else
        {
          *(_BYTE *)(a4 + 23) = 1;
        }
        *(_WORD *)a4 = 8;
        return a2 + 1;
      }
      if (v6 != 100)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2, a3, (uint64_t *)a4);
      v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 160) = v8;
    return a2 + 1;
  }
  if (v6 <= 82)
  {
    if (!*a2)
    {
      if (*(char *)(a4 + 23) < 0)
      {
        *(_QWORD *)(a4 + 8) = 1;
        a4 = *(_QWORD *)a4;
      }
      else
      {
        *(_BYTE *)(a4 + 23) = 1;
      }
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 1) = 0;
      return a2 + 1;
    }
    if (v6 == 68)
    {
      v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_22:
      *(_DWORD *)(a5 + 164) = v7;
      return a2 + 1;
    }
    return std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2, a3, (uint64_t *)a4);
  }
  if (v6 == 83)
  {
    v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_22;
  }
  if (v6 != 87)
    return std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2, a3, (uint64_t *)a4);
  *(_DWORD *)(a5 + 164) |= 0x500u;
  std::__bracket_expression<char,std::regex_traits<char>>::__add_neg_char[abi:ne180100](a5, 95);
  return a2 + 1;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>(std::basic_regex<char> *a1, char *a2, char *a3, uint64_t *a4)
{
  int v5;
  std::basic_regex<char>::value_type v6;
  std::basic_regex<char>::value_type v7;
  std::basic_regex<char>::value_type v8;
  char *v9;
  char v10;
  int v11;
  std::basic_regex<char>::value_type v12;
  __int16 v13;

  if (a2 == a3)
LABEL_80:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  v5 = *a2;
  v6 = *a2;
  if (v5 > 97)
  {
    switch(*a2)
    {
      case 'n':
        if (!a4)
        {
          v7 = 10;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((_BYTE *)a4 + 23) = 1;
        }
        v13 = 10;
        goto LABEL_77;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_25;
      case 'r':
        if (!a4)
        {
          v7 = 13;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((_BYTE *)a4 + 23) = 1;
        }
        v13 = 13;
        goto LABEL_77;
      case 't':
        if (!a4)
        {
          v7 = 9;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((_BYTE *)a4 + 23) = 1;
        }
        v13 = 9;
        goto LABEL_77;
      case 'v':
        if (!a4)
        {
          v7 = 11;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((_BYTE *)a4 + 23) = 1;
        }
        v13 = 11;
        goto LABEL_77;
      default:
        if (v5 == 98)
        {
          if (a4)
          {
            if (*((char *)a4 + 23) < 0)
            {
              a4[1] = 1;
              a4 = (uint64_t *)*a4;
            }
            else
            {
              *((_BYTE *)a4 + 23) = 1;
            }
            v13 = 8;
            goto LABEL_77;
          }
          v7 = 8;
        }
        else
        {
          if (v5 != 102)
            goto LABEL_25;
          if (a4)
          {
            if (*((char *)a4 + 23) < 0)
            {
              a4[1] = 1;
              a4 = (uint64_t *)*a4;
            }
            else
            {
              *((_BYTE *)a4 + 23) = 1;
            }
            v13 = 12;
            goto LABEL_77;
          }
          v7 = 12;
        }
        break;
    }
LABEL_62:
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v7);
    return a2 + 1;
  }
  if (v5 > 91)
  {
    if (v5 == 92)
    {
LABEL_16:
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((_BYTE *)a4 + 23) = 1;
        }
        *(_BYTE *)a4 = v6;
        *((_BYTE *)a4 + 1) = 0;
        return a2 + 1;
      }
      v7 = *a2;
      goto LABEL_62;
    }
    if (v5 != 97)
      goto LABEL_25;
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((_BYTE *)a4 + 23) = 1;
      }
      v13 = 7;
LABEL_77:
      *(_WORD *)a4 = v13;
      return a2 + 1;
    }
    v7 = 7;
    goto LABEL_62;
  }
  if (v5 == 34 || v5 == 47)
    goto LABEL_16;
LABEL_25:
  if ((v6 & 0xF8) != 0x30)
    goto LABEL_80;
  v8 = v5 - 48;
  v9 = a2 + 1;
  if (a2 + 1 != a3)
  {
    if ((*v9 & 0xF8) != 0x30)
      goto LABEL_49;
    v8 = *v9 + 8 * v8 - 48;
    if (a2 + 2 != a3)
    {
      v10 = a2[2];
      v11 = v10 & 0xF8;
      v12 = v10 + 8 * v8 - 48;
      if (v11 == 48)
        v9 = a2 + 3;
      else
        v9 = a2 + 2;
      if (v11 == 48)
        v8 = v12;
      goto LABEL_49;
    }
  }
  v9 = a3;
LABEL_49:
  if (a4)
  {
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((_BYTE *)a4 + 23) = 1;
    }
    *(_BYTE *)a4 = v8;
    *((_BYTE *)a4 + 1) = 0;
  }
  else
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v8);
  }
  return v9;
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_range[abi:ne180100](uint64_t a1, char *a2, char *a3)
{
  char *v3;
  char *v4;
  unint64_t i;
  unint64_t v7;
  char *v8;
  char v9;
  char *v10;
  unint64_t j;
  unint64_t v12;
  char *v13;
  char v14;
  char *v15;
  uint64_t v16;
  unint64_t k;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t m;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  char v31;
  _BYTE *v32;
  char *v33;
  char v34;
  _BYTE *v35;
  void *v36[2];
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  void *v40[2];
  uint64_t v41;
  void *__p[2];
  uint64_t v43;

  v3 = a3;
  v4 = a2;
  if (*(_BYTE *)(a1 + 170))
  {
    if (*(_BYTE *)(a1 + 169))
    {
      for (i = 0; ; ++i)
      {
        v7 = v4[23] < 0 ? *((_QWORD *)v4 + 1) : v4[23];
        if (i >= v7)
          break;
        v8 = v4;
        if (v4[23] < 0)
          v8 = *(char **)v4;
        v9 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), v8[i]);
        v10 = v4;
        if (v4[23] < 0)
          v10 = *(char **)v4;
        v10[i] = v9;
      }
      for (j = 0; ; ++j)
      {
        v12 = v3[23] < 0 ? *((_QWORD *)v3 + 1) : v3[23];
        if (j >= v12)
          break;
        v13 = v3;
        if (v3[23] < 0)
          v13 = *(char **)v3;
        v14 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), v13[j]);
        v15 = v3;
        if (v3[23] < 0)
          v15 = *(char **)v3;
        v15[j] = v14;
      }
    }
    else
    {
      for (k = 0; ; ++k)
      {
        v18 = a2[23] < 0 ? *((_QWORD *)a2 + 1) : a2[23];
        if (k >= v18)
          break;
        v19 = a2;
        if (a2[23] < 0)
          v19 = *(char **)a2;
        v20 = a2;
        if (a2[23] < 0)
          v20 = *(char **)a2;
        v20[k] = v19[k];
      }
      for (m = 0; ; ++m)
      {
        v22 = a3[23] < 0 ? *((_QWORD *)a3 + 1) : a3[23];
        if (m >= v22)
          break;
        v23 = a3;
        if (a3[23] < 0)
          v23 = *(char **)a3;
        v24 = a3;
        if (a3[23] < 0)
          v24 = *(char **)a3;
        v24[m] = v23[m];
      }
    }
    if (v4[23] < 0)
    {
      v26 = v4;
      v4 = *(char **)v4;
      v25 = *((_QWORD *)v26 + 1);
    }
    else
    {
      v25 = v4[23];
    }
    std::regex_traits<char>::transform<char *>(a1 + 16, v4, &v4[v25]);
    if (v3[23] < 0)
    {
      v28 = v3;
      v3 = *(char **)v3;
      v27 = *((_QWORD *)v28 + 1);
    }
    else
    {
      v27 = v3[23];
    }
    std::regex_traits<char>::transform<char *>(a1 + 16, v3, &v3[v27]);
    *(_OWORD *)v40 = v38;
    v41 = v39;
    *(_OWORD *)__p = *(_OWORD *)v36;
    v43 = v37;
    std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100]((char **)(a1 + 88), (__int128 *)v40);
    if (SHIBYTE(v43) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v41) < 0)
      operator delete(v40[0]);
  }
  else
  {
    if (a2[23] < 0)
      v16 = *((_QWORD *)a2 + 1);
    else
      v16 = a2[23];
    if (v16 != 1 || (a3[23] < 0 ? (v29 = *((_QWORD *)a3 + 1)) : (v29 = a3[23]), v29 != 1))
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)9>();
    if (*(_BYTE *)(a1 + 169))
    {
      v30 = a2;
      if (a2[23] < 0)
        v30 = *(char **)a2;
      v31 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), *v30);
      v32 = v4;
      if (v4[23] < 0)
        v32 = *(_BYTE **)v4;
      *v32 = v31;
      v33 = v3;
      if (v3[23] < 0)
        v33 = *(char **)v3;
      v34 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), *v33);
      v35 = v3;
      if (v3[23] < 0)
        v35 = *(_BYTE **)v3;
      *v35 = v34;
    }
    *(_OWORD *)v40 = *(_OWORD *)v4;
    v41 = *((_QWORD *)v4 + 2);
    *((_QWORD *)v4 + 1) = 0;
    *((_QWORD *)v4 + 2) = 0;
    *(_QWORD *)v4 = 0;
    *(_OWORD *)__p = *(_OWORD *)v3;
    v43 = *((_QWORD *)v3 + 2);
    *(_QWORD *)v3 = 0;
    *((_QWORD *)v3 + 1) = 0;
    *((_QWORD *)v3 + 2) = 0;
    std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100]((char **)(a1 + 88), (__int128 *)v40);
    if (SHIBYTE(v43) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v41) < 0)
      operator delete(v40[0]);
  }
}

void sub_1CBD0B0F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  std::pair<std::string,std::string>::~pair((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v5;
  __int16 v6;
  unint64_t v7;
  __int16 v8;
  _WORD *v9;
  char **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  char *v25;
  _WORD *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  __int16 v39;
  char *v40;
  __int16 v41;

  if (!*(_BYTE *)(a1 + 169))
  {
    v18 = a1 + 128;
    v19 = *(_QWORD *)(a1 + 128);
    v10 = (char **)(a1 + 112);
    v8 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    v9 = *(_WORD **)(a1 + 120);
    if (*(_BYTE *)(a1 + 170))
    {
      if ((unint64_t)v9 < v19)
        goto LABEL_24;
      v20 = (char *)v9 - *v10;
      if (v20 > -3)
      {
        v21 = v20 >> 1;
        v22 = v19 - (_QWORD)*v10;
        if (v22 <= (v20 >> 1) + 1)
          v23 = v21 + 1;
        else
          v23 = v22;
        if (v22 >= 0x7FFFFFFFFFFFFFFELL)
          v24 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v24 = v23;
        if (v24)
          v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v18, v24);
        else
          v25 = 0;
        v27 = &v25[2 * v21];
        v28 = &v25[2 * v24];
        *(_WORD *)v27 = v8;
        v26 = v27 + 2;
        v38 = *(char **)(a1 + 112);
        v29 = *(char **)(a1 + 120);
        if (v29 == v38)
          goto LABEL_46;
        do
        {
          v39 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v39;
          v27 -= 2;
        }
        while (v29 != v38);
        goto LABEL_45;
      }
    }
    else
    {
      if ((unint64_t)v9 < v19)
        goto LABEL_24;
      v32 = (char *)v9 - *v10;
      if (v32 > -3)
      {
        v33 = v32 >> 1;
        v34 = v19 - (_QWORD)*v10;
        if (v34 <= (v32 >> 1) + 1)
          v35 = v33 + 1;
        else
          v35 = v34;
        if (v34 >= 0x7FFFFFFFFFFFFFFELL)
          v36 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v36 = v35;
        if (v36)
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v18, v36);
        else
          v37 = 0;
        v27 = &v37[2 * v33];
        v28 = &v37[2 * v36];
        *(_WORD *)v27 = v8;
        v26 = v27 + 2;
        v40 = *(char **)(a1 + 112);
        v29 = *(char **)(a1 + 120);
        if (v29 == v40)
          goto LABEL_46;
        do
        {
          v41 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v41;
          v27 -= 2;
        }
        while (v29 != v40);
        goto LABEL_45;
      }
    }
LABEL_49:
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), a2);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), a3);
  v7 = *(_QWORD *)(a1 + 128);
  v8 = v5 | (unsigned __int16)(v6 << 8);
  v9 = *(_WORD **)(a1 + 120);
  if ((unint64_t)v9 < v7)
  {
LABEL_24:
    *v9 = v8;
    v26 = v9 + 1;
    goto LABEL_48;
  }
  v10 = (char **)(a1 + 112);
  v11 = *(_QWORD *)(a1 + 112);
  v12 = (uint64_t)v9 - v11;
  if ((uint64_t)v9 - v11 <= -3)
    goto LABEL_49;
  v13 = v12 >> 1;
  v14 = v7 - v11;
  if (v14 <= (v12 >> 1) + 1)
    v15 = v13 + 1;
  else
    v15 = v14;
  if (v14 >= 0x7FFFFFFFFFFFFFFELL)
    v16 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v16 = v15;
  if (v16)
    v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(a1 + 128, v16);
  else
    v17 = 0;
  v27 = &v17[2 * v13];
  v28 = &v17[2 * v16];
  *(_WORD *)v27 = v8;
  v26 = v27 + 2;
  v30 = *(char **)(a1 + 112);
  v29 = *(char **)(a1 + 120);
  if (v29 == v30)
    goto LABEL_46;
  do
  {
    v31 = *((_WORD *)v29 - 1);
    v29 -= 2;
    *((_WORD *)v27 - 1) = v31;
    v27 -= 2;
  }
  while (v29 != v30);
LABEL_45:
  v29 = *v10;
LABEL_46:
  *(_QWORD *)(a1 + 112) = v27;
  *(_QWORD *)(a1 + 120) = v26;
  *(_QWORD *)(a1 + 128) = v28;
  if (v29)
    operator delete(v29);
LABEL_48:
  *(_QWORD *)(a1 + 120) = v26;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 1);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0B39C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__bracket_expression<char,std::regex_traits<char>>::__add_equivalence[abi:ne180100](uint64_t *a1, __int128 *a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t result;

  v3 = a1 + 17;
  v4 = a1[18];
  if (v4 >= a1[19])
  {
    result = std::vector<std::string>::__push_back_slow_path<std::string const&>(v3, a2);
  }
  else
  {
    std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)v3, a2);
    result = v4 + 24;
  }
  a1[18] = result;
  return result;
}

void std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  __int128 v4;

  v3 = *(_QWORD *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*(std::string **)(a1 + 8), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    *(_QWORD *)(v3 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v3 = v4;
  }
  *(_QWORD *)(a1 + 8) = v3 + 24;
}

void sub_1CBD0B444(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)2>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 2);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0B484(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::regex_traits<char>::__lookup_classname<char const*>(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  unint64_t v6;
  void **v7;
  void **v8;
  uint64_t classname;
  void *__p[2];
  unsigned __int8 v12;

  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  v6 = v12;
  if ((v12 & 0x80u) == 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  if ((v12 & 0x80u) != 0)
    v6 = (unint64_t)__p[1];
  (*(void (**)(_QWORD, void **, char *))(**(_QWORD **)(a1 + 8) + 48))(*(_QWORD *)(a1 + 8), v7, (char *)v7 + v6);
  if ((v12 & 0x80u) == 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  classname = std::__get_classname((const char *)v8, a4);
  if ((char)v12 < 0)
    operator delete(__p[0]);
  return classname;
}

void sub_1CBD0B534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_neg_char[abi:ne180100](uint64_t a1, uint64_t a2)
{
  char v2;
  unint64_t v4;
  _BYTE *v5;
  unint64_t *v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  _BYTE *v22;
  char v23;
  unint64_t v24;
  _BYTE *v25;
  unint64_t v26;
  unint64_t v27;
  size_t v28;
  _BYTE *v29;
  char v30;
  _BYTE *v31;
  char v32;

  v2 = a2;
  if (*(_BYTE *)(a1 + 169))
  {
    v2 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), a2);
    v5 = *(_BYTE **)(a1 + 72);
    v4 = *(_QWORD *)(a1 + 80);
    if ((unint64_t)v5 >= v4)
    {
      v6 = (unint64_t *)(a1 + 64);
      v7 = *(_QWORD *)(a1 + 64);
      v8 = &v5[-v7];
      v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        v10 = v4 - v7;
        if (2 * v10 > v9)
          v9 = 2 * v10;
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
          v11 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v11 = v9;
        if (v11)
          v12 = operator new(v11);
        else
          v12 = 0;
        v20 = &v8[(_QWORD)v12];
        v21 = (char *)v12 + v11;
        v8[(_QWORD)v12] = v2;
        v19 = (uint64_t)&v8[(_QWORD)v12 + 1];
        if (v5 != (_BYTE *)v7)
        {
          v22 = &v5[~v7];
          do
          {
            v23 = *--v5;
            (v22--)[(_QWORD)v12] = v23;
          }
          while (v5 != (_BYTE *)v7);
LABEL_45:
          v5 = (_BYTE *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    goto LABEL_22;
  }
  v6 = (unint64_t *)(a1 + 64);
  v5 = *(_BYTE **)(a1 + 72);
  v13 = *(_QWORD *)(a1 + 80);
  if (!*(_BYTE *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      v24 = *v6;
      v25 = &v5[-*v6];
      v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        v27 = v13 - v24;
        if (2 * v27 > v26)
          v26 = 2 * v27;
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL)
          v28 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
          v12 = operator new(v28);
        else
          v12 = 0;
        v20 = &v25[(_QWORD)v12];
        v21 = (char *)v12 + v28;
        v25[(_QWORD)v12] = v2;
        v19 = (uint64_t)&v25[(_QWORD)v12 + 1];
        if (v5 != (_BYTE *)v24)
        {
          v31 = &v5[~v24];
          do
          {
            v32 = *--v5;
            (v31--)[(_QWORD)v12] = v32;
          }
          while (v5 != (_BYTE *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    *v5 = v2;
    v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13)
    goto LABEL_22;
  v14 = *v6;
  v15 = &v5[-*v6];
  v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0)
    goto LABEL_50;
  v17 = v13 - v14;
  if (2 * v17 > v16)
    v16 = 2 * v17;
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL)
    v18 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v18 = v16;
  if (v18)
    v12 = operator new(v18);
  else
    v12 = 0;
  v20 = &v15[(_QWORD)v12];
  v21 = (char *)v12 + v18;
  v15[(_QWORD)v12] = v2;
  v19 = (uint64_t)&v15[(_QWORD)v12 + 1];
  if (v5 != (_BYTE *)v14)
  {
    v29 = &v5[~v14];
    do
    {
      v30 = *--v5;
      (v29--)[(_QWORD)v12] = v30;
    }
    while (v5 != (_BYTE *)v14);
    goto LABEL_45;
  }
LABEL_46:
  v12 = v20;
LABEL_47:
  *(_QWORD *)(a1 + 64) = v12;
  *(_QWORD *)(a1 + 72) = v19;
  *(_QWORD *)(a1 + 80) = v21;
  if (v5)
    operator delete(v5);
LABEL_49:
  *(_QWORD *)(a1 + 72) = v19;
}

void std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  std::allocator<std::pair<std::string, std::string>> *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  char *v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  int64x2_t v24;
  std::pair<std::string, std::string> *v25;
  std::__split_buffer<std::pair<std::string, std::string>> v26;

  v6 = (unint64_t)a1[2];
  v4 = (std::allocator<std::pair<std::string, std::string>> *)(a1 + 2);
  v5 = v6;
  v7 = *((_QWORD *)v4 - 1);
  if (v7 >= v6)
  {
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (_QWORD)*a1) >> 4);
    v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (_QWORD)*a1) >> 4);
    if (2 * v13 > v12)
      v12 = 2 * v13;
    if (v13 >= 0x2AAAAAAAAAAAAAALL)
      v14 = 0x555555555555555;
    else
      v14 = v12;
    v26.__end_cap_.__value_ = v4;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[48 * v11];
    v17 = *a2;
    *((_QWORD *)v16 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v16 = v17;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v18 = *(__int128 *)((char *)a2 + 24);
    *((_QWORD *)v16 + 5) = *((_QWORD *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    v20 = *a1;
    v19 = (unint64_t)a1[1];
    if ((char *)v19 == *a1)
    {
      v24 = vdupq_n_s64(v19);
      v21 = &v15[48 * v11];
    }
    else
    {
      v21 = &v15[48 * v11];
      do
      {
        v22 = *(_OWORD *)(v19 - 48);
        *((_QWORD *)v21 - 4) = *(_QWORD *)(v19 - 32);
        *((_OWORD *)v21 - 3) = v22;
        *(_QWORD *)(v19 - 40) = 0;
        *(_QWORD *)(v19 - 32) = 0;
        *(_QWORD *)(v19 - 48) = 0;
        v23 = *(_OWORD *)(v19 - 24);
        *((_QWORD *)v21 - 1) = *(_QWORD *)(v19 - 8);
        *(_OWORD *)(v21 - 24) = v23;
        v21 -= 48;
        *(_QWORD *)(v19 - 16) = 0;
        *(_QWORD *)(v19 - 8) = 0;
        *(_QWORD *)(v19 - 24) = 0;
        v19 -= 48;
      }
      while ((char *)v19 != v20);
      v24 = *(int64x2_t *)a1;
    }
    v10 = v16 + 48;
    *a1 = v21;
    a1[1] = v16 + 48;
    *(int64x2_t *)&v26.__begin_ = v24;
    v25 = (std::pair<std::string, std::string> *)a1[2];
    a1[2] = &v15[48 * v14];
    v26.__end_cap_.__value_ = v25;
    v26.__first_ = (std::__split_buffer<std::pair<std::string, std::string>>::pointer)v24.i64[0];
    std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(&v26);
  }
  else
  {
    v8 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v8;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v9 = *(__int128 *)((char *)a2 + 24);
    *(_QWORD *)(v7 + 40) = *((_QWORD *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    v10 = (char *)(v7 + 48);
  }
  a1[1] = v10;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)9>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 9);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0B968(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(std::__split_buffer<std::pair<std::string, std::string>> *this)
{
  std::__split_buffer<std::pair<std::string, std::string>>::pointer i;
  std::__split_buffer<std::pair<std::string, std::string>>::pointer begin;

  begin = this->__begin_;
  for (i = this->__end_; i != begin; i = this->__end_)
  {
    this->__end_ = i - 1;
    std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>((uint64_t)&i[-1]);
  }
  if (this->__first_)
    operator delete(this->__first_);
}

void (__cdecl ***std::__begin_marked_subexpression<char>::~__begin_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__begin_marked_subexpression<char>::~__begin_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__begin_marked_subexpression<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(_QWORD *)(*(_QWORD *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(result + 8);
  return result;
}

void (__cdecl ***std::__end_marked_subexpression<char>::~__end_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__end_marked_subexpression<char>::~__end_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__end_marked_subexpression<char>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)a2 = -994;
  v2 = *(_QWORD *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(_QWORD *)(v2 + 8) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(v2 + 16) = 1;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(result + 8);
  return result;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_loop(std::basic_regex<char> *this, size_t __min, size_t __max, std::__owns_one_state<char> *__s, size_t __mexp_begin, size_t __mexp_end, BOOL __greedy)
{
  int v8;
  int v9;
  _QWORD *v14;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;
  uint64_t v17;
  unsigned int loop_count;
  std::__node<char> *v19;
  std::__node<char> *v20;

  v8 = __mexp_end;
  v9 = __mexp_begin;
  v14 = (_QWORD *)operator new();
  end = this->__end_;
  first = end->__first_;
  v14[1] = first;
  end->__first_ = 0;
  v17 = operator new();
  loop_count = this->__loop_count_;
  v19 = __s->__first_;
  *(_QWORD *)v17 = &unk_1E8750A90;
  *(_QWORD *)(v17 + 8) = v19;
  *(_QWORD *)(v17 + 16) = v14;
  *(_QWORD *)(v17 + 24) = __min;
  *(_QWORD *)(v17 + 32) = __max;
  *(_DWORD *)(v17 + 40) = loop_count;
  *(_DWORD *)(v17 + 44) = v9;
  *(_DWORD *)(v17 + 48) = v8;
  *(_BYTE *)(v17 + 52) = __greedy;
  __s->__first_ = 0;
  v20 = (std::__node<char> *)operator new();
  v20->__vftable = (std::__node<char>_vtbl *)&unk_1E87503C0;
  v20[1].__vftable = (std::__node<char>_vtbl *)v17;
  this->__end_->__first_ = v20;
  this->__end_ = *(std::__owns_one_state<char> **)(v17 + 16);
  __s->__first_ = (std::__node<char> *)v17;
  ++this->__loop_count_;
}

void sub_1CBD0BC80(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  int v4;
  int v5;
  int v6;

  if (a2 != a3)
  {
    v4 = *a2;
    if ((v4 & 0xF8) == 0x30 || (v4 & 0xFE) == 0x38)
    {
      v5 = v4 - 48;
      *a4 = v5;
      if (++a2 == a3)
      {
        return a3;
      }
      else
      {
        while (1)
        {
          v6 = *a2;
          if ((v6 & 0xF8) != 0x30 && (v6 & 0xFE) != 0x38)
            break;
          if (v5 >= 214748364)
            std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
          v5 = v6 + 10 * v5 - 48;
          *a4 = v5;
          if (++a2 == a3)
            return a3;
        }
      }
    }
  }
  return a2;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 8);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0BD7C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 7);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0BDC8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void (__cdecl ***std::__loop<char>::~__loop(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750390;
  v2 = a1[2];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  return a1;
}

void std::__loop<char>::~__loop(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750390;
  v2 = a1[2];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  JUMPOUT(0x1D17A53D0);
}

unsigned int *std::__loop<char>::__exec(unsigned int *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _BOOL4 v8;
  uint64_t v10;

  v2 = result[10];
  v3 = a2[7];
  v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    v5 = *v4 + 1;
    *v4 = v5;
    v6 = *((_QWORD *)result + 3);
    v7 = *((_QWORD *)result + 4);
    v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      v10 = *(_QWORD *)(v3 + 16 * v2 + 8);
      v8 = v5 < v7 && v10 != a2[2];
    }
    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8)
        goto LABEL_25;
LABEL_22:
      a2[10] = *((_QWORD *)result + 1);
      return std::__loop<char>::__init_repeat[abi:ne180100](result, a2);
    }
    goto LABEL_23;
  }
  *v4 = 0;
  if (*((_QWORD *)result + 4))
  {
    if (*((_QWORD *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }
LABEL_23:
    *(_DWORD *)a2 = -992;
    return result;
  }
  *(_DWORD *)a2 = -994;
LABEL_25:
  a2[10] = *((_QWORD *)result + 2);
  return result;
}

unsigned int *std::__loop<char>::__exec_split(unsigned int *result, int a2, _QWORD *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((_QWORD *)result + 2);
  }
  else
  {
    a3[10] = *((_QWORD *)result + 1);
    return std::__loop<char>::__init_repeat[abi:ne180100](result, a3);
  }
  return result;
}

void (__cdecl ***std::__owns_two_states<char>::~__owns_two_states(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750390;
  v2 = a1[2];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  return a1;
}

void std::__owns_two_states<char>::~__owns_two_states(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750390;
  v2 = a1[2];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  JUMPOUT(0x1D17A53D0);
}

unsigned int *std::__loop<char>::__init_repeat[abi:ne180100](unsigned int *result, _QWORD *a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = result[11];
  *(_QWORD *)(a2[7] + 16 * result[10] + 8) = a2[2];
  v3 = result[12];
  if (v2 != v3)
  {
    v4 = v2 - 1;
    v5 = a2[3];
    v6 = v3 - 1 - v4;
    v7 = a2[4] + 24 * v4 + 8;
    do
    {
      *(_QWORD *)(v7 - 8) = v5;
      *(_QWORD *)v7 = v5;
      *(_BYTE *)(v7 + 8) = 0;
      v7 += 24;
      --v6;
    }
    while (v6);
  }
  return result;
}

void std::__repeat_one_loop<char>::~__repeat_one_loop()
{
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__repeat_one_loop<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(result + 8);
  return result;
}

void (__cdecl ***std::__alternate<char>::~__alternate(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750390;
  v2 = a1[2];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  return a1;
}

void std::__alternate<char>::~__alternate(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1E8750390;
  v2 = a1[2];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  JUMPOUT(0x1D17A53D0);
}

void std::__alternate<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t std::__alternate<char>::__exec_split(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;

  *(_DWORD *)a3 = -994;
  v3 = 8;
  if (a2)
    v3 = 16;
  *(_QWORD *)(a3 + 80) = *(_QWORD *)(result + v3);
  return result;
}

void std::__empty_non_own_state<char>::~__empty_non_own_state()
{
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__empty_non_own_state<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(result + 8);
  return result;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D17A519C](exception, 15);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1CBD0C274(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  std::__owns_one_state<char> *end;
  unsigned int marked_count;
  unsigned __int8 *v8;

  if (a2 == a3)
    return (unsigned __int8 *)a2;
  end = a1->__end_;
  marked_count = a1->__marked_count_;
  v8 = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(a1, a2, a3);
  if (v8 == (unsigned __int8 *)a2)
    return (unsigned __int8 *)a2;
  else
    return std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>(a1, v8, (unsigned __int8 *)a3, end, marked_count + 1, a1->__marked_count_ + 1);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  char *v6;
  char *v7;
  int v8;
  uint64_t v9;
  unsigned int marked_count;
  char *v11;
  _BOOL4 v13;
  uint64_t v14;

  v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_RE<char const*>(a1, a2, a3);
  v7 = v6;
  if (v6 == a2 && v6 != a3)
  {
    if (a2 + 1 == a3 || *a2 != 92)
    {
      return a2;
    }
    else
    {
      v8 = a2[1];
      if (v8 == 40)
      {
        v9 = (uint64_t)(a2 + 2);
        std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(a1);
        marked_count = a1->__marked_count_;
        do
        {
          v11 = (char *)v9;
          v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(a1, v9, a3);
        }
        while ((char *)v9 != v11);
        if (v11 == a3 || v11 + 1 == a3 || *v11 != 92 || v11[1] != 41)
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
        v7 = v11 + 2;
        std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(a1, marked_count);
      }
      else
      {
        v13 = std::basic_regex<char,std::regex_traits<char>>::__test_back_ref(a1, v8);
        v14 = 2;
        if (!v13)
          v14 = 0;
        return &a2[v14];
      }
    }
  }
  return v7;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>(std::basic_regex<char> *this, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t __mexp_begin, size_t __mexp_end)
{
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned int v8;
  int v11;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 *v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  std::basic_regex<char> *v22;
  int v24;
  int v25;

  v6 = a2;
  if (a2 != a3)
  {
    v7 = __mexp_end;
    v8 = __mexp_begin;
    v11 = *a2;
    if (v11 == 42)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_loop(this, 0, 0xFFFFFFFFFFFFFFFFLL, __s, __mexp_begin, __mexp_end, 1);
      return ++v6;
    }
    if (a2 + 1 != a3 && v11 == 92 && a2[1] == 123)
    {
      v13 = a2 + 2;
      v25 = 0;
      v14 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>((uint64_t)this, a2 + 2, a3, &v25);
      if (v14 == v13)
        goto LABEL_16;
      if (v14 != a3)
      {
        v15 = v14 + 1;
        v16 = *v14;
        if (v16 == 44)
        {
          v24 = -1;
          v17 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>((uint64_t)this, v15, a3, &v24);
          if (v17 != a3 && v17 + 1 != a3 && *v17 == 92 && v17[1] == 125)
          {
            v19 = v24;
            v18 = v25;
            if (v24 == -1)
            {
              v19 = -1;
            }
            else if (v24 < v25)
            {
LABEL_16:
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
            }
            v6 = &v17[2 * (v17[1] == 125)];
            v20 = v8;
            v21 = v7;
            v22 = this;
LABEL_23:
            std::basic_regex<char,std::regex_traits<char>>::__push_loop(v22, v18, v19, __s, v20, v21, 1);
            return v6;
          }
        }
        else if (v15 != a3 && v16 == 92 && *v15 == 125)
        {
          v6 = v14 + 2;
          v18 = v25;
          v20 = v8;
          v21 = v7;
          v22 = this;
          v19 = v25;
          goto LABEL_23;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
  }
  return v6;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_RE<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  int v6;
  char *result;
  std::__node<char> *v9;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;

  if (a2 == a3)
  {
    result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<char const*>(this, a2, a3);
    if (result != a2)
      return result;
    return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, a2, a3);
  }
  v6 = *a2;
  if ((a2 + 1 != a3 || v6 != 36)
    && ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0))
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(this, v6);
    return a2 + 1;
  }
  result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<char const*>(this, a2, a3);
  if (result != a2)
    return result;
  if (*a2 != 46)
    return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, a2, a3);
  v9 = (std::__node<char> *)operator new();
  end = this->__end_;
  first = end->__first_;
  v9->__vftable = (std::__node<char>_vtbl *)&unk_1E8750270;
  v9[1].__vftable = (std::__node<char>_vtbl *)first;
  end->__first_ = v9;
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
  return a2 + 1;
}

_BYTE *std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<char const*>(std::basic_regex<char> *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3;
  int v4;

  v3 = a2;
  if (a2 != a3 && a2 + 1 != a3 && *a2 == 92)
  {
    v4 = (char)a2[1];
    if ((v4 - 36) <= 0x3A && ((1 << (a2[1] - 36)) & 0x580000000000441) != 0)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v4);
      v3 += 2;
    }
  }
  return v3;
}

void (__cdecl ***std::__match_any<char>::~__match_any(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__match_any<char>::~__match_any(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1D17A53D0);
}

uint64_t std::__match_any<char>::__exec(uint64_t result, uint64_t a2)
{
  _BYTE *v2;
  uint64_t v3;

  v2 = *(_BYTE **)(a2 + 16);
  if (v2 == *(_BYTE **)(a2 + 24) || !*v2)
  {
    v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(_QWORD *)(a2 + 16) = v2 + 1;
    v3 = *(_QWORD *)(result + 8);
  }
  *(_QWORD *)(a2 + 80) = v3;
  return result;
}

BOOL std::basic_regex<char,std::regex_traits<char>>::__test_back_ref(std::basic_regex<char> *this, char a2)
{
  if ((a2 & 0xF8) != 0x30 && (a2 & 0xFE) != 0x38 || a2 - 49 > 8)
    return 0;
  if (a2 - 48 > this->__marked_count_)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(this, a2 - 48);
  return 1;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(uint64_t a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;

  v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  do
  {
    v7 = v6;
    v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(a1, (std::basic_regex<char> *)v6, a3);
  }
  while (v6 != v7);
  return v7;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(uint64_t a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  std::__owns_one_state<char> *v6;
  int v7;
  char *v8;
  unsigned __int8 *v9;
  int locale_low;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  unsigned int v16;
  std::basic_regex<char> *v17;
  std::basic_regex<char> *v18;

  v6 = *(std::__owns_one_state<char> **)(a1 + 56);
  v7 = *(_DWORD *)(a1 + 28);
  v8 = std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_ERE<char const*>((std::basic_regex<char> *)a1, a2, a3);
  v9 = (unsigned __int8 *)v8;
  if (v8 != (char *)a2 || v8 == (char *)a3)
    goto LABEL_12;
  locale_low = SLOBYTE(a2->__traits_.__loc_.__locale_);
  switch(locale_low)
  {
    case '$':
      v11 = operator new();
      v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      v13 = *(_QWORD *)(a1 + 56);
      goto LABEL_8;
    case '(':
      std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression((std::basic_regex<char> *)a1);
      v16 = *(_DWORD *)(a1 + 28);
      ++*(_DWORD *)(a1 + 36);
      v17 = (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, (char *)&a2->__traits_.__loc_.__locale_ + 1, a3);
      if (v17 == a3 || (v18 = v17, LOBYTE(v17->__traits_.__loc_.__locale_) != 41))
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
      std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression((std::basic_regex<char> *)a1, v16);
      --*(_DWORD *)(a1 + 36);
      v9 = (unsigned __int8 *)&v18->__traits_.__loc_.__locale_ + 1;
LABEL_12:
      if (v9 != (unsigned __int8 *)a2)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(a1, v9, (unsigned __int8 *)a3, v6, (v7 + 1), (*(_DWORD *)(a1 + 28) + 1));
      return (unsigned __int8 *)a2;
    case '^':
      v11 = operator new();
      v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      v13 = *(_QWORD *)(a1 + 56);
LABEL_8:
      v15 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)v11 = v14 + 16;
      *(_QWORD *)(v11 + 8) = v15;
      *(_BYTE *)(v11 + 16) = v12;
      *(_QWORD *)(v13 + 8) = v11;
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      v9 = (unsigned __int8 *)&a2->__traits_.__loc_.__locale_ + 1;
      return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(a1, v9, (unsigned __int8 *)a3, v6, (v7 + 1), (*(_DWORD *)(a1 + 28) + 1));
  }
  return (unsigned __int8 *)a2;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_ERE<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  char *result;
  std::__node<char> *v7;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;

  result = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ORD_CHAR_ERE<char const*>(a1, a2, a3);
  if (result == (char *)a2)
  {
    result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR_ERE<char const*>((uint64_t)a1, a2, a3);
    if (result == (char *)a2)
    {
      if (a2 == a3 || LOBYTE(a2->__traits_.__loc_.__locale_) != 46)
      {
        return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)a1, (char *)a2, (char *)a3);
      }
      else
      {
        v7 = (std::__node<char> *)operator new();
        end = a1->__end_;
        first = end->__first_;
        v7->__vftable = (std::__node<char>_vtbl *)&unk_1E8750270;
        v7[1].__vftable = (std::__node<char>_vtbl *)first;
        end->__first_ = v7;
        a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
        return (char *)&a2->__traits_.__loc_.__locale_ + 1;
      }
    }
  }
  return result;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_ORD_CHAR_ERE<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *this, std::basic_regex<char> *a3)
{
  std::basic_regex<char> *v3;
  int locale_low;
  uint64_t v5;

  v3 = this;
  if (this != a3)
  {
    locale_low = SLOBYTE(this->__traits_.__loc_.__locale_);
    v5 = (locale_low - 36);
    if (v5 > 0x3A)
      goto LABEL_8;
    if (((1 << (locale_low - 36)) & 0x5800000080004D1) != 0)
      return v3;
    if (v5 == 5)
    {
      if (a1->__open_count_)
        return v3;
    }
    else
    {
LABEL_8:
      if ((locale_low - 123) < 2)
        return v3;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, (std::basic_regex<char>::value_type)this->__traits_.__loc_.__locale_);
    return (std::basic_regex<char> *)((char *)v3 + 1);
  }
  return v3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR_ERE<char const*>(uint64_t a1, std::basic_regex<char> *this, std::basic_regex<char> *a3)
{
  std::basic_regex<char> *v3;
  char *v4;
  int v5;
  std::basic_regex<char>::value_type v6;
  BOOL v7;
  _BOOL4 v9;
  uint64_t v10;

  v3 = this;
  if (this == a3)
    return (char *)v3;
  v4 = (char *)&this->__traits_.__loc_.__locale_ + 1;
  if ((std::basic_regex<char> *)((char *)&v3->__traits_.__loc_.__locale_ + 1) == a3
    || LOBYTE(v3->__traits_.__loc_.__locale_) != 92)
  {
    return (char *)v3;
  }
  v5 = *v4;
  v6 = *v4;
  v7 = (v5 - 36) > 0x3A || ((1 << (*v4 - 36)) & 0x5800000080004F1) == 0;
  if (!v7 || (v5 - 123) < 3)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char((std::basic_regex<char> *)a1, v6);
    return (char *)v3 + 2;
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1F0) != 0x40)
  {
    v9 = std::basic_regex<char,std::regex_traits<char>>::__test_back_ref((std::basic_regex<char> *)a1, v6);
    v10 = 2;
    if (!v9)
      v10 = 0;
    return (char *)v3 + v10;
  }
  return std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v4, (char *)a3, 0);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(uint64_t a1, char *__f, char *__l, std::match_results<const char *> *this, int a5)
{
  int v9;
  std::match_results<const char *>::value_type *p_unmatched;
  const char *first;
  const char *second;
  uint64_t result;
  int v14;
  const char *v15;
  int v16;
  std::vector<std::csub_match>::pointer end;
  std::vector<std::csub_match>::pointer begin;

  if ((a5 & 0x80) != 0)
    v9 = a5 & 0xFFA;
  else
    v9 = a5;
  std::match_results<char const*>::__init(this, *(_DWORD *)(a1 + 28) + 1, __f, __l, (unsigned __int16)(v9 & 0x800) >> 11);
  if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(a1, __f, __l, (uint64_t *)this, v9, (v9 & 0x800) == 0))
  {
    if (this->__matches_.__end_ == this->__matches_.__begin_)
      p_unmatched = &this->__unmatched_;
    else
      p_unmatched = this->__matches_.__begin_;
LABEL_8:
    first = p_unmatched->first;
    this->__prefix_.second = p_unmatched->first;
    this->__prefix_.matched = this->__prefix_.first != first;
    second = p_unmatched->second;
    this->__suffix_.first = second;
    this->__suffix_.matched = second != this->__suffix_.second;
    return 1;
  }
  if (__f != __l && (v9 & 0x40) == 0)
  {
    v14 = v9 | 0x80;
    v15 = __f + 1;
    if (v15 != __l)
    {
      while (1)
      {
        std::vector<std::sub_match<char const*>>::assign(&this->__matches_, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__matches_.__end_ - (char *)this->__matches_.__begin_) >> 3), &this->__unmatched_);
        v16 = std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(a1, v15, __l, (uint64_t *)this, v14, 0);
        begin = this->__matches_.__begin_;
        end = this->__matches_.__end_;
        if (v16)
          break;
        std::vector<std::sub_match<char const*>>::assign(&this->__matches_, 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3), &this->__unmatched_);
        if (++v15 == __l)
          goto LABEL_14;
      }
      if (end == begin)
        p_unmatched = &this->__unmatched_;
      else
        p_unmatched = this->__matches_.__begin_;
      goto LABEL_8;
    }
LABEL_14:
    std::vector<std::sub_match<char const*>>::assign(&this->__matches_, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__matches_.__end_ - (char *)this->__matches_.__begin_) >> 3), &this->__unmatched_);
    if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(a1, __l, __l, (uint64_t *)this, v14, 0))
    {
      if (this->__matches_.__end_ == this->__matches_.__begin_)
        p_unmatched = &this->__unmatched_;
      else
        p_unmatched = this->__matches_.__begin_;
      goto LABEL_8;
    }
  }
  result = 0;
  this->__matches_.__end_ = this->__matches_.__begin_;
  return result;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  if ((*(_WORD *)(a1 + 24) & 0x1F0) == 0)
    return std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, a2, a3, a4, a5, a6);
  if (*(_DWORD *)(a1 + 28))
    return std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, a2, a3, a4, a5, a6);
  return std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  uint64_t v6;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  BOOL v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  void **v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  _QWORD *v44;
  __int128 v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  _BYTE v57[40];
  __int128 v58;
  void *__p[2];
  _QWORD v60[3];
  __int128 v61;
  __int128 v62;
  __int128 v63;

  v62 = 0u;
  v63 = 0u;
  v61 = 0u;
  v6 = *(_QWORD *)(a1 + 40);
  if (v6)
  {
    *(_DWORD *)v57 = 0;
    memset(&v57[8], 0, 32);
    v58 = 0uLL;
    *(_OWORD *)__p = 0uLL;
    memset(v60, 0, 21);
    std::deque<std::__state<char>>::push_back(&v61, (uint64_t)v57);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v51 = a4;
    if (*(_QWORD *)&v57[32])
    {
      *(_QWORD *)&v58 = *(_QWORD *)&v57[32];
      operator delete(*(void **)&v57[32]);
    }
    v12 = *((_QWORD *)&v61 + 1);
    v13 = *((_QWORD *)&v63 + 1) + v63 - 1;
    v14 = v13 / 0x2A;
    v15 = *(_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * (v13 / 0x2A));
    v16 = 3 * (v13 % 0x2A);
    v17 = v15 + 32 * v16;
    *(_DWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = a2;
    *(_QWORD *)(*(_QWORD *)(v12 + 8 * v14) + 32 * v16 + 16) = a2;
    *(_QWORD *)(*(_QWORD *)(v12 + 8 * v14) + 32 * v16 + 24) = a3;
    std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)(*(_QWORD *)(v12 + 8 * v14) + 32 * v16 + 56), *(unsigned int *)(a1 + 32));
    v55 = 0;
    v18 = 0;
    v53 = 0;
    v54 = a2;
    v19 = *((_QWORD *)&v63 + 1);
    v20 = *((_QWORD *)&v61 + 1);
    v21 = *((_QWORD *)&v63 + 1) + v63 - 1;
    v22 = v21 / 0x2A;
    v23 = 3 * (v21 % 0x2A);
    *(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * v22) + 32 * v23 + 80) = v6;
    v24 = *(_QWORD *)(v20 + 8 * v22) + 32 * v23;
    v25 = a3 - a2;
    *(_DWORD *)(v24 + 88) = a5;
    *(_BYTE *)(v24 + 92) = a6;
    v52 = a3;
    while (2)
    {
      if ((++v18 & 0xFFF) == 0 && (int)(v18 >> 12) >= (int)v25)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
      v27 = v19 + v63 - 1;
      v28 = *(_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * (v27 / 0x2A));
      v29 = v27 % 0x2A;
      v30 = v28 + 96 * (v27 % 0x2A);
      v32 = (_QWORD *)(v30 + 80);
      v31 = *(_QWORD *)(v30 + 80);
      if (v31)
        (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v31 + 16))(v31, v28 + 96 * v29);
      switch(*(_DWORD *)v30)
      {
        case 0xFFFFFC18:
          v33 = *(_QWORD *)(v28 + 96 * v29 + 16);
          v35 = (a5 & 0x1000) == 0 || v33 == v52;
          v36 = v33 != v54 || (a5 & 0x20) == 0;
          if (!v36 || !v35)
            goto LABEL_37;
          v37 = v33 - *(_QWORD *)(v28 + 96 * v29 + 8);
          v38 = v53;
          if ((v55 & (v53 >= v37)) == 0)
            v38 = v37;
          if (v38 != v25)
          {
            v53 = v38;
            std::deque<std::__state<char>>::pop_back(&v61);
            v55 = 1;
            goto LABEL_38;
          }
          v39 = (void **)*((_QWORD *)&v61 + 1);
          v40 = v62;
          if ((_QWORD)v62 == *((_QWORD *)&v61 + 1))
          {
            v40 = *((_QWORD *)&v61 + 1);
          }
          else
          {
            v41 = (_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * ((unint64_t)v63 / 0x2A));
            v42 = (_QWORD *)(*v41 + 96 * ((unint64_t)v63 % 0x2A));
            v43 = *(_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * ((*((_QWORD *)&v63 + 1) + (_QWORD)v63) / 0x2AuLL))
                + 96 * ((*((_QWORD *)&v63 + 1) + (_QWORD)v63) % 0x2AuLL);
            if (v42 != (_QWORD *)v43)
            {
              do
              {
                std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v42);
                v42 += 12;
                if ((_QWORD *)((char *)v42 - *v41) == (_QWORD *)4032)
                {
                  v44 = (_QWORD *)v41[1];
                  ++v41;
                  v42 = v44;
                }
              }
              while (v42 != (_QWORD *)v43);
              v39 = (void **)*((_QWORD *)&v61 + 1);
              v40 = v62;
            }
          }
          *((_QWORD *)&v63 + 1) = 0;
          v47 = v40 - (_QWORD)v39;
          if (v47 >= 0x11)
          {
            do
            {
              operator delete(*v39);
              v39 = (void **)(*((_QWORD *)&v61 + 1) + 8);
              *((_QWORD *)&v61 + 1) = v39;
              v47 = v62 - (_QWORD)v39;
            }
            while ((_QWORD)v62 - (_QWORD)v39 > 0x10uLL);
          }
          if (v47 >> 3 == 1)
          {
            v48 = 21;
          }
          else
          {
            if (v47 >> 3 != 2)
              goto LABEL_53;
            v48 = 42;
          }
          *(_QWORD *)&v63 = v48;
LABEL_53:
          v55 = 1;
          v53 = v25;
LABEL_38:
          v19 = *((_QWORD *)&v63 + 1);
          if (*((_QWORD *)&v63 + 1))
            continue;
          if ((v55 & 1) != 0)
          {
            v49 = *v51;
            *(_QWORD *)v49 = v54;
            *(_QWORD *)(v49 + 8) = v54 + v53;
            v6 = 1;
            *(_BYTE *)(v49 + 16) = 1;
          }
          else
          {
            v6 = 0;
          }
          break;
        case 0xFFFFFC19:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_38;
        case 0xFFFFFC1D:
          std::deque<std::__state<char>>::push_front((uint64_t)&v61, v28 + 96 * v29);
          goto LABEL_37;
        case 0xFFFFFC1F:
LABEL_37:
          std::deque<std::__state<char>>::pop_back(&v61);
          goto LABEL_38;
        case 0xFFFFFC20:
          v45 = *(_OWORD *)(v30 + 16);
          *(_OWORD *)v57 = *(_OWORD *)v30;
          *(_OWORD *)&v57[16] = v45;
          v58 = 0uLL;
          *(_QWORD *)&v57[32] = 0;
          std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v57[32], *(__int128 **)(v28 + 96 * v29 + 32), *(__int128 **)(v28 + 96 * v29 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v28 + 96 * v29 + 40) - *(_QWORD *)(v28 + 96 * v29 + 32)) >> 3));
          __p[0] = 0;
          __p[1] = 0;
          v60[0] = 0;
          std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *(__int128 **)(v28 + 96 * v29 + 56), *(__int128 **)(v28 + 96 * v29 + 64), (uint64_t)(*(_QWORD *)(v28 + 96 * v29 + 64) - *(_QWORD *)(v28 + 96 * v29 + 56)) >> 4);
          v46 = *v32;
          *(_QWORD *)((char *)&v60[1] + 5) = *(_QWORD *)(v30 + 85);
          v60[1] = v46;
          (*(void (**)(_QWORD, uint64_t, unint64_t))(*(_QWORD *)*v32 + 24))(*v32, 1, v28 + 96 * v29);
          (*(void (**)(_QWORD, _QWORD, _BYTE *))(*(_QWORD *)v60[1] + 24))(v60[1], 0, v57);
          std::deque<std::__state<char>>::push_back(&v61, (uint64_t)v57);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          if (*(_QWORD *)&v57[32])
          {
            *(_QWORD *)&v58 = *(_QWORD *)&v57[32];
            operator delete(*(void **)&v57[32]);
          }
          goto LABEL_38;
        default:
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
      }
      break;
    }
  }
  std::deque<std::__state<char>>::~deque[abi:ne180100](&v61);
  return v6;
}

void sub_1CBD0D368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  std::deque<std::__state<char>>::~deque[abi:ne180100](&a27);
  _Unwind_Resume(a1);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  uint64_t v6;
  _OWORD *v11;
  unsigned int v12;
  const char *v13;
  _OWORD *v14;
  BOOL v15;
  uint64_t v16;
  _QWORD *v17;
  _BYTE *v18;
  const char *v19;
  _OWORD *v20;
  __int128 v21;
  void *v22;
  _OWORD *v23;
  __int128 v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  __int128 v28;
  void *v29;
  _QWORD *v30;
  uint64_t v31;
  _OWORD *v32;
  uint64_t v33;
  unint64_t v34;
  _BYTE *v35;
  unsigned int v36;
  uint64_t v37;
  char v38;
  const char *v40;
  const char *v41;
  char v42;
  _BYTE v45[56];
  void *__p[2];
  _QWORD v47[4];
  std::vector<std::csub_match>::value_type __x;
  _BYTE v49[40];
  __int128 v50;
  void *v51[6];
  _OWORD *v52;
  _OWORD *v53;
  unint64_t v54;

  v52 = 0;
  v53 = 0;
  v54 = 0;
  *(_DWORD *)v49 = 0;
  memset(&v49[8], 0, 32);
  v50 = 0u;
  memset(v51, 0, 37);
  v6 = *(_QWORD *)(a1 + 40);
  if (v6)
  {
    __x.first = a3;
    __x.second = a3;
    __x.matched = 0;
    *(_DWORD *)v45 = 0;
    memset(&v45[8], 0, 48);
    *(_OWORD *)__p = 0uLL;
    memset(v47, 0, 21);
    v53 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v52, (uint64_t)v45);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*(_QWORD *)&v45[32])
    {
      *(_QWORD *)&v45[40] = *(_QWORD *)&v45[32];
      operator delete(*(void **)&v45[32]);
    }
    v11 = v53;
    *((_DWORD *)v53 - 24) = 0;
    *((_QWORD *)v11 - 11) = a2;
    *((_QWORD *)v11 - 10) = a2;
    *((_QWORD *)v11 - 9) = a3;
    std::vector<std::sub_match<char const*>>::resize((std::vector<std::csub_match> *)(v11 - 4), *(unsigned int *)(a1 + 28), &__x);
    std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)((char *)v53 - 40), *(unsigned int *)(a1 + 32));
    v40 = a3;
    v41 = 0;
    v42 = 0;
    v12 = 0;
    v13 = (const char *)(a3 - a2);
    v14 = v53;
    *((_QWORD *)v53 - 2) = v6;
    *((_DWORD *)v14 - 2) = a5;
    *((_BYTE *)v14 - 4) = a6;
    do
    {
      v15 = (++v12 & 0xFFF) != 0 || (int)(v12 >> 12) < (int)v13;
      if (!v15)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
      v17 = v14 - 1;
      v16 = *((_QWORD *)v14 - 2);
      v18 = v14 - 6;
      if (v16)
        (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v16 + 16))(v16, v14 - 6);
      switch(*(_DWORD *)v18)
      {
        case 0xFFFFFC18:
          v19 = (const char *)*((_QWORD *)v14 - 10);
          if ((a5 & 0x20) != 0 && v19 == a2 || (a5 & 0x1000) != 0 && v19 != v40)
            goto LABEL_19;
          v26 = &v19[-*((_QWORD *)v14 - 11)];
          v27 = v41;
          if ((v42 & ((uint64_t)v41 >= (uint64_t)v26)) == 0)
          {
            v28 = *(v14 - 5);
            *(_OWORD *)v49 = *(_OWORD *)v18;
            *(_OWORD *)&v49[16] = v28;
            if (v49 != v18)
            {
              std::vector<std::sub_match<char const*>>::__assign_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v49[32], *((__int128 **)v14 - 8), *((__int128 **)v14 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v14 - 7) - *((_QWORD *)v14 - 8)) >> 3));
              std::vector<std::pair<unsigned long,char const*>>::__assign_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(v51, *((uint64_t **)v14 - 5), *((uint64_t **)v14 - 4), (uint64_t)(*((_QWORD *)v14 - 4) - *((_QWORD *)v14 - 5)) >> 4);
            }
            v29 = (void *)*v17;
            *(void **)((char *)&v51[3] + 5) = *(void **)((char *)v14 - 11);
            v51[3] = v29;
            v27 = v26;
          }
          v30 = v53;
          if (v27 == v13)
          {
            v31 = (uint64_t)v52;
            while (v30 != (_QWORD *)v31)
            {
              v30 -= 12;
              std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v30);
            }
            v53 = (_OWORD *)v31;
            v42 = 1;
            v41 = v13;
          }
          else
          {
            v41 = v27;
            v32 = v53 - 6;
            std::__destroy_at[abi:ne180100]<std::__state<char>,0>((_QWORD *)v53 - 12);
            v53 = v32;
            v42 = 1;
          }
          break;
        case 0xFFFFFC1D:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          break;
        case 0xFFFFFC1F:
LABEL_19:
          v20 = v53 - 6;
          std::__destroy_at[abi:ne180100]<std::__state<char>,0>((_QWORD *)v53 - 12);
          v53 = v20;
          break;
        case 0xFFFFFC20:
          v21 = *(v14 - 5);
          *(_OWORD *)v45 = *(_OWORD *)v18;
          *(_OWORD *)&v45[16] = v21;
          memset(&v45[32], 0, 24);
          std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v45[32], *((__int128 **)v14 - 8), *((__int128 **)v14 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v14 - 7) - *((_QWORD *)v14 - 8)) >> 3));
          __p[0] = 0;
          __p[1] = 0;
          v47[0] = 0;
          std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *((__int128 **)v14 - 5), *((__int128 **)v14 - 4), (uint64_t)(*((_QWORD *)v14 - 4) - *((_QWORD *)v14 - 5)) >> 4);
          v22 = (void *)*v17;
          *(_QWORD *)((char *)&v47[1] + 5) = *(_QWORD *)((char *)v14 - 11);
          v47[1] = v22;
          (*(void (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)*v17 + 24))(*v17, 1, v14 - 6);
          (*(void (**)(_QWORD, _QWORD, _BYTE *))(*(_QWORD *)v47[1] + 24))(v47[1], 0, v45);
          v23 = v53;
          if ((unint64_t)v53 >= v54)
          {
            v53 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v52, (uint64_t)v45);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }
          else
          {
            v24 = *(_OWORD *)&v45[16];
            *v53 = *(_OWORD *)v45;
            v23[1] = v24;
            *((_QWORD *)v23 + 4) = 0;
            *((_QWORD *)v23 + 5) = 0;
            *((_QWORD *)v23 + 6) = 0;
            *((_QWORD *)v23 + 7) = 0;
            v23[2] = *(_OWORD *)&v45[32];
            *((_QWORD *)v23 + 6) = *(_QWORD *)&v45[48];
            memset(&v45[32], 0, 24);
            *((_QWORD *)v23 + 8) = 0;
            *((_QWORD *)v23 + 9) = 0;
            *(_OWORD *)((char *)v23 + 56) = *(_OWORD *)__p;
            *((_QWORD *)v23 + 9) = v47[0];
            __p[0] = 0;
            __p[1] = 0;
            v47[0] = 0;
            v25 = v47[1];
            *(_QWORD *)((char *)v23 + 85) = *(_QWORD *)((char *)&v47[1] + 5);
            *((_QWORD *)v23 + 10) = v25;
            v53 = v23 + 6;
          }
          if (*(_QWORD *)&v45[32])
          {
            *(_QWORD *)&v45[40] = *(_QWORD *)&v45[32];
            operator delete(*(void **)&v45[32]);
          }
          break;
        default:
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
      }
      v14 = v53;
    }
    while (v52 != v53);
    if ((v42 & 1) != 0)
    {
      v33 = *a4;
      *(_QWORD *)v33 = a2;
      *(_QWORD *)(v33 + 8) = &v41[(_QWORD)a2];
      *(_BYTE *)(v33 + 16) = 1;
      if ((_QWORD)v50 != *(_QWORD *)&v49[32])
      {
        v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v50 - *(_QWORD *)&v49[32]) >> 3);
        v35 = (_BYTE *)(*(_QWORD *)&v49[32] + 16);
        v36 = 1;
        do
        {
          v37 = v33 + 24 * v36;
          *(_OWORD *)v37 = *((_OWORD *)v35 - 1);
          v38 = *v35;
          v35 += 24;
          *(_BYTE *)(v37 + 16) = v38;
          v15 = v34 > v36++;
        }
        while (v15);
      }
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  if (v51[0])
  {
    v51[1] = v51[0];
    operator delete(v51[0]);
  }
  if (*(_QWORD *)&v49[32])
  {
    *(_QWORD *)&v50 = *(_QWORD *)&v49[32];
    operator delete(*(void **)&v49[32]);
  }
  *(_QWORD *)v49 = &v52;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)v49);
  return v6;
}

void sub_1CBD0D8A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  uint64_t v35;

  std::__state<char>::~__state(&a19);
  std::__state<char>::~__state(&a35);
  a35 = v35 - 120;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a35);
  _Unwind_Resume(a1);
}

__n128 std::deque<std::__state<char>>::push_back(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  __n128 result;
  uint64_t v11;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 42 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<std::__state<char>>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = *(_QWORD *)(v5 + 8 * (v7 / 0x2A)) + 96 * (v7 % 0x2A);
  v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 32) = 0;
  *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(v8 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(v8 + 56) = 0;
  *(_QWORD *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 72) = 0;
  result = *(__n128 *)(a2 + 56);
  *(__n128 *)(v8 + 56) = result;
  *(_QWORD *)(v8 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  v11 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v8 + 85) = *(_QWORD *)(a2 + 85);
  *(_QWORD *)(v8 + 80) = v11;
  ++a1[5];
  return result;
}

uint64_t std::deque<std::__state<char>>::pop_back(_QWORD *a1)
{
  unint64_t v2;

  v2 = a1[5] + a1[4] - 1;
  std::__destroy_at[abi:ne180100]<std::__state<char>,0>((_QWORD *)(*(_QWORD *)(a1[1] + 8 * (v2 / 0x2A))
                                                                 + 96 * (v2 % 0x2A)));
  --a1[5];
  return std::deque<std::__state<char>>::__maybe_remove_back_spare[abi:ne180100](a1, 1);
}

int64x2_t std::deque<std::__state<char>>::push_front(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  int64x2_t result;

  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
  {
    std::deque<std::__state<char>>::__add_front_capacity((void **)a1);
    v4 = *(_QWORD *)(a1 + 32);
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (_QWORD *)(v5 + 8 * (v4 / 0x2A));
  v7 = *v6 + 96 * (v4 % 0x2A);
  if (*(_QWORD *)(a1 + 16) == v5)
    v7 = 0;
  if (v7 == *v6)
    v7 = *(v6 - 1) + 4032;
  v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v7 - 96) = *(_OWORD *)a2;
  *(_OWORD *)(v7 - 80) = v8;
  *(_QWORD *)(v7 - 56) = 0;
  *(_QWORD *)(v7 - 48) = 0;
  *(_QWORD *)(v7 - 64) = 0;
  *(_OWORD *)(v7 - 64) = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(v7 - 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(v7 - 40) = 0;
  *(_QWORD *)(v7 - 32) = 0;
  *(_QWORD *)(v7 - 24) = 0;
  *(_OWORD *)(v7 - 40) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(v7 - 24) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  v9 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v7 - 11) = *(_QWORD *)(a2 + 85);
  *(_QWORD *)(v7 - 16) = v9;
  result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1CBD153A0);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

void std::deque<std::__state<char>>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x2A;
  v4 = v2 - 42;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0xFC0uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0xFC0uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0xFC0uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1CBD0DE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::__state<char>>::__maybe_remove_back_spare[abi:ne180100](_QWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v7;

  v3 = a1[1];
  v2 = a1[2];
  if (v2 == v3)
    v4 = 0;
  else
    v4 = 42 * ((v2 - v3) >> 3) - 1;
  v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x2A)
    a2 = 1;
  if (v5 < 0x54)
    v7 = a2;
  else
    v7 = 0;
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void std::deque<std::__state<char>>::__add_front_capacity(void **a1)
{
  _BYTE *v2;
  _BYTE *v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  char *v33;
  _QWORD *v34;
  uint64_t v35;
  void *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void *v41;
  void *__p;
  char *v43;
  char *v44;
  char *v45;
  _QWORD *v46;

  v2 = a1[1];
  v3 = a1[2];
  v4 = (v3 - v2) >> 3;
  if (v3 == v2)
    v5 = 0;
  else
    v5 = 42 * v4 - 1;
  v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(_QWORD)a1[5]] < 0x2A)
  {
    v7 = (uint64_t)(a1 + 3);
    v8 = a1[3];
    v9 = *a1;
    v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9)
        v11 = 1;
      else
        v11 = v10 >> 2;
      v46 = a1 + 3;
      __p = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v7, v11);
      v43 = (char *)__p;
      v44 = (char *)__p;
      v45 = (char *)__p + 8 * v12;
      v41 = operator new(0xFC0uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(&__p, &v41);
      v13 = (char *)a1[1];
      v14 = v44;
      if (v13 == a1[2])
      {
        v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p)
                v23 = 1;
              else
                v23 = (v14 - (_BYTE *)__p) >> 2;
              v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v46, v23);
              v26 = v43;
              v14 = &v24[8 * (v23 >> 2)];
              v27 = v44 - v43;
              if (v44 != v43)
              {
                v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                v28 = 8 * (v27 >> 3);
                v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  v30 = *(_QWORD *)v26;
                  v26 += 8;
                  *(_QWORD *)v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              v31 = __p;
              __p = v24;
              v43 = &v24[8 * (v23 >> 2)];
              v44 = v14;
              v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                v14 = v44;
              }
            }
            else
            {
              v16 = v15 >> 3;
              v17 = v15 >> 3 < -1;
              v18 = (v15 >> 3) + 2;
              if (v17)
                v19 = v18;
              else
                v19 = v16 + 1;
              v20 = &v43[-8 * (v19 >> 1)];
              v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                v14 = v43;
              }
              v22 = &v14[-8 * (v19 >> 1)];
              v14 = &v20[v21];
              v43 = v22;
              v44 = &v20[v21];
            }
          }
          v32 = *(_QWORD *)v13;
          v13 += 8;
          *(_QWORD *)v14 = v32;
          v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        v33 = (char *)a1[1];
      }
      v36 = *a1;
      v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      v43 = v33;
      v38 = (char *)a1[3];
      v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      v44 = v13;
      v45 = v38;
      if (v14 - v37 == 8)
        v40 = 21;
      else
        v40 = (uint64_t)a1[4] + 42;
      a1[4] = (void *)v40;
      if (v13 != v33)
        v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      if (v36)
        operator delete(v36);
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0xFC0uLL);
        std::__split_buffer<TNodeEventPtr *>::push_back(a1, &__p);
        v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0xFC0uLL);
      }
      std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8)
        v35 = 21;
      else
        v35 = (uint64_t)a1[4] + 42;
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 42;
    __p = (void *)*((_QWORD *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1CBD0E1B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  void *v12;

  operator delete(v12);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::__state<char>>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  char *v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    v5 = a1[4];
    v6 = &v2[v5 / 0x2A];
    v7 = (char *)*v6 + 96 * (v5 % 0x2A);
    v8 = (unint64_t)v2[(a1[5] + v5) / 0x2A] + 96 * ((a1[5] + v5) % 0x2A);
    if (v7 != (char *)v8)
    {
      do
      {
        std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v7);
        v7 += 96;
        if (v7 - (_BYTE *)*v6 == 4032)
        {
          v9 = (char *)v6[1];
          ++v6;
          v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      v2 = (void **)a1[1];
      v3 = (void **)a1[2];
    }
  }
  *v4 = 0;
  v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v10 >> 3;
  if (v11 == 1)
  {
    v12 = 21;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_16;
    v12 = 42;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<TNodeEventPtr *>::~__split_buffer((uint64_t)a1);
}

char *std::vector<std::sub_match<char const*>>::__assign_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(_QWORD *a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  __int128 *v6;
  uint64_t v8;
  char *result;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  char *v16;
  __int128 v17;
  int64_t v18;
  char *v19;
  unint64_t v20;
  __int128 *v21;
  char *v22;
  char *v23;
  __int128 v24;
  char *v25;
  char *v26;

  v6 = a2;
  v8 = a1[2];
  result = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 3) >= a4)
  {
    v19 = (char *)a1[1];
    v14 = a1 + 1;
    v13 = v19;
    v20 = 0xAAAAAAAAAAAAAAABLL * ((v19 - result) >> 3);
    if (v20 >= a4)
    {
      v25 = result;
      if (a2 != a3)
      {
        v26 = result;
        do
        {
          *(_OWORD *)v26 = *v6;
          v26[16] = *((_BYTE *)v6 + 16);
          v25 += 24;
          v6 = (__int128 *)((char *)v6 + 24);
          v26 += 24;
        }
        while (v6 != a3);
      }
      v18 = v25 - result;
      v13 = result;
    }
    else
    {
      v21 = (__int128 *)((char *)a2 + 24 * v20);
      if (v13 != result)
      {
        do
        {
          *(_OWORD *)result = *v6;
          result[16] = *((_BYTE *)v6 + 16);
          v6 = (__int128 *)((char *)v6 + 24);
          result += 24;
        }
        while (v6 != v21);
      }
      v22 = v13;
      if (v21 != a3)
      {
        v23 = v13;
        do
        {
          v24 = *v21;
          *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
          *(_OWORD *)v23 = v24;
          v23 += 24;
          v21 = (__int128 *)((char *)v21 + 24);
          v22 += 24;
        }
        while (v21 != a3);
      }
      v18 = v22 - v13;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v11;
    result = std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](a1, v12);
    v15 = (char *)a1[1];
    v14 = a1 + 1;
    v13 = v15;
    v16 = v15;
    if (v6 != a3)
    {
      v16 = v13;
      do
      {
        v17 = *v6;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v16 = v17;
        v16 += 24;
        v6 = (__int128 *)((char *)v6 + 24);
      }
      while (v6 != a3);
    }
    v18 = v16 - v13;
  }
  *v14 = &v13[v18];
  return result;
}

char *std::vector<std::pair<unsigned long,char const*>>::__assign_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(_QWORD *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t v8;
  char *result;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  __int128 v16;
  char *v17;
  char *v18;
  unint64_t v19;
  __int128 *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;

  v6 = a2;
  v8 = a1[2];
  result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 4)
  {
    v18 = (char *)a1[1];
    v13 = a1 + 1;
    v12 = v18;
    v19 = (v18 - result) >> 4;
    if (v19 >= a4)
    {
      v26 = result;
      if (a2 != a3)
      {
        v27 = result;
        do
        {
          v28 = *v6;
          v29 = v6[1];
          v6 += 2;
          *(_QWORD *)v27 = v28;
          *((_QWORD *)v27 + 1) = v29;
          v27 += 16;
          v26 += 16;
        }
        while (v6 != a3);
      }
      v17 = (char *)(v26 - result);
      v12 = result;
    }
    else
    {
      v20 = (__int128 *)&a2[2 * v19];
      if (v12 != result)
      {
        do
        {
          v21 = *v6;
          v22 = v6[1];
          v6 += 2;
          *(_QWORD *)result = v21;
          *((_QWORD *)result + 1) = v22;
          result += 16;
        }
        while (v6 != (uint64_t *)v20);
      }
      v23 = v12;
      if (v20 != (__int128 *)a3)
      {
        v24 = v12;
        do
        {
          v25 = *v20++;
          *(_OWORD *)v24 = v25;
          v24 += 16;
          v23 += 16;
        }
        while (v20 != (__int128 *)a3);
      }
      v17 = (char *)(v23 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](a1, v11);
    v14 = (char *)a1[1];
    v13 = a1 + 1;
    v12 = v14;
    v15 = v14;
    if (v6 != a3)
    {
      v15 = v12;
      do
      {
        v16 = *(_OWORD *)v6;
        v6 += 2;
        *(_OWORD *)v15 = v16;
        v15 += 16;
      }
      while (v6 != a3);
    }
    v17 = (char *)(v15 - v12);
  }
  *v13 = &v17[(_QWORD)v12];
  return result;
}

uint64_t std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(char *__f, char *__l, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5;
  int v9;
  uint64_t result;
  std::match_results<const char *> __p;

  v5 = a5;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  v9 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, __f, __l, &__p, a5 | 0x1040u);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)a3, (uint64_t)__f, (std::sub_match<std::__wrap_iter<const char *>> *)__l, (uint64_t *)&__p, (v5 & 0x800) != 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (!v9)
    return 0;
  if (!*(_BYTE *)(a3 + 88))
    return 1;
  result = 0;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
  return result;
}

void sub_1CBD0E724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(std::vector<std::ssub_match> *a1, uint64_t a2, std::sub_match<std::__wrap_iter<const char *>> *a3, uint64_t *a4, char a5)
{
  uint64_t v10;
  std::vector<std::ssub_match>::pointer begin;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t *v20;
  char v21;
  std::vector<std::ssub_match>::pointer end;
  std::sub_match<std::__wrap_iter<const char *>> *v23;

  v10 = a4[6];
  std::vector<std::sub_match<std::__wrap_iter<char const*>>>::resize(a1, 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3));
  begin = a1->__begin_;
  if (a1->__end_ != a1->__begin_)
  {
    v12 = 0;
    v13 = 0;
    v15 = *a4;
    v14 = a4[1];
    do
    {
      v16 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v15) >> 3);
      v17 = (_QWORD *)(v15 + v12 * 24);
      if (v16 <= v13)
        v18 = a4 + 3;
      else
        v18 = v17;
      begin[v12].first.__i_ = (std::__wrap_iter<const char *>::iterator_type)(a2 + *v18 - v10);
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v13)
        v19 = a4 + 3;
      else
        v19 = (uint64_t *)(*a4 + v12 * 24);
      a1->__begin_[v12].second.__i_ = (std::__wrap_iter<const char *>::iterator_type)(a2 + v19[1] - v10);
      v15 = *a4;
      v14 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v14 - *a4) >> 3) <= v13)
        v20 = a4 + 3;
      else
        v20 = (uint64_t *)(*a4 + v12 * 24);
      v21 = *((_BYTE *)v20 + 16);
      begin = a1->__begin_;
      end = a1->__end_;
      a1->__begin_[v12].matched = v21;
      ++v13;
      ++v12;
    }
    while (v13 < 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3));
  }
  a1[1].__begin_ = a3;
  a1[1].__end_ = a3;
  LOBYTE(a1[1].__end_cap_.__value_) = 0;
  v23 = (std::sub_match<std::__wrap_iter<const char *>> *)(a2 + a4[6] - v10);
  a1[2].__begin_ = v23;
  a1[2].__end_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[7] - v10);
  LOBYTE(a1[2].__end_cap_.__value_) = *((_BYTE *)a4 + 64);
  a1[3].__begin_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[9] - v10);
  a1[3].__end_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[10] - v10);
  LOBYTE(a1[3].__end_cap_.__value_) = *((_BYTE *)a4 + 88);
  if ((a5 & 1) == 0)
    a1[4].__end_ = v23;
  LOBYTE(a1[4].__begin_) = *((_BYTE *)a4 + 96);
}

void std::vector<std::sub_match<std::__wrap_iter<char const*>>>::resize(std::vector<std::ssub_match> *this, std::vector<std::ssub_match>::size_type __sz)
{
  std::vector<std::ssub_match>::size_type v2;
  BOOL v3;
  std::vector<std::ssub_match>::size_type v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3);
  v3 = __sz >= v2;
  v4 = __sz - v2;
  if (v4 != 0 && v3)
  {
    std::vector<std::sub_match<std::__wrap_iter<char const*>>>::__append(this, v4);
  }
  else if (!v3)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

void std::vector<std::sub_match<std::__wrap_iter<char const*>>>::__append(std::vector<std::ssub_match> *this, std::vector<std::ssub_match>::size_type __n)
{
  std::__compressed_pair<std::ssub_match *> *p_end_cap;
  std::sub_match<std::__wrap_iter<const char *>> *v5;
  std::sub_match<std::__wrap_iter<const char *>> *value;
  std::sub_match<std::__wrap_iter<const char *>> *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  std::sub_match<std::__wrap_iter<const char *>> *v13;
  std::vector<std::ssub_match>::size_type v14;
  std::sub_match<std::__wrap_iter<const char *>> *v15;
  std::sub_match<std::__wrap_iter<const char *>> *v16;
  std::vector<std::ssub_match>::size_type v17;
  std::sub_match<std::__wrap_iter<const char *>> *v18;
  std::sub_match<std::__wrap_iter<const char *>> *v19;
  std::sub_match<std::__wrap_iter<const char *>> *end;
  std::vector<std::ssub_match>::pointer begin;
  std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> v22;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  v7 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v7) >> 3) >= __n)
  {
    if (__n)
    {
      v13 = &v7[__n];
      v14 = 24 * __n;
      do
      {
        v7->first.__i_ = 0;
        v7->second.__i_ = 0;
        v7->matched = 0;
        ++v7;
        v14 -= 24;
      }
      while (v14);
      v7 = v13;
    }
    this->__end_ = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    v9 = v8 + __n;
    if (v8 + __n > 0xAAAAAAAAAAAAAAALL)
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)this->__begin_) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v11);
    else
      v12 = 0;
    v15 = (std::sub_match<std::__wrap_iter<const char *>> *)&v12[24 * v8];
    v16 = &v15[__n];
    v17 = 24 * __n;
    v18 = v15;
    do
    {
      v18->first.__i_ = 0;
      v18->second.__i_ = 0;
      v18->matched = 0;
      ++v18;
      v17 -= 24;
    }
    while (v17);
    v19 = (std::sub_match<std::__wrap_iter<const char *>> *)&v12[24 * v11];
    begin = this->__begin_;
    end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        v22 = end[-1].std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>>;
        *(_QWORD *)&v15[-1].matched = *(_QWORD *)&end[-1].matched;
        v15[-1].std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> = v22;
        --v15;
        --end;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v15;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v19;
    if (end)
      operator delete(end);
  }
}

void TOperationSizer::ComputeSizeWithTimeout(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void ___ZZ34__DSFileProgress_progressChanged__ENK3__2cvU13block_pointerFvvEEv_block_invoke_cold_1(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>()
{
  unint64_t *v0;
  uint64_t v1;
  int v2;

  OUTLINED_FUNCTION_4();
  do
    OUTLINED_FUNCTION_1(v0);
  while (v2);
  if (!v1)
  {
    OUTLINED_FUNCTION_0();
    OUTLINED_FUNCTION_3();
  }
  OUTLINED_FUNCTION_2();
}

void ___ZN12TGlobalNodes8BootNodeEv_block_invoke_cold_1(uint64_t a1, std::__shared_weak_count **a2, uint64_t a3, id *a4)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v5 = *a2;
  if (*a2)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

}

void TChildrenList::LowerBounds(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void TClientChangeNotifier::TClientChangeNotifier(_QWORD *a1, _QWORD *a2, id *a3, uint64_t a4)
{
  uint64_t v6;
  std::__shared_weak_count *v7;

  if ((_QWORD *)*a1 == a2)
  {
    v6 = 4;
  }
  else
  {
    if (!*a1)
      goto LABEL_6;
    v6 = 5;
    a2 = (_QWORD *)*a1;
  }
  (*(void (**)(_QWORD *))(*a2 + 8 * v6))(a2);
LABEL_6:

  v7 = *(std::__shared_weak_count **)(a4 + 8);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
  OUTLINED_FUNCTION_2();
}

void ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2_cold_1(char a1, uint64_t a2)
{
  unint64_t *v2;
  uint64_t v3;
  int v4;

  if ((a1 & 1) == 0)
  {
    v2 = (unint64_t *)(a2 + 8);
    do
      OUTLINED_FUNCTION_1(v2);
    while (v4);
    if (!v3)
    {
      OUTLINED_FUNCTION_0();
      OUTLINED_FUNCTION_3();
    }
  }
}

void ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2_cold_2(uint64_t a1)
{
  unint64_t *v1;
  uint64_t v2;
  int v3;

  v1 = (unint64_t *)(a1 + 8);
  do
    OUTLINED_FUNCTION_1(v1);
  while (v3);
  if (!v2)
  {
    OUTLINED_FUNCTION_0();
    OUTLINED_FUNCTION_3();
  }
  OUTLINED_FUNCTION_2();
}

void ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke_cold_1(std::__shared_weak_count **a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *a1;
  if (*a1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      OUTLINED_FUNCTION_0();
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke_cold_2(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    OUTLINED_FUNCTION_0();
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t APFSVolumeRole()
{
  return MEMORY[0x1E0CF18C8]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1E0D15428]();
}

uint64_t BRGetCloudDocsRootURL()
{
  return MEMORY[0x1E0D10C78]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1E0C97E90](arg);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

CFDictionaryRef CFBundleCopyInfoDictionaryForURL(CFURLRef url)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98028](url);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1E0C98050](bundle, key, value, tableName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1E0C980D0](allocator, bundleURL);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

Boolean CFBundleGetPackageInfoInDirectory(CFURLRef url, UInt32 *packageType, UInt32 *packageCreator)
{
  return MEMORY[0x1E0C98160](url, packageType, packageCreator);
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return MEMORY[0x1E0C98440](theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1E0C98448](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C984D8](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1E0C984E8]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98648](err);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1E0C98660](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1E0C98670](err);
}

Boolean CFFileSecurityCopyAccessControlList(CFFileSecurityRef fileSec, acl_t *accessControlList)
{
  return MEMORY[0x1E0C986B8](fileSec, accessControlList);
}

Boolean CFFileSecurityGetGroup(CFFileSecurityRef fileSec, gid_t *group)
{
  return MEMORY[0x1E0C986E0](fileSec, group);
}

Boolean CFFileSecurityGetMode(CFFileSecurityRef fileSec, mode_t *mode)
{
  return MEMORY[0x1E0C986E8](fileSec, mode);
}

Boolean CFFileSecurityGetOwner(CFFileSecurityRef fileSec, uid_t *owner)
{
  return MEMORY[0x1E0C986F0](fileSec, owner);
}

Boolean CFFileSecuritySetGroup(CFFileSecurityRef fileSec, gid_t group)
{
  return MEMORY[0x1E0C98700](fileSec, *(_QWORD *)&group);
}

Boolean CFFileSecuritySetMode(CFFileSecurityRef fileSec, mode_t mode)
{
  return MEMORY[0x1E0C98708](fileSec, mode);
}

Boolean CFFileSecuritySetOwner(CFFileSecurityRef fileSec, uid_t owner)
{
  return MEMORY[0x1E0C98710](fileSec, *(_QWORD *)&owner);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988C8]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1E0C98908]();
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1E0C989A8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C00](rl, timer, mode);
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C40]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  MEMORY[0x1E0C98C80](rl, mode, block);
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98CA0](rl, timer, mode);
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1E0C98D08](allocator, flags, order, callout, context, fireDate, interval);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D68](rl);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  MEMORY[0x1E0C98EE8](theString, chars, numChars);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F18](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1E0C98FE8](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x1E0C990C0](theString, range.location, range.length, buffer);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  double result;

  MEMORY[0x1E0C990D0](str);
  return result;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

void CFURLClearResourcePropertyCache(CFURLRef url)
{
  MEMORY[0x1E0C992B8](url);
}

void CFURLClearResourcePropertyCacheForKey(CFURLRef url, CFStringRef key)
{
  MEMORY[0x1E0C992C0](url, key);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C992F8](url);
}

CFDictionaryRef CFURLCopyResourcePropertiesForKeys(CFURLRef url, CFArrayRef keys, CFErrorRef *error)
{
  return (CFDictionaryRef)MEMORY[0x1E0C99330](url, keys, error);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1E0C99338](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99348](anURL);
}

CFDataRef CFURLCreateBookmarkData(CFAllocatorRef allocator, CFURLRef url, CFURLBookmarkCreationOptions options, CFArrayRef resourcePropertiesToInclude, CFURLRef relativeToURL, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C99368](allocator, url, options, resourcePropertiesToInclude, relativeToURL, error);
}

CFDataRef CFURLCreateBookmarkDataFromFile(CFAllocatorRef allocator, CFURLRef fileURL, CFErrorRef *errorRef)
{
  return (CFDataRef)MEMORY[0x1E0C99370](allocator, fileURL, errorRef);
}

CFURLRef CFURLCreateByResolvingBookmarkData(CFAllocatorRef allocator, CFDataRef bookmark, CFURLBookmarkResolutionOptions options, CFURLRef relativeToURL, CFArrayRef resourcePropertiesToInclude, Boolean *isStale, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1E0C99378](allocator, bookmark, options, relativeToURL, resourcePropertiesToInclude, isStale, error);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99390](allocator, url);
}

CFURLRef CFURLCreateFilePathURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1E0C993B8](allocator, url, error);
}

CFURLRef CFURLCreateFileReferenceURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1E0C993C0](allocator, url, error);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFTypeRef CFURLCreateResourcePropertyForKeyFromBookmarkData(CFAllocatorRef allocator, CFStringRef resourcePropertyKey, CFDataRef bookmark)
{
  return (CFTypeRef)MEMORY[0x1E0C993F0](allocator, resourcePropertyKey, bookmark);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

CFURLEnumeratorRef CFURLEnumeratorCreateForDirectoryURL(CFAllocatorRef alloc, CFURLRef directoryURL, CFURLEnumeratorOptions option, CFArrayRef propertyKeys)
{
  return (CFURLEnumeratorRef)MEMORY[0x1E0C99450](alloc, directoryURL, option, propertyKeys);
}

CFURLEnumeratorResult CFURLEnumeratorGetNextURL(CFURLEnumeratorRef enumerator, CFURLRef *url, CFErrorRef *error)
{
  return MEMORY[0x1E0C99468](enumerator, url, error);
}

void CFURLEnumeratorSkipDescendents(CFURLEnumeratorRef enumerator)
{
  MEMORY[0x1E0C99470](enumerator);
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  return (CFURLRef)MEMORY[0x1E0C99478](anURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1E0C994B8]();
}

Boolean CFURLIsFileReferenceURL(CFURLRef url)
{
  return MEMORY[0x1E0C994C8](url);
}

Boolean CFURLSetResourcePropertiesForKeys(CFURLRef url, CFDictionaryRef keyedPropertyValues, CFErrorRef *error)
{
  return MEMORY[0x1E0C994D8](url, keyedPropertyValues, error);
}

Boolean CFURLSetResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  return MEMORY[0x1E0C994E0](url, key, propertyValue, error);
}

Boolean CFURLWriteBookmarkDataToFile(CFDataRef bookmarkRef, CFURLRef fileURL, CFURLBookmarkFileCreationOptions options, CFErrorRef *errorRef)
{
  return MEMORY[0x1E0C99500](bookmarkRef, fileURL, options, errorRef);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1E0C995A8](allocator, flags, error, dictionary, timeout);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return MEMORY[0x1E0C995E8](userNotification, responseFlags, timeout);
}

uint64_t CacheDeleteCopyPurgeableSpaceWithInfo()
{
  return MEMORY[0x1E0D09B58]();
}

uint64_t CacheDeletePurgeSpaceWithInfo()
{
  return MEMORY[0x1E0D09B80]();
}

uint64_t FPFileMetadataCopyLastUsedDateAtURL()
{
  return MEMORY[0x1E0CAA980]();
}

uint64_t FPResolveSymlink()
{
  return MEMORY[0x1E0CAAAB0]();
}

uint64_t FPURLMightBeInFileProvider()
{
  return MEMORY[0x1E0CAAAF0]();
}

FSEventStreamRef FSEventStreamCreate(CFAllocatorRef allocator, FSEventStreamCallback callback, FSEventStreamContext *context, CFArrayRef pathsToWatch, FSEventStreamEventId sinceWhen, CFTimeInterval latency, FSEventStreamCreateFlags flags)
{
  return (FSEventStreamRef)MEMORY[0x1E0CA5758](allocator, callback, context, pathsToWatch, sinceWhen, *(_QWORD *)&flags, latency);
}

void FSEventStreamInvalidate(FSEventStreamRef streamRef)
{
  MEMORY[0x1E0CA5768](streamRef);
}

void FSEventStreamRelease(FSEventStreamRef streamRef)
{
  MEMORY[0x1E0CA5770](streamRef);
}

void FSEventStreamSetDispatchQueue(FSEventStreamRef streamRef, dispatch_queue_t q)
{
  MEMORY[0x1E0CA5780](streamRef, q);
}

Boolean FSEventStreamSetExclusionPaths(FSEventStreamRef streamRef, CFArrayRef pathsToExclude)
{
  return MEMORY[0x1E0CA5788](streamRef, pathsToExclude);
}

Boolean FSEventStreamStart(FSEventStreamRef streamRef)
{
  return MEMORY[0x1E0CA5790](streamRef);
}

void FSEventStreamStop(FSEventStreamRef streamRef)
{
  MEMORY[0x1E0CA5798](streamRef);
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

NSString *NSHomeDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB2C00]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1E0CB3230](aSelector);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return (SCDynamicStoreRef)MEMORY[0x1E0CE8770](allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateComputerName(CFAllocatorRef allocator)
{
  return (CFStringRef)MEMORY[0x1E0CE8788](allocator);
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return MEMORY[0x1E0CE87C8](store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return MEMORY[0x1E0CE87D8](store, keys, patterns);
}

uint64_t SFBrowserCloseNode()
{
  return MEMORY[0x1E0D974A8]();
}

uint64_t SFBrowserCopyChildren()
{
  return MEMORY[0x1E0D974B0]();
}

uint64_t SFBrowserCopyNodeForURL()
{
  return MEMORY[0x1E0D974B8]();
}

uint64_t SFBrowserCreate()
{
  return MEMORY[0x1E0D974C0]();
}

uint64_t SFBrowserGetRootNode()
{
  return MEMORY[0x1E0D974C8]();
}

uint64_t SFBrowserInvalidate()
{
  return MEMORY[0x1E0D974D0]();
}

uint64_t SFBrowserOpenNode()
{
  return MEMORY[0x1E0D974D8]();
}

uint64_t SFBrowserSetClient()
{
  return MEMORY[0x1E0D974E0]();
}

uint64_t SFBrowserSetDispatchQueue()
{
  return MEMORY[0x1E0D974E8]();
}

uint64_t SFNodeCopyDisplayName()
{
  return MEMORY[0x1E0D97528]();
}

uint64_t SFNodeCopyKindString()
{
  return MEMORY[0x1E0D97530]();
}

uint64_t SFNodeCopyKinds()
{
  return MEMORY[0x1E0D97538]();
}

uint64_t SFNodeCopySecondaryName()
{
  return MEMORY[0x1E0D97540]();
}

uint64_t SFNodeCopyTypeIdentifier()
{
  return MEMORY[0x1E0D97548]();
}

uint64_t SFNodeCopyUserName()
{
  return MEMORY[0x1E0D97550]();
}

uint64_t SFNodeGetConnectionState()
{
  return MEMORY[0x1E0D97558]();
}

uint64_t SFNodeGetPriority()
{
  return MEMORY[0x1E0D97560]();
}

uint64_t SFNodeIsContainer()
{
  return MEMORY[0x1E0D97568]();
}

uint64_t SFNodeIsMounted()
{
  return MEMORY[0x1E0D97570]();
}

uint64_t SFNodeIsNeighborhood()
{
  return MEMORY[0x1E0D97578]();
}

uint64_t SFNodeIsServer()
{
  return MEMORY[0x1E0D97580]();
}

uint64_t SFNodeIsSharePoint()
{
  return MEMORY[0x1E0D97588]();
}

uint64_t SFNodeSupportsFileSharing()
{
  return MEMORY[0x1E0D97590]();
}

uint64_t SFNodeSupportsScreenSharing()
{
  return MEMORY[0x1E0D97598]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F0](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1E0CD6610](allocator);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

uint64_t _CFBundleCreateUnique()
{
  return MEMORY[0x1E0C99FF0]();
}

uint64_t _CFURLCacheSetAutoFlushingEnabled()
{
  return MEMORY[0x1E0C9A5C8]();
}

uint64_t _CFURLCopyFileURL()
{
  return MEMORY[0x1E0C9A608]();
}

uint64_t _CFURLCopyLogicalURLOfPromiseAtURL()
{
  return MEMORY[0x1E0C9A628]();
}

uint64_t _CFURLCopyPromiseURLOfLogicalURL()
{
  return MEMORY[0x1E0C9A640]();
}

uint64_t _CFURLCopyResourcePropertyForKeyFromCache()
{
  return MEMORY[0x1E0C9A668]();
}

uint64_t _CFURLCopyResourcePropertyValuesAndFlags()
{
  return MEMORY[0x1E0C9A670]();
}

uint64_t _CFURLGetResourcePropertyFlags()
{
  return MEMORY[0x1E0C9A700]();
}

uint64_t _CFURLGetVolumePropertyFlags()
{
  return MEMORY[0x1E0C9A708]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1E0C9A710]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

std::string::size_type std::string::find(const std::string *this, const std::string::value_type *__s, std::string::size_type __pos, std::string::size_type __n)
{
  return MEMORY[0x1E0DE41C0](this, __s, __pos, __n);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1E0DE41C8](this, __c, __pos);
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1E0DE4240](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1E0DE43B0](this, *(_QWORD *)&__ecode);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4470](this, __pos, __s, __n);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1E0DE4490](this, __pos, __n1, __s, __n2);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
  MEMORY[0x1E0DE44A8](this, __requested_capacity);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1E0DE44C8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE4708]();
}

{
  return MEMORY[0x1E0DE4710]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1E0DE47C8](__s, __icase);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x1E0DE4890](this);
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
  MEMORY[0x1E0DE48A0](this, __lk, a3.__d_.__rep_);
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x1E0DE48A8](this, __lk);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x1E0DE48B0](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1E0DE4910](retstr, __s);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
  MEMORY[0x1E0DE4920](*(_QWORD *)&__ev, __what_arg);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1E0DE4AC8](__str, __idx, *(_QWORD *)&__base);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1E0DE4B38]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1E0DE4B48]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1E0DE4B88](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1E0DE4B90](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1E0DE4D40](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D58](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D60](retstr, *(_QWORD *)&__val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1E0DE4D88]();
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD8](this);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E874DBC0();
}

void operator delete(void *__p)
{
  off_1E874DBC8(__p);
}

uint64_t operator delete()
{
  return off_1E874DBD0();
}

uint64_t operator new[]()
{
  return off_1E874DBD8();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E874DBE0(__sz);
}

uint64_t operator new()
{
  return off_1E874DBE8();
}

uint64_t __CFStringIsMutable()
{
  return MEMORY[0x1E0C9A9F8]();
}

uint64_t __carbon_delete()
{
  return MEMORY[0x1E0C80A70]();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1E0C80C48]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1E0C81438](obj_p);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1E0C814F8](acl, len_p);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  return (Ivar)MEMORY[0x1E0DE7AB8](cls, name);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1E0C82698](a1);
}

uint64_t container_error_copy_unlocalized_description()
{
  return MEMORY[0x1E0C82868]();
}

uint64_t container_get_identifier()
{
  return MEMORY[0x1E0C828D8]();
}

uint64_t container_get_path()
{
  return MEMORY[0x1E0C828E8]();
}

uint64_t container_query_count_results()
{
  return MEMORY[0x1E0C829B0]();
}

uint64_t container_query_create()
{
  return MEMORY[0x1E0C829B8]();
}

uint64_t container_query_free()
{
  return MEMORY[0x1E0C829C8]();
}

uint64_t container_query_get_last_error()
{
  return MEMORY[0x1E0C829D0]();
}

uint64_t container_query_iterate_results_sync()
{
  return MEMORY[0x1E0C829E0]();
}

uint64_t container_query_operation_set_flags()
{
  return MEMORY[0x1E0C829E8]();
}

uint64_t container_query_set_class()
{
  return MEMORY[0x1E0C829F8]();
}

uint64_t container_query_set_include_other_owners()
{
  return MEMORY[0x1E0C82A10]();
}

uint64_t container_query_set_persona_unique_string()
{
  return MEMORY[0x1E0C82A18]();
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return MEMORY[0x1E0C82B18](from, to, state, *(_QWORD *)&flags);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D10](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D38](group, queue, block);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E50](label, attr, target);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x1E0C82F08](object, queue);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
  MEMORY[0x1E0C82F40](source, value);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F48](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1E0C83028](a1, a2);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1E0C833A0](a1, *(_QWORD *)&a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1E0C83528](a1, a2, a3, *(_QWORD *)&a4);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1E0C83610](a1, a2, a3, a4, *(_QWORD *)&a5);
}

uid_t geteuid(void)
{
  return MEMORY[0x1E0C83668]();
}

gid_t getgid(void)
{
  return MEMORY[0x1E0C83678]();
}

uid_t getuid(void)
{
  return MEMORY[0x1E0C83828]();
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1E0C83840](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

ptrdiff_t ivar_getOffset(Ivar v)
{
  return MEMORY[0x1E0DE7B30](v);
}

int kevent(int kq, const kevent *changelist, int nchanges, kevent *eventlist, int nevents, const timespec *timeout)
{
  return MEMORY[0x1E0C83A38](*(_QWORD *)&kq, changelist, *(_QWORD *)&nchanges, eventlist, *(_QWORD *)&nevents, timeout);
}

int kqueue(void)
{
  return MEMORY[0x1E0C83A68]();
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x1E0C83B88](path, namebuff, size, *(_QWORD *)&options);
}

float log2f(float a1)
{
  float result;

  MEMORY[0x1E0C83BF0](a1);
  return result;
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C83C40](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

void objc_moveWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7D18](to, from);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E68](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7FE0](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x1E0DE8000](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1E0C844C0](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1E0C84920](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1E0C84928](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1E0C84930](log, ptr);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_variant_has_internal_ui()
{
  return MEMORY[0x1E0C84A00]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x1E0C84E08]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E40](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1E0C85008](a1);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C85018](a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C85040](a1, a2);
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x1E0C850F0](path, name, *(_QWORD *)&options);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1E0C85138](a1);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1E0C853A0](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1E0C854E0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1E0C85538](__s, __charset);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85568](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

size_t strspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1E0C85608](__s, __charset);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

int unlinkat(int a1, const char *a2, int a3)
{
  return MEMORY[0x1E0C859C0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

void uuid_clear(uuid_t uu)
{
  MEMORY[0x1E0C85A00](uu);
}

char *__cdecl xattr_name_with_flags(const char *a1, xattr_flags_t a2)
{
  return (char *)MEMORY[0x1E0C85D60](a1, a2);
}

char *__cdecl xattr_name_without_flags(const char *a1)
{
  return (char *)MEMORY[0x1E0C85D68](a1);
}

int xattr_preserve_for_intent(const char *a1, xattr_operation_intent_t a2)
{
  return MEMORY[0x1E0C85D70](a1, *(_QWORD *)&a2);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FB0](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1E0C86048](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86260](xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862D0](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x1E0C86330](xdict, key, bytes, length);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x1E0C86398](xdict, key, value);
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
  MEMORY[0x1E0C863B0](xdict, key, uuid);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

